
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:19:20.114] plan(): Setting new future strategy stack:
[10:19:20.115] List of future strategies:
[10:19:20.115] 1. sequential:
[10:19:20.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.115]    - tweaked: FALSE
[10:19:20.115]    - call: future::plan("sequential")
[10:19:20.129] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[10:19:20.142] plan(): Setting new future strategy stack:
[10:19:20.143] List of future strategies:
[10:19:20.143] 1. sequential:
[10:19:20.143]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.143]    - tweaked: FALSE
[10:19:20.143]    - call: plan(sequential)
[10:19:20.154] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[10:19:20.154] future_mapply() ...
[10:19:20.155] Generating random seeds ...
[10:19:20.155] Generating random seed streams for 4 elements ...
[10:19:20.155] Generating random seed streams for 4 elements ... DONE
[10:19:20.155] Generating random seeds ... DONE
[10:19:20.155] Will set RNG state on exit: 10407, -1220327115, -616991854, 1882104135, -313492464, -1582070477, -1875332049
[10:19:20.156] Number of chunks: 1
[10:19:20.156] getGlobalsAndPackagesXApply() ...
[10:19:20.156]  - future.globals: TRUE
[10:19:20.157] getGlobalsAndPackages() ...
[10:19:20.157] Searching for globals...
[10:19:20.161] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:19:20.161] Searching for globals ... DONE
[10:19:20.162] Resolving globals: FALSE
[10:19:20.163] The total size of the 1 globals is 501 bytes (501 bytes)
[10:19:20.163] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[10:19:20.163] - globals: [1] ‘FUN’
[10:19:20.163] - packages: [1] ‘stats’
[10:19:20.163] getGlobalsAndPackages() ... DONE
[10:19:20.163]  - globals found/used: [n=1] ‘FUN’
[10:19:20.163]  - needed namespaces: [n=1] ‘stats’
[10:19:20.164] Finding globals ... DONE
[10:19:20.164] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.164] List of 2
[10:19:20.164]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:19:20.164]  $ MoreArgs     :List of 1
[10:19:20.164]   ..$ min: num 1
[10:19:20.164]  - attr(*, "where")=List of 2
[10:19:20.164]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.164]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.164]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.164]  - attr(*, "resolved")= logi FALSE
[10:19:20.164]  - attr(*, "total_size")= num NA
[10:19:20.171] Packages to be attached in all futures: [n=1] ‘stats’
[10:19:20.171] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.171] Number of futures (= number of chunks): 1
[10:19:20.172] Launching 1 futures (chunks) ...
[10:19:20.172] Chunk #1 of 1 ...
[10:19:20.172]  - Finding globals in '...' for chunk #1 ...
[10:19:20.172] getGlobalsAndPackages() ...
[10:19:20.172] Searching for globals...
[10:19:20.172] 
[10:19:20.173] Searching for globals ... DONE
[10:19:20.173] - globals: [0] <none>
[10:19:20.173] getGlobalsAndPackages() ... DONE
[10:19:20.173]    + additional globals found: [n=0] 
[10:19:20.173]    + additional namespaces needed: [n=0] 
[10:19:20.173]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.173]  - seeds: [4] <seeds>
[10:19:20.173]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.173] getGlobalsAndPackages() ...
[10:19:20.173] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.174] Resolving globals: FALSE
[10:19:20.174] The total size of the 5 globals is 990 bytes (990 bytes)
[10:19:20.174] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 990 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (196 bytes of class ‘list’) and ‘...future.seeds_ii’ (175 bytes of class ‘list’)
[10:19:20.175] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.175] - packages: [1] ‘stats’
[10:19:20.175] getGlobalsAndPackages() ... DONE
[10:19:20.175] run() for ‘Future’ ...
[10:19:20.175] - state: ‘created’
[10:19:20.176] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.176] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.176] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.176]   - Field: ‘label’
[10:19:20.176]   - Field: ‘local’
[10:19:20.176]   - Field: ‘owner’
[10:19:20.176]   - Field: ‘envir’
[10:19:20.177]   - Field: ‘packages’
[10:19:20.177]   - Field: ‘gc’
[10:19:20.177]   - Field: ‘conditions’
[10:19:20.177]   - Field: ‘expr’
[10:19:20.177]   - Field: ‘uuid’
[10:19:20.177]   - Field: ‘seed’
[10:19:20.177]   - Field: ‘version’
[10:19:20.177]   - Field: ‘result’
[10:19:20.177]   - Field: ‘asynchronous’
[10:19:20.177]   - Field: ‘calls’
[10:19:20.177]   - Field: ‘globals’
[10:19:20.177]   - Field: ‘stdout’
[10:19:20.178]   - Field: ‘earlySignal’
[10:19:20.178]   - Field: ‘lazy’
[10:19:20.178]   - Field: ‘state’
[10:19:20.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.178] - Launch lazy future ...
[10:19:20.178] Packages needed by the future expression (n = 1): ‘stats’
[10:19:20.179] Packages needed by future strategies (n = 0): <none>
[10:19:20.179] {
[10:19:20.179]     {
[10:19:20.179]         {
[10:19:20.179]             ...future.startTime <- base::Sys.time()
[10:19:20.179]             {
[10:19:20.179]                 {
[10:19:20.179]                   {
[10:19:20.179]                     {
[10:19:20.179]                       base::local({
[10:19:20.179]                         has_future <- base::requireNamespace("future", 
[10:19:20.179]                           quietly = TRUE)
[10:19:20.179]                         if (has_future) {
[10:19:20.179]                           ns <- base::getNamespace("future")
[10:19:20.179]                           version <- ns[[".package"]][["version"]]
[10:19:20.179]                           if (is.null(version)) 
[10:19:20.179]                             version <- utils::packageVersion("future")
[10:19:20.179]                         }
[10:19:20.179]                         else {
[10:19:20.179]                           version <- NULL
[10:19:20.179]                         }
[10:19:20.179]                         if (!has_future || version < "1.8.0") {
[10:19:20.179]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.179]                             "", base::R.version$version.string), 
[10:19:20.179]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:20.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.179]                               "release", "version")], collapse = " "), 
[10:19:20.179]                             hostname = base::Sys.info()[["nodename"]])
[10:19:20.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.179]                             info)
[10:19:20.179]                           info <- base::paste(info, collapse = "; ")
[10:19:20.179]                           if (!has_future) {
[10:19:20.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.179]                               info)
[10:19:20.179]                           }
[10:19:20.179]                           else {
[10:19:20.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.179]                               info, version)
[10:19:20.179]                           }
[10:19:20.179]                           base::stop(msg)
[10:19:20.179]                         }
[10:19:20.179]                       })
[10:19:20.179]                     }
[10:19:20.179]                     base::local({
[10:19:20.179]                       for (pkg in "stats") {
[10:19:20.179]                         base::loadNamespace(pkg)
[10:19:20.179]                         base::library(pkg, character.only = TRUE)
[10:19:20.179]                       }
[10:19:20.179]                     })
[10:19:20.179]                   }
[10:19:20.179]                   ...future.strategy.old <- future::plan("list")
[10:19:20.179]                   options(future.plan = NULL)
[10:19:20.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.179]                 }
[10:19:20.179]                 ...future.workdir <- getwd()
[10:19:20.179]             }
[10:19:20.179]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.179]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.179]         }
[10:19:20.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.179]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.179]             base::names(...future.oldOptions))
[10:19:20.179]     }
[10:19:20.179]     if (FALSE) {
[10:19:20.179]     }
[10:19:20.179]     else {
[10:19:20.179]         if (TRUE) {
[10:19:20.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.179]                 open = "w")
[10:19:20.179]         }
[10:19:20.179]         else {
[10:19:20.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.179]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.179]         }
[10:19:20.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.179]             base::sink(type = "output", split = FALSE)
[10:19:20.179]             base::close(...future.stdout)
[10:19:20.179]         }, add = TRUE)
[10:19:20.179]     }
[10:19:20.179]     ...future.frame <- base::sys.nframe()
[10:19:20.179]     ...future.conditions <- base::list()
[10:19:20.179]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.179]     if (FALSE) {
[10:19:20.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.179]     }
[10:19:20.179]     ...future.result <- base::tryCatch({
[10:19:20.179]         base::withCallingHandlers({
[10:19:20.179]             ...future.value <- base::withVisible(base::local({
[10:19:20.179]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.179]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.179]                   ...future.globals.maxSize)) {
[10:19:20.179]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.179]                   on.exit(options(oopts), add = TRUE)
[10:19:20.179]                 }
[10:19:20.179]                 {
[10:19:20.179]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:20.179]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:20.179]                       envir = globalenv(), inherits = FALSE)
[10:19:20.179]                     ...future.FUN(...)
[10:19:20.179]                   }
[10:19:20.179]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:20.179]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:20.179]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.179]                     USE.NAMES = FALSE)
[10:19:20.179]                   do.call(mapply, args = args)
[10:19:20.179]                 }
[10:19:20.179]             }))
[10:19:20.179]             future::FutureResult(value = ...future.value$value, 
[10:19:20.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.179]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.179]                     ...future.globalenv.names))
[10:19:20.179]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.179]         }, condition = base::local({
[10:19:20.179]             c <- base::c
[10:19:20.179]             inherits <- base::inherits
[10:19:20.179]             invokeRestart <- base::invokeRestart
[10:19:20.179]             length <- base::length
[10:19:20.179]             list <- base::list
[10:19:20.179]             seq.int <- base::seq.int
[10:19:20.179]             signalCondition <- base::signalCondition
[10:19:20.179]             sys.calls <- base::sys.calls
[10:19:20.179]             `[[` <- base::`[[`
[10:19:20.179]             `+` <- base::`+`
[10:19:20.179]             `<<-` <- base::`<<-`
[10:19:20.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.179]                   3L)]
[10:19:20.179]             }
[10:19:20.179]             function(cond) {
[10:19:20.179]                 is_error <- inherits(cond, "error")
[10:19:20.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.179]                   NULL)
[10:19:20.179]                 if (is_error) {
[10:19:20.179]                   sessionInformation <- function() {
[10:19:20.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.179]                       search = base::search(), system = base::Sys.info())
[10:19:20.179]                   }
[10:19:20.179]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.179]                     cond$call), session = sessionInformation(), 
[10:19:20.179]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.179]                   signalCondition(cond)
[10:19:20.179]                 }
[10:19:20.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.179]                 "immediateCondition"))) {
[10:19:20.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.179]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.179]                   if (TRUE && !signal) {
[10:19:20.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.179]                     {
[10:19:20.179]                       inherits <- base::inherits
[10:19:20.179]                       invokeRestart <- base::invokeRestart
[10:19:20.179]                       is.null <- base::is.null
[10:19:20.179]                       muffled <- FALSE
[10:19:20.179]                       if (inherits(cond, "message")) {
[10:19:20.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.179]                         if (muffled) 
[10:19:20.179]                           invokeRestart("muffleMessage")
[10:19:20.179]                       }
[10:19:20.179]                       else if (inherits(cond, "warning")) {
[10:19:20.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.179]                         if (muffled) 
[10:19:20.179]                           invokeRestart("muffleWarning")
[10:19:20.179]                       }
[10:19:20.179]                       else if (inherits(cond, "condition")) {
[10:19:20.179]                         if (!is.null(pattern)) {
[10:19:20.179]                           computeRestarts <- base::computeRestarts
[10:19:20.179]                           grepl <- base::grepl
[10:19:20.179]                           restarts <- computeRestarts(cond)
[10:19:20.179]                           for (restart in restarts) {
[10:19:20.179]                             name <- restart$name
[10:19:20.179]                             if (is.null(name)) 
[10:19:20.179]                               next
[10:19:20.179]                             if (!grepl(pattern, name)) 
[10:19:20.179]                               next
[10:19:20.179]                             invokeRestart(restart)
[10:19:20.179]                             muffled <- TRUE
[10:19:20.179]                             break
[10:19:20.179]                           }
[10:19:20.179]                         }
[10:19:20.179]                       }
[10:19:20.179]                       invisible(muffled)
[10:19:20.179]                     }
[10:19:20.179]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.179]                   }
[10:19:20.179]                 }
[10:19:20.179]                 else {
[10:19:20.179]                   if (TRUE) {
[10:19:20.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.179]                     {
[10:19:20.179]                       inherits <- base::inherits
[10:19:20.179]                       invokeRestart <- base::invokeRestart
[10:19:20.179]                       is.null <- base::is.null
[10:19:20.179]                       muffled <- FALSE
[10:19:20.179]                       if (inherits(cond, "message")) {
[10:19:20.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.179]                         if (muffled) 
[10:19:20.179]                           invokeRestart("muffleMessage")
[10:19:20.179]                       }
[10:19:20.179]                       else if (inherits(cond, "warning")) {
[10:19:20.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.179]                         if (muffled) 
[10:19:20.179]                           invokeRestart("muffleWarning")
[10:19:20.179]                       }
[10:19:20.179]                       else if (inherits(cond, "condition")) {
[10:19:20.179]                         if (!is.null(pattern)) {
[10:19:20.179]                           computeRestarts <- base::computeRestarts
[10:19:20.179]                           grepl <- base::grepl
[10:19:20.179]                           restarts <- computeRestarts(cond)
[10:19:20.179]                           for (restart in restarts) {
[10:19:20.179]                             name <- restart$name
[10:19:20.179]                             if (is.null(name)) 
[10:19:20.179]                               next
[10:19:20.179]                             if (!grepl(pattern, name)) 
[10:19:20.179]                               next
[10:19:20.179]                             invokeRestart(restart)
[10:19:20.179]                             muffled <- TRUE
[10:19:20.179]                             break
[10:19:20.179]                           }
[10:19:20.179]                         }
[10:19:20.179]                       }
[10:19:20.179]                       invisible(muffled)
[10:19:20.179]                     }
[10:19:20.179]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.179]                   }
[10:19:20.179]                 }
[10:19:20.179]             }
[10:19:20.179]         }))
[10:19:20.179]     }, error = function(ex) {
[10:19:20.179]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.179]                 ...future.rng), started = ...future.startTime, 
[10:19:20.179]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.179]             version = "1.8"), class = "FutureResult")
[10:19:20.179]     }, finally = {
[10:19:20.179]         if (!identical(...future.workdir, getwd())) 
[10:19:20.179]             setwd(...future.workdir)
[10:19:20.179]         {
[10:19:20.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.179]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.179]             }
[10:19:20.179]             base::options(...future.oldOptions)
[10:19:20.179]             if (.Platform$OS.type == "windows") {
[10:19:20.179]                 old_names <- names(...future.oldEnvVars)
[10:19:20.179]                 envs <- base::Sys.getenv()
[10:19:20.179]                 names <- names(envs)
[10:19:20.179]                 common <- intersect(names, old_names)
[10:19:20.179]                 added <- setdiff(names, old_names)
[10:19:20.179]                 removed <- setdiff(old_names, names)
[10:19:20.179]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.179]                   envs[common]]
[10:19:20.179]                 NAMES <- toupper(changed)
[10:19:20.179]                 args <- list()
[10:19:20.179]                 for (kk in seq_along(NAMES)) {
[10:19:20.179]                   name <- changed[[kk]]
[10:19:20.179]                   NAME <- NAMES[[kk]]
[10:19:20.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.179]                     next
[10:19:20.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.179]                 }
[10:19:20.179]                 NAMES <- toupper(added)
[10:19:20.179]                 for (kk in seq_along(NAMES)) {
[10:19:20.179]                   name <- added[[kk]]
[10:19:20.179]                   NAME <- NAMES[[kk]]
[10:19:20.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.179]                     next
[10:19:20.179]                   args[[name]] <- ""
[10:19:20.179]                 }
[10:19:20.179]                 NAMES <- toupper(removed)
[10:19:20.179]                 for (kk in seq_along(NAMES)) {
[10:19:20.179]                   name <- removed[[kk]]
[10:19:20.179]                   NAME <- NAMES[[kk]]
[10:19:20.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.179]                     next
[10:19:20.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.179]                 }
[10:19:20.179]                 if (length(args) > 0) 
[10:19:20.179]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.179]             }
[10:19:20.179]             else {
[10:19:20.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.179]             }
[10:19:20.179]             {
[10:19:20.179]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.179]                   0L) {
[10:19:20.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.179]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.179]                   base::options(opts)
[10:19:20.179]                 }
[10:19:20.179]                 {
[10:19:20.179]                   {
[10:19:20.179]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.179]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.179]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.179]                       inherits = FALSE)
[10:19:20.179]                     NULL
[10:19:20.179]                   }
[10:19:20.179]                   options(future.plan = NULL)
[10:19:20.179]                   if (is.na(NA_character_)) 
[10:19:20.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.179]                     .init = FALSE)
[10:19:20.179]                 }
[10:19:20.179]             }
[10:19:20.179]         }
[10:19:20.179]     })
[10:19:20.179]     if (TRUE) {
[10:19:20.179]         base::sink(type = "output", split = FALSE)
[10:19:20.179]         if (TRUE) {
[10:19:20.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.179]         }
[10:19:20.179]         else {
[10:19:20.179]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.179]         }
[10:19:20.179]         base::close(...future.stdout)
[10:19:20.179]         ...future.stdout <- NULL
[10:19:20.179]     }
[10:19:20.179]     ...future.result$conditions <- ...future.conditions
[10:19:20.179]     ...future.result$finished <- base::Sys.time()
[10:19:20.179]     ...future.result
[10:19:20.179] }
[10:19:20.181] assign_globals() ...
[10:19:20.181] List of 5
[10:19:20.181]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:19:20.181]  $ MoreArgs                 :List of 1
[10:19:20.181]   ..$ min: num 1
[10:19:20.181]  $ ...future.elements_ii    :List of 2
[10:19:20.181]   ..$ n  :List of 4
[10:19:20.181]   .. ..$ : int 1
[10:19:20.181]   .. ..$ : int 2
[10:19:20.181]   .. ..$ : int 3
[10:19:20.181]   .. ..$ : int 4
[10:19:20.181]   ..$ max:List of 4
[10:19:20.181]   .. ..$ : int 2
[10:19:20.181]   .. ..$ : int 3
[10:19:20.181]   .. ..$ : int 4
[10:19:20.181]   .. ..$ : int 5
[10:19:20.181]  $ ...future.seeds_ii       :List of 4
[10:19:20.181]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:19:20.181]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:19:20.181]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[10:19:20.181]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[10:19:20.181]  $ ...future.globals.maxSize: NULL
[10:19:20.181]  - attr(*, "where")=List of 5
[10:19:20.181]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.181]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.181]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.181]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.181]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.181]  - attr(*, "resolved")= logi FALSE
[10:19:20.181]  - attr(*, "total_size")= num 990
[10:19:20.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.181]  - attr(*, "already-done")= logi TRUE
[10:19:20.189] - copied ‘...future.FUN’ to environment
[10:19:20.190] - copied ‘MoreArgs’ to environment
[10:19:20.190] - copied ‘...future.elements_ii’ to environment
[10:19:20.190] - copied ‘...future.seeds_ii’ to environment
[10:19:20.190] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.190] assign_globals() ... done
[10:19:20.190] plan(): Setting new future strategy stack:
[10:19:20.190] List of future strategies:
[10:19:20.190] 1. sequential:
[10:19:20.190]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.190]    - tweaked: FALSE
[10:19:20.190]    - call: NULL
[10:19:20.191] plan(): nbrOfWorkers() = 1
[10:19:20.192] plan(): Setting new future strategy stack:
[10:19:20.192] List of future strategies:
[10:19:20.192] 1. sequential:
[10:19:20.192]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.192]    - tweaked: FALSE
[10:19:20.192]    - call: plan(sequential)
[10:19:20.193] plan(): nbrOfWorkers() = 1
[10:19:20.193] SequentialFuture started (and completed)
[10:19:20.193] - Launch lazy future ... done
[10:19:20.193] run() for ‘SequentialFuture’ ... done
[10:19:20.193] Created future:
[10:19:20.194] SequentialFuture:
[10:19:20.194] Label: ‘future_mapply-1’
[10:19:20.194] Expression:
[10:19:20.194] {
[10:19:20.194]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.194]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.194]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.194]         on.exit(options(oopts), add = TRUE)
[10:19:20.194]     }
[10:19:20.194]     {
[10:19:20.194]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:20.194]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:20.194]                 inherits = FALSE)
[10:19:20.194]             ...future.FUN(...)
[10:19:20.194]         }
[10:19:20.194]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:20.194]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:20.194]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.194]         do.call(mapply, args = args)
[10:19:20.194]     }
[10:19:20.194] }
[10:19:20.194] Lazy evaluation: FALSE
[10:19:20.194] Asynchronous evaluation: FALSE
[10:19:20.194] Local evaluation: TRUE
[10:19:20.194] Environment: R_GlobalEnv
[10:19:20.194] Capture standard output: TRUE
[10:19:20.194] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.194] Globals: 5 objects totaling 990 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 196 bytes, list ‘...future.seeds_ii’ of 175 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.194] Packages: 1 packages (‘stats’)
[10:19:20.194] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:20.194] Resolved: TRUE
[10:19:20.194] Value: 143 bytes of class ‘list’
[10:19:20.194] Early signaling: FALSE
[10:19:20.194] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.194] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.195] Chunk #1 of 1 ... DONE
[10:19:20.195] Launching 1 futures (chunks) ... DONE
[10:19:20.195] Resolving 1 futures (chunks) ...
[10:19:20.195] resolve() on list ...
[10:19:20.195]  recursive: 0
[10:19:20.196]  length: 1
[10:19:20.196] 
[10:19:20.196] resolved() for ‘SequentialFuture’ ...
[10:19:20.196] - state: ‘finished’
[10:19:20.196] - run: TRUE
[10:19:20.196] - result: ‘FutureResult’
[10:19:20.196] resolved() for ‘SequentialFuture’ ... done
[10:19:20.196] Future #1
[10:19:20.198] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.199] - nx: 1
[10:19:20.199] - relay: TRUE
[10:19:20.199] - stdout: TRUE
[10:19:20.199] - signal: TRUE
[10:19:20.199] - resignal: FALSE
[10:19:20.199] - force: TRUE
[10:19:20.199] - relayed: [n=1] FALSE
[10:19:20.199] - queued futures: [n=1] FALSE
[10:19:20.199]  - until=1
[10:19:20.199]  - relaying element #1
[10:19:20.199] - relayed: [n=1] TRUE
[10:19:20.200] - queued futures: [n=1] TRUE
[10:19:20.200] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.200]  length: 0 (resolved future 1)
[10:19:20.200] Relaying remaining futures
[10:19:20.200] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.200] - nx: 1
[10:19:20.200] - relay: TRUE
[10:19:20.200] - stdout: TRUE
[10:19:20.200] - signal: TRUE
[10:19:20.200] - resignal: FALSE
[10:19:20.200] - force: TRUE
[10:19:20.201] - relayed: [n=1] TRUE
[10:19:20.201] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.201] - relayed: [n=1] TRUE
[10:19:20.201] - queued futures: [n=1] TRUE
[10:19:20.201] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.201] resolve() on list ... DONE
[10:19:20.201]  - Number of value chunks collected: 1
[10:19:20.201] Resolving 1 futures (chunks) ... DONE
[10:19:20.201] Reducing values from 1 chunks ...
[10:19:20.201]  - Number of values collected after concatenation: 4
[10:19:20.201]  - Number of values expected: 4
[10:19:20.202] Reducing values from 1 chunks ... DONE
[10:19:20.202] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:19:20.351] plan(): Setting new future strategy stack:
[10:19:20.351] List of future strategies:
[10:19:20.351] 1. sequential:
[10:19:20.351]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.351]    - tweaked: FALSE
[10:19:20.351]    - call: plan(strategy)
[10:19:20.353] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[10:19:20.353] future_mapply() ...
[10:19:20.353] Number of chunks: 1
[10:19:20.353] getGlobalsAndPackagesXApply() ...
[10:19:20.353]  - future.globals: TRUE
[10:19:20.354] getGlobalsAndPackages() ...
[10:19:20.354] Searching for globals...
[10:19:20.354] - globals found: [1] ‘FUN’
[10:19:20.354] Searching for globals ... DONE
[10:19:20.354] Resolving globals: FALSE
[10:19:20.355] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:20.355] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:20.355] - globals: [1] ‘FUN’
[10:19:20.355] 
[10:19:20.355] getGlobalsAndPackages() ... DONE
[10:19:20.355]  - globals found/used: [n=1] ‘FUN’
[10:19:20.355]  - needed namespaces: [n=0] 
[10:19:20.355] Finding globals ... DONE
[10:19:20.356] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.356] List of 2
[10:19:20.356]  $ ...future.FUN:function (x, ...)  
[10:19:20.356]  $ MoreArgs     : NULL
[10:19:20.356]  - attr(*, "where")=List of 2
[10:19:20.356]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.356]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.356]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.356]  - attr(*, "resolved")= logi FALSE
[10:19:20.356]  - attr(*, "total_size")= num NA
[10:19:20.358] Packages to be attached in all futures: [n=0] 
[10:19:20.358] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.358] Number of futures (= number of chunks): 1
[10:19:20.359] Launching 1 futures (chunks) ...
[10:19:20.359] Chunk #1 of 1 ...
[10:19:20.359]  - Finding globals in '...' for chunk #1 ...
[10:19:20.359] getGlobalsAndPackages() ...
[10:19:20.359] Searching for globals...
[10:19:20.359] 
[10:19:20.359] Searching for globals ... DONE
[10:19:20.359] - globals: [0] <none>
[10:19:20.360] getGlobalsAndPackages() ... DONE
[10:19:20.360]    + additional globals found: [n=0] 
[10:19:20.360]    + additional namespaces needed: [n=0] 
[10:19:20.360]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.360]  - seeds: <none>
[10:19:20.360]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.360] getGlobalsAndPackages() ...
[10:19:20.360] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.360] Resolving globals: FALSE
[10:19:20.361] The total size of the 5 globals is 258 bytes (258 bytes)
[10:19:20.361] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 258 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (143 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.361] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.361] 
[10:19:20.361] getGlobalsAndPackages() ... DONE
[10:19:20.362] run() for ‘Future’ ...
[10:19:20.362] - state: ‘created’
[10:19:20.362] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.362] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.362] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.362]   - Field: ‘label’
[10:19:20.362]   - Field: ‘local’
[10:19:20.362]   - Field: ‘owner’
[10:19:20.362]   - Field: ‘envir’
[10:19:20.363]   - Field: ‘packages’
[10:19:20.363]   - Field: ‘gc’
[10:19:20.363]   - Field: ‘conditions’
[10:19:20.363]   - Field: ‘expr’
[10:19:20.363]   - Field: ‘uuid’
[10:19:20.363]   - Field: ‘seed’
[10:19:20.363]   - Field: ‘version’
[10:19:20.363]   - Field: ‘result’
[10:19:20.363]   - Field: ‘asynchronous’
[10:19:20.363]   - Field: ‘calls’
[10:19:20.363]   - Field: ‘globals’
[10:19:20.363]   - Field: ‘stdout’
[10:19:20.363]   - Field: ‘earlySignal’
[10:19:20.364]   - Field: ‘lazy’
[10:19:20.364]   - Field: ‘state’
[10:19:20.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.364] - Launch lazy future ...
[10:19:20.364] Packages needed by the future expression (n = 0): <none>
[10:19:20.364] Packages needed by future strategies (n = 0): <none>
[10:19:20.364] {
[10:19:20.364]     {
[10:19:20.364]         {
[10:19:20.364]             ...future.startTime <- base::Sys.time()
[10:19:20.364]             {
[10:19:20.364]                 {
[10:19:20.364]                   {
[10:19:20.364]                     base::local({
[10:19:20.364]                       has_future <- base::requireNamespace("future", 
[10:19:20.364]                         quietly = TRUE)
[10:19:20.364]                       if (has_future) {
[10:19:20.364]                         ns <- base::getNamespace("future")
[10:19:20.364]                         version <- ns[[".package"]][["version"]]
[10:19:20.364]                         if (is.null(version)) 
[10:19:20.364]                           version <- utils::packageVersion("future")
[10:19:20.364]                       }
[10:19:20.364]                       else {
[10:19:20.364]                         version <- NULL
[10:19:20.364]                       }
[10:19:20.364]                       if (!has_future || version < "1.8.0") {
[10:19:20.364]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.364]                           "", base::R.version$version.string), 
[10:19:20.364]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.364]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.364]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.364]                             "release", "version")], collapse = " "), 
[10:19:20.364]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.364]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.364]                           info)
[10:19:20.364]                         info <- base::paste(info, collapse = "; ")
[10:19:20.364]                         if (!has_future) {
[10:19:20.364]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.364]                             info)
[10:19:20.364]                         }
[10:19:20.364]                         else {
[10:19:20.364]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.364]                             info, version)
[10:19:20.364]                         }
[10:19:20.364]                         base::stop(msg)
[10:19:20.364]                       }
[10:19:20.364]                     })
[10:19:20.364]                   }
[10:19:20.364]                   ...future.strategy.old <- future::plan("list")
[10:19:20.364]                   options(future.plan = NULL)
[10:19:20.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.364]                 }
[10:19:20.364]                 ...future.workdir <- getwd()
[10:19:20.364]             }
[10:19:20.364]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.364]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.364]         }
[10:19:20.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.364]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.364]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.364]             base::names(...future.oldOptions))
[10:19:20.364]     }
[10:19:20.364]     if (FALSE) {
[10:19:20.364]     }
[10:19:20.364]     else {
[10:19:20.364]         if (TRUE) {
[10:19:20.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.364]                 open = "w")
[10:19:20.364]         }
[10:19:20.364]         else {
[10:19:20.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.364]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.364]         }
[10:19:20.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.364]             base::sink(type = "output", split = FALSE)
[10:19:20.364]             base::close(...future.stdout)
[10:19:20.364]         }, add = TRUE)
[10:19:20.364]     }
[10:19:20.364]     ...future.frame <- base::sys.nframe()
[10:19:20.364]     ...future.conditions <- base::list()
[10:19:20.364]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.364]     if (FALSE) {
[10:19:20.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.364]     }
[10:19:20.364]     ...future.result <- base::tryCatch({
[10:19:20.364]         base::withCallingHandlers({
[10:19:20.364]             ...future.value <- base::withVisible(base::local({
[10:19:20.364]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.364]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.364]                   ...future.globals.maxSize)) {
[10:19:20.364]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.364]                   on.exit(options(oopts), add = TRUE)
[10:19:20.364]                 }
[10:19:20.364]                 {
[10:19:20.364]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.364]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.364]                     USE.NAMES = FALSE)
[10:19:20.364]                   do.call(mapply, args = args)
[10:19:20.364]                 }
[10:19:20.364]             }))
[10:19:20.364]             future::FutureResult(value = ...future.value$value, 
[10:19:20.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.364]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.364]                     ...future.globalenv.names))
[10:19:20.364]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.364]         }, condition = base::local({
[10:19:20.364]             c <- base::c
[10:19:20.364]             inherits <- base::inherits
[10:19:20.364]             invokeRestart <- base::invokeRestart
[10:19:20.364]             length <- base::length
[10:19:20.364]             list <- base::list
[10:19:20.364]             seq.int <- base::seq.int
[10:19:20.364]             signalCondition <- base::signalCondition
[10:19:20.364]             sys.calls <- base::sys.calls
[10:19:20.364]             `[[` <- base::`[[`
[10:19:20.364]             `+` <- base::`+`
[10:19:20.364]             `<<-` <- base::`<<-`
[10:19:20.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.364]                   3L)]
[10:19:20.364]             }
[10:19:20.364]             function(cond) {
[10:19:20.364]                 is_error <- inherits(cond, "error")
[10:19:20.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.364]                   NULL)
[10:19:20.364]                 if (is_error) {
[10:19:20.364]                   sessionInformation <- function() {
[10:19:20.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.364]                       search = base::search(), system = base::Sys.info())
[10:19:20.364]                   }
[10:19:20.364]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.364]                     cond$call), session = sessionInformation(), 
[10:19:20.364]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.364]                   signalCondition(cond)
[10:19:20.364]                 }
[10:19:20.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.364]                 "immediateCondition"))) {
[10:19:20.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.364]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.364]                   if (TRUE && !signal) {
[10:19:20.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.364]                     {
[10:19:20.364]                       inherits <- base::inherits
[10:19:20.364]                       invokeRestart <- base::invokeRestart
[10:19:20.364]                       is.null <- base::is.null
[10:19:20.364]                       muffled <- FALSE
[10:19:20.364]                       if (inherits(cond, "message")) {
[10:19:20.364]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.364]                         if (muffled) 
[10:19:20.364]                           invokeRestart("muffleMessage")
[10:19:20.364]                       }
[10:19:20.364]                       else if (inherits(cond, "warning")) {
[10:19:20.364]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.364]                         if (muffled) 
[10:19:20.364]                           invokeRestart("muffleWarning")
[10:19:20.364]                       }
[10:19:20.364]                       else if (inherits(cond, "condition")) {
[10:19:20.364]                         if (!is.null(pattern)) {
[10:19:20.364]                           computeRestarts <- base::computeRestarts
[10:19:20.364]                           grepl <- base::grepl
[10:19:20.364]                           restarts <- computeRestarts(cond)
[10:19:20.364]                           for (restart in restarts) {
[10:19:20.364]                             name <- restart$name
[10:19:20.364]                             if (is.null(name)) 
[10:19:20.364]                               next
[10:19:20.364]                             if (!grepl(pattern, name)) 
[10:19:20.364]                               next
[10:19:20.364]                             invokeRestart(restart)
[10:19:20.364]                             muffled <- TRUE
[10:19:20.364]                             break
[10:19:20.364]                           }
[10:19:20.364]                         }
[10:19:20.364]                       }
[10:19:20.364]                       invisible(muffled)
[10:19:20.364]                     }
[10:19:20.364]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.364]                   }
[10:19:20.364]                 }
[10:19:20.364]                 else {
[10:19:20.364]                   if (TRUE) {
[10:19:20.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.364]                     {
[10:19:20.364]                       inherits <- base::inherits
[10:19:20.364]                       invokeRestart <- base::invokeRestart
[10:19:20.364]                       is.null <- base::is.null
[10:19:20.364]                       muffled <- FALSE
[10:19:20.364]                       if (inherits(cond, "message")) {
[10:19:20.364]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.364]                         if (muffled) 
[10:19:20.364]                           invokeRestart("muffleMessage")
[10:19:20.364]                       }
[10:19:20.364]                       else if (inherits(cond, "warning")) {
[10:19:20.364]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.364]                         if (muffled) 
[10:19:20.364]                           invokeRestart("muffleWarning")
[10:19:20.364]                       }
[10:19:20.364]                       else if (inherits(cond, "condition")) {
[10:19:20.364]                         if (!is.null(pattern)) {
[10:19:20.364]                           computeRestarts <- base::computeRestarts
[10:19:20.364]                           grepl <- base::grepl
[10:19:20.364]                           restarts <- computeRestarts(cond)
[10:19:20.364]                           for (restart in restarts) {
[10:19:20.364]                             name <- restart$name
[10:19:20.364]                             if (is.null(name)) 
[10:19:20.364]                               next
[10:19:20.364]                             if (!grepl(pattern, name)) 
[10:19:20.364]                               next
[10:19:20.364]                             invokeRestart(restart)
[10:19:20.364]                             muffled <- TRUE
[10:19:20.364]                             break
[10:19:20.364]                           }
[10:19:20.364]                         }
[10:19:20.364]                       }
[10:19:20.364]                       invisible(muffled)
[10:19:20.364]                     }
[10:19:20.364]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.364]                   }
[10:19:20.364]                 }
[10:19:20.364]             }
[10:19:20.364]         }))
[10:19:20.364]     }, error = function(ex) {
[10:19:20.364]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.364]                 ...future.rng), started = ...future.startTime, 
[10:19:20.364]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.364]             version = "1.8"), class = "FutureResult")
[10:19:20.364]     }, finally = {
[10:19:20.364]         if (!identical(...future.workdir, getwd())) 
[10:19:20.364]             setwd(...future.workdir)
[10:19:20.364]         {
[10:19:20.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.364]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.364]             }
[10:19:20.364]             base::options(...future.oldOptions)
[10:19:20.364]             if (.Platform$OS.type == "windows") {
[10:19:20.364]                 old_names <- names(...future.oldEnvVars)
[10:19:20.364]                 envs <- base::Sys.getenv()
[10:19:20.364]                 names <- names(envs)
[10:19:20.364]                 common <- intersect(names, old_names)
[10:19:20.364]                 added <- setdiff(names, old_names)
[10:19:20.364]                 removed <- setdiff(old_names, names)
[10:19:20.364]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.364]                   envs[common]]
[10:19:20.364]                 NAMES <- toupper(changed)
[10:19:20.364]                 args <- list()
[10:19:20.364]                 for (kk in seq_along(NAMES)) {
[10:19:20.364]                   name <- changed[[kk]]
[10:19:20.364]                   NAME <- NAMES[[kk]]
[10:19:20.364]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.364]                     next
[10:19:20.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.364]                 }
[10:19:20.364]                 NAMES <- toupper(added)
[10:19:20.364]                 for (kk in seq_along(NAMES)) {
[10:19:20.364]                   name <- added[[kk]]
[10:19:20.364]                   NAME <- NAMES[[kk]]
[10:19:20.364]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.364]                     next
[10:19:20.364]                   args[[name]] <- ""
[10:19:20.364]                 }
[10:19:20.364]                 NAMES <- toupper(removed)
[10:19:20.364]                 for (kk in seq_along(NAMES)) {
[10:19:20.364]                   name <- removed[[kk]]
[10:19:20.364]                   NAME <- NAMES[[kk]]
[10:19:20.364]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.364]                     next
[10:19:20.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.364]                 }
[10:19:20.364]                 if (length(args) > 0) 
[10:19:20.364]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.364]             }
[10:19:20.364]             else {
[10:19:20.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.364]             }
[10:19:20.364]             {
[10:19:20.364]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.364]                   0L) {
[10:19:20.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.364]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.364]                   base::options(opts)
[10:19:20.364]                 }
[10:19:20.364]                 {
[10:19:20.364]                   {
[10:19:20.364]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.364]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.364]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.364]                       inherits = FALSE)
[10:19:20.364]                     NULL
[10:19:20.364]                   }
[10:19:20.364]                   options(future.plan = NULL)
[10:19:20.364]                   if (is.na(NA_character_)) 
[10:19:20.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.364]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.364]                     .init = FALSE)
[10:19:20.364]                 }
[10:19:20.364]             }
[10:19:20.364]         }
[10:19:20.364]     })
[10:19:20.364]     if (TRUE) {
[10:19:20.364]         base::sink(type = "output", split = FALSE)
[10:19:20.364]         if (TRUE) {
[10:19:20.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.364]         }
[10:19:20.364]         else {
[10:19:20.364]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.364]         }
[10:19:20.364]         base::close(...future.stdout)
[10:19:20.364]         ...future.stdout <- NULL
[10:19:20.364]     }
[10:19:20.364]     ...future.result$conditions <- ...future.conditions
[10:19:20.364]     ...future.result$finished <- base::Sys.time()
[10:19:20.364]     ...future.result
[10:19:20.364] }
[10:19:20.366] assign_globals() ...
[10:19:20.366] List of 5
[10:19:20.366]  $ ...future.FUN            :function (x, ...)  
[10:19:20.366]  $ MoreArgs                 : NULL
[10:19:20.366]  $ ...future.elements_ii    :List of 2
[10:19:20.366]   ..$ :List of 4
[10:19:20.366]   .. ..$ : int 1
[10:19:20.366]   .. ..$ : int 2
[10:19:20.366]   .. ..$ : int 3
[10:19:20.366]   .. ..$ : int 4
[10:19:20.366]   ..$ :List of 4
[10:19:20.366]   .. ..$ : int 4
[10:19:20.366]   .. ..$ : int 3
[10:19:20.366]   .. ..$ : int 2
[10:19:20.366]   .. ..$ : int 1
[10:19:20.366]  $ ...future.seeds_ii       : NULL
[10:19:20.366]  $ ...future.globals.maxSize: NULL
[10:19:20.366]  - attr(*, "where")=List of 5
[10:19:20.366]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.366]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.366]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.366]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.366]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.366]  - attr(*, "resolved")= logi FALSE
[10:19:20.366]  - attr(*, "total_size")= num 258
[10:19:20.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.366]  - attr(*, "already-done")= logi TRUE
[10:19:20.372] - copied ‘...future.FUN’ to environment
[10:19:20.373] - copied ‘MoreArgs’ to environment
[10:19:20.373] - copied ‘...future.elements_ii’ to environment
[10:19:20.373] - copied ‘...future.seeds_ii’ to environment
[10:19:20.373] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.373] assign_globals() ... done
[10:19:20.373] plan(): Setting new future strategy stack:
[10:19:20.373] List of future strategies:
[10:19:20.373] 1. sequential:
[10:19:20.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.373]    - tweaked: FALSE
[10:19:20.373]    - call: NULL
[10:19:20.374] plan(): nbrOfWorkers() = 1
[10:19:20.374] plan(): Setting new future strategy stack:
[10:19:20.375] List of future strategies:
[10:19:20.375] 1. sequential:
[10:19:20.375]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.375]    - tweaked: FALSE
[10:19:20.375]    - call: plan(strategy)
[10:19:20.375] plan(): nbrOfWorkers() = 1
[10:19:20.375] SequentialFuture started (and completed)
[10:19:20.375] - Launch lazy future ... done
[10:19:20.375] run() for ‘SequentialFuture’ ... done
[10:19:20.375] Created future:
[10:19:20.376] SequentialFuture:
[10:19:20.376] Label: ‘future_mapply-1’
[10:19:20.376] Expression:
[10:19:20.376] {
[10:19:20.376]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.376]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.376]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.376]         on.exit(options(oopts), add = TRUE)
[10:19:20.376]     }
[10:19:20.376]     {
[10:19:20.376]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.376]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.376]         do.call(mapply, args = args)
[10:19:20.376]     }
[10:19:20.376] }
[10:19:20.376] Lazy evaluation: FALSE
[10:19:20.376] Asynchronous evaluation: FALSE
[10:19:20.376] Local evaluation: TRUE
[10:19:20.376] Environment: R_GlobalEnv
[10:19:20.376] Capture standard output: TRUE
[10:19:20.376] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.376] Globals: 5 objects totaling 258 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 143 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.376] Packages: <none>
[10:19:20.376] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.376] Resolved: TRUE
[10:19:20.376] Value: 103 bytes of class ‘list’
[10:19:20.376] Early signaling: FALSE
[10:19:20.376] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.376] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.377] Chunk #1 of 1 ... DONE
[10:19:20.377] Launching 1 futures (chunks) ... DONE
[10:19:20.378] Resolving 1 futures (chunks) ...
[10:19:20.378] resolve() on list ...
[10:19:20.378]  recursive: 0
[10:19:20.378]  length: 1
[10:19:20.378] 
[10:19:20.378] resolved() for ‘SequentialFuture’ ...
[10:19:20.378] - state: ‘finished’
[10:19:20.378] - run: TRUE
[10:19:20.378] - result: ‘FutureResult’
[10:19:20.378] resolved() for ‘SequentialFuture’ ... done
[10:19:20.378] Future #1
[10:19:20.379] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.379] - nx: 1
[10:19:20.379] - relay: TRUE
[10:19:20.379] - stdout: TRUE
[10:19:20.379] - signal: TRUE
[10:19:20.379] - resignal: FALSE
[10:19:20.379] - force: TRUE
[10:19:20.379] - relayed: [n=1] FALSE
[10:19:20.379] - queued futures: [n=1] FALSE
[10:19:20.379]  - until=1
[10:19:20.379]  - relaying element #1
[10:19:20.379] - relayed: [n=1] TRUE
[10:19:20.380] - queued futures: [n=1] TRUE
[10:19:20.380] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.380]  length: 0 (resolved future 1)
[10:19:20.380] Relaying remaining futures
[10:19:20.380] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.380] - nx: 1
[10:19:20.380] - relay: TRUE
[10:19:20.380] - stdout: TRUE
[10:19:20.380] - signal: TRUE
[10:19:20.380] - resignal: FALSE
[10:19:20.380] - force: TRUE
[10:19:20.380] - relayed: [n=1] TRUE
[10:19:20.380] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.381] - relayed: [n=1] TRUE
[10:19:20.381] - queued futures: [n=1] TRUE
[10:19:20.381] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.381] resolve() on list ... DONE
[10:19:20.381]  - Number of value chunks collected: 1
[10:19:20.381] Resolving 1 futures (chunks) ... DONE
[10:19:20.381] Reducing values from 1 chunks ...
[10:19:20.381]  - Number of values collected after concatenation: 4
[10:19:20.381]  - Number of values expected: 4
[10:19:20.381] Reducing values from 1 chunks ... DONE
[10:19:20.381] future_mapply() ... DONE
[10:19:20.382] future_mapply() ...
[10:19:20.382] Number of chunks: 1
[10:19:20.382] getGlobalsAndPackagesXApply() ...
[10:19:20.382]  - future.globals: TRUE
[10:19:20.382] getGlobalsAndPackages() ...
[10:19:20.382] Searching for globals...
[10:19:20.383] - globals found: [1] ‘FUN’
[10:19:20.383] Searching for globals ... DONE
[10:19:20.383] Resolving globals: FALSE
[10:19:20.383] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:20.383] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:20.383] - globals: [1] ‘FUN’
[10:19:20.384] 
[10:19:20.384] getGlobalsAndPackages() ... DONE
[10:19:20.384]  - globals found/used: [n=1] ‘FUN’
[10:19:20.384]  - needed namespaces: [n=0] 
[10:19:20.384] Finding globals ... DONE
[10:19:20.384] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.384] List of 2
[10:19:20.384]  $ ...future.FUN:function (x, ...)  
[10:19:20.384]  $ MoreArgs     : NULL
[10:19:20.384]  - attr(*, "where")=List of 2
[10:19:20.384]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.384]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.384]  - attr(*, "resolved")= logi FALSE
[10:19:20.384]  - attr(*, "total_size")= num NA
[10:19:20.386] Packages to be attached in all futures: [n=0] 
[10:19:20.386] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.387] Number of futures (= number of chunks): 1
[10:19:20.387] Launching 1 futures (chunks) ...
[10:19:20.387] Chunk #1 of 1 ...
[10:19:20.387]  - Finding globals in '...' for chunk #1 ...
[10:19:20.387] getGlobalsAndPackages() ...
[10:19:20.387] Searching for globals...
[10:19:20.387] 
[10:19:20.387] Searching for globals ... DONE
[10:19:20.388] - globals: [0] <none>
[10:19:20.388] getGlobalsAndPackages() ... DONE
[10:19:20.388]    + additional globals found: [n=0] 
[10:19:20.388]    + additional namespaces needed: [n=0] 
[10:19:20.388]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.388]  - seeds: <none>
[10:19:20.388]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.388] getGlobalsAndPackages() ...
[10:19:20.388] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.388] Resolving globals: FALSE
[10:19:20.389] The total size of the 5 globals is 258 bytes (258 bytes)
[10:19:20.389] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 258 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (143 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.389] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.389] 
[10:19:20.389] getGlobalsAndPackages() ... DONE
[10:19:20.390] run() for ‘Future’ ...
[10:19:20.390] - state: ‘created’
[10:19:20.390] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.390] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.390] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.390]   - Field: ‘label’
[10:19:20.390]   - Field: ‘local’
[10:19:20.391]   - Field: ‘owner’
[10:19:20.391]   - Field: ‘envir’
[10:19:20.391]   - Field: ‘packages’
[10:19:20.391]   - Field: ‘gc’
[10:19:20.391]   - Field: ‘conditions’
[10:19:20.391]   - Field: ‘expr’
[10:19:20.391]   - Field: ‘uuid’
[10:19:20.391]   - Field: ‘seed’
[10:19:20.391]   - Field: ‘version’
[10:19:20.391]   - Field: ‘result’
[10:19:20.391]   - Field: ‘asynchronous’
[10:19:20.391]   - Field: ‘calls’
[10:19:20.392]   - Field: ‘globals’
[10:19:20.392]   - Field: ‘stdout’
[10:19:20.392]   - Field: ‘earlySignal’
[10:19:20.392]   - Field: ‘lazy’
[10:19:20.392]   - Field: ‘state’
[10:19:20.392] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.392] - Launch lazy future ...
[10:19:20.392] Packages needed by the future expression (n = 0): <none>
[10:19:20.392] Packages needed by future strategies (n = 0): <none>
[10:19:20.393] {
[10:19:20.393]     {
[10:19:20.393]         {
[10:19:20.393]             ...future.startTime <- base::Sys.time()
[10:19:20.393]             {
[10:19:20.393]                 {
[10:19:20.393]                   {
[10:19:20.393]                     base::local({
[10:19:20.393]                       has_future <- base::requireNamespace("future", 
[10:19:20.393]                         quietly = TRUE)
[10:19:20.393]                       if (has_future) {
[10:19:20.393]                         ns <- base::getNamespace("future")
[10:19:20.393]                         version <- ns[[".package"]][["version"]]
[10:19:20.393]                         if (is.null(version)) 
[10:19:20.393]                           version <- utils::packageVersion("future")
[10:19:20.393]                       }
[10:19:20.393]                       else {
[10:19:20.393]                         version <- NULL
[10:19:20.393]                       }
[10:19:20.393]                       if (!has_future || version < "1.8.0") {
[10:19:20.393]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.393]                           "", base::R.version$version.string), 
[10:19:20.393]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.393]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.393]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.393]                             "release", "version")], collapse = " "), 
[10:19:20.393]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.393]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.393]                           info)
[10:19:20.393]                         info <- base::paste(info, collapse = "; ")
[10:19:20.393]                         if (!has_future) {
[10:19:20.393]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.393]                             info)
[10:19:20.393]                         }
[10:19:20.393]                         else {
[10:19:20.393]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.393]                             info, version)
[10:19:20.393]                         }
[10:19:20.393]                         base::stop(msg)
[10:19:20.393]                       }
[10:19:20.393]                     })
[10:19:20.393]                   }
[10:19:20.393]                   ...future.strategy.old <- future::plan("list")
[10:19:20.393]                   options(future.plan = NULL)
[10:19:20.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.393]                 }
[10:19:20.393]                 ...future.workdir <- getwd()
[10:19:20.393]             }
[10:19:20.393]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.393]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.393]         }
[10:19:20.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.393]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.393]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.393]             base::names(...future.oldOptions))
[10:19:20.393]     }
[10:19:20.393]     if (FALSE) {
[10:19:20.393]     }
[10:19:20.393]     else {
[10:19:20.393]         if (TRUE) {
[10:19:20.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.393]                 open = "w")
[10:19:20.393]         }
[10:19:20.393]         else {
[10:19:20.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.393]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.393]         }
[10:19:20.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.393]             base::sink(type = "output", split = FALSE)
[10:19:20.393]             base::close(...future.stdout)
[10:19:20.393]         }, add = TRUE)
[10:19:20.393]     }
[10:19:20.393]     ...future.frame <- base::sys.nframe()
[10:19:20.393]     ...future.conditions <- base::list()
[10:19:20.393]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.393]     if (FALSE) {
[10:19:20.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.393]     }
[10:19:20.393]     ...future.result <- base::tryCatch({
[10:19:20.393]         base::withCallingHandlers({
[10:19:20.393]             ...future.value <- base::withVisible(base::local({
[10:19:20.393]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.393]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.393]                   ...future.globals.maxSize)) {
[10:19:20.393]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.393]                   on.exit(options(oopts), add = TRUE)
[10:19:20.393]                 }
[10:19:20.393]                 {
[10:19:20.393]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.393]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.393]                     USE.NAMES = FALSE)
[10:19:20.393]                   do.call(mapply, args = args)
[10:19:20.393]                 }
[10:19:20.393]             }))
[10:19:20.393]             future::FutureResult(value = ...future.value$value, 
[10:19:20.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.393]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.393]                     ...future.globalenv.names))
[10:19:20.393]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.393]         }, condition = base::local({
[10:19:20.393]             c <- base::c
[10:19:20.393]             inherits <- base::inherits
[10:19:20.393]             invokeRestart <- base::invokeRestart
[10:19:20.393]             length <- base::length
[10:19:20.393]             list <- base::list
[10:19:20.393]             seq.int <- base::seq.int
[10:19:20.393]             signalCondition <- base::signalCondition
[10:19:20.393]             sys.calls <- base::sys.calls
[10:19:20.393]             `[[` <- base::`[[`
[10:19:20.393]             `+` <- base::`+`
[10:19:20.393]             `<<-` <- base::`<<-`
[10:19:20.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.393]                   3L)]
[10:19:20.393]             }
[10:19:20.393]             function(cond) {
[10:19:20.393]                 is_error <- inherits(cond, "error")
[10:19:20.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.393]                   NULL)
[10:19:20.393]                 if (is_error) {
[10:19:20.393]                   sessionInformation <- function() {
[10:19:20.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.393]                       search = base::search(), system = base::Sys.info())
[10:19:20.393]                   }
[10:19:20.393]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.393]                     cond$call), session = sessionInformation(), 
[10:19:20.393]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.393]                   signalCondition(cond)
[10:19:20.393]                 }
[10:19:20.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.393]                 "immediateCondition"))) {
[10:19:20.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.393]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.393]                   if (TRUE && !signal) {
[10:19:20.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.393]                     {
[10:19:20.393]                       inherits <- base::inherits
[10:19:20.393]                       invokeRestart <- base::invokeRestart
[10:19:20.393]                       is.null <- base::is.null
[10:19:20.393]                       muffled <- FALSE
[10:19:20.393]                       if (inherits(cond, "message")) {
[10:19:20.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.393]                         if (muffled) 
[10:19:20.393]                           invokeRestart("muffleMessage")
[10:19:20.393]                       }
[10:19:20.393]                       else if (inherits(cond, "warning")) {
[10:19:20.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.393]                         if (muffled) 
[10:19:20.393]                           invokeRestart("muffleWarning")
[10:19:20.393]                       }
[10:19:20.393]                       else if (inherits(cond, "condition")) {
[10:19:20.393]                         if (!is.null(pattern)) {
[10:19:20.393]                           computeRestarts <- base::computeRestarts
[10:19:20.393]                           grepl <- base::grepl
[10:19:20.393]                           restarts <- computeRestarts(cond)
[10:19:20.393]                           for (restart in restarts) {
[10:19:20.393]                             name <- restart$name
[10:19:20.393]                             if (is.null(name)) 
[10:19:20.393]                               next
[10:19:20.393]                             if (!grepl(pattern, name)) 
[10:19:20.393]                               next
[10:19:20.393]                             invokeRestart(restart)
[10:19:20.393]                             muffled <- TRUE
[10:19:20.393]                             break
[10:19:20.393]                           }
[10:19:20.393]                         }
[10:19:20.393]                       }
[10:19:20.393]                       invisible(muffled)
[10:19:20.393]                     }
[10:19:20.393]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.393]                   }
[10:19:20.393]                 }
[10:19:20.393]                 else {
[10:19:20.393]                   if (TRUE) {
[10:19:20.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.393]                     {
[10:19:20.393]                       inherits <- base::inherits
[10:19:20.393]                       invokeRestart <- base::invokeRestart
[10:19:20.393]                       is.null <- base::is.null
[10:19:20.393]                       muffled <- FALSE
[10:19:20.393]                       if (inherits(cond, "message")) {
[10:19:20.393]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.393]                         if (muffled) 
[10:19:20.393]                           invokeRestart("muffleMessage")
[10:19:20.393]                       }
[10:19:20.393]                       else if (inherits(cond, "warning")) {
[10:19:20.393]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.393]                         if (muffled) 
[10:19:20.393]                           invokeRestart("muffleWarning")
[10:19:20.393]                       }
[10:19:20.393]                       else if (inherits(cond, "condition")) {
[10:19:20.393]                         if (!is.null(pattern)) {
[10:19:20.393]                           computeRestarts <- base::computeRestarts
[10:19:20.393]                           grepl <- base::grepl
[10:19:20.393]                           restarts <- computeRestarts(cond)
[10:19:20.393]                           for (restart in restarts) {
[10:19:20.393]                             name <- restart$name
[10:19:20.393]                             if (is.null(name)) 
[10:19:20.393]                               next
[10:19:20.393]                             if (!grepl(pattern, name)) 
[10:19:20.393]                               next
[10:19:20.393]                             invokeRestart(restart)
[10:19:20.393]                             muffled <- TRUE
[10:19:20.393]                             break
[10:19:20.393]                           }
[10:19:20.393]                         }
[10:19:20.393]                       }
[10:19:20.393]                       invisible(muffled)
[10:19:20.393]                     }
[10:19:20.393]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.393]                   }
[10:19:20.393]                 }
[10:19:20.393]             }
[10:19:20.393]         }))
[10:19:20.393]     }, error = function(ex) {
[10:19:20.393]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.393]                 ...future.rng), started = ...future.startTime, 
[10:19:20.393]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.393]             version = "1.8"), class = "FutureResult")
[10:19:20.393]     }, finally = {
[10:19:20.393]         if (!identical(...future.workdir, getwd())) 
[10:19:20.393]             setwd(...future.workdir)
[10:19:20.393]         {
[10:19:20.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.393]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.393]             }
[10:19:20.393]             base::options(...future.oldOptions)
[10:19:20.393]             if (.Platform$OS.type == "windows") {
[10:19:20.393]                 old_names <- names(...future.oldEnvVars)
[10:19:20.393]                 envs <- base::Sys.getenv()
[10:19:20.393]                 names <- names(envs)
[10:19:20.393]                 common <- intersect(names, old_names)
[10:19:20.393]                 added <- setdiff(names, old_names)
[10:19:20.393]                 removed <- setdiff(old_names, names)
[10:19:20.393]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.393]                   envs[common]]
[10:19:20.393]                 NAMES <- toupper(changed)
[10:19:20.393]                 args <- list()
[10:19:20.393]                 for (kk in seq_along(NAMES)) {
[10:19:20.393]                   name <- changed[[kk]]
[10:19:20.393]                   NAME <- NAMES[[kk]]
[10:19:20.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.393]                     next
[10:19:20.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.393]                 }
[10:19:20.393]                 NAMES <- toupper(added)
[10:19:20.393]                 for (kk in seq_along(NAMES)) {
[10:19:20.393]                   name <- added[[kk]]
[10:19:20.393]                   NAME <- NAMES[[kk]]
[10:19:20.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.393]                     next
[10:19:20.393]                   args[[name]] <- ""
[10:19:20.393]                 }
[10:19:20.393]                 NAMES <- toupper(removed)
[10:19:20.393]                 for (kk in seq_along(NAMES)) {
[10:19:20.393]                   name <- removed[[kk]]
[10:19:20.393]                   NAME <- NAMES[[kk]]
[10:19:20.393]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.393]                     next
[10:19:20.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.393]                 }
[10:19:20.393]                 if (length(args) > 0) 
[10:19:20.393]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.393]             }
[10:19:20.393]             else {
[10:19:20.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.393]             }
[10:19:20.393]             {
[10:19:20.393]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.393]                   0L) {
[10:19:20.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.393]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.393]                   base::options(opts)
[10:19:20.393]                 }
[10:19:20.393]                 {
[10:19:20.393]                   {
[10:19:20.393]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.393]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.393]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.393]                       inherits = FALSE)
[10:19:20.393]                     NULL
[10:19:20.393]                   }
[10:19:20.393]                   options(future.plan = NULL)
[10:19:20.393]                   if (is.na(NA_character_)) 
[10:19:20.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.393]                     .init = FALSE)
[10:19:20.393]                 }
[10:19:20.393]             }
[10:19:20.393]         }
[10:19:20.393]     })
[10:19:20.393]     if (TRUE) {
[10:19:20.393]         base::sink(type = "output", split = FALSE)
[10:19:20.393]         if (TRUE) {
[10:19:20.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.393]         }
[10:19:20.393]         else {
[10:19:20.393]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.393]         }
[10:19:20.393]         base::close(...future.stdout)
[10:19:20.393]         ...future.stdout <- NULL
[10:19:20.393]     }
[10:19:20.393]     ...future.result$conditions <- ...future.conditions
[10:19:20.393]     ...future.result$finished <- base::Sys.time()
[10:19:20.393]     ...future.result
[10:19:20.393] }
[10:19:20.394] assign_globals() ...
[10:19:20.395] List of 5
[10:19:20.395]  $ ...future.FUN            :function (x, ...)  
[10:19:20.395]  $ MoreArgs                 : NULL
[10:19:20.395]  $ ...future.elements_ii    :List of 2
[10:19:20.395]   ..$ :List of 4
[10:19:20.395]   .. ..$ : int 1
[10:19:20.395]   .. ..$ : int 2
[10:19:20.395]   .. ..$ : int 3
[10:19:20.395]   .. ..$ : int 4
[10:19:20.395]   ..$ :List of 4
[10:19:20.395]   .. ..$ : int 4
[10:19:20.395]   .. ..$ : int 3
[10:19:20.395]   .. ..$ : int 2
[10:19:20.395]   .. ..$ : int 1
[10:19:20.395]  $ ...future.seeds_ii       : NULL
[10:19:20.395]  $ ...future.globals.maxSize: NULL
[10:19:20.395]  - attr(*, "where")=List of 5
[10:19:20.395]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.395]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.395]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.395]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.395]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.395]  - attr(*, "resolved")= logi FALSE
[10:19:20.395]  - attr(*, "total_size")= num 258
[10:19:20.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.395]  - attr(*, "already-done")= logi TRUE
[10:19:20.403] - copied ‘...future.FUN’ to environment
[10:19:20.403] - copied ‘MoreArgs’ to environment
[10:19:20.403] - copied ‘...future.elements_ii’ to environment
[10:19:20.403] - copied ‘...future.seeds_ii’ to environment
[10:19:20.403] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.403] assign_globals() ... done
[10:19:20.403] plan(): Setting new future strategy stack:
[10:19:20.403] List of future strategies:
[10:19:20.403] 1. sequential:
[10:19:20.403]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.403]    - tweaked: FALSE
[10:19:20.403]    - call: NULL
[10:19:20.404] plan(): nbrOfWorkers() = 1
[10:19:20.405] plan(): Setting new future strategy stack:
[10:19:20.405] List of future strategies:
[10:19:20.405] 1. sequential:
[10:19:20.405]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.405]    - tweaked: FALSE
[10:19:20.405]    - call: plan(strategy)
[10:19:20.405] plan(): nbrOfWorkers() = 1
[10:19:20.405] SequentialFuture started (and completed)
[10:19:20.405] - Launch lazy future ... done
[10:19:20.406] run() for ‘SequentialFuture’ ... done
[10:19:20.406] Created future:
[10:19:20.406] SequentialFuture:
[10:19:20.406] Label: ‘future_mapply-1’
[10:19:20.406] Expression:
[10:19:20.406] {
[10:19:20.406]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.406]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.406]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.406]         on.exit(options(oopts), add = TRUE)
[10:19:20.406]     }
[10:19:20.406]     {
[10:19:20.406]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.406]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.406]         do.call(mapply, args = args)
[10:19:20.406]     }
[10:19:20.406] }
[10:19:20.406] Lazy evaluation: FALSE
[10:19:20.406] Asynchronous evaluation: FALSE
[10:19:20.406] Local evaluation: TRUE
[10:19:20.406] Environment: R_GlobalEnv
[10:19:20.406] Capture standard output: TRUE
[10:19:20.406] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.406] Globals: 5 objects totaling 258 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 143 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.406] Packages: <none>
[10:19:20.406] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.406] Resolved: TRUE
[10:19:20.406] Value: 103 bytes of class ‘list’
[10:19:20.406] Early signaling: FALSE
[10:19:20.406] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.406] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.406] Chunk #1 of 1 ... DONE
[10:19:20.407] Launching 1 futures (chunks) ... DONE
[10:19:20.407] Resolving 1 futures (chunks) ...
[10:19:20.407] resolve() on list ...
[10:19:20.407]  recursive: 0
[10:19:20.407]  length: 1
[10:19:20.407] 
[10:19:20.407] resolved() for ‘SequentialFuture’ ...
[10:19:20.407] - state: ‘finished’
[10:19:20.407] - run: TRUE
[10:19:20.407] - result: ‘FutureResult’
[10:19:20.407] resolved() for ‘SequentialFuture’ ... done
[10:19:20.408] Future #1
[10:19:20.408] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.408] - nx: 1
[10:19:20.408] - relay: TRUE
[10:19:20.408] - stdout: TRUE
[10:19:20.408] - signal: TRUE
[10:19:20.408] - resignal: FALSE
[10:19:20.408] - force: TRUE
[10:19:20.408] - relayed: [n=1] FALSE
[10:19:20.408] - queued futures: [n=1] FALSE
[10:19:20.408]  - until=1
[10:19:20.408]  - relaying element #1
[10:19:20.409] - relayed: [n=1] TRUE
[10:19:20.409] - queued futures: [n=1] TRUE
[10:19:20.409] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.409]  length: 0 (resolved future 1)
[10:19:20.409] Relaying remaining futures
[10:19:20.409] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.409] - nx: 1
[10:19:20.409] - relay: TRUE
[10:19:20.409] - stdout: TRUE
[10:19:20.409] - signal: TRUE
[10:19:20.410] - resignal: FALSE
[10:19:20.410] - force: TRUE
[10:19:20.410] - relayed: [n=1] TRUE
[10:19:20.410] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.410] - relayed: [n=1] TRUE
[10:19:20.410] - queued futures: [n=1] TRUE
[10:19:20.410] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.410] resolve() on list ... DONE
[10:19:20.410]  - Number of value chunks collected: 1
[10:19:20.410] Resolving 1 futures (chunks) ... DONE
[10:19:20.410] Reducing values from 1 chunks ...
[10:19:20.411]  - Number of values collected after concatenation: 4
[10:19:20.411]  - Number of values expected: 4
[10:19:20.411] Reducing values from 1 chunks ... DONE
[10:19:20.411] future_mapply() ... DONE
[10:19:20.411] future_mapply() ...
[10:19:20.411] Number of chunks: 1
[10:19:20.411] getGlobalsAndPackagesXApply() ...
[10:19:20.411]  - future.globals: TRUE
[10:19:20.411] getGlobalsAndPackages() ...
[10:19:20.411] Searching for globals...
[10:19:20.412] - globals found: [1] ‘FUN’
[10:19:20.412] Searching for globals ... DONE
[10:19:20.412] Resolving globals: FALSE
[10:19:20.412] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:20.413] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:20.413] - globals: [1] ‘FUN’
[10:19:20.413] 
[10:19:20.413] getGlobalsAndPackages() ... DONE
[10:19:20.413]  - globals found/used: [n=1] ‘FUN’
[10:19:20.413]  - needed namespaces: [n=0] 
[10:19:20.413] Finding globals ... DONE
[10:19:20.413] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.414] List of 2
[10:19:20.414]  $ ...future.FUN:function (x, ...)  
[10:19:20.414]  $ MoreArgs     : NULL
[10:19:20.414]  - attr(*, "where")=List of 2
[10:19:20.414]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.414]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.414]  - attr(*, "resolved")= logi FALSE
[10:19:20.414]  - attr(*, "total_size")= num NA
[10:19:20.416] Packages to be attached in all futures: [n=0] 
[10:19:20.416] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.416] Number of futures (= number of chunks): 1
[10:19:20.416] Launching 1 futures (chunks) ...
[10:19:20.416] Chunk #1 of 1 ...
[10:19:20.416]  - Finding globals in '...' for chunk #1 ...
[10:19:20.417] getGlobalsAndPackages() ...
[10:19:20.417] Searching for globals...
[10:19:20.417] 
[10:19:20.417] Searching for globals ... DONE
[10:19:20.417] - globals: [0] <none>
[10:19:20.417] getGlobalsAndPackages() ... DONE
[10:19:20.417]    + additional globals found: [n=0] 
[10:19:20.417]    + additional namespaces needed: [n=0] 
[10:19:20.417]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.418]  - seeds: <none>
[10:19:20.418]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.418] getGlobalsAndPackages() ...
[10:19:20.418] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.418] Resolving globals: FALSE
[10:19:20.418] The total size of the 5 globals is 313 bytes (313 bytes)
[10:19:20.419] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 313 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (198 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.419] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.419] 
[10:19:20.419] getGlobalsAndPackages() ... DONE
[10:19:20.419] run() for ‘Future’ ...
[10:19:20.419] - state: ‘created’
[10:19:20.419] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.420] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.420] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.420]   - Field: ‘label’
[10:19:20.420]   - Field: ‘local’
[10:19:20.420]   - Field: ‘owner’
[10:19:20.420]   - Field: ‘envir’
[10:19:20.420]   - Field: ‘packages’
[10:19:20.420]   - Field: ‘gc’
[10:19:20.420]   - Field: ‘conditions’
[10:19:20.421]   - Field: ‘expr’
[10:19:20.421]   - Field: ‘uuid’
[10:19:20.421]   - Field: ‘seed’
[10:19:20.421]   - Field: ‘version’
[10:19:20.421]   - Field: ‘result’
[10:19:20.421]   - Field: ‘asynchronous’
[10:19:20.421]   - Field: ‘calls’
[10:19:20.421]   - Field: ‘globals’
[10:19:20.421]   - Field: ‘stdout’
[10:19:20.421]   - Field: ‘earlySignal’
[10:19:20.421]   - Field: ‘lazy’
[10:19:20.421]   - Field: ‘state’
[10:19:20.422] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.422] - Launch lazy future ...
[10:19:20.422] Packages needed by the future expression (n = 0): <none>
[10:19:20.422] Packages needed by future strategies (n = 0): <none>
[10:19:20.422] {
[10:19:20.422]     {
[10:19:20.422]         {
[10:19:20.422]             ...future.startTime <- base::Sys.time()
[10:19:20.422]             {
[10:19:20.422]                 {
[10:19:20.422]                   {
[10:19:20.422]                     base::local({
[10:19:20.422]                       has_future <- base::requireNamespace("future", 
[10:19:20.422]                         quietly = TRUE)
[10:19:20.422]                       if (has_future) {
[10:19:20.422]                         ns <- base::getNamespace("future")
[10:19:20.422]                         version <- ns[[".package"]][["version"]]
[10:19:20.422]                         if (is.null(version)) 
[10:19:20.422]                           version <- utils::packageVersion("future")
[10:19:20.422]                       }
[10:19:20.422]                       else {
[10:19:20.422]                         version <- NULL
[10:19:20.422]                       }
[10:19:20.422]                       if (!has_future || version < "1.8.0") {
[10:19:20.422]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.422]                           "", base::R.version$version.string), 
[10:19:20.422]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.422]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.422]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.422]                             "release", "version")], collapse = " "), 
[10:19:20.422]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.422]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.422]                           info)
[10:19:20.422]                         info <- base::paste(info, collapse = "; ")
[10:19:20.422]                         if (!has_future) {
[10:19:20.422]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.422]                             info)
[10:19:20.422]                         }
[10:19:20.422]                         else {
[10:19:20.422]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.422]                             info, version)
[10:19:20.422]                         }
[10:19:20.422]                         base::stop(msg)
[10:19:20.422]                       }
[10:19:20.422]                     })
[10:19:20.422]                   }
[10:19:20.422]                   ...future.strategy.old <- future::plan("list")
[10:19:20.422]                   options(future.plan = NULL)
[10:19:20.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.422]                 }
[10:19:20.422]                 ...future.workdir <- getwd()
[10:19:20.422]             }
[10:19:20.422]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.422]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.422]         }
[10:19:20.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.422]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.422]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.422]             base::names(...future.oldOptions))
[10:19:20.422]     }
[10:19:20.422]     if (FALSE) {
[10:19:20.422]     }
[10:19:20.422]     else {
[10:19:20.422]         if (TRUE) {
[10:19:20.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.422]                 open = "w")
[10:19:20.422]         }
[10:19:20.422]         else {
[10:19:20.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.422]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.422]         }
[10:19:20.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.422]             base::sink(type = "output", split = FALSE)
[10:19:20.422]             base::close(...future.stdout)
[10:19:20.422]         }, add = TRUE)
[10:19:20.422]     }
[10:19:20.422]     ...future.frame <- base::sys.nframe()
[10:19:20.422]     ...future.conditions <- base::list()
[10:19:20.422]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.422]     if (FALSE) {
[10:19:20.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.422]     }
[10:19:20.422]     ...future.result <- base::tryCatch({
[10:19:20.422]         base::withCallingHandlers({
[10:19:20.422]             ...future.value <- base::withVisible(base::local({
[10:19:20.422]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.422]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.422]                   ...future.globals.maxSize)) {
[10:19:20.422]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.422]                   on.exit(options(oopts), add = TRUE)
[10:19:20.422]                 }
[10:19:20.422]                 {
[10:19:20.422]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.422]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.422]                     USE.NAMES = FALSE)
[10:19:20.422]                   do.call(mapply, args = args)
[10:19:20.422]                 }
[10:19:20.422]             }))
[10:19:20.422]             future::FutureResult(value = ...future.value$value, 
[10:19:20.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.422]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.422]                     ...future.globalenv.names))
[10:19:20.422]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.422]         }, condition = base::local({
[10:19:20.422]             c <- base::c
[10:19:20.422]             inherits <- base::inherits
[10:19:20.422]             invokeRestart <- base::invokeRestart
[10:19:20.422]             length <- base::length
[10:19:20.422]             list <- base::list
[10:19:20.422]             seq.int <- base::seq.int
[10:19:20.422]             signalCondition <- base::signalCondition
[10:19:20.422]             sys.calls <- base::sys.calls
[10:19:20.422]             `[[` <- base::`[[`
[10:19:20.422]             `+` <- base::`+`
[10:19:20.422]             `<<-` <- base::`<<-`
[10:19:20.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.422]                   3L)]
[10:19:20.422]             }
[10:19:20.422]             function(cond) {
[10:19:20.422]                 is_error <- inherits(cond, "error")
[10:19:20.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.422]                   NULL)
[10:19:20.422]                 if (is_error) {
[10:19:20.422]                   sessionInformation <- function() {
[10:19:20.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.422]                       search = base::search(), system = base::Sys.info())
[10:19:20.422]                   }
[10:19:20.422]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.422]                     cond$call), session = sessionInformation(), 
[10:19:20.422]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.422]                   signalCondition(cond)
[10:19:20.422]                 }
[10:19:20.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.422]                 "immediateCondition"))) {
[10:19:20.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.422]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.422]                   if (TRUE && !signal) {
[10:19:20.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.422]                     {
[10:19:20.422]                       inherits <- base::inherits
[10:19:20.422]                       invokeRestart <- base::invokeRestart
[10:19:20.422]                       is.null <- base::is.null
[10:19:20.422]                       muffled <- FALSE
[10:19:20.422]                       if (inherits(cond, "message")) {
[10:19:20.422]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.422]                         if (muffled) 
[10:19:20.422]                           invokeRestart("muffleMessage")
[10:19:20.422]                       }
[10:19:20.422]                       else if (inherits(cond, "warning")) {
[10:19:20.422]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.422]                         if (muffled) 
[10:19:20.422]                           invokeRestart("muffleWarning")
[10:19:20.422]                       }
[10:19:20.422]                       else if (inherits(cond, "condition")) {
[10:19:20.422]                         if (!is.null(pattern)) {
[10:19:20.422]                           computeRestarts <- base::computeRestarts
[10:19:20.422]                           grepl <- base::grepl
[10:19:20.422]                           restarts <- computeRestarts(cond)
[10:19:20.422]                           for (restart in restarts) {
[10:19:20.422]                             name <- restart$name
[10:19:20.422]                             if (is.null(name)) 
[10:19:20.422]                               next
[10:19:20.422]                             if (!grepl(pattern, name)) 
[10:19:20.422]                               next
[10:19:20.422]                             invokeRestart(restart)
[10:19:20.422]                             muffled <- TRUE
[10:19:20.422]                             break
[10:19:20.422]                           }
[10:19:20.422]                         }
[10:19:20.422]                       }
[10:19:20.422]                       invisible(muffled)
[10:19:20.422]                     }
[10:19:20.422]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.422]                   }
[10:19:20.422]                 }
[10:19:20.422]                 else {
[10:19:20.422]                   if (TRUE) {
[10:19:20.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.422]                     {
[10:19:20.422]                       inherits <- base::inherits
[10:19:20.422]                       invokeRestart <- base::invokeRestart
[10:19:20.422]                       is.null <- base::is.null
[10:19:20.422]                       muffled <- FALSE
[10:19:20.422]                       if (inherits(cond, "message")) {
[10:19:20.422]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.422]                         if (muffled) 
[10:19:20.422]                           invokeRestart("muffleMessage")
[10:19:20.422]                       }
[10:19:20.422]                       else if (inherits(cond, "warning")) {
[10:19:20.422]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.422]                         if (muffled) 
[10:19:20.422]                           invokeRestart("muffleWarning")
[10:19:20.422]                       }
[10:19:20.422]                       else if (inherits(cond, "condition")) {
[10:19:20.422]                         if (!is.null(pattern)) {
[10:19:20.422]                           computeRestarts <- base::computeRestarts
[10:19:20.422]                           grepl <- base::grepl
[10:19:20.422]                           restarts <- computeRestarts(cond)
[10:19:20.422]                           for (restart in restarts) {
[10:19:20.422]                             name <- restart$name
[10:19:20.422]                             if (is.null(name)) 
[10:19:20.422]                               next
[10:19:20.422]                             if (!grepl(pattern, name)) 
[10:19:20.422]                               next
[10:19:20.422]                             invokeRestart(restart)
[10:19:20.422]                             muffled <- TRUE
[10:19:20.422]                             break
[10:19:20.422]                           }
[10:19:20.422]                         }
[10:19:20.422]                       }
[10:19:20.422]                       invisible(muffled)
[10:19:20.422]                     }
[10:19:20.422]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.422]                   }
[10:19:20.422]                 }
[10:19:20.422]             }
[10:19:20.422]         }))
[10:19:20.422]     }, error = function(ex) {
[10:19:20.422]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.422]                 ...future.rng), started = ...future.startTime, 
[10:19:20.422]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.422]             version = "1.8"), class = "FutureResult")
[10:19:20.422]     }, finally = {
[10:19:20.422]         if (!identical(...future.workdir, getwd())) 
[10:19:20.422]             setwd(...future.workdir)
[10:19:20.422]         {
[10:19:20.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.422]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.422]             }
[10:19:20.422]             base::options(...future.oldOptions)
[10:19:20.422]             if (.Platform$OS.type == "windows") {
[10:19:20.422]                 old_names <- names(...future.oldEnvVars)
[10:19:20.422]                 envs <- base::Sys.getenv()
[10:19:20.422]                 names <- names(envs)
[10:19:20.422]                 common <- intersect(names, old_names)
[10:19:20.422]                 added <- setdiff(names, old_names)
[10:19:20.422]                 removed <- setdiff(old_names, names)
[10:19:20.422]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.422]                   envs[common]]
[10:19:20.422]                 NAMES <- toupper(changed)
[10:19:20.422]                 args <- list()
[10:19:20.422]                 for (kk in seq_along(NAMES)) {
[10:19:20.422]                   name <- changed[[kk]]
[10:19:20.422]                   NAME <- NAMES[[kk]]
[10:19:20.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.422]                     next
[10:19:20.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.422]                 }
[10:19:20.422]                 NAMES <- toupper(added)
[10:19:20.422]                 for (kk in seq_along(NAMES)) {
[10:19:20.422]                   name <- added[[kk]]
[10:19:20.422]                   NAME <- NAMES[[kk]]
[10:19:20.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.422]                     next
[10:19:20.422]                   args[[name]] <- ""
[10:19:20.422]                 }
[10:19:20.422]                 NAMES <- toupper(removed)
[10:19:20.422]                 for (kk in seq_along(NAMES)) {
[10:19:20.422]                   name <- removed[[kk]]
[10:19:20.422]                   NAME <- NAMES[[kk]]
[10:19:20.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.422]                     next
[10:19:20.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.422]                 }
[10:19:20.422]                 if (length(args) > 0) 
[10:19:20.422]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.422]             }
[10:19:20.422]             else {
[10:19:20.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.422]             }
[10:19:20.422]             {
[10:19:20.422]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.422]                   0L) {
[10:19:20.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.422]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.422]                   base::options(opts)
[10:19:20.422]                 }
[10:19:20.422]                 {
[10:19:20.422]                   {
[10:19:20.422]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.422]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.422]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.422]                       inherits = FALSE)
[10:19:20.422]                     NULL
[10:19:20.422]                   }
[10:19:20.422]                   options(future.plan = NULL)
[10:19:20.422]                   if (is.na(NA_character_)) 
[10:19:20.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.422]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.422]                     .init = FALSE)
[10:19:20.422]                 }
[10:19:20.422]             }
[10:19:20.422]         }
[10:19:20.422]     })
[10:19:20.422]     if (TRUE) {
[10:19:20.422]         base::sink(type = "output", split = FALSE)
[10:19:20.422]         if (TRUE) {
[10:19:20.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.422]         }
[10:19:20.422]         else {
[10:19:20.422]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.422]         }
[10:19:20.422]         base::close(...future.stdout)
[10:19:20.422]         ...future.stdout <- NULL
[10:19:20.422]     }
[10:19:20.422]     ...future.result$conditions <- ...future.conditions
[10:19:20.422]     ...future.result$finished <- base::Sys.time()
[10:19:20.422]     ...future.result
[10:19:20.422] }
[10:19:20.424] assign_globals() ...
[10:19:20.424] List of 5
[10:19:20.424]  $ ...future.FUN            :function (x, ...)  
[10:19:20.424]  $ MoreArgs                 : NULL
[10:19:20.424]  $ ...future.elements_ii    :List of 2
[10:19:20.424]   ..$ times:List of 4
[10:19:20.424]   .. ..$ : int 1
[10:19:20.424]   .. ..$ : int 2
[10:19:20.424]   .. ..$ : int 3
[10:19:20.424]   .. ..$ : int 4
[10:19:20.424]   ..$ x    :List of 4
[10:19:20.424]   .. ..$ : int 4
[10:19:20.424]   .. ..$ : int 3
[10:19:20.424]   .. ..$ : int 2
[10:19:20.424]   .. ..$ : int 1
[10:19:20.424]  $ ...future.seeds_ii       : NULL
[10:19:20.424]  $ ...future.globals.maxSize: NULL
[10:19:20.424]  - attr(*, "where")=List of 5
[10:19:20.424]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.424]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.424]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.424]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.424]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.424]  - attr(*, "resolved")= logi FALSE
[10:19:20.424]  - attr(*, "total_size")= num 313
[10:19:20.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.424]  - attr(*, "already-done")= logi TRUE
[10:19:20.433] - copied ‘...future.FUN’ to environment
[10:19:20.433] - copied ‘MoreArgs’ to environment
[10:19:20.433] - copied ‘...future.elements_ii’ to environment
[10:19:20.433] - copied ‘...future.seeds_ii’ to environment
[10:19:20.433] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.433] assign_globals() ... done
[10:19:20.434] plan(): Setting new future strategy stack:
[10:19:20.434] List of future strategies:
[10:19:20.434] 1. sequential:
[10:19:20.434]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.434]    - tweaked: FALSE
[10:19:20.434]    - call: NULL
[10:19:20.434] plan(): nbrOfWorkers() = 1
[10:19:20.435] plan(): Setting new future strategy stack:
[10:19:20.435] List of future strategies:
[10:19:20.435] 1. sequential:
[10:19:20.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.435]    - tweaked: FALSE
[10:19:20.435]    - call: plan(strategy)
[10:19:20.436] plan(): nbrOfWorkers() = 1
[10:19:20.436] SequentialFuture started (and completed)
[10:19:20.436] - Launch lazy future ... done
[10:19:20.436] run() for ‘SequentialFuture’ ... done
[10:19:20.436] Created future:
[10:19:20.436] SequentialFuture:
[10:19:20.436] Label: ‘future_mapply-1’
[10:19:20.436] Expression:
[10:19:20.436] {
[10:19:20.436]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.436]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.436]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.436]         on.exit(options(oopts), add = TRUE)
[10:19:20.436]     }
[10:19:20.436]     {
[10:19:20.436]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.436]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.436]         do.call(mapply, args = args)
[10:19:20.436]     }
[10:19:20.436] }
[10:19:20.436] Lazy evaluation: FALSE
[10:19:20.436] Asynchronous evaluation: FALSE
[10:19:20.436] Local evaluation: TRUE
[10:19:20.436] Environment: R_GlobalEnv
[10:19:20.436] Capture standard output: TRUE
[10:19:20.436] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.436] Globals: 5 objects totaling 313 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 198 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.436] Packages: <none>
[10:19:20.436] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.436] Resolved: TRUE
[10:19:20.436] Value: 103 bytes of class ‘list’
[10:19:20.436] Early signaling: FALSE
[10:19:20.436] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.436] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.437] Chunk #1 of 1 ... DONE
[10:19:20.437] Launching 1 futures (chunks) ... DONE
[10:19:20.437] Resolving 1 futures (chunks) ...
[10:19:20.437] resolve() on list ...
[10:19:20.437]  recursive: 0
[10:19:20.437]  length: 1
[10:19:20.438] 
[10:19:20.438] resolved() for ‘SequentialFuture’ ...
[10:19:20.438] - state: ‘finished’
[10:19:20.438] - run: TRUE
[10:19:20.438] - result: ‘FutureResult’
[10:19:20.438] resolved() for ‘SequentialFuture’ ... done
[10:19:20.438] Future #1
[10:19:20.438] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.438] - nx: 1
[10:19:20.438] - relay: TRUE
[10:19:20.438] - stdout: TRUE
[10:19:20.439] - signal: TRUE
[10:19:20.439] - resignal: FALSE
[10:19:20.439] - force: TRUE
[10:19:20.439] - relayed: [n=1] FALSE
[10:19:20.439] - queued futures: [n=1] FALSE
[10:19:20.439]  - until=1
[10:19:20.439]  - relaying element #1
[10:19:20.439] - relayed: [n=1] TRUE
[10:19:20.439] - queued futures: [n=1] TRUE
[10:19:20.439] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.440]  length: 0 (resolved future 1)
[10:19:20.440] Relaying remaining futures
[10:19:20.440] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.440] - nx: 1
[10:19:20.440] - relay: TRUE
[10:19:20.440] - stdout: TRUE
[10:19:20.440] - signal: TRUE
[10:19:20.440] - resignal: FALSE
[10:19:20.440] - force: TRUE
[10:19:20.440] - relayed: [n=1] TRUE
[10:19:20.440] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.440] - relayed: [n=1] TRUE
[10:19:20.440] - queued futures: [n=1] TRUE
[10:19:20.441] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.441] resolve() on list ... DONE
[10:19:20.441]  - Number of value chunks collected: 1
[10:19:20.441] Resolving 1 futures (chunks) ... DONE
[10:19:20.441] Reducing values from 1 chunks ...
[10:19:20.441]  - Number of values collected after concatenation: 4
[10:19:20.441]  - Number of values expected: 4
[10:19:20.441] Reducing values from 1 chunks ... DONE
[10:19:20.441] future_mapply() ... DONE
[10:19:20.441] future_mapply() ...
[10:19:20.442] Number of chunks: 1
[10:19:20.442] getGlobalsAndPackagesXApply() ...
[10:19:20.442]  - future.globals: TRUE
[10:19:20.442] getGlobalsAndPackages() ...
[10:19:20.442] Searching for globals...
[10:19:20.443] - globals found: [1] ‘FUN’
[10:19:20.443] Searching for globals ... DONE
[10:19:20.443] Resolving globals: FALSE
[10:19:20.443] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:20.443] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:20.443] - globals: [1] ‘FUN’
[10:19:20.444] 
[10:19:20.444] getGlobalsAndPackages() ... DONE
[10:19:20.444]  - globals found/used: [n=1] ‘FUN’
[10:19:20.444]  - needed namespaces: [n=0] 
[10:19:20.444] Finding globals ... DONE
[10:19:20.444] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.444] List of 2
[10:19:20.444]  $ ...future.FUN:function (x, ...)  
[10:19:20.444]  $ MoreArgs     :List of 1
[10:19:20.444]   ..$ x: num 42
[10:19:20.444]  - attr(*, "where")=List of 2
[10:19:20.444]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.444]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.444]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.444]  - attr(*, "resolved")= logi FALSE
[10:19:20.444]  - attr(*, "total_size")= num NA
[10:19:20.447] Packages to be attached in all futures: [n=0] 
[10:19:20.447] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.447] Number of futures (= number of chunks): 1
[10:19:20.447] Launching 1 futures (chunks) ...
[10:19:20.447] Chunk #1 of 1 ...
[10:19:20.448]  - Finding globals in '...' for chunk #1 ...
[10:19:20.448] getGlobalsAndPackages() ...
[10:19:20.448] Searching for globals...
[10:19:20.448] 
[10:19:20.448] Searching for globals ... DONE
[10:19:20.448] - globals: [0] <none>
[10:19:20.448] getGlobalsAndPackages() ... DONE
[10:19:20.448]    + additional globals found: [n=0] 
[10:19:20.448]    + additional namespaces needed: [n=0] 
[10:19:20.450]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.450]  - seeds: <none>
[10:19:20.450]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.450] getGlobalsAndPackages() ...
[10:19:20.451] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.451] Resolving globals: FALSE
[10:19:20.451] The total size of the 5 globals is 310 bytes (310 bytes)
[10:19:20.451] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 310 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (133 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[10:19:20.452] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.452] 
[10:19:20.452] getGlobalsAndPackages() ... DONE
[10:19:20.452] run() for ‘Future’ ...
[10:19:20.452] - state: ‘created’
[10:19:20.452] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.453] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.453] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.453]   - Field: ‘label’
[10:19:20.453]   - Field: ‘local’
[10:19:20.453]   - Field: ‘owner’
[10:19:20.453]   - Field: ‘envir’
[10:19:20.453]   - Field: ‘packages’
[10:19:20.453]   - Field: ‘gc’
[10:19:20.453]   - Field: ‘conditions’
[10:19:20.453]   - Field: ‘expr’
[10:19:20.454]   - Field: ‘uuid’
[10:19:20.454]   - Field: ‘seed’
[10:19:20.454]   - Field: ‘version’
[10:19:20.454]   - Field: ‘result’
[10:19:20.454]   - Field: ‘asynchronous’
[10:19:20.454]   - Field: ‘calls’
[10:19:20.454]   - Field: ‘globals’
[10:19:20.454]   - Field: ‘stdout’
[10:19:20.454]   - Field: ‘earlySignal’
[10:19:20.454]   - Field: ‘lazy’
[10:19:20.454]   - Field: ‘state’
[10:19:20.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.455] - Launch lazy future ...
[10:19:20.455] Packages needed by the future expression (n = 0): <none>
[10:19:20.455] Packages needed by future strategies (n = 0): <none>
[10:19:20.455] {
[10:19:20.455]     {
[10:19:20.455]         {
[10:19:20.455]             ...future.startTime <- base::Sys.time()
[10:19:20.455]             {
[10:19:20.455]                 {
[10:19:20.455]                   {
[10:19:20.455]                     base::local({
[10:19:20.455]                       has_future <- base::requireNamespace("future", 
[10:19:20.455]                         quietly = TRUE)
[10:19:20.455]                       if (has_future) {
[10:19:20.455]                         ns <- base::getNamespace("future")
[10:19:20.455]                         version <- ns[[".package"]][["version"]]
[10:19:20.455]                         if (is.null(version)) 
[10:19:20.455]                           version <- utils::packageVersion("future")
[10:19:20.455]                       }
[10:19:20.455]                       else {
[10:19:20.455]                         version <- NULL
[10:19:20.455]                       }
[10:19:20.455]                       if (!has_future || version < "1.8.0") {
[10:19:20.455]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.455]                           "", base::R.version$version.string), 
[10:19:20.455]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.455]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.455]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.455]                             "release", "version")], collapse = " "), 
[10:19:20.455]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.455]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.455]                           info)
[10:19:20.455]                         info <- base::paste(info, collapse = "; ")
[10:19:20.455]                         if (!has_future) {
[10:19:20.455]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.455]                             info)
[10:19:20.455]                         }
[10:19:20.455]                         else {
[10:19:20.455]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.455]                             info, version)
[10:19:20.455]                         }
[10:19:20.455]                         base::stop(msg)
[10:19:20.455]                       }
[10:19:20.455]                     })
[10:19:20.455]                   }
[10:19:20.455]                   ...future.strategy.old <- future::plan("list")
[10:19:20.455]                   options(future.plan = NULL)
[10:19:20.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.455]                 }
[10:19:20.455]                 ...future.workdir <- getwd()
[10:19:20.455]             }
[10:19:20.455]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.455]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.455]         }
[10:19:20.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.455]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.455]             base::names(...future.oldOptions))
[10:19:20.455]     }
[10:19:20.455]     if (FALSE) {
[10:19:20.455]     }
[10:19:20.455]     else {
[10:19:20.455]         if (TRUE) {
[10:19:20.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.455]                 open = "w")
[10:19:20.455]         }
[10:19:20.455]         else {
[10:19:20.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.455]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.455]         }
[10:19:20.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.455]             base::sink(type = "output", split = FALSE)
[10:19:20.455]             base::close(...future.stdout)
[10:19:20.455]         }, add = TRUE)
[10:19:20.455]     }
[10:19:20.455]     ...future.frame <- base::sys.nframe()
[10:19:20.455]     ...future.conditions <- base::list()
[10:19:20.455]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.455]     if (FALSE) {
[10:19:20.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.455]     }
[10:19:20.455]     ...future.result <- base::tryCatch({
[10:19:20.455]         base::withCallingHandlers({
[10:19:20.455]             ...future.value <- base::withVisible(base::local({
[10:19:20.455]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.455]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.455]                   ...future.globals.maxSize)) {
[10:19:20.455]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.455]                   on.exit(options(oopts), add = TRUE)
[10:19:20.455]                 }
[10:19:20.455]                 {
[10:19:20.455]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.455]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.455]                     USE.NAMES = FALSE)
[10:19:20.455]                   do.call(mapply, args = args)
[10:19:20.455]                 }
[10:19:20.455]             }))
[10:19:20.455]             future::FutureResult(value = ...future.value$value, 
[10:19:20.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.455]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.455]                     ...future.globalenv.names))
[10:19:20.455]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.455]         }, condition = base::local({
[10:19:20.455]             c <- base::c
[10:19:20.455]             inherits <- base::inherits
[10:19:20.455]             invokeRestart <- base::invokeRestart
[10:19:20.455]             length <- base::length
[10:19:20.455]             list <- base::list
[10:19:20.455]             seq.int <- base::seq.int
[10:19:20.455]             signalCondition <- base::signalCondition
[10:19:20.455]             sys.calls <- base::sys.calls
[10:19:20.455]             `[[` <- base::`[[`
[10:19:20.455]             `+` <- base::`+`
[10:19:20.455]             `<<-` <- base::`<<-`
[10:19:20.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.455]                   3L)]
[10:19:20.455]             }
[10:19:20.455]             function(cond) {
[10:19:20.455]                 is_error <- inherits(cond, "error")
[10:19:20.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.455]                   NULL)
[10:19:20.455]                 if (is_error) {
[10:19:20.455]                   sessionInformation <- function() {
[10:19:20.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.455]                       search = base::search(), system = base::Sys.info())
[10:19:20.455]                   }
[10:19:20.455]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.455]                     cond$call), session = sessionInformation(), 
[10:19:20.455]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.455]                   signalCondition(cond)
[10:19:20.455]                 }
[10:19:20.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.455]                 "immediateCondition"))) {
[10:19:20.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.455]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.455]                   if (TRUE && !signal) {
[10:19:20.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.455]                     {
[10:19:20.455]                       inherits <- base::inherits
[10:19:20.455]                       invokeRestart <- base::invokeRestart
[10:19:20.455]                       is.null <- base::is.null
[10:19:20.455]                       muffled <- FALSE
[10:19:20.455]                       if (inherits(cond, "message")) {
[10:19:20.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.455]                         if (muffled) 
[10:19:20.455]                           invokeRestart("muffleMessage")
[10:19:20.455]                       }
[10:19:20.455]                       else if (inherits(cond, "warning")) {
[10:19:20.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.455]                         if (muffled) 
[10:19:20.455]                           invokeRestart("muffleWarning")
[10:19:20.455]                       }
[10:19:20.455]                       else if (inherits(cond, "condition")) {
[10:19:20.455]                         if (!is.null(pattern)) {
[10:19:20.455]                           computeRestarts <- base::computeRestarts
[10:19:20.455]                           grepl <- base::grepl
[10:19:20.455]                           restarts <- computeRestarts(cond)
[10:19:20.455]                           for (restart in restarts) {
[10:19:20.455]                             name <- restart$name
[10:19:20.455]                             if (is.null(name)) 
[10:19:20.455]                               next
[10:19:20.455]                             if (!grepl(pattern, name)) 
[10:19:20.455]                               next
[10:19:20.455]                             invokeRestart(restart)
[10:19:20.455]                             muffled <- TRUE
[10:19:20.455]                             break
[10:19:20.455]                           }
[10:19:20.455]                         }
[10:19:20.455]                       }
[10:19:20.455]                       invisible(muffled)
[10:19:20.455]                     }
[10:19:20.455]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.455]                   }
[10:19:20.455]                 }
[10:19:20.455]                 else {
[10:19:20.455]                   if (TRUE) {
[10:19:20.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.455]                     {
[10:19:20.455]                       inherits <- base::inherits
[10:19:20.455]                       invokeRestart <- base::invokeRestart
[10:19:20.455]                       is.null <- base::is.null
[10:19:20.455]                       muffled <- FALSE
[10:19:20.455]                       if (inherits(cond, "message")) {
[10:19:20.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.455]                         if (muffled) 
[10:19:20.455]                           invokeRestart("muffleMessage")
[10:19:20.455]                       }
[10:19:20.455]                       else if (inherits(cond, "warning")) {
[10:19:20.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.455]                         if (muffled) 
[10:19:20.455]                           invokeRestart("muffleWarning")
[10:19:20.455]                       }
[10:19:20.455]                       else if (inherits(cond, "condition")) {
[10:19:20.455]                         if (!is.null(pattern)) {
[10:19:20.455]                           computeRestarts <- base::computeRestarts
[10:19:20.455]                           grepl <- base::grepl
[10:19:20.455]                           restarts <- computeRestarts(cond)
[10:19:20.455]                           for (restart in restarts) {
[10:19:20.455]                             name <- restart$name
[10:19:20.455]                             if (is.null(name)) 
[10:19:20.455]                               next
[10:19:20.455]                             if (!grepl(pattern, name)) 
[10:19:20.455]                               next
[10:19:20.455]                             invokeRestart(restart)
[10:19:20.455]                             muffled <- TRUE
[10:19:20.455]                             break
[10:19:20.455]                           }
[10:19:20.455]                         }
[10:19:20.455]                       }
[10:19:20.455]                       invisible(muffled)
[10:19:20.455]                     }
[10:19:20.455]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.455]                   }
[10:19:20.455]                 }
[10:19:20.455]             }
[10:19:20.455]         }))
[10:19:20.455]     }, error = function(ex) {
[10:19:20.455]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.455]                 ...future.rng), started = ...future.startTime, 
[10:19:20.455]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.455]             version = "1.8"), class = "FutureResult")
[10:19:20.455]     }, finally = {
[10:19:20.455]         if (!identical(...future.workdir, getwd())) 
[10:19:20.455]             setwd(...future.workdir)
[10:19:20.455]         {
[10:19:20.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.455]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.455]             }
[10:19:20.455]             base::options(...future.oldOptions)
[10:19:20.455]             if (.Platform$OS.type == "windows") {
[10:19:20.455]                 old_names <- names(...future.oldEnvVars)
[10:19:20.455]                 envs <- base::Sys.getenv()
[10:19:20.455]                 names <- names(envs)
[10:19:20.455]                 common <- intersect(names, old_names)
[10:19:20.455]                 added <- setdiff(names, old_names)
[10:19:20.455]                 removed <- setdiff(old_names, names)
[10:19:20.455]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.455]                   envs[common]]
[10:19:20.455]                 NAMES <- toupper(changed)
[10:19:20.455]                 args <- list()
[10:19:20.455]                 for (kk in seq_along(NAMES)) {
[10:19:20.455]                   name <- changed[[kk]]
[10:19:20.455]                   NAME <- NAMES[[kk]]
[10:19:20.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.455]                     next
[10:19:20.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.455]                 }
[10:19:20.455]                 NAMES <- toupper(added)
[10:19:20.455]                 for (kk in seq_along(NAMES)) {
[10:19:20.455]                   name <- added[[kk]]
[10:19:20.455]                   NAME <- NAMES[[kk]]
[10:19:20.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.455]                     next
[10:19:20.455]                   args[[name]] <- ""
[10:19:20.455]                 }
[10:19:20.455]                 NAMES <- toupper(removed)
[10:19:20.455]                 for (kk in seq_along(NAMES)) {
[10:19:20.455]                   name <- removed[[kk]]
[10:19:20.455]                   NAME <- NAMES[[kk]]
[10:19:20.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.455]                     next
[10:19:20.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.455]                 }
[10:19:20.455]                 if (length(args) > 0) 
[10:19:20.455]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.455]             }
[10:19:20.455]             else {
[10:19:20.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.455]             }
[10:19:20.455]             {
[10:19:20.455]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.455]                   0L) {
[10:19:20.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.455]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.455]                   base::options(opts)
[10:19:20.455]                 }
[10:19:20.455]                 {
[10:19:20.455]                   {
[10:19:20.455]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.455]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.455]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.455]                       inherits = FALSE)
[10:19:20.455]                     NULL
[10:19:20.455]                   }
[10:19:20.455]                   options(future.plan = NULL)
[10:19:20.455]                   if (is.na(NA_character_)) 
[10:19:20.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.455]                     .init = FALSE)
[10:19:20.455]                 }
[10:19:20.455]             }
[10:19:20.455]         }
[10:19:20.455]     })
[10:19:20.455]     if (TRUE) {
[10:19:20.455]         base::sink(type = "output", split = FALSE)
[10:19:20.455]         if (TRUE) {
[10:19:20.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.455]         }
[10:19:20.455]         else {
[10:19:20.455]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.455]         }
[10:19:20.455]         base::close(...future.stdout)
[10:19:20.455]         ...future.stdout <- NULL
[10:19:20.455]     }
[10:19:20.455]     ...future.result$conditions <- ...future.conditions
[10:19:20.455]     ...future.result$finished <- base::Sys.time()
[10:19:20.455]     ...future.result
[10:19:20.455] }
[10:19:20.457] assign_globals() ...
[10:19:20.457] List of 5
[10:19:20.457]  $ ...future.FUN            :function (x, ...)  
[10:19:20.457]  $ MoreArgs                 :List of 1
[10:19:20.457]   ..$ x: num 42
[10:19:20.457]  $ ...future.elements_ii    :List of 1
[10:19:20.457]   ..$ times:List of 4
[10:19:20.457]   .. ..$ : int 1
[10:19:20.457]   .. ..$ : int 2
[10:19:20.457]   .. ..$ : int 3
[10:19:20.457]   .. ..$ : int 4
[10:19:20.457]  $ ...future.seeds_ii       : NULL
[10:19:20.457]  $ ...future.globals.maxSize: NULL
[10:19:20.457]  - attr(*, "where")=List of 5
[10:19:20.457]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.457]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.457]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.457]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.457]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.457]  - attr(*, "resolved")= logi FALSE
[10:19:20.457]  - attr(*, "total_size")= num 310
[10:19:20.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.457]  - attr(*, "already-done")= logi TRUE
[10:19:20.463] - copied ‘...future.FUN’ to environment
[10:19:20.463] - copied ‘MoreArgs’ to environment
[10:19:20.463] - copied ‘...future.elements_ii’ to environment
[10:19:20.463] - copied ‘...future.seeds_ii’ to environment
[10:19:20.463] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.463] assign_globals() ... done
[10:19:20.463] plan(): Setting new future strategy stack:
[10:19:20.463] List of future strategies:
[10:19:20.463] 1. sequential:
[10:19:20.463]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.463]    - tweaked: FALSE
[10:19:20.463]    - call: NULL
[10:19:20.464] plan(): nbrOfWorkers() = 1
[10:19:20.465] plan(): Setting new future strategy stack:
[10:19:20.465] List of future strategies:
[10:19:20.465] 1. sequential:
[10:19:20.465]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.465]    - tweaked: FALSE
[10:19:20.465]    - call: plan(strategy)
[10:19:20.465] plan(): nbrOfWorkers() = 1
[10:19:20.465] SequentialFuture started (and completed)
[10:19:20.465] - Launch lazy future ... done
[10:19:20.466] run() for ‘SequentialFuture’ ... done
[10:19:20.466] Created future:
[10:19:20.466] SequentialFuture:
[10:19:20.466] Label: ‘future_mapply-1’
[10:19:20.466] Expression:
[10:19:20.466] {
[10:19:20.466]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.466]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.466]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.466]         on.exit(options(oopts), add = TRUE)
[10:19:20.466]     }
[10:19:20.466]     {
[10:19:20.466]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.466]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.466]         do.call(mapply, args = args)
[10:19:20.466]     }
[10:19:20.466] }
[10:19:20.466] Lazy evaluation: FALSE
[10:19:20.466] Asynchronous evaluation: FALSE
[10:19:20.466] Local evaluation: TRUE
[10:19:20.466] Environment: R_GlobalEnv
[10:19:20.466] Capture standard output: TRUE
[10:19:20.466] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.466] Globals: 5 objects totaling 310 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 133 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.466] Packages: <none>
[10:19:20.466] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.466] Resolved: TRUE
[10:19:20.466] Value: 143 bytes of class ‘list’
[10:19:20.466] Early signaling: FALSE
[10:19:20.466] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.466] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.466] Chunk #1 of 1 ... DONE
[10:19:20.467] Launching 1 futures (chunks) ... DONE
[10:19:20.467] Resolving 1 futures (chunks) ...
[10:19:20.467] resolve() on list ...
[10:19:20.467]  recursive: 0
[10:19:20.467]  length: 1
[10:19:20.467] 
[10:19:20.467] resolved() for ‘SequentialFuture’ ...
[10:19:20.467] - state: ‘finished’
[10:19:20.467] - run: TRUE
[10:19:20.467] - result: ‘FutureResult’
[10:19:20.467] resolved() for ‘SequentialFuture’ ... done
[10:19:20.468] Future #1
[10:19:20.468] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.468] - nx: 1
[10:19:20.468] - relay: TRUE
[10:19:20.468] - stdout: TRUE
[10:19:20.468] - signal: TRUE
[10:19:20.468] - resignal: FALSE
[10:19:20.468] - force: TRUE
[10:19:20.468] - relayed: [n=1] FALSE
[10:19:20.468] - queued futures: [n=1] FALSE
[10:19:20.468]  - until=1
[10:19:20.468]  - relaying element #1
[10:19:20.469] - relayed: [n=1] TRUE
[10:19:20.469] - queued futures: [n=1] TRUE
[10:19:20.469] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.469]  length: 0 (resolved future 1)
[10:19:20.469] Relaying remaining futures
[10:19:20.469] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.469] - nx: 1
[10:19:20.469] - relay: TRUE
[10:19:20.469] - stdout: TRUE
[10:19:20.469] - signal: TRUE
[10:19:20.469] - resignal: FALSE
[10:19:20.470] - force: TRUE
[10:19:20.470] - relayed: [n=1] TRUE
[10:19:20.470] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.470] - relayed: [n=1] TRUE
[10:19:20.470] - queued futures: [n=1] TRUE
[10:19:20.470] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.470] resolve() on list ... DONE
[10:19:20.470]  - Number of value chunks collected: 1
[10:19:20.470] Resolving 1 futures (chunks) ... DONE
[10:19:20.470] Reducing values from 1 chunks ...
[10:19:20.470]  - Number of values collected after concatenation: 4
[10:19:20.471]  - Number of values expected: 4
[10:19:20.471] Reducing values from 1 chunks ... DONE
[10:19:20.471] future_mapply() ... DONE
[10:19:20.471] future_mapply() ...
[10:19:20.471] Number of chunks: 1
[10:19:20.471] getGlobalsAndPackagesXApply() ...
[10:19:20.471]  - future.globals: TRUE
[10:19:20.471] getGlobalsAndPackages() ...
[10:19:20.471] Searching for globals...
[10:19:20.473] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:19:20.473] Searching for globals ... DONE
[10:19:20.473] Resolving globals: FALSE
[10:19:20.473] The total size of the 1 globals is 414 bytes (414 bytes)
[10:19:20.475] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:19:20.475] - globals: [1] ‘FUN’
[10:19:20.475] 
[10:19:20.476] getGlobalsAndPackages() ... DONE
[10:19:20.476]  - globals found/used: [n=1] ‘FUN’
[10:19:20.476]  - needed namespaces: [n=0] 
[10:19:20.476] Finding globals ... DONE
[10:19:20.476] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.476] List of 2
[10:19:20.476]  $ ...future.FUN:function (x, y)  
[10:19:20.476]  $ MoreArgs     : NULL
[10:19:20.476]  - attr(*, "where")=List of 2
[10:19:20.476]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.476]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.476]  - attr(*, "resolved")= logi FALSE
[10:19:20.476]  - attr(*, "total_size")= num NA
[10:19:20.478] Packages to be attached in all futures: [n=0] 
[10:19:20.479] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.479] Number of futures (= number of chunks): 1
[10:19:20.479] Launching 1 futures (chunks) ...
[10:19:20.479] Chunk #1 of 1 ...
[10:19:20.479]  - Finding globals in '...' for chunk #1 ...
[10:19:20.479] getGlobalsAndPackages() ...
[10:19:20.479] Searching for globals...
[10:19:20.480] 
[10:19:20.480] Searching for globals ... DONE
[10:19:20.480] - globals: [0] <none>
[10:19:20.480] getGlobalsAndPackages() ... DONE
[10:19:20.480]    + additional globals found: [n=0] 
[10:19:20.480]    + additional namespaces needed: [n=0] 
[10:19:20.480]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.480]  - seeds: <none>
[10:19:20.480]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.480] getGlobalsAndPackages() ...
[10:19:20.480] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.481] Resolving globals: FALSE
[10:19:20.481] The total size of the 5 globals is 745 bytes (745 bytes)
[10:19:20.481] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 745 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (250 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.481] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.482] 
[10:19:20.482] getGlobalsAndPackages() ... DONE
[10:19:20.482] run() for ‘Future’ ...
[10:19:20.482] - state: ‘created’
[10:19:20.482] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.482] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.483]   - Field: ‘label’
[10:19:20.483]   - Field: ‘local’
[10:19:20.483]   - Field: ‘owner’
[10:19:20.483]   - Field: ‘envir’
[10:19:20.483]   - Field: ‘packages’
[10:19:20.483]   - Field: ‘gc’
[10:19:20.483]   - Field: ‘conditions’
[10:19:20.483]   - Field: ‘expr’
[10:19:20.483]   - Field: ‘uuid’
[10:19:20.483]   - Field: ‘seed’
[10:19:20.483]   - Field: ‘version’
[10:19:20.483]   - Field: ‘result’
[10:19:20.484]   - Field: ‘asynchronous’
[10:19:20.484]   - Field: ‘calls’
[10:19:20.484]   - Field: ‘globals’
[10:19:20.484]   - Field: ‘stdout’
[10:19:20.484]   - Field: ‘earlySignal’
[10:19:20.484]   - Field: ‘lazy’
[10:19:20.484]   - Field: ‘state’
[10:19:20.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.484] - Launch lazy future ...
[10:19:20.484] Packages needed by the future expression (n = 0): <none>
[10:19:20.485] Packages needed by future strategies (n = 0): <none>
[10:19:20.485] {
[10:19:20.485]     {
[10:19:20.485]         {
[10:19:20.485]             ...future.startTime <- base::Sys.time()
[10:19:20.485]             {
[10:19:20.485]                 {
[10:19:20.485]                   {
[10:19:20.485]                     base::local({
[10:19:20.485]                       has_future <- base::requireNamespace("future", 
[10:19:20.485]                         quietly = TRUE)
[10:19:20.485]                       if (has_future) {
[10:19:20.485]                         ns <- base::getNamespace("future")
[10:19:20.485]                         version <- ns[[".package"]][["version"]]
[10:19:20.485]                         if (is.null(version)) 
[10:19:20.485]                           version <- utils::packageVersion("future")
[10:19:20.485]                       }
[10:19:20.485]                       else {
[10:19:20.485]                         version <- NULL
[10:19:20.485]                       }
[10:19:20.485]                       if (!has_future || version < "1.8.0") {
[10:19:20.485]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.485]                           "", base::R.version$version.string), 
[10:19:20.485]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.485]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.485]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.485]                             "release", "version")], collapse = " "), 
[10:19:20.485]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.485]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.485]                           info)
[10:19:20.485]                         info <- base::paste(info, collapse = "; ")
[10:19:20.485]                         if (!has_future) {
[10:19:20.485]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.485]                             info)
[10:19:20.485]                         }
[10:19:20.485]                         else {
[10:19:20.485]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.485]                             info, version)
[10:19:20.485]                         }
[10:19:20.485]                         base::stop(msg)
[10:19:20.485]                       }
[10:19:20.485]                     })
[10:19:20.485]                   }
[10:19:20.485]                   ...future.strategy.old <- future::plan("list")
[10:19:20.485]                   options(future.plan = NULL)
[10:19:20.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.485]                 }
[10:19:20.485]                 ...future.workdir <- getwd()
[10:19:20.485]             }
[10:19:20.485]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.485]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.485]         }
[10:19:20.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.485]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.485]             base::names(...future.oldOptions))
[10:19:20.485]     }
[10:19:20.485]     if (FALSE) {
[10:19:20.485]     }
[10:19:20.485]     else {
[10:19:20.485]         if (TRUE) {
[10:19:20.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.485]                 open = "w")
[10:19:20.485]         }
[10:19:20.485]         else {
[10:19:20.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.485]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.485]         }
[10:19:20.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.485]             base::sink(type = "output", split = FALSE)
[10:19:20.485]             base::close(...future.stdout)
[10:19:20.485]         }, add = TRUE)
[10:19:20.485]     }
[10:19:20.485]     ...future.frame <- base::sys.nframe()
[10:19:20.485]     ...future.conditions <- base::list()
[10:19:20.485]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.485]     if (FALSE) {
[10:19:20.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.485]     }
[10:19:20.485]     ...future.result <- base::tryCatch({
[10:19:20.485]         base::withCallingHandlers({
[10:19:20.485]             ...future.value <- base::withVisible(base::local({
[10:19:20.485]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.485]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.485]                   ...future.globals.maxSize)) {
[10:19:20.485]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.485]                   on.exit(options(oopts), add = TRUE)
[10:19:20.485]                 }
[10:19:20.485]                 {
[10:19:20.485]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.485]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.485]                     USE.NAMES = FALSE)
[10:19:20.485]                   do.call(mapply, args = args)
[10:19:20.485]                 }
[10:19:20.485]             }))
[10:19:20.485]             future::FutureResult(value = ...future.value$value, 
[10:19:20.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.485]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.485]                     ...future.globalenv.names))
[10:19:20.485]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.485]         }, condition = base::local({
[10:19:20.485]             c <- base::c
[10:19:20.485]             inherits <- base::inherits
[10:19:20.485]             invokeRestart <- base::invokeRestart
[10:19:20.485]             length <- base::length
[10:19:20.485]             list <- base::list
[10:19:20.485]             seq.int <- base::seq.int
[10:19:20.485]             signalCondition <- base::signalCondition
[10:19:20.485]             sys.calls <- base::sys.calls
[10:19:20.485]             `[[` <- base::`[[`
[10:19:20.485]             `+` <- base::`+`
[10:19:20.485]             `<<-` <- base::`<<-`
[10:19:20.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.485]                   3L)]
[10:19:20.485]             }
[10:19:20.485]             function(cond) {
[10:19:20.485]                 is_error <- inherits(cond, "error")
[10:19:20.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.485]                   NULL)
[10:19:20.485]                 if (is_error) {
[10:19:20.485]                   sessionInformation <- function() {
[10:19:20.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.485]                       search = base::search(), system = base::Sys.info())
[10:19:20.485]                   }
[10:19:20.485]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.485]                     cond$call), session = sessionInformation(), 
[10:19:20.485]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.485]                   signalCondition(cond)
[10:19:20.485]                 }
[10:19:20.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.485]                 "immediateCondition"))) {
[10:19:20.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.485]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.485]                   if (TRUE && !signal) {
[10:19:20.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.485]                     {
[10:19:20.485]                       inherits <- base::inherits
[10:19:20.485]                       invokeRestart <- base::invokeRestart
[10:19:20.485]                       is.null <- base::is.null
[10:19:20.485]                       muffled <- FALSE
[10:19:20.485]                       if (inherits(cond, "message")) {
[10:19:20.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.485]                         if (muffled) 
[10:19:20.485]                           invokeRestart("muffleMessage")
[10:19:20.485]                       }
[10:19:20.485]                       else if (inherits(cond, "warning")) {
[10:19:20.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.485]                         if (muffled) 
[10:19:20.485]                           invokeRestart("muffleWarning")
[10:19:20.485]                       }
[10:19:20.485]                       else if (inherits(cond, "condition")) {
[10:19:20.485]                         if (!is.null(pattern)) {
[10:19:20.485]                           computeRestarts <- base::computeRestarts
[10:19:20.485]                           grepl <- base::grepl
[10:19:20.485]                           restarts <- computeRestarts(cond)
[10:19:20.485]                           for (restart in restarts) {
[10:19:20.485]                             name <- restart$name
[10:19:20.485]                             if (is.null(name)) 
[10:19:20.485]                               next
[10:19:20.485]                             if (!grepl(pattern, name)) 
[10:19:20.485]                               next
[10:19:20.485]                             invokeRestart(restart)
[10:19:20.485]                             muffled <- TRUE
[10:19:20.485]                             break
[10:19:20.485]                           }
[10:19:20.485]                         }
[10:19:20.485]                       }
[10:19:20.485]                       invisible(muffled)
[10:19:20.485]                     }
[10:19:20.485]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.485]                   }
[10:19:20.485]                 }
[10:19:20.485]                 else {
[10:19:20.485]                   if (TRUE) {
[10:19:20.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.485]                     {
[10:19:20.485]                       inherits <- base::inherits
[10:19:20.485]                       invokeRestart <- base::invokeRestart
[10:19:20.485]                       is.null <- base::is.null
[10:19:20.485]                       muffled <- FALSE
[10:19:20.485]                       if (inherits(cond, "message")) {
[10:19:20.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.485]                         if (muffled) 
[10:19:20.485]                           invokeRestart("muffleMessage")
[10:19:20.485]                       }
[10:19:20.485]                       else if (inherits(cond, "warning")) {
[10:19:20.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.485]                         if (muffled) 
[10:19:20.485]                           invokeRestart("muffleWarning")
[10:19:20.485]                       }
[10:19:20.485]                       else if (inherits(cond, "condition")) {
[10:19:20.485]                         if (!is.null(pattern)) {
[10:19:20.485]                           computeRestarts <- base::computeRestarts
[10:19:20.485]                           grepl <- base::grepl
[10:19:20.485]                           restarts <- computeRestarts(cond)
[10:19:20.485]                           for (restart in restarts) {
[10:19:20.485]                             name <- restart$name
[10:19:20.485]                             if (is.null(name)) 
[10:19:20.485]                               next
[10:19:20.485]                             if (!grepl(pattern, name)) 
[10:19:20.485]                               next
[10:19:20.485]                             invokeRestart(restart)
[10:19:20.485]                             muffled <- TRUE
[10:19:20.485]                             break
[10:19:20.485]                           }
[10:19:20.485]                         }
[10:19:20.485]                       }
[10:19:20.485]                       invisible(muffled)
[10:19:20.485]                     }
[10:19:20.485]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.485]                   }
[10:19:20.485]                 }
[10:19:20.485]             }
[10:19:20.485]         }))
[10:19:20.485]     }, error = function(ex) {
[10:19:20.485]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.485]                 ...future.rng), started = ...future.startTime, 
[10:19:20.485]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.485]             version = "1.8"), class = "FutureResult")
[10:19:20.485]     }, finally = {
[10:19:20.485]         if (!identical(...future.workdir, getwd())) 
[10:19:20.485]             setwd(...future.workdir)
[10:19:20.485]         {
[10:19:20.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.485]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.485]             }
[10:19:20.485]             base::options(...future.oldOptions)
[10:19:20.485]             if (.Platform$OS.type == "windows") {
[10:19:20.485]                 old_names <- names(...future.oldEnvVars)
[10:19:20.485]                 envs <- base::Sys.getenv()
[10:19:20.485]                 names <- names(envs)
[10:19:20.485]                 common <- intersect(names, old_names)
[10:19:20.485]                 added <- setdiff(names, old_names)
[10:19:20.485]                 removed <- setdiff(old_names, names)
[10:19:20.485]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.485]                   envs[common]]
[10:19:20.485]                 NAMES <- toupper(changed)
[10:19:20.485]                 args <- list()
[10:19:20.485]                 for (kk in seq_along(NAMES)) {
[10:19:20.485]                   name <- changed[[kk]]
[10:19:20.485]                   NAME <- NAMES[[kk]]
[10:19:20.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.485]                     next
[10:19:20.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.485]                 }
[10:19:20.485]                 NAMES <- toupper(added)
[10:19:20.485]                 for (kk in seq_along(NAMES)) {
[10:19:20.485]                   name <- added[[kk]]
[10:19:20.485]                   NAME <- NAMES[[kk]]
[10:19:20.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.485]                     next
[10:19:20.485]                   args[[name]] <- ""
[10:19:20.485]                 }
[10:19:20.485]                 NAMES <- toupper(removed)
[10:19:20.485]                 for (kk in seq_along(NAMES)) {
[10:19:20.485]                   name <- removed[[kk]]
[10:19:20.485]                   NAME <- NAMES[[kk]]
[10:19:20.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.485]                     next
[10:19:20.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.485]                 }
[10:19:20.485]                 if (length(args) > 0) 
[10:19:20.485]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.485]             }
[10:19:20.485]             else {
[10:19:20.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.485]             }
[10:19:20.485]             {
[10:19:20.485]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.485]                   0L) {
[10:19:20.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.485]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.485]                   base::options(opts)
[10:19:20.485]                 }
[10:19:20.485]                 {
[10:19:20.485]                   {
[10:19:20.485]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.485]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.485]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.485]                       inherits = FALSE)
[10:19:20.485]                     NULL
[10:19:20.485]                   }
[10:19:20.485]                   options(future.plan = NULL)
[10:19:20.485]                   if (is.na(NA_character_)) 
[10:19:20.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.485]                     .init = FALSE)
[10:19:20.485]                 }
[10:19:20.485]             }
[10:19:20.485]         }
[10:19:20.485]     })
[10:19:20.485]     if (TRUE) {
[10:19:20.485]         base::sink(type = "output", split = FALSE)
[10:19:20.485]         if (TRUE) {
[10:19:20.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.485]         }
[10:19:20.485]         else {
[10:19:20.485]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.485]         }
[10:19:20.485]         base::close(...future.stdout)
[10:19:20.485]         ...future.stdout <- NULL
[10:19:20.485]     }
[10:19:20.485]     ...future.result$conditions <- ...future.conditions
[10:19:20.485]     ...future.result$finished <- base::Sys.time()
[10:19:20.485]     ...future.result
[10:19:20.485] }
[10:19:20.487] assign_globals() ...
[10:19:20.487] List of 5
[10:19:20.487]  $ ...future.FUN            :function (x, y)  
[10:19:20.487]  $ MoreArgs                 : NULL
[10:19:20.487]  $ ...future.elements_ii    :List of 2
[10:19:20.487]   ..$ :List of 3
[10:19:20.487]   .. ..$ a: num 1
[10:19:20.487]   .. ..$ b: num 2
[10:19:20.487]   .. ..$ c: num 3
[10:19:20.487]   ..$ :List of 3
[10:19:20.487]   .. ..$ A: num 10
[10:19:20.487]   .. ..$ B: num 0
[10:19:20.487]   .. ..$ C: num -10
[10:19:20.487]  $ ...future.seeds_ii       : NULL
[10:19:20.487]  $ ...future.globals.maxSize: NULL
[10:19:20.487]  - attr(*, "where")=List of 5
[10:19:20.487]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.487]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.487]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.487]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.487]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.487]  - attr(*, "resolved")= logi FALSE
[10:19:20.487]  - attr(*, "total_size")= num 745
[10:19:20.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.487]  - attr(*, "already-done")= logi TRUE
[10:19:20.493] - reassign environment for ‘...future.FUN’
[10:19:20.493] - copied ‘...future.FUN’ to environment
[10:19:20.493] - copied ‘MoreArgs’ to environment
[10:19:20.493] - copied ‘...future.elements_ii’ to environment
[10:19:20.493] - copied ‘...future.seeds_ii’ to environment
[10:19:20.493] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.493] assign_globals() ... done
[10:19:20.493] plan(): Setting new future strategy stack:
[10:19:20.494] List of future strategies:
[10:19:20.494] 1. sequential:
[10:19:20.494]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.494]    - tweaked: FALSE
[10:19:20.494]    - call: NULL
[10:19:20.494] plan(): nbrOfWorkers() = 1
[10:19:20.495] plan(): Setting new future strategy stack:
[10:19:20.495] List of future strategies:
[10:19:20.495] 1. sequential:
[10:19:20.495]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.495]    - tweaked: FALSE
[10:19:20.495]    - call: plan(strategy)
[10:19:20.495] plan(): nbrOfWorkers() = 1
[10:19:20.495] SequentialFuture started (and completed)
[10:19:20.496] - Launch lazy future ... done
[10:19:20.496] run() for ‘SequentialFuture’ ... done
[10:19:20.496] Created future:
[10:19:20.496] SequentialFuture:
[10:19:20.496] Label: ‘future_mapply-1’
[10:19:20.496] Expression:
[10:19:20.496] {
[10:19:20.496]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.496]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.496]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.496]         on.exit(options(oopts), add = TRUE)
[10:19:20.496]     }
[10:19:20.496]     {
[10:19:20.496]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.496]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.496]         do.call(mapply, args = args)
[10:19:20.496]     }
[10:19:20.496] }
[10:19:20.496] Lazy evaluation: FALSE
[10:19:20.496] Asynchronous evaluation: FALSE
[10:19:20.496] Local evaluation: TRUE
[10:19:20.496] Environment: R_GlobalEnv
[10:19:20.496] Capture standard output: TRUE
[10:19:20.496] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.496] Globals: 5 objects totaling 745 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 250 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.496] Packages: <none>
[10:19:20.496] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.496] Resolved: TRUE
[10:19:20.496] Value: 103 bytes of class ‘list’
[10:19:20.496] Early signaling: FALSE
[10:19:20.496] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.496] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.497] Chunk #1 of 1 ... DONE
[10:19:20.497] Launching 1 futures (chunks) ... DONE
[10:19:20.497] Resolving 1 futures (chunks) ...
[10:19:20.497] resolve() on list ...
[10:19:20.497]  recursive: 0
[10:19:20.497]  length: 1
[10:19:20.497] 
[10:19:20.497] resolved() for ‘SequentialFuture’ ...
[10:19:20.497] - state: ‘finished’
[10:19:20.497] - run: TRUE
[10:19:20.497] - result: ‘FutureResult’
[10:19:20.498] resolved() for ‘SequentialFuture’ ... done
[10:19:20.498] Future #1
[10:19:20.498] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.499] - nx: 1
[10:19:20.500] - relay: TRUE
[10:19:20.500] - stdout: TRUE
[10:19:20.500] - signal: TRUE
[10:19:20.500] - resignal: FALSE
[10:19:20.500] - force: TRUE
[10:19:20.500] - relayed: [n=1] FALSE
[10:19:20.500] - queued futures: [n=1] FALSE
[10:19:20.500]  - until=1
[10:19:20.500]  - relaying element #1
[10:19:20.500] - relayed: [n=1] TRUE
[10:19:20.500] - queued futures: [n=1] TRUE
[10:19:20.501] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.501]  length: 0 (resolved future 1)
[10:19:20.501] Relaying remaining futures
[10:19:20.501] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.501] - nx: 1
[10:19:20.501] - relay: TRUE
[10:19:20.501] - stdout: TRUE
[10:19:20.501] - signal: TRUE
[10:19:20.501] - resignal: FALSE
[10:19:20.501] - force: TRUE
[10:19:20.501] - relayed: [n=1] TRUE
[10:19:20.501] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.502] - relayed: [n=1] TRUE
[10:19:20.502] - queued futures: [n=1] TRUE
[10:19:20.502] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.502] resolve() on list ... DONE
[10:19:20.502]  - Number of value chunks collected: 1
[10:19:20.502] Resolving 1 futures (chunks) ... DONE
[10:19:20.502] Reducing values from 1 chunks ...
[10:19:20.502]  - Number of values collected after concatenation: 3
[10:19:20.502]  - Number of values expected: 3
[10:19:20.502] Reducing values from 1 chunks ... DONE
[10:19:20.502] future_mapply() ... DONE
- future_.mapply()
[10:19:20.503] future_mapply() ...
[10:19:20.503] Number of chunks: 1
[10:19:20.503] getGlobalsAndPackagesXApply() ...
[10:19:20.503]  - future.globals: TRUE
[10:19:20.504] getGlobalsAndPackages() ...
[10:19:20.504] Searching for globals...
[10:19:20.505] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:19:20.505] Searching for globals ... DONE
[10:19:20.505] Resolving globals: FALSE
[10:19:20.505] The total size of the 1 globals is 414 bytes (414 bytes)
[10:19:20.506] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:19:20.506] - globals: [1] ‘FUN’
[10:19:20.506] 
[10:19:20.506] getGlobalsAndPackages() ... DONE
[10:19:20.506]  - globals found/used: [n=1] ‘FUN’
[10:19:20.506]  - needed namespaces: [n=0] 
[10:19:20.506] Finding globals ... DONE
[10:19:20.506] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.507] List of 2
[10:19:20.507]  $ ...future.FUN:function (x, y)  
[10:19:20.507]  $ MoreArgs     : list()
[10:19:20.507]  - attr(*, "where")=List of 2
[10:19:20.507]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.507]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.507]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.507]  - attr(*, "resolved")= logi FALSE
[10:19:20.507]  - attr(*, "total_size")= num NA
[10:19:20.509] Packages to be attached in all futures: [n=0] 
[10:19:20.509] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.509] Number of futures (= number of chunks): 1
[10:19:20.509] Launching 1 futures (chunks) ...
[10:19:20.509] Chunk #1 of 1 ...
[10:19:20.509]  - Finding globals in '...' for chunk #1 ...
[10:19:20.510] getGlobalsAndPackages() ...
[10:19:20.510] Searching for globals...
[10:19:20.510] 
[10:19:20.510] Searching for globals ... DONE
[10:19:20.510] - globals: [0] <none>
[10:19:20.510] getGlobalsAndPackages() ... DONE
[10:19:20.510]    + additional globals found: [n=0] 
[10:19:20.510]    + additional namespaces needed: [n=0] 
[10:19:20.510]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.510]  - seeds: <none>
[10:19:20.511]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.511] getGlobalsAndPackages() ...
[10:19:20.511] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.511] Resolving globals: FALSE
[10:19:20.511] The total size of the 5 globals is 749 bytes (749 bytes)
[10:19:20.512] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 749 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (250 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:20.512] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.512] 
[10:19:20.512] getGlobalsAndPackages() ... DONE
[10:19:20.512] run() for ‘Future’ ...
[10:19:20.512] - state: ‘created’
[10:19:20.512] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.513] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.513]   - Field: ‘label’
[10:19:20.513]   - Field: ‘local’
[10:19:20.513]   - Field: ‘owner’
[10:19:20.513]   - Field: ‘envir’
[10:19:20.513]   - Field: ‘packages’
[10:19:20.513]   - Field: ‘gc’
[10:19:20.513]   - Field: ‘conditions’
[10:19:20.513]   - Field: ‘expr’
[10:19:20.514]   - Field: ‘uuid’
[10:19:20.514]   - Field: ‘seed’
[10:19:20.514]   - Field: ‘version’
[10:19:20.514]   - Field: ‘result’
[10:19:20.514]   - Field: ‘asynchronous’
[10:19:20.514]   - Field: ‘calls’
[10:19:20.514]   - Field: ‘globals’
[10:19:20.514]   - Field: ‘stdout’
[10:19:20.514]   - Field: ‘earlySignal’
[10:19:20.514]   - Field: ‘lazy’
[10:19:20.514]   - Field: ‘state’
[10:19:20.514] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.515] - Launch lazy future ...
[10:19:20.515] Packages needed by the future expression (n = 0): <none>
[10:19:20.515] Packages needed by future strategies (n = 0): <none>
[10:19:20.515] {
[10:19:20.515]     {
[10:19:20.515]         {
[10:19:20.515]             ...future.startTime <- base::Sys.time()
[10:19:20.515]             {
[10:19:20.515]                 {
[10:19:20.515]                   {
[10:19:20.515]                     base::local({
[10:19:20.515]                       has_future <- base::requireNamespace("future", 
[10:19:20.515]                         quietly = TRUE)
[10:19:20.515]                       if (has_future) {
[10:19:20.515]                         ns <- base::getNamespace("future")
[10:19:20.515]                         version <- ns[[".package"]][["version"]]
[10:19:20.515]                         if (is.null(version)) 
[10:19:20.515]                           version <- utils::packageVersion("future")
[10:19:20.515]                       }
[10:19:20.515]                       else {
[10:19:20.515]                         version <- NULL
[10:19:20.515]                       }
[10:19:20.515]                       if (!has_future || version < "1.8.0") {
[10:19:20.515]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.515]                           "", base::R.version$version.string), 
[10:19:20.515]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.515]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.515]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.515]                             "release", "version")], collapse = " "), 
[10:19:20.515]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.515]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.515]                           info)
[10:19:20.515]                         info <- base::paste(info, collapse = "; ")
[10:19:20.515]                         if (!has_future) {
[10:19:20.515]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.515]                             info)
[10:19:20.515]                         }
[10:19:20.515]                         else {
[10:19:20.515]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.515]                             info, version)
[10:19:20.515]                         }
[10:19:20.515]                         base::stop(msg)
[10:19:20.515]                       }
[10:19:20.515]                     })
[10:19:20.515]                   }
[10:19:20.515]                   ...future.strategy.old <- future::plan("list")
[10:19:20.515]                   options(future.plan = NULL)
[10:19:20.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.515]                 }
[10:19:20.515]                 ...future.workdir <- getwd()
[10:19:20.515]             }
[10:19:20.515]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.515]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.515]         }
[10:19:20.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.515]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.515]             base::names(...future.oldOptions))
[10:19:20.515]     }
[10:19:20.515]     if (FALSE) {
[10:19:20.515]     }
[10:19:20.515]     else {
[10:19:20.515]         if (TRUE) {
[10:19:20.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.515]                 open = "w")
[10:19:20.515]         }
[10:19:20.515]         else {
[10:19:20.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.515]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.515]         }
[10:19:20.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.515]             base::sink(type = "output", split = FALSE)
[10:19:20.515]             base::close(...future.stdout)
[10:19:20.515]         }, add = TRUE)
[10:19:20.515]     }
[10:19:20.515]     ...future.frame <- base::sys.nframe()
[10:19:20.515]     ...future.conditions <- base::list()
[10:19:20.515]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.515]     if (FALSE) {
[10:19:20.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.515]     }
[10:19:20.515]     ...future.result <- base::tryCatch({
[10:19:20.515]         base::withCallingHandlers({
[10:19:20.515]             ...future.value <- base::withVisible(base::local({
[10:19:20.515]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.515]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.515]                   ...future.globals.maxSize)) {
[10:19:20.515]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.515]                   on.exit(options(oopts), add = TRUE)
[10:19:20.515]                 }
[10:19:20.515]                 {
[10:19:20.515]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.515]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.515]                     USE.NAMES = FALSE)
[10:19:20.515]                   do.call(mapply, args = args)
[10:19:20.515]                 }
[10:19:20.515]             }))
[10:19:20.515]             future::FutureResult(value = ...future.value$value, 
[10:19:20.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.515]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.515]                     ...future.globalenv.names))
[10:19:20.515]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.515]         }, condition = base::local({
[10:19:20.515]             c <- base::c
[10:19:20.515]             inherits <- base::inherits
[10:19:20.515]             invokeRestart <- base::invokeRestart
[10:19:20.515]             length <- base::length
[10:19:20.515]             list <- base::list
[10:19:20.515]             seq.int <- base::seq.int
[10:19:20.515]             signalCondition <- base::signalCondition
[10:19:20.515]             sys.calls <- base::sys.calls
[10:19:20.515]             `[[` <- base::`[[`
[10:19:20.515]             `+` <- base::`+`
[10:19:20.515]             `<<-` <- base::`<<-`
[10:19:20.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.515]                   3L)]
[10:19:20.515]             }
[10:19:20.515]             function(cond) {
[10:19:20.515]                 is_error <- inherits(cond, "error")
[10:19:20.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.515]                   NULL)
[10:19:20.515]                 if (is_error) {
[10:19:20.515]                   sessionInformation <- function() {
[10:19:20.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.515]                       search = base::search(), system = base::Sys.info())
[10:19:20.515]                   }
[10:19:20.515]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.515]                     cond$call), session = sessionInformation(), 
[10:19:20.515]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.515]                   signalCondition(cond)
[10:19:20.515]                 }
[10:19:20.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.515]                 "immediateCondition"))) {
[10:19:20.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.515]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.515]                   if (TRUE && !signal) {
[10:19:20.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.515]                     {
[10:19:20.515]                       inherits <- base::inherits
[10:19:20.515]                       invokeRestart <- base::invokeRestart
[10:19:20.515]                       is.null <- base::is.null
[10:19:20.515]                       muffled <- FALSE
[10:19:20.515]                       if (inherits(cond, "message")) {
[10:19:20.515]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.515]                         if (muffled) 
[10:19:20.515]                           invokeRestart("muffleMessage")
[10:19:20.515]                       }
[10:19:20.515]                       else if (inherits(cond, "warning")) {
[10:19:20.515]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.515]                         if (muffled) 
[10:19:20.515]                           invokeRestart("muffleWarning")
[10:19:20.515]                       }
[10:19:20.515]                       else if (inherits(cond, "condition")) {
[10:19:20.515]                         if (!is.null(pattern)) {
[10:19:20.515]                           computeRestarts <- base::computeRestarts
[10:19:20.515]                           grepl <- base::grepl
[10:19:20.515]                           restarts <- computeRestarts(cond)
[10:19:20.515]                           for (restart in restarts) {
[10:19:20.515]                             name <- restart$name
[10:19:20.515]                             if (is.null(name)) 
[10:19:20.515]                               next
[10:19:20.515]                             if (!grepl(pattern, name)) 
[10:19:20.515]                               next
[10:19:20.515]                             invokeRestart(restart)
[10:19:20.515]                             muffled <- TRUE
[10:19:20.515]                             break
[10:19:20.515]                           }
[10:19:20.515]                         }
[10:19:20.515]                       }
[10:19:20.515]                       invisible(muffled)
[10:19:20.515]                     }
[10:19:20.515]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.515]                   }
[10:19:20.515]                 }
[10:19:20.515]                 else {
[10:19:20.515]                   if (TRUE) {
[10:19:20.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.515]                     {
[10:19:20.515]                       inherits <- base::inherits
[10:19:20.515]                       invokeRestart <- base::invokeRestart
[10:19:20.515]                       is.null <- base::is.null
[10:19:20.515]                       muffled <- FALSE
[10:19:20.515]                       if (inherits(cond, "message")) {
[10:19:20.515]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.515]                         if (muffled) 
[10:19:20.515]                           invokeRestart("muffleMessage")
[10:19:20.515]                       }
[10:19:20.515]                       else if (inherits(cond, "warning")) {
[10:19:20.515]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.515]                         if (muffled) 
[10:19:20.515]                           invokeRestart("muffleWarning")
[10:19:20.515]                       }
[10:19:20.515]                       else if (inherits(cond, "condition")) {
[10:19:20.515]                         if (!is.null(pattern)) {
[10:19:20.515]                           computeRestarts <- base::computeRestarts
[10:19:20.515]                           grepl <- base::grepl
[10:19:20.515]                           restarts <- computeRestarts(cond)
[10:19:20.515]                           for (restart in restarts) {
[10:19:20.515]                             name <- restart$name
[10:19:20.515]                             if (is.null(name)) 
[10:19:20.515]                               next
[10:19:20.515]                             if (!grepl(pattern, name)) 
[10:19:20.515]                               next
[10:19:20.515]                             invokeRestart(restart)
[10:19:20.515]                             muffled <- TRUE
[10:19:20.515]                             break
[10:19:20.515]                           }
[10:19:20.515]                         }
[10:19:20.515]                       }
[10:19:20.515]                       invisible(muffled)
[10:19:20.515]                     }
[10:19:20.515]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.515]                   }
[10:19:20.515]                 }
[10:19:20.515]             }
[10:19:20.515]         }))
[10:19:20.515]     }, error = function(ex) {
[10:19:20.515]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.515]                 ...future.rng), started = ...future.startTime, 
[10:19:20.515]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.515]             version = "1.8"), class = "FutureResult")
[10:19:20.515]     }, finally = {
[10:19:20.515]         if (!identical(...future.workdir, getwd())) 
[10:19:20.515]             setwd(...future.workdir)
[10:19:20.515]         {
[10:19:20.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.515]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.515]             }
[10:19:20.515]             base::options(...future.oldOptions)
[10:19:20.515]             if (.Platform$OS.type == "windows") {
[10:19:20.515]                 old_names <- names(...future.oldEnvVars)
[10:19:20.515]                 envs <- base::Sys.getenv()
[10:19:20.515]                 names <- names(envs)
[10:19:20.515]                 common <- intersect(names, old_names)
[10:19:20.515]                 added <- setdiff(names, old_names)
[10:19:20.515]                 removed <- setdiff(old_names, names)
[10:19:20.515]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.515]                   envs[common]]
[10:19:20.515]                 NAMES <- toupper(changed)
[10:19:20.515]                 args <- list()
[10:19:20.515]                 for (kk in seq_along(NAMES)) {
[10:19:20.515]                   name <- changed[[kk]]
[10:19:20.515]                   NAME <- NAMES[[kk]]
[10:19:20.515]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.515]                     next
[10:19:20.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.515]                 }
[10:19:20.515]                 NAMES <- toupper(added)
[10:19:20.515]                 for (kk in seq_along(NAMES)) {
[10:19:20.515]                   name <- added[[kk]]
[10:19:20.515]                   NAME <- NAMES[[kk]]
[10:19:20.515]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.515]                     next
[10:19:20.515]                   args[[name]] <- ""
[10:19:20.515]                 }
[10:19:20.515]                 NAMES <- toupper(removed)
[10:19:20.515]                 for (kk in seq_along(NAMES)) {
[10:19:20.515]                   name <- removed[[kk]]
[10:19:20.515]                   NAME <- NAMES[[kk]]
[10:19:20.515]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.515]                     next
[10:19:20.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.515]                 }
[10:19:20.515]                 if (length(args) > 0) 
[10:19:20.515]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.515]             }
[10:19:20.515]             else {
[10:19:20.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.515]             }
[10:19:20.515]             {
[10:19:20.515]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.515]                   0L) {
[10:19:20.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.515]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.515]                   base::options(opts)
[10:19:20.515]                 }
[10:19:20.515]                 {
[10:19:20.515]                   {
[10:19:20.515]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.515]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.515]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.515]                       inherits = FALSE)
[10:19:20.515]                     NULL
[10:19:20.515]                   }
[10:19:20.515]                   options(future.plan = NULL)
[10:19:20.515]                   if (is.na(NA_character_)) 
[10:19:20.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.515]                     .init = FALSE)
[10:19:20.515]                 }
[10:19:20.515]             }
[10:19:20.515]         }
[10:19:20.515]     })
[10:19:20.515]     if (TRUE) {
[10:19:20.515]         base::sink(type = "output", split = FALSE)
[10:19:20.515]         if (TRUE) {
[10:19:20.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.515]         }
[10:19:20.515]         else {
[10:19:20.515]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.515]         }
[10:19:20.515]         base::close(...future.stdout)
[10:19:20.515]         ...future.stdout <- NULL
[10:19:20.515]     }
[10:19:20.515]     ...future.result$conditions <- ...future.conditions
[10:19:20.515]     ...future.result$finished <- base::Sys.time()
[10:19:20.515]     ...future.result
[10:19:20.515] }
[10:19:20.517] assign_globals() ...
[10:19:20.517] List of 5
[10:19:20.517]  $ ...future.FUN            :function (x, y)  
[10:19:20.517]  $ MoreArgs                 : list()
[10:19:20.517]  $ ...future.elements_ii    :List of 2
[10:19:20.517]   ..$ :List of 3
[10:19:20.517]   .. ..$ a: num 1
[10:19:20.517]   .. ..$ b: num 2
[10:19:20.517]   .. ..$ c: num 3
[10:19:20.517]   ..$ :List of 3
[10:19:20.517]   .. ..$ A: num 10
[10:19:20.517]   .. ..$ B: num 0
[10:19:20.517]   .. ..$ C: num -10
[10:19:20.517]  $ ...future.seeds_ii       : NULL
[10:19:20.517]  $ ...future.globals.maxSize: NULL
[10:19:20.517]  - attr(*, "where")=List of 5
[10:19:20.517]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.517]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.517]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.517]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.517]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.517]  - attr(*, "resolved")= logi FALSE
[10:19:20.517]  - attr(*, "total_size")= num 749
[10:19:20.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.517]  - attr(*, "already-done")= logi TRUE
[10:19:20.525] - reassign environment for ‘...future.FUN’
[10:19:20.525] - copied ‘...future.FUN’ to environment
[10:19:20.525] - copied ‘MoreArgs’ to environment
[10:19:20.525] - copied ‘...future.elements_ii’ to environment
[10:19:20.525] - copied ‘...future.seeds_ii’ to environment
[10:19:20.525] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.525] assign_globals() ... done
[10:19:20.526] plan(): Setting new future strategy stack:
[10:19:20.526] List of future strategies:
[10:19:20.526] 1. sequential:
[10:19:20.526]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.526]    - tweaked: FALSE
[10:19:20.526]    - call: NULL
[10:19:20.526] plan(): nbrOfWorkers() = 1
[10:19:20.527] plan(): Setting new future strategy stack:
[10:19:20.527] List of future strategies:
[10:19:20.527] 1. sequential:
[10:19:20.527]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.527]    - tweaked: FALSE
[10:19:20.527]    - call: plan(strategy)
[10:19:20.527] plan(): nbrOfWorkers() = 1
[10:19:20.528] SequentialFuture started (and completed)
[10:19:20.528] - Launch lazy future ... done
[10:19:20.528] run() for ‘SequentialFuture’ ... done
[10:19:20.528] Created future:
[10:19:20.528] SequentialFuture:
[10:19:20.528] Label: ‘future_.mapply-1’
[10:19:20.528] Expression:
[10:19:20.528] {
[10:19:20.528]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.528]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.528]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.528]         on.exit(options(oopts), add = TRUE)
[10:19:20.528]     }
[10:19:20.528]     {
[10:19:20.528]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.528]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.528]         do.call(mapply, args = args)
[10:19:20.528]     }
[10:19:20.528] }
[10:19:20.528] Lazy evaluation: FALSE
[10:19:20.528] Asynchronous evaluation: FALSE
[10:19:20.528] Local evaluation: TRUE
[10:19:20.528] Environment: R_GlobalEnv
[10:19:20.528] Capture standard output: TRUE
[10:19:20.528] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.528] Globals: 5 objects totaling 749 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 250 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.528] Packages: <none>
[10:19:20.528] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.528] Resolved: TRUE
[10:19:20.528] Value: 103 bytes of class ‘list’
[10:19:20.528] Early signaling: FALSE
[10:19:20.528] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.528] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.529] Chunk #1 of 1 ... DONE
[10:19:20.529] Launching 1 futures (chunks) ... DONE
[10:19:20.529] Resolving 1 futures (chunks) ...
[10:19:20.529] resolve() on list ...
[10:19:20.529]  recursive: 0
[10:19:20.529]  length: 1
[10:19:20.529] 
[10:19:20.529] resolved() for ‘SequentialFuture’ ...
[10:19:20.529] - state: ‘finished’
[10:19:20.530] - run: TRUE
[10:19:20.530] - result: ‘FutureResult’
[10:19:20.530] resolved() for ‘SequentialFuture’ ... done
[10:19:20.530] Future #1
[10:19:20.530] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.530] - nx: 1
[10:19:20.530] - relay: TRUE
[10:19:20.530] - stdout: TRUE
[10:19:20.530] - signal: TRUE
[10:19:20.530] - resignal: FALSE
[10:19:20.530] - force: TRUE
[10:19:20.530] - relayed: [n=1] FALSE
[10:19:20.530] - queued futures: [n=1] FALSE
[10:19:20.531]  - until=1
[10:19:20.531]  - relaying element #1
[10:19:20.531] - relayed: [n=1] TRUE
[10:19:20.531] - queued futures: [n=1] TRUE
[10:19:20.531] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.531]  length: 0 (resolved future 1)
[10:19:20.531] Relaying remaining futures
[10:19:20.531] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.531] - nx: 1
[10:19:20.531] - relay: TRUE
[10:19:20.531] - stdout: TRUE
[10:19:20.532] - signal: TRUE
[10:19:20.532] - resignal: FALSE
[10:19:20.532] - force: TRUE
[10:19:20.532] - relayed: [n=1] TRUE
[10:19:20.532] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.532] - relayed: [n=1] TRUE
[10:19:20.532] - queued futures: [n=1] TRUE
[10:19:20.532] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.532] resolve() on list ... DONE
[10:19:20.532]  - Number of value chunks collected: 1
[10:19:20.532] Resolving 1 futures (chunks) ... DONE
[10:19:20.533] Reducing values from 1 chunks ...
[10:19:20.533]  - Number of values collected after concatenation: 3
[10:19:20.533]  - Number of values expected: 3
[10:19:20.533] Reducing values from 1 chunks ... DONE
[10:19:20.533] future_mapply() ... DONE
[10:19:20.533] future_mapply() ...
[10:19:20.535] Number of chunks: 5
[10:19:20.535] getGlobalsAndPackagesXApply() ...
[10:19:20.535]  - future.globals: TRUE
[10:19:20.535] getGlobalsAndPackages() ...
[10:19:20.535] Searching for globals...
[10:19:20.536] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:20.536] Searching for globals ... DONE
[10:19:20.536] Resolving globals: FALSE
[10:19:20.537] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:20.537] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:20.537] - globals: [1] ‘FUN’
[10:19:20.537] 
[10:19:20.537] getGlobalsAndPackages() ... DONE
[10:19:20.537]  - globals found/used: [n=1] ‘FUN’
[10:19:20.537]  - needed namespaces: [n=0] 
[10:19:20.538] Finding globals ... DONE
[10:19:20.538] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.538] List of 2
[10:19:20.538]  $ ...future.FUN:function (C, k)  
[10:19:20.538]  $ MoreArgs     : NULL
[10:19:20.538]  - attr(*, "where")=List of 2
[10:19:20.538]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.538]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.538]  - attr(*, "resolved")= logi FALSE
[10:19:20.538]  - attr(*, "total_size")= num NA
[10:19:20.540] Packages to be attached in all futures: [n=0] 
[10:19:20.540] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.540] Number of futures (= number of chunks): 5
[10:19:20.541] Launching 5 futures (chunks) ...
[10:19:20.541] Chunk #1 of 5 ...
[10:19:20.541]  - Finding globals in '...' for chunk #1 ...
[10:19:20.541] getGlobalsAndPackages() ...
[10:19:20.541] Searching for globals...
[10:19:20.541] 
[10:19:20.541] Searching for globals ... DONE
[10:19:20.541] - globals: [0] <none>
[10:19:20.541] getGlobalsAndPackages() ... DONE
[10:19:20.542]    + additional globals found: [n=0] 
[10:19:20.542]    + additional namespaces needed: [n=0] 
[10:19:20.542]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.542]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:20.542]  - seeds: <none>
[10:19:20.542]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.542] getGlobalsAndPackages() ...
[10:19:20.542] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.542] Resolving globals: FALSE
[10:19:20.543] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:20.543] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.543] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.543] 
[10:19:20.543] getGlobalsAndPackages() ... DONE
[10:19:20.544] run() for ‘Future’ ...
[10:19:20.544] - state: ‘created’
[10:19:20.544] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.544] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.544] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.544]   - Field: ‘label’
[10:19:20.544]   - Field: ‘local’
[10:19:20.544]   - Field: ‘owner’
[10:19:20.545]   - Field: ‘envir’
[10:19:20.545]   - Field: ‘packages’
[10:19:20.545]   - Field: ‘gc’
[10:19:20.546]   - Field: ‘conditions’
[10:19:20.546]   - Field: ‘expr’
[10:19:20.547]   - Field: ‘uuid’
[10:19:20.547]   - Field: ‘seed’
[10:19:20.547]   - Field: ‘version’
[10:19:20.547]   - Field: ‘result’
[10:19:20.547]   - Field: ‘asynchronous’
[10:19:20.547]   - Field: ‘calls’
[10:19:20.547]   - Field: ‘globals’
[10:19:20.547]   - Field: ‘stdout’
[10:19:20.547]   - Field: ‘earlySignal’
[10:19:20.547]   - Field: ‘lazy’
[10:19:20.547]   - Field: ‘state’
[10:19:20.547] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.548] - Launch lazy future ...
[10:19:20.548] Packages needed by the future expression (n = 0): <none>
[10:19:20.548] Packages needed by future strategies (n = 0): <none>
[10:19:20.548] {
[10:19:20.548]     {
[10:19:20.548]         {
[10:19:20.548]             ...future.startTime <- base::Sys.time()
[10:19:20.548]             {
[10:19:20.548]                 {
[10:19:20.548]                   {
[10:19:20.548]                     base::local({
[10:19:20.548]                       has_future <- base::requireNamespace("future", 
[10:19:20.548]                         quietly = TRUE)
[10:19:20.548]                       if (has_future) {
[10:19:20.548]                         ns <- base::getNamespace("future")
[10:19:20.548]                         version <- ns[[".package"]][["version"]]
[10:19:20.548]                         if (is.null(version)) 
[10:19:20.548]                           version <- utils::packageVersion("future")
[10:19:20.548]                       }
[10:19:20.548]                       else {
[10:19:20.548]                         version <- NULL
[10:19:20.548]                       }
[10:19:20.548]                       if (!has_future || version < "1.8.0") {
[10:19:20.548]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.548]                           "", base::R.version$version.string), 
[10:19:20.548]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.548]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.548]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.548]                             "release", "version")], collapse = " "), 
[10:19:20.548]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.548]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.548]                           info)
[10:19:20.548]                         info <- base::paste(info, collapse = "; ")
[10:19:20.548]                         if (!has_future) {
[10:19:20.548]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.548]                             info)
[10:19:20.548]                         }
[10:19:20.548]                         else {
[10:19:20.548]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.548]                             info, version)
[10:19:20.548]                         }
[10:19:20.548]                         base::stop(msg)
[10:19:20.548]                       }
[10:19:20.548]                     })
[10:19:20.548]                   }
[10:19:20.548]                   ...future.strategy.old <- future::plan("list")
[10:19:20.548]                   options(future.plan = NULL)
[10:19:20.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.548]                 }
[10:19:20.548]                 ...future.workdir <- getwd()
[10:19:20.548]             }
[10:19:20.548]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.548]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.548]         }
[10:19:20.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.548]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:20.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.548]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.548]             base::names(...future.oldOptions))
[10:19:20.548]     }
[10:19:20.548]     if (FALSE) {
[10:19:20.548]     }
[10:19:20.548]     else {
[10:19:20.548]         if (TRUE) {
[10:19:20.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.548]                 open = "w")
[10:19:20.548]         }
[10:19:20.548]         else {
[10:19:20.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.548]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.548]         }
[10:19:20.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.548]             base::sink(type = "output", split = FALSE)
[10:19:20.548]             base::close(...future.stdout)
[10:19:20.548]         }, add = TRUE)
[10:19:20.548]     }
[10:19:20.548]     ...future.frame <- base::sys.nframe()
[10:19:20.548]     ...future.conditions <- base::list()
[10:19:20.548]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.548]     if (FALSE) {
[10:19:20.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.548]     }
[10:19:20.548]     ...future.result <- base::tryCatch({
[10:19:20.548]         base::withCallingHandlers({
[10:19:20.548]             ...future.value <- base::withVisible(base::local({
[10:19:20.548]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.548]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.548]                   ...future.globals.maxSize)) {
[10:19:20.548]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.548]                   on.exit(options(oopts), add = TRUE)
[10:19:20.548]                 }
[10:19:20.548]                 {
[10:19:20.548]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.548]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.548]                     USE.NAMES = FALSE)
[10:19:20.548]                   do.call(mapply, args = args)
[10:19:20.548]                 }
[10:19:20.548]             }))
[10:19:20.548]             future::FutureResult(value = ...future.value$value, 
[10:19:20.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.548]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.548]                     ...future.globalenv.names))
[10:19:20.548]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.548]         }, condition = base::local({
[10:19:20.548]             c <- base::c
[10:19:20.548]             inherits <- base::inherits
[10:19:20.548]             invokeRestart <- base::invokeRestart
[10:19:20.548]             length <- base::length
[10:19:20.548]             list <- base::list
[10:19:20.548]             seq.int <- base::seq.int
[10:19:20.548]             signalCondition <- base::signalCondition
[10:19:20.548]             sys.calls <- base::sys.calls
[10:19:20.548]             `[[` <- base::`[[`
[10:19:20.548]             `+` <- base::`+`
[10:19:20.548]             `<<-` <- base::`<<-`
[10:19:20.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.548]                   3L)]
[10:19:20.548]             }
[10:19:20.548]             function(cond) {
[10:19:20.548]                 is_error <- inherits(cond, "error")
[10:19:20.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.548]                   NULL)
[10:19:20.548]                 if (is_error) {
[10:19:20.548]                   sessionInformation <- function() {
[10:19:20.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.548]                       search = base::search(), system = base::Sys.info())
[10:19:20.548]                   }
[10:19:20.548]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.548]                     cond$call), session = sessionInformation(), 
[10:19:20.548]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.548]                   signalCondition(cond)
[10:19:20.548]                 }
[10:19:20.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.548]                 "immediateCondition"))) {
[10:19:20.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.548]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.548]                   if (TRUE && !signal) {
[10:19:20.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.548]                     {
[10:19:20.548]                       inherits <- base::inherits
[10:19:20.548]                       invokeRestart <- base::invokeRestart
[10:19:20.548]                       is.null <- base::is.null
[10:19:20.548]                       muffled <- FALSE
[10:19:20.548]                       if (inherits(cond, "message")) {
[10:19:20.548]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.548]                         if (muffled) 
[10:19:20.548]                           invokeRestart("muffleMessage")
[10:19:20.548]                       }
[10:19:20.548]                       else if (inherits(cond, "warning")) {
[10:19:20.548]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.548]                         if (muffled) 
[10:19:20.548]                           invokeRestart("muffleWarning")
[10:19:20.548]                       }
[10:19:20.548]                       else if (inherits(cond, "condition")) {
[10:19:20.548]                         if (!is.null(pattern)) {
[10:19:20.548]                           computeRestarts <- base::computeRestarts
[10:19:20.548]                           grepl <- base::grepl
[10:19:20.548]                           restarts <- computeRestarts(cond)
[10:19:20.548]                           for (restart in restarts) {
[10:19:20.548]                             name <- restart$name
[10:19:20.548]                             if (is.null(name)) 
[10:19:20.548]                               next
[10:19:20.548]                             if (!grepl(pattern, name)) 
[10:19:20.548]                               next
[10:19:20.548]                             invokeRestart(restart)
[10:19:20.548]                             muffled <- TRUE
[10:19:20.548]                             break
[10:19:20.548]                           }
[10:19:20.548]                         }
[10:19:20.548]                       }
[10:19:20.548]                       invisible(muffled)
[10:19:20.548]                     }
[10:19:20.548]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.548]                   }
[10:19:20.548]                 }
[10:19:20.548]                 else {
[10:19:20.548]                   if (TRUE) {
[10:19:20.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.548]                     {
[10:19:20.548]                       inherits <- base::inherits
[10:19:20.548]                       invokeRestart <- base::invokeRestart
[10:19:20.548]                       is.null <- base::is.null
[10:19:20.548]                       muffled <- FALSE
[10:19:20.548]                       if (inherits(cond, "message")) {
[10:19:20.548]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.548]                         if (muffled) 
[10:19:20.548]                           invokeRestart("muffleMessage")
[10:19:20.548]                       }
[10:19:20.548]                       else if (inherits(cond, "warning")) {
[10:19:20.548]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.548]                         if (muffled) 
[10:19:20.548]                           invokeRestart("muffleWarning")
[10:19:20.548]                       }
[10:19:20.548]                       else if (inherits(cond, "condition")) {
[10:19:20.548]                         if (!is.null(pattern)) {
[10:19:20.548]                           computeRestarts <- base::computeRestarts
[10:19:20.548]                           grepl <- base::grepl
[10:19:20.548]                           restarts <- computeRestarts(cond)
[10:19:20.548]                           for (restart in restarts) {
[10:19:20.548]                             name <- restart$name
[10:19:20.548]                             if (is.null(name)) 
[10:19:20.548]                               next
[10:19:20.548]                             if (!grepl(pattern, name)) 
[10:19:20.548]                               next
[10:19:20.548]                             invokeRestart(restart)
[10:19:20.548]                             muffled <- TRUE
[10:19:20.548]                             break
[10:19:20.548]                           }
[10:19:20.548]                         }
[10:19:20.548]                       }
[10:19:20.548]                       invisible(muffled)
[10:19:20.548]                     }
[10:19:20.548]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.548]                   }
[10:19:20.548]                 }
[10:19:20.548]             }
[10:19:20.548]         }))
[10:19:20.548]     }, error = function(ex) {
[10:19:20.548]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.548]                 ...future.rng), started = ...future.startTime, 
[10:19:20.548]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.548]             version = "1.8"), class = "FutureResult")
[10:19:20.548]     }, finally = {
[10:19:20.548]         if (!identical(...future.workdir, getwd())) 
[10:19:20.548]             setwd(...future.workdir)
[10:19:20.548]         {
[10:19:20.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.548]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.548]             }
[10:19:20.548]             base::options(...future.oldOptions)
[10:19:20.548]             if (.Platform$OS.type == "windows") {
[10:19:20.548]                 old_names <- names(...future.oldEnvVars)
[10:19:20.548]                 envs <- base::Sys.getenv()
[10:19:20.548]                 names <- names(envs)
[10:19:20.548]                 common <- intersect(names, old_names)
[10:19:20.548]                 added <- setdiff(names, old_names)
[10:19:20.548]                 removed <- setdiff(old_names, names)
[10:19:20.548]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.548]                   envs[common]]
[10:19:20.548]                 NAMES <- toupper(changed)
[10:19:20.548]                 args <- list()
[10:19:20.548]                 for (kk in seq_along(NAMES)) {
[10:19:20.548]                   name <- changed[[kk]]
[10:19:20.548]                   NAME <- NAMES[[kk]]
[10:19:20.548]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.548]                     next
[10:19:20.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.548]                 }
[10:19:20.548]                 NAMES <- toupper(added)
[10:19:20.548]                 for (kk in seq_along(NAMES)) {
[10:19:20.548]                   name <- added[[kk]]
[10:19:20.548]                   NAME <- NAMES[[kk]]
[10:19:20.548]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.548]                     next
[10:19:20.548]                   args[[name]] <- ""
[10:19:20.548]                 }
[10:19:20.548]                 NAMES <- toupper(removed)
[10:19:20.548]                 for (kk in seq_along(NAMES)) {
[10:19:20.548]                   name <- removed[[kk]]
[10:19:20.548]                   NAME <- NAMES[[kk]]
[10:19:20.548]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.548]                     next
[10:19:20.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.548]                 }
[10:19:20.548]                 if (length(args) > 0) 
[10:19:20.548]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.548]             }
[10:19:20.548]             else {
[10:19:20.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.548]             }
[10:19:20.548]             {
[10:19:20.548]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.548]                   0L) {
[10:19:20.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.548]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.548]                   base::options(opts)
[10:19:20.548]                 }
[10:19:20.548]                 {
[10:19:20.548]                   {
[10:19:20.548]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.548]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.548]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.548]                       inherits = FALSE)
[10:19:20.548]                     NULL
[10:19:20.548]                   }
[10:19:20.548]                   options(future.plan = NULL)
[10:19:20.548]                   if (is.na(NA_character_)) 
[10:19:20.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.548]                     .init = FALSE)
[10:19:20.548]                 }
[10:19:20.548]             }
[10:19:20.548]         }
[10:19:20.548]     })
[10:19:20.548]     if (TRUE) {
[10:19:20.548]         base::sink(type = "output", split = FALSE)
[10:19:20.548]         if (TRUE) {
[10:19:20.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.548]         }
[10:19:20.548]         else {
[10:19:20.548]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.548]         }
[10:19:20.548]         base::close(...future.stdout)
[10:19:20.548]         ...future.stdout <- NULL
[10:19:20.548]     }
[10:19:20.548]     ...future.result$conditions <- ...future.conditions
[10:19:20.548]     ...future.result$finished <- base::Sys.time()
[10:19:20.548]     ...future.result
[10:19:20.548] }
[10:19:20.550] assign_globals() ...
[10:19:20.550] List of 5
[10:19:20.550]  $ ...future.FUN            :function (C, k)  
[10:19:20.550]  $ MoreArgs                 : NULL
[10:19:20.550]  $ ...future.elements_ii    :List of 2
[10:19:20.550]   ..$ :List of 1
[10:19:20.550]   .. ..$ : chr "A"
[10:19:20.550]   ..$ :List of 1
[10:19:20.550]   .. ..$ : int 5
[10:19:20.550]  $ ...future.seeds_ii       : NULL
[10:19:20.550]  $ ...future.globals.maxSize: NULL
[10:19:20.550]  - attr(*, "where")=List of 5
[10:19:20.550]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.550]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.550]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.550]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.550]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.550]  - attr(*, "resolved")= logi FALSE
[10:19:20.550]  - attr(*, "total_size")= num 847
[10:19:20.550]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.550]  - attr(*, "already-done")= logi TRUE
[10:19:20.555] - reassign environment for ‘...future.FUN’
[10:19:20.555] - copied ‘...future.FUN’ to environment
[10:19:20.555] - copied ‘MoreArgs’ to environment
[10:19:20.555] - copied ‘...future.elements_ii’ to environment
[10:19:20.555] - copied ‘...future.seeds_ii’ to environment
[10:19:20.555] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.555] assign_globals() ... done
[10:19:20.555] plan(): Setting new future strategy stack:
[10:19:20.556] List of future strategies:
[10:19:20.556] 1. sequential:
[10:19:20.556]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.556]    - tweaked: FALSE
[10:19:20.556]    - call: NULL
[10:19:20.556] plan(): nbrOfWorkers() = 1
[10:19:20.557] plan(): Setting new future strategy stack:
[10:19:20.557] List of future strategies:
[10:19:20.557] 1. sequential:
[10:19:20.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.557]    - tweaked: FALSE
[10:19:20.557]    - call: plan(strategy)
[10:19:20.557] plan(): nbrOfWorkers() = 1
[10:19:20.557] SequentialFuture started (and completed)
[10:19:20.557] - Launch lazy future ... done
[10:19:20.558] run() for ‘SequentialFuture’ ... done
[10:19:20.558] Created future:
[10:19:20.558] SequentialFuture:
[10:19:20.558] Label: ‘future_mapply-1’
[10:19:20.558] Expression:
[10:19:20.558] {
[10:19:20.558]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.558]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.558]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.558]         on.exit(options(oopts), add = TRUE)
[10:19:20.558]     }
[10:19:20.558]     {
[10:19:20.558]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.558]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.558]         do.call(mapply, args = args)
[10:19:20.558]     }
[10:19:20.558] }
[10:19:20.558] Lazy evaluation: FALSE
[10:19:20.558] Asynchronous evaluation: FALSE
[10:19:20.558] Local evaluation: TRUE
[10:19:20.558] Environment: R_GlobalEnv
[10:19:20.558] Capture standard output: TRUE
[10:19:20.558] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.558] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.558] Packages: <none>
[10:19:20.558] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.558] Resolved: TRUE
[10:19:20.558] Value: 52 bytes of class ‘list’
[10:19:20.558] Early signaling: FALSE
[10:19:20.558] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.558] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.559] Chunk #1 of 5 ... DONE
[10:19:20.559] Chunk #2 of 5 ...
[10:19:20.559]  - Finding globals in '...' for chunk #2 ...
[10:19:20.559] getGlobalsAndPackages() ...
[10:19:20.559] Searching for globals...
[10:19:20.559] 
[10:19:20.559] Searching for globals ... DONE
[10:19:20.559] - globals: [0] <none>
[10:19:20.559] getGlobalsAndPackages() ... DONE
[10:19:20.559]    + additional globals found: [n=0] 
[10:19:20.560]    + additional namespaces needed: [n=0] 
[10:19:20.560]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:20.560]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:20.560]  - seeds: <none>
[10:19:20.560]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.560] getGlobalsAndPackages() ...
[10:19:20.560] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.560] Resolving globals: FALSE
[10:19:20.561] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:20.561] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.561] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.561] 
[10:19:20.561] getGlobalsAndPackages() ... DONE
[10:19:20.562] run() for ‘Future’ ...
[10:19:20.562] - state: ‘created’
[10:19:20.562] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.562] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.562] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.562]   - Field: ‘label’
[10:19:20.562]   - Field: ‘local’
[10:19:20.562]   - Field: ‘owner’
[10:19:20.562]   - Field: ‘envir’
[10:19:20.563]   - Field: ‘packages’
[10:19:20.563]   - Field: ‘gc’
[10:19:20.563]   - Field: ‘conditions’
[10:19:20.563]   - Field: ‘expr’
[10:19:20.563]   - Field: ‘uuid’
[10:19:20.563]   - Field: ‘seed’
[10:19:20.563]   - Field: ‘version’
[10:19:20.563]   - Field: ‘result’
[10:19:20.563]   - Field: ‘asynchronous’
[10:19:20.563]   - Field: ‘calls’
[10:19:20.563]   - Field: ‘globals’
[10:19:20.563]   - Field: ‘stdout’
[10:19:20.564]   - Field: ‘earlySignal’
[10:19:20.564]   - Field: ‘lazy’
[10:19:20.564]   - Field: ‘state’
[10:19:20.564] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.564] - Launch lazy future ...
[10:19:20.564] Packages needed by the future expression (n = 0): <none>
[10:19:20.564] Packages needed by future strategies (n = 0): <none>
[10:19:20.565] {
[10:19:20.565]     {
[10:19:20.565]         {
[10:19:20.565]             ...future.startTime <- base::Sys.time()
[10:19:20.565]             {
[10:19:20.565]                 {
[10:19:20.565]                   {
[10:19:20.565]                     base::local({
[10:19:20.565]                       has_future <- base::requireNamespace("future", 
[10:19:20.565]                         quietly = TRUE)
[10:19:20.565]                       if (has_future) {
[10:19:20.565]                         ns <- base::getNamespace("future")
[10:19:20.565]                         version <- ns[[".package"]][["version"]]
[10:19:20.565]                         if (is.null(version)) 
[10:19:20.565]                           version <- utils::packageVersion("future")
[10:19:20.565]                       }
[10:19:20.565]                       else {
[10:19:20.565]                         version <- NULL
[10:19:20.565]                       }
[10:19:20.565]                       if (!has_future || version < "1.8.0") {
[10:19:20.565]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.565]                           "", base::R.version$version.string), 
[10:19:20.565]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.565]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.565]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.565]                             "release", "version")], collapse = " "), 
[10:19:20.565]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.565]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.565]                           info)
[10:19:20.565]                         info <- base::paste(info, collapse = "; ")
[10:19:20.565]                         if (!has_future) {
[10:19:20.565]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.565]                             info)
[10:19:20.565]                         }
[10:19:20.565]                         else {
[10:19:20.565]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.565]                             info, version)
[10:19:20.565]                         }
[10:19:20.565]                         base::stop(msg)
[10:19:20.565]                       }
[10:19:20.565]                     })
[10:19:20.565]                   }
[10:19:20.565]                   ...future.strategy.old <- future::plan("list")
[10:19:20.565]                   options(future.plan = NULL)
[10:19:20.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.565]                 }
[10:19:20.565]                 ...future.workdir <- getwd()
[10:19:20.565]             }
[10:19:20.565]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.565]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.565]         }
[10:19:20.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.565]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:20.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.565]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.565]             base::names(...future.oldOptions))
[10:19:20.565]     }
[10:19:20.565]     if (FALSE) {
[10:19:20.565]     }
[10:19:20.565]     else {
[10:19:20.565]         if (TRUE) {
[10:19:20.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.565]                 open = "w")
[10:19:20.565]         }
[10:19:20.565]         else {
[10:19:20.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.565]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.565]         }
[10:19:20.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.565]             base::sink(type = "output", split = FALSE)
[10:19:20.565]             base::close(...future.stdout)
[10:19:20.565]         }, add = TRUE)
[10:19:20.565]     }
[10:19:20.565]     ...future.frame <- base::sys.nframe()
[10:19:20.565]     ...future.conditions <- base::list()
[10:19:20.565]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.565]     if (FALSE) {
[10:19:20.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.565]     }
[10:19:20.565]     ...future.result <- base::tryCatch({
[10:19:20.565]         base::withCallingHandlers({
[10:19:20.565]             ...future.value <- base::withVisible(base::local({
[10:19:20.565]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.565]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.565]                   ...future.globals.maxSize)) {
[10:19:20.565]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.565]                   on.exit(options(oopts), add = TRUE)
[10:19:20.565]                 }
[10:19:20.565]                 {
[10:19:20.565]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.565]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.565]                     USE.NAMES = FALSE)
[10:19:20.565]                   do.call(mapply, args = args)
[10:19:20.565]                 }
[10:19:20.565]             }))
[10:19:20.565]             future::FutureResult(value = ...future.value$value, 
[10:19:20.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.565]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.565]                     ...future.globalenv.names))
[10:19:20.565]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.565]         }, condition = base::local({
[10:19:20.565]             c <- base::c
[10:19:20.565]             inherits <- base::inherits
[10:19:20.565]             invokeRestart <- base::invokeRestart
[10:19:20.565]             length <- base::length
[10:19:20.565]             list <- base::list
[10:19:20.565]             seq.int <- base::seq.int
[10:19:20.565]             signalCondition <- base::signalCondition
[10:19:20.565]             sys.calls <- base::sys.calls
[10:19:20.565]             `[[` <- base::`[[`
[10:19:20.565]             `+` <- base::`+`
[10:19:20.565]             `<<-` <- base::`<<-`
[10:19:20.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.565]                   3L)]
[10:19:20.565]             }
[10:19:20.565]             function(cond) {
[10:19:20.565]                 is_error <- inherits(cond, "error")
[10:19:20.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.565]                   NULL)
[10:19:20.565]                 if (is_error) {
[10:19:20.565]                   sessionInformation <- function() {
[10:19:20.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.565]                       search = base::search(), system = base::Sys.info())
[10:19:20.565]                   }
[10:19:20.565]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.565]                     cond$call), session = sessionInformation(), 
[10:19:20.565]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.565]                   signalCondition(cond)
[10:19:20.565]                 }
[10:19:20.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.565]                 "immediateCondition"))) {
[10:19:20.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.565]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.565]                   if (TRUE && !signal) {
[10:19:20.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.565]                     {
[10:19:20.565]                       inherits <- base::inherits
[10:19:20.565]                       invokeRestart <- base::invokeRestart
[10:19:20.565]                       is.null <- base::is.null
[10:19:20.565]                       muffled <- FALSE
[10:19:20.565]                       if (inherits(cond, "message")) {
[10:19:20.565]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.565]                         if (muffled) 
[10:19:20.565]                           invokeRestart("muffleMessage")
[10:19:20.565]                       }
[10:19:20.565]                       else if (inherits(cond, "warning")) {
[10:19:20.565]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.565]                         if (muffled) 
[10:19:20.565]                           invokeRestart("muffleWarning")
[10:19:20.565]                       }
[10:19:20.565]                       else if (inherits(cond, "condition")) {
[10:19:20.565]                         if (!is.null(pattern)) {
[10:19:20.565]                           computeRestarts <- base::computeRestarts
[10:19:20.565]                           grepl <- base::grepl
[10:19:20.565]                           restarts <- computeRestarts(cond)
[10:19:20.565]                           for (restart in restarts) {
[10:19:20.565]                             name <- restart$name
[10:19:20.565]                             if (is.null(name)) 
[10:19:20.565]                               next
[10:19:20.565]                             if (!grepl(pattern, name)) 
[10:19:20.565]                               next
[10:19:20.565]                             invokeRestart(restart)
[10:19:20.565]                             muffled <- TRUE
[10:19:20.565]                             break
[10:19:20.565]                           }
[10:19:20.565]                         }
[10:19:20.565]                       }
[10:19:20.565]                       invisible(muffled)
[10:19:20.565]                     }
[10:19:20.565]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.565]                   }
[10:19:20.565]                 }
[10:19:20.565]                 else {
[10:19:20.565]                   if (TRUE) {
[10:19:20.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.565]                     {
[10:19:20.565]                       inherits <- base::inherits
[10:19:20.565]                       invokeRestart <- base::invokeRestart
[10:19:20.565]                       is.null <- base::is.null
[10:19:20.565]                       muffled <- FALSE
[10:19:20.565]                       if (inherits(cond, "message")) {
[10:19:20.565]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.565]                         if (muffled) 
[10:19:20.565]                           invokeRestart("muffleMessage")
[10:19:20.565]                       }
[10:19:20.565]                       else if (inherits(cond, "warning")) {
[10:19:20.565]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.565]                         if (muffled) 
[10:19:20.565]                           invokeRestart("muffleWarning")
[10:19:20.565]                       }
[10:19:20.565]                       else if (inherits(cond, "condition")) {
[10:19:20.565]                         if (!is.null(pattern)) {
[10:19:20.565]                           computeRestarts <- base::computeRestarts
[10:19:20.565]                           grepl <- base::grepl
[10:19:20.565]                           restarts <- computeRestarts(cond)
[10:19:20.565]                           for (restart in restarts) {
[10:19:20.565]                             name <- restart$name
[10:19:20.565]                             if (is.null(name)) 
[10:19:20.565]                               next
[10:19:20.565]                             if (!grepl(pattern, name)) 
[10:19:20.565]                               next
[10:19:20.565]                             invokeRestart(restart)
[10:19:20.565]                             muffled <- TRUE
[10:19:20.565]                             break
[10:19:20.565]                           }
[10:19:20.565]                         }
[10:19:20.565]                       }
[10:19:20.565]                       invisible(muffled)
[10:19:20.565]                     }
[10:19:20.565]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.565]                   }
[10:19:20.565]                 }
[10:19:20.565]             }
[10:19:20.565]         }))
[10:19:20.565]     }, error = function(ex) {
[10:19:20.565]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.565]                 ...future.rng), started = ...future.startTime, 
[10:19:20.565]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.565]             version = "1.8"), class = "FutureResult")
[10:19:20.565]     }, finally = {
[10:19:20.565]         if (!identical(...future.workdir, getwd())) 
[10:19:20.565]             setwd(...future.workdir)
[10:19:20.565]         {
[10:19:20.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.565]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.565]             }
[10:19:20.565]             base::options(...future.oldOptions)
[10:19:20.565]             if (.Platform$OS.type == "windows") {
[10:19:20.565]                 old_names <- names(...future.oldEnvVars)
[10:19:20.565]                 envs <- base::Sys.getenv()
[10:19:20.565]                 names <- names(envs)
[10:19:20.565]                 common <- intersect(names, old_names)
[10:19:20.565]                 added <- setdiff(names, old_names)
[10:19:20.565]                 removed <- setdiff(old_names, names)
[10:19:20.565]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.565]                   envs[common]]
[10:19:20.565]                 NAMES <- toupper(changed)
[10:19:20.565]                 args <- list()
[10:19:20.565]                 for (kk in seq_along(NAMES)) {
[10:19:20.565]                   name <- changed[[kk]]
[10:19:20.565]                   NAME <- NAMES[[kk]]
[10:19:20.565]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.565]                     next
[10:19:20.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.565]                 }
[10:19:20.565]                 NAMES <- toupper(added)
[10:19:20.565]                 for (kk in seq_along(NAMES)) {
[10:19:20.565]                   name <- added[[kk]]
[10:19:20.565]                   NAME <- NAMES[[kk]]
[10:19:20.565]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.565]                     next
[10:19:20.565]                   args[[name]] <- ""
[10:19:20.565]                 }
[10:19:20.565]                 NAMES <- toupper(removed)
[10:19:20.565]                 for (kk in seq_along(NAMES)) {
[10:19:20.565]                   name <- removed[[kk]]
[10:19:20.565]                   NAME <- NAMES[[kk]]
[10:19:20.565]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.565]                     next
[10:19:20.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.565]                 }
[10:19:20.565]                 if (length(args) > 0) 
[10:19:20.565]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.565]             }
[10:19:20.565]             else {
[10:19:20.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.565]             }
[10:19:20.565]             {
[10:19:20.565]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.565]                   0L) {
[10:19:20.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.565]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.565]                   base::options(opts)
[10:19:20.565]                 }
[10:19:20.565]                 {
[10:19:20.565]                   {
[10:19:20.565]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.565]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.565]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.565]                       inherits = FALSE)
[10:19:20.565]                     NULL
[10:19:20.565]                   }
[10:19:20.565]                   options(future.plan = NULL)
[10:19:20.565]                   if (is.na(NA_character_)) 
[10:19:20.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.565]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.565]                     .init = FALSE)
[10:19:20.565]                 }
[10:19:20.565]             }
[10:19:20.565]         }
[10:19:20.565]     })
[10:19:20.565]     if (TRUE) {
[10:19:20.565]         base::sink(type = "output", split = FALSE)
[10:19:20.565]         if (TRUE) {
[10:19:20.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.565]         }
[10:19:20.565]         else {
[10:19:20.565]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.565]         }
[10:19:20.565]         base::close(...future.stdout)
[10:19:20.565]         ...future.stdout <- NULL
[10:19:20.565]     }
[10:19:20.565]     ...future.result$conditions <- ...future.conditions
[10:19:20.565]     ...future.result$finished <- base::Sys.time()
[10:19:20.565]     ...future.result
[10:19:20.565] }
[10:19:20.566] assign_globals() ...
[10:19:20.566] List of 5
[10:19:20.566]  $ ...future.FUN            :function (C, k)  
[10:19:20.566]  $ MoreArgs                 : NULL
[10:19:20.566]  $ ...future.elements_ii    :List of 2
[10:19:20.566]   ..$ :List of 1
[10:19:20.566]   .. ..$ : chr "B"
[10:19:20.566]   ..$ :List of 1
[10:19:20.566]   .. ..$ : int 4
[10:19:20.566]  $ ...future.seeds_ii       : NULL
[10:19:20.566]  $ ...future.globals.maxSize: NULL
[10:19:20.566]  - attr(*, "where")=List of 5
[10:19:20.566]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.566]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.566]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.566]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.566]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.566]  - attr(*, "resolved")= logi FALSE
[10:19:20.566]  - attr(*, "total_size")= num 847
[10:19:20.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.566]  - attr(*, "already-done")= logi TRUE
[10:19:20.572] - reassign environment for ‘...future.FUN’
[10:19:20.573] - copied ‘...future.FUN’ to environment
[10:19:20.573] - copied ‘MoreArgs’ to environment
[10:19:20.573] - copied ‘...future.elements_ii’ to environment
[10:19:20.573] - copied ‘...future.seeds_ii’ to environment
[10:19:20.573] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.573] assign_globals() ... done
[10:19:20.573] plan(): Setting new future strategy stack:
[10:19:20.573] List of future strategies:
[10:19:20.573] 1. sequential:
[10:19:20.573]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.573]    - tweaked: FALSE
[10:19:20.573]    - call: NULL
[10:19:20.574] plan(): nbrOfWorkers() = 1
[10:19:20.574] plan(): Setting new future strategy stack:
[10:19:20.575] List of future strategies:
[10:19:20.575] 1. sequential:
[10:19:20.575]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.575]    - tweaked: FALSE
[10:19:20.575]    - call: plan(strategy)
[10:19:20.575] plan(): nbrOfWorkers() = 1
[10:19:20.575] SequentialFuture started (and completed)
[10:19:20.575] - Launch lazy future ... done
[10:19:20.575] run() for ‘SequentialFuture’ ... done
[10:19:20.575] Created future:
[10:19:20.576] SequentialFuture:
[10:19:20.576] Label: ‘future_mapply-2’
[10:19:20.576] Expression:
[10:19:20.576] {
[10:19:20.576]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.576]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.576]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.576]         on.exit(options(oopts), add = TRUE)
[10:19:20.576]     }
[10:19:20.576]     {
[10:19:20.576]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.576]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.576]         do.call(mapply, args = args)
[10:19:20.576]     }
[10:19:20.576] }
[10:19:20.576] Lazy evaluation: FALSE
[10:19:20.576] Asynchronous evaluation: FALSE
[10:19:20.576] Local evaluation: TRUE
[10:19:20.576] Environment: R_GlobalEnv
[10:19:20.576] Capture standard output: TRUE
[10:19:20.576] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.576] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.576] Packages: <none>
[10:19:20.576] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.576] Resolved: TRUE
[10:19:20.576] Value: 51 bytes of class ‘list’
[10:19:20.576] Early signaling: FALSE
[10:19:20.576] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.576] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.576] Chunk #2 of 5 ... DONE
[10:19:20.576] Chunk #3 of 5 ...
[10:19:20.576]  - Finding globals in '...' for chunk #3 ...
[10:19:20.577] getGlobalsAndPackages() ...
[10:19:20.577] Searching for globals...
[10:19:20.577] 
[10:19:20.577] Searching for globals ... DONE
[10:19:20.577] - globals: [0] <none>
[10:19:20.577] getGlobalsAndPackages() ... DONE
[10:19:20.577]    + additional globals found: [n=0] 
[10:19:20.577]    + additional namespaces needed: [n=0] 
[10:19:20.577]  - Finding globals in '...' for chunk #3 ... DONE
[10:19:20.577]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:20.578]  - seeds: <none>
[10:19:20.578]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.578] getGlobalsAndPackages() ...
[10:19:20.578] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.578] Resolving globals: FALSE
[10:19:20.578] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:20.579] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.579] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.579] 
[10:19:20.579] getGlobalsAndPackages() ... DONE
[10:19:20.579] run() for ‘Future’ ...
[10:19:20.579] - state: ‘created’
[10:19:20.580] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.580] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.580] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.580]   - Field: ‘label’
[10:19:20.580]   - Field: ‘local’
[10:19:20.580]   - Field: ‘owner’
[10:19:20.580]   - Field: ‘envir’
[10:19:20.580]   - Field: ‘packages’
[10:19:20.580]   - Field: ‘gc’
[10:19:20.580]   - Field: ‘conditions’
[10:19:20.581]   - Field: ‘expr’
[10:19:20.581]   - Field: ‘uuid’
[10:19:20.581]   - Field: ‘seed’
[10:19:20.581]   - Field: ‘version’
[10:19:20.581]   - Field: ‘result’
[10:19:20.581]   - Field: ‘asynchronous’
[10:19:20.581]   - Field: ‘calls’
[10:19:20.581]   - Field: ‘globals’
[10:19:20.581]   - Field: ‘stdout’
[10:19:20.581]   - Field: ‘earlySignal’
[10:19:20.581]   - Field: ‘lazy’
[10:19:20.581]   - Field: ‘state’
[10:19:20.582] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.582] - Launch lazy future ...
[10:19:20.582] Packages needed by the future expression (n = 0): <none>
[10:19:20.582] Packages needed by future strategies (n = 0): <none>
[10:19:20.582] {
[10:19:20.582]     {
[10:19:20.582]         {
[10:19:20.582]             ...future.startTime <- base::Sys.time()
[10:19:20.582]             {
[10:19:20.582]                 {
[10:19:20.582]                   {
[10:19:20.582]                     base::local({
[10:19:20.582]                       has_future <- base::requireNamespace("future", 
[10:19:20.582]                         quietly = TRUE)
[10:19:20.582]                       if (has_future) {
[10:19:20.582]                         ns <- base::getNamespace("future")
[10:19:20.582]                         version <- ns[[".package"]][["version"]]
[10:19:20.582]                         if (is.null(version)) 
[10:19:20.582]                           version <- utils::packageVersion("future")
[10:19:20.582]                       }
[10:19:20.582]                       else {
[10:19:20.582]                         version <- NULL
[10:19:20.582]                       }
[10:19:20.582]                       if (!has_future || version < "1.8.0") {
[10:19:20.582]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.582]                           "", base::R.version$version.string), 
[10:19:20.582]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.582]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.582]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.582]                             "release", "version")], collapse = " "), 
[10:19:20.582]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.582]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.582]                           info)
[10:19:20.582]                         info <- base::paste(info, collapse = "; ")
[10:19:20.582]                         if (!has_future) {
[10:19:20.582]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.582]                             info)
[10:19:20.582]                         }
[10:19:20.582]                         else {
[10:19:20.582]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.582]                             info, version)
[10:19:20.582]                         }
[10:19:20.582]                         base::stop(msg)
[10:19:20.582]                       }
[10:19:20.582]                     })
[10:19:20.582]                   }
[10:19:20.582]                   ...future.strategy.old <- future::plan("list")
[10:19:20.582]                   options(future.plan = NULL)
[10:19:20.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.582]                 }
[10:19:20.582]                 ...future.workdir <- getwd()
[10:19:20.582]             }
[10:19:20.582]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.582]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.582]         }
[10:19:20.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.582]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:20.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.582]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.582]             base::names(...future.oldOptions))
[10:19:20.582]     }
[10:19:20.582]     if (FALSE) {
[10:19:20.582]     }
[10:19:20.582]     else {
[10:19:20.582]         if (TRUE) {
[10:19:20.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.582]                 open = "w")
[10:19:20.582]         }
[10:19:20.582]         else {
[10:19:20.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.582]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.582]         }
[10:19:20.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.582]             base::sink(type = "output", split = FALSE)
[10:19:20.582]             base::close(...future.stdout)
[10:19:20.582]         }, add = TRUE)
[10:19:20.582]     }
[10:19:20.582]     ...future.frame <- base::sys.nframe()
[10:19:20.582]     ...future.conditions <- base::list()
[10:19:20.582]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.582]     if (FALSE) {
[10:19:20.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.582]     }
[10:19:20.582]     ...future.result <- base::tryCatch({
[10:19:20.582]         base::withCallingHandlers({
[10:19:20.582]             ...future.value <- base::withVisible(base::local({
[10:19:20.582]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.582]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.582]                   ...future.globals.maxSize)) {
[10:19:20.582]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.582]                   on.exit(options(oopts), add = TRUE)
[10:19:20.582]                 }
[10:19:20.582]                 {
[10:19:20.582]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.582]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.582]                     USE.NAMES = FALSE)
[10:19:20.582]                   do.call(mapply, args = args)
[10:19:20.582]                 }
[10:19:20.582]             }))
[10:19:20.582]             future::FutureResult(value = ...future.value$value, 
[10:19:20.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.582]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.582]                     ...future.globalenv.names))
[10:19:20.582]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.582]         }, condition = base::local({
[10:19:20.582]             c <- base::c
[10:19:20.582]             inherits <- base::inherits
[10:19:20.582]             invokeRestart <- base::invokeRestart
[10:19:20.582]             length <- base::length
[10:19:20.582]             list <- base::list
[10:19:20.582]             seq.int <- base::seq.int
[10:19:20.582]             signalCondition <- base::signalCondition
[10:19:20.582]             sys.calls <- base::sys.calls
[10:19:20.582]             `[[` <- base::`[[`
[10:19:20.582]             `+` <- base::`+`
[10:19:20.582]             `<<-` <- base::`<<-`
[10:19:20.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.582]                   3L)]
[10:19:20.582]             }
[10:19:20.582]             function(cond) {
[10:19:20.582]                 is_error <- inherits(cond, "error")
[10:19:20.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.582]                   NULL)
[10:19:20.582]                 if (is_error) {
[10:19:20.582]                   sessionInformation <- function() {
[10:19:20.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.582]                       search = base::search(), system = base::Sys.info())
[10:19:20.582]                   }
[10:19:20.582]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.582]                     cond$call), session = sessionInformation(), 
[10:19:20.582]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.582]                   signalCondition(cond)
[10:19:20.582]                 }
[10:19:20.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.582]                 "immediateCondition"))) {
[10:19:20.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.582]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.582]                   if (TRUE && !signal) {
[10:19:20.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.582]                     {
[10:19:20.582]                       inherits <- base::inherits
[10:19:20.582]                       invokeRestart <- base::invokeRestart
[10:19:20.582]                       is.null <- base::is.null
[10:19:20.582]                       muffled <- FALSE
[10:19:20.582]                       if (inherits(cond, "message")) {
[10:19:20.582]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.582]                         if (muffled) 
[10:19:20.582]                           invokeRestart("muffleMessage")
[10:19:20.582]                       }
[10:19:20.582]                       else if (inherits(cond, "warning")) {
[10:19:20.582]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.582]                         if (muffled) 
[10:19:20.582]                           invokeRestart("muffleWarning")
[10:19:20.582]                       }
[10:19:20.582]                       else if (inherits(cond, "condition")) {
[10:19:20.582]                         if (!is.null(pattern)) {
[10:19:20.582]                           computeRestarts <- base::computeRestarts
[10:19:20.582]                           grepl <- base::grepl
[10:19:20.582]                           restarts <- computeRestarts(cond)
[10:19:20.582]                           for (restart in restarts) {
[10:19:20.582]                             name <- restart$name
[10:19:20.582]                             if (is.null(name)) 
[10:19:20.582]                               next
[10:19:20.582]                             if (!grepl(pattern, name)) 
[10:19:20.582]                               next
[10:19:20.582]                             invokeRestart(restart)
[10:19:20.582]                             muffled <- TRUE
[10:19:20.582]                             break
[10:19:20.582]                           }
[10:19:20.582]                         }
[10:19:20.582]                       }
[10:19:20.582]                       invisible(muffled)
[10:19:20.582]                     }
[10:19:20.582]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.582]                   }
[10:19:20.582]                 }
[10:19:20.582]                 else {
[10:19:20.582]                   if (TRUE) {
[10:19:20.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.582]                     {
[10:19:20.582]                       inherits <- base::inherits
[10:19:20.582]                       invokeRestart <- base::invokeRestart
[10:19:20.582]                       is.null <- base::is.null
[10:19:20.582]                       muffled <- FALSE
[10:19:20.582]                       if (inherits(cond, "message")) {
[10:19:20.582]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.582]                         if (muffled) 
[10:19:20.582]                           invokeRestart("muffleMessage")
[10:19:20.582]                       }
[10:19:20.582]                       else if (inherits(cond, "warning")) {
[10:19:20.582]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.582]                         if (muffled) 
[10:19:20.582]                           invokeRestart("muffleWarning")
[10:19:20.582]                       }
[10:19:20.582]                       else if (inherits(cond, "condition")) {
[10:19:20.582]                         if (!is.null(pattern)) {
[10:19:20.582]                           computeRestarts <- base::computeRestarts
[10:19:20.582]                           grepl <- base::grepl
[10:19:20.582]                           restarts <- computeRestarts(cond)
[10:19:20.582]                           for (restart in restarts) {
[10:19:20.582]                             name <- restart$name
[10:19:20.582]                             if (is.null(name)) 
[10:19:20.582]                               next
[10:19:20.582]                             if (!grepl(pattern, name)) 
[10:19:20.582]                               next
[10:19:20.582]                             invokeRestart(restart)
[10:19:20.582]                             muffled <- TRUE
[10:19:20.582]                             break
[10:19:20.582]                           }
[10:19:20.582]                         }
[10:19:20.582]                       }
[10:19:20.582]                       invisible(muffled)
[10:19:20.582]                     }
[10:19:20.582]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.582]                   }
[10:19:20.582]                 }
[10:19:20.582]             }
[10:19:20.582]         }))
[10:19:20.582]     }, error = function(ex) {
[10:19:20.582]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.582]                 ...future.rng), started = ...future.startTime, 
[10:19:20.582]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.582]             version = "1.8"), class = "FutureResult")
[10:19:20.582]     }, finally = {
[10:19:20.582]         if (!identical(...future.workdir, getwd())) 
[10:19:20.582]             setwd(...future.workdir)
[10:19:20.582]         {
[10:19:20.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.582]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.582]             }
[10:19:20.582]             base::options(...future.oldOptions)
[10:19:20.582]             if (.Platform$OS.type == "windows") {
[10:19:20.582]                 old_names <- names(...future.oldEnvVars)
[10:19:20.582]                 envs <- base::Sys.getenv()
[10:19:20.582]                 names <- names(envs)
[10:19:20.582]                 common <- intersect(names, old_names)
[10:19:20.582]                 added <- setdiff(names, old_names)
[10:19:20.582]                 removed <- setdiff(old_names, names)
[10:19:20.582]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.582]                   envs[common]]
[10:19:20.582]                 NAMES <- toupper(changed)
[10:19:20.582]                 args <- list()
[10:19:20.582]                 for (kk in seq_along(NAMES)) {
[10:19:20.582]                   name <- changed[[kk]]
[10:19:20.582]                   NAME <- NAMES[[kk]]
[10:19:20.582]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.582]                     next
[10:19:20.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.582]                 }
[10:19:20.582]                 NAMES <- toupper(added)
[10:19:20.582]                 for (kk in seq_along(NAMES)) {
[10:19:20.582]                   name <- added[[kk]]
[10:19:20.582]                   NAME <- NAMES[[kk]]
[10:19:20.582]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.582]                     next
[10:19:20.582]                   args[[name]] <- ""
[10:19:20.582]                 }
[10:19:20.582]                 NAMES <- toupper(removed)
[10:19:20.582]                 for (kk in seq_along(NAMES)) {
[10:19:20.582]                   name <- removed[[kk]]
[10:19:20.582]                   NAME <- NAMES[[kk]]
[10:19:20.582]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.582]                     next
[10:19:20.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.582]                 }
[10:19:20.582]                 if (length(args) > 0) 
[10:19:20.582]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.582]             }
[10:19:20.582]             else {
[10:19:20.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.582]             }
[10:19:20.582]             {
[10:19:20.582]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.582]                   0L) {
[10:19:20.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.582]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.582]                   base::options(opts)
[10:19:20.582]                 }
[10:19:20.582]                 {
[10:19:20.582]                   {
[10:19:20.582]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.582]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.582]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.582]                       inherits = FALSE)
[10:19:20.582]                     NULL
[10:19:20.582]                   }
[10:19:20.582]                   options(future.plan = NULL)
[10:19:20.582]                   if (is.na(NA_character_)) 
[10:19:20.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.582]                     .init = FALSE)
[10:19:20.582]                 }
[10:19:20.582]             }
[10:19:20.582]         }
[10:19:20.582]     })
[10:19:20.582]     if (TRUE) {
[10:19:20.582]         base::sink(type = "output", split = FALSE)
[10:19:20.582]         if (TRUE) {
[10:19:20.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.582]         }
[10:19:20.582]         else {
[10:19:20.582]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.582]         }
[10:19:20.582]         base::close(...future.stdout)
[10:19:20.582]         ...future.stdout <- NULL
[10:19:20.582]     }
[10:19:20.582]     ...future.result$conditions <- ...future.conditions
[10:19:20.582]     ...future.result$finished <- base::Sys.time()
[10:19:20.582]     ...future.result
[10:19:20.582] }
[10:19:20.584] assign_globals() ...
[10:19:20.584] List of 5
[10:19:20.584]  $ ...future.FUN            :function (C, k)  
[10:19:20.584]  $ MoreArgs                 : NULL
[10:19:20.584]  $ ...future.elements_ii    :List of 2
[10:19:20.584]   ..$ :List of 1
[10:19:20.584]   .. ..$ : chr "C"
[10:19:20.584]   ..$ :List of 1
[10:19:20.584]   .. ..$ : int 3
[10:19:20.584]  $ ...future.seeds_ii       : NULL
[10:19:20.584]  $ ...future.globals.maxSize: NULL
[10:19:20.584]  - attr(*, "where")=List of 5
[10:19:20.584]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.584]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.584]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.584]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.584]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.584]  - attr(*, "resolved")= logi FALSE
[10:19:20.584]  - attr(*, "total_size")= num 847
[10:19:20.584]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.584]  - attr(*, "already-done")= logi TRUE
[10:19:20.589] - reassign environment for ‘...future.FUN’
[10:19:20.589] - copied ‘...future.FUN’ to environment
[10:19:20.589] - copied ‘MoreArgs’ to environment
[10:19:20.589] - copied ‘...future.elements_ii’ to environment
[10:19:20.589] - copied ‘...future.seeds_ii’ to environment
[10:19:20.589] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.589] assign_globals() ... done
[10:19:20.589] plan(): Setting new future strategy stack:
[10:19:20.590] List of future strategies:
[10:19:20.590] 1. sequential:
[10:19:20.590]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.590]    - tweaked: FALSE
[10:19:20.590]    - call: NULL
[10:19:20.590] plan(): nbrOfWorkers() = 1
[10:19:20.591] plan(): Setting new future strategy stack:
[10:19:20.591] List of future strategies:
[10:19:20.591] 1. sequential:
[10:19:20.591]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.591]    - tweaked: FALSE
[10:19:20.591]    - call: plan(strategy)
[10:19:20.617] plan(): nbrOfWorkers() = 1
[10:19:20.617] SequentialFuture started (and completed)
[10:19:20.617] - Launch lazy future ... done
[10:19:20.618] run() for ‘SequentialFuture’ ... done
[10:19:20.618] Created future:
[10:19:20.618] SequentialFuture:
[10:19:20.618] Label: ‘future_mapply-3’
[10:19:20.618] Expression:
[10:19:20.618] {
[10:19:20.618]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.618]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.618]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.618]         on.exit(options(oopts), add = TRUE)
[10:19:20.618]     }
[10:19:20.618]     {
[10:19:20.618]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.618]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.618]         do.call(mapply, args = args)
[10:19:20.618]     }
[10:19:20.618] }
[10:19:20.618] Lazy evaluation: FALSE
[10:19:20.618] Asynchronous evaluation: FALSE
[10:19:20.618] Local evaluation: TRUE
[10:19:20.618] Environment: R_GlobalEnv
[10:19:20.618] Capture standard output: TRUE
[10:19:20.618] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.618] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.618] Packages: <none>
[10:19:20.618] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.618] Resolved: TRUE
[10:19:20.618] Value: 50 bytes of class ‘list’
[10:19:20.618] Early signaling: FALSE
[10:19:20.618] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.618] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.619] Chunk #3 of 5 ... DONE
[10:19:20.619] Chunk #4 of 5 ...
[10:19:20.619]  - Finding globals in '...' for chunk #4 ...
[10:19:20.619] getGlobalsAndPackages() ...
[10:19:20.619] Searching for globals...
[10:19:20.619] 
[10:19:20.619] Searching for globals ... DONE
[10:19:20.620] - globals: [0] <none>
[10:19:20.620] getGlobalsAndPackages() ... DONE
[10:19:20.620]    + additional globals found: [n=0] 
[10:19:20.620]    + additional namespaces needed: [n=0] 
[10:19:20.620]  - Finding globals in '...' for chunk #4 ... DONE
[10:19:20.620]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:20.620]  - seeds: <none>
[10:19:20.620]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.620] getGlobalsAndPackages() ...
[10:19:20.620] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.620] Resolving globals: FALSE
[10:19:20.621] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:20.621] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.621] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.621] 
[10:19:20.622] getGlobalsAndPackages() ... DONE
[10:19:20.622] run() for ‘Future’ ...
[10:19:20.622] - state: ‘created’
[10:19:20.622] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.622] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.622] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.622]   - Field: ‘label’
[10:19:20.623]   - Field: ‘local’
[10:19:20.623]   - Field: ‘owner’
[10:19:20.623]   - Field: ‘envir’
[10:19:20.623]   - Field: ‘packages’
[10:19:20.623]   - Field: ‘gc’
[10:19:20.623]   - Field: ‘conditions’
[10:19:20.623]   - Field: ‘expr’
[10:19:20.623]   - Field: ‘uuid’
[10:19:20.623]   - Field: ‘seed’
[10:19:20.623]   - Field: ‘version’
[10:19:20.623]   - Field: ‘result’
[10:19:20.624]   - Field: ‘asynchronous’
[10:19:20.624]   - Field: ‘calls’
[10:19:20.624]   - Field: ‘globals’
[10:19:20.624]   - Field: ‘stdout’
[10:19:20.624]   - Field: ‘earlySignal’
[10:19:20.624]   - Field: ‘lazy’
[10:19:20.624]   - Field: ‘state’
[10:19:20.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.624] - Launch lazy future ...
[10:19:20.624] Packages needed by the future expression (n = 0): <none>
[10:19:20.624] Packages needed by future strategies (n = 0): <none>
[10:19:20.625] {
[10:19:20.625]     {
[10:19:20.625]         {
[10:19:20.625]             ...future.startTime <- base::Sys.time()
[10:19:20.625]             {
[10:19:20.625]                 {
[10:19:20.625]                   {
[10:19:20.625]                     base::local({
[10:19:20.625]                       has_future <- base::requireNamespace("future", 
[10:19:20.625]                         quietly = TRUE)
[10:19:20.625]                       if (has_future) {
[10:19:20.625]                         ns <- base::getNamespace("future")
[10:19:20.625]                         version <- ns[[".package"]][["version"]]
[10:19:20.625]                         if (is.null(version)) 
[10:19:20.625]                           version <- utils::packageVersion("future")
[10:19:20.625]                       }
[10:19:20.625]                       else {
[10:19:20.625]                         version <- NULL
[10:19:20.625]                       }
[10:19:20.625]                       if (!has_future || version < "1.8.0") {
[10:19:20.625]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.625]                           "", base::R.version$version.string), 
[10:19:20.625]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.625]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.625]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.625]                             "release", "version")], collapse = " "), 
[10:19:20.625]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.625]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.625]                           info)
[10:19:20.625]                         info <- base::paste(info, collapse = "; ")
[10:19:20.625]                         if (!has_future) {
[10:19:20.625]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.625]                             info)
[10:19:20.625]                         }
[10:19:20.625]                         else {
[10:19:20.625]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.625]                             info, version)
[10:19:20.625]                         }
[10:19:20.625]                         base::stop(msg)
[10:19:20.625]                       }
[10:19:20.625]                     })
[10:19:20.625]                   }
[10:19:20.625]                   ...future.strategy.old <- future::plan("list")
[10:19:20.625]                   options(future.plan = NULL)
[10:19:20.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.625]                 }
[10:19:20.625]                 ...future.workdir <- getwd()
[10:19:20.625]             }
[10:19:20.625]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.625]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.625]         }
[10:19:20.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.625]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:20.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.625]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.625]             base::names(...future.oldOptions))
[10:19:20.625]     }
[10:19:20.625]     if (FALSE) {
[10:19:20.625]     }
[10:19:20.625]     else {
[10:19:20.625]         if (TRUE) {
[10:19:20.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.625]                 open = "w")
[10:19:20.625]         }
[10:19:20.625]         else {
[10:19:20.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.625]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.625]         }
[10:19:20.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.625]             base::sink(type = "output", split = FALSE)
[10:19:20.625]             base::close(...future.stdout)
[10:19:20.625]         }, add = TRUE)
[10:19:20.625]     }
[10:19:20.625]     ...future.frame <- base::sys.nframe()
[10:19:20.625]     ...future.conditions <- base::list()
[10:19:20.625]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.625]     if (FALSE) {
[10:19:20.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.625]     }
[10:19:20.625]     ...future.result <- base::tryCatch({
[10:19:20.625]         base::withCallingHandlers({
[10:19:20.625]             ...future.value <- base::withVisible(base::local({
[10:19:20.625]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.625]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.625]                   ...future.globals.maxSize)) {
[10:19:20.625]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.625]                   on.exit(options(oopts), add = TRUE)
[10:19:20.625]                 }
[10:19:20.625]                 {
[10:19:20.625]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.625]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.625]                     USE.NAMES = FALSE)
[10:19:20.625]                   do.call(mapply, args = args)
[10:19:20.625]                 }
[10:19:20.625]             }))
[10:19:20.625]             future::FutureResult(value = ...future.value$value, 
[10:19:20.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.625]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.625]                     ...future.globalenv.names))
[10:19:20.625]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.625]         }, condition = base::local({
[10:19:20.625]             c <- base::c
[10:19:20.625]             inherits <- base::inherits
[10:19:20.625]             invokeRestart <- base::invokeRestart
[10:19:20.625]             length <- base::length
[10:19:20.625]             list <- base::list
[10:19:20.625]             seq.int <- base::seq.int
[10:19:20.625]             signalCondition <- base::signalCondition
[10:19:20.625]             sys.calls <- base::sys.calls
[10:19:20.625]             `[[` <- base::`[[`
[10:19:20.625]             `+` <- base::`+`
[10:19:20.625]             `<<-` <- base::`<<-`
[10:19:20.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.625]                   3L)]
[10:19:20.625]             }
[10:19:20.625]             function(cond) {
[10:19:20.625]                 is_error <- inherits(cond, "error")
[10:19:20.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.625]                   NULL)
[10:19:20.625]                 if (is_error) {
[10:19:20.625]                   sessionInformation <- function() {
[10:19:20.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.625]                       search = base::search(), system = base::Sys.info())
[10:19:20.625]                   }
[10:19:20.625]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.625]                     cond$call), session = sessionInformation(), 
[10:19:20.625]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.625]                   signalCondition(cond)
[10:19:20.625]                 }
[10:19:20.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.625]                 "immediateCondition"))) {
[10:19:20.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.625]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.625]                   if (TRUE && !signal) {
[10:19:20.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.625]                     {
[10:19:20.625]                       inherits <- base::inherits
[10:19:20.625]                       invokeRestart <- base::invokeRestart
[10:19:20.625]                       is.null <- base::is.null
[10:19:20.625]                       muffled <- FALSE
[10:19:20.625]                       if (inherits(cond, "message")) {
[10:19:20.625]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.625]                         if (muffled) 
[10:19:20.625]                           invokeRestart("muffleMessage")
[10:19:20.625]                       }
[10:19:20.625]                       else if (inherits(cond, "warning")) {
[10:19:20.625]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.625]                         if (muffled) 
[10:19:20.625]                           invokeRestart("muffleWarning")
[10:19:20.625]                       }
[10:19:20.625]                       else if (inherits(cond, "condition")) {
[10:19:20.625]                         if (!is.null(pattern)) {
[10:19:20.625]                           computeRestarts <- base::computeRestarts
[10:19:20.625]                           grepl <- base::grepl
[10:19:20.625]                           restarts <- computeRestarts(cond)
[10:19:20.625]                           for (restart in restarts) {
[10:19:20.625]                             name <- restart$name
[10:19:20.625]                             if (is.null(name)) 
[10:19:20.625]                               next
[10:19:20.625]                             if (!grepl(pattern, name)) 
[10:19:20.625]                               next
[10:19:20.625]                             invokeRestart(restart)
[10:19:20.625]                             muffled <- TRUE
[10:19:20.625]                             break
[10:19:20.625]                           }
[10:19:20.625]                         }
[10:19:20.625]                       }
[10:19:20.625]                       invisible(muffled)
[10:19:20.625]                     }
[10:19:20.625]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.625]                   }
[10:19:20.625]                 }
[10:19:20.625]                 else {
[10:19:20.625]                   if (TRUE) {
[10:19:20.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.625]                     {
[10:19:20.625]                       inherits <- base::inherits
[10:19:20.625]                       invokeRestart <- base::invokeRestart
[10:19:20.625]                       is.null <- base::is.null
[10:19:20.625]                       muffled <- FALSE
[10:19:20.625]                       if (inherits(cond, "message")) {
[10:19:20.625]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.625]                         if (muffled) 
[10:19:20.625]                           invokeRestart("muffleMessage")
[10:19:20.625]                       }
[10:19:20.625]                       else if (inherits(cond, "warning")) {
[10:19:20.625]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.625]                         if (muffled) 
[10:19:20.625]                           invokeRestart("muffleWarning")
[10:19:20.625]                       }
[10:19:20.625]                       else if (inherits(cond, "condition")) {
[10:19:20.625]                         if (!is.null(pattern)) {
[10:19:20.625]                           computeRestarts <- base::computeRestarts
[10:19:20.625]                           grepl <- base::grepl
[10:19:20.625]                           restarts <- computeRestarts(cond)
[10:19:20.625]                           for (restart in restarts) {
[10:19:20.625]                             name <- restart$name
[10:19:20.625]                             if (is.null(name)) 
[10:19:20.625]                               next
[10:19:20.625]                             if (!grepl(pattern, name)) 
[10:19:20.625]                               next
[10:19:20.625]                             invokeRestart(restart)
[10:19:20.625]                             muffled <- TRUE
[10:19:20.625]                             break
[10:19:20.625]                           }
[10:19:20.625]                         }
[10:19:20.625]                       }
[10:19:20.625]                       invisible(muffled)
[10:19:20.625]                     }
[10:19:20.625]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.625]                   }
[10:19:20.625]                 }
[10:19:20.625]             }
[10:19:20.625]         }))
[10:19:20.625]     }, error = function(ex) {
[10:19:20.625]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.625]                 ...future.rng), started = ...future.startTime, 
[10:19:20.625]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.625]             version = "1.8"), class = "FutureResult")
[10:19:20.625]     }, finally = {
[10:19:20.625]         if (!identical(...future.workdir, getwd())) 
[10:19:20.625]             setwd(...future.workdir)
[10:19:20.625]         {
[10:19:20.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.625]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.625]             }
[10:19:20.625]             base::options(...future.oldOptions)
[10:19:20.625]             if (.Platform$OS.type == "windows") {
[10:19:20.625]                 old_names <- names(...future.oldEnvVars)
[10:19:20.625]                 envs <- base::Sys.getenv()
[10:19:20.625]                 names <- names(envs)
[10:19:20.625]                 common <- intersect(names, old_names)
[10:19:20.625]                 added <- setdiff(names, old_names)
[10:19:20.625]                 removed <- setdiff(old_names, names)
[10:19:20.625]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.625]                   envs[common]]
[10:19:20.625]                 NAMES <- toupper(changed)
[10:19:20.625]                 args <- list()
[10:19:20.625]                 for (kk in seq_along(NAMES)) {
[10:19:20.625]                   name <- changed[[kk]]
[10:19:20.625]                   NAME <- NAMES[[kk]]
[10:19:20.625]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.625]                     next
[10:19:20.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.625]                 }
[10:19:20.625]                 NAMES <- toupper(added)
[10:19:20.625]                 for (kk in seq_along(NAMES)) {
[10:19:20.625]                   name <- added[[kk]]
[10:19:20.625]                   NAME <- NAMES[[kk]]
[10:19:20.625]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.625]                     next
[10:19:20.625]                   args[[name]] <- ""
[10:19:20.625]                 }
[10:19:20.625]                 NAMES <- toupper(removed)
[10:19:20.625]                 for (kk in seq_along(NAMES)) {
[10:19:20.625]                   name <- removed[[kk]]
[10:19:20.625]                   NAME <- NAMES[[kk]]
[10:19:20.625]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.625]                     next
[10:19:20.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.625]                 }
[10:19:20.625]                 if (length(args) > 0) 
[10:19:20.625]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.625]             }
[10:19:20.625]             else {
[10:19:20.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.625]             }
[10:19:20.625]             {
[10:19:20.625]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.625]                   0L) {
[10:19:20.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.625]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.625]                   base::options(opts)
[10:19:20.625]                 }
[10:19:20.625]                 {
[10:19:20.625]                   {
[10:19:20.625]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.625]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.625]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.625]                       inherits = FALSE)
[10:19:20.625]                     NULL
[10:19:20.625]                   }
[10:19:20.625]                   options(future.plan = NULL)
[10:19:20.625]                   if (is.na(NA_character_)) 
[10:19:20.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.625]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.625]                     .init = FALSE)
[10:19:20.625]                 }
[10:19:20.625]             }
[10:19:20.625]         }
[10:19:20.625]     })
[10:19:20.625]     if (TRUE) {
[10:19:20.625]         base::sink(type = "output", split = FALSE)
[10:19:20.625]         if (TRUE) {
[10:19:20.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.625]         }
[10:19:20.625]         else {
[10:19:20.625]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.625]         }
[10:19:20.625]         base::close(...future.stdout)
[10:19:20.625]         ...future.stdout <- NULL
[10:19:20.625]     }
[10:19:20.625]     ...future.result$conditions <- ...future.conditions
[10:19:20.625]     ...future.result$finished <- base::Sys.time()
[10:19:20.625]     ...future.result
[10:19:20.625] }
[10:19:20.627] assign_globals() ...
[10:19:20.627] List of 5
[10:19:20.627]  $ ...future.FUN            :function (C, k)  
[10:19:20.627]  $ MoreArgs                 : NULL
[10:19:20.627]  $ ...future.elements_ii    :List of 2
[10:19:20.627]   ..$ :List of 1
[10:19:20.627]   .. ..$ : chr "D"
[10:19:20.627]   ..$ :List of 1
[10:19:20.627]   .. ..$ : int 2
[10:19:20.627]  $ ...future.seeds_ii       : NULL
[10:19:20.627]  $ ...future.globals.maxSize: NULL
[10:19:20.627]  - attr(*, "where")=List of 5
[10:19:20.627]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.627]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.627]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.627]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.627]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.627]  - attr(*, "resolved")= logi FALSE
[10:19:20.627]  - attr(*, "total_size")= num 847
[10:19:20.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.627]  - attr(*, "already-done")= logi TRUE
[10:19:20.632] - reassign environment for ‘...future.FUN’
[10:19:20.632] - copied ‘...future.FUN’ to environment
[10:19:20.632] - copied ‘MoreArgs’ to environment
[10:19:20.632] - copied ‘...future.elements_ii’ to environment
[10:19:20.632] - copied ‘...future.seeds_ii’ to environment
[10:19:20.632] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.632] assign_globals() ... done
[10:19:20.632] plan(): Setting new future strategy stack:
[10:19:20.632] List of future strategies:
[10:19:20.632] 1. sequential:
[10:19:20.632]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.632]    - tweaked: FALSE
[10:19:20.632]    - call: NULL
[10:19:20.633] plan(): nbrOfWorkers() = 1
[10:19:20.634] plan(): Setting new future strategy stack:
[10:19:20.634] List of future strategies:
[10:19:20.634] 1. sequential:
[10:19:20.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.634]    - tweaked: FALSE
[10:19:20.634]    - call: plan(strategy)
[10:19:20.634] plan(): nbrOfWorkers() = 1
[10:19:20.634] SequentialFuture started (and completed)
[10:19:20.634] - Launch lazy future ... done
[10:19:20.634] run() for ‘SequentialFuture’ ... done
[10:19:20.635] Created future:
[10:19:20.635] SequentialFuture:
[10:19:20.635] Label: ‘future_mapply-4’
[10:19:20.635] Expression:
[10:19:20.635] {
[10:19:20.635]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.635]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.635]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.635]         on.exit(options(oopts), add = TRUE)
[10:19:20.635]     }
[10:19:20.635]     {
[10:19:20.635]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.635]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.635]         do.call(mapply, args = args)
[10:19:20.635]     }
[10:19:20.635] }
[10:19:20.635] Lazy evaluation: FALSE
[10:19:20.635] Asynchronous evaluation: FALSE
[10:19:20.635] Local evaluation: TRUE
[10:19:20.635] Environment: R_GlobalEnv
[10:19:20.635] Capture standard output: TRUE
[10:19:20.635] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.635] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.635] Packages: <none>
[10:19:20.635] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.635] Resolved: TRUE
[10:19:20.635] Value: 49 bytes of class ‘list’
[10:19:20.635] Early signaling: FALSE
[10:19:20.635] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.635] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.635] Chunk #4 of 5 ... DONE
[10:19:20.636] Chunk #5 of 5 ...
[10:19:20.636]  - Finding globals in '...' for chunk #5 ...
[10:19:20.636] getGlobalsAndPackages() ...
[10:19:20.636] Searching for globals...
[10:19:20.636] 
[10:19:20.636] Searching for globals ... DONE
[10:19:20.636] - globals: [0] <none>
[10:19:20.636] getGlobalsAndPackages() ... DONE
[10:19:20.636]    + additional globals found: [n=0] 
[10:19:20.637]    + additional namespaces needed: [n=0] 
[10:19:20.637]  - Finding globals in '...' for chunk #5 ... DONE
[10:19:20.637]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:20.637]  - seeds: <none>
[10:19:20.637]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.637] getGlobalsAndPackages() ...
[10:19:20.637] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.637] Resolving globals: FALSE
[10:19:20.638] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:20.638] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.638] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.638] 
[10:19:20.638] getGlobalsAndPackages() ... DONE
[10:19:20.639] run() for ‘Future’ ...
[10:19:20.639] - state: ‘created’
[10:19:20.639] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.639] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.639] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.639]   - Field: ‘label’
[10:19:20.639]   - Field: ‘local’
[10:19:20.639]   - Field: ‘owner’
[10:19:20.639]   - Field: ‘envir’
[10:19:20.640]   - Field: ‘packages’
[10:19:20.640]   - Field: ‘gc’
[10:19:20.640]   - Field: ‘conditions’
[10:19:20.640]   - Field: ‘expr’
[10:19:20.640]   - Field: ‘uuid’
[10:19:20.640]   - Field: ‘seed’
[10:19:20.640]   - Field: ‘version’
[10:19:20.640]   - Field: ‘result’
[10:19:20.640]   - Field: ‘asynchronous’
[10:19:20.640]   - Field: ‘calls’
[10:19:20.640]   - Field: ‘globals’
[10:19:20.640]   - Field: ‘stdout’
[10:19:20.641]   - Field: ‘earlySignal’
[10:19:20.641]   - Field: ‘lazy’
[10:19:20.641]   - Field: ‘state’
[10:19:20.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.641] - Launch lazy future ...
[10:19:20.641] Packages needed by the future expression (n = 0): <none>
[10:19:20.641] Packages needed by future strategies (n = 0): <none>
[10:19:20.643] {
[10:19:20.643]     {
[10:19:20.643]         {
[10:19:20.643]             ...future.startTime <- base::Sys.time()
[10:19:20.643]             {
[10:19:20.643]                 {
[10:19:20.643]                   {
[10:19:20.643]                     base::local({
[10:19:20.643]                       has_future <- base::requireNamespace("future", 
[10:19:20.643]                         quietly = TRUE)
[10:19:20.643]                       if (has_future) {
[10:19:20.643]                         ns <- base::getNamespace("future")
[10:19:20.643]                         version <- ns[[".package"]][["version"]]
[10:19:20.643]                         if (is.null(version)) 
[10:19:20.643]                           version <- utils::packageVersion("future")
[10:19:20.643]                       }
[10:19:20.643]                       else {
[10:19:20.643]                         version <- NULL
[10:19:20.643]                       }
[10:19:20.643]                       if (!has_future || version < "1.8.0") {
[10:19:20.643]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.643]                           "", base::R.version$version.string), 
[10:19:20.643]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.643]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.643]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.643]                             "release", "version")], collapse = " "), 
[10:19:20.643]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.643]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.643]                           info)
[10:19:20.643]                         info <- base::paste(info, collapse = "; ")
[10:19:20.643]                         if (!has_future) {
[10:19:20.643]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.643]                             info)
[10:19:20.643]                         }
[10:19:20.643]                         else {
[10:19:20.643]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.643]                             info, version)
[10:19:20.643]                         }
[10:19:20.643]                         base::stop(msg)
[10:19:20.643]                       }
[10:19:20.643]                     })
[10:19:20.643]                   }
[10:19:20.643]                   ...future.strategy.old <- future::plan("list")
[10:19:20.643]                   options(future.plan = NULL)
[10:19:20.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.643]                 }
[10:19:20.643]                 ...future.workdir <- getwd()
[10:19:20.643]             }
[10:19:20.643]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.643]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.643]         }
[10:19:20.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.643]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:20.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.643]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.643]             base::names(...future.oldOptions))
[10:19:20.643]     }
[10:19:20.643]     if (FALSE) {
[10:19:20.643]     }
[10:19:20.643]     else {
[10:19:20.643]         if (TRUE) {
[10:19:20.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.643]                 open = "w")
[10:19:20.643]         }
[10:19:20.643]         else {
[10:19:20.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.643]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.643]         }
[10:19:20.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.643]             base::sink(type = "output", split = FALSE)
[10:19:20.643]             base::close(...future.stdout)
[10:19:20.643]         }, add = TRUE)
[10:19:20.643]     }
[10:19:20.643]     ...future.frame <- base::sys.nframe()
[10:19:20.643]     ...future.conditions <- base::list()
[10:19:20.643]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.643]     if (FALSE) {
[10:19:20.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.643]     }
[10:19:20.643]     ...future.result <- base::tryCatch({
[10:19:20.643]         base::withCallingHandlers({
[10:19:20.643]             ...future.value <- base::withVisible(base::local({
[10:19:20.643]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.643]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.643]                   ...future.globals.maxSize)) {
[10:19:20.643]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.643]                   on.exit(options(oopts), add = TRUE)
[10:19:20.643]                 }
[10:19:20.643]                 {
[10:19:20.643]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.643]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.643]                     USE.NAMES = FALSE)
[10:19:20.643]                   do.call(mapply, args = args)
[10:19:20.643]                 }
[10:19:20.643]             }))
[10:19:20.643]             future::FutureResult(value = ...future.value$value, 
[10:19:20.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.643]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.643]                     ...future.globalenv.names))
[10:19:20.643]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.643]         }, condition = base::local({
[10:19:20.643]             c <- base::c
[10:19:20.643]             inherits <- base::inherits
[10:19:20.643]             invokeRestart <- base::invokeRestart
[10:19:20.643]             length <- base::length
[10:19:20.643]             list <- base::list
[10:19:20.643]             seq.int <- base::seq.int
[10:19:20.643]             signalCondition <- base::signalCondition
[10:19:20.643]             sys.calls <- base::sys.calls
[10:19:20.643]             `[[` <- base::`[[`
[10:19:20.643]             `+` <- base::`+`
[10:19:20.643]             `<<-` <- base::`<<-`
[10:19:20.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.643]                   3L)]
[10:19:20.643]             }
[10:19:20.643]             function(cond) {
[10:19:20.643]                 is_error <- inherits(cond, "error")
[10:19:20.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.643]                   NULL)
[10:19:20.643]                 if (is_error) {
[10:19:20.643]                   sessionInformation <- function() {
[10:19:20.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.643]                       search = base::search(), system = base::Sys.info())
[10:19:20.643]                   }
[10:19:20.643]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.643]                     cond$call), session = sessionInformation(), 
[10:19:20.643]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.643]                   signalCondition(cond)
[10:19:20.643]                 }
[10:19:20.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.643]                 "immediateCondition"))) {
[10:19:20.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.643]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.643]                   if (TRUE && !signal) {
[10:19:20.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.643]                     {
[10:19:20.643]                       inherits <- base::inherits
[10:19:20.643]                       invokeRestart <- base::invokeRestart
[10:19:20.643]                       is.null <- base::is.null
[10:19:20.643]                       muffled <- FALSE
[10:19:20.643]                       if (inherits(cond, "message")) {
[10:19:20.643]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.643]                         if (muffled) 
[10:19:20.643]                           invokeRestart("muffleMessage")
[10:19:20.643]                       }
[10:19:20.643]                       else if (inherits(cond, "warning")) {
[10:19:20.643]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.643]                         if (muffled) 
[10:19:20.643]                           invokeRestart("muffleWarning")
[10:19:20.643]                       }
[10:19:20.643]                       else if (inherits(cond, "condition")) {
[10:19:20.643]                         if (!is.null(pattern)) {
[10:19:20.643]                           computeRestarts <- base::computeRestarts
[10:19:20.643]                           grepl <- base::grepl
[10:19:20.643]                           restarts <- computeRestarts(cond)
[10:19:20.643]                           for (restart in restarts) {
[10:19:20.643]                             name <- restart$name
[10:19:20.643]                             if (is.null(name)) 
[10:19:20.643]                               next
[10:19:20.643]                             if (!grepl(pattern, name)) 
[10:19:20.643]                               next
[10:19:20.643]                             invokeRestart(restart)
[10:19:20.643]                             muffled <- TRUE
[10:19:20.643]                             break
[10:19:20.643]                           }
[10:19:20.643]                         }
[10:19:20.643]                       }
[10:19:20.643]                       invisible(muffled)
[10:19:20.643]                     }
[10:19:20.643]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.643]                   }
[10:19:20.643]                 }
[10:19:20.643]                 else {
[10:19:20.643]                   if (TRUE) {
[10:19:20.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.643]                     {
[10:19:20.643]                       inherits <- base::inherits
[10:19:20.643]                       invokeRestart <- base::invokeRestart
[10:19:20.643]                       is.null <- base::is.null
[10:19:20.643]                       muffled <- FALSE
[10:19:20.643]                       if (inherits(cond, "message")) {
[10:19:20.643]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.643]                         if (muffled) 
[10:19:20.643]                           invokeRestart("muffleMessage")
[10:19:20.643]                       }
[10:19:20.643]                       else if (inherits(cond, "warning")) {
[10:19:20.643]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.643]                         if (muffled) 
[10:19:20.643]                           invokeRestart("muffleWarning")
[10:19:20.643]                       }
[10:19:20.643]                       else if (inherits(cond, "condition")) {
[10:19:20.643]                         if (!is.null(pattern)) {
[10:19:20.643]                           computeRestarts <- base::computeRestarts
[10:19:20.643]                           grepl <- base::grepl
[10:19:20.643]                           restarts <- computeRestarts(cond)
[10:19:20.643]                           for (restart in restarts) {
[10:19:20.643]                             name <- restart$name
[10:19:20.643]                             if (is.null(name)) 
[10:19:20.643]                               next
[10:19:20.643]                             if (!grepl(pattern, name)) 
[10:19:20.643]                               next
[10:19:20.643]                             invokeRestart(restart)
[10:19:20.643]                             muffled <- TRUE
[10:19:20.643]                             break
[10:19:20.643]                           }
[10:19:20.643]                         }
[10:19:20.643]                       }
[10:19:20.643]                       invisible(muffled)
[10:19:20.643]                     }
[10:19:20.643]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.643]                   }
[10:19:20.643]                 }
[10:19:20.643]             }
[10:19:20.643]         }))
[10:19:20.643]     }, error = function(ex) {
[10:19:20.643]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.643]                 ...future.rng), started = ...future.startTime, 
[10:19:20.643]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.643]             version = "1.8"), class = "FutureResult")
[10:19:20.643]     }, finally = {
[10:19:20.643]         if (!identical(...future.workdir, getwd())) 
[10:19:20.643]             setwd(...future.workdir)
[10:19:20.643]         {
[10:19:20.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.643]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.643]             }
[10:19:20.643]             base::options(...future.oldOptions)
[10:19:20.643]             if (.Platform$OS.type == "windows") {
[10:19:20.643]                 old_names <- names(...future.oldEnvVars)
[10:19:20.643]                 envs <- base::Sys.getenv()
[10:19:20.643]                 names <- names(envs)
[10:19:20.643]                 common <- intersect(names, old_names)
[10:19:20.643]                 added <- setdiff(names, old_names)
[10:19:20.643]                 removed <- setdiff(old_names, names)
[10:19:20.643]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.643]                   envs[common]]
[10:19:20.643]                 NAMES <- toupper(changed)
[10:19:20.643]                 args <- list()
[10:19:20.643]                 for (kk in seq_along(NAMES)) {
[10:19:20.643]                   name <- changed[[kk]]
[10:19:20.643]                   NAME <- NAMES[[kk]]
[10:19:20.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.643]                     next
[10:19:20.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.643]                 }
[10:19:20.643]                 NAMES <- toupper(added)
[10:19:20.643]                 for (kk in seq_along(NAMES)) {
[10:19:20.643]                   name <- added[[kk]]
[10:19:20.643]                   NAME <- NAMES[[kk]]
[10:19:20.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.643]                     next
[10:19:20.643]                   args[[name]] <- ""
[10:19:20.643]                 }
[10:19:20.643]                 NAMES <- toupper(removed)
[10:19:20.643]                 for (kk in seq_along(NAMES)) {
[10:19:20.643]                   name <- removed[[kk]]
[10:19:20.643]                   NAME <- NAMES[[kk]]
[10:19:20.643]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.643]                     next
[10:19:20.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.643]                 }
[10:19:20.643]                 if (length(args) > 0) 
[10:19:20.643]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.643]             }
[10:19:20.643]             else {
[10:19:20.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.643]             }
[10:19:20.643]             {
[10:19:20.643]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.643]                   0L) {
[10:19:20.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.643]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.643]                   base::options(opts)
[10:19:20.643]                 }
[10:19:20.643]                 {
[10:19:20.643]                   {
[10:19:20.643]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.643]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.643]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.643]                       inherits = FALSE)
[10:19:20.643]                     NULL
[10:19:20.643]                   }
[10:19:20.643]                   options(future.plan = NULL)
[10:19:20.643]                   if (is.na(NA_character_)) 
[10:19:20.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.643]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.643]                     .init = FALSE)
[10:19:20.643]                 }
[10:19:20.643]             }
[10:19:20.643]         }
[10:19:20.643]     })
[10:19:20.643]     if (TRUE) {
[10:19:20.643]         base::sink(type = "output", split = FALSE)
[10:19:20.643]         if (TRUE) {
[10:19:20.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.643]         }
[10:19:20.643]         else {
[10:19:20.643]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.643]         }
[10:19:20.643]         base::close(...future.stdout)
[10:19:20.643]         ...future.stdout <- NULL
[10:19:20.643]     }
[10:19:20.643]     ...future.result$conditions <- ...future.conditions
[10:19:20.643]     ...future.result$finished <- base::Sys.time()
[10:19:20.643]     ...future.result
[10:19:20.643] }
[10:19:20.645] assign_globals() ...
[10:19:20.645] List of 5
[10:19:20.645]  $ ...future.FUN            :function (C, k)  
[10:19:20.645]  $ MoreArgs                 : NULL
[10:19:20.645]  $ ...future.elements_ii    :List of 2
[10:19:20.645]   ..$ :List of 1
[10:19:20.645]   .. ..$ : chr "E"
[10:19:20.645]   ..$ :List of 1
[10:19:20.645]   .. ..$ : int 1
[10:19:20.645]  $ ...future.seeds_ii       : NULL
[10:19:20.645]  $ ...future.globals.maxSize: NULL
[10:19:20.645]  - attr(*, "where")=List of 5
[10:19:20.645]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.645]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.645]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.645]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.645]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.645]  - attr(*, "resolved")= logi FALSE
[10:19:20.645]  - attr(*, "total_size")= num 847
[10:19:20.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.645]  - attr(*, "already-done")= logi TRUE
[10:19:20.650] - reassign environment for ‘...future.FUN’
[10:19:20.650] - copied ‘...future.FUN’ to environment
[10:19:20.650] - copied ‘MoreArgs’ to environment
[10:19:20.650] - copied ‘...future.elements_ii’ to environment
[10:19:20.650] - copied ‘...future.seeds_ii’ to environment
[10:19:20.650] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.650] assign_globals() ... done
[10:19:20.650] plan(): Setting new future strategy stack:
[10:19:20.651] List of future strategies:
[10:19:20.651] 1. sequential:
[10:19:20.651]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.651]    - tweaked: FALSE
[10:19:20.651]    - call: NULL
[10:19:20.651] plan(): nbrOfWorkers() = 1
[10:19:20.652] plan(): Setting new future strategy stack:
[10:19:20.652] List of future strategies:
[10:19:20.652] 1. sequential:
[10:19:20.652]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.652]    - tweaked: FALSE
[10:19:20.652]    - call: plan(strategy)
[10:19:20.652] plan(): nbrOfWorkers() = 1
[10:19:20.652] SequentialFuture started (and completed)
[10:19:20.652] - Launch lazy future ... done
[10:19:20.653] run() for ‘SequentialFuture’ ... done
[10:19:20.653] Created future:
[10:19:20.653] SequentialFuture:
[10:19:20.653] Label: ‘future_mapply-5’
[10:19:20.653] Expression:
[10:19:20.653] {
[10:19:20.653]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.653]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.653]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.653]         on.exit(options(oopts), add = TRUE)
[10:19:20.653]     }
[10:19:20.653]     {
[10:19:20.653]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.653]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.653]         do.call(mapply, args = args)
[10:19:20.653]     }
[10:19:20.653] }
[10:19:20.653] Lazy evaluation: FALSE
[10:19:20.653] Asynchronous evaluation: FALSE
[10:19:20.653] Local evaluation: TRUE
[10:19:20.653] Environment: R_GlobalEnv
[10:19:20.653] Capture standard output: TRUE
[10:19:20.653] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.653] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.653] Packages: <none>
[10:19:20.653] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.653] Resolved: TRUE
[10:19:20.653] Value: 48 bytes of class ‘list’
[10:19:20.653] Early signaling: FALSE
[10:19:20.653] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.653] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.654] Chunk #5 of 5 ... DONE
[10:19:20.654] Launching 5 futures (chunks) ... DONE
[10:19:20.654] Resolving 5 futures (chunks) ...
[10:19:20.654] resolve() on list ...
[10:19:20.654]  recursive: 0
[10:19:20.654]  length: 5
[10:19:20.654] 
[10:19:20.654] resolved() for ‘SequentialFuture’ ...
[10:19:20.654] - state: ‘finished’
[10:19:20.654] - run: TRUE
[10:19:20.654] - result: ‘FutureResult’
[10:19:20.654] resolved() for ‘SequentialFuture’ ... done
[10:19:20.655] Future #1
[10:19:20.655] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.655] - nx: 5
[10:19:20.655] - relay: TRUE
[10:19:20.655] - stdout: TRUE
[10:19:20.655] - signal: TRUE
[10:19:20.655] - resignal: FALSE
[10:19:20.655] - force: TRUE
[10:19:20.655] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:19:20.655] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:19:20.655]  - until=1
[10:19:20.656]  - relaying element #1
[10:19:20.656] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:20.656] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:20.656] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.656]  length: 4 (resolved future 1)
[10:19:20.656] resolved() for ‘SequentialFuture’ ...
[10:19:20.656] - state: ‘finished’
[10:19:20.656] - run: TRUE
[10:19:20.656] - result: ‘FutureResult’
[10:19:20.656] resolved() for ‘SequentialFuture’ ... done
[10:19:20.657] Future #2
[10:19:20.657] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:19:20.657] - nx: 5
[10:19:20.657] - relay: TRUE
[10:19:20.657] - stdout: TRUE
[10:19:20.657] - signal: TRUE
[10:19:20.657] - resignal: FALSE
[10:19:20.657] - force: TRUE
[10:19:20.657] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:20.657] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:20.657]  - until=2
[10:19:20.657]  - relaying element #2
[10:19:20.658] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:20.658] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:20.658] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:19:20.658]  length: 3 (resolved future 2)
[10:19:20.658] resolved() for ‘SequentialFuture’ ...
[10:19:20.658] - state: ‘finished’
[10:19:20.658] - run: TRUE
[10:19:20.658] - result: ‘FutureResult’
[10:19:20.658] resolved() for ‘SequentialFuture’ ... done
[10:19:20.658] Future #3
[10:19:20.659] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:19:20.659] - nx: 5
[10:19:20.659] - relay: TRUE
[10:19:20.659] - stdout: TRUE
[10:19:20.659] - signal: TRUE
[10:19:20.659] - resignal: FALSE
[10:19:20.659] - force: TRUE
[10:19:20.659] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:20.659] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:20.659]  - until=3
[10:19:20.659]  - relaying element #3
[10:19:20.660] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:20.660] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:20.660] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:19:20.660]  length: 2 (resolved future 3)
[10:19:20.660] resolved() for ‘SequentialFuture’ ...
[10:19:20.660] - state: ‘finished’
[10:19:20.660] - run: TRUE
[10:19:20.660] - result: ‘FutureResult’
[10:19:20.660] resolved() for ‘SequentialFuture’ ... done
[10:19:20.660] Future #4
[10:19:20.661] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:19:20.661] - nx: 5
[10:19:20.661] - relay: TRUE
[10:19:20.661] - stdout: TRUE
[10:19:20.661] - signal: TRUE
[10:19:20.661] - resignal: FALSE
[10:19:20.661] - force: TRUE
[10:19:20.661] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:20.661] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:20.661]  - until=4
[10:19:20.661]  - relaying element #4
[10:19:20.661] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:20.662] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:20.662] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:19:20.662]  length: 1 (resolved future 4)
[10:19:20.662] resolved() for ‘SequentialFuture’ ...
[10:19:20.662] - state: ‘finished’
[10:19:20.662] - run: TRUE
[10:19:20.662] - result: ‘FutureResult’
[10:19:20.662] resolved() for ‘SequentialFuture’ ... done
[10:19:20.662] Future #5
[10:19:20.662] signalConditionsASAP(SequentialFuture, pos=5) ...
[10:19:20.662] - nx: 5
[10:19:20.663] - relay: TRUE
[10:19:20.663] - stdout: TRUE
[10:19:20.663] - signal: TRUE
[10:19:20.663] - resignal: FALSE
[10:19:20.663] - force: TRUE
[10:19:20.663] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:20.663] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:20.663]  - until=5
[10:19:20.663]  - relaying element #5
[10:19:20.663] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:20.663] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:20.664] signalConditionsASAP(SequentialFuture, pos=5) ... done
[10:19:20.664]  length: 0 (resolved future 5)
[10:19:20.664] Relaying remaining futures
[10:19:20.664] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.664] - nx: 5
[10:19:20.664] - relay: TRUE
[10:19:20.664] - stdout: TRUE
[10:19:20.664] - signal: TRUE
[10:19:20.664] - resignal: FALSE
[10:19:20.664] - force: TRUE
[10:19:20.664] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:20.664] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[10:19:20.664] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:20.665] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:20.665] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.665] resolve() on list ... DONE
[10:19:20.665]  - Number of value chunks collected: 5
[10:19:20.665] Resolving 5 futures (chunks) ... DONE
[10:19:20.665] Reducing values from 5 chunks ...
[10:19:20.665]  - Number of values collected after concatenation: 5
[10:19:20.665]  - Number of values expected: 5
[10:19:20.665] Reducing values from 5 chunks ... DONE
[10:19:20.666] future_mapply() ... DONE
[10:19:20.667] future_mapply() ...
[10:19:20.667] Number of chunks: 1
[10:19:20.667] getGlobalsAndPackagesXApply() ...
[10:19:20.667]  - future.globals: TRUE
[10:19:20.668] getGlobalsAndPackages() ...
[10:19:20.668] Searching for globals...
[10:19:20.669] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:20.669] Searching for globals ... DONE
[10:19:20.669] Resolving globals: FALSE
[10:19:20.669] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:20.670] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:20.670] - globals: [1] ‘FUN’
[10:19:20.670] 
[10:19:20.670] getGlobalsAndPackages() ... DONE
[10:19:20.670]  - globals found/used: [n=1] ‘FUN’
[10:19:20.670]  - needed namespaces: [n=0] 
[10:19:20.670] Finding globals ... DONE
[10:19:20.670] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.671] List of 2
[10:19:20.671]  $ ...future.FUN:function (C, k)  
[10:19:20.671]  $ MoreArgs     : list()
[10:19:20.671]  - attr(*, "where")=List of 2
[10:19:20.671]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.671]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.671]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.671]  - attr(*, "resolved")= logi FALSE
[10:19:20.671]  - attr(*, "total_size")= num NA
[10:19:20.673] Packages to be attached in all futures: [n=0] 
[10:19:20.673] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.673] Number of futures (= number of chunks): 1
[10:19:20.673] Launching 1 futures (chunks) ...
[10:19:20.673] Chunk #1 of 1 ...
[10:19:20.673]  - Finding globals in '...' for chunk #1 ...
[10:19:20.674] getGlobalsAndPackages() ...
[10:19:20.674] Searching for globals...
[10:19:20.674] 
[10:19:20.674] Searching for globals ... DONE
[10:19:20.674] - globals: [0] <none>
[10:19:20.674] getGlobalsAndPackages() ... DONE
[10:19:20.674]    + additional globals found: [n=0] 
[10:19:20.674]    + additional namespaces needed: [n=0] 
[10:19:20.674]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.674]  - seeds: <none>
[10:19:20.675]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.675] getGlobalsAndPackages() ...
[10:19:20.675] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.675] Resolving globals: FALSE
[10:19:20.675] The total size of the 5 globals is 967 bytes (967 bytes)
[10:19:20.676] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 967 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (192 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:20.676] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.676] 
[10:19:20.676] getGlobalsAndPackages() ... DONE
[10:19:20.676] run() for ‘Future’ ...
[10:19:20.676] - state: ‘created’
[10:19:20.676] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.677] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.677] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.677]   - Field: ‘label’
[10:19:20.677]   - Field: ‘local’
[10:19:20.677]   - Field: ‘owner’
[10:19:20.677]   - Field: ‘envir’
[10:19:20.677]   - Field: ‘packages’
[10:19:20.677]   - Field: ‘gc’
[10:19:20.677]   - Field: ‘conditions’
[10:19:20.677]   - Field: ‘expr’
[10:19:20.678]   - Field: ‘uuid’
[10:19:20.678]   - Field: ‘seed’
[10:19:20.678]   - Field: ‘version’
[10:19:20.678]   - Field: ‘result’
[10:19:20.678]   - Field: ‘asynchronous’
[10:19:20.678]   - Field: ‘calls’
[10:19:20.678]   - Field: ‘globals’
[10:19:20.678]   - Field: ‘stdout’
[10:19:20.678]   - Field: ‘earlySignal’
[10:19:20.678]   - Field: ‘lazy’
[10:19:20.678]   - Field: ‘state’
[10:19:20.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.679] - Launch lazy future ...
[10:19:20.679] Packages needed by the future expression (n = 0): <none>
[10:19:20.679] Packages needed by future strategies (n = 0): <none>
[10:19:20.679] {
[10:19:20.679]     {
[10:19:20.679]         {
[10:19:20.679]             ...future.startTime <- base::Sys.time()
[10:19:20.679]             {
[10:19:20.679]                 {
[10:19:20.679]                   {
[10:19:20.679]                     base::local({
[10:19:20.679]                       has_future <- base::requireNamespace("future", 
[10:19:20.679]                         quietly = TRUE)
[10:19:20.679]                       if (has_future) {
[10:19:20.679]                         ns <- base::getNamespace("future")
[10:19:20.679]                         version <- ns[[".package"]][["version"]]
[10:19:20.679]                         if (is.null(version)) 
[10:19:20.679]                           version <- utils::packageVersion("future")
[10:19:20.679]                       }
[10:19:20.679]                       else {
[10:19:20.679]                         version <- NULL
[10:19:20.679]                       }
[10:19:20.679]                       if (!has_future || version < "1.8.0") {
[10:19:20.679]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.679]                           "", base::R.version$version.string), 
[10:19:20.679]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.679]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.679]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.679]                             "release", "version")], collapse = " "), 
[10:19:20.679]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.679]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.679]                           info)
[10:19:20.679]                         info <- base::paste(info, collapse = "; ")
[10:19:20.679]                         if (!has_future) {
[10:19:20.679]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.679]                             info)
[10:19:20.679]                         }
[10:19:20.679]                         else {
[10:19:20.679]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.679]                             info, version)
[10:19:20.679]                         }
[10:19:20.679]                         base::stop(msg)
[10:19:20.679]                       }
[10:19:20.679]                     })
[10:19:20.679]                   }
[10:19:20.679]                   ...future.strategy.old <- future::plan("list")
[10:19:20.679]                   options(future.plan = NULL)
[10:19:20.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.679]                 }
[10:19:20.679]                 ...future.workdir <- getwd()
[10:19:20.679]             }
[10:19:20.679]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.679]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.679]         }
[10:19:20.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.679]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.679]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.679]             base::names(...future.oldOptions))
[10:19:20.679]     }
[10:19:20.679]     if (FALSE) {
[10:19:20.679]     }
[10:19:20.679]     else {
[10:19:20.679]         if (TRUE) {
[10:19:20.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.679]                 open = "w")
[10:19:20.679]         }
[10:19:20.679]         else {
[10:19:20.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.679]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.679]         }
[10:19:20.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.679]             base::sink(type = "output", split = FALSE)
[10:19:20.679]             base::close(...future.stdout)
[10:19:20.679]         }, add = TRUE)
[10:19:20.679]     }
[10:19:20.679]     ...future.frame <- base::sys.nframe()
[10:19:20.679]     ...future.conditions <- base::list()
[10:19:20.679]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.679]     if (FALSE) {
[10:19:20.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.679]     }
[10:19:20.679]     ...future.result <- base::tryCatch({
[10:19:20.679]         base::withCallingHandlers({
[10:19:20.679]             ...future.value <- base::withVisible(base::local({
[10:19:20.679]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.679]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.679]                   ...future.globals.maxSize)) {
[10:19:20.679]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.679]                   on.exit(options(oopts), add = TRUE)
[10:19:20.679]                 }
[10:19:20.679]                 {
[10:19:20.679]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.679]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.679]                     USE.NAMES = FALSE)
[10:19:20.679]                   do.call(mapply, args = args)
[10:19:20.679]                 }
[10:19:20.679]             }))
[10:19:20.679]             future::FutureResult(value = ...future.value$value, 
[10:19:20.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.679]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.679]                     ...future.globalenv.names))
[10:19:20.679]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.679]         }, condition = base::local({
[10:19:20.679]             c <- base::c
[10:19:20.679]             inherits <- base::inherits
[10:19:20.679]             invokeRestart <- base::invokeRestart
[10:19:20.679]             length <- base::length
[10:19:20.679]             list <- base::list
[10:19:20.679]             seq.int <- base::seq.int
[10:19:20.679]             signalCondition <- base::signalCondition
[10:19:20.679]             sys.calls <- base::sys.calls
[10:19:20.679]             `[[` <- base::`[[`
[10:19:20.679]             `+` <- base::`+`
[10:19:20.679]             `<<-` <- base::`<<-`
[10:19:20.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.679]                   3L)]
[10:19:20.679]             }
[10:19:20.679]             function(cond) {
[10:19:20.679]                 is_error <- inherits(cond, "error")
[10:19:20.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.679]                   NULL)
[10:19:20.679]                 if (is_error) {
[10:19:20.679]                   sessionInformation <- function() {
[10:19:20.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.679]                       search = base::search(), system = base::Sys.info())
[10:19:20.679]                   }
[10:19:20.679]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.679]                     cond$call), session = sessionInformation(), 
[10:19:20.679]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.679]                   signalCondition(cond)
[10:19:20.679]                 }
[10:19:20.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.679]                 "immediateCondition"))) {
[10:19:20.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.679]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.679]                   if (TRUE && !signal) {
[10:19:20.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.679]                     {
[10:19:20.679]                       inherits <- base::inherits
[10:19:20.679]                       invokeRestart <- base::invokeRestart
[10:19:20.679]                       is.null <- base::is.null
[10:19:20.679]                       muffled <- FALSE
[10:19:20.679]                       if (inherits(cond, "message")) {
[10:19:20.679]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.679]                         if (muffled) 
[10:19:20.679]                           invokeRestart("muffleMessage")
[10:19:20.679]                       }
[10:19:20.679]                       else if (inherits(cond, "warning")) {
[10:19:20.679]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.679]                         if (muffled) 
[10:19:20.679]                           invokeRestart("muffleWarning")
[10:19:20.679]                       }
[10:19:20.679]                       else if (inherits(cond, "condition")) {
[10:19:20.679]                         if (!is.null(pattern)) {
[10:19:20.679]                           computeRestarts <- base::computeRestarts
[10:19:20.679]                           grepl <- base::grepl
[10:19:20.679]                           restarts <- computeRestarts(cond)
[10:19:20.679]                           for (restart in restarts) {
[10:19:20.679]                             name <- restart$name
[10:19:20.679]                             if (is.null(name)) 
[10:19:20.679]                               next
[10:19:20.679]                             if (!grepl(pattern, name)) 
[10:19:20.679]                               next
[10:19:20.679]                             invokeRestart(restart)
[10:19:20.679]                             muffled <- TRUE
[10:19:20.679]                             break
[10:19:20.679]                           }
[10:19:20.679]                         }
[10:19:20.679]                       }
[10:19:20.679]                       invisible(muffled)
[10:19:20.679]                     }
[10:19:20.679]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.679]                   }
[10:19:20.679]                 }
[10:19:20.679]                 else {
[10:19:20.679]                   if (TRUE) {
[10:19:20.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.679]                     {
[10:19:20.679]                       inherits <- base::inherits
[10:19:20.679]                       invokeRestart <- base::invokeRestart
[10:19:20.679]                       is.null <- base::is.null
[10:19:20.679]                       muffled <- FALSE
[10:19:20.679]                       if (inherits(cond, "message")) {
[10:19:20.679]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.679]                         if (muffled) 
[10:19:20.679]                           invokeRestart("muffleMessage")
[10:19:20.679]                       }
[10:19:20.679]                       else if (inherits(cond, "warning")) {
[10:19:20.679]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.679]                         if (muffled) 
[10:19:20.679]                           invokeRestart("muffleWarning")
[10:19:20.679]                       }
[10:19:20.679]                       else if (inherits(cond, "condition")) {
[10:19:20.679]                         if (!is.null(pattern)) {
[10:19:20.679]                           computeRestarts <- base::computeRestarts
[10:19:20.679]                           grepl <- base::grepl
[10:19:20.679]                           restarts <- computeRestarts(cond)
[10:19:20.679]                           for (restart in restarts) {
[10:19:20.679]                             name <- restart$name
[10:19:20.679]                             if (is.null(name)) 
[10:19:20.679]                               next
[10:19:20.679]                             if (!grepl(pattern, name)) 
[10:19:20.679]                               next
[10:19:20.679]                             invokeRestart(restart)
[10:19:20.679]                             muffled <- TRUE
[10:19:20.679]                             break
[10:19:20.679]                           }
[10:19:20.679]                         }
[10:19:20.679]                       }
[10:19:20.679]                       invisible(muffled)
[10:19:20.679]                     }
[10:19:20.679]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.679]                   }
[10:19:20.679]                 }
[10:19:20.679]             }
[10:19:20.679]         }))
[10:19:20.679]     }, error = function(ex) {
[10:19:20.679]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.679]                 ...future.rng), started = ...future.startTime, 
[10:19:20.679]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.679]             version = "1.8"), class = "FutureResult")
[10:19:20.679]     }, finally = {
[10:19:20.679]         if (!identical(...future.workdir, getwd())) 
[10:19:20.679]             setwd(...future.workdir)
[10:19:20.679]         {
[10:19:20.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.679]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.679]             }
[10:19:20.679]             base::options(...future.oldOptions)
[10:19:20.679]             if (.Platform$OS.type == "windows") {
[10:19:20.679]                 old_names <- names(...future.oldEnvVars)
[10:19:20.679]                 envs <- base::Sys.getenv()
[10:19:20.679]                 names <- names(envs)
[10:19:20.679]                 common <- intersect(names, old_names)
[10:19:20.679]                 added <- setdiff(names, old_names)
[10:19:20.679]                 removed <- setdiff(old_names, names)
[10:19:20.679]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.679]                   envs[common]]
[10:19:20.679]                 NAMES <- toupper(changed)
[10:19:20.679]                 args <- list()
[10:19:20.679]                 for (kk in seq_along(NAMES)) {
[10:19:20.679]                   name <- changed[[kk]]
[10:19:20.679]                   NAME <- NAMES[[kk]]
[10:19:20.679]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.679]                     next
[10:19:20.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.679]                 }
[10:19:20.679]                 NAMES <- toupper(added)
[10:19:20.679]                 for (kk in seq_along(NAMES)) {
[10:19:20.679]                   name <- added[[kk]]
[10:19:20.679]                   NAME <- NAMES[[kk]]
[10:19:20.679]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.679]                     next
[10:19:20.679]                   args[[name]] <- ""
[10:19:20.679]                 }
[10:19:20.679]                 NAMES <- toupper(removed)
[10:19:20.679]                 for (kk in seq_along(NAMES)) {
[10:19:20.679]                   name <- removed[[kk]]
[10:19:20.679]                   NAME <- NAMES[[kk]]
[10:19:20.679]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.679]                     next
[10:19:20.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.679]                 }
[10:19:20.679]                 if (length(args) > 0) 
[10:19:20.679]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.679]             }
[10:19:20.679]             else {
[10:19:20.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.679]             }
[10:19:20.679]             {
[10:19:20.679]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.679]                   0L) {
[10:19:20.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.679]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.679]                   base::options(opts)
[10:19:20.679]                 }
[10:19:20.679]                 {
[10:19:20.679]                   {
[10:19:20.679]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.679]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.679]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.679]                       inherits = FALSE)
[10:19:20.679]                     NULL
[10:19:20.679]                   }
[10:19:20.679]                   options(future.plan = NULL)
[10:19:20.679]                   if (is.na(NA_character_)) 
[10:19:20.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.679]                     .init = FALSE)
[10:19:20.679]                 }
[10:19:20.679]             }
[10:19:20.679]         }
[10:19:20.679]     })
[10:19:20.679]     if (TRUE) {
[10:19:20.679]         base::sink(type = "output", split = FALSE)
[10:19:20.679]         if (TRUE) {
[10:19:20.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.679]         }
[10:19:20.679]         else {
[10:19:20.679]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.679]         }
[10:19:20.679]         base::close(...future.stdout)
[10:19:20.679]         ...future.stdout <- NULL
[10:19:20.679]     }
[10:19:20.679]     ...future.result$conditions <- ...future.conditions
[10:19:20.679]     ...future.result$finished <- base::Sys.time()
[10:19:20.679]     ...future.result
[10:19:20.679] }
[10:19:20.681] assign_globals() ...
[10:19:20.681] List of 5
[10:19:20.681]  $ ...future.FUN            :function (C, k)  
[10:19:20.681]  $ MoreArgs                 : list()
[10:19:20.681]  $ ...future.elements_ii    :List of 2
[10:19:20.681]   ..$ :List of 5
[10:19:20.681]   .. ..$ : chr "A"
[10:19:20.681]   .. ..$ : chr "B"
[10:19:20.681]   .. ..$ : chr "C"
[10:19:20.681]   .. ..$ : chr "D"
[10:19:20.681]   .. ..$ : chr "E"
[10:19:20.681]   ..$ :List of 5
[10:19:20.681]   .. ..$ : int 5
[10:19:20.681]   .. ..$ : int 4
[10:19:20.681]   .. ..$ : int 3
[10:19:20.681]   .. ..$ : int 2
[10:19:20.681]   .. ..$ : int 1
[10:19:20.681]  $ ...future.seeds_ii       : NULL
[10:19:20.681]  $ ...future.globals.maxSize: NULL
[10:19:20.681]  - attr(*, "where")=List of 5
[10:19:20.681]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.681]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.681]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.681]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.681]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.681]  - attr(*, "resolved")= logi FALSE
[10:19:20.681]  - attr(*, "total_size")= num 967
[10:19:20.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.681]  - attr(*, "already-done")= logi TRUE
[10:19:20.688] - reassign environment for ‘...future.FUN’
[10:19:20.688] - copied ‘...future.FUN’ to environment
[10:19:20.688] - copied ‘MoreArgs’ to environment
[10:19:20.688] - copied ‘...future.elements_ii’ to environment
[10:19:20.688] - copied ‘...future.seeds_ii’ to environment
[10:19:20.688] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.688] assign_globals() ... done
[10:19:20.688] plan(): Setting new future strategy stack:
[10:19:20.688] List of future strategies:
[10:19:20.688] 1. sequential:
[10:19:20.688]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.688]    - tweaked: FALSE
[10:19:20.688]    - call: NULL
[10:19:20.689] plan(): nbrOfWorkers() = 1
[10:19:20.691] plan(): Setting new future strategy stack:
[10:19:20.691] List of future strategies:
[10:19:20.691] 1. sequential:
[10:19:20.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.691]    - tweaked: FALSE
[10:19:20.691]    - call: plan(strategy)
[10:19:20.691] plan(): nbrOfWorkers() = 1
[10:19:20.692] SequentialFuture started (and completed)
[10:19:20.692] - Launch lazy future ... done
[10:19:20.692] run() for ‘SequentialFuture’ ... done
[10:19:20.692] Created future:
[10:19:20.692] SequentialFuture:
[10:19:20.692] Label: ‘future_.mapply-1’
[10:19:20.692] Expression:
[10:19:20.692] {
[10:19:20.692]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.692]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.692]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.692]         on.exit(options(oopts), add = TRUE)
[10:19:20.692]     }
[10:19:20.692]     {
[10:19:20.692]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.692]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.692]         do.call(mapply, args = args)
[10:19:20.692]     }
[10:19:20.692] }
[10:19:20.692] Lazy evaluation: FALSE
[10:19:20.692] Asynchronous evaluation: FALSE
[10:19:20.692] Local evaluation: TRUE
[10:19:20.692] Environment: R_GlobalEnv
[10:19:20.692] Capture standard output: TRUE
[10:19:20.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.692] Globals: 5 objects totaling 967 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.692] Packages: <none>
[10:19:20.692] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.692] Resolved: TRUE
[10:19:20.692] Value: 126 bytes of class ‘list’
[10:19:20.692] Early signaling: FALSE
[10:19:20.692] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.692] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.693] Chunk #1 of 1 ... DONE
[10:19:20.693] Launching 1 futures (chunks) ... DONE
[10:19:20.693] Resolving 1 futures (chunks) ...
[10:19:20.693] resolve() on list ...
[10:19:20.693]  recursive: 0
[10:19:20.693]  length: 1
[10:19:20.693] 
[10:19:20.693] resolved() for ‘SequentialFuture’ ...
[10:19:20.694] - state: ‘finished’
[10:19:20.694] - run: TRUE
[10:19:20.694] - result: ‘FutureResult’
[10:19:20.694] resolved() for ‘SequentialFuture’ ... done
[10:19:20.694] Future #1
[10:19:20.694] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.694] - nx: 1
[10:19:20.694] - relay: TRUE
[10:19:20.694] - stdout: TRUE
[10:19:20.694] - signal: TRUE
[10:19:20.694] - resignal: FALSE
[10:19:20.695] - force: TRUE
[10:19:20.695] - relayed: [n=1] FALSE
[10:19:20.695] - queued futures: [n=1] FALSE
[10:19:20.695]  - until=1
[10:19:20.695]  - relaying element #1
[10:19:20.695] - relayed: [n=1] TRUE
[10:19:20.695] - queued futures: [n=1] TRUE
[10:19:20.695] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.695]  length: 0 (resolved future 1)
[10:19:20.695] Relaying remaining futures
[10:19:20.695] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.696] - nx: 1
[10:19:20.696] - relay: TRUE
[10:19:20.696] - stdout: TRUE
[10:19:20.696] - signal: TRUE
[10:19:20.696] - resignal: FALSE
[10:19:20.696] - force: TRUE
[10:19:20.696] - relayed: [n=1] TRUE
[10:19:20.696] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.696] - relayed: [n=1] TRUE
[10:19:20.696] - queued futures: [n=1] TRUE
[10:19:20.696] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.696] resolve() on list ... DONE
[10:19:20.697]  - Number of value chunks collected: 1
[10:19:20.697] Resolving 1 futures (chunks) ... DONE
[10:19:20.697] Reducing values from 1 chunks ...
[10:19:20.697]  - Number of values collected after concatenation: 5
[10:19:20.697]  - Number of values expected: 5
[10:19:20.697] Reducing values from 1 chunks ... DONE
[10:19:20.697] future_mapply() ... DONE
[10:19:20.697] future_mapply() ...
[10:19:20.698] Number of chunks: 3
[10:19:20.698] Index remapping (attribute 'ordering'): [n = 5] 3, 4, 1, 2, 5
[10:19:20.698] getGlobalsAndPackagesXApply() ...
[10:19:20.698]  - future.globals: TRUE
[10:19:20.698] getGlobalsAndPackages() ...
[10:19:20.698] Searching for globals...
[10:19:20.699] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:20.700] Searching for globals ... DONE
[10:19:20.700] Resolving globals: FALSE
[10:19:20.700] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:20.700] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:20.700] - globals: [1] ‘FUN’
[10:19:20.700] 
[10:19:20.701] getGlobalsAndPackages() ... DONE
[10:19:20.701]  - globals found/used: [n=1] ‘FUN’
[10:19:20.701]  - needed namespaces: [n=0] 
[10:19:20.701] Finding globals ... DONE
[10:19:20.701] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.701] List of 2
[10:19:20.701]  $ ...future.FUN:function (C, k)  
[10:19:20.701]  $ MoreArgs     : NULL
[10:19:20.701]  - attr(*, "where")=List of 2
[10:19:20.701]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.701]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.701]  - attr(*, "resolved")= logi FALSE
[10:19:20.701]  - attr(*, "total_size")= num NA
[10:19:20.703] Packages to be attached in all futures: [n=0] 
[10:19:20.703] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.704] Number of futures (= number of chunks): 3
[10:19:20.704] Launching 3 futures (chunks) ...
[10:19:20.704] Chunk #1 of 3 ...
[10:19:20.704]  - Finding globals in '...' for chunk #1 ...
[10:19:20.704] getGlobalsAndPackages() ...
[10:19:20.704] Searching for globals...
[10:19:20.704] 
[10:19:20.704] Searching for globals ... DONE
[10:19:20.705] - globals: [0] <none>
[10:19:20.705] getGlobalsAndPackages() ... DONE
[10:19:20.705]    + additional globals found: [n=0] 
[10:19:20.705]    + additional namespaces needed: [n=0] 
[10:19:20.705]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.705]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:19:20.705]  - seeds: <none>
[10:19:20.705]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.705] getGlobalsAndPackages() ...
[10:19:20.705] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.705] Resolving globals: FALSE
[10:19:20.706] The total size of the 5 globals is 876 bytes (876 bytes)
[10:19:20.706] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.706] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.706] 
[10:19:20.706] getGlobalsAndPackages() ... DONE
[10:19:20.707] run() for ‘Future’ ...
[10:19:20.707] - state: ‘created’
[10:19:20.707] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.707] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.707] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.707]   - Field: ‘label’
[10:19:20.707]   - Field: ‘local’
[10:19:20.708]   - Field: ‘owner’
[10:19:20.708]   - Field: ‘envir’
[10:19:20.708]   - Field: ‘packages’
[10:19:20.708]   - Field: ‘gc’
[10:19:20.708]   - Field: ‘conditions’
[10:19:20.708]   - Field: ‘expr’
[10:19:20.708]   - Field: ‘uuid’
[10:19:20.708]   - Field: ‘seed’
[10:19:20.708]   - Field: ‘version’
[10:19:20.708]   - Field: ‘result’
[10:19:20.708]   - Field: ‘asynchronous’
[10:19:20.708]   - Field: ‘calls’
[10:19:20.709]   - Field: ‘globals’
[10:19:20.709]   - Field: ‘stdout’
[10:19:20.709]   - Field: ‘earlySignal’
[10:19:20.709]   - Field: ‘lazy’
[10:19:20.709]   - Field: ‘state’
[10:19:20.709] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.709] - Launch lazy future ...
[10:19:20.709] Packages needed by the future expression (n = 0): <none>
[10:19:20.709] Packages needed by future strategies (n = 0): <none>
[10:19:20.710] {
[10:19:20.710]     {
[10:19:20.710]         {
[10:19:20.710]             ...future.startTime <- base::Sys.time()
[10:19:20.710]             {
[10:19:20.710]                 {
[10:19:20.710]                   {
[10:19:20.710]                     base::local({
[10:19:20.710]                       has_future <- base::requireNamespace("future", 
[10:19:20.710]                         quietly = TRUE)
[10:19:20.710]                       if (has_future) {
[10:19:20.710]                         ns <- base::getNamespace("future")
[10:19:20.710]                         version <- ns[[".package"]][["version"]]
[10:19:20.710]                         if (is.null(version)) 
[10:19:20.710]                           version <- utils::packageVersion("future")
[10:19:20.710]                       }
[10:19:20.710]                       else {
[10:19:20.710]                         version <- NULL
[10:19:20.710]                       }
[10:19:20.710]                       if (!has_future || version < "1.8.0") {
[10:19:20.710]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.710]                           "", base::R.version$version.string), 
[10:19:20.710]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.710]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.710]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.710]                             "release", "version")], collapse = " "), 
[10:19:20.710]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.710]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.710]                           info)
[10:19:20.710]                         info <- base::paste(info, collapse = "; ")
[10:19:20.710]                         if (!has_future) {
[10:19:20.710]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.710]                             info)
[10:19:20.710]                         }
[10:19:20.710]                         else {
[10:19:20.710]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.710]                             info, version)
[10:19:20.710]                         }
[10:19:20.710]                         base::stop(msg)
[10:19:20.710]                       }
[10:19:20.710]                     })
[10:19:20.710]                   }
[10:19:20.710]                   ...future.strategy.old <- future::plan("list")
[10:19:20.710]                   options(future.plan = NULL)
[10:19:20.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.710]                 }
[10:19:20.710]                 ...future.workdir <- getwd()
[10:19:20.710]             }
[10:19:20.710]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.710]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.710]         }
[10:19:20.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.710]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:19:20.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.710]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.710]             base::names(...future.oldOptions))
[10:19:20.710]     }
[10:19:20.710]     if (FALSE) {
[10:19:20.710]     }
[10:19:20.710]     else {
[10:19:20.710]         if (TRUE) {
[10:19:20.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.710]                 open = "w")
[10:19:20.710]         }
[10:19:20.710]         else {
[10:19:20.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.710]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.710]         }
[10:19:20.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.710]             base::sink(type = "output", split = FALSE)
[10:19:20.710]             base::close(...future.stdout)
[10:19:20.710]         }, add = TRUE)
[10:19:20.710]     }
[10:19:20.710]     ...future.frame <- base::sys.nframe()
[10:19:20.710]     ...future.conditions <- base::list()
[10:19:20.710]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.710]     if (FALSE) {
[10:19:20.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.710]     }
[10:19:20.710]     ...future.result <- base::tryCatch({
[10:19:20.710]         base::withCallingHandlers({
[10:19:20.710]             ...future.value <- base::withVisible(base::local({
[10:19:20.710]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.710]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.710]                   ...future.globals.maxSize)) {
[10:19:20.710]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.710]                   on.exit(options(oopts), add = TRUE)
[10:19:20.710]                 }
[10:19:20.710]                 {
[10:19:20.710]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.710]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.710]                     USE.NAMES = FALSE)
[10:19:20.710]                   do.call(mapply, args = args)
[10:19:20.710]                 }
[10:19:20.710]             }))
[10:19:20.710]             future::FutureResult(value = ...future.value$value, 
[10:19:20.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.710]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.710]                     ...future.globalenv.names))
[10:19:20.710]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.710]         }, condition = base::local({
[10:19:20.710]             c <- base::c
[10:19:20.710]             inherits <- base::inherits
[10:19:20.710]             invokeRestart <- base::invokeRestart
[10:19:20.710]             length <- base::length
[10:19:20.710]             list <- base::list
[10:19:20.710]             seq.int <- base::seq.int
[10:19:20.710]             signalCondition <- base::signalCondition
[10:19:20.710]             sys.calls <- base::sys.calls
[10:19:20.710]             `[[` <- base::`[[`
[10:19:20.710]             `+` <- base::`+`
[10:19:20.710]             `<<-` <- base::`<<-`
[10:19:20.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.710]                   3L)]
[10:19:20.710]             }
[10:19:20.710]             function(cond) {
[10:19:20.710]                 is_error <- inherits(cond, "error")
[10:19:20.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.710]                   NULL)
[10:19:20.710]                 if (is_error) {
[10:19:20.710]                   sessionInformation <- function() {
[10:19:20.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.710]                       search = base::search(), system = base::Sys.info())
[10:19:20.710]                   }
[10:19:20.710]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.710]                     cond$call), session = sessionInformation(), 
[10:19:20.710]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.710]                   signalCondition(cond)
[10:19:20.710]                 }
[10:19:20.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.710]                 "immediateCondition"))) {
[10:19:20.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.710]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.710]                   if (TRUE && !signal) {
[10:19:20.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.710]                     {
[10:19:20.710]                       inherits <- base::inherits
[10:19:20.710]                       invokeRestart <- base::invokeRestart
[10:19:20.710]                       is.null <- base::is.null
[10:19:20.710]                       muffled <- FALSE
[10:19:20.710]                       if (inherits(cond, "message")) {
[10:19:20.710]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.710]                         if (muffled) 
[10:19:20.710]                           invokeRestart("muffleMessage")
[10:19:20.710]                       }
[10:19:20.710]                       else if (inherits(cond, "warning")) {
[10:19:20.710]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.710]                         if (muffled) 
[10:19:20.710]                           invokeRestart("muffleWarning")
[10:19:20.710]                       }
[10:19:20.710]                       else if (inherits(cond, "condition")) {
[10:19:20.710]                         if (!is.null(pattern)) {
[10:19:20.710]                           computeRestarts <- base::computeRestarts
[10:19:20.710]                           grepl <- base::grepl
[10:19:20.710]                           restarts <- computeRestarts(cond)
[10:19:20.710]                           for (restart in restarts) {
[10:19:20.710]                             name <- restart$name
[10:19:20.710]                             if (is.null(name)) 
[10:19:20.710]                               next
[10:19:20.710]                             if (!grepl(pattern, name)) 
[10:19:20.710]                               next
[10:19:20.710]                             invokeRestart(restart)
[10:19:20.710]                             muffled <- TRUE
[10:19:20.710]                             break
[10:19:20.710]                           }
[10:19:20.710]                         }
[10:19:20.710]                       }
[10:19:20.710]                       invisible(muffled)
[10:19:20.710]                     }
[10:19:20.710]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.710]                   }
[10:19:20.710]                 }
[10:19:20.710]                 else {
[10:19:20.710]                   if (TRUE) {
[10:19:20.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.710]                     {
[10:19:20.710]                       inherits <- base::inherits
[10:19:20.710]                       invokeRestart <- base::invokeRestart
[10:19:20.710]                       is.null <- base::is.null
[10:19:20.710]                       muffled <- FALSE
[10:19:20.710]                       if (inherits(cond, "message")) {
[10:19:20.710]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.710]                         if (muffled) 
[10:19:20.710]                           invokeRestart("muffleMessage")
[10:19:20.710]                       }
[10:19:20.710]                       else if (inherits(cond, "warning")) {
[10:19:20.710]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.710]                         if (muffled) 
[10:19:20.710]                           invokeRestart("muffleWarning")
[10:19:20.710]                       }
[10:19:20.710]                       else if (inherits(cond, "condition")) {
[10:19:20.710]                         if (!is.null(pattern)) {
[10:19:20.710]                           computeRestarts <- base::computeRestarts
[10:19:20.710]                           grepl <- base::grepl
[10:19:20.710]                           restarts <- computeRestarts(cond)
[10:19:20.710]                           for (restart in restarts) {
[10:19:20.710]                             name <- restart$name
[10:19:20.710]                             if (is.null(name)) 
[10:19:20.710]                               next
[10:19:20.710]                             if (!grepl(pattern, name)) 
[10:19:20.710]                               next
[10:19:20.710]                             invokeRestart(restart)
[10:19:20.710]                             muffled <- TRUE
[10:19:20.710]                             break
[10:19:20.710]                           }
[10:19:20.710]                         }
[10:19:20.710]                       }
[10:19:20.710]                       invisible(muffled)
[10:19:20.710]                     }
[10:19:20.710]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.710]                   }
[10:19:20.710]                 }
[10:19:20.710]             }
[10:19:20.710]         }))
[10:19:20.710]     }, error = function(ex) {
[10:19:20.710]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.710]                 ...future.rng), started = ...future.startTime, 
[10:19:20.710]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.710]             version = "1.8"), class = "FutureResult")
[10:19:20.710]     }, finally = {
[10:19:20.710]         if (!identical(...future.workdir, getwd())) 
[10:19:20.710]             setwd(...future.workdir)
[10:19:20.710]         {
[10:19:20.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.710]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.710]             }
[10:19:20.710]             base::options(...future.oldOptions)
[10:19:20.710]             if (.Platform$OS.type == "windows") {
[10:19:20.710]                 old_names <- names(...future.oldEnvVars)
[10:19:20.710]                 envs <- base::Sys.getenv()
[10:19:20.710]                 names <- names(envs)
[10:19:20.710]                 common <- intersect(names, old_names)
[10:19:20.710]                 added <- setdiff(names, old_names)
[10:19:20.710]                 removed <- setdiff(old_names, names)
[10:19:20.710]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.710]                   envs[common]]
[10:19:20.710]                 NAMES <- toupper(changed)
[10:19:20.710]                 args <- list()
[10:19:20.710]                 for (kk in seq_along(NAMES)) {
[10:19:20.710]                   name <- changed[[kk]]
[10:19:20.710]                   NAME <- NAMES[[kk]]
[10:19:20.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.710]                     next
[10:19:20.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.710]                 }
[10:19:20.710]                 NAMES <- toupper(added)
[10:19:20.710]                 for (kk in seq_along(NAMES)) {
[10:19:20.710]                   name <- added[[kk]]
[10:19:20.710]                   NAME <- NAMES[[kk]]
[10:19:20.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.710]                     next
[10:19:20.710]                   args[[name]] <- ""
[10:19:20.710]                 }
[10:19:20.710]                 NAMES <- toupper(removed)
[10:19:20.710]                 for (kk in seq_along(NAMES)) {
[10:19:20.710]                   name <- removed[[kk]]
[10:19:20.710]                   NAME <- NAMES[[kk]]
[10:19:20.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.710]                     next
[10:19:20.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.710]                 }
[10:19:20.710]                 if (length(args) > 0) 
[10:19:20.710]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.710]             }
[10:19:20.710]             else {
[10:19:20.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.710]             }
[10:19:20.710]             {
[10:19:20.710]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.710]                   0L) {
[10:19:20.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.710]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.710]                   base::options(opts)
[10:19:20.710]                 }
[10:19:20.710]                 {
[10:19:20.710]                   {
[10:19:20.710]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.710]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.710]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.710]                       inherits = FALSE)
[10:19:20.710]                     NULL
[10:19:20.710]                   }
[10:19:20.710]                   options(future.plan = NULL)
[10:19:20.710]                   if (is.na(NA_character_)) 
[10:19:20.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.710]                     .init = FALSE)
[10:19:20.710]                 }
[10:19:20.710]             }
[10:19:20.710]         }
[10:19:20.710]     })
[10:19:20.710]     if (TRUE) {
[10:19:20.710]         base::sink(type = "output", split = FALSE)
[10:19:20.710]         if (TRUE) {
[10:19:20.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.710]         }
[10:19:20.710]         else {
[10:19:20.710]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.710]         }
[10:19:20.710]         base::close(...future.stdout)
[10:19:20.710]         ...future.stdout <- NULL
[10:19:20.710]     }
[10:19:20.710]     ...future.result$conditions <- ...future.conditions
[10:19:20.710]     ...future.result$finished <- base::Sys.time()
[10:19:20.710]     ...future.result
[10:19:20.710] }
[10:19:20.711] assign_globals() ...
[10:19:20.711] List of 5
[10:19:20.711]  $ ...future.FUN            :function (C, k)  
[10:19:20.711]  $ MoreArgs                 : NULL
[10:19:20.711]  $ ...future.elements_ii    :List of 2
[10:19:20.711]   ..$ :List of 2
[10:19:20.711]   .. ..$ : chr "C"
[10:19:20.711]   .. ..$ : chr "D"
[10:19:20.711]   ..$ :List of 2
[10:19:20.711]   .. ..$ : int 3
[10:19:20.711]   .. ..$ : int 2
[10:19:20.711]  $ ...future.seeds_ii       : NULL
[10:19:20.711]  $ ...future.globals.maxSize: NULL
[10:19:20.711]  - attr(*, "where")=List of 5
[10:19:20.711]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.711]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.711]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.711]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.711]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.711]  - attr(*, "resolved")= logi FALSE
[10:19:20.711]  - attr(*, "total_size")= num 876
[10:19:20.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.711]  - attr(*, "already-done")= logi TRUE
[10:19:20.718] - reassign environment for ‘...future.FUN’
[10:19:20.718] - copied ‘...future.FUN’ to environment
[10:19:20.718] - copied ‘MoreArgs’ to environment
[10:19:20.718] - copied ‘...future.elements_ii’ to environment
[10:19:20.718] - copied ‘...future.seeds_ii’ to environment
[10:19:20.718] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.718] assign_globals() ... done
[10:19:20.719] plan(): Setting new future strategy stack:
[10:19:20.719] List of future strategies:
[10:19:20.719] 1. sequential:
[10:19:20.719]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.719]    - tweaked: FALSE
[10:19:20.719]    - call: NULL
[10:19:20.719] plan(): nbrOfWorkers() = 1
[10:19:20.720] plan(): Setting new future strategy stack:
[10:19:20.720] List of future strategies:
[10:19:20.720] 1. sequential:
[10:19:20.720]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.720]    - tweaked: FALSE
[10:19:20.720]    - call: plan(strategy)
[10:19:20.720] plan(): nbrOfWorkers() = 1
[10:19:20.721] SequentialFuture started (and completed)
[10:19:20.721] - Launch lazy future ... done
[10:19:20.721] run() for ‘SequentialFuture’ ... done
[10:19:20.721] Created future:
[10:19:20.721] SequentialFuture:
[10:19:20.721] Label: ‘future_mapply-1’
[10:19:20.721] Expression:
[10:19:20.721] {
[10:19:20.721]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.721]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.721]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.721]         on.exit(options(oopts), add = TRUE)
[10:19:20.721]     }
[10:19:20.721]     {
[10:19:20.721]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.721]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.721]         do.call(mapply, args = args)
[10:19:20.721]     }
[10:19:20.721] }
[10:19:20.721] Lazy evaluation: FALSE
[10:19:20.721] Asynchronous evaluation: FALSE
[10:19:20.721] Local evaluation: TRUE
[10:19:20.721] Environment: R_GlobalEnv
[10:19:20.721] Capture standard output: TRUE
[10:19:20.721] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.721] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.721] Packages: <none>
[10:19:20.721] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.721] Resolved: TRUE
[10:19:20.721] Value: 68 bytes of class ‘list’
[10:19:20.721] Early signaling: FALSE
[10:19:20.721] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.721] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.722] Chunk #1 of 3 ... DONE
[10:19:20.722] Chunk #2 of 3 ...
[10:19:20.722]  - Finding globals in '...' for chunk #2 ...
[10:19:20.722] getGlobalsAndPackages() ...
[10:19:20.722] Searching for globals...
[10:19:20.722] 
[10:19:20.722] Searching for globals ... DONE
[10:19:20.723] - globals: [0] <none>
[10:19:20.723] getGlobalsAndPackages() ... DONE
[10:19:20.723]    + additional globals found: [n=0] 
[10:19:20.723]    + additional namespaces needed: [n=0] 
[10:19:20.723]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:20.723]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:19:20.723]  - seeds: <none>
[10:19:20.723]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.723] getGlobalsAndPackages() ...
[10:19:20.723] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.723] Resolving globals: FALSE
[10:19:20.724] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:20.724] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.724] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.724] 
[10:19:20.724] getGlobalsAndPackages() ... DONE
[10:19:20.725] run() for ‘Future’ ...
[10:19:20.725] - state: ‘created’
[10:19:20.725] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.725] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.725] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.725]   - Field: ‘label’
[10:19:20.725]   - Field: ‘local’
[10:19:20.726]   - Field: ‘owner’
[10:19:20.726]   - Field: ‘envir’
[10:19:20.726]   - Field: ‘packages’
[10:19:20.726]   - Field: ‘gc’
[10:19:20.726]   - Field: ‘conditions’
[10:19:20.726]   - Field: ‘expr’
[10:19:20.726]   - Field: ‘uuid’
[10:19:20.726]   - Field: ‘seed’
[10:19:20.726]   - Field: ‘version’
[10:19:20.726]   - Field: ‘result’
[10:19:20.726]   - Field: ‘asynchronous’
[10:19:20.726]   - Field: ‘calls’
[10:19:20.727]   - Field: ‘globals’
[10:19:20.727]   - Field: ‘stdout’
[10:19:20.727]   - Field: ‘earlySignal’
[10:19:20.727]   - Field: ‘lazy’
[10:19:20.727]   - Field: ‘state’
[10:19:20.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.727] - Launch lazy future ...
[10:19:20.727] Packages needed by the future expression (n = 0): <none>
[10:19:20.727] Packages needed by future strategies (n = 0): <none>
[10:19:20.728] {
[10:19:20.728]     {
[10:19:20.728]         {
[10:19:20.728]             ...future.startTime <- base::Sys.time()
[10:19:20.728]             {
[10:19:20.728]                 {
[10:19:20.728]                   {
[10:19:20.728]                     base::local({
[10:19:20.728]                       has_future <- base::requireNamespace("future", 
[10:19:20.728]                         quietly = TRUE)
[10:19:20.728]                       if (has_future) {
[10:19:20.728]                         ns <- base::getNamespace("future")
[10:19:20.728]                         version <- ns[[".package"]][["version"]]
[10:19:20.728]                         if (is.null(version)) 
[10:19:20.728]                           version <- utils::packageVersion("future")
[10:19:20.728]                       }
[10:19:20.728]                       else {
[10:19:20.728]                         version <- NULL
[10:19:20.728]                       }
[10:19:20.728]                       if (!has_future || version < "1.8.0") {
[10:19:20.728]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.728]                           "", base::R.version$version.string), 
[10:19:20.728]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.728]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.728]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.728]                             "release", "version")], collapse = " "), 
[10:19:20.728]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.728]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.728]                           info)
[10:19:20.728]                         info <- base::paste(info, collapse = "; ")
[10:19:20.728]                         if (!has_future) {
[10:19:20.728]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.728]                             info)
[10:19:20.728]                         }
[10:19:20.728]                         else {
[10:19:20.728]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.728]                             info, version)
[10:19:20.728]                         }
[10:19:20.728]                         base::stop(msg)
[10:19:20.728]                       }
[10:19:20.728]                     })
[10:19:20.728]                   }
[10:19:20.728]                   ...future.strategy.old <- future::plan("list")
[10:19:20.728]                   options(future.plan = NULL)
[10:19:20.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.728]                 }
[10:19:20.728]                 ...future.workdir <- getwd()
[10:19:20.728]             }
[10:19:20.728]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.728]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.728]         }
[10:19:20.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.728]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:19:20.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.728]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.728]             base::names(...future.oldOptions))
[10:19:20.728]     }
[10:19:20.728]     if (FALSE) {
[10:19:20.728]     }
[10:19:20.728]     else {
[10:19:20.728]         if (TRUE) {
[10:19:20.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.728]                 open = "w")
[10:19:20.728]         }
[10:19:20.728]         else {
[10:19:20.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.728]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.728]         }
[10:19:20.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.728]             base::sink(type = "output", split = FALSE)
[10:19:20.728]             base::close(...future.stdout)
[10:19:20.728]         }, add = TRUE)
[10:19:20.728]     }
[10:19:20.728]     ...future.frame <- base::sys.nframe()
[10:19:20.728]     ...future.conditions <- base::list()
[10:19:20.728]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.728]     if (FALSE) {
[10:19:20.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.728]     }
[10:19:20.728]     ...future.result <- base::tryCatch({
[10:19:20.728]         base::withCallingHandlers({
[10:19:20.728]             ...future.value <- base::withVisible(base::local({
[10:19:20.728]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.728]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.728]                   ...future.globals.maxSize)) {
[10:19:20.728]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.728]                   on.exit(options(oopts), add = TRUE)
[10:19:20.728]                 }
[10:19:20.728]                 {
[10:19:20.728]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.728]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.728]                     USE.NAMES = FALSE)
[10:19:20.728]                   do.call(mapply, args = args)
[10:19:20.728]                 }
[10:19:20.728]             }))
[10:19:20.728]             future::FutureResult(value = ...future.value$value, 
[10:19:20.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.728]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.728]                     ...future.globalenv.names))
[10:19:20.728]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.728]         }, condition = base::local({
[10:19:20.728]             c <- base::c
[10:19:20.728]             inherits <- base::inherits
[10:19:20.728]             invokeRestart <- base::invokeRestart
[10:19:20.728]             length <- base::length
[10:19:20.728]             list <- base::list
[10:19:20.728]             seq.int <- base::seq.int
[10:19:20.728]             signalCondition <- base::signalCondition
[10:19:20.728]             sys.calls <- base::sys.calls
[10:19:20.728]             `[[` <- base::`[[`
[10:19:20.728]             `+` <- base::`+`
[10:19:20.728]             `<<-` <- base::`<<-`
[10:19:20.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.728]                   3L)]
[10:19:20.728]             }
[10:19:20.728]             function(cond) {
[10:19:20.728]                 is_error <- inherits(cond, "error")
[10:19:20.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.728]                   NULL)
[10:19:20.728]                 if (is_error) {
[10:19:20.728]                   sessionInformation <- function() {
[10:19:20.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.728]                       search = base::search(), system = base::Sys.info())
[10:19:20.728]                   }
[10:19:20.728]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.728]                     cond$call), session = sessionInformation(), 
[10:19:20.728]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.728]                   signalCondition(cond)
[10:19:20.728]                 }
[10:19:20.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.728]                 "immediateCondition"))) {
[10:19:20.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.728]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.728]                   if (TRUE && !signal) {
[10:19:20.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.728]                     {
[10:19:20.728]                       inherits <- base::inherits
[10:19:20.728]                       invokeRestart <- base::invokeRestart
[10:19:20.728]                       is.null <- base::is.null
[10:19:20.728]                       muffled <- FALSE
[10:19:20.728]                       if (inherits(cond, "message")) {
[10:19:20.728]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.728]                         if (muffled) 
[10:19:20.728]                           invokeRestart("muffleMessage")
[10:19:20.728]                       }
[10:19:20.728]                       else if (inherits(cond, "warning")) {
[10:19:20.728]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.728]                         if (muffled) 
[10:19:20.728]                           invokeRestart("muffleWarning")
[10:19:20.728]                       }
[10:19:20.728]                       else if (inherits(cond, "condition")) {
[10:19:20.728]                         if (!is.null(pattern)) {
[10:19:20.728]                           computeRestarts <- base::computeRestarts
[10:19:20.728]                           grepl <- base::grepl
[10:19:20.728]                           restarts <- computeRestarts(cond)
[10:19:20.728]                           for (restart in restarts) {
[10:19:20.728]                             name <- restart$name
[10:19:20.728]                             if (is.null(name)) 
[10:19:20.728]                               next
[10:19:20.728]                             if (!grepl(pattern, name)) 
[10:19:20.728]                               next
[10:19:20.728]                             invokeRestart(restart)
[10:19:20.728]                             muffled <- TRUE
[10:19:20.728]                             break
[10:19:20.728]                           }
[10:19:20.728]                         }
[10:19:20.728]                       }
[10:19:20.728]                       invisible(muffled)
[10:19:20.728]                     }
[10:19:20.728]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.728]                   }
[10:19:20.728]                 }
[10:19:20.728]                 else {
[10:19:20.728]                   if (TRUE) {
[10:19:20.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.728]                     {
[10:19:20.728]                       inherits <- base::inherits
[10:19:20.728]                       invokeRestart <- base::invokeRestart
[10:19:20.728]                       is.null <- base::is.null
[10:19:20.728]                       muffled <- FALSE
[10:19:20.728]                       if (inherits(cond, "message")) {
[10:19:20.728]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.728]                         if (muffled) 
[10:19:20.728]                           invokeRestart("muffleMessage")
[10:19:20.728]                       }
[10:19:20.728]                       else if (inherits(cond, "warning")) {
[10:19:20.728]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.728]                         if (muffled) 
[10:19:20.728]                           invokeRestart("muffleWarning")
[10:19:20.728]                       }
[10:19:20.728]                       else if (inherits(cond, "condition")) {
[10:19:20.728]                         if (!is.null(pattern)) {
[10:19:20.728]                           computeRestarts <- base::computeRestarts
[10:19:20.728]                           grepl <- base::grepl
[10:19:20.728]                           restarts <- computeRestarts(cond)
[10:19:20.728]                           for (restart in restarts) {
[10:19:20.728]                             name <- restart$name
[10:19:20.728]                             if (is.null(name)) 
[10:19:20.728]                               next
[10:19:20.728]                             if (!grepl(pattern, name)) 
[10:19:20.728]                               next
[10:19:20.728]                             invokeRestart(restart)
[10:19:20.728]                             muffled <- TRUE
[10:19:20.728]                             break
[10:19:20.728]                           }
[10:19:20.728]                         }
[10:19:20.728]                       }
[10:19:20.728]                       invisible(muffled)
[10:19:20.728]                     }
[10:19:20.728]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.728]                   }
[10:19:20.728]                 }
[10:19:20.728]             }
[10:19:20.728]         }))
[10:19:20.728]     }, error = function(ex) {
[10:19:20.728]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.728]                 ...future.rng), started = ...future.startTime, 
[10:19:20.728]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.728]             version = "1.8"), class = "FutureResult")
[10:19:20.728]     }, finally = {
[10:19:20.728]         if (!identical(...future.workdir, getwd())) 
[10:19:20.728]             setwd(...future.workdir)
[10:19:20.728]         {
[10:19:20.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.728]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.728]             }
[10:19:20.728]             base::options(...future.oldOptions)
[10:19:20.728]             if (.Platform$OS.type == "windows") {
[10:19:20.728]                 old_names <- names(...future.oldEnvVars)
[10:19:20.728]                 envs <- base::Sys.getenv()
[10:19:20.728]                 names <- names(envs)
[10:19:20.728]                 common <- intersect(names, old_names)
[10:19:20.728]                 added <- setdiff(names, old_names)
[10:19:20.728]                 removed <- setdiff(old_names, names)
[10:19:20.728]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.728]                   envs[common]]
[10:19:20.728]                 NAMES <- toupper(changed)
[10:19:20.728]                 args <- list()
[10:19:20.728]                 for (kk in seq_along(NAMES)) {
[10:19:20.728]                   name <- changed[[kk]]
[10:19:20.728]                   NAME <- NAMES[[kk]]
[10:19:20.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.728]                     next
[10:19:20.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.728]                 }
[10:19:20.728]                 NAMES <- toupper(added)
[10:19:20.728]                 for (kk in seq_along(NAMES)) {
[10:19:20.728]                   name <- added[[kk]]
[10:19:20.728]                   NAME <- NAMES[[kk]]
[10:19:20.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.728]                     next
[10:19:20.728]                   args[[name]] <- ""
[10:19:20.728]                 }
[10:19:20.728]                 NAMES <- toupper(removed)
[10:19:20.728]                 for (kk in seq_along(NAMES)) {
[10:19:20.728]                   name <- removed[[kk]]
[10:19:20.728]                   NAME <- NAMES[[kk]]
[10:19:20.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.728]                     next
[10:19:20.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.728]                 }
[10:19:20.728]                 if (length(args) > 0) 
[10:19:20.728]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.728]             }
[10:19:20.728]             else {
[10:19:20.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.728]             }
[10:19:20.728]             {
[10:19:20.728]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.728]                   0L) {
[10:19:20.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.728]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.728]                   base::options(opts)
[10:19:20.728]                 }
[10:19:20.728]                 {
[10:19:20.728]                   {
[10:19:20.728]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.728]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.728]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.728]                       inherits = FALSE)
[10:19:20.728]                     NULL
[10:19:20.728]                   }
[10:19:20.728]                   options(future.plan = NULL)
[10:19:20.728]                   if (is.na(NA_character_)) 
[10:19:20.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.728]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.728]                     .init = FALSE)
[10:19:20.728]                 }
[10:19:20.728]             }
[10:19:20.728]         }
[10:19:20.728]     })
[10:19:20.728]     if (TRUE) {
[10:19:20.728]         base::sink(type = "output", split = FALSE)
[10:19:20.728]         if (TRUE) {
[10:19:20.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.728]         }
[10:19:20.728]         else {
[10:19:20.728]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.728]         }
[10:19:20.728]         base::close(...future.stdout)
[10:19:20.728]         ...future.stdout <- NULL
[10:19:20.728]     }
[10:19:20.728]     ...future.result$conditions <- ...future.conditions
[10:19:20.728]     ...future.result$finished <- base::Sys.time()
[10:19:20.728]     ...future.result
[10:19:20.728] }
[10:19:20.729] assign_globals() ...
[10:19:20.729] List of 5
[10:19:20.729]  $ ...future.FUN            :function (C, k)  
[10:19:20.729]  $ MoreArgs                 : NULL
[10:19:20.729]  $ ...future.elements_ii    :List of 2
[10:19:20.729]   ..$ :List of 1
[10:19:20.729]   .. ..$ : chr "A"
[10:19:20.729]   ..$ :List of 1
[10:19:20.729]   .. ..$ : int 5
[10:19:20.729]  $ ...future.seeds_ii       : NULL
[10:19:20.729]  $ ...future.globals.maxSize: NULL
[10:19:20.729]  - attr(*, "where")=List of 5
[10:19:20.729]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.729]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.729]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.729]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.729]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.729]  - attr(*, "resolved")= logi FALSE
[10:19:20.729]  - attr(*, "total_size")= num 847
[10:19:20.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.729]  - attr(*, "already-done")= logi TRUE
[10:19:20.734] - reassign environment for ‘...future.FUN’
[10:19:20.734] - copied ‘...future.FUN’ to environment
[10:19:20.734] - copied ‘MoreArgs’ to environment
[10:19:20.734] - copied ‘...future.elements_ii’ to environment
[10:19:20.734] - copied ‘...future.seeds_ii’ to environment
[10:19:20.735] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.735] assign_globals() ... done
[10:19:20.735] plan(): Setting new future strategy stack:
[10:19:20.735] List of future strategies:
[10:19:20.735] 1. sequential:
[10:19:20.735]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.735]    - tweaked: FALSE
[10:19:20.735]    - call: NULL
[10:19:20.735] plan(): nbrOfWorkers() = 1
[10:19:20.736] plan(): Setting new future strategy stack:
[10:19:20.736] List of future strategies:
[10:19:20.736] 1. sequential:
[10:19:20.736]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.736]    - tweaked: FALSE
[10:19:20.736]    - call: plan(strategy)
[10:19:20.737] plan(): nbrOfWorkers() = 1
[10:19:20.737] SequentialFuture started (and completed)
[10:19:20.737] - Launch lazy future ... done
[10:19:20.737] run() for ‘SequentialFuture’ ... done
[10:19:20.737] Created future:
[10:19:20.737] SequentialFuture:
[10:19:20.737] Label: ‘future_mapply-2’
[10:19:20.737] Expression:
[10:19:20.737] {
[10:19:20.737]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.737]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.737]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.737]         on.exit(options(oopts), add = TRUE)
[10:19:20.737]     }
[10:19:20.737]     {
[10:19:20.737]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.737]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.737]         do.call(mapply, args = args)
[10:19:20.737]     }
[10:19:20.737] }
[10:19:20.737] Lazy evaluation: FALSE
[10:19:20.737] Asynchronous evaluation: FALSE
[10:19:20.737] Local evaluation: TRUE
[10:19:20.737] Environment: R_GlobalEnv
[10:19:20.737] Capture standard output: TRUE
[10:19:20.737] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.737] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.737] Packages: <none>
[10:19:20.737] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.737] Resolved: TRUE
[10:19:20.737] Value: 52 bytes of class ‘list’
[10:19:20.737] Early signaling: FALSE
[10:19:20.737] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.737] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.739] Chunk #2 of 3 ... DONE
[10:19:20.739] Chunk #3 of 3 ...
[10:19:20.739]  - Finding globals in '...' for chunk #3 ...
[10:19:20.739] getGlobalsAndPackages() ...
[10:19:20.739] Searching for globals...
[10:19:20.740] 
[10:19:20.740] Searching for globals ... DONE
[10:19:20.740] - globals: [0] <none>
[10:19:20.740] getGlobalsAndPackages() ... DONE
[10:19:20.740]    + additional globals found: [n=0] 
[10:19:20.740]    + additional namespaces needed: [n=0] 
[10:19:20.740]  - Finding globals in '...' for chunk #3 ... DONE
[10:19:20.740]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:19:20.740]  - seeds: <none>
[10:19:20.740]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.741] getGlobalsAndPackages() ...
[10:19:20.741] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.741] Resolving globals: FALSE
[10:19:20.741] The total size of the 5 globals is 876 bytes (876 bytes)
[10:19:20.742] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.742] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.742] 
[10:19:20.742] getGlobalsAndPackages() ... DONE
[10:19:20.742] run() for ‘Future’ ...
[10:19:20.742] - state: ‘created’
[10:19:20.742] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.743] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.743]   - Field: ‘label’
[10:19:20.743]   - Field: ‘local’
[10:19:20.743]   - Field: ‘owner’
[10:19:20.743]   - Field: ‘envir’
[10:19:20.743]   - Field: ‘packages’
[10:19:20.743]   - Field: ‘gc’
[10:19:20.743]   - Field: ‘conditions’
[10:19:20.743]   - Field: ‘expr’
[10:19:20.743]   - Field: ‘uuid’
[10:19:20.743]   - Field: ‘seed’
[10:19:20.744]   - Field: ‘version’
[10:19:20.744]   - Field: ‘result’
[10:19:20.744]   - Field: ‘asynchronous’
[10:19:20.744]   - Field: ‘calls’
[10:19:20.744]   - Field: ‘globals’
[10:19:20.744]   - Field: ‘stdout’
[10:19:20.744]   - Field: ‘earlySignal’
[10:19:20.744]   - Field: ‘lazy’
[10:19:20.744]   - Field: ‘state’
[10:19:20.744] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.744] - Launch lazy future ...
[10:19:20.745] Packages needed by the future expression (n = 0): <none>
[10:19:20.745] Packages needed by future strategies (n = 0): <none>
[10:19:20.745] {
[10:19:20.745]     {
[10:19:20.745]         {
[10:19:20.745]             ...future.startTime <- base::Sys.time()
[10:19:20.745]             {
[10:19:20.745]                 {
[10:19:20.745]                   {
[10:19:20.745]                     base::local({
[10:19:20.745]                       has_future <- base::requireNamespace("future", 
[10:19:20.745]                         quietly = TRUE)
[10:19:20.745]                       if (has_future) {
[10:19:20.745]                         ns <- base::getNamespace("future")
[10:19:20.745]                         version <- ns[[".package"]][["version"]]
[10:19:20.745]                         if (is.null(version)) 
[10:19:20.745]                           version <- utils::packageVersion("future")
[10:19:20.745]                       }
[10:19:20.745]                       else {
[10:19:20.745]                         version <- NULL
[10:19:20.745]                       }
[10:19:20.745]                       if (!has_future || version < "1.8.0") {
[10:19:20.745]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.745]                           "", base::R.version$version.string), 
[10:19:20.745]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.745]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.745]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.745]                             "release", "version")], collapse = " "), 
[10:19:20.745]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.745]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.745]                           info)
[10:19:20.745]                         info <- base::paste(info, collapse = "; ")
[10:19:20.745]                         if (!has_future) {
[10:19:20.745]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.745]                             info)
[10:19:20.745]                         }
[10:19:20.745]                         else {
[10:19:20.745]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.745]                             info, version)
[10:19:20.745]                         }
[10:19:20.745]                         base::stop(msg)
[10:19:20.745]                       }
[10:19:20.745]                     })
[10:19:20.745]                   }
[10:19:20.745]                   ...future.strategy.old <- future::plan("list")
[10:19:20.745]                   options(future.plan = NULL)
[10:19:20.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.745]                 }
[10:19:20.745]                 ...future.workdir <- getwd()
[10:19:20.745]             }
[10:19:20.745]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.745]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.745]         }
[10:19:20.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.745]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:19:20.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.745]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.745]             base::names(...future.oldOptions))
[10:19:20.745]     }
[10:19:20.745]     if (FALSE) {
[10:19:20.745]     }
[10:19:20.745]     else {
[10:19:20.745]         if (TRUE) {
[10:19:20.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.745]                 open = "w")
[10:19:20.745]         }
[10:19:20.745]         else {
[10:19:20.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.745]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.745]         }
[10:19:20.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.745]             base::sink(type = "output", split = FALSE)
[10:19:20.745]             base::close(...future.stdout)
[10:19:20.745]         }, add = TRUE)
[10:19:20.745]     }
[10:19:20.745]     ...future.frame <- base::sys.nframe()
[10:19:20.745]     ...future.conditions <- base::list()
[10:19:20.745]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.745]     if (FALSE) {
[10:19:20.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.745]     }
[10:19:20.745]     ...future.result <- base::tryCatch({
[10:19:20.745]         base::withCallingHandlers({
[10:19:20.745]             ...future.value <- base::withVisible(base::local({
[10:19:20.745]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.745]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.745]                   ...future.globals.maxSize)) {
[10:19:20.745]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.745]                   on.exit(options(oopts), add = TRUE)
[10:19:20.745]                 }
[10:19:20.745]                 {
[10:19:20.745]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.745]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.745]                     USE.NAMES = FALSE)
[10:19:20.745]                   do.call(mapply, args = args)
[10:19:20.745]                 }
[10:19:20.745]             }))
[10:19:20.745]             future::FutureResult(value = ...future.value$value, 
[10:19:20.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.745]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.745]                     ...future.globalenv.names))
[10:19:20.745]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.745]         }, condition = base::local({
[10:19:20.745]             c <- base::c
[10:19:20.745]             inherits <- base::inherits
[10:19:20.745]             invokeRestart <- base::invokeRestart
[10:19:20.745]             length <- base::length
[10:19:20.745]             list <- base::list
[10:19:20.745]             seq.int <- base::seq.int
[10:19:20.745]             signalCondition <- base::signalCondition
[10:19:20.745]             sys.calls <- base::sys.calls
[10:19:20.745]             `[[` <- base::`[[`
[10:19:20.745]             `+` <- base::`+`
[10:19:20.745]             `<<-` <- base::`<<-`
[10:19:20.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.745]                   3L)]
[10:19:20.745]             }
[10:19:20.745]             function(cond) {
[10:19:20.745]                 is_error <- inherits(cond, "error")
[10:19:20.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.745]                   NULL)
[10:19:20.745]                 if (is_error) {
[10:19:20.745]                   sessionInformation <- function() {
[10:19:20.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.745]                       search = base::search(), system = base::Sys.info())
[10:19:20.745]                   }
[10:19:20.745]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.745]                     cond$call), session = sessionInformation(), 
[10:19:20.745]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.745]                   signalCondition(cond)
[10:19:20.745]                 }
[10:19:20.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.745]                 "immediateCondition"))) {
[10:19:20.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.745]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.745]                   if (TRUE && !signal) {
[10:19:20.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.745]                     {
[10:19:20.745]                       inherits <- base::inherits
[10:19:20.745]                       invokeRestart <- base::invokeRestart
[10:19:20.745]                       is.null <- base::is.null
[10:19:20.745]                       muffled <- FALSE
[10:19:20.745]                       if (inherits(cond, "message")) {
[10:19:20.745]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.745]                         if (muffled) 
[10:19:20.745]                           invokeRestart("muffleMessage")
[10:19:20.745]                       }
[10:19:20.745]                       else if (inherits(cond, "warning")) {
[10:19:20.745]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.745]                         if (muffled) 
[10:19:20.745]                           invokeRestart("muffleWarning")
[10:19:20.745]                       }
[10:19:20.745]                       else if (inherits(cond, "condition")) {
[10:19:20.745]                         if (!is.null(pattern)) {
[10:19:20.745]                           computeRestarts <- base::computeRestarts
[10:19:20.745]                           grepl <- base::grepl
[10:19:20.745]                           restarts <- computeRestarts(cond)
[10:19:20.745]                           for (restart in restarts) {
[10:19:20.745]                             name <- restart$name
[10:19:20.745]                             if (is.null(name)) 
[10:19:20.745]                               next
[10:19:20.745]                             if (!grepl(pattern, name)) 
[10:19:20.745]                               next
[10:19:20.745]                             invokeRestart(restart)
[10:19:20.745]                             muffled <- TRUE
[10:19:20.745]                             break
[10:19:20.745]                           }
[10:19:20.745]                         }
[10:19:20.745]                       }
[10:19:20.745]                       invisible(muffled)
[10:19:20.745]                     }
[10:19:20.745]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.745]                   }
[10:19:20.745]                 }
[10:19:20.745]                 else {
[10:19:20.745]                   if (TRUE) {
[10:19:20.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.745]                     {
[10:19:20.745]                       inherits <- base::inherits
[10:19:20.745]                       invokeRestart <- base::invokeRestart
[10:19:20.745]                       is.null <- base::is.null
[10:19:20.745]                       muffled <- FALSE
[10:19:20.745]                       if (inherits(cond, "message")) {
[10:19:20.745]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.745]                         if (muffled) 
[10:19:20.745]                           invokeRestart("muffleMessage")
[10:19:20.745]                       }
[10:19:20.745]                       else if (inherits(cond, "warning")) {
[10:19:20.745]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.745]                         if (muffled) 
[10:19:20.745]                           invokeRestart("muffleWarning")
[10:19:20.745]                       }
[10:19:20.745]                       else if (inherits(cond, "condition")) {
[10:19:20.745]                         if (!is.null(pattern)) {
[10:19:20.745]                           computeRestarts <- base::computeRestarts
[10:19:20.745]                           grepl <- base::grepl
[10:19:20.745]                           restarts <- computeRestarts(cond)
[10:19:20.745]                           for (restart in restarts) {
[10:19:20.745]                             name <- restart$name
[10:19:20.745]                             if (is.null(name)) 
[10:19:20.745]                               next
[10:19:20.745]                             if (!grepl(pattern, name)) 
[10:19:20.745]                               next
[10:19:20.745]                             invokeRestart(restart)
[10:19:20.745]                             muffled <- TRUE
[10:19:20.745]                             break
[10:19:20.745]                           }
[10:19:20.745]                         }
[10:19:20.745]                       }
[10:19:20.745]                       invisible(muffled)
[10:19:20.745]                     }
[10:19:20.745]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.745]                   }
[10:19:20.745]                 }
[10:19:20.745]             }
[10:19:20.745]         }))
[10:19:20.745]     }, error = function(ex) {
[10:19:20.745]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.745]                 ...future.rng), started = ...future.startTime, 
[10:19:20.745]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.745]             version = "1.8"), class = "FutureResult")
[10:19:20.745]     }, finally = {
[10:19:20.745]         if (!identical(...future.workdir, getwd())) 
[10:19:20.745]             setwd(...future.workdir)
[10:19:20.745]         {
[10:19:20.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.745]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.745]             }
[10:19:20.745]             base::options(...future.oldOptions)
[10:19:20.745]             if (.Platform$OS.type == "windows") {
[10:19:20.745]                 old_names <- names(...future.oldEnvVars)
[10:19:20.745]                 envs <- base::Sys.getenv()
[10:19:20.745]                 names <- names(envs)
[10:19:20.745]                 common <- intersect(names, old_names)
[10:19:20.745]                 added <- setdiff(names, old_names)
[10:19:20.745]                 removed <- setdiff(old_names, names)
[10:19:20.745]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.745]                   envs[common]]
[10:19:20.745]                 NAMES <- toupper(changed)
[10:19:20.745]                 args <- list()
[10:19:20.745]                 for (kk in seq_along(NAMES)) {
[10:19:20.745]                   name <- changed[[kk]]
[10:19:20.745]                   NAME <- NAMES[[kk]]
[10:19:20.745]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.745]                     next
[10:19:20.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.745]                 }
[10:19:20.745]                 NAMES <- toupper(added)
[10:19:20.745]                 for (kk in seq_along(NAMES)) {
[10:19:20.745]                   name <- added[[kk]]
[10:19:20.745]                   NAME <- NAMES[[kk]]
[10:19:20.745]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.745]                     next
[10:19:20.745]                   args[[name]] <- ""
[10:19:20.745]                 }
[10:19:20.745]                 NAMES <- toupper(removed)
[10:19:20.745]                 for (kk in seq_along(NAMES)) {
[10:19:20.745]                   name <- removed[[kk]]
[10:19:20.745]                   NAME <- NAMES[[kk]]
[10:19:20.745]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.745]                     next
[10:19:20.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.745]                 }
[10:19:20.745]                 if (length(args) > 0) 
[10:19:20.745]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.745]             }
[10:19:20.745]             else {
[10:19:20.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.745]             }
[10:19:20.745]             {
[10:19:20.745]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.745]                   0L) {
[10:19:20.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.745]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.745]                   base::options(opts)
[10:19:20.745]                 }
[10:19:20.745]                 {
[10:19:20.745]                   {
[10:19:20.745]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.745]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.745]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.745]                       inherits = FALSE)
[10:19:20.745]                     NULL
[10:19:20.745]                   }
[10:19:20.745]                   options(future.plan = NULL)
[10:19:20.745]                   if (is.na(NA_character_)) 
[10:19:20.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.745]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.745]                     .init = FALSE)
[10:19:20.745]                 }
[10:19:20.745]             }
[10:19:20.745]         }
[10:19:20.745]     })
[10:19:20.745]     if (TRUE) {
[10:19:20.745]         base::sink(type = "output", split = FALSE)
[10:19:20.745]         if (TRUE) {
[10:19:20.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.745]         }
[10:19:20.745]         else {
[10:19:20.745]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.745]         }
[10:19:20.745]         base::close(...future.stdout)
[10:19:20.745]         ...future.stdout <- NULL
[10:19:20.745]     }
[10:19:20.745]     ...future.result$conditions <- ...future.conditions
[10:19:20.745]     ...future.result$finished <- base::Sys.time()
[10:19:20.745]     ...future.result
[10:19:20.745] }
[10:19:20.747] assign_globals() ...
[10:19:20.747] List of 5
[10:19:20.747]  $ ...future.FUN            :function (C, k)  
[10:19:20.747]  $ MoreArgs                 : NULL
[10:19:20.747]  $ ...future.elements_ii    :List of 2
[10:19:20.747]   ..$ :List of 2
[10:19:20.747]   .. ..$ : chr "B"
[10:19:20.747]   .. ..$ : chr "E"
[10:19:20.747]   ..$ :List of 2
[10:19:20.747]   .. ..$ : int 4
[10:19:20.747]   .. ..$ : int 1
[10:19:20.747]  $ ...future.seeds_ii       : NULL
[10:19:20.747]  $ ...future.globals.maxSize: NULL
[10:19:20.747]  - attr(*, "where")=List of 5
[10:19:20.747]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.747]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.747]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.747]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.747]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.747]  - attr(*, "resolved")= logi FALSE
[10:19:20.747]  - attr(*, "total_size")= num 876
[10:19:20.747]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.747]  - attr(*, "already-done")= logi TRUE
[10:19:20.752] - reassign environment for ‘...future.FUN’
[10:19:20.752] - copied ‘...future.FUN’ to environment
[10:19:20.752] - copied ‘MoreArgs’ to environment
[10:19:20.752] - copied ‘...future.elements_ii’ to environment
[10:19:20.752] - copied ‘...future.seeds_ii’ to environment
[10:19:20.752] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.752] assign_globals() ... done
[10:19:20.753] plan(): Setting new future strategy stack:
[10:19:20.753] List of future strategies:
[10:19:20.753] 1. sequential:
[10:19:20.753]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.753]    - tweaked: FALSE
[10:19:20.753]    - call: NULL
[10:19:20.753] plan(): nbrOfWorkers() = 1
[10:19:20.754] plan(): Setting new future strategy stack:
[10:19:20.754] List of future strategies:
[10:19:20.754] 1. sequential:
[10:19:20.754]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.754]    - tweaked: FALSE
[10:19:20.754]    - call: plan(strategy)
[10:19:20.754] plan(): nbrOfWorkers() = 1
[10:19:20.754] SequentialFuture started (and completed)
[10:19:20.755] - Launch lazy future ... done
[10:19:20.755] run() for ‘SequentialFuture’ ... done
[10:19:20.755] Created future:
[10:19:20.755] SequentialFuture:
[10:19:20.755] Label: ‘future_mapply-3’
[10:19:20.755] Expression:
[10:19:20.755] {
[10:19:20.755]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.755]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.755]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.755]         on.exit(options(oopts), add = TRUE)
[10:19:20.755]     }
[10:19:20.755]     {
[10:19:20.755]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.755]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.755]         do.call(mapply, args = args)
[10:19:20.755]     }
[10:19:20.755] }
[10:19:20.755] Lazy evaluation: FALSE
[10:19:20.755] Asynchronous evaluation: FALSE
[10:19:20.755] Local evaluation: TRUE
[10:19:20.755] Environment: R_GlobalEnv
[10:19:20.755] Capture standard output: TRUE
[10:19:20.755] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.755] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.755] Packages: <none>
[10:19:20.755] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.755] Resolved: TRUE
[10:19:20.755] Value: 68 bytes of class ‘list’
[10:19:20.755] Early signaling: FALSE
[10:19:20.755] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.755] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.756] Chunk #3 of 3 ... DONE
[10:19:20.756] Launching 3 futures (chunks) ... DONE
[10:19:20.756] Resolving 3 futures (chunks) ...
[10:19:20.756] resolve() on list ...
[10:19:20.756]  recursive: 0
[10:19:20.756]  length: 3
[10:19:20.756] 
[10:19:20.756] resolved() for ‘SequentialFuture’ ...
[10:19:20.756] - state: ‘finished’
[10:19:20.756] - run: TRUE
[10:19:20.756] - result: ‘FutureResult’
[10:19:20.757] resolved() for ‘SequentialFuture’ ... done
[10:19:20.757] Future #1
[10:19:20.757] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.757] - nx: 3
[10:19:20.757] - relay: TRUE
[10:19:20.757] - stdout: TRUE
[10:19:20.757] - signal: TRUE
[10:19:20.757] - resignal: FALSE
[10:19:20.757] - force: TRUE
[10:19:20.757] - relayed: [n=3] FALSE, FALSE, FALSE
[10:19:20.757] - queued futures: [n=3] FALSE, FALSE, FALSE
[10:19:20.757]  - until=1
[10:19:20.758]  - relaying element #1
[10:19:20.758] - relayed: [n=3] TRUE, FALSE, FALSE
[10:19:20.758] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:19:20.758] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.758]  length: 2 (resolved future 1)
[10:19:20.758] resolved() for ‘SequentialFuture’ ...
[10:19:20.758] - state: ‘finished’
[10:19:20.758] - run: TRUE
[10:19:20.758] - result: ‘FutureResult’
[10:19:20.758] resolved() for ‘SequentialFuture’ ... done
[10:19:20.758] Future #2
[10:19:20.759] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:19:20.759] - nx: 3
[10:19:20.759] - relay: TRUE
[10:19:20.759] - stdout: TRUE
[10:19:20.759] - signal: TRUE
[10:19:20.759] - resignal: FALSE
[10:19:20.759] - force: TRUE
[10:19:20.759] - relayed: [n=3] TRUE, FALSE, FALSE
[10:19:20.759] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:19:20.759]  - until=2
[10:19:20.759]  - relaying element #2
[10:19:20.760] - relayed: [n=3] TRUE, TRUE, FALSE
[10:19:20.760] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:19:20.760] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:19:20.760]  length: 1 (resolved future 2)
[10:19:20.760] resolved() for ‘SequentialFuture’ ...
[10:19:20.760] - state: ‘finished’
[10:19:20.760] - run: TRUE
[10:19:20.760] - result: ‘FutureResult’
[10:19:20.760] resolved() for ‘SequentialFuture’ ... done
[10:19:20.760] Future #3
[10:19:20.761] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:19:20.761] - nx: 3
[10:19:20.761] - relay: TRUE
[10:19:20.762] - stdout: TRUE
[10:19:20.762] - signal: TRUE
[10:19:20.762] - resignal: FALSE
[10:19:20.762] - force: TRUE
[10:19:20.762] - relayed: [n=3] TRUE, TRUE, FALSE
[10:19:20.762] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:19:20.763]  - until=3
[10:19:20.763]  - relaying element #3
[10:19:20.763] - relayed: [n=3] TRUE, TRUE, TRUE
[10:19:20.763] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:19:20.763] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:19:20.763]  length: 0 (resolved future 3)
[10:19:20.763] Relaying remaining futures
[10:19:20.763] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.763] - nx: 3
[10:19:20.763] - relay: TRUE
[10:19:20.764] - stdout: TRUE
[10:19:20.764] - signal: TRUE
[10:19:20.764] - resignal: FALSE
[10:19:20.764] - force: TRUE
[10:19:20.764] - relayed: [n=3] TRUE, TRUE, TRUE
[10:19:20.764] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[10:19:20.764] - relayed: [n=3] TRUE, TRUE, TRUE
[10:19:20.764] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:19:20.764] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.764] resolve() on list ... DONE
[10:19:20.764]  - Number of value chunks collected: 3
[10:19:20.765] Resolving 3 futures (chunks) ... DONE
[10:19:20.765] Reducing values from 3 chunks ...
[10:19:20.765]  - Number of values collected after concatenation: 5
[10:19:20.765]  - Number of values expected: 5
[10:19:20.765] Reverse index remapping (attribute 'ordering'): [n = 5] 3, 4, 1, 2, 5
[10:19:20.765] Reducing values from 3 chunks ... DONE
[10:19:20.765] future_mapply() ... DONE
[10:19:20.765] future_mapply() ...
[10:19:20.765] Number of chunks: 1
[10:19:20.766] getGlobalsAndPackagesXApply() ...
[10:19:20.766]  - future.globals: TRUE
[10:19:20.766] getGlobalsAndPackages() ...
[10:19:20.766] Searching for globals...
[10:19:20.767] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:20.767] Searching for globals ... DONE
[10:19:20.767] Resolving globals: FALSE
[10:19:20.768] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:20.768] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:20.768] - globals: [1] ‘FUN’
[10:19:20.768] 
[10:19:20.768] getGlobalsAndPackages() ... DONE
[10:19:20.768]  - globals found/used: [n=1] ‘FUN’
[10:19:20.768]  - needed namespaces: [n=0] 
[10:19:20.768] Finding globals ... DONE
[10:19:20.769] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.769] List of 2
[10:19:20.769]  $ ...future.FUN:function (C, k)  
[10:19:20.769]  $ MoreArgs     : list()
[10:19:20.769]  - attr(*, "where")=List of 2
[10:19:20.769]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.769]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.769]  - attr(*, "resolved")= logi FALSE
[10:19:20.769]  - attr(*, "total_size")= num NA
[10:19:20.771] Packages to be attached in all futures: [n=0] 
[10:19:20.771] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.771] Number of futures (= number of chunks): 1
[10:19:20.771] Launching 1 futures (chunks) ...
[10:19:20.771] Chunk #1 of 1 ...
[10:19:20.772]  - Finding globals in '...' for chunk #1 ...
[10:19:20.772] getGlobalsAndPackages() ...
[10:19:20.772] Searching for globals...
[10:19:20.772] 
[10:19:20.772] Searching for globals ... DONE
[10:19:20.772] - globals: [0] <none>
[10:19:20.772] getGlobalsAndPackages() ... DONE
[10:19:20.772]    + additional globals found: [n=0] 
[10:19:20.772]    + additional namespaces needed: [n=0] 
[10:19:20.772]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.773]  - seeds: <none>
[10:19:20.773]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.773] getGlobalsAndPackages() ...
[10:19:20.773] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.773] Resolving globals: FALSE
[10:19:20.773] The total size of the 5 globals is 967 bytes (967 bytes)
[10:19:20.774] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 967 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (192 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:20.774] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.774] 
[10:19:20.774] getGlobalsAndPackages() ... DONE
[10:19:20.774] run() for ‘Future’ ...
[10:19:20.774] - state: ‘created’
[10:19:20.774] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.775] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.775]   - Field: ‘label’
[10:19:20.775]   - Field: ‘local’
[10:19:20.775]   - Field: ‘owner’
[10:19:20.775]   - Field: ‘envir’
[10:19:20.775]   - Field: ‘packages’
[10:19:20.775]   - Field: ‘gc’
[10:19:20.775]   - Field: ‘conditions’
[10:19:20.775]   - Field: ‘expr’
[10:19:20.776]   - Field: ‘uuid’
[10:19:20.776]   - Field: ‘seed’
[10:19:20.776]   - Field: ‘version’
[10:19:20.776]   - Field: ‘result’
[10:19:20.776]   - Field: ‘asynchronous’
[10:19:20.776]   - Field: ‘calls’
[10:19:20.776]   - Field: ‘globals’
[10:19:20.776]   - Field: ‘stdout’
[10:19:20.776]   - Field: ‘earlySignal’
[10:19:20.776]   - Field: ‘lazy’
[10:19:20.776]   - Field: ‘state’
[10:19:20.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.777] - Launch lazy future ...
[10:19:20.777] Packages needed by the future expression (n = 0): <none>
[10:19:20.777] Packages needed by future strategies (n = 0): <none>
[10:19:20.777] {
[10:19:20.777]     {
[10:19:20.777]         {
[10:19:20.777]             ...future.startTime <- base::Sys.time()
[10:19:20.777]             {
[10:19:20.777]                 {
[10:19:20.777]                   {
[10:19:20.777]                     base::local({
[10:19:20.777]                       has_future <- base::requireNamespace("future", 
[10:19:20.777]                         quietly = TRUE)
[10:19:20.777]                       if (has_future) {
[10:19:20.777]                         ns <- base::getNamespace("future")
[10:19:20.777]                         version <- ns[[".package"]][["version"]]
[10:19:20.777]                         if (is.null(version)) 
[10:19:20.777]                           version <- utils::packageVersion("future")
[10:19:20.777]                       }
[10:19:20.777]                       else {
[10:19:20.777]                         version <- NULL
[10:19:20.777]                       }
[10:19:20.777]                       if (!has_future || version < "1.8.0") {
[10:19:20.777]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.777]                           "", base::R.version$version.string), 
[10:19:20.777]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.777]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.777]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.777]                             "release", "version")], collapse = " "), 
[10:19:20.777]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.777]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.777]                           info)
[10:19:20.777]                         info <- base::paste(info, collapse = "; ")
[10:19:20.777]                         if (!has_future) {
[10:19:20.777]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.777]                             info)
[10:19:20.777]                         }
[10:19:20.777]                         else {
[10:19:20.777]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.777]                             info, version)
[10:19:20.777]                         }
[10:19:20.777]                         base::stop(msg)
[10:19:20.777]                       }
[10:19:20.777]                     })
[10:19:20.777]                   }
[10:19:20.777]                   ...future.strategy.old <- future::plan("list")
[10:19:20.777]                   options(future.plan = NULL)
[10:19:20.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.777]                 }
[10:19:20.777]                 ...future.workdir <- getwd()
[10:19:20.777]             }
[10:19:20.777]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.777]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.777]         }
[10:19:20.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.777]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.777]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.777]             base::names(...future.oldOptions))
[10:19:20.777]     }
[10:19:20.777]     if (FALSE) {
[10:19:20.777]     }
[10:19:20.777]     else {
[10:19:20.777]         if (TRUE) {
[10:19:20.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.777]                 open = "w")
[10:19:20.777]         }
[10:19:20.777]         else {
[10:19:20.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.777]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.777]         }
[10:19:20.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.777]             base::sink(type = "output", split = FALSE)
[10:19:20.777]             base::close(...future.stdout)
[10:19:20.777]         }, add = TRUE)
[10:19:20.777]     }
[10:19:20.777]     ...future.frame <- base::sys.nframe()
[10:19:20.777]     ...future.conditions <- base::list()
[10:19:20.777]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.777]     if (FALSE) {
[10:19:20.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.777]     }
[10:19:20.777]     ...future.result <- base::tryCatch({
[10:19:20.777]         base::withCallingHandlers({
[10:19:20.777]             ...future.value <- base::withVisible(base::local({
[10:19:20.777]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.777]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.777]                   ...future.globals.maxSize)) {
[10:19:20.777]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.777]                   on.exit(options(oopts), add = TRUE)
[10:19:20.777]                 }
[10:19:20.777]                 {
[10:19:20.777]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.777]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.777]                     USE.NAMES = FALSE)
[10:19:20.777]                   do.call(mapply, args = args)
[10:19:20.777]                 }
[10:19:20.777]             }))
[10:19:20.777]             future::FutureResult(value = ...future.value$value, 
[10:19:20.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.777]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.777]                     ...future.globalenv.names))
[10:19:20.777]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.777]         }, condition = base::local({
[10:19:20.777]             c <- base::c
[10:19:20.777]             inherits <- base::inherits
[10:19:20.777]             invokeRestart <- base::invokeRestart
[10:19:20.777]             length <- base::length
[10:19:20.777]             list <- base::list
[10:19:20.777]             seq.int <- base::seq.int
[10:19:20.777]             signalCondition <- base::signalCondition
[10:19:20.777]             sys.calls <- base::sys.calls
[10:19:20.777]             `[[` <- base::`[[`
[10:19:20.777]             `+` <- base::`+`
[10:19:20.777]             `<<-` <- base::`<<-`
[10:19:20.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.777]                   3L)]
[10:19:20.777]             }
[10:19:20.777]             function(cond) {
[10:19:20.777]                 is_error <- inherits(cond, "error")
[10:19:20.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.777]                   NULL)
[10:19:20.777]                 if (is_error) {
[10:19:20.777]                   sessionInformation <- function() {
[10:19:20.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.777]                       search = base::search(), system = base::Sys.info())
[10:19:20.777]                   }
[10:19:20.777]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.777]                     cond$call), session = sessionInformation(), 
[10:19:20.777]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.777]                   signalCondition(cond)
[10:19:20.777]                 }
[10:19:20.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.777]                 "immediateCondition"))) {
[10:19:20.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.777]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.777]                   if (TRUE && !signal) {
[10:19:20.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.777]                     {
[10:19:20.777]                       inherits <- base::inherits
[10:19:20.777]                       invokeRestart <- base::invokeRestart
[10:19:20.777]                       is.null <- base::is.null
[10:19:20.777]                       muffled <- FALSE
[10:19:20.777]                       if (inherits(cond, "message")) {
[10:19:20.777]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.777]                         if (muffled) 
[10:19:20.777]                           invokeRestart("muffleMessage")
[10:19:20.777]                       }
[10:19:20.777]                       else if (inherits(cond, "warning")) {
[10:19:20.777]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.777]                         if (muffled) 
[10:19:20.777]                           invokeRestart("muffleWarning")
[10:19:20.777]                       }
[10:19:20.777]                       else if (inherits(cond, "condition")) {
[10:19:20.777]                         if (!is.null(pattern)) {
[10:19:20.777]                           computeRestarts <- base::computeRestarts
[10:19:20.777]                           grepl <- base::grepl
[10:19:20.777]                           restarts <- computeRestarts(cond)
[10:19:20.777]                           for (restart in restarts) {
[10:19:20.777]                             name <- restart$name
[10:19:20.777]                             if (is.null(name)) 
[10:19:20.777]                               next
[10:19:20.777]                             if (!grepl(pattern, name)) 
[10:19:20.777]                               next
[10:19:20.777]                             invokeRestart(restart)
[10:19:20.777]                             muffled <- TRUE
[10:19:20.777]                             break
[10:19:20.777]                           }
[10:19:20.777]                         }
[10:19:20.777]                       }
[10:19:20.777]                       invisible(muffled)
[10:19:20.777]                     }
[10:19:20.777]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.777]                   }
[10:19:20.777]                 }
[10:19:20.777]                 else {
[10:19:20.777]                   if (TRUE) {
[10:19:20.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.777]                     {
[10:19:20.777]                       inherits <- base::inherits
[10:19:20.777]                       invokeRestart <- base::invokeRestart
[10:19:20.777]                       is.null <- base::is.null
[10:19:20.777]                       muffled <- FALSE
[10:19:20.777]                       if (inherits(cond, "message")) {
[10:19:20.777]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.777]                         if (muffled) 
[10:19:20.777]                           invokeRestart("muffleMessage")
[10:19:20.777]                       }
[10:19:20.777]                       else if (inherits(cond, "warning")) {
[10:19:20.777]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.777]                         if (muffled) 
[10:19:20.777]                           invokeRestart("muffleWarning")
[10:19:20.777]                       }
[10:19:20.777]                       else if (inherits(cond, "condition")) {
[10:19:20.777]                         if (!is.null(pattern)) {
[10:19:20.777]                           computeRestarts <- base::computeRestarts
[10:19:20.777]                           grepl <- base::grepl
[10:19:20.777]                           restarts <- computeRestarts(cond)
[10:19:20.777]                           for (restart in restarts) {
[10:19:20.777]                             name <- restart$name
[10:19:20.777]                             if (is.null(name)) 
[10:19:20.777]                               next
[10:19:20.777]                             if (!grepl(pattern, name)) 
[10:19:20.777]                               next
[10:19:20.777]                             invokeRestart(restart)
[10:19:20.777]                             muffled <- TRUE
[10:19:20.777]                             break
[10:19:20.777]                           }
[10:19:20.777]                         }
[10:19:20.777]                       }
[10:19:20.777]                       invisible(muffled)
[10:19:20.777]                     }
[10:19:20.777]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.777]                   }
[10:19:20.777]                 }
[10:19:20.777]             }
[10:19:20.777]         }))
[10:19:20.777]     }, error = function(ex) {
[10:19:20.777]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.777]                 ...future.rng), started = ...future.startTime, 
[10:19:20.777]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.777]             version = "1.8"), class = "FutureResult")
[10:19:20.777]     }, finally = {
[10:19:20.777]         if (!identical(...future.workdir, getwd())) 
[10:19:20.777]             setwd(...future.workdir)
[10:19:20.777]         {
[10:19:20.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.777]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.777]             }
[10:19:20.777]             base::options(...future.oldOptions)
[10:19:20.777]             if (.Platform$OS.type == "windows") {
[10:19:20.777]                 old_names <- names(...future.oldEnvVars)
[10:19:20.777]                 envs <- base::Sys.getenv()
[10:19:20.777]                 names <- names(envs)
[10:19:20.777]                 common <- intersect(names, old_names)
[10:19:20.777]                 added <- setdiff(names, old_names)
[10:19:20.777]                 removed <- setdiff(old_names, names)
[10:19:20.777]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.777]                   envs[common]]
[10:19:20.777]                 NAMES <- toupper(changed)
[10:19:20.777]                 args <- list()
[10:19:20.777]                 for (kk in seq_along(NAMES)) {
[10:19:20.777]                   name <- changed[[kk]]
[10:19:20.777]                   NAME <- NAMES[[kk]]
[10:19:20.777]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.777]                     next
[10:19:20.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.777]                 }
[10:19:20.777]                 NAMES <- toupper(added)
[10:19:20.777]                 for (kk in seq_along(NAMES)) {
[10:19:20.777]                   name <- added[[kk]]
[10:19:20.777]                   NAME <- NAMES[[kk]]
[10:19:20.777]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.777]                     next
[10:19:20.777]                   args[[name]] <- ""
[10:19:20.777]                 }
[10:19:20.777]                 NAMES <- toupper(removed)
[10:19:20.777]                 for (kk in seq_along(NAMES)) {
[10:19:20.777]                   name <- removed[[kk]]
[10:19:20.777]                   NAME <- NAMES[[kk]]
[10:19:20.777]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.777]                     next
[10:19:20.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.777]                 }
[10:19:20.777]                 if (length(args) > 0) 
[10:19:20.777]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.777]             }
[10:19:20.777]             else {
[10:19:20.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.777]             }
[10:19:20.777]             {
[10:19:20.777]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.777]                   0L) {
[10:19:20.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.777]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.777]                   base::options(opts)
[10:19:20.777]                 }
[10:19:20.777]                 {
[10:19:20.777]                   {
[10:19:20.777]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.777]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.777]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.777]                       inherits = FALSE)
[10:19:20.777]                     NULL
[10:19:20.777]                   }
[10:19:20.777]                   options(future.plan = NULL)
[10:19:20.777]                   if (is.na(NA_character_)) 
[10:19:20.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.777]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.777]                     .init = FALSE)
[10:19:20.777]                 }
[10:19:20.777]             }
[10:19:20.777]         }
[10:19:20.777]     })
[10:19:20.777]     if (TRUE) {
[10:19:20.777]         base::sink(type = "output", split = FALSE)
[10:19:20.777]         if (TRUE) {
[10:19:20.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.777]         }
[10:19:20.777]         else {
[10:19:20.777]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.777]         }
[10:19:20.777]         base::close(...future.stdout)
[10:19:20.777]         ...future.stdout <- NULL
[10:19:20.777]     }
[10:19:20.777]     ...future.result$conditions <- ...future.conditions
[10:19:20.777]     ...future.result$finished <- base::Sys.time()
[10:19:20.777]     ...future.result
[10:19:20.777] }
[10:19:20.779] assign_globals() ...
[10:19:20.779] List of 5
[10:19:20.779]  $ ...future.FUN            :function (C, k)  
[10:19:20.779]  $ MoreArgs                 : list()
[10:19:20.779]  $ ...future.elements_ii    :List of 2
[10:19:20.779]   ..$ :List of 5
[10:19:20.779]   .. ..$ : chr "A"
[10:19:20.779]   .. ..$ : chr "B"
[10:19:20.779]   .. ..$ : chr "C"
[10:19:20.779]   .. ..$ : chr "D"
[10:19:20.779]   .. ..$ : chr "E"
[10:19:20.779]   ..$ :List of 5
[10:19:20.779]   .. ..$ : int 5
[10:19:20.779]   .. ..$ : int 4
[10:19:20.779]   .. ..$ : int 3
[10:19:20.779]   .. ..$ : int 2
[10:19:20.779]   .. ..$ : int 1
[10:19:20.779]  $ ...future.seeds_ii       : NULL
[10:19:20.779]  $ ...future.globals.maxSize: NULL
[10:19:20.779]  - attr(*, "where")=List of 5
[10:19:20.779]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.779]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.779]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.779]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.779]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.779]  - attr(*, "resolved")= logi FALSE
[10:19:20.779]  - attr(*, "total_size")= num 967
[10:19:20.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.779]  - attr(*, "already-done")= logi TRUE
[10:19:20.787] - reassign environment for ‘...future.FUN’
[10:19:20.787] - copied ‘...future.FUN’ to environment
[10:19:20.787] - copied ‘MoreArgs’ to environment
[10:19:20.787] - copied ‘...future.elements_ii’ to environment
[10:19:20.787] - copied ‘...future.seeds_ii’ to environment
[10:19:20.787] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.787] assign_globals() ... done
[10:19:20.788] plan(): Setting new future strategy stack:
[10:19:20.788] List of future strategies:
[10:19:20.788] 1. sequential:
[10:19:20.788]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.788]    - tweaked: FALSE
[10:19:20.788]    - call: NULL
[10:19:20.788] plan(): nbrOfWorkers() = 1
[10:19:20.789] plan(): Setting new future strategy stack:
[10:19:20.789] List of future strategies:
[10:19:20.789] 1. sequential:
[10:19:20.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.789]    - tweaked: FALSE
[10:19:20.789]    - call: plan(strategy)
[10:19:20.789] plan(): nbrOfWorkers() = 1
[10:19:20.790] SequentialFuture started (and completed)
[10:19:20.790] - Launch lazy future ... done
[10:19:20.790] run() for ‘SequentialFuture’ ... done
[10:19:20.790] Created future:
[10:19:20.790] SequentialFuture:
[10:19:20.790] Label: ‘future_.mapply-1’
[10:19:20.790] Expression:
[10:19:20.790] {
[10:19:20.790]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.790]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.790]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.790]         on.exit(options(oopts), add = TRUE)
[10:19:20.790]     }
[10:19:20.790]     {
[10:19:20.790]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.790]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.790]         do.call(mapply, args = args)
[10:19:20.790]     }
[10:19:20.790] }
[10:19:20.790] Lazy evaluation: FALSE
[10:19:20.790] Asynchronous evaluation: FALSE
[10:19:20.790] Local evaluation: TRUE
[10:19:20.790] Environment: R_GlobalEnv
[10:19:20.790] Capture standard output: TRUE
[10:19:20.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.790] Globals: 5 objects totaling 967 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.790] Packages: <none>
[10:19:20.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.790] Resolved: TRUE
[10:19:20.790] Value: 126 bytes of class ‘list’
[10:19:20.790] Early signaling: FALSE
[10:19:20.790] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.790] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.791] Chunk #1 of 1 ... DONE
[10:19:20.791] Launching 1 futures (chunks) ... DONE
[10:19:20.791] Resolving 1 futures (chunks) ...
[10:19:20.791] resolve() on list ...
[10:19:20.791]  recursive: 0
[10:19:20.791]  length: 1
[10:19:20.791] 
[10:19:20.791] resolved() for ‘SequentialFuture’ ...
[10:19:20.791] - state: ‘finished’
[10:19:20.791] - run: TRUE
[10:19:20.792] - result: ‘FutureResult’
[10:19:20.792] resolved() for ‘SequentialFuture’ ... done
[10:19:20.792] Future #1
[10:19:20.792] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.792] - nx: 1
[10:19:20.792] - relay: TRUE
[10:19:20.792] - stdout: TRUE
[10:19:20.792] - signal: TRUE
[10:19:20.792] - resignal: FALSE
[10:19:20.792] - force: TRUE
[10:19:20.792] - relayed: [n=1] FALSE
[10:19:20.792] - queued futures: [n=1] FALSE
[10:19:20.793]  - until=1
[10:19:20.793]  - relaying element #1
[10:19:20.793] - relayed: [n=1] TRUE
[10:19:20.793] - queued futures: [n=1] TRUE
[10:19:20.793] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.793]  length: 0 (resolved future 1)
[10:19:20.793] Relaying remaining futures
[10:19:20.793] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.793] - nx: 1
[10:19:20.793] - relay: TRUE
[10:19:20.793] - stdout: TRUE
[10:19:20.793] - signal: TRUE
[10:19:20.794] - resignal: FALSE
[10:19:20.794] - force: TRUE
[10:19:20.794] - relayed: [n=1] TRUE
[10:19:20.794] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.794] - relayed: [n=1] TRUE
[10:19:20.794] - queued futures: [n=1] TRUE
[10:19:20.794] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.794] resolve() on list ... DONE
[10:19:20.794]  - Number of value chunks collected: 1
[10:19:20.794] Resolving 1 futures (chunks) ... DONE
[10:19:20.794] Reducing values from 1 chunks ...
[10:19:20.795]  - Number of values collected after concatenation: 5
[10:19:20.795]  - Number of values expected: 5
[10:19:20.795] Reducing values from 1 chunks ... DONE
[10:19:20.795] future_mapply() ... DONE
[10:19:20.795] future_mapply() ...
[10:19:20.795] Number of chunks: 2
[10:19:20.795] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:19:20.796] getGlobalsAndPackagesXApply() ...
[10:19:20.796]  - future.globals: TRUE
[10:19:20.796] getGlobalsAndPackages() ...
[10:19:20.796] Searching for globals...
[10:19:20.797] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:20.797] Searching for globals ... DONE
[10:19:20.797] Resolving globals: FALSE
[10:19:20.797] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:20.798] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:20.798] - globals: [1] ‘FUN’
[10:19:20.798] 
[10:19:20.798] getGlobalsAndPackages() ... DONE
[10:19:20.798]  - globals found/used: [n=1] ‘FUN’
[10:19:20.798]  - needed namespaces: [n=0] 
[10:19:20.798] Finding globals ... DONE
[10:19:20.798] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.799] List of 2
[10:19:20.799]  $ ...future.FUN:function (C, k)  
[10:19:20.799]  $ MoreArgs     : NULL
[10:19:20.799]  - attr(*, "where")=List of 2
[10:19:20.799]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.799]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.799]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.799]  - attr(*, "resolved")= logi FALSE
[10:19:20.799]  - attr(*, "total_size")= num NA
[10:19:20.801] Packages to be attached in all futures: [n=0] 
[10:19:20.801] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.801] Number of futures (= number of chunks): 2
[10:19:20.801] Launching 2 futures (chunks) ...
[10:19:20.801] Chunk #1 of 2 ...
[10:19:20.801]  - Finding globals in '...' for chunk #1 ...
[10:19:20.801] getGlobalsAndPackages() ...
[10:19:20.802] Searching for globals...
[10:19:20.802] 
[10:19:20.802] Searching for globals ... DONE
[10:19:20.802] - globals: [0] <none>
[10:19:20.802] getGlobalsAndPackages() ... DONE
[10:19:20.802]    + additional globals found: [n=0] 
[10:19:20.802]    + additional namespaces needed: [n=0] 
[10:19:20.802]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.802]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:20.802]  - seeds: <none>
[10:19:20.803]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.803] getGlobalsAndPackages() ...
[10:19:20.803] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.803] Resolving globals: FALSE
[10:19:20.803] The total size of the 5 globals is 876 bytes (876 bytes)
[10:19:20.804] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.804] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.804] 
[10:19:20.804] getGlobalsAndPackages() ... DONE
[10:19:20.804] run() for ‘Future’ ...
[10:19:20.804] - state: ‘created’
[10:19:20.804] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.805] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.805] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.805]   - Field: ‘label’
[10:19:20.805]   - Field: ‘local’
[10:19:20.805]   - Field: ‘owner’
[10:19:20.805]   - Field: ‘envir’
[10:19:20.805]   - Field: ‘packages’
[10:19:20.805]   - Field: ‘gc’
[10:19:20.805]   - Field: ‘conditions’
[10:19:20.807]   - Field: ‘expr’
[10:19:20.807]   - Field: ‘uuid’
[10:19:20.807]   - Field: ‘seed’
[10:19:20.807]   - Field: ‘version’
[10:19:20.807]   - Field: ‘result’
[10:19:20.807]   - Field: ‘asynchronous’
[10:19:20.807]   - Field: ‘calls’
[10:19:20.807]   - Field: ‘globals’
[10:19:20.807]   - Field: ‘stdout’
[10:19:20.807]   - Field: ‘earlySignal’
[10:19:20.807]   - Field: ‘lazy’
[10:19:20.808]   - Field: ‘state’
[10:19:20.808] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.808] - Launch lazy future ...
[10:19:20.808] Packages needed by the future expression (n = 0): <none>
[10:19:20.808] Packages needed by future strategies (n = 0): <none>
[10:19:20.808] {
[10:19:20.808]     {
[10:19:20.808]         {
[10:19:20.808]             ...future.startTime <- base::Sys.time()
[10:19:20.808]             {
[10:19:20.808]                 {
[10:19:20.808]                   {
[10:19:20.808]                     base::local({
[10:19:20.808]                       has_future <- base::requireNamespace("future", 
[10:19:20.808]                         quietly = TRUE)
[10:19:20.808]                       if (has_future) {
[10:19:20.808]                         ns <- base::getNamespace("future")
[10:19:20.808]                         version <- ns[[".package"]][["version"]]
[10:19:20.808]                         if (is.null(version)) 
[10:19:20.808]                           version <- utils::packageVersion("future")
[10:19:20.808]                       }
[10:19:20.808]                       else {
[10:19:20.808]                         version <- NULL
[10:19:20.808]                       }
[10:19:20.808]                       if (!has_future || version < "1.8.0") {
[10:19:20.808]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.808]                           "", base::R.version$version.string), 
[10:19:20.808]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.808]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.808]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.808]                             "release", "version")], collapse = " "), 
[10:19:20.808]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.808]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.808]                           info)
[10:19:20.808]                         info <- base::paste(info, collapse = "; ")
[10:19:20.808]                         if (!has_future) {
[10:19:20.808]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.808]                             info)
[10:19:20.808]                         }
[10:19:20.808]                         else {
[10:19:20.808]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.808]                             info, version)
[10:19:20.808]                         }
[10:19:20.808]                         base::stop(msg)
[10:19:20.808]                       }
[10:19:20.808]                     })
[10:19:20.808]                   }
[10:19:20.808]                   ...future.strategy.old <- future::plan("list")
[10:19:20.808]                   options(future.plan = NULL)
[10:19:20.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.808]                 }
[10:19:20.808]                 ...future.workdir <- getwd()
[10:19:20.808]             }
[10:19:20.808]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.808]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.808]         }
[10:19:20.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.808]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:20.808]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.808]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.808]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.808]             base::names(...future.oldOptions))
[10:19:20.808]     }
[10:19:20.808]     if (FALSE) {
[10:19:20.808]     }
[10:19:20.808]     else {
[10:19:20.808]         if (TRUE) {
[10:19:20.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.808]                 open = "w")
[10:19:20.808]         }
[10:19:20.808]         else {
[10:19:20.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.808]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.808]         }
[10:19:20.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.808]             base::sink(type = "output", split = FALSE)
[10:19:20.808]             base::close(...future.stdout)
[10:19:20.808]         }, add = TRUE)
[10:19:20.808]     }
[10:19:20.808]     ...future.frame <- base::sys.nframe()
[10:19:20.808]     ...future.conditions <- base::list()
[10:19:20.808]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.808]     if (FALSE) {
[10:19:20.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.808]     }
[10:19:20.808]     ...future.result <- base::tryCatch({
[10:19:20.808]         base::withCallingHandlers({
[10:19:20.808]             ...future.value <- base::withVisible(base::local({
[10:19:20.808]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.808]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.808]                   ...future.globals.maxSize)) {
[10:19:20.808]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.808]                   on.exit(options(oopts), add = TRUE)
[10:19:20.808]                 }
[10:19:20.808]                 {
[10:19:20.808]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.808]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.808]                     USE.NAMES = FALSE)
[10:19:20.808]                   do.call(mapply, args = args)
[10:19:20.808]                 }
[10:19:20.808]             }))
[10:19:20.808]             future::FutureResult(value = ...future.value$value, 
[10:19:20.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.808]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.808]                     ...future.globalenv.names))
[10:19:20.808]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.808]         }, condition = base::local({
[10:19:20.808]             c <- base::c
[10:19:20.808]             inherits <- base::inherits
[10:19:20.808]             invokeRestart <- base::invokeRestart
[10:19:20.808]             length <- base::length
[10:19:20.808]             list <- base::list
[10:19:20.808]             seq.int <- base::seq.int
[10:19:20.808]             signalCondition <- base::signalCondition
[10:19:20.808]             sys.calls <- base::sys.calls
[10:19:20.808]             `[[` <- base::`[[`
[10:19:20.808]             `+` <- base::`+`
[10:19:20.808]             `<<-` <- base::`<<-`
[10:19:20.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.808]                   3L)]
[10:19:20.808]             }
[10:19:20.808]             function(cond) {
[10:19:20.808]                 is_error <- inherits(cond, "error")
[10:19:20.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.808]                   NULL)
[10:19:20.808]                 if (is_error) {
[10:19:20.808]                   sessionInformation <- function() {
[10:19:20.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.808]                       search = base::search(), system = base::Sys.info())
[10:19:20.808]                   }
[10:19:20.808]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.808]                     cond$call), session = sessionInformation(), 
[10:19:20.808]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.808]                   signalCondition(cond)
[10:19:20.808]                 }
[10:19:20.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.808]                 "immediateCondition"))) {
[10:19:20.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.808]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.808]                   if (TRUE && !signal) {
[10:19:20.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.808]                     {
[10:19:20.808]                       inherits <- base::inherits
[10:19:20.808]                       invokeRestart <- base::invokeRestart
[10:19:20.808]                       is.null <- base::is.null
[10:19:20.808]                       muffled <- FALSE
[10:19:20.808]                       if (inherits(cond, "message")) {
[10:19:20.808]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.808]                         if (muffled) 
[10:19:20.808]                           invokeRestart("muffleMessage")
[10:19:20.808]                       }
[10:19:20.808]                       else if (inherits(cond, "warning")) {
[10:19:20.808]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.808]                         if (muffled) 
[10:19:20.808]                           invokeRestart("muffleWarning")
[10:19:20.808]                       }
[10:19:20.808]                       else if (inherits(cond, "condition")) {
[10:19:20.808]                         if (!is.null(pattern)) {
[10:19:20.808]                           computeRestarts <- base::computeRestarts
[10:19:20.808]                           grepl <- base::grepl
[10:19:20.808]                           restarts <- computeRestarts(cond)
[10:19:20.808]                           for (restart in restarts) {
[10:19:20.808]                             name <- restart$name
[10:19:20.808]                             if (is.null(name)) 
[10:19:20.808]                               next
[10:19:20.808]                             if (!grepl(pattern, name)) 
[10:19:20.808]                               next
[10:19:20.808]                             invokeRestart(restart)
[10:19:20.808]                             muffled <- TRUE
[10:19:20.808]                             break
[10:19:20.808]                           }
[10:19:20.808]                         }
[10:19:20.808]                       }
[10:19:20.808]                       invisible(muffled)
[10:19:20.808]                     }
[10:19:20.808]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.808]                   }
[10:19:20.808]                 }
[10:19:20.808]                 else {
[10:19:20.808]                   if (TRUE) {
[10:19:20.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.808]                     {
[10:19:20.808]                       inherits <- base::inherits
[10:19:20.808]                       invokeRestart <- base::invokeRestart
[10:19:20.808]                       is.null <- base::is.null
[10:19:20.808]                       muffled <- FALSE
[10:19:20.808]                       if (inherits(cond, "message")) {
[10:19:20.808]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.808]                         if (muffled) 
[10:19:20.808]                           invokeRestart("muffleMessage")
[10:19:20.808]                       }
[10:19:20.808]                       else if (inherits(cond, "warning")) {
[10:19:20.808]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.808]                         if (muffled) 
[10:19:20.808]                           invokeRestart("muffleWarning")
[10:19:20.808]                       }
[10:19:20.808]                       else if (inherits(cond, "condition")) {
[10:19:20.808]                         if (!is.null(pattern)) {
[10:19:20.808]                           computeRestarts <- base::computeRestarts
[10:19:20.808]                           grepl <- base::grepl
[10:19:20.808]                           restarts <- computeRestarts(cond)
[10:19:20.808]                           for (restart in restarts) {
[10:19:20.808]                             name <- restart$name
[10:19:20.808]                             if (is.null(name)) 
[10:19:20.808]                               next
[10:19:20.808]                             if (!grepl(pattern, name)) 
[10:19:20.808]                               next
[10:19:20.808]                             invokeRestart(restart)
[10:19:20.808]                             muffled <- TRUE
[10:19:20.808]                             break
[10:19:20.808]                           }
[10:19:20.808]                         }
[10:19:20.808]                       }
[10:19:20.808]                       invisible(muffled)
[10:19:20.808]                     }
[10:19:20.808]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.808]                   }
[10:19:20.808]                 }
[10:19:20.808]             }
[10:19:20.808]         }))
[10:19:20.808]     }, error = function(ex) {
[10:19:20.808]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.808]                 ...future.rng), started = ...future.startTime, 
[10:19:20.808]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.808]             version = "1.8"), class = "FutureResult")
[10:19:20.808]     }, finally = {
[10:19:20.808]         if (!identical(...future.workdir, getwd())) 
[10:19:20.808]             setwd(...future.workdir)
[10:19:20.808]         {
[10:19:20.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.808]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.808]             }
[10:19:20.808]             base::options(...future.oldOptions)
[10:19:20.808]             if (.Platform$OS.type == "windows") {
[10:19:20.808]                 old_names <- names(...future.oldEnvVars)
[10:19:20.808]                 envs <- base::Sys.getenv()
[10:19:20.808]                 names <- names(envs)
[10:19:20.808]                 common <- intersect(names, old_names)
[10:19:20.808]                 added <- setdiff(names, old_names)
[10:19:20.808]                 removed <- setdiff(old_names, names)
[10:19:20.808]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.808]                   envs[common]]
[10:19:20.808]                 NAMES <- toupper(changed)
[10:19:20.808]                 args <- list()
[10:19:20.808]                 for (kk in seq_along(NAMES)) {
[10:19:20.808]                   name <- changed[[kk]]
[10:19:20.808]                   NAME <- NAMES[[kk]]
[10:19:20.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.808]                     next
[10:19:20.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.808]                 }
[10:19:20.808]                 NAMES <- toupper(added)
[10:19:20.808]                 for (kk in seq_along(NAMES)) {
[10:19:20.808]                   name <- added[[kk]]
[10:19:20.808]                   NAME <- NAMES[[kk]]
[10:19:20.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.808]                     next
[10:19:20.808]                   args[[name]] <- ""
[10:19:20.808]                 }
[10:19:20.808]                 NAMES <- toupper(removed)
[10:19:20.808]                 for (kk in seq_along(NAMES)) {
[10:19:20.808]                   name <- removed[[kk]]
[10:19:20.808]                   NAME <- NAMES[[kk]]
[10:19:20.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.808]                     next
[10:19:20.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.808]                 }
[10:19:20.808]                 if (length(args) > 0) 
[10:19:20.808]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.808]             }
[10:19:20.808]             else {
[10:19:20.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.808]             }
[10:19:20.808]             {
[10:19:20.808]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.808]                   0L) {
[10:19:20.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.808]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.808]                   base::options(opts)
[10:19:20.808]                 }
[10:19:20.808]                 {
[10:19:20.808]                   {
[10:19:20.808]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.808]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.808]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.808]                       inherits = FALSE)
[10:19:20.808]                     NULL
[10:19:20.808]                   }
[10:19:20.808]                   options(future.plan = NULL)
[10:19:20.808]                   if (is.na(NA_character_)) 
[10:19:20.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.808]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.808]                     .init = FALSE)
[10:19:20.808]                 }
[10:19:20.808]             }
[10:19:20.808]         }
[10:19:20.808]     })
[10:19:20.808]     if (TRUE) {
[10:19:20.808]         base::sink(type = "output", split = FALSE)
[10:19:20.808]         if (TRUE) {
[10:19:20.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.808]         }
[10:19:20.808]         else {
[10:19:20.808]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.808]         }
[10:19:20.808]         base::close(...future.stdout)
[10:19:20.808]         ...future.stdout <- NULL
[10:19:20.808]     }
[10:19:20.808]     ...future.result$conditions <- ...future.conditions
[10:19:20.808]     ...future.result$finished <- base::Sys.time()
[10:19:20.808]     ...future.result
[10:19:20.808] }
[10:19:20.810] assign_globals() ...
[10:19:20.810] List of 5
[10:19:20.810]  $ ...future.FUN            :function (C, k)  
[10:19:20.810]  $ MoreArgs                 : NULL
[10:19:20.810]  $ ...future.elements_ii    :List of 2
[10:19:20.810]   ..$ :List of 2
[10:19:20.810]   .. ..$ : chr "E"
[10:19:20.810]   .. ..$ : chr "D"
[10:19:20.810]   ..$ :List of 2
[10:19:20.810]   .. ..$ : int 1
[10:19:20.810]   .. ..$ : int 2
[10:19:20.810]  $ ...future.seeds_ii       : NULL
[10:19:20.810]  $ ...future.globals.maxSize: NULL
[10:19:20.810]  - attr(*, "where")=List of 5
[10:19:20.810]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.810]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.810]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.810]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.810]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.810]  - attr(*, "resolved")= logi FALSE
[10:19:20.810]  - attr(*, "total_size")= num 876
[10:19:20.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.810]  - attr(*, "already-done")= logi TRUE
[10:19:20.815] - reassign environment for ‘...future.FUN’
[10:19:20.815] - copied ‘...future.FUN’ to environment
[10:19:20.815] - copied ‘MoreArgs’ to environment
[10:19:20.815] - copied ‘...future.elements_ii’ to environment
[10:19:20.816] - copied ‘...future.seeds_ii’ to environment
[10:19:20.816] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.816] assign_globals() ... done
[10:19:20.816] plan(): Setting new future strategy stack:
[10:19:20.816] List of future strategies:
[10:19:20.816] 1. sequential:
[10:19:20.816]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.816]    - tweaked: FALSE
[10:19:20.816]    - call: NULL
[10:19:20.816] plan(): nbrOfWorkers() = 1
[10:19:20.817] plan(): Setting new future strategy stack:
[10:19:20.817] List of future strategies:
[10:19:20.817] 1. sequential:
[10:19:20.817]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.817]    - tweaked: FALSE
[10:19:20.817]    - call: plan(strategy)
[10:19:20.818] plan(): nbrOfWorkers() = 1
[10:19:20.818] SequentialFuture started (and completed)
[10:19:20.818] - Launch lazy future ... done
[10:19:20.818] run() for ‘SequentialFuture’ ... done
[10:19:20.818] Created future:
[10:19:20.818] SequentialFuture:
[10:19:20.818] Label: ‘future_mapply-1’
[10:19:20.818] Expression:
[10:19:20.818] {
[10:19:20.818]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.818]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.818]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.818]         on.exit(options(oopts), add = TRUE)
[10:19:20.818]     }
[10:19:20.818]     {
[10:19:20.818]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.818]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.818]         do.call(mapply, args = args)
[10:19:20.818]     }
[10:19:20.818] }
[10:19:20.818] Lazy evaluation: FALSE
[10:19:20.818] Asynchronous evaluation: FALSE
[10:19:20.818] Local evaluation: TRUE
[10:19:20.818] Environment: R_GlobalEnv
[10:19:20.818] Capture standard output: TRUE
[10:19:20.818] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.818] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.818] Packages: <none>
[10:19:20.818] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.818] Resolved: TRUE
[10:19:20.818] Value: 66 bytes of class ‘list’
[10:19:20.818] Early signaling: FALSE
[10:19:20.818] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.818] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.819] Chunk #1 of 2 ... DONE
[10:19:20.819] Chunk #2 of 2 ...
[10:19:20.819]  - Finding globals in '...' for chunk #2 ...
[10:19:20.819] getGlobalsAndPackages() ...
[10:19:20.819] Searching for globals...
[10:19:20.820] 
[10:19:20.820] Searching for globals ... DONE
[10:19:20.820] - globals: [0] <none>
[10:19:20.820] getGlobalsAndPackages() ... DONE
[10:19:20.820]    + additional globals found: [n=0] 
[10:19:20.820]    + additional namespaces needed: [n=0] 
[10:19:20.820]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:20.820]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:20.820]  - seeds: <none>
[10:19:20.820]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.821] getGlobalsAndPackages() ...
[10:19:20.821] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.821] Resolving globals: FALSE
[10:19:20.821] The total size of the 5 globals is 905 bytes (905 bytes)
[10:19:20.821] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 905 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.822] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.822] 
[10:19:20.822] getGlobalsAndPackages() ... DONE
[10:19:20.822] run() for ‘Future’ ...
[10:19:20.822] - state: ‘created’
[10:19:20.822] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.822] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.823] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.823]   - Field: ‘label’
[10:19:20.823]   - Field: ‘local’
[10:19:20.823]   - Field: ‘owner’
[10:19:20.823]   - Field: ‘envir’
[10:19:20.823]   - Field: ‘packages’
[10:19:20.823]   - Field: ‘gc’
[10:19:20.823]   - Field: ‘conditions’
[10:19:20.823]   - Field: ‘expr’
[10:19:20.823]   - Field: ‘uuid’
[10:19:20.823]   - Field: ‘seed’
[10:19:20.824]   - Field: ‘version’
[10:19:20.824]   - Field: ‘result’
[10:19:20.824]   - Field: ‘asynchronous’
[10:19:20.824]   - Field: ‘calls’
[10:19:20.824]   - Field: ‘globals’
[10:19:20.824]   - Field: ‘stdout’
[10:19:20.824]   - Field: ‘earlySignal’
[10:19:20.824]   - Field: ‘lazy’
[10:19:20.824]   - Field: ‘state’
[10:19:20.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.824] - Launch lazy future ...
[10:19:20.824] Packages needed by the future expression (n = 0): <none>
[10:19:20.825] Packages needed by future strategies (n = 0): <none>
[10:19:20.825] {
[10:19:20.825]     {
[10:19:20.825]         {
[10:19:20.825]             ...future.startTime <- base::Sys.time()
[10:19:20.825]             {
[10:19:20.825]                 {
[10:19:20.825]                   {
[10:19:20.825]                     base::local({
[10:19:20.825]                       has_future <- base::requireNamespace("future", 
[10:19:20.825]                         quietly = TRUE)
[10:19:20.825]                       if (has_future) {
[10:19:20.825]                         ns <- base::getNamespace("future")
[10:19:20.825]                         version <- ns[[".package"]][["version"]]
[10:19:20.825]                         if (is.null(version)) 
[10:19:20.825]                           version <- utils::packageVersion("future")
[10:19:20.825]                       }
[10:19:20.825]                       else {
[10:19:20.825]                         version <- NULL
[10:19:20.825]                       }
[10:19:20.825]                       if (!has_future || version < "1.8.0") {
[10:19:20.825]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.825]                           "", base::R.version$version.string), 
[10:19:20.825]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.825]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.825]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.825]                             "release", "version")], collapse = " "), 
[10:19:20.825]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.825]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.825]                           info)
[10:19:20.825]                         info <- base::paste(info, collapse = "; ")
[10:19:20.825]                         if (!has_future) {
[10:19:20.825]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.825]                             info)
[10:19:20.825]                         }
[10:19:20.825]                         else {
[10:19:20.825]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.825]                             info, version)
[10:19:20.825]                         }
[10:19:20.825]                         base::stop(msg)
[10:19:20.825]                       }
[10:19:20.825]                     })
[10:19:20.825]                   }
[10:19:20.825]                   ...future.strategy.old <- future::plan("list")
[10:19:20.825]                   options(future.plan = NULL)
[10:19:20.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.825]                 }
[10:19:20.825]                 ...future.workdir <- getwd()
[10:19:20.825]             }
[10:19:20.825]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.825]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.825]         }
[10:19:20.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.825]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:20.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.825]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.825]             base::names(...future.oldOptions))
[10:19:20.825]     }
[10:19:20.825]     if (FALSE) {
[10:19:20.825]     }
[10:19:20.825]     else {
[10:19:20.825]         if (TRUE) {
[10:19:20.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.825]                 open = "w")
[10:19:20.825]         }
[10:19:20.825]         else {
[10:19:20.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.825]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.825]         }
[10:19:20.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.825]             base::sink(type = "output", split = FALSE)
[10:19:20.825]             base::close(...future.stdout)
[10:19:20.825]         }, add = TRUE)
[10:19:20.825]     }
[10:19:20.825]     ...future.frame <- base::sys.nframe()
[10:19:20.825]     ...future.conditions <- base::list()
[10:19:20.825]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.825]     if (FALSE) {
[10:19:20.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.825]     }
[10:19:20.825]     ...future.result <- base::tryCatch({
[10:19:20.825]         base::withCallingHandlers({
[10:19:20.825]             ...future.value <- base::withVisible(base::local({
[10:19:20.825]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.825]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.825]                   ...future.globals.maxSize)) {
[10:19:20.825]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.825]                   on.exit(options(oopts), add = TRUE)
[10:19:20.825]                 }
[10:19:20.825]                 {
[10:19:20.825]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.825]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.825]                     USE.NAMES = FALSE)
[10:19:20.825]                   do.call(mapply, args = args)
[10:19:20.825]                 }
[10:19:20.825]             }))
[10:19:20.825]             future::FutureResult(value = ...future.value$value, 
[10:19:20.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.825]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.825]                     ...future.globalenv.names))
[10:19:20.825]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.825]         }, condition = base::local({
[10:19:20.825]             c <- base::c
[10:19:20.825]             inherits <- base::inherits
[10:19:20.825]             invokeRestart <- base::invokeRestart
[10:19:20.825]             length <- base::length
[10:19:20.825]             list <- base::list
[10:19:20.825]             seq.int <- base::seq.int
[10:19:20.825]             signalCondition <- base::signalCondition
[10:19:20.825]             sys.calls <- base::sys.calls
[10:19:20.825]             `[[` <- base::`[[`
[10:19:20.825]             `+` <- base::`+`
[10:19:20.825]             `<<-` <- base::`<<-`
[10:19:20.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.825]                   3L)]
[10:19:20.825]             }
[10:19:20.825]             function(cond) {
[10:19:20.825]                 is_error <- inherits(cond, "error")
[10:19:20.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.825]                   NULL)
[10:19:20.825]                 if (is_error) {
[10:19:20.825]                   sessionInformation <- function() {
[10:19:20.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.825]                       search = base::search(), system = base::Sys.info())
[10:19:20.825]                   }
[10:19:20.825]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.825]                     cond$call), session = sessionInformation(), 
[10:19:20.825]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.825]                   signalCondition(cond)
[10:19:20.825]                 }
[10:19:20.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.825]                 "immediateCondition"))) {
[10:19:20.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.825]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.825]                   if (TRUE && !signal) {
[10:19:20.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.825]                     {
[10:19:20.825]                       inherits <- base::inherits
[10:19:20.825]                       invokeRestart <- base::invokeRestart
[10:19:20.825]                       is.null <- base::is.null
[10:19:20.825]                       muffled <- FALSE
[10:19:20.825]                       if (inherits(cond, "message")) {
[10:19:20.825]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.825]                         if (muffled) 
[10:19:20.825]                           invokeRestart("muffleMessage")
[10:19:20.825]                       }
[10:19:20.825]                       else if (inherits(cond, "warning")) {
[10:19:20.825]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.825]                         if (muffled) 
[10:19:20.825]                           invokeRestart("muffleWarning")
[10:19:20.825]                       }
[10:19:20.825]                       else if (inherits(cond, "condition")) {
[10:19:20.825]                         if (!is.null(pattern)) {
[10:19:20.825]                           computeRestarts <- base::computeRestarts
[10:19:20.825]                           grepl <- base::grepl
[10:19:20.825]                           restarts <- computeRestarts(cond)
[10:19:20.825]                           for (restart in restarts) {
[10:19:20.825]                             name <- restart$name
[10:19:20.825]                             if (is.null(name)) 
[10:19:20.825]                               next
[10:19:20.825]                             if (!grepl(pattern, name)) 
[10:19:20.825]                               next
[10:19:20.825]                             invokeRestart(restart)
[10:19:20.825]                             muffled <- TRUE
[10:19:20.825]                             break
[10:19:20.825]                           }
[10:19:20.825]                         }
[10:19:20.825]                       }
[10:19:20.825]                       invisible(muffled)
[10:19:20.825]                     }
[10:19:20.825]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.825]                   }
[10:19:20.825]                 }
[10:19:20.825]                 else {
[10:19:20.825]                   if (TRUE) {
[10:19:20.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.825]                     {
[10:19:20.825]                       inherits <- base::inherits
[10:19:20.825]                       invokeRestart <- base::invokeRestart
[10:19:20.825]                       is.null <- base::is.null
[10:19:20.825]                       muffled <- FALSE
[10:19:20.825]                       if (inherits(cond, "message")) {
[10:19:20.825]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.825]                         if (muffled) 
[10:19:20.825]                           invokeRestart("muffleMessage")
[10:19:20.825]                       }
[10:19:20.825]                       else if (inherits(cond, "warning")) {
[10:19:20.825]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.825]                         if (muffled) 
[10:19:20.825]                           invokeRestart("muffleWarning")
[10:19:20.825]                       }
[10:19:20.825]                       else if (inherits(cond, "condition")) {
[10:19:20.825]                         if (!is.null(pattern)) {
[10:19:20.825]                           computeRestarts <- base::computeRestarts
[10:19:20.825]                           grepl <- base::grepl
[10:19:20.825]                           restarts <- computeRestarts(cond)
[10:19:20.825]                           for (restart in restarts) {
[10:19:20.825]                             name <- restart$name
[10:19:20.825]                             if (is.null(name)) 
[10:19:20.825]                               next
[10:19:20.825]                             if (!grepl(pattern, name)) 
[10:19:20.825]                               next
[10:19:20.825]                             invokeRestart(restart)
[10:19:20.825]                             muffled <- TRUE
[10:19:20.825]                             break
[10:19:20.825]                           }
[10:19:20.825]                         }
[10:19:20.825]                       }
[10:19:20.825]                       invisible(muffled)
[10:19:20.825]                     }
[10:19:20.825]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.825]                   }
[10:19:20.825]                 }
[10:19:20.825]             }
[10:19:20.825]         }))
[10:19:20.825]     }, error = function(ex) {
[10:19:20.825]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.825]                 ...future.rng), started = ...future.startTime, 
[10:19:20.825]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.825]             version = "1.8"), class = "FutureResult")
[10:19:20.825]     }, finally = {
[10:19:20.825]         if (!identical(...future.workdir, getwd())) 
[10:19:20.825]             setwd(...future.workdir)
[10:19:20.825]         {
[10:19:20.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.825]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.825]             }
[10:19:20.825]             base::options(...future.oldOptions)
[10:19:20.825]             if (.Platform$OS.type == "windows") {
[10:19:20.825]                 old_names <- names(...future.oldEnvVars)
[10:19:20.825]                 envs <- base::Sys.getenv()
[10:19:20.825]                 names <- names(envs)
[10:19:20.825]                 common <- intersect(names, old_names)
[10:19:20.825]                 added <- setdiff(names, old_names)
[10:19:20.825]                 removed <- setdiff(old_names, names)
[10:19:20.825]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.825]                   envs[common]]
[10:19:20.825]                 NAMES <- toupper(changed)
[10:19:20.825]                 args <- list()
[10:19:20.825]                 for (kk in seq_along(NAMES)) {
[10:19:20.825]                   name <- changed[[kk]]
[10:19:20.825]                   NAME <- NAMES[[kk]]
[10:19:20.825]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.825]                     next
[10:19:20.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.825]                 }
[10:19:20.825]                 NAMES <- toupper(added)
[10:19:20.825]                 for (kk in seq_along(NAMES)) {
[10:19:20.825]                   name <- added[[kk]]
[10:19:20.825]                   NAME <- NAMES[[kk]]
[10:19:20.825]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.825]                     next
[10:19:20.825]                   args[[name]] <- ""
[10:19:20.825]                 }
[10:19:20.825]                 NAMES <- toupper(removed)
[10:19:20.825]                 for (kk in seq_along(NAMES)) {
[10:19:20.825]                   name <- removed[[kk]]
[10:19:20.825]                   NAME <- NAMES[[kk]]
[10:19:20.825]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.825]                     next
[10:19:20.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.825]                 }
[10:19:20.825]                 if (length(args) > 0) 
[10:19:20.825]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.825]             }
[10:19:20.825]             else {
[10:19:20.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.825]             }
[10:19:20.825]             {
[10:19:20.825]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.825]                   0L) {
[10:19:20.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.825]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.825]                   base::options(opts)
[10:19:20.825]                 }
[10:19:20.825]                 {
[10:19:20.825]                   {
[10:19:20.825]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.825]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.825]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.825]                       inherits = FALSE)
[10:19:20.825]                     NULL
[10:19:20.825]                   }
[10:19:20.825]                   options(future.plan = NULL)
[10:19:20.825]                   if (is.na(NA_character_)) 
[10:19:20.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.825]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.825]                     .init = FALSE)
[10:19:20.825]                 }
[10:19:20.825]             }
[10:19:20.825]         }
[10:19:20.825]     })
[10:19:20.825]     if (TRUE) {
[10:19:20.825]         base::sink(type = "output", split = FALSE)
[10:19:20.825]         if (TRUE) {
[10:19:20.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.825]         }
[10:19:20.825]         else {
[10:19:20.825]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.825]         }
[10:19:20.825]         base::close(...future.stdout)
[10:19:20.825]         ...future.stdout <- NULL
[10:19:20.825]     }
[10:19:20.825]     ...future.result$conditions <- ...future.conditions
[10:19:20.825]     ...future.result$finished <- base::Sys.time()
[10:19:20.825]     ...future.result
[10:19:20.825] }
[10:19:20.827] assign_globals() ...
[10:19:20.827] List of 5
[10:19:20.827]  $ ...future.FUN            :function (C, k)  
[10:19:20.827]  $ MoreArgs                 : NULL
[10:19:20.827]  $ ...future.elements_ii    :List of 2
[10:19:20.827]   ..$ :List of 3
[10:19:20.827]   .. ..$ : chr "C"
[10:19:20.827]   .. ..$ : chr "B"
[10:19:20.827]   .. ..$ : chr "A"
[10:19:20.827]   ..$ :List of 3
[10:19:20.827]   .. ..$ : int 3
[10:19:20.827]   .. ..$ : int 4
[10:19:20.827]   .. ..$ : int 5
[10:19:20.827]  $ ...future.seeds_ii       : NULL
[10:19:20.827]  $ ...future.globals.maxSize: NULL
[10:19:20.827]  - attr(*, "where")=List of 5
[10:19:20.827]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.827]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.827]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.827]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.827]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.827]  - attr(*, "resolved")= logi FALSE
[10:19:20.827]  - attr(*, "total_size")= num 905
[10:19:20.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.827]  - attr(*, "already-done")= logi TRUE
[10:19:20.834] - reassign environment for ‘...future.FUN’
[10:19:20.834] - copied ‘...future.FUN’ to environment
[10:19:20.834] - copied ‘MoreArgs’ to environment
[10:19:20.834] - copied ‘...future.elements_ii’ to environment
[10:19:20.835] - copied ‘...future.seeds_ii’ to environment
[10:19:20.835] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.835] assign_globals() ... done
[10:19:20.835] plan(): Setting new future strategy stack:
[10:19:20.835] List of future strategies:
[10:19:20.835] 1. sequential:
[10:19:20.835]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.835]    - tweaked: FALSE
[10:19:20.835]    - call: NULL
[10:19:20.835] plan(): nbrOfWorkers() = 1
[10:19:20.836] plan(): Setting new future strategy stack:
[10:19:20.836] List of future strategies:
[10:19:20.836] 1. sequential:
[10:19:20.836]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.836]    - tweaked: FALSE
[10:19:20.836]    - call: plan(strategy)
[10:19:20.837] plan(): nbrOfWorkers() = 1
[10:19:20.837] SequentialFuture started (and completed)
[10:19:20.837] - Launch lazy future ... done
[10:19:20.837] run() for ‘SequentialFuture’ ... done
[10:19:20.837] Created future:
[10:19:20.837] SequentialFuture:
[10:19:20.837] Label: ‘future_mapply-2’
[10:19:20.837] Expression:
[10:19:20.837] {
[10:19:20.837]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.837]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.837]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.837]         on.exit(options(oopts), add = TRUE)
[10:19:20.837]     }
[10:19:20.837]     {
[10:19:20.837]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.837]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.837]         do.call(mapply, args = args)
[10:19:20.837]     }
[10:19:20.837] }
[10:19:20.837] Lazy evaluation: FALSE
[10:19:20.837] Asynchronous evaluation: FALSE
[10:19:20.837] Local evaluation: TRUE
[10:19:20.837] Environment: R_GlobalEnv
[10:19:20.837] Capture standard output: TRUE
[10:19:20.837] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.837] Globals: 5 objects totaling 905 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.837] Packages: <none>
[10:19:20.837] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.837] Resolved: TRUE
[10:19:20.837] Value: 91 bytes of class ‘list’
[10:19:20.837] Early signaling: FALSE
[10:19:20.837] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.837] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.838] Chunk #2 of 2 ... DONE
[10:19:20.838] Launching 2 futures (chunks) ... DONE
[10:19:20.838] Resolving 2 futures (chunks) ...
[10:19:20.838] resolve() on list ...
[10:19:20.838]  recursive: 0
[10:19:20.839]  length: 2
[10:19:20.839] 
[10:19:20.839] resolved() for ‘SequentialFuture’ ...
[10:19:20.839] - state: ‘finished’
[10:19:20.839] - run: TRUE
[10:19:20.839] - result: ‘FutureResult’
[10:19:20.839] resolved() for ‘SequentialFuture’ ... done
[10:19:20.839] Future #1
[10:19:20.839] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.839] - nx: 2
[10:19:20.839] - relay: TRUE
[10:19:20.840] - stdout: TRUE
[10:19:20.840] - signal: TRUE
[10:19:20.840] - resignal: FALSE
[10:19:20.840] - force: TRUE
[10:19:20.840] - relayed: [n=2] FALSE, FALSE
[10:19:20.840] - queued futures: [n=2] FALSE, FALSE
[10:19:20.840]  - until=1
[10:19:20.840]  - relaying element #1
[10:19:20.840] - relayed: [n=2] TRUE, FALSE
[10:19:20.840] - queued futures: [n=2] TRUE, FALSE
[10:19:20.840] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.841]  length: 1 (resolved future 1)
[10:19:20.841] resolved() for ‘SequentialFuture’ ...
[10:19:20.841] - state: ‘finished’
[10:19:20.841] - run: TRUE
[10:19:20.841] - result: ‘FutureResult’
[10:19:20.841] resolved() for ‘SequentialFuture’ ... done
[10:19:20.841] Future #2
[10:19:20.841] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:19:20.841] - nx: 2
[10:19:20.841] - relay: TRUE
[10:19:20.841] - stdout: TRUE
[10:19:20.842] - signal: TRUE
[10:19:20.842] - resignal: FALSE
[10:19:20.842] - force: TRUE
[10:19:20.842] - relayed: [n=2] TRUE, FALSE
[10:19:20.842] - queued futures: [n=2] TRUE, FALSE
[10:19:20.842]  - until=2
[10:19:20.842]  - relaying element #2
[10:19:20.842] - relayed: [n=2] TRUE, TRUE
[10:19:20.842] - queued futures: [n=2] TRUE, TRUE
[10:19:20.842] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:19:20.842]  length: 0 (resolved future 2)
[10:19:20.843] Relaying remaining futures
[10:19:20.843] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.843] - nx: 2
[10:19:20.843] - relay: TRUE
[10:19:20.843] - stdout: TRUE
[10:19:20.843] - signal: TRUE
[10:19:20.843] - resignal: FALSE
[10:19:20.843] - force: TRUE
[10:19:20.843] - relayed: [n=2] TRUE, TRUE
[10:19:20.843] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:20.843] - relayed: [n=2] TRUE, TRUE
[10:19:20.843] - queued futures: [n=2] TRUE, TRUE
[10:19:20.844] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.844] resolve() on list ... DONE
[10:19:20.844]  - Number of value chunks collected: 2
[10:19:20.844] Resolving 2 futures (chunks) ... DONE
[10:19:20.844] Reducing values from 2 chunks ...
[10:19:20.844]  - Number of values collected after concatenation: 5
[10:19:20.844]  - Number of values expected: 5
[10:19:20.844] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:19:20.844] Reducing values from 2 chunks ... DONE
[10:19:20.844] future_mapply() ... DONE
[10:19:20.845] future_mapply() ...
[10:19:20.845] Number of chunks: 1
[10:19:20.845] getGlobalsAndPackagesXApply() ...
[10:19:20.845]  - future.globals: TRUE
[10:19:20.845] getGlobalsAndPackages() ...
[10:19:20.845] Searching for globals...
[10:19:20.846] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:20.846] Searching for globals ... DONE
[10:19:20.847] Resolving globals: FALSE
[10:19:20.847] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:20.847] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:20.847] - globals: [1] ‘FUN’
[10:19:20.847] 
[10:19:20.848] getGlobalsAndPackages() ... DONE
[10:19:20.848]  - globals found/used: [n=1] ‘FUN’
[10:19:20.848]  - needed namespaces: [n=0] 
[10:19:20.848] Finding globals ... DONE
[10:19:20.848] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.848] List of 2
[10:19:20.848]  $ ...future.FUN:function (C, k)  
[10:19:20.848]  $ MoreArgs     : list()
[10:19:20.848]  - attr(*, "where")=List of 2
[10:19:20.848]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.848]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.848]  - attr(*, "resolved")= logi FALSE
[10:19:20.848]  - attr(*, "total_size")= num NA
[10:19:20.850] Packages to be attached in all futures: [n=0] 
[10:19:20.851] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.851] Number of futures (= number of chunks): 1
[10:19:20.851] Launching 1 futures (chunks) ...
[10:19:20.851] Chunk #1 of 1 ...
[10:19:20.851]  - Finding globals in '...' for chunk #1 ...
[10:19:20.851] getGlobalsAndPackages() ...
[10:19:20.851] Searching for globals...
[10:19:20.853] 
[10:19:20.853] Searching for globals ... DONE
[10:19:20.853] - globals: [0] <none>
[10:19:20.853] getGlobalsAndPackages() ... DONE
[10:19:20.853]    + additional globals found: [n=0] 
[10:19:20.854]    + additional namespaces needed: [n=0] 
[10:19:20.854]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.854]  - seeds: <none>
[10:19:20.854]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.854] getGlobalsAndPackages() ...
[10:19:20.854] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.854] Resolving globals: FALSE
[10:19:20.855] The total size of the 5 globals is 967 bytes (967 bytes)
[10:19:20.855] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 967 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (192 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:20.855] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.855] 
[10:19:20.855] getGlobalsAndPackages() ... DONE
[10:19:20.856] run() for ‘Future’ ...
[10:19:20.856] - state: ‘created’
[10:19:20.856] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.856] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.856] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.856]   - Field: ‘label’
[10:19:20.856]   - Field: ‘local’
[10:19:20.857]   - Field: ‘owner’
[10:19:20.857]   - Field: ‘envir’
[10:19:20.857]   - Field: ‘packages’
[10:19:20.857]   - Field: ‘gc’
[10:19:20.857]   - Field: ‘conditions’
[10:19:20.857]   - Field: ‘expr’
[10:19:20.857]   - Field: ‘uuid’
[10:19:20.857]   - Field: ‘seed’
[10:19:20.857]   - Field: ‘version’
[10:19:20.857]   - Field: ‘result’
[10:19:20.857]   - Field: ‘asynchronous’
[10:19:20.858]   - Field: ‘calls’
[10:19:20.858]   - Field: ‘globals’
[10:19:20.858]   - Field: ‘stdout’
[10:19:20.858]   - Field: ‘earlySignal’
[10:19:20.858]   - Field: ‘lazy’
[10:19:20.858]   - Field: ‘state’
[10:19:20.858] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.858] - Launch lazy future ...
[10:19:20.858] Packages needed by the future expression (n = 0): <none>
[10:19:20.858] Packages needed by future strategies (n = 0): <none>
[10:19:20.859] {
[10:19:20.859]     {
[10:19:20.859]         {
[10:19:20.859]             ...future.startTime <- base::Sys.time()
[10:19:20.859]             {
[10:19:20.859]                 {
[10:19:20.859]                   {
[10:19:20.859]                     base::local({
[10:19:20.859]                       has_future <- base::requireNamespace("future", 
[10:19:20.859]                         quietly = TRUE)
[10:19:20.859]                       if (has_future) {
[10:19:20.859]                         ns <- base::getNamespace("future")
[10:19:20.859]                         version <- ns[[".package"]][["version"]]
[10:19:20.859]                         if (is.null(version)) 
[10:19:20.859]                           version <- utils::packageVersion("future")
[10:19:20.859]                       }
[10:19:20.859]                       else {
[10:19:20.859]                         version <- NULL
[10:19:20.859]                       }
[10:19:20.859]                       if (!has_future || version < "1.8.0") {
[10:19:20.859]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.859]                           "", base::R.version$version.string), 
[10:19:20.859]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.859]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.859]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.859]                             "release", "version")], collapse = " "), 
[10:19:20.859]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.859]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.859]                           info)
[10:19:20.859]                         info <- base::paste(info, collapse = "; ")
[10:19:20.859]                         if (!has_future) {
[10:19:20.859]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.859]                             info)
[10:19:20.859]                         }
[10:19:20.859]                         else {
[10:19:20.859]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.859]                             info, version)
[10:19:20.859]                         }
[10:19:20.859]                         base::stop(msg)
[10:19:20.859]                       }
[10:19:20.859]                     })
[10:19:20.859]                   }
[10:19:20.859]                   ...future.strategy.old <- future::plan("list")
[10:19:20.859]                   options(future.plan = NULL)
[10:19:20.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.859]                 }
[10:19:20.859]                 ...future.workdir <- getwd()
[10:19:20.859]             }
[10:19:20.859]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.859]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.859]         }
[10:19:20.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.859]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.859]             base::names(...future.oldOptions))
[10:19:20.859]     }
[10:19:20.859]     if (FALSE) {
[10:19:20.859]     }
[10:19:20.859]     else {
[10:19:20.859]         if (TRUE) {
[10:19:20.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.859]                 open = "w")
[10:19:20.859]         }
[10:19:20.859]         else {
[10:19:20.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.859]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.859]         }
[10:19:20.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.859]             base::sink(type = "output", split = FALSE)
[10:19:20.859]             base::close(...future.stdout)
[10:19:20.859]         }, add = TRUE)
[10:19:20.859]     }
[10:19:20.859]     ...future.frame <- base::sys.nframe()
[10:19:20.859]     ...future.conditions <- base::list()
[10:19:20.859]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.859]     if (FALSE) {
[10:19:20.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.859]     }
[10:19:20.859]     ...future.result <- base::tryCatch({
[10:19:20.859]         base::withCallingHandlers({
[10:19:20.859]             ...future.value <- base::withVisible(base::local({
[10:19:20.859]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.859]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.859]                   ...future.globals.maxSize)) {
[10:19:20.859]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.859]                   on.exit(options(oopts), add = TRUE)
[10:19:20.859]                 }
[10:19:20.859]                 {
[10:19:20.859]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.859]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.859]                     USE.NAMES = FALSE)
[10:19:20.859]                   do.call(mapply, args = args)
[10:19:20.859]                 }
[10:19:20.859]             }))
[10:19:20.859]             future::FutureResult(value = ...future.value$value, 
[10:19:20.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.859]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.859]                     ...future.globalenv.names))
[10:19:20.859]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.859]         }, condition = base::local({
[10:19:20.859]             c <- base::c
[10:19:20.859]             inherits <- base::inherits
[10:19:20.859]             invokeRestart <- base::invokeRestart
[10:19:20.859]             length <- base::length
[10:19:20.859]             list <- base::list
[10:19:20.859]             seq.int <- base::seq.int
[10:19:20.859]             signalCondition <- base::signalCondition
[10:19:20.859]             sys.calls <- base::sys.calls
[10:19:20.859]             `[[` <- base::`[[`
[10:19:20.859]             `+` <- base::`+`
[10:19:20.859]             `<<-` <- base::`<<-`
[10:19:20.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.859]                   3L)]
[10:19:20.859]             }
[10:19:20.859]             function(cond) {
[10:19:20.859]                 is_error <- inherits(cond, "error")
[10:19:20.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.859]                   NULL)
[10:19:20.859]                 if (is_error) {
[10:19:20.859]                   sessionInformation <- function() {
[10:19:20.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.859]                       search = base::search(), system = base::Sys.info())
[10:19:20.859]                   }
[10:19:20.859]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.859]                     cond$call), session = sessionInformation(), 
[10:19:20.859]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.859]                   signalCondition(cond)
[10:19:20.859]                 }
[10:19:20.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.859]                 "immediateCondition"))) {
[10:19:20.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.859]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.859]                   if (TRUE && !signal) {
[10:19:20.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.859]                     {
[10:19:20.859]                       inherits <- base::inherits
[10:19:20.859]                       invokeRestart <- base::invokeRestart
[10:19:20.859]                       is.null <- base::is.null
[10:19:20.859]                       muffled <- FALSE
[10:19:20.859]                       if (inherits(cond, "message")) {
[10:19:20.859]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.859]                         if (muffled) 
[10:19:20.859]                           invokeRestart("muffleMessage")
[10:19:20.859]                       }
[10:19:20.859]                       else if (inherits(cond, "warning")) {
[10:19:20.859]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.859]                         if (muffled) 
[10:19:20.859]                           invokeRestart("muffleWarning")
[10:19:20.859]                       }
[10:19:20.859]                       else if (inherits(cond, "condition")) {
[10:19:20.859]                         if (!is.null(pattern)) {
[10:19:20.859]                           computeRestarts <- base::computeRestarts
[10:19:20.859]                           grepl <- base::grepl
[10:19:20.859]                           restarts <- computeRestarts(cond)
[10:19:20.859]                           for (restart in restarts) {
[10:19:20.859]                             name <- restart$name
[10:19:20.859]                             if (is.null(name)) 
[10:19:20.859]                               next
[10:19:20.859]                             if (!grepl(pattern, name)) 
[10:19:20.859]                               next
[10:19:20.859]                             invokeRestart(restart)
[10:19:20.859]                             muffled <- TRUE
[10:19:20.859]                             break
[10:19:20.859]                           }
[10:19:20.859]                         }
[10:19:20.859]                       }
[10:19:20.859]                       invisible(muffled)
[10:19:20.859]                     }
[10:19:20.859]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.859]                   }
[10:19:20.859]                 }
[10:19:20.859]                 else {
[10:19:20.859]                   if (TRUE) {
[10:19:20.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.859]                     {
[10:19:20.859]                       inherits <- base::inherits
[10:19:20.859]                       invokeRestart <- base::invokeRestart
[10:19:20.859]                       is.null <- base::is.null
[10:19:20.859]                       muffled <- FALSE
[10:19:20.859]                       if (inherits(cond, "message")) {
[10:19:20.859]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.859]                         if (muffled) 
[10:19:20.859]                           invokeRestart("muffleMessage")
[10:19:20.859]                       }
[10:19:20.859]                       else if (inherits(cond, "warning")) {
[10:19:20.859]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.859]                         if (muffled) 
[10:19:20.859]                           invokeRestart("muffleWarning")
[10:19:20.859]                       }
[10:19:20.859]                       else if (inherits(cond, "condition")) {
[10:19:20.859]                         if (!is.null(pattern)) {
[10:19:20.859]                           computeRestarts <- base::computeRestarts
[10:19:20.859]                           grepl <- base::grepl
[10:19:20.859]                           restarts <- computeRestarts(cond)
[10:19:20.859]                           for (restart in restarts) {
[10:19:20.859]                             name <- restart$name
[10:19:20.859]                             if (is.null(name)) 
[10:19:20.859]                               next
[10:19:20.859]                             if (!grepl(pattern, name)) 
[10:19:20.859]                               next
[10:19:20.859]                             invokeRestart(restart)
[10:19:20.859]                             muffled <- TRUE
[10:19:20.859]                             break
[10:19:20.859]                           }
[10:19:20.859]                         }
[10:19:20.859]                       }
[10:19:20.859]                       invisible(muffled)
[10:19:20.859]                     }
[10:19:20.859]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.859]                   }
[10:19:20.859]                 }
[10:19:20.859]             }
[10:19:20.859]         }))
[10:19:20.859]     }, error = function(ex) {
[10:19:20.859]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.859]                 ...future.rng), started = ...future.startTime, 
[10:19:20.859]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.859]             version = "1.8"), class = "FutureResult")
[10:19:20.859]     }, finally = {
[10:19:20.859]         if (!identical(...future.workdir, getwd())) 
[10:19:20.859]             setwd(...future.workdir)
[10:19:20.859]         {
[10:19:20.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.859]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.859]             }
[10:19:20.859]             base::options(...future.oldOptions)
[10:19:20.859]             if (.Platform$OS.type == "windows") {
[10:19:20.859]                 old_names <- names(...future.oldEnvVars)
[10:19:20.859]                 envs <- base::Sys.getenv()
[10:19:20.859]                 names <- names(envs)
[10:19:20.859]                 common <- intersect(names, old_names)
[10:19:20.859]                 added <- setdiff(names, old_names)
[10:19:20.859]                 removed <- setdiff(old_names, names)
[10:19:20.859]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.859]                   envs[common]]
[10:19:20.859]                 NAMES <- toupper(changed)
[10:19:20.859]                 args <- list()
[10:19:20.859]                 for (kk in seq_along(NAMES)) {
[10:19:20.859]                   name <- changed[[kk]]
[10:19:20.859]                   NAME <- NAMES[[kk]]
[10:19:20.859]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.859]                     next
[10:19:20.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.859]                 }
[10:19:20.859]                 NAMES <- toupper(added)
[10:19:20.859]                 for (kk in seq_along(NAMES)) {
[10:19:20.859]                   name <- added[[kk]]
[10:19:20.859]                   NAME <- NAMES[[kk]]
[10:19:20.859]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.859]                     next
[10:19:20.859]                   args[[name]] <- ""
[10:19:20.859]                 }
[10:19:20.859]                 NAMES <- toupper(removed)
[10:19:20.859]                 for (kk in seq_along(NAMES)) {
[10:19:20.859]                   name <- removed[[kk]]
[10:19:20.859]                   NAME <- NAMES[[kk]]
[10:19:20.859]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.859]                     next
[10:19:20.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.859]                 }
[10:19:20.859]                 if (length(args) > 0) 
[10:19:20.859]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.859]             }
[10:19:20.859]             else {
[10:19:20.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.859]             }
[10:19:20.859]             {
[10:19:20.859]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.859]                   0L) {
[10:19:20.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.859]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.859]                   base::options(opts)
[10:19:20.859]                 }
[10:19:20.859]                 {
[10:19:20.859]                   {
[10:19:20.859]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.859]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.859]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.859]                       inherits = FALSE)
[10:19:20.859]                     NULL
[10:19:20.859]                   }
[10:19:20.859]                   options(future.plan = NULL)
[10:19:20.859]                   if (is.na(NA_character_)) 
[10:19:20.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.859]                     .init = FALSE)
[10:19:20.859]                 }
[10:19:20.859]             }
[10:19:20.859]         }
[10:19:20.859]     })
[10:19:20.859]     if (TRUE) {
[10:19:20.859]         base::sink(type = "output", split = FALSE)
[10:19:20.859]         if (TRUE) {
[10:19:20.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.859]         }
[10:19:20.859]         else {
[10:19:20.859]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.859]         }
[10:19:20.859]         base::close(...future.stdout)
[10:19:20.859]         ...future.stdout <- NULL
[10:19:20.859]     }
[10:19:20.859]     ...future.result$conditions <- ...future.conditions
[10:19:20.859]     ...future.result$finished <- base::Sys.time()
[10:19:20.859]     ...future.result
[10:19:20.859] }
[10:19:20.861] assign_globals() ...
[10:19:20.861] List of 5
[10:19:20.861]  $ ...future.FUN            :function (C, k)  
[10:19:20.861]  $ MoreArgs                 : list()
[10:19:20.861]  $ ...future.elements_ii    :List of 2
[10:19:20.861]   ..$ :List of 5
[10:19:20.861]   .. ..$ : chr "A"
[10:19:20.861]   .. ..$ : chr "B"
[10:19:20.861]   .. ..$ : chr "C"
[10:19:20.861]   .. ..$ : chr "D"
[10:19:20.861]   .. ..$ : chr "E"
[10:19:20.861]   ..$ :List of 5
[10:19:20.861]   .. ..$ : int 5
[10:19:20.861]   .. ..$ : int 4
[10:19:20.861]   .. ..$ : int 3
[10:19:20.861]   .. ..$ : int 2
[10:19:20.861]   .. ..$ : int 1
[10:19:20.861]  $ ...future.seeds_ii       : NULL
[10:19:20.861]  $ ...future.globals.maxSize: NULL
[10:19:20.861]  - attr(*, "where")=List of 5
[10:19:20.861]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.861]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.861]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.861]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.861]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.861]  - attr(*, "resolved")= logi FALSE
[10:19:20.861]  - attr(*, "total_size")= num 967
[10:19:20.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.861]  - attr(*, "already-done")= logi TRUE
[10:19:20.867] - reassign environment for ‘...future.FUN’
[10:19:20.867] - copied ‘...future.FUN’ to environment
[10:19:20.868] - copied ‘MoreArgs’ to environment
[10:19:20.868] - copied ‘...future.elements_ii’ to environment
[10:19:20.868] - copied ‘...future.seeds_ii’ to environment
[10:19:20.868] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.868] assign_globals() ... done
[10:19:20.868] plan(): Setting new future strategy stack:
[10:19:20.868] List of future strategies:
[10:19:20.868] 1. sequential:
[10:19:20.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.868]    - tweaked: FALSE
[10:19:20.868]    - call: NULL
[10:19:20.869] plan(): nbrOfWorkers() = 1
[10:19:20.869] plan(): Setting new future strategy stack:
[10:19:20.869] List of future strategies:
[10:19:20.869] 1. sequential:
[10:19:20.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.869]    - tweaked: FALSE
[10:19:20.869]    - call: plan(strategy)
[10:19:20.870] plan(): nbrOfWorkers() = 1
[10:19:20.870] SequentialFuture started (and completed)
[10:19:20.870] - Launch lazy future ... done
[10:19:20.870] run() for ‘SequentialFuture’ ... done
[10:19:20.870] Created future:
[10:19:20.870] SequentialFuture:
[10:19:20.870] Label: ‘future_.mapply-1’
[10:19:20.870] Expression:
[10:19:20.870] {
[10:19:20.870]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.870]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.870]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.870]         on.exit(options(oopts), add = TRUE)
[10:19:20.870]     }
[10:19:20.870]     {
[10:19:20.870]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.870]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.870]         do.call(mapply, args = args)
[10:19:20.870]     }
[10:19:20.870] }
[10:19:20.870] Lazy evaluation: FALSE
[10:19:20.870] Asynchronous evaluation: FALSE
[10:19:20.870] Local evaluation: TRUE
[10:19:20.870] Environment: R_GlobalEnv
[10:19:20.870] Capture standard output: TRUE
[10:19:20.870] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.870] Globals: 5 objects totaling 967 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.870] Packages: <none>
[10:19:20.870] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.870] Resolved: TRUE
[10:19:20.870] Value: 126 bytes of class ‘list’
[10:19:20.870] Early signaling: FALSE
[10:19:20.870] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.870] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.871] Chunk #1 of 1 ... DONE
[10:19:20.871] Launching 1 futures (chunks) ... DONE
[10:19:20.871] Resolving 1 futures (chunks) ...
[10:19:20.871] resolve() on list ...
[10:19:20.871]  recursive: 0
[10:19:20.872]  length: 1
[10:19:20.872] 
[10:19:20.872] resolved() for ‘SequentialFuture’ ...
[10:19:20.872] - state: ‘finished’
[10:19:20.872] - run: TRUE
[10:19:20.872] - result: ‘FutureResult’
[10:19:20.872] resolved() for ‘SequentialFuture’ ... done
[10:19:20.872] Future #1
[10:19:20.872] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.872] - nx: 1
[10:19:20.872] - relay: TRUE
[10:19:20.873] - stdout: TRUE
[10:19:20.873] - signal: TRUE
[10:19:20.873] - resignal: FALSE
[10:19:20.873] - force: TRUE
[10:19:20.873] - relayed: [n=1] FALSE
[10:19:20.873] - queued futures: [n=1] FALSE
[10:19:20.873]  - until=1
[10:19:20.873]  - relaying element #1
[10:19:20.873] - relayed: [n=1] TRUE
[10:19:20.873] - queued futures: [n=1] TRUE
[10:19:20.873] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.874]  length: 0 (resolved future 1)
[10:19:20.874] Relaying remaining futures
[10:19:20.874] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.874] - nx: 1
[10:19:20.874] - relay: TRUE
[10:19:20.874] - stdout: TRUE
[10:19:20.874] - signal: TRUE
[10:19:20.874] - resignal: FALSE
[10:19:20.874] - force: TRUE
[10:19:20.874] - relayed: [n=1] TRUE
[10:19:20.874] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.874] - relayed: [n=1] TRUE
[10:19:20.875] - queued futures: [n=1] TRUE
[10:19:20.875] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.875] resolve() on list ... DONE
[10:19:20.876]  - Number of value chunks collected: 1
[10:19:20.876] Resolving 1 futures (chunks) ... DONE
[10:19:20.877] Reducing values from 1 chunks ...
[10:19:20.877]  - Number of values collected after concatenation: 5
[10:19:20.877]  - Number of values expected: 5
[10:19:20.877] Reducing values from 1 chunks ... DONE
[10:19:20.877] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[10:19:20.877] future_mapply() ...
[10:19:20.878] Number of chunks: 1
[10:19:20.878] getGlobalsAndPackagesXApply() ...
[10:19:20.878]  - future.globals: TRUE
[10:19:20.878] getGlobalsAndPackages() ...
[10:19:20.878] Searching for globals...
[10:19:20.879] - globals found: [1] ‘FUN’
[10:19:20.879] Searching for globals ... DONE
[10:19:20.879] Resolving globals: FALSE
[10:19:20.879] The total size of the 1 globals is 185 bytes (185 bytes)
[10:19:20.880] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:19:20.880] - globals: [1] ‘FUN’
[10:19:20.880] 
[10:19:20.880] getGlobalsAndPackages() ... DONE
[10:19:20.880]  - globals found/used: [n=1] ‘FUN’
[10:19:20.880]  - needed namespaces: [n=0] 
[10:19:20.880] Finding globals ... DONE
[10:19:20.880] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.881] List of 2
[10:19:20.881]  $ ...future.FUN:function (x)  
[10:19:20.881]  $ MoreArgs     : NULL
[10:19:20.881]  - attr(*, "where")=List of 2
[10:19:20.881]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.881]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.881]  - attr(*, "resolved")= logi FALSE
[10:19:20.881]  - attr(*, "total_size")= num NA
[10:19:20.883] Packages to be attached in all futures: [n=0] 
[10:19:20.883] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.883] Number of futures (= number of chunks): 1
[10:19:20.883] Launching 1 futures (chunks) ...
[10:19:20.883] Chunk #1 of 1 ...
[10:19:20.884]  - Finding globals in '...' for chunk #1 ...
[10:19:20.884] getGlobalsAndPackages() ...
[10:19:20.884] Searching for globals...
[10:19:20.884] 
[10:19:20.884] Searching for globals ... DONE
[10:19:20.884] - globals: [0] <none>
[10:19:20.884] getGlobalsAndPackages() ... DONE
[10:19:20.884]    + additional globals found: [n=0] 
[10:19:20.884]    + additional namespaces needed: [n=0] 
[10:19:20.884]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.885]  - seeds: <none>
[10:19:20.885]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.885] getGlobalsAndPackages() ...
[10:19:20.885] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.885] Resolving globals: FALSE
[10:19:20.885] The total size of the 5 globals is 366 bytes (366 bytes)
[10:19:20.886] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 366 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:20.886] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.886] 
[10:19:20.886] getGlobalsAndPackages() ... DONE
[10:19:20.886] run() for ‘Future’ ...
[10:19:20.886] - state: ‘created’
[10:19:20.886] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.887] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.887]   - Field: ‘label’
[10:19:20.887]   - Field: ‘local’
[10:19:20.887]   - Field: ‘owner’
[10:19:20.887]   - Field: ‘envir’
[10:19:20.887]   - Field: ‘packages’
[10:19:20.887]   - Field: ‘gc’
[10:19:20.887]   - Field: ‘conditions’
[10:19:20.887]   - Field: ‘expr’
[10:19:20.888]   - Field: ‘uuid’
[10:19:20.888]   - Field: ‘seed’
[10:19:20.888]   - Field: ‘version’
[10:19:20.888]   - Field: ‘result’
[10:19:20.888]   - Field: ‘asynchronous’
[10:19:20.888]   - Field: ‘calls’
[10:19:20.888]   - Field: ‘globals’
[10:19:20.888]   - Field: ‘stdout’
[10:19:20.888]   - Field: ‘earlySignal’
[10:19:20.888]   - Field: ‘lazy’
[10:19:20.888]   - Field: ‘state’
[10:19:20.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.889] - Launch lazy future ...
[10:19:20.889] Packages needed by the future expression (n = 0): <none>
[10:19:20.889] Packages needed by future strategies (n = 0): <none>
[10:19:20.889] {
[10:19:20.889]     {
[10:19:20.889]         {
[10:19:20.889]             ...future.startTime <- base::Sys.time()
[10:19:20.889]             {
[10:19:20.889]                 {
[10:19:20.889]                   {
[10:19:20.889]                     base::local({
[10:19:20.889]                       has_future <- base::requireNamespace("future", 
[10:19:20.889]                         quietly = TRUE)
[10:19:20.889]                       if (has_future) {
[10:19:20.889]                         ns <- base::getNamespace("future")
[10:19:20.889]                         version <- ns[[".package"]][["version"]]
[10:19:20.889]                         if (is.null(version)) 
[10:19:20.889]                           version <- utils::packageVersion("future")
[10:19:20.889]                       }
[10:19:20.889]                       else {
[10:19:20.889]                         version <- NULL
[10:19:20.889]                       }
[10:19:20.889]                       if (!has_future || version < "1.8.0") {
[10:19:20.889]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.889]                           "", base::R.version$version.string), 
[10:19:20.889]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.889]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.889]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.889]                             "release", "version")], collapse = " "), 
[10:19:20.889]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.889]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.889]                           info)
[10:19:20.889]                         info <- base::paste(info, collapse = "; ")
[10:19:20.889]                         if (!has_future) {
[10:19:20.889]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.889]                             info)
[10:19:20.889]                         }
[10:19:20.889]                         else {
[10:19:20.889]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.889]                             info, version)
[10:19:20.889]                         }
[10:19:20.889]                         base::stop(msg)
[10:19:20.889]                       }
[10:19:20.889]                     })
[10:19:20.889]                   }
[10:19:20.889]                   ...future.strategy.old <- future::plan("list")
[10:19:20.889]                   options(future.plan = NULL)
[10:19:20.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.889]                 }
[10:19:20.889]                 ...future.workdir <- getwd()
[10:19:20.889]             }
[10:19:20.889]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.889]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.889]         }
[10:19:20.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.889]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.889]             base::names(...future.oldOptions))
[10:19:20.889]     }
[10:19:20.889]     if (FALSE) {
[10:19:20.889]     }
[10:19:20.889]     else {
[10:19:20.889]         if (TRUE) {
[10:19:20.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.889]                 open = "w")
[10:19:20.889]         }
[10:19:20.889]         else {
[10:19:20.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.889]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.889]         }
[10:19:20.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.889]             base::sink(type = "output", split = FALSE)
[10:19:20.889]             base::close(...future.stdout)
[10:19:20.889]         }, add = TRUE)
[10:19:20.889]     }
[10:19:20.889]     ...future.frame <- base::sys.nframe()
[10:19:20.889]     ...future.conditions <- base::list()
[10:19:20.889]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.889]     if (FALSE) {
[10:19:20.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.889]     }
[10:19:20.889]     ...future.result <- base::tryCatch({
[10:19:20.889]         base::withCallingHandlers({
[10:19:20.889]             ...future.value <- base::withVisible(base::local({
[10:19:20.889]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.889]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.889]                   ...future.globals.maxSize)) {
[10:19:20.889]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.889]                   on.exit(options(oopts), add = TRUE)
[10:19:20.889]                 }
[10:19:20.889]                 {
[10:19:20.889]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.889]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.889]                     USE.NAMES = FALSE)
[10:19:20.889]                   do.call(mapply, args = args)
[10:19:20.889]                 }
[10:19:20.889]             }))
[10:19:20.889]             future::FutureResult(value = ...future.value$value, 
[10:19:20.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.889]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.889]                     ...future.globalenv.names))
[10:19:20.889]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.889]         }, condition = base::local({
[10:19:20.889]             c <- base::c
[10:19:20.889]             inherits <- base::inherits
[10:19:20.889]             invokeRestart <- base::invokeRestart
[10:19:20.889]             length <- base::length
[10:19:20.889]             list <- base::list
[10:19:20.889]             seq.int <- base::seq.int
[10:19:20.889]             signalCondition <- base::signalCondition
[10:19:20.889]             sys.calls <- base::sys.calls
[10:19:20.889]             `[[` <- base::`[[`
[10:19:20.889]             `+` <- base::`+`
[10:19:20.889]             `<<-` <- base::`<<-`
[10:19:20.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.889]                   3L)]
[10:19:20.889]             }
[10:19:20.889]             function(cond) {
[10:19:20.889]                 is_error <- inherits(cond, "error")
[10:19:20.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.889]                   NULL)
[10:19:20.889]                 if (is_error) {
[10:19:20.889]                   sessionInformation <- function() {
[10:19:20.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.889]                       search = base::search(), system = base::Sys.info())
[10:19:20.889]                   }
[10:19:20.889]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.889]                     cond$call), session = sessionInformation(), 
[10:19:20.889]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.889]                   signalCondition(cond)
[10:19:20.889]                 }
[10:19:20.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.889]                 "immediateCondition"))) {
[10:19:20.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.889]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.889]                   if (TRUE && !signal) {
[10:19:20.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.889]                     {
[10:19:20.889]                       inherits <- base::inherits
[10:19:20.889]                       invokeRestart <- base::invokeRestart
[10:19:20.889]                       is.null <- base::is.null
[10:19:20.889]                       muffled <- FALSE
[10:19:20.889]                       if (inherits(cond, "message")) {
[10:19:20.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.889]                         if (muffled) 
[10:19:20.889]                           invokeRestart("muffleMessage")
[10:19:20.889]                       }
[10:19:20.889]                       else if (inherits(cond, "warning")) {
[10:19:20.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.889]                         if (muffled) 
[10:19:20.889]                           invokeRestart("muffleWarning")
[10:19:20.889]                       }
[10:19:20.889]                       else if (inherits(cond, "condition")) {
[10:19:20.889]                         if (!is.null(pattern)) {
[10:19:20.889]                           computeRestarts <- base::computeRestarts
[10:19:20.889]                           grepl <- base::grepl
[10:19:20.889]                           restarts <- computeRestarts(cond)
[10:19:20.889]                           for (restart in restarts) {
[10:19:20.889]                             name <- restart$name
[10:19:20.889]                             if (is.null(name)) 
[10:19:20.889]                               next
[10:19:20.889]                             if (!grepl(pattern, name)) 
[10:19:20.889]                               next
[10:19:20.889]                             invokeRestart(restart)
[10:19:20.889]                             muffled <- TRUE
[10:19:20.889]                             break
[10:19:20.889]                           }
[10:19:20.889]                         }
[10:19:20.889]                       }
[10:19:20.889]                       invisible(muffled)
[10:19:20.889]                     }
[10:19:20.889]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.889]                   }
[10:19:20.889]                 }
[10:19:20.889]                 else {
[10:19:20.889]                   if (TRUE) {
[10:19:20.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.889]                     {
[10:19:20.889]                       inherits <- base::inherits
[10:19:20.889]                       invokeRestart <- base::invokeRestart
[10:19:20.889]                       is.null <- base::is.null
[10:19:20.889]                       muffled <- FALSE
[10:19:20.889]                       if (inherits(cond, "message")) {
[10:19:20.889]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.889]                         if (muffled) 
[10:19:20.889]                           invokeRestart("muffleMessage")
[10:19:20.889]                       }
[10:19:20.889]                       else if (inherits(cond, "warning")) {
[10:19:20.889]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.889]                         if (muffled) 
[10:19:20.889]                           invokeRestart("muffleWarning")
[10:19:20.889]                       }
[10:19:20.889]                       else if (inherits(cond, "condition")) {
[10:19:20.889]                         if (!is.null(pattern)) {
[10:19:20.889]                           computeRestarts <- base::computeRestarts
[10:19:20.889]                           grepl <- base::grepl
[10:19:20.889]                           restarts <- computeRestarts(cond)
[10:19:20.889]                           for (restart in restarts) {
[10:19:20.889]                             name <- restart$name
[10:19:20.889]                             if (is.null(name)) 
[10:19:20.889]                               next
[10:19:20.889]                             if (!grepl(pattern, name)) 
[10:19:20.889]                               next
[10:19:20.889]                             invokeRestart(restart)
[10:19:20.889]                             muffled <- TRUE
[10:19:20.889]                             break
[10:19:20.889]                           }
[10:19:20.889]                         }
[10:19:20.889]                       }
[10:19:20.889]                       invisible(muffled)
[10:19:20.889]                     }
[10:19:20.889]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.889]                   }
[10:19:20.889]                 }
[10:19:20.889]             }
[10:19:20.889]         }))
[10:19:20.889]     }, error = function(ex) {
[10:19:20.889]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.889]                 ...future.rng), started = ...future.startTime, 
[10:19:20.889]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.889]             version = "1.8"), class = "FutureResult")
[10:19:20.889]     }, finally = {
[10:19:20.889]         if (!identical(...future.workdir, getwd())) 
[10:19:20.889]             setwd(...future.workdir)
[10:19:20.889]         {
[10:19:20.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.889]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.889]             }
[10:19:20.889]             base::options(...future.oldOptions)
[10:19:20.889]             if (.Platform$OS.type == "windows") {
[10:19:20.889]                 old_names <- names(...future.oldEnvVars)
[10:19:20.889]                 envs <- base::Sys.getenv()
[10:19:20.889]                 names <- names(envs)
[10:19:20.889]                 common <- intersect(names, old_names)
[10:19:20.889]                 added <- setdiff(names, old_names)
[10:19:20.889]                 removed <- setdiff(old_names, names)
[10:19:20.889]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.889]                   envs[common]]
[10:19:20.889]                 NAMES <- toupper(changed)
[10:19:20.889]                 args <- list()
[10:19:20.889]                 for (kk in seq_along(NAMES)) {
[10:19:20.889]                   name <- changed[[kk]]
[10:19:20.889]                   NAME <- NAMES[[kk]]
[10:19:20.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.889]                     next
[10:19:20.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.889]                 }
[10:19:20.889]                 NAMES <- toupper(added)
[10:19:20.889]                 for (kk in seq_along(NAMES)) {
[10:19:20.889]                   name <- added[[kk]]
[10:19:20.889]                   NAME <- NAMES[[kk]]
[10:19:20.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.889]                     next
[10:19:20.889]                   args[[name]] <- ""
[10:19:20.889]                 }
[10:19:20.889]                 NAMES <- toupper(removed)
[10:19:20.889]                 for (kk in seq_along(NAMES)) {
[10:19:20.889]                   name <- removed[[kk]]
[10:19:20.889]                   NAME <- NAMES[[kk]]
[10:19:20.889]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.889]                     next
[10:19:20.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.889]                 }
[10:19:20.889]                 if (length(args) > 0) 
[10:19:20.889]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.889]             }
[10:19:20.889]             else {
[10:19:20.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.889]             }
[10:19:20.889]             {
[10:19:20.889]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.889]                   0L) {
[10:19:20.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.889]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.889]                   base::options(opts)
[10:19:20.889]                 }
[10:19:20.889]                 {
[10:19:20.889]                   {
[10:19:20.889]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.889]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.889]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.889]                       inherits = FALSE)
[10:19:20.889]                     NULL
[10:19:20.889]                   }
[10:19:20.889]                   options(future.plan = NULL)
[10:19:20.889]                   if (is.na(NA_character_)) 
[10:19:20.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.889]                     .init = FALSE)
[10:19:20.889]                 }
[10:19:20.889]             }
[10:19:20.889]         }
[10:19:20.889]     })
[10:19:20.889]     if (TRUE) {
[10:19:20.889]         base::sink(type = "output", split = FALSE)
[10:19:20.889]         if (TRUE) {
[10:19:20.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.889]         }
[10:19:20.889]         else {
[10:19:20.889]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.889]         }
[10:19:20.889]         base::close(...future.stdout)
[10:19:20.889]         ...future.stdout <- NULL
[10:19:20.889]     }
[10:19:20.889]     ...future.result$conditions <- ...future.conditions
[10:19:20.889]     ...future.result$finished <- base::Sys.time()
[10:19:20.889]     ...future.result
[10:19:20.889] }
[10:19:20.891] assign_globals() ...
[10:19:20.891] List of 5
[10:19:20.891]  $ ...future.FUN            :function (x)  
[10:19:20.891]  $ MoreArgs                 : NULL
[10:19:20.891]  $ ...future.elements_ii    :List of 1
[10:19:20.891]   ..$ :List of 1
[10:19:20.891]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:19:20.891]  $ ...future.seeds_ii       : NULL
[10:19:20.891]  $ ...future.globals.maxSize: NULL
[10:19:20.891]  - attr(*, "where")=List of 5
[10:19:20.891]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.891]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.891]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.891]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.891]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.891]  - attr(*, "resolved")= logi FALSE
[10:19:20.891]  - attr(*, "total_size")= num 366
[10:19:20.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.891]  - attr(*, "already-done")= logi TRUE
[10:19:20.895] - copied ‘...future.FUN’ to environment
[10:19:20.896] - copied ‘MoreArgs’ to environment
[10:19:20.896] - copied ‘...future.elements_ii’ to environment
[10:19:20.896] - copied ‘...future.seeds_ii’ to environment
[10:19:20.896] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.896] assign_globals() ... done
[10:19:20.896] plan(): Setting new future strategy stack:
[10:19:20.896] List of future strategies:
[10:19:20.896] 1. sequential:
[10:19:20.896]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.896]    - tweaked: FALSE
[10:19:20.896]    - call: NULL
[10:19:20.897] plan(): nbrOfWorkers() = 1
[10:19:20.898] plan(): Setting new future strategy stack:
[10:19:20.898] List of future strategies:
[10:19:20.898] 1. sequential:
[10:19:20.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.898]    - tweaked: FALSE
[10:19:20.898]    - call: plan(strategy)
[10:19:20.898] plan(): nbrOfWorkers() = 1
[10:19:20.898] SequentialFuture started (and completed)
[10:19:20.898] - Launch lazy future ... done
[10:19:20.900] run() for ‘SequentialFuture’ ... done
[10:19:20.900] Created future:
[10:19:20.900] SequentialFuture:
[10:19:20.900] Label: ‘future_mapply-1’
[10:19:20.900] Expression:
[10:19:20.900] {
[10:19:20.900]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.900]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.900]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.900]         on.exit(options(oopts), add = TRUE)
[10:19:20.900]     }
[10:19:20.900]     {
[10:19:20.900]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.900]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.900]         do.call(mapply, args = args)
[10:19:20.900]     }
[10:19:20.900] }
[10:19:20.900] Lazy evaluation: FALSE
[10:19:20.900] Asynchronous evaluation: FALSE
[10:19:20.900] Local evaluation: TRUE
[10:19:20.900] Environment: R_GlobalEnv
[10:19:20.900] Capture standard output: TRUE
[10:19:20.900] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.900] Globals: 5 objects totaling 366 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.900] Packages: <none>
[10:19:20.900] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.900] Resolved: TRUE
[10:19:20.900] Value: 92 bytes of class ‘list’
[10:19:20.900] Early signaling: FALSE
[10:19:20.900] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.900] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.901] Chunk #1 of 1 ... DONE
[10:19:20.901] Launching 1 futures (chunks) ... DONE
[10:19:20.901] Resolving 1 futures (chunks) ...
[10:19:20.901] resolve() on list ...
[10:19:20.901]  recursive: 0
[10:19:20.901]  length: 1
[10:19:20.901] 
[10:19:20.902] resolved() for ‘SequentialFuture’ ...
[10:19:20.902] - state: ‘finished’
[10:19:20.902] - run: TRUE
[10:19:20.902] - result: ‘FutureResult’
[10:19:20.902] resolved() for ‘SequentialFuture’ ... done
[10:19:20.902] Future #1
[10:19:20.902] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.902] - nx: 1
[10:19:20.902] - relay: TRUE
[10:19:20.902] - stdout: TRUE
[10:19:20.902] - signal: TRUE
[10:19:20.902] - resignal: FALSE
[10:19:20.903] - force: TRUE
[10:19:20.903] - relayed: [n=1] FALSE
[10:19:20.903] - queued futures: [n=1] FALSE
[10:19:20.903]  - until=1
[10:19:20.903]  - relaying element #1
[10:19:20.903] - relayed: [n=1] TRUE
[10:19:20.903] - queued futures: [n=1] TRUE
[10:19:20.903] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.903]  length: 0 (resolved future 1)
[10:19:20.903] Relaying remaining futures
[10:19:20.904] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.904] - nx: 1
[10:19:20.904] - relay: TRUE
[10:19:20.904] - stdout: TRUE
[10:19:20.904] - signal: TRUE
[10:19:20.904] - resignal: FALSE
[10:19:20.904] - force: TRUE
[10:19:20.904] - relayed: [n=1] TRUE
[10:19:20.904] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.904] - relayed: [n=1] TRUE
[10:19:20.904] - queued futures: [n=1] TRUE
[10:19:20.904] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.904] resolve() on list ... DONE
[10:19:20.905]  - Number of value chunks collected: 1
[10:19:20.905] Resolving 1 futures (chunks) ... DONE
[10:19:20.905] Reducing values from 1 chunks ...
[10:19:20.905]  - Number of values collected after concatenation: 1
[10:19:20.905]  - Number of values expected: 1
[10:19:20.905] Reducing values from 1 chunks ... DONE
[10:19:20.905] future_mapply() ... DONE
[10:19:20.905] future_mapply() ...
[10:19:20.905] Number of chunks: 1
[10:19:20.905] getGlobalsAndPackagesXApply() ...
[10:19:20.906]  - future.globals: TRUE
[10:19:20.906] getGlobalsAndPackages() ...
[10:19:20.906] Searching for globals...
[10:19:20.907] - globals found: [1] ‘FUN’
[10:19:20.907] Searching for globals ... DONE
[10:19:20.907] Resolving globals: FALSE
[10:19:20.907] The total size of the 1 globals is 185 bytes (185 bytes)
[10:19:20.907] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:19:20.908] - globals: [1] ‘FUN’
[10:19:20.908] 
[10:19:20.908] getGlobalsAndPackages() ... DONE
[10:19:20.908]  - globals found/used: [n=1] ‘FUN’
[10:19:20.908]  - needed namespaces: [n=0] 
[10:19:20.908] Finding globals ... DONE
[10:19:20.908] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.908] List of 2
[10:19:20.908]  $ ...future.FUN:function (x)  
[10:19:20.908]  $ MoreArgs     : list()
[10:19:20.908]  - attr(*, "where")=List of 2
[10:19:20.908]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.908]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.908]  - attr(*, "resolved")= logi FALSE
[10:19:20.908]  - attr(*, "total_size")= num NA
[10:19:20.911] Packages to be attached in all futures: [n=0] 
[10:19:20.911] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.911] Number of futures (= number of chunks): 1
[10:19:20.911] Launching 1 futures (chunks) ...
[10:19:20.911] Chunk #1 of 1 ...
[10:19:20.911]  - Finding globals in '...' for chunk #1 ...
[10:19:20.911] getGlobalsAndPackages() ...
[10:19:20.911] Searching for globals...
[10:19:20.912] 
[10:19:20.912] Searching for globals ... DONE
[10:19:20.912] - globals: [0] <none>
[10:19:20.912] getGlobalsAndPackages() ... DONE
[10:19:20.912]    + additional globals found: [n=0] 
[10:19:20.912]    + additional namespaces needed: [n=0] 
[10:19:20.912]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.912]  - seeds: <none>
[10:19:20.912]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.912] getGlobalsAndPackages() ...
[10:19:20.912] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.913] Resolving globals: FALSE
[10:19:20.913] The total size of the 5 globals is 370 bytes (370 bytes)
[10:19:20.913] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 370 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:20.913] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.914] 
[10:19:20.914] getGlobalsAndPackages() ... DONE
[10:19:20.914] run() for ‘Future’ ...
[10:19:20.914] - state: ‘created’
[10:19:20.914] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.914] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.914] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.915]   - Field: ‘label’
[10:19:20.915]   - Field: ‘local’
[10:19:20.915]   - Field: ‘owner’
[10:19:20.915]   - Field: ‘envir’
[10:19:20.915]   - Field: ‘packages’
[10:19:20.915]   - Field: ‘gc’
[10:19:20.915]   - Field: ‘conditions’
[10:19:20.915]   - Field: ‘expr’
[10:19:20.915]   - Field: ‘uuid’
[10:19:20.915]   - Field: ‘seed’
[10:19:20.915]   - Field: ‘version’
[10:19:20.915]   - Field: ‘result’
[10:19:20.916]   - Field: ‘asynchronous’
[10:19:20.916]   - Field: ‘calls’
[10:19:20.916]   - Field: ‘globals’
[10:19:20.916]   - Field: ‘stdout’
[10:19:20.916]   - Field: ‘earlySignal’
[10:19:20.916]   - Field: ‘lazy’
[10:19:20.916]   - Field: ‘state’
[10:19:20.916] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.916] - Launch lazy future ...
[10:19:20.916] Packages needed by the future expression (n = 0): <none>
[10:19:20.916] Packages needed by future strategies (n = 0): <none>
[10:19:20.917] {
[10:19:20.917]     {
[10:19:20.917]         {
[10:19:20.917]             ...future.startTime <- base::Sys.time()
[10:19:20.917]             {
[10:19:20.917]                 {
[10:19:20.917]                   {
[10:19:20.917]                     base::local({
[10:19:20.917]                       has_future <- base::requireNamespace("future", 
[10:19:20.917]                         quietly = TRUE)
[10:19:20.917]                       if (has_future) {
[10:19:20.917]                         ns <- base::getNamespace("future")
[10:19:20.917]                         version <- ns[[".package"]][["version"]]
[10:19:20.917]                         if (is.null(version)) 
[10:19:20.917]                           version <- utils::packageVersion("future")
[10:19:20.917]                       }
[10:19:20.917]                       else {
[10:19:20.917]                         version <- NULL
[10:19:20.917]                       }
[10:19:20.917]                       if (!has_future || version < "1.8.0") {
[10:19:20.917]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.917]                           "", base::R.version$version.string), 
[10:19:20.917]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.917]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.917]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.917]                             "release", "version")], collapse = " "), 
[10:19:20.917]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.917]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.917]                           info)
[10:19:20.917]                         info <- base::paste(info, collapse = "; ")
[10:19:20.917]                         if (!has_future) {
[10:19:20.917]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.917]                             info)
[10:19:20.917]                         }
[10:19:20.917]                         else {
[10:19:20.917]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.917]                             info, version)
[10:19:20.917]                         }
[10:19:20.917]                         base::stop(msg)
[10:19:20.917]                       }
[10:19:20.917]                     })
[10:19:20.917]                   }
[10:19:20.917]                   ...future.strategy.old <- future::plan("list")
[10:19:20.917]                   options(future.plan = NULL)
[10:19:20.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.917]                 }
[10:19:20.917]                 ...future.workdir <- getwd()
[10:19:20.917]             }
[10:19:20.917]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.917]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.917]         }
[10:19:20.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.917]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.917]             base::names(...future.oldOptions))
[10:19:20.917]     }
[10:19:20.917]     if (FALSE) {
[10:19:20.917]     }
[10:19:20.917]     else {
[10:19:20.917]         if (TRUE) {
[10:19:20.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.917]                 open = "w")
[10:19:20.917]         }
[10:19:20.917]         else {
[10:19:20.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.917]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.917]         }
[10:19:20.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.917]             base::sink(type = "output", split = FALSE)
[10:19:20.917]             base::close(...future.stdout)
[10:19:20.917]         }, add = TRUE)
[10:19:20.917]     }
[10:19:20.917]     ...future.frame <- base::sys.nframe()
[10:19:20.917]     ...future.conditions <- base::list()
[10:19:20.917]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.917]     if (FALSE) {
[10:19:20.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.917]     }
[10:19:20.917]     ...future.result <- base::tryCatch({
[10:19:20.917]         base::withCallingHandlers({
[10:19:20.917]             ...future.value <- base::withVisible(base::local({
[10:19:20.917]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.917]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.917]                   ...future.globals.maxSize)) {
[10:19:20.917]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.917]                   on.exit(options(oopts), add = TRUE)
[10:19:20.917]                 }
[10:19:20.917]                 {
[10:19:20.917]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.917]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.917]                     USE.NAMES = FALSE)
[10:19:20.917]                   do.call(mapply, args = args)
[10:19:20.917]                 }
[10:19:20.917]             }))
[10:19:20.917]             future::FutureResult(value = ...future.value$value, 
[10:19:20.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.917]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.917]                     ...future.globalenv.names))
[10:19:20.917]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.917]         }, condition = base::local({
[10:19:20.917]             c <- base::c
[10:19:20.917]             inherits <- base::inherits
[10:19:20.917]             invokeRestart <- base::invokeRestart
[10:19:20.917]             length <- base::length
[10:19:20.917]             list <- base::list
[10:19:20.917]             seq.int <- base::seq.int
[10:19:20.917]             signalCondition <- base::signalCondition
[10:19:20.917]             sys.calls <- base::sys.calls
[10:19:20.917]             `[[` <- base::`[[`
[10:19:20.917]             `+` <- base::`+`
[10:19:20.917]             `<<-` <- base::`<<-`
[10:19:20.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.917]                   3L)]
[10:19:20.917]             }
[10:19:20.917]             function(cond) {
[10:19:20.917]                 is_error <- inherits(cond, "error")
[10:19:20.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.917]                   NULL)
[10:19:20.917]                 if (is_error) {
[10:19:20.917]                   sessionInformation <- function() {
[10:19:20.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.917]                       search = base::search(), system = base::Sys.info())
[10:19:20.917]                   }
[10:19:20.917]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.917]                     cond$call), session = sessionInformation(), 
[10:19:20.917]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.917]                   signalCondition(cond)
[10:19:20.917]                 }
[10:19:20.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.917]                 "immediateCondition"))) {
[10:19:20.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.917]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.917]                   if (TRUE && !signal) {
[10:19:20.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.917]                     {
[10:19:20.917]                       inherits <- base::inherits
[10:19:20.917]                       invokeRestart <- base::invokeRestart
[10:19:20.917]                       is.null <- base::is.null
[10:19:20.917]                       muffled <- FALSE
[10:19:20.917]                       if (inherits(cond, "message")) {
[10:19:20.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.917]                         if (muffled) 
[10:19:20.917]                           invokeRestart("muffleMessage")
[10:19:20.917]                       }
[10:19:20.917]                       else if (inherits(cond, "warning")) {
[10:19:20.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.917]                         if (muffled) 
[10:19:20.917]                           invokeRestart("muffleWarning")
[10:19:20.917]                       }
[10:19:20.917]                       else if (inherits(cond, "condition")) {
[10:19:20.917]                         if (!is.null(pattern)) {
[10:19:20.917]                           computeRestarts <- base::computeRestarts
[10:19:20.917]                           grepl <- base::grepl
[10:19:20.917]                           restarts <- computeRestarts(cond)
[10:19:20.917]                           for (restart in restarts) {
[10:19:20.917]                             name <- restart$name
[10:19:20.917]                             if (is.null(name)) 
[10:19:20.917]                               next
[10:19:20.917]                             if (!grepl(pattern, name)) 
[10:19:20.917]                               next
[10:19:20.917]                             invokeRestart(restart)
[10:19:20.917]                             muffled <- TRUE
[10:19:20.917]                             break
[10:19:20.917]                           }
[10:19:20.917]                         }
[10:19:20.917]                       }
[10:19:20.917]                       invisible(muffled)
[10:19:20.917]                     }
[10:19:20.917]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.917]                   }
[10:19:20.917]                 }
[10:19:20.917]                 else {
[10:19:20.917]                   if (TRUE) {
[10:19:20.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.917]                     {
[10:19:20.917]                       inherits <- base::inherits
[10:19:20.917]                       invokeRestart <- base::invokeRestart
[10:19:20.917]                       is.null <- base::is.null
[10:19:20.917]                       muffled <- FALSE
[10:19:20.917]                       if (inherits(cond, "message")) {
[10:19:20.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.917]                         if (muffled) 
[10:19:20.917]                           invokeRestart("muffleMessage")
[10:19:20.917]                       }
[10:19:20.917]                       else if (inherits(cond, "warning")) {
[10:19:20.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.917]                         if (muffled) 
[10:19:20.917]                           invokeRestart("muffleWarning")
[10:19:20.917]                       }
[10:19:20.917]                       else if (inherits(cond, "condition")) {
[10:19:20.917]                         if (!is.null(pattern)) {
[10:19:20.917]                           computeRestarts <- base::computeRestarts
[10:19:20.917]                           grepl <- base::grepl
[10:19:20.917]                           restarts <- computeRestarts(cond)
[10:19:20.917]                           for (restart in restarts) {
[10:19:20.917]                             name <- restart$name
[10:19:20.917]                             if (is.null(name)) 
[10:19:20.917]                               next
[10:19:20.917]                             if (!grepl(pattern, name)) 
[10:19:20.917]                               next
[10:19:20.917]                             invokeRestart(restart)
[10:19:20.917]                             muffled <- TRUE
[10:19:20.917]                             break
[10:19:20.917]                           }
[10:19:20.917]                         }
[10:19:20.917]                       }
[10:19:20.917]                       invisible(muffled)
[10:19:20.917]                     }
[10:19:20.917]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.917]                   }
[10:19:20.917]                 }
[10:19:20.917]             }
[10:19:20.917]         }))
[10:19:20.917]     }, error = function(ex) {
[10:19:20.917]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.917]                 ...future.rng), started = ...future.startTime, 
[10:19:20.917]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.917]             version = "1.8"), class = "FutureResult")
[10:19:20.917]     }, finally = {
[10:19:20.917]         if (!identical(...future.workdir, getwd())) 
[10:19:20.917]             setwd(...future.workdir)
[10:19:20.917]         {
[10:19:20.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.917]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.917]             }
[10:19:20.917]             base::options(...future.oldOptions)
[10:19:20.917]             if (.Platform$OS.type == "windows") {
[10:19:20.917]                 old_names <- names(...future.oldEnvVars)
[10:19:20.917]                 envs <- base::Sys.getenv()
[10:19:20.917]                 names <- names(envs)
[10:19:20.917]                 common <- intersect(names, old_names)
[10:19:20.917]                 added <- setdiff(names, old_names)
[10:19:20.917]                 removed <- setdiff(old_names, names)
[10:19:20.917]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.917]                   envs[common]]
[10:19:20.917]                 NAMES <- toupper(changed)
[10:19:20.917]                 args <- list()
[10:19:20.917]                 for (kk in seq_along(NAMES)) {
[10:19:20.917]                   name <- changed[[kk]]
[10:19:20.917]                   NAME <- NAMES[[kk]]
[10:19:20.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.917]                     next
[10:19:20.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.917]                 }
[10:19:20.917]                 NAMES <- toupper(added)
[10:19:20.917]                 for (kk in seq_along(NAMES)) {
[10:19:20.917]                   name <- added[[kk]]
[10:19:20.917]                   NAME <- NAMES[[kk]]
[10:19:20.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.917]                     next
[10:19:20.917]                   args[[name]] <- ""
[10:19:20.917]                 }
[10:19:20.917]                 NAMES <- toupper(removed)
[10:19:20.917]                 for (kk in seq_along(NAMES)) {
[10:19:20.917]                   name <- removed[[kk]]
[10:19:20.917]                   NAME <- NAMES[[kk]]
[10:19:20.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.917]                     next
[10:19:20.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.917]                 }
[10:19:20.917]                 if (length(args) > 0) 
[10:19:20.917]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.917]             }
[10:19:20.917]             else {
[10:19:20.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.917]             }
[10:19:20.917]             {
[10:19:20.917]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.917]                   0L) {
[10:19:20.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.917]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.917]                   base::options(opts)
[10:19:20.917]                 }
[10:19:20.917]                 {
[10:19:20.917]                   {
[10:19:20.917]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.917]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.917]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.917]                       inherits = FALSE)
[10:19:20.917]                     NULL
[10:19:20.917]                   }
[10:19:20.917]                   options(future.plan = NULL)
[10:19:20.917]                   if (is.na(NA_character_)) 
[10:19:20.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.917]                     .init = FALSE)
[10:19:20.917]                 }
[10:19:20.917]             }
[10:19:20.917]         }
[10:19:20.917]     })
[10:19:20.917]     if (TRUE) {
[10:19:20.917]         base::sink(type = "output", split = FALSE)
[10:19:20.917]         if (TRUE) {
[10:19:20.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.917]         }
[10:19:20.917]         else {
[10:19:20.917]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.917]         }
[10:19:20.917]         base::close(...future.stdout)
[10:19:20.917]         ...future.stdout <- NULL
[10:19:20.917]     }
[10:19:20.917]     ...future.result$conditions <- ...future.conditions
[10:19:20.917]     ...future.result$finished <- base::Sys.time()
[10:19:20.917]     ...future.result
[10:19:20.917] }
[10:19:20.919] assign_globals() ...
[10:19:20.919] List of 5
[10:19:20.919]  $ ...future.FUN            :function (x)  
[10:19:20.919]  $ MoreArgs                 : list()
[10:19:20.919]  $ ...future.elements_ii    :List of 1
[10:19:20.919]   ..$ :List of 1
[10:19:20.919]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:19:20.919]  $ ...future.seeds_ii       : NULL
[10:19:20.919]  $ ...future.globals.maxSize: NULL
[10:19:20.919]  - attr(*, "where")=List of 5
[10:19:20.919]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.919]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.919]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.919]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.919]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.919]  - attr(*, "resolved")= logi FALSE
[10:19:20.919]  - attr(*, "total_size")= num 370
[10:19:20.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.919]  - attr(*, "already-done")= logi TRUE
[10:19:20.925] - copied ‘...future.FUN’ to environment
[10:19:20.925] - copied ‘MoreArgs’ to environment
[10:19:20.925] - copied ‘...future.elements_ii’ to environment
[10:19:20.925] - copied ‘...future.seeds_ii’ to environment
[10:19:20.925] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.925] assign_globals() ... done
[10:19:20.925] plan(): Setting new future strategy stack:
[10:19:20.925] List of future strategies:
[10:19:20.925] 1. sequential:
[10:19:20.925]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.925]    - tweaked: FALSE
[10:19:20.925]    - call: NULL
[10:19:20.926] plan(): nbrOfWorkers() = 1
[10:19:20.926] plan(): Setting new future strategy stack:
[10:19:20.927] List of future strategies:
[10:19:20.927] 1. sequential:
[10:19:20.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.927]    - tweaked: FALSE
[10:19:20.927]    - call: plan(strategy)
[10:19:20.927] plan(): nbrOfWorkers() = 1
[10:19:20.927] SequentialFuture started (and completed)
[10:19:20.927] - Launch lazy future ... done
[10:19:20.927] run() for ‘SequentialFuture’ ... done
[10:19:20.927] Created future:
[10:19:20.928] SequentialFuture:
[10:19:20.928] Label: ‘future_.mapply-1’
[10:19:20.928] Expression:
[10:19:20.928] {
[10:19:20.928]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.928]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.928]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.928]         on.exit(options(oopts), add = TRUE)
[10:19:20.928]     }
[10:19:20.928]     {
[10:19:20.928]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.928]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.928]         do.call(mapply, args = args)
[10:19:20.928]     }
[10:19:20.928] }
[10:19:20.928] Lazy evaluation: FALSE
[10:19:20.928] Asynchronous evaluation: FALSE
[10:19:20.928] Local evaluation: TRUE
[10:19:20.928] Environment: R_GlobalEnv
[10:19:20.928] Capture standard output: TRUE
[10:19:20.928] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.928] Globals: 5 objects totaling 370 bytes (function ‘...future.FUN’ of 185 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.928] Packages: <none>
[10:19:20.928] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.928] Resolved: TRUE
[10:19:20.928] Value: 92 bytes of class ‘list’
[10:19:20.928] Early signaling: FALSE
[10:19:20.928] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.928] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.928] Chunk #1 of 1 ... DONE
[10:19:20.928] Launching 1 futures (chunks) ... DONE
[10:19:20.928] Resolving 1 futures (chunks) ...
[10:19:20.929] resolve() on list ...
[10:19:20.929]  recursive: 0
[10:19:20.929]  length: 1
[10:19:20.929] 
[10:19:20.929] resolved() for ‘SequentialFuture’ ...
[10:19:20.929] - state: ‘finished’
[10:19:20.929] - run: TRUE
[10:19:20.929] - result: ‘FutureResult’
[10:19:20.929] resolved() for ‘SequentialFuture’ ... done
[10:19:20.929] Future #1
[10:19:20.929] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.930] - nx: 1
[10:19:20.930] - relay: TRUE
[10:19:20.930] - stdout: TRUE
[10:19:20.930] - signal: TRUE
[10:19:20.930] - resignal: FALSE
[10:19:20.930] - force: TRUE
[10:19:20.930] - relayed: [n=1] FALSE
[10:19:20.930] - queued futures: [n=1] FALSE
[10:19:20.930]  - until=1
[10:19:20.930]  - relaying element #1
[10:19:20.930] - relayed: [n=1] TRUE
[10:19:20.931] - queued futures: [n=1] TRUE
[10:19:20.931] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.931]  length: 0 (resolved future 1)
[10:19:20.931] Relaying remaining futures
[10:19:20.931] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.931] - nx: 1
[10:19:20.931] - relay: TRUE
[10:19:20.931] - stdout: TRUE
[10:19:20.931] - signal: TRUE
[10:19:20.931] - resignal: FALSE
[10:19:20.931] - force: TRUE
[10:19:20.931] - relayed: [n=1] TRUE
[10:19:20.931] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.932] - relayed: [n=1] TRUE
[10:19:20.932] - queued futures: [n=1] TRUE
[10:19:20.932] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.932] resolve() on list ... DONE
[10:19:20.932]  - Number of value chunks collected: 1
[10:19:20.932] Resolving 1 futures (chunks) ... DONE
[10:19:20.932] Reducing values from 1 chunks ...
[10:19:20.932]  - Number of values collected after concatenation: 1
[10:19:20.932]  - Number of values expected: 1
[10:19:20.932] Reducing values from 1 chunks ... DONE
[10:19:20.932] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[10:19:20.933] future_mapply() ...
[10:19:20.933] Number of chunks: 1
[10:19:20.933] getGlobalsAndPackagesXApply() ...
[10:19:20.933]  - future.globals: TRUE
[10:19:20.933] getGlobalsAndPackages() ...
[10:19:20.933] Searching for globals...
[10:19:20.934] - globals found: [1] ‘FUN’
[10:19:20.934] Searching for globals ... DONE
[10:19:20.934] Resolving globals: FALSE
[10:19:20.935] The total size of the 1 globals is 326 bytes (326 bytes)
[10:19:20.935] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:19:20.935] - globals: [1] ‘FUN’
[10:19:20.935] 
[10:19:20.935] getGlobalsAndPackages() ... DONE
[10:19:20.935]  - globals found/used: [n=1] ‘FUN’
[10:19:20.935]  - needed namespaces: [n=0] 
[10:19:20.935] Finding globals ... DONE
[10:19:20.936] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.936] List of 2
[10:19:20.936]  $ ...future.FUN:function (x, y)  
[10:19:20.936]  $ MoreArgs     :List of 1
[10:19:20.936]   ..$ y: int [1:2] 3 4
[10:19:20.936]  - attr(*, "where")=List of 2
[10:19:20.936]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.936]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.936]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.936]  - attr(*, "resolved")= logi FALSE
[10:19:20.936]  - attr(*, "total_size")= num NA
[10:19:20.938] Packages to be attached in all futures: [n=0] 
[10:19:20.938] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.939] Number of futures (= number of chunks): 1
[10:19:20.939] Launching 1 futures (chunks) ...
[10:19:20.939] Chunk #1 of 1 ...
[10:19:20.939]  - Finding globals in '...' for chunk #1 ...
[10:19:20.939] getGlobalsAndPackages() ...
[10:19:20.939] Searching for globals...
[10:19:20.939] 
[10:19:20.939] Searching for globals ... DONE
[10:19:20.940] - globals: [0] <none>
[10:19:20.940] getGlobalsAndPackages() ... DONE
[10:19:20.940]    + additional globals found: [n=0] 
[10:19:20.940]    + additional namespaces needed: [n=0] 
[10:19:20.940]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.940]  - seeds: <none>
[10:19:20.940]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.940] getGlobalsAndPackages() ...
[10:19:20.940] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.940] Resolving globals: FALSE
[10:19:20.941] The total size of the 5 globals is 668 bytes (668 bytes)
[10:19:20.941] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 668 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (105 bytes of class ‘list’)
[10:19:20.941] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.941] 
[10:19:20.941] getGlobalsAndPackages() ... DONE
[10:19:20.942] run() for ‘Future’ ...
[10:19:20.942] - state: ‘created’
[10:19:20.942] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.942] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.942]   - Field: ‘label’
[10:19:20.942]   - Field: ‘local’
[10:19:20.944]   - Field: ‘owner’
[10:19:20.944]   - Field: ‘envir’
[10:19:20.944]   - Field: ‘packages’
[10:19:20.944]   - Field: ‘gc’
[10:19:20.944]   - Field: ‘conditions’
[10:19:20.944]   - Field: ‘expr’
[10:19:20.944]   - Field: ‘uuid’
[10:19:20.945]   - Field: ‘seed’
[10:19:20.945]   - Field: ‘version’
[10:19:20.945]   - Field: ‘result’
[10:19:20.945]   - Field: ‘asynchronous’
[10:19:20.945]   - Field: ‘calls’
[10:19:20.945]   - Field: ‘globals’
[10:19:20.945]   - Field: ‘stdout’
[10:19:20.945]   - Field: ‘earlySignal’
[10:19:20.945]   - Field: ‘lazy’
[10:19:20.945]   - Field: ‘state’
[10:19:20.945] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.946] - Launch lazy future ...
[10:19:20.946] Packages needed by the future expression (n = 0): <none>
[10:19:20.946] Packages needed by future strategies (n = 0): <none>
[10:19:20.946] {
[10:19:20.946]     {
[10:19:20.946]         {
[10:19:20.946]             ...future.startTime <- base::Sys.time()
[10:19:20.946]             {
[10:19:20.946]                 {
[10:19:20.946]                   {
[10:19:20.946]                     base::local({
[10:19:20.946]                       has_future <- base::requireNamespace("future", 
[10:19:20.946]                         quietly = TRUE)
[10:19:20.946]                       if (has_future) {
[10:19:20.946]                         ns <- base::getNamespace("future")
[10:19:20.946]                         version <- ns[[".package"]][["version"]]
[10:19:20.946]                         if (is.null(version)) 
[10:19:20.946]                           version <- utils::packageVersion("future")
[10:19:20.946]                       }
[10:19:20.946]                       else {
[10:19:20.946]                         version <- NULL
[10:19:20.946]                       }
[10:19:20.946]                       if (!has_future || version < "1.8.0") {
[10:19:20.946]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.946]                           "", base::R.version$version.string), 
[10:19:20.946]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.946]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.946]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.946]                             "release", "version")], collapse = " "), 
[10:19:20.946]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.946]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.946]                           info)
[10:19:20.946]                         info <- base::paste(info, collapse = "; ")
[10:19:20.946]                         if (!has_future) {
[10:19:20.946]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.946]                             info)
[10:19:20.946]                         }
[10:19:20.946]                         else {
[10:19:20.946]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.946]                             info, version)
[10:19:20.946]                         }
[10:19:20.946]                         base::stop(msg)
[10:19:20.946]                       }
[10:19:20.946]                     })
[10:19:20.946]                   }
[10:19:20.946]                   ...future.strategy.old <- future::plan("list")
[10:19:20.946]                   options(future.plan = NULL)
[10:19:20.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.946]                 }
[10:19:20.946]                 ...future.workdir <- getwd()
[10:19:20.946]             }
[10:19:20.946]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.946]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.946]         }
[10:19:20.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.946]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.946]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.946]             base::names(...future.oldOptions))
[10:19:20.946]     }
[10:19:20.946]     if (FALSE) {
[10:19:20.946]     }
[10:19:20.946]     else {
[10:19:20.946]         if (TRUE) {
[10:19:20.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.946]                 open = "w")
[10:19:20.946]         }
[10:19:20.946]         else {
[10:19:20.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.946]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.946]         }
[10:19:20.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.946]             base::sink(type = "output", split = FALSE)
[10:19:20.946]             base::close(...future.stdout)
[10:19:20.946]         }, add = TRUE)
[10:19:20.946]     }
[10:19:20.946]     ...future.frame <- base::sys.nframe()
[10:19:20.946]     ...future.conditions <- base::list()
[10:19:20.946]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.946]     if (FALSE) {
[10:19:20.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.946]     }
[10:19:20.946]     ...future.result <- base::tryCatch({
[10:19:20.946]         base::withCallingHandlers({
[10:19:20.946]             ...future.value <- base::withVisible(base::local({
[10:19:20.946]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.946]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.946]                   ...future.globals.maxSize)) {
[10:19:20.946]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.946]                   on.exit(options(oopts), add = TRUE)
[10:19:20.946]                 }
[10:19:20.946]                 {
[10:19:20.946]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.946]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.946]                     USE.NAMES = FALSE)
[10:19:20.946]                   do.call(mapply, args = args)
[10:19:20.946]                 }
[10:19:20.946]             }))
[10:19:20.946]             future::FutureResult(value = ...future.value$value, 
[10:19:20.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.946]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.946]                     ...future.globalenv.names))
[10:19:20.946]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.946]         }, condition = base::local({
[10:19:20.946]             c <- base::c
[10:19:20.946]             inherits <- base::inherits
[10:19:20.946]             invokeRestart <- base::invokeRestart
[10:19:20.946]             length <- base::length
[10:19:20.946]             list <- base::list
[10:19:20.946]             seq.int <- base::seq.int
[10:19:20.946]             signalCondition <- base::signalCondition
[10:19:20.946]             sys.calls <- base::sys.calls
[10:19:20.946]             `[[` <- base::`[[`
[10:19:20.946]             `+` <- base::`+`
[10:19:20.946]             `<<-` <- base::`<<-`
[10:19:20.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.946]                   3L)]
[10:19:20.946]             }
[10:19:20.946]             function(cond) {
[10:19:20.946]                 is_error <- inherits(cond, "error")
[10:19:20.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.946]                   NULL)
[10:19:20.946]                 if (is_error) {
[10:19:20.946]                   sessionInformation <- function() {
[10:19:20.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.946]                       search = base::search(), system = base::Sys.info())
[10:19:20.946]                   }
[10:19:20.946]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.946]                     cond$call), session = sessionInformation(), 
[10:19:20.946]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.946]                   signalCondition(cond)
[10:19:20.946]                 }
[10:19:20.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.946]                 "immediateCondition"))) {
[10:19:20.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.946]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.946]                   if (TRUE && !signal) {
[10:19:20.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.946]                     {
[10:19:20.946]                       inherits <- base::inherits
[10:19:20.946]                       invokeRestart <- base::invokeRestart
[10:19:20.946]                       is.null <- base::is.null
[10:19:20.946]                       muffled <- FALSE
[10:19:20.946]                       if (inherits(cond, "message")) {
[10:19:20.946]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.946]                         if (muffled) 
[10:19:20.946]                           invokeRestart("muffleMessage")
[10:19:20.946]                       }
[10:19:20.946]                       else if (inherits(cond, "warning")) {
[10:19:20.946]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.946]                         if (muffled) 
[10:19:20.946]                           invokeRestart("muffleWarning")
[10:19:20.946]                       }
[10:19:20.946]                       else if (inherits(cond, "condition")) {
[10:19:20.946]                         if (!is.null(pattern)) {
[10:19:20.946]                           computeRestarts <- base::computeRestarts
[10:19:20.946]                           grepl <- base::grepl
[10:19:20.946]                           restarts <- computeRestarts(cond)
[10:19:20.946]                           for (restart in restarts) {
[10:19:20.946]                             name <- restart$name
[10:19:20.946]                             if (is.null(name)) 
[10:19:20.946]                               next
[10:19:20.946]                             if (!grepl(pattern, name)) 
[10:19:20.946]                               next
[10:19:20.946]                             invokeRestart(restart)
[10:19:20.946]                             muffled <- TRUE
[10:19:20.946]                             break
[10:19:20.946]                           }
[10:19:20.946]                         }
[10:19:20.946]                       }
[10:19:20.946]                       invisible(muffled)
[10:19:20.946]                     }
[10:19:20.946]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.946]                   }
[10:19:20.946]                 }
[10:19:20.946]                 else {
[10:19:20.946]                   if (TRUE) {
[10:19:20.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.946]                     {
[10:19:20.946]                       inherits <- base::inherits
[10:19:20.946]                       invokeRestart <- base::invokeRestart
[10:19:20.946]                       is.null <- base::is.null
[10:19:20.946]                       muffled <- FALSE
[10:19:20.946]                       if (inherits(cond, "message")) {
[10:19:20.946]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.946]                         if (muffled) 
[10:19:20.946]                           invokeRestart("muffleMessage")
[10:19:20.946]                       }
[10:19:20.946]                       else if (inherits(cond, "warning")) {
[10:19:20.946]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.946]                         if (muffled) 
[10:19:20.946]                           invokeRestart("muffleWarning")
[10:19:20.946]                       }
[10:19:20.946]                       else if (inherits(cond, "condition")) {
[10:19:20.946]                         if (!is.null(pattern)) {
[10:19:20.946]                           computeRestarts <- base::computeRestarts
[10:19:20.946]                           grepl <- base::grepl
[10:19:20.946]                           restarts <- computeRestarts(cond)
[10:19:20.946]                           for (restart in restarts) {
[10:19:20.946]                             name <- restart$name
[10:19:20.946]                             if (is.null(name)) 
[10:19:20.946]                               next
[10:19:20.946]                             if (!grepl(pattern, name)) 
[10:19:20.946]                               next
[10:19:20.946]                             invokeRestart(restart)
[10:19:20.946]                             muffled <- TRUE
[10:19:20.946]                             break
[10:19:20.946]                           }
[10:19:20.946]                         }
[10:19:20.946]                       }
[10:19:20.946]                       invisible(muffled)
[10:19:20.946]                     }
[10:19:20.946]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.946]                   }
[10:19:20.946]                 }
[10:19:20.946]             }
[10:19:20.946]         }))
[10:19:20.946]     }, error = function(ex) {
[10:19:20.946]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.946]                 ...future.rng), started = ...future.startTime, 
[10:19:20.946]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.946]             version = "1.8"), class = "FutureResult")
[10:19:20.946]     }, finally = {
[10:19:20.946]         if (!identical(...future.workdir, getwd())) 
[10:19:20.946]             setwd(...future.workdir)
[10:19:20.946]         {
[10:19:20.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.946]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.946]             }
[10:19:20.946]             base::options(...future.oldOptions)
[10:19:20.946]             if (.Platform$OS.type == "windows") {
[10:19:20.946]                 old_names <- names(...future.oldEnvVars)
[10:19:20.946]                 envs <- base::Sys.getenv()
[10:19:20.946]                 names <- names(envs)
[10:19:20.946]                 common <- intersect(names, old_names)
[10:19:20.946]                 added <- setdiff(names, old_names)
[10:19:20.946]                 removed <- setdiff(old_names, names)
[10:19:20.946]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.946]                   envs[common]]
[10:19:20.946]                 NAMES <- toupper(changed)
[10:19:20.946]                 args <- list()
[10:19:20.946]                 for (kk in seq_along(NAMES)) {
[10:19:20.946]                   name <- changed[[kk]]
[10:19:20.946]                   NAME <- NAMES[[kk]]
[10:19:20.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.946]                     next
[10:19:20.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.946]                 }
[10:19:20.946]                 NAMES <- toupper(added)
[10:19:20.946]                 for (kk in seq_along(NAMES)) {
[10:19:20.946]                   name <- added[[kk]]
[10:19:20.946]                   NAME <- NAMES[[kk]]
[10:19:20.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.946]                     next
[10:19:20.946]                   args[[name]] <- ""
[10:19:20.946]                 }
[10:19:20.946]                 NAMES <- toupper(removed)
[10:19:20.946]                 for (kk in seq_along(NAMES)) {
[10:19:20.946]                   name <- removed[[kk]]
[10:19:20.946]                   NAME <- NAMES[[kk]]
[10:19:20.946]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.946]                     next
[10:19:20.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.946]                 }
[10:19:20.946]                 if (length(args) > 0) 
[10:19:20.946]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.946]             }
[10:19:20.946]             else {
[10:19:20.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.946]             }
[10:19:20.946]             {
[10:19:20.946]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.946]                   0L) {
[10:19:20.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.946]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.946]                   base::options(opts)
[10:19:20.946]                 }
[10:19:20.946]                 {
[10:19:20.946]                   {
[10:19:20.946]                     base::assign(".Random.seed", c(10407L, -1220327115L, 
[10:19:20.946]                     -616991854L, 1882104135L, -313492464L, -1582070477L, 
[10:19:20.946]                     -1875332049L), envir = base::globalenv(), 
[10:19:20.946]                       inherits = FALSE)
[10:19:20.946]                     NULL
[10:19:20.946]                   }
[10:19:20.946]                   options(future.plan = NULL)
[10:19:20.946]                   if (is.na(NA_character_)) 
[10:19:20.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.946]                     .init = FALSE)
[10:19:20.946]                 }
[10:19:20.946]             }
[10:19:20.946]         }
[10:19:20.946]     })
[10:19:20.946]     if (TRUE) {
[10:19:20.946]         base::sink(type = "output", split = FALSE)
[10:19:20.946]         if (TRUE) {
[10:19:20.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.946]         }
[10:19:20.946]         else {
[10:19:20.946]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.946]         }
[10:19:20.946]         base::close(...future.stdout)
[10:19:20.946]         ...future.stdout <- NULL
[10:19:20.946]     }
[10:19:20.946]     ...future.result$conditions <- ...future.conditions
[10:19:20.946]     ...future.result$finished <- base::Sys.time()
[10:19:20.946]     ...future.result
[10:19:20.946] }
[10:19:20.948] assign_globals() ...
[10:19:20.948] List of 5
[10:19:20.948]  $ ...future.FUN            :function (x, y)  
[10:19:20.948]  $ MoreArgs                 :List of 1
[10:19:20.948]   ..$ y: int [1:2] 3 4
[10:19:20.948]  $ ...future.elements_ii    :List of 1
[10:19:20.948]   ..$ x:List of 2
[10:19:20.948]   .. ..$ : int 1
[10:19:20.948]   .. ..$ : int 2
[10:19:20.948]  $ ...future.seeds_ii       : NULL
[10:19:20.948]  $ ...future.globals.maxSize: NULL
[10:19:20.948]  - attr(*, "where")=List of 5
[10:19:20.948]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.948]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.948]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.948]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.948]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.948]  - attr(*, "resolved")= logi FALSE
[10:19:20.948]  - attr(*, "total_size")= num 668
[10:19:20.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.948]  - attr(*, "already-done")= logi TRUE
[10:19:20.953] - reassign environment for ‘...future.FUN’
[10:19:20.953] - copied ‘...future.FUN’ to environment
[10:19:20.953] - copied ‘MoreArgs’ to environment
[10:19:20.953] - copied ‘...future.elements_ii’ to environment
[10:19:20.953] - copied ‘...future.seeds_ii’ to environment
[10:19:20.953] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.953] assign_globals() ... done
[10:19:20.954] plan(): Setting new future strategy stack:
[10:19:20.954] List of future strategies:
[10:19:20.954] 1. sequential:
[10:19:20.954]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.954]    - tweaked: FALSE
[10:19:20.954]    - call: NULL
[10:19:20.954] plan(): nbrOfWorkers() = 1
[10:19:20.955] plan(): Setting new future strategy stack:
[10:19:20.955] List of future strategies:
[10:19:20.955] 1. sequential:
[10:19:20.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.955]    - tweaked: FALSE
[10:19:20.955]    - call: plan(strategy)
[10:19:20.955] plan(): nbrOfWorkers() = 1
[10:19:20.956] SequentialFuture started (and completed)
[10:19:20.956] - Launch lazy future ... done
[10:19:20.956] run() for ‘SequentialFuture’ ... done
[10:19:20.956] Created future:
[10:19:20.956] SequentialFuture:
[10:19:20.956] Label: ‘future_mapply-1’
[10:19:20.956] Expression:
[10:19:20.956] {
[10:19:20.956]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.956]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.956]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.956]         on.exit(options(oopts), add = TRUE)
[10:19:20.956]     }
[10:19:20.956]     {
[10:19:20.956]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:20.956]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.956]         do.call(mapply, args = args)
[10:19:20.956]     }
[10:19:20.956] }
[10:19:20.956] Lazy evaluation: FALSE
[10:19:20.956] Asynchronous evaluation: FALSE
[10:19:20.956] Local evaluation: TRUE
[10:19:20.956] Environment: R_GlobalEnv
[10:19:20.956] Capture standard output: TRUE
[10:19:20.956] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.956] Globals: 5 objects totaling 668 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.956] Packages: <none>
[10:19:20.956] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:20.956] Resolved: TRUE
[10:19:20.956] Value: 217 bytes of class ‘list’
[10:19:20.956] Early signaling: FALSE
[10:19:20.956] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.956] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.957] Chunk #1 of 1 ... DONE
[10:19:20.957] Launching 1 futures (chunks) ... DONE
[10:19:20.957] Resolving 1 futures (chunks) ...
[10:19:20.957] resolve() on list ...
[10:19:20.957]  recursive: 0
[10:19:20.957]  length: 1
[10:19:20.957] 
[10:19:20.957] resolved() for ‘SequentialFuture’ ...
[10:19:20.957] - state: ‘finished’
[10:19:20.957] - run: TRUE
[10:19:20.958] - result: ‘FutureResult’
[10:19:20.958] resolved() for ‘SequentialFuture’ ... done
[10:19:20.958] Future #1
[10:19:20.958] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.958] - nx: 1
[10:19:20.958] - relay: TRUE
[10:19:20.958] - stdout: TRUE
[10:19:20.958] - signal: TRUE
[10:19:20.958] - resignal: FALSE
[10:19:20.958] - force: TRUE
[10:19:20.958] - relayed: [n=1] FALSE
[10:19:20.958] - queued futures: [n=1] FALSE
[10:19:20.959]  - until=1
[10:19:20.959]  - relaying element #1
[10:19:20.959] - relayed: [n=1] TRUE
[10:19:20.959] - queued futures: [n=1] TRUE
[10:19:20.959] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.959]  length: 0 (resolved future 1)
[10:19:20.959] Relaying remaining futures
[10:19:20.959] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.959] - nx: 1
[10:19:20.959] - relay: TRUE
[10:19:20.959] - stdout: TRUE
[10:19:20.959] - signal: TRUE
[10:19:20.960] - resignal: FALSE
[10:19:20.960] - force: TRUE
[10:19:20.960] - relayed: [n=1] TRUE
[10:19:20.960] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.960] - relayed: [n=1] TRUE
[10:19:20.960] - queued futures: [n=1] TRUE
[10:19:20.960] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.960] resolve() on list ... DONE
[10:19:20.960]  - Number of value chunks collected: 1
[10:19:20.960] Resolving 1 futures (chunks) ... DONE
[10:19:20.960] Reducing values from 1 chunks ...
[10:19:20.961]  - Number of values collected after concatenation: 2
[10:19:20.961]  - Number of values expected: 2
[10:19:20.961] Reducing values from 1 chunks ... DONE
[10:19:20.961] future_mapply() ... DONE
[10:19:20.961] future_mapply() ...
[10:19:20.961] Generating random seeds ...
[10:19:20.961] Generating random seed streams for 2 elements ...
[10:19:20.961] Generating random seed streams for 2 elements ... DONE
[10:19:20.961] Generating random seeds ... DONE
[10:19:20.961] Will set RNG state on exit: 10407, 1882104135, 309052741, -1148982459, -1875332049, 1128907104, 2048926850
[10:19:20.962] Number of chunks: 1
[10:19:20.962] getGlobalsAndPackagesXApply() ...
[10:19:20.962]  - future.globals: TRUE
[10:19:20.962] getGlobalsAndPackages() ...
[10:19:20.962] Searching for globals...
[10:19:20.963] - globals found: [1] ‘FUN’
[10:19:20.963] Searching for globals ... DONE
[10:19:20.963] Resolving globals: FALSE
[10:19:20.963] The total size of the 1 globals is 326 bytes (326 bytes)
[10:19:20.964] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:19:20.964] - globals: [1] ‘FUN’
[10:19:20.964] 
[10:19:20.964] getGlobalsAndPackages() ... DONE
[10:19:20.964]  - globals found/used: [n=1] ‘FUN’
[10:19:20.964]  - needed namespaces: [n=0] 
[10:19:20.964] Finding globals ... DONE
[10:19:20.964] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.964] List of 2
[10:19:20.964]  $ ...future.FUN:function (x, y)  
[10:19:20.964]  $ MoreArgs     :List of 1
[10:19:20.964]   ..$ y: int [1:2] 3 4
[10:19:20.964]  - attr(*, "where")=List of 2
[10:19:20.964]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.964]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.964]  - attr(*, "resolved")= logi FALSE
[10:19:20.964]  - attr(*, "total_size")= num NA
[10:19:20.968] Packages to be attached in all futures: [n=0] 
[10:19:20.969] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.969] Number of futures (= number of chunks): 1
[10:19:20.969] Launching 1 futures (chunks) ...
[10:19:20.969] Chunk #1 of 1 ...
[10:19:20.969]  - Finding globals in '...' for chunk #1 ...
[10:19:20.969] getGlobalsAndPackages() ...
[10:19:20.969] Searching for globals...
[10:19:20.969] 
[10:19:20.970] Searching for globals ... DONE
[10:19:20.970] - globals: [0] <none>
[10:19:20.970] getGlobalsAndPackages() ... DONE
[10:19:20.970]    + additional globals found: [n=0] 
[10:19:20.970]    + additional namespaces needed: [n=0] 
[10:19:20.970]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.970]  - seeds: [2] <seeds>
[10:19:20.970]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.970] getGlobalsAndPackages() ...
[10:19:20.970] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.970] Resolving globals: FALSE
[10:19:20.971] The total size of the 5 globals is 744 bytes (744 bytes)
[10:19:20.971] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 744 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (105 bytes of class ‘list’)
[10:19:20.971] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.972] 
[10:19:20.972] getGlobalsAndPackages() ... DONE
[10:19:20.972] run() for ‘Future’ ...
[10:19:20.972] - state: ‘created’
[10:19:20.972] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:20.972] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:20.973]   - Field: ‘label’
[10:19:20.973]   - Field: ‘local’
[10:19:20.973]   - Field: ‘owner’
[10:19:20.973]   - Field: ‘envir’
[10:19:20.973]   - Field: ‘packages’
[10:19:20.973]   - Field: ‘gc’
[10:19:20.973]   - Field: ‘conditions’
[10:19:20.973]   - Field: ‘expr’
[10:19:20.973]   - Field: ‘uuid’
[10:19:20.973]   - Field: ‘seed’
[10:19:20.973]   - Field: ‘version’
[10:19:20.973]   - Field: ‘result’
[10:19:20.973]   - Field: ‘asynchronous’
[10:19:20.974]   - Field: ‘calls’
[10:19:20.974]   - Field: ‘globals’
[10:19:20.974]   - Field: ‘stdout’
[10:19:20.974]   - Field: ‘earlySignal’
[10:19:20.974]   - Field: ‘lazy’
[10:19:20.974]   - Field: ‘state’
[10:19:20.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:20.974] - Launch lazy future ...
[10:19:20.974] Packages needed by the future expression (n = 0): <none>
[10:19:20.974] Packages needed by future strategies (n = 0): <none>
[10:19:20.975] {
[10:19:20.975]     {
[10:19:20.975]         {
[10:19:20.975]             ...future.startTime <- base::Sys.time()
[10:19:20.975]             {
[10:19:20.975]                 {
[10:19:20.975]                   {
[10:19:20.975]                     base::local({
[10:19:20.975]                       has_future <- base::requireNamespace("future", 
[10:19:20.975]                         quietly = TRUE)
[10:19:20.975]                       if (has_future) {
[10:19:20.975]                         ns <- base::getNamespace("future")
[10:19:20.975]                         version <- ns[[".package"]][["version"]]
[10:19:20.975]                         if (is.null(version)) 
[10:19:20.975]                           version <- utils::packageVersion("future")
[10:19:20.975]                       }
[10:19:20.975]                       else {
[10:19:20.975]                         version <- NULL
[10:19:20.975]                       }
[10:19:20.975]                       if (!has_future || version < "1.8.0") {
[10:19:20.975]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:20.975]                           "", base::R.version$version.string), 
[10:19:20.975]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:20.975]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:20.975]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:20.975]                             "release", "version")], collapse = " "), 
[10:19:20.975]                           hostname = base::Sys.info()[["nodename"]])
[10:19:20.975]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:20.975]                           info)
[10:19:20.975]                         info <- base::paste(info, collapse = "; ")
[10:19:20.975]                         if (!has_future) {
[10:19:20.975]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:20.975]                             info)
[10:19:20.975]                         }
[10:19:20.975]                         else {
[10:19:20.975]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:20.975]                             info, version)
[10:19:20.975]                         }
[10:19:20.975]                         base::stop(msg)
[10:19:20.975]                       }
[10:19:20.975]                     })
[10:19:20.975]                   }
[10:19:20.975]                   ...future.strategy.old <- future::plan("list")
[10:19:20.975]                   options(future.plan = NULL)
[10:19:20.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:20.975]                 }
[10:19:20.975]                 ...future.workdir <- getwd()
[10:19:20.975]             }
[10:19:20.975]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:20.975]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:20.975]         }
[10:19:20.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:20.975]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:20.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:20.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:20.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:20.975]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:20.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:20.975]             base::names(...future.oldOptions))
[10:19:20.975]     }
[10:19:20.975]     if (FALSE) {
[10:19:20.975]     }
[10:19:20.975]     else {
[10:19:20.975]         if (TRUE) {
[10:19:20.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:20.975]                 open = "w")
[10:19:20.975]         }
[10:19:20.975]         else {
[10:19:20.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:20.975]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:20.975]         }
[10:19:20.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:20.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:20.975]             base::sink(type = "output", split = FALSE)
[10:19:20.975]             base::close(...future.stdout)
[10:19:20.975]         }, add = TRUE)
[10:19:20.975]     }
[10:19:20.975]     ...future.frame <- base::sys.nframe()
[10:19:20.975]     ...future.conditions <- base::list()
[10:19:20.975]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:20.975]     if (FALSE) {
[10:19:20.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:20.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:20.975]     }
[10:19:20.975]     ...future.result <- base::tryCatch({
[10:19:20.975]         base::withCallingHandlers({
[10:19:20.975]             ...future.value <- base::withVisible(base::local({
[10:19:20.975]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.975]                 if (!identical(...future.globals.maxSize.org, 
[10:19:20.975]                   ...future.globals.maxSize)) {
[10:19:20.975]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.975]                   on.exit(options(oopts), add = TRUE)
[10:19:20.975]                 }
[10:19:20.975]                 {
[10:19:20.975]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:20.975]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:20.975]                       envir = globalenv(), inherits = FALSE)
[10:19:20.975]                     ...future.FUN(...)
[10:19:20.975]                   }
[10:19:20.975]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:20.975]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:20.975]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:20.975]                     USE.NAMES = FALSE)
[10:19:20.975]                   do.call(mapply, args = args)
[10:19:20.975]                 }
[10:19:20.975]             }))
[10:19:20.975]             future::FutureResult(value = ...future.value$value, 
[10:19:20.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.975]                   ...future.rng), globalenv = if (FALSE) 
[10:19:20.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:20.975]                     ...future.globalenv.names))
[10:19:20.975]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:20.975]         }, condition = base::local({
[10:19:20.975]             c <- base::c
[10:19:20.975]             inherits <- base::inherits
[10:19:20.975]             invokeRestart <- base::invokeRestart
[10:19:20.975]             length <- base::length
[10:19:20.975]             list <- base::list
[10:19:20.975]             seq.int <- base::seq.int
[10:19:20.975]             signalCondition <- base::signalCondition
[10:19:20.975]             sys.calls <- base::sys.calls
[10:19:20.975]             `[[` <- base::`[[`
[10:19:20.975]             `+` <- base::`+`
[10:19:20.975]             `<<-` <- base::`<<-`
[10:19:20.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:20.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:20.975]                   3L)]
[10:19:20.975]             }
[10:19:20.975]             function(cond) {
[10:19:20.975]                 is_error <- inherits(cond, "error")
[10:19:20.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:20.975]                   NULL)
[10:19:20.975]                 if (is_error) {
[10:19:20.975]                   sessionInformation <- function() {
[10:19:20.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:20.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:20.975]                       search = base::search(), system = base::Sys.info())
[10:19:20.975]                   }
[10:19:20.975]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:20.975]                     cond$call), session = sessionInformation(), 
[10:19:20.975]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:20.975]                   signalCondition(cond)
[10:19:20.975]                 }
[10:19:20.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:20.975]                 "immediateCondition"))) {
[10:19:20.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:20.975]                   ...future.conditions[[length(...future.conditions) + 
[10:19:20.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:20.975]                   if (TRUE && !signal) {
[10:19:20.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.975]                     {
[10:19:20.975]                       inherits <- base::inherits
[10:19:20.975]                       invokeRestart <- base::invokeRestart
[10:19:20.975]                       is.null <- base::is.null
[10:19:20.975]                       muffled <- FALSE
[10:19:20.975]                       if (inherits(cond, "message")) {
[10:19:20.975]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.975]                         if (muffled) 
[10:19:20.975]                           invokeRestart("muffleMessage")
[10:19:20.975]                       }
[10:19:20.975]                       else if (inherits(cond, "warning")) {
[10:19:20.975]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.975]                         if (muffled) 
[10:19:20.975]                           invokeRestart("muffleWarning")
[10:19:20.975]                       }
[10:19:20.975]                       else if (inherits(cond, "condition")) {
[10:19:20.975]                         if (!is.null(pattern)) {
[10:19:20.975]                           computeRestarts <- base::computeRestarts
[10:19:20.975]                           grepl <- base::grepl
[10:19:20.975]                           restarts <- computeRestarts(cond)
[10:19:20.975]                           for (restart in restarts) {
[10:19:20.975]                             name <- restart$name
[10:19:20.975]                             if (is.null(name)) 
[10:19:20.975]                               next
[10:19:20.975]                             if (!grepl(pattern, name)) 
[10:19:20.975]                               next
[10:19:20.975]                             invokeRestart(restart)
[10:19:20.975]                             muffled <- TRUE
[10:19:20.975]                             break
[10:19:20.975]                           }
[10:19:20.975]                         }
[10:19:20.975]                       }
[10:19:20.975]                       invisible(muffled)
[10:19:20.975]                     }
[10:19:20.975]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.975]                   }
[10:19:20.975]                 }
[10:19:20.975]                 else {
[10:19:20.975]                   if (TRUE) {
[10:19:20.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:20.975]                     {
[10:19:20.975]                       inherits <- base::inherits
[10:19:20.975]                       invokeRestart <- base::invokeRestart
[10:19:20.975]                       is.null <- base::is.null
[10:19:20.975]                       muffled <- FALSE
[10:19:20.975]                       if (inherits(cond, "message")) {
[10:19:20.975]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:20.975]                         if (muffled) 
[10:19:20.975]                           invokeRestart("muffleMessage")
[10:19:20.975]                       }
[10:19:20.975]                       else if (inherits(cond, "warning")) {
[10:19:20.975]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:20.975]                         if (muffled) 
[10:19:20.975]                           invokeRestart("muffleWarning")
[10:19:20.975]                       }
[10:19:20.975]                       else if (inherits(cond, "condition")) {
[10:19:20.975]                         if (!is.null(pattern)) {
[10:19:20.975]                           computeRestarts <- base::computeRestarts
[10:19:20.975]                           grepl <- base::grepl
[10:19:20.975]                           restarts <- computeRestarts(cond)
[10:19:20.975]                           for (restart in restarts) {
[10:19:20.975]                             name <- restart$name
[10:19:20.975]                             if (is.null(name)) 
[10:19:20.975]                               next
[10:19:20.975]                             if (!grepl(pattern, name)) 
[10:19:20.975]                               next
[10:19:20.975]                             invokeRestart(restart)
[10:19:20.975]                             muffled <- TRUE
[10:19:20.975]                             break
[10:19:20.975]                           }
[10:19:20.975]                         }
[10:19:20.975]                       }
[10:19:20.975]                       invisible(muffled)
[10:19:20.975]                     }
[10:19:20.975]                     muffleCondition(cond, pattern = "^muffle")
[10:19:20.975]                   }
[10:19:20.975]                 }
[10:19:20.975]             }
[10:19:20.975]         }))
[10:19:20.975]     }, error = function(ex) {
[10:19:20.975]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:20.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:20.975]                 ...future.rng), started = ...future.startTime, 
[10:19:20.975]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:20.975]             version = "1.8"), class = "FutureResult")
[10:19:20.975]     }, finally = {
[10:19:20.975]         if (!identical(...future.workdir, getwd())) 
[10:19:20.975]             setwd(...future.workdir)
[10:19:20.975]         {
[10:19:20.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:20.975]                 ...future.oldOptions$nwarnings <- NULL
[10:19:20.975]             }
[10:19:20.975]             base::options(...future.oldOptions)
[10:19:20.975]             if (.Platform$OS.type == "windows") {
[10:19:20.975]                 old_names <- names(...future.oldEnvVars)
[10:19:20.975]                 envs <- base::Sys.getenv()
[10:19:20.975]                 names <- names(envs)
[10:19:20.975]                 common <- intersect(names, old_names)
[10:19:20.975]                 added <- setdiff(names, old_names)
[10:19:20.975]                 removed <- setdiff(old_names, names)
[10:19:20.975]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:20.975]                   envs[common]]
[10:19:20.975]                 NAMES <- toupper(changed)
[10:19:20.975]                 args <- list()
[10:19:20.975]                 for (kk in seq_along(NAMES)) {
[10:19:20.975]                   name <- changed[[kk]]
[10:19:20.975]                   NAME <- NAMES[[kk]]
[10:19:20.975]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.975]                     next
[10:19:20.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.975]                 }
[10:19:20.975]                 NAMES <- toupper(added)
[10:19:20.975]                 for (kk in seq_along(NAMES)) {
[10:19:20.975]                   name <- added[[kk]]
[10:19:20.975]                   NAME <- NAMES[[kk]]
[10:19:20.975]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.975]                     next
[10:19:20.975]                   args[[name]] <- ""
[10:19:20.975]                 }
[10:19:20.975]                 NAMES <- toupper(removed)
[10:19:20.975]                 for (kk in seq_along(NAMES)) {
[10:19:20.975]                   name <- removed[[kk]]
[10:19:20.975]                   NAME <- NAMES[[kk]]
[10:19:20.975]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:20.975]                     next
[10:19:20.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:20.975]                 }
[10:19:20.975]                 if (length(args) > 0) 
[10:19:20.975]                   base::do.call(base::Sys.setenv, args = args)
[10:19:20.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:20.975]             }
[10:19:20.975]             else {
[10:19:20.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:20.975]             }
[10:19:20.975]             {
[10:19:20.975]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:20.975]                   0L) {
[10:19:20.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:20.975]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:20.975]                   base::options(opts)
[10:19:20.975]                 }
[10:19:20.975]                 {
[10:19:20.975]                   {
[10:19:20.975]                     base::assign(".Random.seed", c(10407L, 1882104135L, 
[10:19:20.975]                     309052741L, -1148982459L, -1875332049L, 1128907104L, 
[10:19:20.975]                     2048926850L), envir = base::globalenv(), 
[10:19:20.975]                       inherits = FALSE)
[10:19:20.975]                     NULL
[10:19:20.975]                   }
[10:19:20.975]                   options(future.plan = NULL)
[10:19:20.975]                   if (is.na(NA_character_)) 
[10:19:20.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:20.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:20.975]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:20.975]                     .init = FALSE)
[10:19:20.975]                 }
[10:19:20.975]             }
[10:19:20.975]         }
[10:19:20.975]     })
[10:19:20.975]     if (TRUE) {
[10:19:20.975]         base::sink(type = "output", split = FALSE)
[10:19:20.975]         if (TRUE) {
[10:19:20.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:20.975]         }
[10:19:20.975]         else {
[10:19:20.975]             ...future.result["stdout"] <- base::list(NULL)
[10:19:20.975]         }
[10:19:20.975]         base::close(...future.stdout)
[10:19:20.975]         ...future.stdout <- NULL
[10:19:20.975]     }
[10:19:20.975]     ...future.result$conditions <- ...future.conditions
[10:19:20.975]     ...future.result$finished <- base::Sys.time()
[10:19:20.975]     ...future.result
[10:19:20.975] }
[10:19:20.977] assign_globals() ...
[10:19:20.977] List of 5
[10:19:20.977]  $ ...future.FUN            :function (x, y)  
[10:19:20.977]  $ MoreArgs                 :List of 1
[10:19:20.977]   ..$ y: int [1:2] 3 4
[10:19:20.977]  $ ...future.elements_ii    :List of 1
[10:19:20.977]   ..$ x:List of 2
[10:19:20.977]   .. ..$ : int 1
[10:19:20.977]   .. ..$ : int 2
[10:19:20.977]  $ ...future.seeds_ii       :List of 2
[10:19:20.977]   ..$ : int [1:7] 10407 135907218 896799533 200318199 73997638 -127388449 2083658269
[10:19:20.977]   ..$ : int [1:7] 10407 -1594840019 -1385810350 -163244244 852405865 -1417681927 -403165421
[10:19:20.977]  $ ...future.globals.maxSize: NULL
[10:19:20.977]  - attr(*, "where")=List of 5
[10:19:20.977]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:20.977]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:20.977]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:20.977]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:20.977]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:20.977]  - attr(*, "resolved")= logi FALSE
[10:19:20.977]  - attr(*, "total_size")= num 744
[10:19:20.977]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.977]  - attr(*, "already-done")= logi TRUE
[10:19:20.982] - reassign environment for ‘...future.FUN’
[10:19:20.982] - copied ‘...future.FUN’ to environment
[10:19:20.982] - copied ‘MoreArgs’ to environment
[10:19:20.982] - copied ‘...future.elements_ii’ to environment
[10:19:20.982] - copied ‘...future.seeds_ii’ to environment
[10:19:20.982] - copied ‘...future.globals.maxSize’ to environment
[10:19:20.983] assign_globals() ... done
[10:19:20.983] plan(): Setting new future strategy stack:
[10:19:20.983] List of future strategies:
[10:19:20.983] 1. sequential:
[10:19:20.983]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.983]    - tweaked: FALSE
[10:19:20.983]    - call: NULL
[10:19:20.983] plan(): nbrOfWorkers() = 1
[10:19:20.984] plan(): Setting new future strategy stack:
[10:19:20.984] List of future strategies:
[10:19:20.984] 1. sequential:
[10:19:20.984]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:20.984]    - tweaked: FALSE
[10:19:20.984]    - call: plan(strategy)
[10:19:20.985] plan(): nbrOfWorkers() = 1
[10:19:20.985] SequentialFuture started (and completed)
[10:19:20.985] - Launch lazy future ... done
[10:19:20.985] run() for ‘SequentialFuture’ ... done
[10:19:20.985] Created future:
[10:19:20.985] SequentialFuture:
[10:19:20.985] Label: ‘future_mapply-1’
[10:19:20.985] Expression:
[10:19:20.985] {
[10:19:20.985]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:20.985]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:20.985]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:20.985]         on.exit(options(oopts), add = TRUE)
[10:19:20.985]     }
[10:19:20.985]     {
[10:19:20.985]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:20.985]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:20.985]                 inherits = FALSE)
[10:19:20.985]             ...future.FUN(...)
[10:19:20.985]         }
[10:19:20.985]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:20.985]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:20.985]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:20.985]         do.call(mapply, args = args)
[10:19:20.985]     }
[10:19:20.985] }
[10:19:20.985] Lazy evaluation: FALSE
[10:19:20.985] Asynchronous evaluation: FALSE
[10:19:20.985] Local evaluation: TRUE
[10:19:20.985] Environment: R_GlobalEnv
[10:19:20.985] Capture standard output: TRUE
[10:19:20.985] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:20.985] Globals: 5 objects totaling 744 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 105 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:20.985] Packages: <none>
[10:19:20.985] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:20.985] Resolved: TRUE
[10:19:20.985] Value: 217 bytes of class ‘list’
[10:19:20.985] Early signaling: FALSE
[10:19:20.985] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:20.985] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:20.986] Chunk #1 of 1 ... DONE
[10:19:20.986] Launching 1 futures (chunks) ... DONE
[10:19:20.986] Resolving 1 futures (chunks) ...
[10:19:20.986] resolve() on list ...
[10:19:20.986]  recursive: 0
[10:19:20.986]  length: 1
[10:19:20.986] 
[10:19:20.986] resolved() for ‘SequentialFuture’ ...
[10:19:20.987] - state: ‘finished’
[10:19:20.988] - run: TRUE
[10:19:20.988] - result: ‘FutureResult’
[10:19:20.988] resolved() for ‘SequentialFuture’ ... done
[10:19:20.988] Future #1
[10:19:20.989] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:20.989] - nx: 1
[10:19:20.989] - relay: TRUE
[10:19:20.989] - stdout: TRUE
[10:19:20.989] - signal: TRUE
[10:19:20.989] - resignal: FALSE
[10:19:20.989] - force: TRUE
[10:19:20.989] - relayed: [n=1] FALSE
[10:19:20.989] - queued futures: [n=1] FALSE
[10:19:20.989]  - until=1
[10:19:20.989]  - relaying element #1
[10:19:20.990] - relayed: [n=1] TRUE
[10:19:20.990] - queued futures: [n=1] TRUE
[10:19:20.990] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:20.990]  length: 0 (resolved future 1)
[10:19:20.990] Relaying remaining futures
[10:19:20.990] signalConditionsASAP(NULL, pos=0) ...
[10:19:20.990] - nx: 1
[10:19:20.990] - relay: TRUE
[10:19:20.990] - stdout: TRUE
[10:19:20.990] - signal: TRUE
[10:19:20.990] - resignal: FALSE
[10:19:20.991] - force: TRUE
[10:19:20.991] - relayed: [n=1] TRUE
[10:19:20.991] - queued futures: [n=1] TRUE
 - flush all
[10:19:20.991] - relayed: [n=1] TRUE
[10:19:20.991] - queued futures: [n=1] TRUE
[10:19:20.991] signalConditionsASAP(NULL, pos=0) ... done
[10:19:20.991] resolve() on list ... DONE
[10:19:20.991]  - Number of value chunks collected: 1
[10:19:20.991] Resolving 1 futures (chunks) ... DONE
[10:19:20.991] Reducing values from 1 chunks ...
[10:19:20.991]  - Number of values collected after concatenation: 2
[10:19:20.991]  - Number of values expected: 2
[10:19:20.992] Reducing values from 1 chunks ... DONE
[10:19:20.992] future_mapply() ... DONE
[10:19:20.992] future_mapply() ...
[10:19:20.992] Number of chunks: 1
[10:19:20.992] getGlobalsAndPackagesXApply() ...
[10:19:20.992]  - future.globals: TRUE
[10:19:20.992] getGlobalsAndPackages() ...
[10:19:20.992] Searching for globals...
[10:19:20.993] - globals found: [1] ‘FUN’
[10:19:20.993] Searching for globals ... DONE
[10:19:20.993] Resolving globals: FALSE
[10:19:20.994] The total size of the 1 globals is 326 bytes (326 bytes)
[10:19:20.994] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:19:20.994] - globals: [1] ‘FUN’
[10:19:20.994] 
[10:19:20.994] getGlobalsAndPackages() ... DONE
[10:19:20.994]  - globals found/used: [n=1] ‘FUN’
[10:19:20.994]  - needed namespaces: [n=0] 
[10:19:20.995] Finding globals ... DONE
[10:19:20.995] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:20.995] List of 2
[10:19:20.995]  $ ...future.FUN:function (x, y)  
[10:19:20.995]  $ MoreArgs     :List of 1
[10:19:20.995]   ..$ y: int [1:2] 3 4
[10:19:20.995]  - attr(*, "where")=List of 2
[10:19:20.995]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:20.995]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:20.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:20.995]  - attr(*, "resolved")= logi FALSE
[10:19:20.995]  - attr(*, "total_size")= num NA
[10:19:20.997] Packages to be attached in all futures: [n=0] 
[10:19:20.998] getGlobalsAndPackagesXApply() ... DONE
[10:19:20.998] Number of futures (= number of chunks): 1
[10:19:20.998] Launching 1 futures (chunks) ...
[10:19:20.998] Chunk #1 of 1 ...
[10:19:20.998]  - Finding globals in '...' for chunk #1 ...
[10:19:20.998] getGlobalsAndPackages() ...
[10:19:20.998] Searching for globals...
[10:19:20.998] 
[10:19:20.999] Searching for globals ... DONE
[10:19:20.999] - globals: [0] <none>
[10:19:20.999] getGlobalsAndPackages() ... DONE
[10:19:20.999]    + additional globals found: [n=0] 
[10:19:20.999]    + additional namespaces needed: [n=0] 
[10:19:20.999]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:20.999]  - seeds: <none>
[10:19:20.999]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.999] getGlobalsAndPackages() ...
[10:19:20.999] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:20.999] Resolving globals: FALSE
[10:19:21.000] The total size of the 5 globals is 668 bytes (668 bytes)
[10:19:21.000] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 668 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (105 bytes of class ‘list’)
[10:19:21.000] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.000] 
[10:19:21.001] getGlobalsAndPackages() ... DONE
[10:19:21.001] run() for ‘Future’ ...
[10:19:21.001] - state: ‘created’
[10:19:21.001] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:21.001] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:21.001]   - Field: ‘label’
[10:19:21.002]   - Field: ‘local’
[10:19:21.002]   - Field: ‘owner’
[10:19:21.002]   - Field: ‘envir’
[10:19:21.002]   - Field: ‘packages’
[10:19:21.002]   - Field: ‘gc’
[10:19:21.002]   - Field: ‘conditions’
[10:19:21.002]   - Field: ‘expr’
[10:19:21.002]   - Field: ‘uuid’
[10:19:21.002]   - Field: ‘seed’
[10:19:21.002]   - Field: ‘version’
[10:19:21.002]   - Field: ‘result’
[10:19:21.002]   - Field: ‘asynchronous’
[10:19:21.003]   - Field: ‘calls’
[10:19:21.003]   - Field: ‘globals’
[10:19:21.003]   - Field: ‘stdout’
[10:19:21.003]   - Field: ‘earlySignal’
[10:19:21.003]   - Field: ‘lazy’
[10:19:21.003]   - Field: ‘state’
[10:19:21.003] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:21.003] - Launch lazy future ...
[10:19:21.003] Packages needed by the future expression (n = 0): <none>
[10:19:21.003] Packages needed by future strategies (n = 0): <none>
[10:19:21.004] {
[10:19:21.004]     {
[10:19:21.004]         {
[10:19:21.004]             ...future.startTime <- base::Sys.time()
[10:19:21.004]             {
[10:19:21.004]                 {
[10:19:21.004]                   {
[10:19:21.004]                     base::local({
[10:19:21.004]                       has_future <- base::requireNamespace("future", 
[10:19:21.004]                         quietly = TRUE)
[10:19:21.004]                       if (has_future) {
[10:19:21.004]                         ns <- base::getNamespace("future")
[10:19:21.004]                         version <- ns[[".package"]][["version"]]
[10:19:21.004]                         if (is.null(version)) 
[10:19:21.004]                           version <- utils::packageVersion("future")
[10:19:21.004]                       }
[10:19:21.004]                       else {
[10:19:21.004]                         version <- NULL
[10:19:21.004]                       }
[10:19:21.004]                       if (!has_future || version < "1.8.0") {
[10:19:21.004]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.004]                           "", base::R.version$version.string), 
[10:19:21.004]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:21.004]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.004]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.004]                             "release", "version")], collapse = " "), 
[10:19:21.004]                           hostname = base::Sys.info()[["nodename"]])
[10:19:21.004]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.004]                           info)
[10:19:21.004]                         info <- base::paste(info, collapse = "; ")
[10:19:21.004]                         if (!has_future) {
[10:19:21.004]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.004]                             info)
[10:19:21.004]                         }
[10:19:21.004]                         else {
[10:19:21.004]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.004]                             info, version)
[10:19:21.004]                         }
[10:19:21.004]                         base::stop(msg)
[10:19:21.004]                       }
[10:19:21.004]                     })
[10:19:21.004]                   }
[10:19:21.004]                   ...future.strategy.old <- future::plan("list")
[10:19:21.004]                   options(future.plan = NULL)
[10:19:21.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.004]                 }
[10:19:21.004]                 ...future.workdir <- getwd()
[10:19:21.004]             }
[10:19:21.004]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.004]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.004]         }
[10:19:21.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:21.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.004]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.004]             base::names(...future.oldOptions))
[10:19:21.004]     }
[10:19:21.004]     if (FALSE) {
[10:19:21.004]     }
[10:19:21.004]     else {
[10:19:21.004]         if (TRUE) {
[10:19:21.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.004]                 open = "w")
[10:19:21.004]         }
[10:19:21.004]         else {
[10:19:21.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.004]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.004]         }
[10:19:21.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.004]             base::sink(type = "output", split = FALSE)
[10:19:21.004]             base::close(...future.stdout)
[10:19:21.004]         }, add = TRUE)
[10:19:21.004]     }
[10:19:21.004]     ...future.frame <- base::sys.nframe()
[10:19:21.004]     ...future.conditions <- base::list()
[10:19:21.004]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.004]     if (FALSE) {
[10:19:21.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.004]     }
[10:19:21.004]     ...future.result <- base::tryCatch({
[10:19:21.004]         base::withCallingHandlers({
[10:19:21.004]             ...future.value <- base::withVisible(base::local({
[10:19:21.004]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.004]                 if (!identical(...future.globals.maxSize.org, 
[10:19:21.004]                   ...future.globals.maxSize)) {
[10:19:21.004]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.004]                   on.exit(options(oopts), add = TRUE)
[10:19:21.004]                 }
[10:19:21.004]                 {
[10:19:21.004]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.004]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.004]                     USE.NAMES = FALSE)
[10:19:21.004]                   do.call(mapply, args = args)
[10:19:21.004]                 }
[10:19:21.004]             }))
[10:19:21.004]             future::FutureResult(value = ...future.value$value, 
[10:19:21.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.004]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.004]                     ...future.globalenv.names))
[10:19:21.004]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.004]         }, condition = base::local({
[10:19:21.004]             c <- base::c
[10:19:21.004]             inherits <- base::inherits
[10:19:21.004]             invokeRestart <- base::invokeRestart
[10:19:21.004]             length <- base::length
[10:19:21.004]             list <- base::list
[10:19:21.004]             seq.int <- base::seq.int
[10:19:21.004]             signalCondition <- base::signalCondition
[10:19:21.004]             sys.calls <- base::sys.calls
[10:19:21.004]             `[[` <- base::`[[`
[10:19:21.004]             `+` <- base::`+`
[10:19:21.004]             `<<-` <- base::`<<-`
[10:19:21.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.004]                   3L)]
[10:19:21.004]             }
[10:19:21.004]             function(cond) {
[10:19:21.004]                 is_error <- inherits(cond, "error")
[10:19:21.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.004]                   NULL)
[10:19:21.004]                 if (is_error) {
[10:19:21.004]                   sessionInformation <- function() {
[10:19:21.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.004]                       search = base::search(), system = base::Sys.info())
[10:19:21.004]                   }
[10:19:21.004]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.004]                     cond$call), session = sessionInformation(), 
[10:19:21.004]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.004]                   signalCondition(cond)
[10:19:21.004]                 }
[10:19:21.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.004]                 "immediateCondition"))) {
[10:19:21.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.004]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.004]                   if (TRUE && !signal) {
[10:19:21.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.004]                     {
[10:19:21.004]                       inherits <- base::inherits
[10:19:21.004]                       invokeRestart <- base::invokeRestart
[10:19:21.004]                       is.null <- base::is.null
[10:19:21.004]                       muffled <- FALSE
[10:19:21.004]                       if (inherits(cond, "message")) {
[10:19:21.004]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.004]                         if (muffled) 
[10:19:21.004]                           invokeRestart("muffleMessage")
[10:19:21.004]                       }
[10:19:21.004]                       else if (inherits(cond, "warning")) {
[10:19:21.004]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.004]                         if (muffled) 
[10:19:21.004]                           invokeRestart("muffleWarning")
[10:19:21.004]                       }
[10:19:21.004]                       else if (inherits(cond, "condition")) {
[10:19:21.004]                         if (!is.null(pattern)) {
[10:19:21.004]                           computeRestarts <- base::computeRestarts
[10:19:21.004]                           grepl <- base::grepl
[10:19:21.004]                           restarts <- computeRestarts(cond)
[10:19:21.004]                           for (restart in restarts) {
[10:19:21.004]                             name <- restart$name
[10:19:21.004]                             if (is.null(name)) 
[10:19:21.004]                               next
[10:19:21.004]                             if (!grepl(pattern, name)) 
[10:19:21.004]                               next
[10:19:21.004]                             invokeRestart(restart)
[10:19:21.004]                             muffled <- TRUE
[10:19:21.004]                             break
[10:19:21.004]                           }
[10:19:21.004]                         }
[10:19:21.004]                       }
[10:19:21.004]                       invisible(muffled)
[10:19:21.004]                     }
[10:19:21.004]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.004]                   }
[10:19:21.004]                 }
[10:19:21.004]                 else {
[10:19:21.004]                   if (TRUE) {
[10:19:21.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.004]                     {
[10:19:21.004]                       inherits <- base::inherits
[10:19:21.004]                       invokeRestart <- base::invokeRestart
[10:19:21.004]                       is.null <- base::is.null
[10:19:21.004]                       muffled <- FALSE
[10:19:21.004]                       if (inherits(cond, "message")) {
[10:19:21.004]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.004]                         if (muffled) 
[10:19:21.004]                           invokeRestart("muffleMessage")
[10:19:21.004]                       }
[10:19:21.004]                       else if (inherits(cond, "warning")) {
[10:19:21.004]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.004]                         if (muffled) 
[10:19:21.004]                           invokeRestart("muffleWarning")
[10:19:21.004]                       }
[10:19:21.004]                       else if (inherits(cond, "condition")) {
[10:19:21.004]                         if (!is.null(pattern)) {
[10:19:21.004]                           computeRestarts <- base::computeRestarts
[10:19:21.004]                           grepl <- base::grepl
[10:19:21.004]                           restarts <- computeRestarts(cond)
[10:19:21.004]                           for (restart in restarts) {
[10:19:21.004]                             name <- restart$name
[10:19:21.004]                             if (is.null(name)) 
[10:19:21.004]                               next
[10:19:21.004]                             if (!grepl(pattern, name)) 
[10:19:21.004]                               next
[10:19:21.004]                             invokeRestart(restart)
[10:19:21.004]                             muffled <- TRUE
[10:19:21.004]                             break
[10:19:21.004]                           }
[10:19:21.004]                         }
[10:19:21.004]                       }
[10:19:21.004]                       invisible(muffled)
[10:19:21.004]                     }
[10:19:21.004]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.004]                   }
[10:19:21.004]                 }
[10:19:21.004]             }
[10:19:21.004]         }))
[10:19:21.004]     }, error = function(ex) {
[10:19:21.004]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.004]                 ...future.rng), started = ...future.startTime, 
[10:19:21.004]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.004]             version = "1.8"), class = "FutureResult")
[10:19:21.004]     }, finally = {
[10:19:21.004]         if (!identical(...future.workdir, getwd())) 
[10:19:21.004]             setwd(...future.workdir)
[10:19:21.004]         {
[10:19:21.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.004]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.004]             }
[10:19:21.004]             base::options(...future.oldOptions)
[10:19:21.004]             if (.Platform$OS.type == "windows") {
[10:19:21.004]                 old_names <- names(...future.oldEnvVars)
[10:19:21.004]                 envs <- base::Sys.getenv()
[10:19:21.004]                 names <- names(envs)
[10:19:21.004]                 common <- intersect(names, old_names)
[10:19:21.004]                 added <- setdiff(names, old_names)
[10:19:21.004]                 removed <- setdiff(old_names, names)
[10:19:21.004]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.004]                   envs[common]]
[10:19:21.004]                 NAMES <- toupper(changed)
[10:19:21.004]                 args <- list()
[10:19:21.004]                 for (kk in seq_along(NAMES)) {
[10:19:21.004]                   name <- changed[[kk]]
[10:19:21.004]                   NAME <- NAMES[[kk]]
[10:19:21.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.004]                     next
[10:19:21.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.004]                 }
[10:19:21.004]                 NAMES <- toupper(added)
[10:19:21.004]                 for (kk in seq_along(NAMES)) {
[10:19:21.004]                   name <- added[[kk]]
[10:19:21.004]                   NAME <- NAMES[[kk]]
[10:19:21.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.004]                     next
[10:19:21.004]                   args[[name]] <- ""
[10:19:21.004]                 }
[10:19:21.004]                 NAMES <- toupper(removed)
[10:19:21.004]                 for (kk in seq_along(NAMES)) {
[10:19:21.004]                   name <- removed[[kk]]
[10:19:21.004]                   NAME <- NAMES[[kk]]
[10:19:21.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.004]                     next
[10:19:21.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.004]                 }
[10:19:21.004]                 if (length(args) > 0) 
[10:19:21.004]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.004]             }
[10:19:21.004]             else {
[10:19:21.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.004]             }
[10:19:21.004]             {
[10:19:21.004]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.004]                   0L) {
[10:19:21.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.004]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.004]                   base::options(opts)
[10:19:21.004]                 }
[10:19:21.004]                 {
[10:19:21.004]                   {
[10:19:21.004]                     base::assign(".Random.seed", c(10407L, 1882104135L, 
[10:19:21.004]                     309052741L, -1148982459L, -1875332049L, 1128907104L, 
[10:19:21.004]                     2048926850L), envir = base::globalenv(), 
[10:19:21.004]                       inherits = FALSE)
[10:19:21.004]                     NULL
[10:19:21.004]                   }
[10:19:21.004]                   options(future.plan = NULL)
[10:19:21.004]                   if (is.na(NA_character_)) 
[10:19:21.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.004]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.004]                     .init = FALSE)
[10:19:21.004]                 }
[10:19:21.004]             }
[10:19:21.004]         }
[10:19:21.004]     })
[10:19:21.004]     if (TRUE) {
[10:19:21.004]         base::sink(type = "output", split = FALSE)
[10:19:21.004]         if (TRUE) {
[10:19:21.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.004]         }
[10:19:21.004]         else {
[10:19:21.004]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.004]         }
[10:19:21.004]         base::close(...future.stdout)
[10:19:21.004]         ...future.stdout <- NULL
[10:19:21.004]     }
[10:19:21.004]     ...future.result$conditions <- ...future.conditions
[10:19:21.004]     ...future.result$finished <- base::Sys.time()
[10:19:21.004]     ...future.result
[10:19:21.004] }
[10:19:21.005] assign_globals() ...
[10:19:21.006] List of 5
[10:19:21.006]  $ ...future.FUN            :function (x, y)  
[10:19:21.006]  $ MoreArgs                 :List of 1
[10:19:21.006]   ..$ y: int [1:2] 3 4
[10:19:21.006]  $ ...future.elements_ii    :List of 1
[10:19:21.006]   ..$ x:List of 2
[10:19:21.006]   .. ..$ : int 1
[10:19:21.006]   .. ..$ : int 2
[10:19:21.006]  $ ...future.seeds_ii       : NULL
[10:19:21.006]  $ ...future.globals.maxSize: NULL
[10:19:21.006]  - attr(*, "where")=List of 5
[10:19:21.006]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.006]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.006]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.006]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.006]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.006]  - attr(*, "resolved")= logi FALSE
[10:19:21.006]  - attr(*, "total_size")= num 668
[10:19:21.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.006]  - attr(*, "already-done")= logi TRUE
[10:19:21.012] - reassign environment for ‘...future.FUN’
[10:19:21.012] - copied ‘...future.FUN’ to environment
[10:19:21.012] - copied ‘MoreArgs’ to environment
[10:19:21.012] - copied ‘...future.elements_ii’ to environment
[10:19:21.012] - copied ‘...future.seeds_ii’ to environment
[10:19:21.013] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.013] assign_globals() ... done
[10:19:21.013] plan(): Setting new future strategy stack:
[10:19:21.013] List of future strategies:
[10:19:21.013] 1. sequential:
[10:19:21.013]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.013]    - tweaked: FALSE
[10:19:21.013]    - call: NULL
[10:19:21.013] plan(): nbrOfWorkers() = 1
[10:19:21.014] plan(): Setting new future strategy stack:
[10:19:21.014] List of future strategies:
[10:19:21.014] 1. sequential:
[10:19:21.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.014]    - tweaked: FALSE
[10:19:21.014]    - call: plan(strategy)
[10:19:21.015] plan(): nbrOfWorkers() = 1
[10:19:21.015] SequentialFuture started (and completed)
[10:19:21.015] - Launch lazy future ... done
[10:19:21.015] run() for ‘SequentialFuture’ ... done
[10:19:21.015] Created future:
[10:19:21.015] SequentialFuture:
[10:19:21.015] Label: ‘future_.mapply-1’
[10:19:21.015] Expression:
[10:19:21.015] {
[10:19:21.015]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.015]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.015]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.015]         on.exit(options(oopts), add = TRUE)
[10:19:21.015]     }
[10:19:21.015]     {
[10:19:21.015]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.015]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.015]         do.call(mapply, args = args)
[10:19:21.015]     }
[10:19:21.015] }
[10:19:21.015] Lazy evaluation: FALSE
[10:19:21.015] Asynchronous evaluation: FALSE
[10:19:21.015] Local evaluation: TRUE
[10:19:21.015] Environment: R_GlobalEnv
[10:19:21.015] Capture standard output: TRUE
[10:19:21.015] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.015] Globals: 5 objects totaling 668 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.015] Packages: <none>
[10:19:21.015] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.015] Resolved: TRUE
[10:19:21.015] Value: 217 bytes of class ‘list’
[10:19:21.015] Early signaling: FALSE
[10:19:21.015] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.015] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.016] Chunk #1 of 1 ... DONE
[10:19:21.016] Launching 1 futures (chunks) ... DONE
[10:19:21.016] Resolving 1 futures (chunks) ...
[10:19:21.016] resolve() on list ...
[10:19:21.016]  recursive: 0
[10:19:21.016]  length: 1
[10:19:21.016] 
[10:19:21.016] resolved() for ‘SequentialFuture’ ...
[10:19:21.017] - state: ‘finished’
[10:19:21.017] - run: TRUE
[10:19:21.017] - result: ‘FutureResult’
[10:19:21.017] resolved() for ‘SequentialFuture’ ... done
[10:19:21.017] Future #1
[10:19:21.017] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:21.017] - nx: 1
[10:19:21.017] - relay: TRUE
[10:19:21.017] - stdout: TRUE
[10:19:21.017] - signal: TRUE
[10:19:21.017] - resignal: FALSE
[10:19:21.018] - force: TRUE
[10:19:21.018] - relayed: [n=1] FALSE
[10:19:21.018] - queued futures: [n=1] FALSE
[10:19:21.018]  - until=1
[10:19:21.018]  - relaying element #1
[10:19:21.018] - relayed: [n=1] TRUE
[10:19:21.018] - queued futures: [n=1] TRUE
[10:19:21.018] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:21.018]  length: 0 (resolved future 1)
[10:19:21.018] Relaying remaining futures
[10:19:21.018] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.018] - nx: 1
[10:19:21.019] - relay: TRUE
[10:19:21.019] - stdout: TRUE
[10:19:21.019] - signal: TRUE
[10:19:21.019] - resignal: FALSE
[10:19:21.019] - force: TRUE
[10:19:21.019] - relayed: [n=1] TRUE
[10:19:21.019] - queued futures: [n=1] TRUE
 - flush all
[10:19:21.019] - relayed: [n=1] TRUE
[10:19:21.019] - queued futures: [n=1] TRUE
[10:19:21.019] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.019] resolve() on list ... DONE
[10:19:21.019]  - Number of value chunks collected: 1
[10:19:21.020] Resolving 1 futures (chunks) ... DONE
[10:19:21.020] Reducing values from 1 chunks ...
[10:19:21.020]  - Number of values collected after concatenation: 2
[10:19:21.020]  - Number of values expected: 2
[10:19:21.020] Reducing values from 1 chunks ... DONE
[10:19:21.020] future_mapply() ... DONE
- Recycle arguments to same length ...
[10:19:21.020] future_mapply() ...
[10:19:21.020] Number of chunks: 1
[10:19:21.020] getGlobalsAndPackagesXApply() ...
[10:19:21.020]  - future.globals: TRUE
[10:19:21.021] getGlobalsAndPackages() ...
[10:19:21.021] Searching for globals...
[10:19:21.021] - globals found: [1] ‘FUN’
[10:19:21.021] Searching for globals ... DONE
[10:19:21.021] Resolving globals: FALSE
[10:19:21.022] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:21.022] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:21.022] - globals: [1] ‘FUN’
[10:19:21.022] 
[10:19:21.022] getGlobalsAndPackages() ... DONE
[10:19:21.022]  - globals found/used: [n=1] ‘FUN’
[10:19:21.022]  - needed namespaces: [n=0] 
[10:19:21.022] Finding globals ... DONE
[10:19:21.023] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.023] List of 2
[10:19:21.023]  $ ...future.FUN:function (x, ...)  
[10:19:21.023]  $ MoreArgs     : NULL
[10:19:21.023]  - attr(*, "where")=List of 2
[10:19:21.023]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.023]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.023]  - attr(*, "resolved")= logi FALSE
[10:19:21.023]  - attr(*, "total_size")= num NA
[10:19:21.025] Packages to be attached in all futures: [n=0] 
[10:19:21.025] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.026] Number of futures (= number of chunks): 1
[10:19:21.026] Launching 1 futures (chunks) ...
[10:19:21.026] Chunk #1 of 1 ...
[10:19:21.026]  - Finding globals in '...' for chunk #1 ...
[10:19:21.026] getGlobalsAndPackages() ...
[10:19:21.026] Searching for globals...
[10:19:21.027] 
[10:19:21.027] Searching for globals ... DONE
[10:19:21.027] - globals: [0] <none>
[10:19:21.027] getGlobalsAndPackages() ... DONE
[10:19:21.027]    + additional globals found: [n=0] 
[10:19:21.027]    + additional namespaces needed: [n=0] 
[10:19:21.027]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.027]  - seeds: <none>
[10:19:21.028]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.028] getGlobalsAndPackages() ...
[10:19:21.028] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.028] Resolving globals: FALSE
[10:19:21.029] The total size of the 5 globals is 258 bytes (258 bytes)
[10:19:21.029] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 258 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (143 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.029] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.029] 
[10:19:21.029] getGlobalsAndPackages() ... DONE
[10:19:21.030] run() for ‘Future’ ...
[10:19:21.030] - state: ‘created’
[10:19:21.030] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:21.030] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.030] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:21.030]   - Field: ‘label’
[10:19:21.030]   - Field: ‘local’
[10:19:21.032]   - Field: ‘owner’
[10:19:21.032]   - Field: ‘envir’
[10:19:21.032]   - Field: ‘packages’
[10:19:21.032]   - Field: ‘gc’
[10:19:21.032]   - Field: ‘conditions’
[10:19:21.033]   - Field: ‘expr’
[10:19:21.033]   - Field: ‘uuid’
[10:19:21.033]   - Field: ‘seed’
[10:19:21.033]   - Field: ‘version’
[10:19:21.033]   - Field: ‘result’
[10:19:21.033]   - Field: ‘asynchronous’
[10:19:21.033]   - Field: ‘calls’
[10:19:21.033]   - Field: ‘globals’
[10:19:21.033]   - Field: ‘stdout’
[10:19:21.033]   - Field: ‘earlySignal’
[10:19:21.034]   - Field: ‘lazy’
[10:19:21.034]   - Field: ‘state’
[10:19:21.034] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:21.034] - Launch lazy future ...
[10:19:21.034] Packages needed by the future expression (n = 0): <none>
[10:19:21.034] Packages needed by future strategies (n = 0): <none>
[10:19:21.034] {
[10:19:21.034]     {
[10:19:21.034]         {
[10:19:21.034]             ...future.startTime <- base::Sys.time()
[10:19:21.034]             {
[10:19:21.034]                 {
[10:19:21.034]                   {
[10:19:21.034]                     base::local({
[10:19:21.034]                       has_future <- base::requireNamespace("future", 
[10:19:21.034]                         quietly = TRUE)
[10:19:21.034]                       if (has_future) {
[10:19:21.034]                         ns <- base::getNamespace("future")
[10:19:21.034]                         version <- ns[[".package"]][["version"]]
[10:19:21.034]                         if (is.null(version)) 
[10:19:21.034]                           version <- utils::packageVersion("future")
[10:19:21.034]                       }
[10:19:21.034]                       else {
[10:19:21.034]                         version <- NULL
[10:19:21.034]                       }
[10:19:21.034]                       if (!has_future || version < "1.8.0") {
[10:19:21.034]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.034]                           "", base::R.version$version.string), 
[10:19:21.034]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:21.034]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.034]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.034]                             "release", "version")], collapse = " "), 
[10:19:21.034]                           hostname = base::Sys.info()[["nodename"]])
[10:19:21.034]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.034]                           info)
[10:19:21.034]                         info <- base::paste(info, collapse = "; ")
[10:19:21.034]                         if (!has_future) {
[10:19:21.034]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.034]                             info)
[10:19:21.034]                         }
[10:19:21.034]                         else {
[10:19:21.034]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.034]                             info, version)
[10:19:21.034]                         }
[10:19:21.034]                         base::stop(msg)
[10:19:21.034]                       }
[10:19:21.034]                     })
[10:19:21.034]                   }
[10:19:21.034]                   ...future.strategy.old <- future::plan("list")
[10:19:21.034]                   options(future.plan = NULL)
[10:19:21.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.034]                 }
[10:19:21.034]                 ...future.workdir <- getwd()
[10:19:21.034]             }
[10:19:21.034]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.034]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.034]         }
[10:19:21.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:21.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.034]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.034]             base::names(...future.oldOptions))
[10:19:21.034]     }
[10:19:21.034]     if (FALSE) {
[10:19:21.034]     }
[10:19:21.034]     else {
[10:19:21.034]         if (TRUE) {
[10:19:21.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.034]                 open = "w")
[10:19:21.034]         }
[10:19:21.034]         else {
[10:19:21.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.034]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.034]         }
[10:19:21.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.034]             base::sink(type = "output", split = FALSE)
[10:19:21.034]             base::close(...future.stdout)
[10:19:21.034]         }, add = TRUE)
[10:19:21.034]     }
[10:19:21.034]     ...future.frame <- base::sys.nframe()
[10:19:21.034]     ...future.conditions <- base::list()
[10:19:21.034]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.034]     if (FALSE) {
[10:19:21.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.034]     }
[10:19:21.034]     ...future.result <- base::tryCatch({
[10:19:21.034]         base::withCallingHandlers({
[10:19:21.034]             ...future.value <- base::withVisible(base::local({
[10:19:21.034]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.034]                 if (!identical(...future.globals.maxSize.org, 
[10:19:21.034]                   ...future.globals.maxSize)) {
[10:19:21.034]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.034]                   on.exit(options(oopts), add = TRUE)
[10:19:21.034]                 }
[10:19:21.034]                 {
[10:19:21.034]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.034]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.034]                     USE.NAMES = FALSE)
[10:19:21.034]                   do.call(mapply, args = args)
[10:19:21.034]                 }
[10:19:21.034]             }))
[10:19:21.034]             future::FutureResult(value = ...future.value$value, 
[10:19:21.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.034]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.034]                     ...future.globalenv.names))
[10:19:21.034]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.034]         }, condition = base::local({
[10:19:21.034]             c <- base::c
[10:19:21.034]             inherits <- base::inherits
[10:19:21.034]             invokeRestart <- base::invokeRestart
[10:19:21.034]             length <- base::length
[10:19:21.034]             list <- base::list
[10:19:21.034]             seq.int <- base::seq.int
[10:19:21.034]             signalCondition <- base::signalCondition
[10:19:21.034]             sys.calls <- base::sys.calls
[10:19:21.034]             `[[` <- base::`[[`
[10:19:21.034]             `+` <- base::`+`
[10:19:21.034]             `<<-` <- base::`<<-`
[10:19:21.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.034]                   3L)]
[10:19:21.034]             }
[10:19:21.034]             function(cond) {
[10:19:21.034]                 is_error <- inherits(cond, "error")
[10:19:21.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.034]                   NULL)
[10:19:21.034]                 if (is_error) {
[10:19:21.034]                   sessionInformation <- function() {
[10:19:21.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.034]                       search = base::search(), system = base::Sys.info())
[10:19:21.034]                   }
[10:19:21.034]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.034]                     cond$call), session = sessionInformation(), 
[10:19:21.034]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.034]                   signalCondition(cond)
[10:19:21.034]                 }
[10:19:21.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.034]                 "immediateCondition"))) {
[10:19:21.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.034]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.034]                   if (TRUE && !signal) {
[10:19:21.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.034]                     {
[10:19:21.034]                       inherits <- base::inherits
[10:19:21.034]                       invokeRestart <- base::invokeRestart
[10:19:21.034]                       is.null <- base::is.null
[10:19:21.034]                       muffled <- FALSE
[10:19:21.034]                       if (inherits(cond, "message")) {
[10:19:21.034]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.034]                         if (muffled) 
[10:19:21.034]                           invokeRestart("muffleMessage")
[10:19:21.034]                       }
[10:19:21.034]                       else if (inherits(cond, "warning")) {
[10:19:21.034]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.034]                         if (muffled) 
[10:19:21.034]                           invokeRestart("muffleWarning")
[10:19:21.034]                       }
[10:19:21.034]                       else if (inherits(cond, "condition")) {
[10:19:21.034]                         if (!is.null(pattern)) {
[10:19:21.034]                           computeRestarts <- base::computeRestarts
[10:19:21.034]                           grepl <- base::grepl
[10:19:21.034]                           restarts <- computeRestarts(cond)
[10:19:21.034]                           for (restart in restarts) {
[10:19:21.034]                             name <- restart$name
[10:19:21.034]                             if (is.null(name)) 
[10:19:21.034]                               next
[10:19:21.034]                             if (!grepl(pattern, name)) 
[10:19:21.034]                               next
[10:19:21.034]                             invokeRestart(restart)
[10:19:21.034]                             muffled <- TRUE
[10:19:21.034]                             break
[10:19:21.034]                           }
[10:19:21.034]                         }
[10:19:21.034]                       }
[10:19:21.034]                       invisible(muffled)
[10:19:21.034]                     }
[10:19:21.034]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.034]                   }
[10:19:21.034]                 }
[10:19:21.034]                 else {
[10:19:21.034]                   if (TRUE) {
[10:19:21.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.034]                     {
[10:19:21.034]                       inherits <- base::inherits
[10:19:21.034]                       invokeRestart <- base::invokeRestart
[10:19:21.034]                       is.null <- base::is.null
[10:19:21.034]                       muffled <- FALSE
[10:19:21.034]                       if (inherits(cond, "message")) {
[10:19:21.034]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.034]                         if (muffled) 
[10:19:21.034]                           invokeRestart("muffleMessage")
[10:19:21.034]                       }
[10:19:21.034]                       else if (inherits(cond, "warning")) {
[10:19:21.034]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.034]                         if (muffled) 
[10:19:21.034]                           invokeRestart("muffleWarning")
[10:19:21.034]                       }
[10:19:21.034]                       else if (inherits(cond, "condition")) {
[10:19:21.034]                         if (!is.null(pattern)) {
[10:19:21.034]                           computeRestarts <- base::computeRestarts
[10:19:21.034]                           grepl <- base::grepl
[10:19:21.034]                           restarts <- computeRestarts(cond)
[10:19:21.034]                           for (restart in restarts) {
[10:19:21.034]                             name <- restart$name
[10:19:21.034]                             if (is.null(name)) 
[10:19:21.034]                               next
[10:19:21.034]                             if (!grepl(pattern, name)) 
[10:19:21.034]                               next
[10:19:21.034]                             invokeRestart(restart)
[10:19:21.034]                             muffled <- TRUE
[10:19:21.034]                             break
[10:19:21.034]                           }
[10:19:21.034]                         }
[10:19:21.034]                       }
[10:19:21.034]                       invisible(muffled)
[10:19:21.034]                     }
[10:19:21.034]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.034]                   }
[10:19:21.034]                 }
[10:19:21.034]             }
[10:19:21.034]         }))
[10:19:21.034]     }, error = function(ex) {
[10:19:21.034]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.034]                 ...future.rng), started = ...future.startTime, 
[10:19:21.034]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.034]             version = "1.8"), class = "FutureResult")
[10:19:21.034]     }, finally = {
[10:19:21.034]         if (!identical(...future.workdir, getwd())) 
[10:19:21.034]             setwd(...future.workdir)
[10:19:21.034]         {
[10:19:21.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.034]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.034]             }
[10:19:21.034]             base::options(...future.oldOptions)
[10:19:21.034]             if (.Platform$OS.type == "windows") {
[10:19:21.034]                 old_names <- names(...future.oldEnvVars)
[10:19:21.034]                 envs <- base::Sys.getenv()
[10:19:21.034]                 names <- names(envs)
[10:19:21.034]                 common <- intersect(names, old_names)
[10:19:21.034]                 added <- setdiff(names, old_names)
[10:19:21.034]                 removed <- setdiff(old_names, names)
[10:19:21.034]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.034]                   envs[common]]
[10:19:21.034]                 NAMES <- toupper(changed)
[10:19:21.034]                 args <- list()
[10:19:21.034]                 for (kk in seq_along(NAMES)) {
[10:19:21.034]                   name <- changed[[kk]]
[10:19:21.034]                   NAME <- NAMES[[kk]]
[10:19:21.034]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.034]                     next
[10:19:21.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.034]                 }
[10:19:21.034]                 NAMES <- toupper(added)
[10:19:21.034]                 for (kk in seq_along(NAMES)) {
[10:19:21.034]                   name <- added[[kk]]
[10:19:21.034]                   NAME <- NAMES[[kk]]
[10:19:21.034]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.034]                     next
[10:19:21.034]                   args[[name]] <- ""
[10:19:21.034]                 }
[10:19:21.034]                 NAMES <- toupper(removed)
[10:19:21.034]                 for (kk in seq_along(NAMES)) {
[10:19:21.034]                   name <- removed[[kk]]
[10:19:21.034]                   NAME <- NAMES[[kk]]
[10:19:21.034]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.034]                     next
[10:19:21.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.034]                 }
[10:19:21.034]                 if (length(args) > 0) 
[10:19:21.034]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.034]             }
[10:19:21.034]             else {
[10:19:21.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.034]             }
[10:19:21.034]             {
[10:19:21.034]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.034]                   0L) {
[10:19:21.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.034]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.034]                   base::options(opts)
[10:19:21.034]                 }
[10:19:21.034]                 {
[10:19:21.034]                   {
[10:19:21.034]                     base::assign(".Random.seed", c(10407L, 1882104135L, 
[10:19:21.034]                     309052741L, -1148982459L, -1875332049L, 1128907104L, 
[10:19:21.034]                     2048926850L), envir = base::globalenv(), 
[10:19:21.034]                       inherits = FALSE)
[10:19:21.034]                     NULL
[10:19:21.034]                   }
[10:19:21.034]                   options(future.plan = NULL)
[10:19:21.034]                   if (is.na(NA_character_)) 
[10:19:21.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.034]                     .init = FALSE)
[10:19:21.034]                 }
[10:19:21.034]             }
[10:19:21.034]         }
[10:19:21.034]     })
[10:19:21.034]     if (TRUE) {
[10:19:21.034]         base::sink(type = "output", split = FALSE)
[10:19:21.034]         if (TRUE) {
[10:19:21.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.034]         }
[10:19:21.034]         else {
[10:19:21.034]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.034]         }
[10:19:21.034]         base::close(...future.stdout)
[10:19:21.034]         ...future.stdout <- NULL
[10:19:21.034]     }
[10:19:21.034]     ...future.result$conditions <- ...future.conditions
[10:19:21.034]     ...future.result$finished <- base::Sys.time()
[10:19:21.034]     ...future.result
[10:19:21.034] }
[10:19:21.036] assign_globals() ...
[10:19:21.036] List of 5
[10:19:21.036]  $ ...future.FUN            :function (x, ...)  
[10:19:21.036]  $ MoreArgs                 : NULL
[10:19:21.036]  $ ...future.elements_ii    :List of 2
[10:19:21.036]   ..$ :List of 4
[10:19:21.036]   .. ..$ : int 1
[10:19:21.036]   .. ..$ : int 2
[10:19:21.036]   .. ..$ : int 3
[10:19:21.036]   .. ..$ : int 4
[10:19:21.036]   ..$ :List of 4
[10:19:21.036]   .. ..$ : int 2
[10:19:21.036]   .. ..$ : int 1
[10:19:21.036]   .. ..$ : int 2
[10:19:21.036]   .. ..$ : int 1
[10:19:21.036]  $ ...future.seeds_ii       : NULL
[10:19:21.036]  $ ...future.globals.maxSize: NULL
[10:19:21.036]  - attr(*, "where")=List of 5
[10:19:21.036]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.036]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.036]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.036]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.036]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.036]  - attr(*, "resolved")= logi FALSE
[10:19:21.036]  - attr(*, "total_size")= num 258
[10:19:21.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.036]  - attr(*, "already-done")= logi TRUE
[10:19:21.043] - copied ‘...future.FUN’ to environment
[10:19:21.043] - copied ‘MoreArgs’ to environment
[10:19:21.043] - copied ‘...future.elements_ii’ to environment
[10:19:21.043] - copied ‘...future.seeds_ii’ to environment
[10:19:21.043] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.043] assign_globals() ... done
[10:19:21.044] plan(): Setting new future strategy stack:
[10:19:21.044] List of future strategies:
[10:19:21.044] 1. sequential:
[10:19:21.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.044]    - tweaked: FALSE
[10:19:21.044]    - call: NULL
[10:19:21.044] plan(): nbrOfWorkers() = 1
[10:19:21.045] plan(): Setting new future strategy stack:
[10:19:21.045] List of future strategies:
[10:19:21.045] 1. sequential:
[10:19:21.045]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.045]    - tweaked: FALSE
[10:19:21.045]    - call: plan(strategy)
[10:19:21.045] plan(): nbrOfWorkers() = 1
[10:19:21.045] SequentialFuture started (and completed)
[10:19:21.046] - Launch lazy future ... done
[10:19:21.046] run() for ‘SequentialFuture’ ... done
[10:19:21.046] Created future:
[10:19:21.046] SequentialFuture:
[10:19:21.046] Label: ‘future_mapply-1’
[10:19:21.046] Expression:
[10:19:21.046] {
[10:19:21.046]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.046]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.046]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.046]         on.exit(options(oopts), add = TRUE)
[10:19:21.046]     }
[10:19:21.046]     {
[10:19:21.046]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.046]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.046]         do.call(mapply, args = args)
[10:19:21.046]     }
[10:19:21.046] }
[10:19:21.046] Lazy evaluation: FALSE
[10:19:21.046] Asynchronous evaluation: FALSE
[10:19:21.046] Local evaluation: TRUE
[10:19:21.046] Environment: R_GlobalEnv
[10:19:21.046] Capture standard output: TRUE
[10:19:21.046] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.046] Globals: 5 objects totaling 258 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 143 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.046] Packages: <none>
[10:19:21.046] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.046] Resolved: TRUE
[10:19:21.046] Value: 87 bytes of class ‘list’
[10:19:21.046] Early signaling: FALSE
[10:19:21.046] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.046] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.047] Chunk #1 of 1 ... DONE
[10:19:21.047] Launching 1 futures (chunks) ... DONE
[10:19:21.047] Resolving 1 futures (chunks) ...
[10:19:21.047] resolve() on list ...
[10:19:21.047]  recursive: 0
[10:19:21.047]  length: 1
[10:19:21.047] 
[10:19:21.047] resolved() for ‘SequentialFuture’ ...
[10:19:21.047] - state: ‘finished’
[10:19:21.047] - run: TRUE
[10:19:21.047] - result: ‘FutureResult’
[10:19:21.048] resolved() for ‘SequentialFuture’ ... done
[10:19:21.048] Future #1
[10:19:21.048] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:21.048] - nx: 1
[10:19:21.048] - relay: TRUE
[10:19:21.048] - stdout: TRUE
[10:19:21.048] - signal: TRUE
[10:19:21.048] - resignal: FALSE
[10:19:21.048] - force: TRUE
[10:19:21.048] - relayed: [n=1] FALSE
[10:19:21.048] - queued futures: [n=1] FALSE
[10:19:21.049]  - until=1
[10:19:21.049]  - relaying element #1
[10:19:21.049] - relayed: [n=1] TRUE
[10:19:21.049] - queued futures: [n=1] TRUE
[10:19:21.049] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:21.049]  length: 0 (resolved future 1)
[10:19:21.049] Relaying remaining futures
[10:19:21.049] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.049] - nx: 1
[10:19:21.049] - relay: TRUE
[10:19:21.049] - stdout: TRUE
[10:19:21.049] - signal: TRUE
[10:19:21.050] - resignal: FALSE
[10:19:21.050] - force: TRUE
[10:19:21.050] - relayed: [n=1] TRUE
[10:19:21.050] - queued futures: [n=1] TRUE
 - flush all
[10:19:21.050] - relayed: [n=1] TRUE
[10:19:21.050] - queued futures: [n=1] TRUE
[10:19:21.050] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.050] resolve() on list ... DONE
[10:19:21.050]  - Number of value chunks collected: 1
[10:19:21.050] Resolving 1 futures (chunks) ... DONE
[10:19:21.050] Reducing values from 1 chunks ...
[10:19:21.051]  - Number of values collected after concatenation: 4
[10:19:21.051]  - Number of values expected: 4
[10:19:21.051] Reducing values from 1 chunks ... DONE
[10:19:21.051] future_mapply() ... DONE
- Parallel RNG ...
[10:19:21.051] future_mapply() ...
[10:19:21.051] Generating random seeds ...
[10:19:21.051] Generating random seed streams for 4 elements ...
[10:19:21.051] Generating random seed streams for 4 elements ... DONE
[10:19:21.051] Generating random seeds ... DONE
[10:19:21.051] Will set RNG state on exit: 10407, -1148982459, -108834958, 699588979, 2048926850, -404809558, -953988872
[10:19:21.052] Number of chunks: 1
[10:19:21.052] getGlobalsAndPackagesXApply() ...
[10:19:21.052]  - future.globals: TRUE
[10:19:21.052] getGlobalsAndPackages() ...
[10:19:21.052] Searching for globals...
[10:19:21.055] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:19:21.055] Searching for globals ... DONE
[10:19:21.055] Resolving globals: FALSE
[10:19:21.056] The total size of the 1 globals is 501 bytes (501 bytes)
[10:19:21.056] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[10:19:21.056] - globals: [1] ‘FUN’
[10:19:21.056] - packages: [1] ‘stats’
[10:19:21.056] getGlobalsAndPackages() ... DONE
[10:19:21.056]  - globals found/used: [n=1] ‘FUN’
[10:19:21.057]  - needed namespaces: [n=1] ‘stats’
[10:19:21.057] Finding globals ... DONE
[10:19:21.057] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.057] List of 2
[10:19:21.057]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:19:21.057]  $ MoreArgs     :List of 1
[10:19:21.057]   ..$ min: num 1
[10:19:21.057]  - attr(*, "where")=List of 2
[10:19:21.057]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.057]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.057]  - attr(*, "resolved")= logi FALSE
[10:19:21.057]  - attr(*, "total_size")= num NA
[10:19:21.060] Packages to be attached in all futures: [n=1] ‘stats’
[10:19:21.060] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.060] Number of futures (= number of chunks): 1
[10:19:21.060] Launching 1 futures (chunks) ...
[10:19:21.060] Chunk #1 of 1 ...
[10:19:21.060]  - Finding globals in '...' for chunk #1 ...
[10:19:21.060] getGlobalsAndPackages() ...
[10:19:21.061] Searching for globals...
[10:19:21.061] 
[10:19:21.061] Searching for globals ... DONE
[10:19:21.061] - globals: [0] <none>
[10:19:21.061] getGlobalsAndPackages() ... DONE
[10:19:21.061]    + additional globals found: [n=0] 
[10:19:21.061]    + additional namespaces needed: [n=0] 
[10:19:21.061]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.061]  - seeds: [4] <seeds>
[10:19:21.062]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.062] getGlobalsAndPackages() ...
[10:19:21.062] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.062] Resolving globals: FALSE
[10:19:21.062] The total size of the 5 globals is 990 bytes (990 bytes)
[10:19:21.063] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 990 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (196 bytes of class ‘list’) and ‘...future.seeds_ii’ (175 bytes of class ‘list’)
[10:19:21.063] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.063] - packages: [1] ‘stats’
[10:19:21.063] getGlobalsAndPackages() ... DONE
[10:19:21.063] run() for ‘Future’ ...
[10:19:21.063] - state: ‘created’
[10:19:21.064] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:21.064] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.064] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:21.064]   - Field: ‘label’
[10:19:21.064]   - Field: ‘local’
[10:19:21.064]   - Field: ‘owner’
[10:19:21.064]   - Field: ‘envir’
[10:19:21.064]   - Field: ‘packages’
[10:19:21.064]   - Field: ‘gc’
[10:19:21.065]   - Field: ‘conditions’
[10:19:21.065]   - Field: ‘expr’
[10:19:21.065]   - Field: ‘uuid’
[10:19:21.065]   - Field: ‘seed’
[10:19:21.065]   - Field: ‘version’
[10:19:21.065]   - Field: ‘result’
[10:19:21.065]   - Field: ‘asynchronous’
[10:19:21.065]   - Field: ‘calls’
[10:19:21.065]   - Field: ‘globals’
[10:19:21.065]   - Field: ‘stdout’
[10:19:21.065]   - Field: ‘earlySignal’
[10:19:21.065]   - Field: ‘lazy’
[10:19:21.066]   - Field: ‘state’
[10:19:21.066] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:21.066] - Launch lazy future ...
[10:19:21.066] Packages needed by the future expression (n = 1): ‘stats’
[10:19:21.066] Packages needed by future strategies (n = 0): <none>
[10:19:21.067] {
[10:19:21.067]     {
[10:19:21.067]         {
[10:19:21.067]             ...future.startTime <- base::Sys.time()
[10:19:21.067]             {
[10:19:21.067]                 {
[10:19:21.067]                   {
[10:19:21.067]                     {
[10:19:21.067]                       base::local({
[10:19:21.067]                         has_future <- base::requireNamespace("future", 
[10:19:21.067]                           quietly = TRUE)
[10:19:21.067]                         if (has_future) {
[10:19:21.067]                           ns <- base::getNamespace("future")
[10:19:21.067]                           version <- ns[[".package"]][["version"]]
[10:19:21.067]                           if (is.null(version)) 
[10:19:21.067]                             version <- utils::packageVersion("future")
[10:19:21.067]                         }
[10:19:21.067]                         else {
[10:19:21.067]                           version <- NULL
[10:19:21.067]                         }
[10:19:21.067]                         if (!has_future || version < "1.8.0") {
[10:19:21.067]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.067]                             "", base::R.version$version.string), 
[10:19:21.067]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.067]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.067]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.067]                               "release", "version")], collapse = " "), 
[10:19:21.067]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.067]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.067]                             info)
[10:19:21.067]                           info <- base::paste(info, collapse = "; ")
[10:19:21.067]                           if (!has_future) {
[10:19:21.067]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.067]                               info)
[10:19:21.067]                           }
[10:19:21.067]                           else {
[10:19:21.067]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.067]                               info, version)
[10:19:21.067]                           }
[10:19:21.067]                           base::stop(msg)
[10:19:21.067]                         }
[10:19:21.067]                       })
[10:19:21.067]                     }
[10:19:21.067]                     base::local({
[10:19:21.067]                       for (pkg in "stats") {
[10:19:21.067]                         base::loadNamespace(pkg)
[10:19:21.067]                         base::library(pkg, character.only = TRUE)
[10:19:21.067]                       }
[10:19:21.067]                     })
[10:19:21.067]                   }
[10:19:21.067]                   ...future.strategy.old <- future::plan("list")
[10:19:21.067]                   options(future.plan = NULL)
[10:19:21.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.067]                 }
[10:19:21.067]                 ...future.workdir <- getwd()
[10:19:21.067]             }
[10:19:21.067]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.067]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.067]         }
[10:19:21.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:21.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.067]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.067]             base::names(...future.oldOptions))
[10:19:21.067]     }
[10:19:21.067]     if (FALSE) {
[10:19:21.067]     }
[10:19:21.067]     else {
[10:19:21.067]         if (TRUE) {
[10:19:21.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.067]                 open = "w")
[10:19:21.067]         }
[10:19:21.067]         else {
[10:19:21.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.067]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.067]         }
[10:19:21.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.067]             base::sink(type = "output", split = FALSE)
[10:19:21.067]             base::close(...future.stdout)
[10:19:21.067]         }, add = TRUE)
[10:19:21.067]     }
[10:19:21.067]     ...future.frame <- base::sys.nframe()
[10:19:21.067]     ...future.conditions <- base::list()
[10:19:21.067]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.067]     if (FALSE) {
[10:19:21.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.067]     }
[10:19:21.067]     ...future.result <- base::tryCatch({
[10:19:21.067]         base::withCallingHandlers({
[10:19:21.067]             ...future.value <- base::withVisible(base::local({
[10:19:21.067]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.067]                 if (!identical(...future.globals.maxSize.org, 
[10:19:21.067]                   ...future.globals.maxSize)) {
[10:19:21.067]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.067]                   on.exit(options(oopts), add = TRUE)
[10:19:21.067]                 }
[10:19:21.067]                 {
[10:19:21.067]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:21.067]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:21.067]                       envir = globalenv(), inherits = FALSE)
[10:19:21.067]                     ...future.FUN(...)
[10:19:21.067]                   }
[10:19:21.067]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:21.067]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:21.067]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.067]                     USE.NAMES = FALSE)
[10:19:21.067]                   do.call(mapply, args = args)
[10:19:21.067]                 }
[10:19:21.067]             }))
[10:19:21.067]             future::FutureResult(value = ...future.value$value, 
[10:19:21.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.067]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.067]                     ...future.globalenv.names))
[10:19:21.067]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.067]         }, condition = base::local({
[10:19:21.067]             c <- base::c
[10:19:21.067]             inherits <- base::inherits
[10:19:21.067]             invokeRestart <- base::invokeRestart
[10:19:21.067]             length <- base::length
[10:19:21.067]             list <- base::list
[10:19:21.067]             seq.int <- base::seq.int
[10:19:21.067]             signalCondition <- base::signalCondition
[10:19:21.067]             sys.calls <- base::sys.calls
[10:19:21.067]             `[[` <- base::`[[`
[10:19:21.067]             `+` <- base::`+`
[10:19:21.067]             `<<-` <- base::`<<-`
[10:19:21.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.067]                   3L)]
[10:19:21.067]             }
[10:19:21.067]             function(cond) {
[10:19:21.067]                 is_error <- inherits(cond, "error")
[10:19:21.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.067]                   NULL)
[10:19:21.067]                 if (is_error) {
[10:19:21.067]                   sessionInformation <- function() {
[10:19:21.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.067]                       search = base::search(), system = base::Sys.info())
[10:19:21.067]                   }
[10:19:21.067]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.067]                     cond$call), session = sessionInformation(), 
[10:19:21.067]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.067]                   signalCondition(cond)
[10:19:21.067]                 }
[10:19:21.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.067]                 "immediateCondition"))) {
[10:19:21.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.067]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.067]                   if (TRUE && !signal) {
[10:19:21.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.067]                     {
[10:19:21.067]                       inherits <- base::inherits
[10:19:21.067]                       invokeRestart <- base::invokeRestart
[10:19:21.067]                       is.null <- base::is.null
[10:19:21.067]                       muffled <- FALSE
[10:19:21.067]                       if (inherits(cond, "message")) {
[10:19:21.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.067]                         if (muffled) 
[10:19:21.067]                           invokeRestart("muffleMessage")
[10:19:21.067]                       }
[10:19:21.067]                       else if (inherits(cond, "warning")) {
[10:19:21.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.067]                         if (muffled) 
[10:19:21.067]                           invokeRestart("muffleWarning")
[10:19:21.067]                       }
[10:19:21.067]                       else if (inherits(cond, "condition")) {
[10:19:21.067]                         if (!is.null(pattern)) {
[10:19:21.067]                           computeRestarts <- base::computeRestarts
[10:19:21.067]                           grepl <- base::grepl
[10:19:21.067]                           restarts <- computeRestarts(cond)
[10:19:21.067]                           for (restart in restarts) {
[10:19:21.067]                             name <- restart$name
[10:19:21.067]                             if (is.null(name)) 
[10:19:21.067]                               next
[10:19:21.067]                             if (!grepl(pattern, name)) 
[10:19:21.067]                               next
[10:19:21.067]                             invokeRestart(restart)
[10:19:21.067]                             muffled <- TRUE
[10:19:21.067]                             break
[10:19:21.067]                           }
[10:19:21.067]                         }
[10:19:21.067]                       }
[10:19:21.067]                       invisible(muffled)
[10:19:21.067]                     }
[10:19:21.067]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.067]                   }
[10:19:21.067]                 }
[10:19:21.067]                 else {
[10:19:21.067]                   if (TRUE) {
[10:19:21.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.067]                     {
[10:19:21.067]                       inherits <- base::inherits
[10:19:21.067]                       invokeRestart <- base::invokeRestart
[10:19:21.067]                       is.null <- base::is.null
[10:19:21.067]                       muffled <- FALSE
[10:19:21.067]                       if (inherits(cond, "message")) {
[10:19:21.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.067]                         if (muffled) 
[10:19:21.067]                           invokeRestart("muffleMessage")
[10:19:21.067]                       }
[10:19:21.067]                       else if (inherits(cond, "warning")) {
[10:19:21.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.067]                         if (muffled) 
[10:19:21.067]                           invokeRestart("muffleWarning")
[10:19:21.067]                       }
[10:19:21.067]                       else if (inherits(cond, "condition")) {
[10:19:21.067]                         if (!is.null(pattern)) {
[10:19:21.067]                           computeRestarts <- base::computeRestarts
[10:19:21.067]                           grepl <- base::grepl
[10:19:21.067]                           restarts <- computeRestarts(cond)
[10:19:21.067]                           for (restart in restarts) {
[10:19:21.067]                             name <- restart$name
[10:19:21.067]                             if (is.null(name)) 
[10:19:21.067]                               next
[10:19:21.067]                             if (!grepl(pattern, name)) 
[10:19:21.067]                               next
[10:19:21.067]                             invokeRestart(restart)
[10:19:21.067]                             muffled <- TRUE
[10:19:21.067]                             break
[10:19:21.067]                           }
[10:19:21.067]                         }
[10:19:21.067]                       }
[10:19:21.067]                       invisible(muffled)
[10:19:21.067]                     }
[10:19:21.067]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.067]                   }
[10:19:21.067]                 }
[10:19:21.067]             }
[10:19:21.067]         }))
[10:19:21.067]     }, error = function(ex) {
[10:19:21.067]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.067]                 ...future.rng), started = ...future.startTime, 
[10:19:21.067]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.067]             version = "1.8"), class = "FutureResult")
[10:19:21.067]     }, finally = {
[10:19:21.067]         if (!identical(...future.workdir, getwd())) 
[10:19:21.067]             setwd(...future.workdir)
[10:19:21.067]         {
[10:19:21.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.067]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.067]             }
[10:19:21.067]             base::options(...future.oldOptions)
[10:19:21.067]             if (.Platform$OS.type == "windows") {
[10:19:21.067]                 old_names <- names(...future.oldEnvVars)
[10:19:21.067]                 envs <- base::Sys.getenv()
[10:19:21.067]                 names <- names(envs)
[10:19:21.067]                 common <- intersect(names, old_names)
[10:19:21.067]                 added <- setdiff(names, old_names)
[10:19:21.067]                 removed <- setdiff(old_names, names)
[10:19:21.067]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.067]                   envs[common]]
[10:19:21.067]                 NAMES <- toupper(changed)
[10:19:21.067]                 args <- list()
[10:19:21.067]                 for (kk in seq_along(NAMES)) {
[10:19:21.067]                   name <- changed[[kk]]
[10:19:21.067]                   NAME <- NAMES[[kk]]
[10:19:21.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.067]                     next
[10:19:21.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.067]                 }
[10:19:21.067]                 NAMES <- toupper(added)
[10:19:21.067]                 for (kk in seq_along(NAMES)) {
[10:19:21.067]                   name <- added[[kk]]
[10:19:21.067]                   NAME <- NAMES[[kk]]
[10:19:21.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.067]                     next
[10:19:21.067]                   args[[name]] <- ""
[10:19:21.067]                 }
[10:19:21.067]                 NAMES <- toupper(removed)
[10:19:21.067]                 for (kk in seq_along(NAMES)) {
[10:19:21.067]                   name <- removed[[kk]]
[10:19:21.067]                   NAME <- NAMES[[kk]]
[10:19:21.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.067]                     next
[10:19:21.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.067]                 }
[10:19:21.067]                 if (length(args) > 0) 
[10:19:21.067]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.067]             }
[10:19:21.067]             else {
[10:19:21.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.067]             }
[10:19:21.067]             {
[10:19:21.067]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.067]                   0L) {
[10:19:21.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.067]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.067]                   base::options(opts)
[10:19:21.067]                 }
[10:19:21.067]                 {
[10:19:21.067]                   {
[10:19:21.067]                     base::assign(".Random.seed", c(10407L, -1148982459L, 
[10:19:21.067]                     -108834958L, 699588979L, 2048926850L, -404809558L, 
[10:19:21.067]                     -953988872L), envir = base::globalenv(), 
[10:19:21.067]                       inherits = FALSE)
[10:19:21.067]                     NULL
[10:19:21.067]                   }
[10:19:21.067]                   options(future.plan = NULL)
[10:19:21.067]                   if (is.na(NA_character_)) 
[10:19:21.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.067]                     .init = FALSE)
[10:19:21.067]                 }
[10:19:21.067]             }
[10:19:21.067]         }
[10:19:21.067]     })
[10:19:21.067]     if (TRUE) {
[10:19:21.067]         base::sink(type = "output", split = FALSE)
[10:19:21.067]         if (TRUE) {
[10:19:21.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.067]         }
[10:19:21.067]         else {
[10:19:21.067]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.067]         }
[10:19:21.067]         base::close(...future.stdout)
[10:19:21.067]         ...future.stdout <- NULL
[10:19:21.067]     }
[10:19:21.067]     ...future.result$conditions <- ...future.conditions
[10:19:21.067]     ...future.result$finished <- base::Sys.time()
[10:19:21.067]     ...future.result
[10:19:21.067] }
[10:19:21.068] assign_globals() ...
[10:19:21.068] List of 5
[10:19:21.068]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:19:21.068]  $ MoreArgs                 :List of 1
[10:19:21.068]   ..$ min: num 1
[10:19:21.068]  $ ...future.elements_ii    :List of 2
[10:19:21.068]   ..$ n  :List of 4
[10:19:21.068]   .. ..$ : int 1
[10:19:21.068]   .. ..$ : int 2
[10:19:21.068]   .. ..$ : int 3
[10:19:21.068]   .. ..$ : int 4
[10:19:21.068]   ..$ max:List of 4
[10:19:21.068]   .. ..$ : int 2
[10:19:21.068]   .. ..$ : int 3
[10:19:21.068]   .. ..$ : int 4
[10:19:21.068]   .. ..$ : int 5
[10:19:21.068]  $ ...future.seeds_ii       :List of 4
[10:19:21.068]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:19:21.068]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:19:21.068]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[10:19:21.068]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[10:19:21.068]  $ ...future.globals.maxSize: NULL
[10:19:21.068]  - attr(*, "where")=List of 5
[10:19:21.068]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.068]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.068]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.068]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.068]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.068]  - attr(*, "resolved")= logi FALSE
[10:19:21.068]  - attr(*, "total_size")= num 990
[10:19:21.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.068]  - attr(*, "already-done")= logi TRUE
[10:19:21.078] - copied ‘...future.FUN’ to environment
[10:19:21.079] - copied ‘MoreArgs’ to environment
[10:19:21.079] - copied ‘...future.elements_ii’ to environment
[10:19:21.079] - copied ‘...future.seeds_ii’ to environment
[10:19:21.079] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.079] assign_globals() ... done
[10:19:21.079] plan(): Setting new future strategy stack:
[10:19:21.079] List of future strategies:
[10:19:21.079] 1. sequential:
[10:19:21.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.079]    - tweaked: FALSE
[10:19:21.079]    - call: NULL
[10:19:21.080] plan(): nbrOfWorkers() = 1
[10:19:21.081] plan(): Setting new future strategy stack:
[10:19:21.081] List of future strategies:
[10:19:21.081] 1. sequential:
[10:19:21.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.081]    - tweaked: FALSE
[10:19:21.081]    - call: plan(strategy)
[10:19:21.081] plan(): nbrOfWorkers() = 1
[10:19:21.081] SequentialFuture started (and completed)
[10:19:21.081] - Launch lazy future ... done
[10:19:21.081] run() for ‘SequentialFuture’ ... done
[10:19:21.082] Created future:
[10:19:21.082] SequentialFuture:
[10:19:21.082] Label: ‘future_mapply-1’
[10:19:21.082] Expression:
[10:19:21.082] {
[10:19:21.082]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.082]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.082]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.082]         on.exit(options(oopts), add = TRUE)
[10:19:21.082]     }
[10:19:21.082]     {
[10:19:21.082]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:21.082]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:21.082]                 inherits = FALSE)
[10:19:21.082]             ...future.FUN(...)
[10:19:21.082]         }
[10:19:21.082]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:21.082]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:21.082]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.082]         do.call(mapply, args = args)
[10:19:21.082]     }
[10:19:21.082] }
[10:19:21.082] Lazy evaluation: FALSE
[10:19:21.082] Asynchronous evaluation: FALSE
[10:19:21.082] Local evaluation: TRUE
[10:19:21.082] Environment: R_GlobalEnv
[10:19:21.082] Capture standard output: TRUE
[10:19:21.082] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.082] Globals: 5 objects totaling 990 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 196 bytes, list ‘...future.seeds_ii’ of 175 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.082] Packages: 1 packages (‘stats’)
[10:19:21.082] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:21.082] Resolved: TRUE
[10:19:21.082] Value: 143 bytes of class ‘list’
[10:19:21.082] Early signaling: FALSE
[10:19:21.082] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.082] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.082] Chunk #1 of 1 ... DONE
[10:19:21.083] Launching 1 futures (chunks) ... DONE
[10:19:21.083] Resolving 1 futures (chunks) ...
[10:19:21.083] resolve() on list ...
[10:19:21.083]  recursive: 0
[10:19:21.083]  length: 1
[10:19:21.083] 
[10:19:21.083] resolved() for ‘SequentialFuture’ ...
[10:19:21.083] - state: ‘finished’
[10:19:21.083] - run: TRUE
[10:19:21.083] - result: ‘FutureResult’
[10:19:21.083] resolved() for ‘SequentialFuture’ ... done
[10:19:21.084] Future #1
[10:19:21.084] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:21.084] - nx: 1
[10:19:21.084] - relay: TRUE
[10:19:21.084] - stdout: TRUE
[10:19:21.084] - signal: TRUE
[10:19:21.084] - resignal: FALSE
[10:19:21.084] - force: TRUE
[10:19:21.084] - relayed: [n=1] FALSE
[10:19:21.084] - queued futures: [n=1] FALSE
[10:19:21.084]  - until=1
[10:19:21.084]  - relaying element #1
[10:19:21.085] - relayed: [n=1] TRUE
[10:19:21.085] - queued futures: [n=1] TRUE
[10:19:21.085] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:21.085]  length: 0 (resolved future 1)
[10:19:21.085] Relaying remaining futures
[10:19:21.085] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.085] - nx: 1
[10:19:21.085] - relay: TRUE
[10:19:21.085] - stdout: TRUE
[10:19:21.085] - signal: TRUE
[10:19:21.085] - resignal: FALSE
[10:19:21.085] - force: TRUE
[10:19:21.086] - relayed: [n=1] TRUE
[10:19:21.086] - queued futures: [n=1] TRUE
 - flush all
[10:19:21.086] - relayed: [n=1] TRUE
[10:19:21.086] - queued futures: [n=1] TRUE
[10:19:21.086] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.086] resolve() on list ... DONE
[10:19:21.086]  - Number of value chunks collected: 1
[10:19:21.086] Resolving 1 futures (chunks) ... DONE
[10:19:21.086] Reducing values from 1 chunks ...
[10:19:21.086]  - Number of values collected after concatenation: 4
[10:19:21.086]  - Number of values expected: 4
[10:19:21.087] Reducing values from 1 chunks ... DONE
[10:19:21.087] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[10:19:21.089] future_mapply() ...
[10:19:21.089] Number of chunks: 1
[10:19:21.089] getGlobalsAndPackagesXApply() ...
[10:19:21.089]  - future.globals: TRUE
[10:19:21.089] getGlobalsAndPackages() ...
[10:19:21.089] Searching for globals...
[10:19:21.090] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:19:21.091] Searching for globals ... DONE
[10:19:21.091] Resolving globals: FALSE
[10:19:21.091] The total size of the 1 globals is 337 bytes (337 bytes)
[10:19:21.091] The total size of the 1 globals exported for future expression (‘FUN()’) is 337 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (337 bytes of class ‘function’)
[10:19:21.091] - globals: [1] ‘FUN’
[10:19:21.092] - packages: [1] ‘stats’
[10:19:21.092] getGlobalsAndPackages() ... DONE
[10:19:21.092]  - globals found/used: [n=1] ‘FUN’
[10:19:21.092]  - needed namespaces: [n=1] ‘stats’
[10:19:21.092] Finding globals ... DONE
[10:19:21.092] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.092] List of 2
[10:19:21.092]  $ ...future.FUN:function (x, w, ...)  
[10:19:21.092]  $ MoreArgs     : NULL
[10:19:21.092]  - attr(*, "where")=List of 2
[10:19:21.092]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.092]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.092]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.092]  - attr(*, "resolved")= logi FALSE
[10:19:21.092]  - attr(*, "total_size")= num NA
[10:19:21.095] Packages to be attached in all futures: [n=1] ‘stats’
[10:19:21.095] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.095] Number of futures (= number of chunks): 1
[10:19:21.095] Launching 1 futures (chunks) ...
[10:19:21.095] Chunk #1 of 1 ...
[10:19:21.095]  - Finding globals in '...' for chunk #1 ...
[10:19:21.095] getGlobalsAndPackages() ...
[10:19:21.095] Searching for globals...
[10:19:21.099] 
[10:19:21.099] Searching for globals ... DONE
[10:19:21.099] - globals: [0] <none>
[10:19:21.099] getGlobalsAndPackages() ... DONE
[10:19:21.099]    + additional globals found: [n=0] 
[10:19:21.099]    + additional namespaces needed: [n=0] 
[10:19:21.100]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.100]  - seeds: <none>
[10:19:21.100]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.100] getGlobalsAndPackages() ...
[10:19:21.100] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.100] Resolving globals: FALSE
[10:19:21.100] The total size of the 5 globals is 1.31 KiB (1345 bytes)
[10:19:21.101] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.31 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (927 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.101] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.101] - packages: [1] ‘stats’
[10:19:21.101] getGlobalsAndPackages() ... DONE
[10:19:21.102] run() for ‘Future’ ...
[10:19:21.102] - state: ‘created’
[10:19:21.102] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:21.102] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:21.102]   - Field: ‘label’
[10:19:21.102]   - Field: ‘local’
[10:19:21.103]   - Field: ‘owner’
[10:19:21.103]   - Field: ‘envir’
[10:19:21.103]   - Field: ‘packages’
[10:19:21.103]   - Field: ‘gc’
[10:19:21.103]   - Field: ‘conditions’
[10:19:21.103]   - Field: ‘expr’
[10:19:21.103]   - Field: ‘uuid’
[10:19:21.103]   - Field: ‘seed’
[10:19:21.103]   - Field: ‘version’
[10:19:21.103]   - Field: ‘result’
[10:19:21.103]   - Field: ‘asynchronous’
[10:19:21.104]   - Field: ‘calls’
[10:19:21.104]   - Field: ‘globals’
[10:19:21.104]   - Field: ‘stdout’
[10:19:21.104]   - Field: ‘earlySignal’
[10:19:21.104]   - Field: ‘lazy’
[10:19:21.104]   - Field: ‘state’
[10:19:21.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:21.104] - Launch lazy future ...
[10:19:21.104] Packages needed by the future expression (n = 1): ‘stats’
[10:19:21.104] Packages needed by future strategies (n = 0): <none>
[10:19:21.105] {
[10:19:21.105]     {
[10:19:21.105]         {
[10:19:21.105]             ...future.startTime <- base::Sys.time()
[10:19:21.105]             {
[10:19:21.105]                 {
[10:19:21.105]                   {
[10:19:21.105]                     {
[10:19:21.105]                       base::local({
[10:19:21.105]                         has_future <- base::requireNamespace("future", 
[10:19:21.105]                           quietly = TRUE)
[10:19:21.105]                         if (has_future) {
[10:19:21.105]                           ns <- base::getNamespace("future")
[10:19:21.105]                           version <- ns[[".package"]][["version"]]
[10:19:21.105]                           if (is.null(version)) 
[10:19:21.105]                             version <- utils::packageVersion("future")
[10:19:21.105]                         }
[10:19:21.105]                         else {
[10:19:21.105]                           version <- NULL
[10:19:21.105]                         }
[10:19:21.105]                         if (!has_future || version < "1.8.0") {
[10:19:21.105]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.105]                             "", base::R.version$version.string), 
[10:19:21.105]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.105]                               "release", "version")], collapse = " "), 
[10:19:21.105]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.105]                             info)
[10:19:21.105]                           info <- base::paste(info, collapse = "; ")
[10:19:21.105]                           if (!has_future) {
[10:19:21.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.105]                               info)
[10:19:21.105]                           }
[10:19:21.105]                           else {
[10:19:21.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.105]                               info, version)
[10:19:21.105]                           }
[10:19:21.105]                           base::stop(msg)
[10:19:21.105]                         }
[10:19:21.105]                       })
[10:19:21.105]                     }
[10:19:21.105]                     base::local({
[10:19:21.105]                       for (pkg in "stats") {
[10:19:21.105]                         base::loadNamespace(pkg)
[10:19:21.105]                         base::library(pkg, character.only = TRUE)
[10:19:21.105]                       }
[10:19:21.105]                     })
[10:19:21.105]                   }
[10:19:21.105]                   ...future.strategy.old <- future::plan("list")
[10:19:21.105]                   options(future.plan = NULL)
[10:19:21.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.105]                 }
[10:19:21.105]                 ...future.workdir <- getwd()
[10:19:21.105]             }
[10:19:21.105]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.105]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.105]         }
[10:19:21.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:21.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.105]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.105]             base::names(...future.oldOptions))
[10:19:21.105]     }
[10:19:21.105]     if (FALSE) {
[10:19:21.105]     }
[10:19:21.105]     else {
[10:19:21.105]         if (TRUE) {
[10:19:21.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.105]                 open = "w")
[10:19:21.105]         }
[10:19:21.105]         else {
[10:19:21.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.105]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.105]         }
[10:19:21.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.105]             base::sink(type = "output", split = FALSE)
[10:19:21.105]             base::close(...future.stdout)
[10:19:21.105]         }, add = TRUE)
[10:19:21.105]     }
[10:19:21.105]     ...future.frame <- base::sys.nframe()
[10:19:21.105]     ...future.conditions <- base::list()
[10:19:21.105]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.105]     if (FALSE) {
[10:19:21.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.105]     }
[10:19:21.105]     ...future.result <- base::tryCatch({
[10:19:21.105]         base::withCallingHandlers({
[10:19:21.105]             ...future.value <- base::withVisible(base::local({
[10:19:21.105]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.105]                 if (!identical(...future.globals.maxSize.org, 
[10:19:21.105]                   ...future.globals.maxSize)) {
[10:19:21.105]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.105]                   on.exit(options(oopts), add = TRUE)
[10:19:21.105]                 }
[10:19:21.105]                 {
[10:19:21.105]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.105]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.105]                     USE.NAMES = FALSE)
[10:19:21.105]                   do.call(mapply, args = args)
[10:19:21.105]                 }
[10:19:21.105]             }))
[10:19:21.105]             future::FutureResult(value = ...future.value$value, 
[10:19:21.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.105]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.105]                     ...future.globalenv.names))
[10:19:21.105]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.105]         }, condition = base::local({
[10:19:21.105]             c <- base::c
[10:19:21.105]             inherits <- base::inherits
[10:19:21.105]             invokeRestart <- base::invokeRestart
[10:19:21.105]             length <- base::length
[10:19:21.105]             list <- base::list
[10:19:21.105]             seq.int <- base::seq.int
[10:19:21.105]             signalCondition <- base::signalCondition
[10:19:21.105]             sys.calls <- base::sys.calls
[10:19:21.105]             `[[` <- base::`[[`
[10:19:21.105]             `+` <- base::`+`
[10:19:21.105]             `<<-` <- base::`<<-`
[10:19:21.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.105]                   3L)]
[10:19:21.105]             }
[10:19:21.105]             function(cond) {
[10:19:21.105]                 is_error <- inherits(cond, "error")
[10:19:21.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.105]                   NULL)
[10:19:21.105]                 if (is_error) {
[10:19:21.105]                   sessionInformation <- function() {
[10:19:21.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.105]                       search = base::search(), system = base::Sys.info())
[10:19:21.105]                   }
[10:19:21.105]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.105]                     cond$call), session = sessionInformation(), 
[10:19:21.105]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.105]                   signalCondition(cond)
[10:19:21.105]                 }
[10:19:21.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.105]                 "immediateCondition"))) {
[10:19:21.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.105]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.105]                   if (TRUE && !signal) {
[10:19:21.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.105]                     {
[10:19:21.105]                       inherits <- base::inherits
[10:19:21.105]                       invokeRestart <- base::invokeRestart
[10:19:21.105]                       is.null <- base::is.null
[10:19:21.105]                       muffled <- FALSE
[10:19:21.105]                       if (inherits(cond, "message")) {
[10:19:21.105]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.105]                         if (muffled) 
[10:19:21.105]                           invokeRestart("muffleMessage")
[10:19:21.105]                       }
[10:19:21.105]                       else if (inherits(cond, "warning")) {
[10:19:21.105]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.105]                         if (muffled) 
[10:19:21.105]                           invokeRestart("muffleWarning")
[10:19:21.105]                       }
[10:19:21.105]                       else if (inherits(cond, "condition")) {
[10:19:21.105]                         if (!is.null(pattern)) {
[10:19:21.105]                           computeRestarts <- base::computeRestarts
[10:19:21.105]                           grepl <- base::grepl
[10:19:21.105]                           restarts <- computeRestarts(cond)
[10:19:21.105]                           for (restart in restarts) {
[10:19:21.105]                             name <- restart$name
[10:19:21.105]                             if (is.null(name)) 
[10:19:21.105]                               next
[10:19:21.105]                             if (!grepl(pattern, name)) 
[10:19:21.105]                               next
[10:19:21.105]                             invokeRestart(restart)
[10:19:21.105]                             muffled <- TRUE
[10:19:21.105]                             break
[10:19:21.105]                           }
[10:19:21.105]                         }
[10:19:21.105]                       }
[10:19:21.105]                       invisible(muffled)
[10:19:21.105]                     }
[10:19:21.105]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.105]                   }
[10:19:21.105]                 }
[10:19:21.105]                 else {
[10:19:21.105]                   if (TRUE) {
[10:19:21.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.105]                     {
[10:19:21.105]                       inherits <- base::inherits
[10:19:21.105]                       invokeRestart <- base::invokeRestart
[10:19:21.105]                       is.null <- base::is.null
[10:19:21.105]                       muffled <- FALSE
[10:19:21.105]                       if (inherits(cond, "message")) {
[10:19:21.105]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.105]                         if (muffled) 
[10:19:21.105]                           invokeRestart("muffleMessage")
[10:19:21.105]                       }
[10:19:21.105]                       else if (inherits(cond, "warning")) {
[10:19:21.105]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.105]                         if (muffled) 
[10:19:21.105]                           invokeRestart("muffleWarning")
[10:19:21.105]                       }
[10:19:21.105]                       else if (inherits(cond, "condition")) {
[10:19:21.105]                         if (!is.null(pattern)) {
[10:19:21.105]                           computeRestarts <- base::computeRestarts
[10:19:21.105]                           grepl <- base::grepl
[10:19:21.105]                           restarts <- computeRestarts(cond)
[10:19:21.105]                           for (restart in restarts) {
[10:19:21.105]                             name <- restart$name
[10:19:21.105]                             if (is.null(name)) 
[10:19:21.105]                               next
[10:19:21.105]                             if (!grepl(pattern, name)) 
[10:19:21.105]                               next
[10:19:21.105]                             invokeRestart(restart)
[10:19:21.105]                             muffled <- TRUE
[10:19:21.105]                             break
[10:19:21.105]                           }
[10:19:21.105]                         }
[10:19:21.105]                       }
[10:19:21.105]                       invisible(muffled)
[10:19:21.105]                     }
[10:19:21.105]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.105]                   }
[10:19:21.105]                 }
[10:19:21.105]             }
[10:19:21.105]         }))
[10:19:21.105]     }, error = function(ex) {
[10:19:21.105]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.105]                 ...future.rng), started = ...future.startTime, 
[10:19:21.105]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.105]             version = "1.8"), class = "FutureResult")
[10:19:21.105]     }, finally = {
[10:19:21.105]         if (!identical(...future.workdir, getwd())) 
[10:19:21.105]             setwd(...future.workdir)
[10:19:21.105]         {
[10:19:21.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.105]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.105]             }
[10:19:21.105]             base::options(...future.oldOptions)
[10:19:21.105]             if (.Platform$OS.type == "windows") {
[10:19:21.105]                 old_names <- names(...future.oldEnvVars)
[10:19:21.105]                 envs <- base::Sys.getenv()
[10:19:21.105]                 names <- names(envs)
[10:19:21.105]                 common <- intersect(names, old_names)
[10:19:21.105]                 added <- setdiff(names, old_names)
[10:19:21.105]                 removed <- setdiff(old_names, names)
[10:19:21.105]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.105]                   envs[common]]
[10:19:21.105]                 NAMES <- toupper(changed)
[10:19:21.105]                 args <- list()
[10:19:21.105]                 for (kk in seq_along(NAMES)) {
[10:19:21.105]                   name <- changed[[kk]]
[10:19:21.105]                   NAME <- NAMES[[kk]]
[10:19:21.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.105]                     next
[10:19:21.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.105]                 }
[10:19:21.105]                 NAMES <- toupper(added)
[10:19:21.105]                 for (kk in seq_along(NAMES)) {
[10:19:21.105]                   name <- added[[kk]]
[10:19:21.105]                   NAME <- NAMES[[kk]]
[10:19:21.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.105]                     next
[10:19:21.105]                   args[[name]] <- ""
[10:19:21.105]                 }
[10:19:21.105]                 NAMES <- toupper(removed)
[10:19:21.105]                 for (kk in seq_along(NAMES)) {
[10:19:21.105]                   name <- removed[[kk]]
[10:19:21.105]                   NAME <- NAMES[[kk]]
[10:19:21.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.105]                     next
[10:19:21.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.105]                 }
[10:19:21.105]                 if (length(args) > 0) 
[10:19:21.105]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.105]             }
[10:19:21.105]             else {
[10:19:21.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.105]             }
[10:19:21.105]             {
[10:19:21.105]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.105]                   0L) {
[10:19:21.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.105]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.105]                   base::options(opts)
[10:19:21.105]                 }
[10:19:21.105]                 {
[10:19:21.105]                   {
[10:19:21.105]                     base::assign(".Random.seed", c(10407L, 1357160251L, 
[10:19:21.105]                     225855203L, -549175997L, 1156055373L, -2076787052L, 
[10:19:21.105]                     -581190600L), envir = base::globalenv(), 
[10:19:21.105]                       inherits = FALSE)
[10:19:21.105]                     NULL
[10:19:21.105]                   }
[10:19:21.105]                   options(future.plan = NULL)
[10:19:21.105]                   if (is.na(NA_character_)) 
[10:19:21.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.105]                     .init = FALSE)
[10:19:21.105]                 }
[10:19:21.105]             }
[10:19:21.105]         }
[10:19:21.105]     })
[10:19:21.105]     if (TRUE) {
[10:19:21.105]         base::sink(type = "output", split = FALSE)
[10:19:21.105]         if (TRUE) {
[10:19:21.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.105]         }
[10:19:21.105]         else {
[10:19:21.105]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.105]         }
[10:19:21.105]         base::close(...future.stdout)
[10:19:21.105]         ...future.stdout <- NULL
[10:19:21.105]     }
[10:19:21.105]     ...future.result$conditions <- ...future.conditions
[10:19:21.105]     ...future.result$finished <- base::Sys.time()
[10:19:21.105]     ...future.result
[10:19:21.105] }
[10:19:21.107] assign_globals() ...
[10:19:21.107] List of 5
[10:19:21.107]  $ ...future.FUN            :function (x, w, ...)  
[10:19:21.107]  $ MoreArgs                 : NULL
[10:19:21.107]  $ ...future.elements_ii    :List of 2
[10:19:21.107]   ..$ :List of 5
[10:19:21.107]   .. ..$ : num [1:10] 0.629 0.692 0.555 0.507 0.846 ...
[10:19:21.107]   .. ..$ : num [1:10] 0.1474 0.0239 0.3763 0.9638 0.7402 ...
[10:19:21.107]   .. ..$ : num [1:10] 0.218 0.817 0.738 0.131 0.835 ...
[10:19:21.107]   .. ..$ : num [1:10] 0.82237 0.02887 0.14218 0.64743 0.00727 ...
[10:19:21.107]   .. ..$ : num [1:10] 0.684 0.606 0.874 0.617 0.36 ...
[10:19:21.107]   ..$ :List of 5
[10:19:21.107]   .. ..$ : num [1:10] 6 5 8 10 9 3 6 9 11 7
[10:19:21.107]   .. ..$ : num [1:10] 7 4 8 4 10 4 7 8 10 8
[10:19:21.107]   .. ..$ : num [1:10] 4 4 9 8 7 4 9 6 6 5
[10:19:21.107]   .. ..$ : num [1:10] 7 8 8 10 10 7 6 3 4 5
[10:19:21.107]   .. ..$ : num [1:10] 7 5 7 7 8 8 11 3 6 2
[10:19:21.107]  $ ...future.seeds_ii       : NULL
[10:19:21.107]  $ ...future.globals.maxSize: NULL
[10:19:21.107]  - attr(*, "where")=List of 5
[10:19:21.107]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.107]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.107]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.107]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.107]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.107]  - attr(*, "resolved")= logi FALSE
[10:19:21.107]  - attr(*, "total_size")= num 1345
[10:19:21.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.107]  - attr(*, "already-done")= logi TRUE
[10:19:21.114] - copied ‘...future.FUN’ to environment
[10:19:21.114] - copied ‘MoreArgs’ to environment
[10:19:21.114] - copied ‘...future.elements_ii’ to environment
[10:19:21.114] - copied ‘...future.seeds_ii’ to environment
[10:19:21.114] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.114] assign_globals() ... done
[10:19:21.115] plan(): Setting new future strategy stack:
[10:19:21.115] List of future strategies:
[10:19:21.115] 1. sequential:
[10:19:21.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.115]    - tweaked: FALSE
[10:19:21.115]    - call: NULL
[10:19:21.115] plan(): nbrOfWorkers() = 1
[10:19:21.116] plan(): Setting new future strategy stack:
[10:19:21.116] List of future strategies:
[10:19:21.116] 1. sequential:
[10:19:21.116]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.116]    - tweaked: FALSE
[10:19:21.116]    - call: plan(strategy)
[10:19:21.117] plan(): nbrOfWorkers() = 1
[10:19:21.117] SequentialFuture started (and completed)
[10:19:21.117] - Launch lazy future ... done
[10:19:21.117] run() for ‘SequentialFuture’ ... done
[10:19:21.117] Created future:
[10:19:21.117] SequentialFuture:
[10:19:21.117] Label: ‘future_Map-1’
[10:19:21.117] Expression:
[10:19:21.117] {
[10:19:21.117]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.117]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.117]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.117]         on.exit(options(oopts), add = TRUE)
[10:19:21.117]     }
[10:19:21.117]     {
[10:19:21.117]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.117]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.117]         do.call(mapply, args = args)
[10:19:21.117]     }
[10:19:21.117] }
[10:19:21.117] Lazy evaluation: FALSE
[10:19:21.117] Asynchronous evaluation: FALSE
[10:19:21.117] Local evaluation: TRUE
[10:19:21.117] Environment: R_GlobalEnv
[10:19:21.117] Capture standard output: TRUE
[10:19:21.117] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.117] Globals: 5 objects totaling 1.31 KiB (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 927 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.117] Packages: 1 packages (‘stats’)
[10:19:21.117] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.117] Resolved: TRUE
[10:19:21.117] Value: 111 bytes of class ‘list’
[10:19:21.117] Early signaling: FALSE
[10:19:21.117] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.117] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.118] Chunk #1 of 1 ... DONE
[10:19:21.118] Launching 1 futures (chunks) ... DONE
[10:19:21.118] Resolving 1 futures (chunks) ...
[10:19:21.118] resolve() on list ...
[10:19:21.118]  recursive: 0
[10:19:21.118]  length: 1
[10:19:21.118] 
[10:19:21.119] resolved() for ‘SequentialFuture’ ...
[10:19:21.119] - state: ‘finished’
[10:19:21.119] - run: TRUE
[10:19:21.119] - result: ‘FutureResult’
[10:19:21.119] resolved() for ‘SequentialFuture’ ... done
[10:19:21.119] Future #1
[10:19:21.119] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:21.119] - nx: 1
[10:19:21.119] - relay: TRUE
[10:19:21.119] - stdout: TRUE
[10:19:21.119] - signal: TRUE
[10:19:21.120] - resignal: FALSE
[10:19:21.120] - force: TRUE
[10:19:21.120] - relayed: [n=1] FALSE
[10:19:21.120] - queued futures: [n=1] FALSE
[10:19:21.120]  - until=1
[10:19:21.120]  - relaying element #1
[10:19:21.120] - relayed: [n=1] TRUE
[10:19:21.120] - queued futures: [n=1] TRUE
[10:19:21.120] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:21.120]  length: 0 (resolved future 1)
[10:19:21.120] Relaying remaining futures
[10:19:21.121] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.121] - nx: 1
[10:19:21.121] - relay: TRUE
[10:19:21.121] - stdout: TRUE
[10:19:21.121] - signal: TRUE
[10:19:21.121] - resignal: FALSE
[10:19:21.121] - force: TRUE
[10:19:21.121] - relayed: [n=1] TRUE
[10:19:21.121] - queued futures: [n=1] TRUE
 - flush all
[10:19:21.123] - relayed: [n=1] TRUE
[10:19:21.123] - queued futures: [n=1] TRUE
[10:19:21.123] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.123] resolve() on list ... DONE
[10:19:21.123]  - Number of value chunks collected: 1
[10:19:21.124] Resolving 1 futures (chunks) ... DONE
[10:19:21.124] Reducing values from 1 chunks ...
[10:19:21.124]  - Number of values collected after concatenation: 5
[10:19:21.124]  - Number of values expected: 5
[10:19:21.124] Reducing values from 1 chunks ... DONE
[10:19:21.124] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[10:19:21.126] future_mapply() ...
[10:19:21.126] Number of chunks: 1
[10:19:21.126] getGlobalsAndPackagesXApply() ...
[10:19:21.126]  - future.globals: TRUE
[10:19:21.126] getGlobalsAndPackages() ...
[10:19:21.126] Searching for globals...
[10:19:21.127] - globals found: [1] ‘FUN’
[10:19:21.127] Searching for globals ... DONE
[10:19:21.127] Resolving globals: FALSE
[10:19:21.127] The total size of the 1 globals is 32 bytes (32 bytes)
[10:19:21.128] The total size of the 1 globals exported for future expression (‘FUN()’) is 32 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (32 bytes of class ‘function’)
[10:19:21.128] - globals: [1] ‘FUN’
[10:19:21.128] 
[10:19:21.128] getGlobalsAndPackages() ... DONE
[10:19:21.128]  - globals found/used: [n=1] ‘FUN’
[10:19:21.128]  - needed namespaces: [n=0] 
[10:19:21.128] Finding globals ... DONE
[10:19:21.128] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.129] List of 2
[10:19:21.129]  $ ...future.FUN:function (e1, e2)  
[10:19:21.129]  $ MoreArgs     : NULL
[10:19:21.129]  - attr(*, "where")=List of 2
[10:19:21.129]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.129]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.129]  - attr(*, "resolved")= logi FALSE
[10:19:21.129]  - attr(*, "total_size")= num NA
[10:19:21.131] Packages to be attached in all futures: [n=0] 
[10:19:21.131] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.131] Number of futures (= number of chunks): 1
[10:19:21.131] Launching 1 futures (chunks) ...
[10:19:21.131] Chunk #1 of 1 ...
[10:19:21.131]  - Finding globals in '...' for chunk #1 ...
[10:19:21.132] getGlobalsAndPackages() ...
[10:19:21.132] Searching for globals...
[10:19:21.132] 
[10:19:21.132] Searching for globals ... DONE
[10:19:21.132] - globals: [0] <none>
[10:19:21.132] getGlobalsAndPackages() ... DONE
[10:19:21.132]    + additional globals found: [n=0] 
[10:19:21.132]    + additional namespaces needed: [n=0] 
[10:19:21.132]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.133]  - seeds: <none>
[10:19:21.133]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.133] getGlobalsAndPackages() ...
[10:19:21.133] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.133] Resolving globals: FALSE
[10:19:21.133] The total size of the 5 globals is 244 bytes (244 bytes)
[10:19:21.134] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 244 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (131 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.134] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.134] 
[10:19:21.134] getGlobalsAndPackages() ... DONE
[10:19:21.134] run() for ‘Future’ ...
[10:19:21.134] - state: ‘created’
[10:19:21.134] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:21.135] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:21.135]   - Field: ‘label’
[10:19:21.135]   - Field: ‘local’
[10:19:21.135]   - Field: ‘owner’
[10:19:21.135]   - Field: ‘envir’
[10:19:21.135]   - Field: ‘packages’
[10:19:21.135]   - Field: ‘gc’
[10:19:21.135]   - Field: ‘conditions’
[10:19:21.135]   - Field: ‘expr’
[10:19:21.136]   - Field: ‘uuid’
[10:19:21.136]   - Field: ‘seed’
[10:19:21.136]   - Field: ‘version’
[10:19:21.136]   - Field: ‘result’
[10:19:21.136]   - Field: ‘asynchronous’
[10:19:21.136]   - Field: ‘calls’
[10:19:21.136]   - Field: ‘globals’
[10:19:21.136]   - Field: ‘stdout’
[10:19:21.136]   - Field: ‘earlySignal’
[10:19:21.136]   - Field: ‘lazy’
[10:19:21.136]   - Field: ‘state’
[10:19:21.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:21.137] - Launch lazy future ...
[10:19:21.137] Packages needed by the future expression (n = 0): <none>
[10:19:21.137] Packages needed by future strategies (n = 0): <none>
[10:19:21.137] {
[10:19:21.137]     {
[10:19:21.137]         {
[10:19:21.137]             ...future.startTime <- base::Sys.time()
[10:19:21.137]             {
[10:19:21.137]                 {
[10:19:21.137]                   {
[10:19:21.137]                     base::local({
[10:19:21.137]                       has_future <- base::requireNamespace("future", 
[10:19:21.137]                         quietly = TRUE)
[10:19:21.137]                       if (has_future) {
[10:19:21.137]                         ns <- base::getNamespace("future")
[10:19:21.137]                         version <- ns[[".package"]][["version"]]
[10:19:21.137]                         if (is.null(version)) 
[10:19:21.137]                           version <- utils::packageVersion("future")
[10:19:21.137]                       }
[10:19:21.137]                       else {
[10:19:21.137]                         version <- NULL
[10:19:21.137]                       }
[10:19:21.137]                       if (!has_future || version < "1.8.0") {
[10:19:21.137]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.137]                           "", base::R.version$version.string), 
[10:19:21.137]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:21.137]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.137]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.137]                             "release", "version")], collapse = " "), 
[10:19:21.137]                           hostname = base::Sys.info()[["nodename"]])
[10:19:21.137]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.137]                           info)
[10:19:21.137]                         info <- base::paste(info, collapse = "; ")
[10:19:21.137]                         if (!has_future) {
[10:19:21.137]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.137]                             info)
[10:19:21.137]                         }
[10:19:21.137]                         else {
[10:19:21.137]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.137]                             info, version)
[10:19:21.137]                         }
[10:19:21.137]                         base::stop(msg)
[10:19:21.137]                       }
[10:19:21.137]                     })
[10:19:21.137]                   }
[10:19:21.137]                   ...future.strategy.old <- future::plan("list")
[10:19:21.137]                   options(future.plan = NULL)
[10:19:21.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.137]                 }
[10:19:21.137]                 ...future.workdir <- getwd()
[10:19:21.137]             }
[10:19:21.137]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.137]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.137]         }
[10:19:21.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:21.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.137]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.137]             base::names(...future.oldOptions))
[10:19:21.137]     }
[10:19:21.137]     if (FALSE) {
[10:19:21.137]     }
[10:19:21.137]     else {
[10:19:21.137]         if (TRUE) {
[10:19:21.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.137]                 open = "w")
[10:19:21.137]         }
[10:19:21.137]         else {
[10:19:21.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.137]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.137]         }
[10:19:21.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.137]             base::sink(type = "output", split = FALSE)
[10:19:21.137]             base::close(...future.stdout)
[10:19:21.137]         }, add = TRUE)
[10:19:21.137]     }
[10:19:21.137]     ...future.frame <- base::sys.nframe()
[10:19:21.137]     ...future.conditions <- base::list()
[10:19:21.137]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.137]     if (FALSE) {
[10:19:21.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.137]     }
[10:19:21.137]     ...future.result <- base::tryCatch({
[10:19:21.137]         base::withCallingHandlers({
[10:19:21.137]             ...future.value <- base::withVisible(base::local({
[10:19:21.137]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.137]                 if (!identical(...future.globals.maxSize.org, 
[10:19:21.137]                   ...future.globals.maxSize)) {
[10:19:21.137]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.137]                   on.exit(options(oopts), add = TRUE)
[10:19:21.137]                 }
[10:19:21.137]                 {
[10:19:21.137]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.137]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.137]                     USE.NAMES = FALSE)
[10:19:21.137]                   do.call(mapply, args = args)
[10:19:21.137]                 }
[10:19:21.137]             }))
[10:19:21.137]             future::FutureResult(value = ...future.value$value, 
[10:19:21.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.137]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.137]                     ...future.globalenv.names))
[10:19:21.137]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.137]         }, condition = base::local({
[10:19:21.137]             c <- base::c
[10:19:21.137]             inherits <- base::inherits
[10:19:21.137]             invokeRestart <- base::invokeRestart
[10:19:21.137]             length <- base::length
[10:19:21.137]             list <- base::list
[10:19:21.137]             seq.int <- base::seq.int
[10:19:21.137]             signalCondition <- base::signalCondition
[10:19:21.137]             sys.calls <- base::sys.calls
[10:19:21.137]             `[[` <- base::`[[`
[10:19:21.137]             `+` <- base::`+`
[10:19:21.137]             `<<-` <- base::`<<-`
[10:19:21.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.137]                   3L)]
[10:19:21.137]             }
[10:19:21.137]             function(cond) {
[10:19:21.137]                 is_error <- inherits(cond, "error")
[10:19:21.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.137]                   NULL)
[10:19:21.137]                 if (is_error) {
[10:19:21.137]                   sessionInformation <- function() {
[10:19:21.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.137]                       search = base::search(), system = base::Sys.info())
[10:19:21.137]                   }
[10:19:21.137]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.137]                     cond$call), session = sessionInformation(), 
[10:19:21.137]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.137]                   signalCondition(cond)
[10:19:21.137]                 }
[10:19:21.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.137]                 "immediateCondition"))) {
[10:19:21.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.137]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.137]                   if (TRUE && !signal) {
[10:19:21.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.137]                     {
[10:19:21.137]                       inherits <- base::inherits
[10:19:21.137]                       invokeRestart <- base::invokeRestart
[10:19:21.137]                       is.null <- base::is.null
[10:19:21.137]                       muffled <- FALSE
[10:19:21.137]                       if (inherits(cond, "message")) {
[10:19:21.137]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.137]                         if (muffled) 
[10:19:21.137]                           invokeRestart("muffleMessage")
[10:19:21.137]                       }
[10:19:21.137]                       else if (inherits(cond, "warning")) {
[10:19:21.137]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.137]                         if (muffled) 
[10:19:21.137]                           invokeRestart("muffleWarning")
[10:19:21.137]                       }
[10:19:21.137]                       else if (inherits(cond, "condition")) {
[10:19:21.137]                         if (!is.null(pattern)) {
[10:19:21.137]                           computeRestarts <- base::computeRestarts
[10:19:21.137]                           grepl <- base::grepl
[10:19:21.137]                           restarts <- computeRestarts(cond)
[10:19:21.137]                           for (restart in restarts) {
[10:19:21.137]                             name <- restart$name
[10:19:21.137]                             if (is.null(name)) 
[10:19:21.137]                               next
[10:19:21.137]                             if (!grepl(pattern, name)) 
[10:19:21.137]                               next
[10:19:21.137]                             invokeRestart(restart)
[10:19:21.137]                             muffled <- TRUE
[10:19:21.137]                             break
[10:19:21.137]                           }
[10:19:21.137]                         }
[10:19:21.137]                       }
[10:19:21.137]                       invisible(muffled)
[10:19:21.137]                     }
[10:19:21.137]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.137]                   }
[10:19:21.137]                 }
[10:19:21.137]                 else {
[10:19:21.137]                   if (TRUE) {
[10:19:21.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.137]                     {
[10:19:21.137]                       inherits <- base::inherits
[10:19:21.137]                       invokeRestart <- base::invokeRestart
[10:19:21.137]                       is.null <- base::is.null
[10:19:21.137]                       muffled <- FALSE
[10:19:21.137]                       if (inherits(cond, "message")) {
[10:19:21.137]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.137]                         if (muffled) 
[10:19:21.137]                           invokeRestart("muffleMessage")
[10:19:21.137]                       }
[10:19:21.137]                       else if (inherits(cond, "warning")) {
[10:19:21.137]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.137]                         if (muffled) 
[10:19:21.137]                           invokeRestart("muffleWarning")
[10:19:21.137]                       }
[10:19:21.137]                       else if (inherits(cond, "condition")) {
[10:19:21.137]                         if (!is.null(pattern)) {
[10:19:21.137]                           computeRestarts <- base::computeRestarts
[10:19:21.137]                           grepl <- base::grepl
[10:19:21.137]                           restarts <- computeRestarts(cond)
[10:19:21.137]                           for (restart in restarts) {
[10:19:21.137]                             name <- restart$name
[10:19:21.137]                             if (is.null(name)) 
[10:19:21.137]                               next
[10:19:21.137]                             if (!grepl(pattern, name)) 
[10:19:21.137]                               next
[10:19:21.137]                             invokeRestart(restart)
[10:19:21.137]                             muffled <- TRUE
[10:19:21.137]                             break
[10:19:21.137]                           }
[10:19:21.137]                         }
[10:19:21.137]                       }
[10:19:21.137]                       invisible(muffled)
[10:19:21.137]                     }
[10:19:21.137]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.137]                   }
[10:19:21.137]                 }
[10:19:21.137]             }
[10:19:21.137]         }))
[10:19:21.137]     }, error = function(ex) {
[10:19:21.137]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.137]                 ...future.rng), started = ...future.startTime, 
[10:19:21.137]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.137]             version = "1.8"), class = "FutureResult")
[10:19:21.137]     }, finally = {
[10:19:21.137]         if (!identical(...future.workdir, getwd())) 
[10:19:21.137]             setwd(...future.workdir)
[10:19:21.137]         {
[10:19:21.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.137]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.137]             }
[10:19:21.137]             base::options(...future.oldOptions)
[10:19:21.137]             if (.Platform$OS.type == "windows") {
[10:19:21.137]                 old_names <- names(...future.oldEnvVars)
[10:19:21.137]                 envs <- base::Sys.getenv()
[10:19:21.137]                 names <- names(envs)
[10:19:21.137]                 common <- intersect(names, old_names)
[10:19:21.137]                 added <- setdiff(names, old_names)
[10:19:21.137]                 removed <- setdiff(old_names, names)
[10:19:21.137]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.137]                   envs[common]]
[10:19:21.137]                 NAMES <- toupper(changed)
[10:19:21.137]                 args <- list()
[10:19:21.137]                 for (kk in seq_along(NAMES)) {
[10:19:21.137]                   name <- changed[[kk]]
[10:19:21.137]                   NAME <- NAMES[[kk]]
[10:19:21.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.137]                     next
[10:19:21.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.137]                 }
[10:19:21.137]                 NAMES <- toupper(added)
[10:19:21.137]                 for (kk in seq_along(NAMES)) {
[10:19:21.137]                   name <- added[[kk]]
[10:19:21.137]                   NAME <- NAMES[[kk]]
[10:19:21.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.137]                     next
[10:19:21.137]                   args[[name]] <- ""
[10:19:21.137]                 }
[10:19:21.137]                 NAMES <- toupper(removed)
[10:19:21.137]                 for (kk in seq_along(NAMES)) {
[10:19:21.137]                   name <- removed[[kk]]
[10:19:21.137]                   NAME <- NAMES[[kk]]
[10:19:21.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.137]                     next
[10:19:21.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.137]                 }
[10:19:21.137]                 if (length(args) > 0) 
[10:19:21.137]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.137]             }
[10:19:21.137]             else {
[10:19:21.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.137]             }
[10:19:21.137]             {
[10:19:21.137]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.137]                   0L) {
[10:19:21.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.137]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.137]                   base::options(opts)
[10:19:21.137]                 }
[10:19:21.137]                 {
[10:19:21.137]                   {
[10:19:21.137]                     base::assign(".Random.seed", c(10407L, 1357160251L, 
[10:19:21.137]                     225855203L, -549175997L, 1156055373L, -2076787052L, 
[10:19:21.137]                     -581190600L), envir = base::globalenv(), 
[10:19:21.137]                       inherits = FALSE)
[10:19:21.137]                     NULL
[10:19:21.137]                   }
[10:19:21.137]                   options(future.plan = NULL)
[10:19:21.137]                   if (is.na(NA_character_)) 
[10:19:21.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.137]                     .init = FALSE)
[10:19:21.137]                 }
[10:19:21.137]             }
[10:19:21.137]         }
[10:19:21.137]     })
[10:19:21.137]     if (TRUE) {
[10:19:21.137]         base::sink(type = "output", split = FALSE)
[10:19:21.137]         if (TRUE) {
[10:19:21.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.137]         }
[10:19:21.137]         else {
[10:19:21.137]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.137]         }
[10:19:21.137]         base::close(...future.stdout)
[10:19:21.137]         ...future.stdout <- NULL
[10:19:21.137]     }
[10:19:21.137]     ...future.result$conditions <- ...future.conditions
[10:19:21.137]     ...future.result$finished <- base::Sys.time()
[10:19:21.137]     ...future.result
[10:19:21.137] }
[10:19:21.139] assign_globals() ...
[10:19:21.139] List of 5
[10:19:21.139]  $ ...future.FUN            :function (e1, e2)  
[10:19:21.139]  $ MoreArgs                 : NULL
[10:19:21.139]  $ ...future.elements_ii    :List of 2
[10:19:21.139]   ..$ :List of 3
[10:19:21.139]   .. ..$ : num 1
[10:19:21.139]   .. ..$ : num 1
[10:19:21.139]   .. ..$ : num 1
[10:19:21.139]   ..$ :List of 3
[10:19:21.139]   .. ..$ : int 1
[10:19:21.139]   .. ..$ : int 2
[10:19:21.139]   .. ..$ : int 3
[10:19:21.139]  $ ...future.seeds_ii       : NULL
[10:19:21.139]  $ ...future.globals.maxSize: NULL
[10:19:21.139]  - attr(*, "where")=List of 5
[10:19:21.139]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.139]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.139]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.139]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.139]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.139]  - attr(*, "resolved")= logi FALSE
[10:19:21.139]  - attr(*, "total_size")= num 244
[10:19:21.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.139]  - attr(*, "already-done")= logi TRUE
[10:19:21.146] - copied ‘...future.FUN’ to environment
[10:19:21.146] - copied ‘MoreArgs’ to environment
[10:19:21.147] - copied ‘...future.elements_ii’ to environment
[10:19:21.147] - copied ‘...future.seeds_ii’ to environment
[10:19:21.147] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.147] assign_globals() ... done
[10:19:21.147] plan(): Setting new future strategy stack:
[10:19:21.147] List of future strategies:
[10:19:21.147] 1. sequential:
[10:19:21.147]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.147]    - tweaked: FALSE
[10:19:21.147]    - call: NULL
[10:19:21.148] plan(): nbrOfWorkers() = 1
[10:19:21.148] plan(): Setting new future strategy stack:
[10:19:21.149] List of future strategies:
[10:19:21.149] 1. sequential:
[10:19:21.149]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.149]    - tweaked: FALSE
[10:19:21.149]    - call: plan(strategy)
[10:19:21.149] plan(): nbrOfWorkers() = 1
[10:19:21.149] SequentialFuture started (and completed)
[10:19:21.149] - Launch lazy future ... done
[10:19:21.149] run() for ‘SequentialFuture’ ... done
[10:19:21.150] Created future:
[10:19:21.150] SequentialFuture:
[10:19:21.150] Label: ‘future_Map-1’
[10:19:21.150] Expression:
[10:19:21.150] {
[10:19:21.150]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.150]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.150]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.150]         on.exit(options(oopts), add = TRUE)
[10:19:21.150]     }
[10:19:21.150]     {
[10:19:21.150]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.150]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.150]         do.call(mapply, args = args)
[10:19:21.150]     }
[10:19:21.150] }
[10:19:21.150] Lazy evaluation: FALSE
[10:19:21.150] Asynchronous evaluation: FALSE
[10:19:21.150] Local evaluation: TRUE
[10:19:21.150] Environment: R_GlobalEnv
[10:19:21.150] Capture standard output: TRUE
[10:19:21.150] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.150] Globals: 5 objects totaling 244 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 131 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.150] Packages: <none>
[10:19:21.150] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.150] Resolved: TRUE
[10:19:21.150] Value: 79 bytes of class ‘list’
[10:19:21.150] Early signaling: FALSE
[10:19:21.150] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.150] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.150] Chunk #1 of 1 ... DONE
[10:19:21.150] Launching 1 futures (chunks) ... DONE
[10:19:21.151] Resolving 1 futures (chunks) ...
[10:19:21.151] resolve() on list ...
[10:19:21.151]  recursive: 0
[10:19:21.151]  length: 1
[10:19:21.151] 
[10:19:21.151] resolved() for ‘SequentialFuture’ ...
[10:19:21.151] - state: ‘finished’
[10:19:21.151] - run: TRUE
[10:19:21.151] - result: ‘FutureResult’
[10:19:21.151] resolved() for ‘SequentialFuture’ ... done
[10:19:21.151] Future #1
[10:19:21.152] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:21.152] - nx: 1
[10:19:21.152] - relay: TRUE
[10:19:21.152] - stdout: TRUE
[10:19:21.152] - signal: TRUE
[10:19:21.152] - resignal: FALSE
[10:19:21.152] - force: TRUE
[10:19:21.152] - relayed: [n=1] FALSE
[10:19:21.152] - queued futures: [n=1] FALSE
[10:19:21.152]  - until=1
[10:19:21.152]  - relaying element #1
[10:19:21.153] - relayed: [n=1] TRUE
[10:19:21.153] - queued futures: [n=1] TRUE
[10:19:21.153] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:21.153]  length: 0 (resolved future 1)
[10:19:21.153] Relaying remaining futures
[10:19:21.153] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.153] - nx: 1
[10:19:21.153] - relay: TRUE
[10:19:21.153] - stdout: TRUE
[10:19:21.153] - signal: TRUE
[10:19:21.153] - resignal: FALSE
[10:19:21.153] - force: TRUE
[10:19:21.154] - relayed: [n=1] TRUE
[10:19:21.154] - queued futures: [n=1] TRUE
 - flush all
[10:19:21.154] - relayed: [n=1] TRUE
[10:19:21.154] - queued futures: [n=1] TRUE
[10:19:21.154] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.154] resolve() on list ... DONE
[10:19:21.154]  - Number of value chunks collected: 1
[10:19:21.154] Resolving 1 futures (chunks) ... DONE
[10:19:21.154] Reducing values from 1 chunks ...
[10:19:21.154]  - Number of values collected after concatenation: 3
[10:19:21.154]  - Number of values expected: 3
[10:19:21.155] Reducing values from 1 chunks ... DONE
[10:19:21.155] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[10:19:21.155] future_mapply() ...
[10:19:21.155] Number of chunks: 1
[10:19:21.155] getGlobalsAndPackagesXApply() ...
[10:19:21.155]  - future.globals: TRUE
[10:19:21.155] getGlobalsAndPackages() ...
[10:19:21.156] Searching for globals...
[10:19:21.156] - globals found: [1] ‘FUN’
[10:19:21.157] Searching for globals ... DONE
[10:19:21.157] Resolving globals: FALSE
[10:19:21.157] The total size of the 1 globals is 185 bytes (185 bytes)
[10:19:21.157] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:19:21.157] - globals: [1] ‘FUN’
[10:19:21.157] 
[10:19:21.158] getGlobalsAndPackages() ... DONE
[10:19:21.158]  - globals found/used: [n=1] ‘FUN’
[10:19:21.158]  - needed namespaces: [n=0] 
[10:19:21.158] Finding globals ... DONE
[10:19:21.158] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.158] List of 2
[10:19:21.158]  $ ...future.FUN:function (x)  
[10:19:21.158]  $ MoreArgs     : NULL
[10:19:21.158]  - attr(*, "where")=List of 2
[10:19:21.158]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.158]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.158]  - attr(*, "resolved")= logi FALSE
[10:19:21.158]  - attr(*, "total_size")= num NA
[10:19:21.160] Packages to be attached in all futures: [n=0] 
[10:19:21.160] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.161] Number of futures (= number of chunks): 1
[10:19:21.161] Launching 1 futures (chunks) ...
[10:19:21.161] Chunk #1 of 1 ...
[10:19:21.161]  - Finding globals in '...' for chunk #1 ...
[10:19:21.161] getGlobalsAndPackages() ...
[10:19:21.161] Searching for globals...
[10:19:21.161] 
[10:19:21.162] Searching for globals ... DONE
[10:19:21.162] - globals: [0] <none>
[10:19:21.162] getGlobalsAndPackages() ... DONE
[10:19:21.162]    + additional globals found: [n=0] 
[10:19:21.162]    + additional namespaces needed: [n=0] 
[10:19:21.162]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.162]  - seeds: <none>
[10:19:21.162]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.162] getGlobalsAndPackages() ...
[10:19:21.162] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.162] Resolving globals: FALSE
[10:19:21.163] The total size of the 5 globals is 388 bytes (388 bytes)
[10:19:21.163] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 388 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (122 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.163] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.163] 
[10:19:21.163] getGlobalsAndPackages() ... DONE
[10:19:21.164] run() for ‘Future’ ...
[10:19:21.164] - state: ‘created’
[10:19:21.164] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:19:21.164] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.164] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:19:21.164]   - Field: ‘label’
[10:19:21.165]   - Field: ‘local’
[10:19:21.165]   - Field: ‘owner’
[10:19:21.165]   - Field: ‘envir’
[10:19:21.165]   - Field: ‘packages’
[10:19:21.165]   - Field: ‘gc’
[10:19:21.165]   - Field: ‘conditions’
[10:19:21.165]   - Field: ‘expr’
[10:19:21.165]   - Field: ‘uuid’
[10:19:21.165]   - Field: ‘seed’
[10:19:21.165]   - Field: ‘version’
[10:19:21.165]   - Field: ‘result’
[10:19:21.165]   - Field: ‘asynchronous’
[10:19:21.166]   - Field: ‘calls’
[10:19:21.166]   - Field: ‘globals’
[10:19:21.166]   - Field: ‘stdout’
[10:19:21.166]   - Field: ‘earlySignal’
[10:19:21.166]   - Field: ‘lazy’
[10:19:21.166]   - Field: ‘state’
[10:19:21.166] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:19:21.166] - Launch lazy future ...
[10:19:21.166] Packages needed by the future expression (n = 0): <none>
[10:19:21.166] Packages needed by future strategies (n = 0): <none>
[10:19:21.167] {
[10:19:21.167]     {
[10:19:21.167]         {
[10:19:21.167]             ...future.startTime <- base::Sys.time()
[10:19:21.167]             {
[10:19:21.167]                 {
[10:19:21.167]                   {
[10:19:21.167]                     base::local({
[10:19:21.167]                       has_future <- base::requireNamespace("future", 
[10:19:21.167]                         quietly = TRUE)
[10:19:21.167]                       if (has_future) {
[10:19:21.167]                         ns <- base::getNamespace("future")
[10:19:21.167]                         version <- ns[[".package"]][["version"]]
[10:19:21.167]                         if (is.null(version)) 
[10:19:21.167]                           version <- utils::packageVersion("future")
[10:19:21.167]                       }
[10:19:21.167]                       else {
[10:19:21.167]                         version <- NULL
[10:19:21.167]                       }
[10:19:21.167]                       if (!has_future || version < "1.8.0") {
[10:19:21.167]                         info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.167]                           "", base::R.version$version.string), 
[10:19:21.167]                           platform = base::sprintf("%s (%s-bit)", 
[10:19:21.167]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.167]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.167]                             "release", "version")], collapse = " "), 
[10:19:21.167]                           hostname = base::Sys.info()[["nodename"]])
[10:19:21.167]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.167]                           info)
[10:19:21.167]                         info <- base::paste(info, collapse = "; ")
[10:19:21.167]                         if (!has_future) {
[10:19:21.167]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.167]                             info)
[10:19:21.167]                         }
[10:19:21.167]                         else {
[10:19:21.167]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.167]                             info, version)
[10:19:21.167]                         }
[10:19:21.167]                         base::stop(msg)
[10:19:21.167]                       }
[10:19:21.167]                     })
[10:19:21.167]                   }
[10:19:21.167]                   ...future.strategy.old <- future::plan("list")
[10:19:21.167]                   options(future.plan = NULL)
[10:19:21.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.167]                 }
[10:19:21.167]                 ...future.workdir <- getwd()
[10:19:21.167]             }
[10:19:21.167]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.167]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.167]         }
[10:19:21.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.167]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:21.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.167]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.167]             base::names(...future.oldOptions))
[10:19:21.167]     }
[10:19:21.167]     if (FALSE) {
[10:19:21.167]     }
[10:19:21.167]     else {
[10:19:21.167]         if (TRUE) {
[10:19:21.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.167]                 open = "w")
[10:19:21.167]         }
[10:19:21.167]         else {
[10:19:21.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.167]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.167]         }
[10:19:21.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.167]             base::sink(type = "output", split = FALSE)
[10:19:21.167]             base::close(...future.stdout)
[10:19:21.167]         }, add = TRUE)
[10:19:21.167]     }
[10:19:21.167]     ...future.frame <- base::sys.nframe()
[10:19:21.167]     ...future.conditions <- base::list()
[10:19:21.167]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.167]     if (FALSE) {
[10:19:21.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.167]     }
[10:19:21.167]     ...future.result <- base::tryCatch({
[10:19:21.167]         base::withCallingHandlers({
[10:19:21.167]             ...future.value <- base::withVisible(base::local({
[10:19:21.167]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.167]                 if (!identical(...future.globals.maxSize.org, 
[10:19:21.167]                   ...future.globals.maxSize)) {
[10:19:21.167]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.167]                   on.exit(options(oopts), add = TRUE)
[10:19:21.167]                 }
[10:19:21.167]                 {
[10:19:21.167]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.167]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.167]                     USE.NAMES = FALSE)
[10:19:21.167]                   do.call(mapply, args = args)
[10:19:21.167]                 }
[10:19:21.167]             }))
[10:19:21.167]             future::FutureResult(value = ...future.value$value, 
[10:19:21.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.167]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.167]                     ...future.globalenv.names))
[10:19:21.167]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.167]         }, condition = base::local({
[10:19:21.167]             c <- base::c
[10:19:21.167]             inherits <- base::inherits
[10:19:21.167]             invokeRestart <- base::invokeRestart
[10:19:21.167]             length <- base::length
[10:19:21.167]             list <- base::list
[10:19:21.167]             seq.int <- base::seq.int
[10:19:21.167]             signalCondition <- base::signalCondition
[10:19:21.167]             sys.calls <- base::sys.calls
[10:19:21.167]             `[[` <- base::`[[`
[10:19:21.167]             `+` <- base::`+`
[10:19:21.167]             `<<-` <- base::`<<-`
[10:19:21.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.167]                   3L)]
[10:19:21.167]             }
[10:19:21.167]             function(cond) {
[10:19:21.167]                 is_error <- inherits(cond, "error")
[10:19:21.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.167]                   NULL)
[10:19:21.167]                 if (is_error) {
[10:19:21.167]                   sessionInformation <- function() {
[10:19:21.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.167]                       search = base::search(), system = base::Sys.info())
[10:19:21.167]                   }
[10:19:21.167]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.167]                     cond$call), session = sessionInformation(), 
[10:19:21.167]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.167]                   signalCondition(cond)
[10:19:21.167]                 }
[10:19:21.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.167]                 "immediateCondition"))) {
[10:19:21.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.167]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.167]                   if (TRUE && !signal) {
[10:19:21.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.167]                     {
[10:19:21.167]                       inherits <- base::inherits
[10:19:21.167]                       invokeRestart <- base::invokeRestart
[10:19:21.167]                       is.null <- base::is.null
[10:19:21.167]                       muffled <- FALSE
[10:19:21.167]                       if (inherits(cond, "message")) {
[10:19:21.167]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.167]                         if (muffled) 
[10:19:21.167]                           invokeRestart("muffleMessage")
[10:19:21.167]                       }
[10:19:21.167]                       else if (inherits(cond, "warning")) {
[10:19:21.167]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.167]                         if (muffled) 
[10:19:21.167]                           invokeRestart("muffleWarning")
[10:19:21.167]                       }
[10:19:21.167]                       else if (inherits(cond, "condition")) {
[10:19:21.167]                         if (!is.null(pattern)) {
[10:19:21.167]                           computeRestarts <- base::computeRestarts
[10:19:21.167]                           grepl <- base::grepl
[10:19:21.167]                           restarts <- computeRestarts(cond)
[10:19:21.167]                           for (restart in restarts) {
[10:19:21.167]                             name <- restart$name
[10:19:21.167]                             if (is.null(name)) 
[10:19:21.167]                               next
[10:19:21.167]                             if (!grepl(pattern, name)) 
[10:19:21.167]                               next
[10:19:21.167]                             invokeRestart(restart)
[10:19:21.167]                             muffled <- TRUE
[10:19:21.167]                             break
[10:19:21.167]                           }
[10:19:21.167]                         }
[10:19:21.167]                       }
[10:19:21.167]                       invisible(muffled)
[10:19:21.167]                     }
[10:19:21.167]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.167]                   }
[10:19:21.167]                 }
[10:19:21.167]                 else {
[10:19:21.167]                   if (TRUE) {
[10:19:21.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.167]                     {
[10:19:21.167]                       inherits <- base::inherits
[10:19:21.167]                       invokeRestart <- base::invokeRestart
[10:19:21.167]                       is.null <- base::is.null
[10:19:21.167]                       muffled <- FALSE
[10:19:21.167]                       if (inherits(cond, "message")) {
[10:19:21.167]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.167]                         if (muffled) 
[10:19:21.167]                           invokeRestart("muffleMessage")
[10:19:21.167]                       }
[10:19:21.167]                       else if (inherits(cond, "warning")) {
[10:19:21.167]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.167]                         if (muffled) 
[10:19:21.167]                           invokeRestart("muffleWarning")
[10:19:21.167]                       }
[10:19:21.167]                       else if (inherits(cond, "condition")) {
[10:19:21.167]                         if (!is.null(pattern)) {
[10:19:21.167]                           computeRestarts <- base::computeRestarts
[10:19:21.167]                           grepl <- base::grepl
[10:19:21.167]                           restarts <- computeRestarts(cond)
[10:19:21.167]                           for (restart in restarts) {
[10:19:21.167]                             name <- restart$name
[10:19:21.167]                             if (is.null(name)) 
[10:19:21.167]                               next
[10:19:21.167]                             if (!grepl(pattern, name)) 
[10:19:21.167]                               next
[10:19:21.167]                             invokeRestart(restart)
[10:19:21.167]                             muffled <- TRUE
[10:19:21.167]                             break
[10:19:21.167]                           }
[10:19:21.167]                         }
[10:19:21.167]                       }
[10:19:21.167]                       invisible(muffled)
[10:19:21.167]                     }
[10:19:21.167]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.167]                   }
[10:19:21.167]                 }
[10:19:21.167]             }
[10:19:21.167]         }))
[10:19:21.167]     }, error = function(ex) {
[10:19:21.167]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.167]                 ...future.rng), started = ...future.startTime, 
[10:19:21.167]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.167]             version = "1.8"), class = "FutureResult")
[10:19:21.167]     }, finally = {
[10:19:21.167]         if (!identical(...future.workdir, getwd())) 
[10:19:21.167]             setwd(...future.workdir)
[10:19:21.167]         {
[10:19:21.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.167]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.167]             }
[10:19:21.167]             base::options(...future.oldOptions)
[10:19:21.167]             if (.Platform$OS.type == "windows") {
[10:19:21.167]                 old_names <- names(...future.oldEnvVars)
[10:19:21.167]                 envs <- base::Sys.getenv()
[10:19:21.167]                 names <- names(envs)
[10:19:21.167]                 common <- intersect(names, old_names)
[10:19:21.167]                 added <- setdiff(names, old_names)
[10:19:21.167]                 removed <- setdiff(old_names, names)
[10:19:21.167]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.167]                   envs[common]]
[10:19:21.167]                 NAMES <- toupper(changed)
[10:19:21.167]                 args <- list()
[10:19:21.167]                 for (kk in seq_along(NAMES)) {
[10:19:21.167]                   name <- changed[[kk]]
[10:19:21.167]                   NAME <- NAMES[[kk]]
[10:19:21.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.167]                     next
[10:19:21.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.167]                 }
[10:19:21.167]                 NAMES <- toupper(added)
[10:19:21.167]                 for (kk in seq_along(NAMES)) {
[10:19:21.167]                   name <- added[[kk]]
[10:19:21.167]                   NAME <- NAMES[[kk]]
[10:19:21.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.167]                     next
[10:19:21.167]                   args[[name]] <- ""
[10:19:21.167]                 }
[10:19:21.167]                 NAMES <- toupper(removed)
[10:19:21.167]                 for (kk in seq_along(NAMES)) {
[10:19:21.167]                   name <- removed[[kk]]
[10:19:21.167]                   NAME <- NAMES[[kk]]
[10:19:21.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.167]                     next
[10:19:21.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.167]                 }
[10:19:21.167]                 if (length(args) > 0) 
[10:19:21.167]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.167]             }
[10:19:21.167]             else {
[10:19:21.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.167]             }
[10:19:21.167]             {
[10:19:21.167]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.167]                   0L) {
[10:19:21.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.167]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.167]                   base::options(opts)
[10:19:21.167]                 }
[10:19:21.167]                 {
[10:19:21.167]                   {
[10:19:21.167]                     base::assign(".Random.seed", c(10407L, 1357160251L, 
[10:19:21.167]                     225855203L, -549175997L, 1156055373L, -2076787052L, 
[10:19:21.167]                     -581190600L), envir = base::globalenv(), 
[10:19:21.167]                       inherits = FALSE)
[10:19:21.167]                     NULL
[10:19:21.167]                   }
[10:19:21.167]                   options(future.plan = NULL)
[10:19:21.167]                   if (is.na(NA_character_)) 
[10:19:21.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.167]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.167]                     .init = FALSE)
[10:19:21.167]                 }
[10:19:21.167]             }
[10:19:21.167]         }
[10:19:21.167]     })
[10:19:21.167]     if (TRUE) {
[10:19:21.167]         base::sink(type = "output", split = FALSE)
[10:19:21.167]         if (TRUE) {
[10:19:21.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.167]         }
[10:19:21.167]         else {
[10:19:21.167]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.167]         }
[10:19:21.167]         base::close(...future.stdout)
[10:19:21.167]         ...future.stdout <- NULL
[10:19:21.167]     }
[10:19:21.167]     ...future.result$conditions <- ...future.conditions
[10:19:21.167]     ...future.result$finished <- base::Sys.time()
[10:19:21.167]     ...future.result
[10:19:21.167] }
[10:19:21.168] assign_globals() ...
[10:19:21.169] List of 5
[10:19:21.169]  $ ...future.FUN            :function (x)  
[10:19:21.169]  $ MoreArgs                 : NULL
[10:19:21.169]  $ ...future.elements_ii    :List of 1
[10:19:21.169]   ..$ :List of 2
[10:19:21.169]   .. ..$ a: num 0
[10:19:21.169]   .. ..$ b: num 0
[10:19:21.169]  $ ...future.seeds_ii       : NULL
[10:19:21.169]  $ ...future.globals.maxSize: NULL
[10:19:21.169]  - attr(*, "where")=List of 5
[10:19:21.169]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.169]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.169]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.169]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.169]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.169]  - attr(*, "resolved")= logi FALSE
[10:19:21.169]  - attr(*, "total_size")= num 388
[10:19:21.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.169]  - attr(*, "already-done")= logi TRUE
[10:19:21.175] - copied ‘...future.FUN’ to environment
[10:19:21.175] - copied ‘MoreArgs’ to environment
[10:19:21.175] - copied ‘...future.elements_ii’ to environment
[10:19:21.175] - copied ‘...future.seeds_ii’ to environment
[10:19:21.175] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.176] assign_globals() ... done
[10:19:21.176] plan(): Setting new future strategy stack:
[10:19:21.176] List of future strategies:
[10:19:21.176] 1. sequential:
[10:19:21.176]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.176]    - tweaked: FALSE
[10:19:21.176]    - call: NULL
[10:19:21.176] plan(): nbrOfWorkers() = 1
[10:19:21.177] plan(): Setting new future strategy stack:
[10:19:21.177] List of future strategies:
[10:19:21.177] 1. sequential:
[10:19:21.177]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.177]    - tweaked: FALSE
[10:19:21.177]    - call: plan(strategy)
[10:19:21.178] plan(): nbrOfWorkers() = 1
[10:19:21.178] SequentialFuture started (and completed)
[10:19:21.178] - Launch lazy future ... done
[10:19:21.178] run() for ‘SequentialFuture’ ... done
[10:19:21.178] Created future:
[10:19:21.178] SequentialFuture:
[10:19:21.178] Label: ‘future_mapply-1’
[10:19:21.178] Expression:
[10:19:21.178] {
[10:19:21.178]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.178]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.178]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.178]         on.exit(options(oopts), add = TRUE)
[10:19:21.178]     }
[10:19:21.178]     {
[10:19:21.178]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.178]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.178]         do.call(mapply, args = args)
[10:19:21.178]     }
[10:19:21.178] }
[10:19:21.178] Lazy evaluation: FALSE
[10:19:21.178] Asynchronous evaluation: FALSE
[10:19:21.178] Local evaluation: TRUE
[10:19:21.178] Environment: R_GlobalEnv
[10:19:21.178] Capture standard output: TRUE
[10:19:21.178] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.178] Globals: 5 objects totaling 388 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 122 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.178] Packages: <none>
[10:19:21.178] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.178] Resolved: TRUE
[10:19:21.178] Value: 63 bytes of class ‘list’
[10:19:21.178] Early signaling: FALSE
[10:19:21.178] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.178] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:19:21.179] Chunk #1 of 1 ... DONE
[10:19:21.179] Launching 1 futures (chunks) ... DONE
[10:19:21.179] Resolving 1 futures (chunks) ...
[10:19:21.179] resolve() on list ...
[10:19:21.179]  recursive: 0
[10:19:21.179]  length: 1
[10:19:21.179] 
[10:19:21.179] resolved() for ‘SequentialFuture’ ...
[10:19:21.180] - state: ‘finished’
[10:19:21.180] - run: TRUE
[10:19:21.180] - result: ‘FutureResult’
[10:19:21.180] resolved() for ‘SequentialFuture’ ... done
[10:19:21.180] Future #1
[10:19:21.180] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:19:21.180] - nx: 1
[10:19:21.180] - relay: TRUE
[10:19:21.180] - stdout: TRUE
[10:19:21.180] - signal: TRUE
[10:19:21.180] - resignal: FALSE
[10:19:21.180] - force: TRUE
[10:19:21.181] - relayed: [n=1] FALSE
[10:19:21.181] - queued futures: [n=1] FALSE
[10:19:21.181]  - until=1
[10:19:21.181]  - relaying element #1
[10:19:21.181] - relayed: [n=1] TRUE
[10:19:21.181] - queued futures: [n=1] TRUE
[10:19:21.181] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:19:21.181]  length: 0 (resolved future 1)
[10:19:21.181] Relaying remaining futures
[10:19:21.181] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.181] - nx: 1
[10:19:21.182] - relay: TRUE
[10:19:21.182] - stdout: TRUE
[10:19:21.182] - signal: TRUE
[10:19:21.182] - resignal: FALSE
[10:19:21.182] - force: TRUE
[10:19:21.182] - relayed: [n=1] TRUE
[10:19:21.182] - queued futures: [n=1] TRUE
 - flush all
[10:19:21.182] - relayed: [n=1] TRUE
[10:19:21.182] - queued futures: [n=1] TRUE
[10:19:21.182] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.182] resolve() on list ... DONE
[10:19:21.182]  - Number of value chunks collected: 1
[10:19:21.183] Resolving 1 futures (chunks) ... DONE
[10:19:21.183] Reducing values from 1 chunks ...
[10:19:21.183]  - Number of values collected after concatenation: 2
[10:19:21.183]  - Number of values expected: 2
[10:19:21.183] Reducing values from 1 chunks ... DONE
[10:19:21.183] future_mapply() ... DONE
[10:19:21.183] plan(): Setting new future strategy stack:
[10:19:21.183] List of future strategies:
[10:19:21.183] 1. sequential:
[10:19:21.183]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.183]    - tweaked: FALSE
[10:19:21.183]    - call: plan(sequential)
[10:19:21.184] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:19:21.184] plan(): Setting new future strategy stack:
[10:19:21.184] List of future strategies:
[10:19:21.184] 1. multicore:
[10:19:21.184]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.184]    - tweaked: FALSE
[10:19:21.184]    - call: plan(strategy)
[10:19:21.186] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[10:19:21.186] future_mapply() ...
[10:19:21.188] Number of chunks: 2
[10:19:21.188] getGlobalsAndPackagesXApply() ...
[10:19:21.188]  - future.globals: TRUE
[10:19:21.188] getGlobalsAndPackages() ...
[10:19:21.188] Searching for globals...
[10:19:21.189] - globals found: [1] ‘FUN’
[10:19:21.189] Searching for globals ... DONE
[10:19:21.189] Resolving globals: FALSE
[10:19:21.189] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:21.189] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:21.189] - globals: [1] ‘FUN’
[10:19:21.190] 
[10:19:21.190] getGlobalsAndPackages() ... DONE
[10:19:21.190]  - globals found/used: [n=1] ‘FUN’
[10:19:21.190]  - needed namespaces: [n=0] 
[10:19:21.190] Finding globals ... DONE
[10:19:21.190] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.190] List of 2
[10:19:21.190]  $ ...future.FUN:function (x, ...)  
[10:19:21.190]  $ MoreArgs     : NULL
[10:19:21.190]  - attr(*, "where")=List of 2
[10:19:21.190]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.190]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.190]  - attr(*, "resolved")= logi FALSE
[10:19:21.190]  - attr(*, "total_size")= num NA
[10:19:21.194] Packages to be attached in all futures: [n=0] 
[10:19:21.194] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.194] Number of futures (= number of chunks): 2
[10:19:21.194] Launching 2 futures (chunks) ...
[10:19:21.194] Chunk #1 of 2 ...
[10:19:21.195]  - Finding globals in '...' for chunk #1 ...
[10:19:21.195] getGlobalsAndPackages() ...
[10:19:21.195] Searching for globals...
[10:19:21.195] 
[10:19:21.195] Searching for globals ... DONE
[10:19:21.195] - globals: [0] <none>
[10:19:21.195] getGlobalsAndPackages() ... DONE
[10:19:21.195]    + additional globals found: [n=0] 
[10:19:21.196]    + additional namespaces needed: [n=0] 
[10:19:21.196]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.196]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.196]  - seeds: <none>
[10:19:21.196]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.196] getGlobalsAndPackages() ...
[10:19:21.196] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.196] Resolving globals: FALSE
[10:19:21.197] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:21.197] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.197] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.197] 
[10:19:21.197] getGlobalsAndPackages() ... DONE
[10:19:21.198] run() for ‘Future’ ...
[10:19:21.198] - state: ‘created’
[10:19:21.198] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.199] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.200]   - Field: ‘label’
[10:19:21.200]   - Field: ‘local’
[10:19:21.200]   - Field: ‘owner’
[10:19:21.200]   - Field: ‘envir’
[10:19:21.200]   - Field: ‘workers’
[10:19:21.200]   - Field: ‘packages’
[10:19:21.200]   - Field: ‘gc’
[10:19:21.200]   - Field: ‘job’
[10:19:21.200]   - Field: ‘conditions’
[10:19:21.200]   - Field: ‘expr’
[10:19:21.201]   - Field: ‘uuid’
[10:19:21.201]   - Field: ‘seed’
[10:19:21.201]   - Field: ‘version’
[10:19:21.201]   - Field: ‘result’
[10:19:21.201]   - Field: ‘asynchronous’
[10:19:21.201]   - Field: ‘calls’
[10:19:21.201]   - Field: ‘globals’
[10:19:21.201]   - Field: ‘stdout’
[10:19:21.201]   - Field: ‘earlySignal’
[10:19:21.201]   - Field: ‘lazy’
[10:19:21.201]   - Field: ‘state’
[10:19:21.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.202] - Launch lazy future ...
[10:19:21.203] Packages needed by the future expression (n = 0): <none>
[10:19:21.203] Packages needed by future strategies (n = 0): <none>
[10:19:21.203] {
[10:19:21.203]     {
[10:19:21.203]         {
[10:19:21.203]             ...future.startTime <- base::Sys.time()
[10:19:21.203]             {
[10:19:21.203]                 {
[10:19:21.203]                   {
[10:19:21.203]                     {
[10:19:21.203]                       base::local({
[10:19:21.203]                         has_future <- base::requireNamespace("future", 
[10:19:21.203]                           quietly = TRUE)
[10:19:21.203]                         if (has_future) {
[10:19:21.203]                           ns <- base::getNamespace("future")
[10:19:21.203]                           version <- ns[[".package"]][["version"]]
[10:19:21.203]                           if (is.null(version)) 
[10:19:21.203]                             version <- utils::packageVersion("future")
[10:19:21.203]                         }
[10:19:21.203]                         else {
[10:19:21.203]                           version <- NULL
[10:19:21.203]                         }
[10:19:21.203]                         if (!has_future || version < "1.8.0") {
[10:19:21.203]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.203]                             "", base::R.version$version.string), 
[10:19:21.203]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.203]                               "release", "version")], collapse = " "), 
[10:19:21.203]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.203]                             info)
[10:19:21.203]                           info <- base::paste(info, collapse = "; ")
[10:19:21.203]                           if (!has_future) {
[10:19:21.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.203]                               info)
[10:19:21.203]                           }
[10:19:21.203]                           else {
[10:19:21.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.203]                               info, version)
[10:19:21.203]                           }
[10:19:21.203]                           base::stop(msg)
[10:19:21.203]                         }
[10:19:21.203]                       })
[10:19:21.203]                     }
[10:19:21.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.203]                     base::options(mc.cores = 1L)
[10:19:21.203]                   }
[10:19:21.203]                   ...future.strategy.old <- future::plan("list")
[10:19:21.203]                   options(future.plan = NULL)
[10:19:21.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.203]                 }
[10:19:21.203]                 ...future.workdir <- getwd()
[10:19:21.203]             }
[10:19:21.203]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.203]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.203]         }
[10:19:21.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.203]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.203]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.203]             base::names(...future.oldOptions))
[10:19:21.203]     }
[10:19:21.203]     if (FALSE) {
[10:19:21.203]     }
[10:19:21.203]     else {
[10:19:21.203]         if (TRUE) {
[10:19:21.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.203]                 open = "w")
[10:19:21.203]         }
[10:19:21.203]         else {
[10:19:21.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.203]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.203]         }
[10:19:21.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.203]             base::sink(type = "output", split = FALSE)
[10:19:21.203]             base::close(...future.stdout)
[10:19:21.203]         }, add = TRUE)
[10:19:21.203]     }
[10:19:21.203]     ...future.frame <- base::sys.nframe()
[10:19:21.203]     ...future.conditions <- base::list()
[10:19:21.203]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.203]     if (FALSE) {
[10:19:21.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.203]     }
[10:19:21.203]     ...future.result <- base::tryCatch({
[10:19:21.203]         base::withCallingHandlers({
[10:19:21.203]             ...future.value <- base::withVisible(base::local({
[10:19:21.203]                 withCallingHandlers({
[10:19:21.203]                   {
[10:19:21.203]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.203]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.203]                       ...future.globals.maxSize)) {
[10:19:21.203]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.203]                       on.exit(options(oopts), add = TRUE)
[10:19:21.203]                     }
[10:19:21.203]                     {
[10:19:21.203]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.203]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.203]                         USE.NAMES = FALSE)
[10:19:21.203]                       do.call(mapply, args = args)
[10:19:21.203]                     }
[10:19:21.203]                   }
[10:19:21.203]                 }, immediateCondition = function(cond) {
[10:19:21.203]                   save_rds <- function (object, pathname, ...) 
[10:19:21.203]                   {
[10:19:21.203]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.203]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.203]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.203]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.203]                         fi_tmp[["mtime"]])
[10:19:21.203]                     }
[10:19:21.203]                     tryCatch({
[10:19:21.203]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.203]                     }, error = function(ex) {
[10:19:21.203]                       msg <- conditionMessage(ex)
[10:19:21.203]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.203]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.203]                         fi_tmp[["mtime"]], msg)
[10:19:21.203]                       ex$message <- msg
[10:19:21.203]                       stop(ex)
[10:19:21.203]                     })
[10:19:21.203]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.203]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.203]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.203]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.203]                       fi <- file.info(pathname)
[10:19:21.203]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.203]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.203]                         fi[["size"]], fi[["mtime"]])
[10:19:21.203]                       stop(msg)
[10:19:21.203]                     }
[10:19:21.203]                     invisible(pathname)
[10:19:21.203]                   }
[10:19:21.203]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.203]                     rootPath = tempdir()) 
[10:19:21.203]                   {
[10:19:21.203]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.203]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.203]                       tmpdir = path, fileext = ".rds")
[10:19:21.203]                     save_rds(obj, file)
[10:19:21.203]                   }
[10:19:21.203]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.203]                   {
[10:19:21.203]                     inherits <- base::inherits
[10:19:21.203]                     invokeRestart <- base::invokeRestart
[10:19:21.203]                     is.null <- base::is.null
[10:19:21.203]                     muffled <- FALSE
[10:19:21.203]                     if (inherits(cond, "message")) {
[10:19:21.203]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.203]                       if (muffled) 
[10:19:21.203]                         invokeRestart("muffleMessage")
[10:19:21.203]                     }
[10:19:21.203]                     else if (inherits(cond, "warning")) {
[10:19:21.203]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.203]                       if (muffled) 
[10:19:21.203]                         invokeRestart("muffleWarning")
[10:19:21.203]                     }
[10:19:21.203]                     else if (inherits(cond, "condition")) {
[10:19:21.203]                       if (!is.null(pattern)) {
[10:19:21.203]                         computeRestarts <- base::computeRestarts
[10:19:21.203]                         grepl <- base::grepl
[10:19:21.203]                         restarts <- computeRestarts(cond)
[10:19:21.203]                         for (restart in restarts) {
[10:19:21.203]                           name <- restart$name
[10:19:21.203]                           if (is.null(name)) 
[10:19:21.203]                             next
[10:19:21.203]                           if (!grepl(pattern, name)) 
[10:19:21.203]                             next
[10:19:21.203]                           invokeRestart(restart)
[10:19:21.203]                           muffled <- TRUE
[10:19:21.203]                           break
[10:19:21.203]                         }
[10:19:21.203]                       }
[10:19:21.203]                     }
[10:19:21.203]                     invisible(muffled)
[10:19:21.203]                   }
[10:19:21.203]                   muffleCondition(cond)
[10:19:21.203]                 })
[10:19:21.203]             }))
[10:19:21.203]             future::FutureResult(value = ...future.value$value, 
[10:19:21.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.203]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.203]                     ...future.globalenv.names))
[10:19:21.203]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.203]         }, condition = base::local({
[10:19:21.203]             c <- base::c
[10:19:21.203]             inherits <- base::inherits
[10:19:21.203]             invokeRestart <- base::invokeRestart
[10:19:21.203]             length <- base::length
[10:19:21.203]             list <- base::list
[10:19:21.203]             seq.int <- base::seq.int
[10:19:21.203]             signalCondition <- base::signalCondition
[10:19:21.203]             sys.calls <- base::sys.calls
[10:19:21.203]             `[[` <- base::`[[`
[10:19:21.203]             `+` <- base::`+`
[10:19:21.203]             `<<-` <- base::`<<-`
[10:19:21.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.203]                   3L)]
[10:19:21.203]             }
[10:19:21.203]             function(cond) {
[10:19:21.203]                 is_error <- inherits(cond, "error")
[10:19:21.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.203]                   NULL)
[10:19:21.203]                 if (is_error) {
[10:19:21.203]                   sessionInformation <- function() {
[10:19:21.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.203]                       search = base::search(), system = base::Sys.info())
[10:19:21.203]                   }
[10:19:21.203]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.203]                     cond$call), session = sessionInformation(), 
[10:19:21.203]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.203]                   signalCondition(cond)
[10:19:21.203]                 }
[10:19:21.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.203]                 "immediateCondition"))) {
[10:19:21.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.203]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.203]                   if (TRUE && !signal) {
[10:19:21.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.203]                     {
[10:19:21.203]                       inherits <- base::inherits
[10:19:21.203]                       invokeRestart <- base::invokeRestart
[10:19:21.203]                       is.null <- base::is.null
[10:19:21.203]                       muffled <- FALSE
[10:19:21.203]                       if (inherits(cond, "message")) {
[10:19:21.203]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.203]                         if (muffled) 
[10:19:21.203]                           invokeRestart("muffleMessage")
[10:19:21.203]                       }
[10:19:21.203]                       else if (inherits(cond, "warning")) {
[10:19:21.203]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.203]                         if (muffled) 
[10:19:21.203]                           invokeRestart("muffleWarning")
[10:19:21.203]                       }
[10:19:21.203]                       else if (inherits(cond, "condition")) {
[10:19:21.203]                         if (!is.null(pattern)) {
[10:19:21.203]                           computeRestarts <- base::computeRestarts
[10:19:21.203]                           grepl <- base::grepl
[10:19:21.203]                           restarts <- computeRestarts(cond)
[10:19:21.203]                           for (restart in restarts) {
[10:19:21.203]                             name <- restart$name
[10:19:21.203]                             if (is.null(name)) 
[10:19:21.203]                               next
[10:19:21.203]                             if (!grepl(pattern, name)) 
[10:19:21.203]                               next
[10:19:21.203]                             invokeRestart(restart)
[10:19:21.203]                             muffled <- TRUE
[10:19:21.203]                             break
[10:19:21.203]                           }
[10:19:21.203]                         }
[10:19:21.203]                       }
[10:19:21.203]                       invisible(muffled)
[10:19:21.203]                     }
[10:19:21.203]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.203]                   }
[10:19:21.203]                 }
[10:19:21.203]                 else {
[10:19:21.203]                   if (TRUE) {
[10:19:21.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.203]                     {
[10:19:21.203]                       inherits <- base::inherits
[10:19:21.203]                       invokeRestart <- base::invokeRestart
[10:19:21.203]                       is.null <- base::is.null
[10:19:21.203]                       muffled <- FALSE
[10:19:21.203]                       if (inherits(cond, "message")) {
[10:19:21.203]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.203]                         if (muffled) 
[10:19:21.203]                           invokeRestart("muffleMessage")
[10:19:21.203]                       }
[10:19:21.203]                       else if (inherits(cond, "warning")) {
[10:19:21.203]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.203]                         if (muffled) 
[10:19:21.203]                           invokeRestart("muffleWarning")
[10:19:21.203]                       }
[10:19:21.203]                       else if (inherits(cond, "condition")) {
[10:19:21.203]                         if (!is.null(pattern)) {
[10:19:21.203]                           computeRestarts <- base::computeRestarts
[10:19:21.203]                           grepl <- base::grepl
[10:19:21.203]                           restarts <- computeRestarts(cond)
[10:19:21.203]                           for (restart in restarts) {
[10:19:21.203]                             name <- restart$name
[10:19:21.203]                             if (is.null(name)) 
[10:19:21.203]                               next
[10:19:21.203]                             if (!grepl(pattern, name)) 
[10:19:21.203]                               next
[10:19:21.203]                             invokeRestart(restart)
[10:19:21.203]                             muffled <- TRUE
[10:19:21.203]                             break
[10:19:21.203]                           }
[10:19:21.203]                         }
[10:19:21.203]                       }
[10:19:21.203]                       invisible(muffled)
[10:19:21.203]                     }
[10:19:21.203]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.203]                   }
[10:19:21.203]                 }
[10:19:21.203]             }
[10:19:21.203]         }))
[10:19:21.203]     }, error = function(ex) {
[10:19:21.203]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.203]                 ...future.rng), started = ...future.startTime, 
[10:19:21.203]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.203]             version = "1.8"), class = "FutureResult")
[10:19:21.203]     }, finally = {
[10:19:21.203]         if (!identical(...future.workdir, getwd())) 
[10:19:21.203]             setwd(...future.workdir)
[10:19:21.203]         {
[10:19:21.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.203]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.203]             }
[10:19:21.203]             base::options(...future.oldOptions)
[10:19:21.203]             if (.Platform$OS.type == "windows") {
[10:19:21.203]                 old_names <- names(...future.oldEnvVars)
[10:19:21.203]                 envs <- base::Sys.getenv()
[10:19:21.203]                 names <- names(envs)
[10:19:21.203]                 common <- intersect(names, old_names)
[10:19:21.203]                 added <- setdiff(names, old_names)
[10:19:21.203]                 removed <- setdiff(old_names, names)
[10:19:21.203]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.203]                   envs[common]]
[10:19:21.203]                 NAMES <- toupper(changed)
[10:19:21.203]                 args <- list()
[10:19:21.203]                 for (kk in seq_along(NAMES)) {
[10:19:21.203]                   name <- changed[[kk]]
[10:19:21.203]                   NAME <- NAMES[[kk]]
[10:19:21.203]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.203]                     next
[10:19:21.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.203]                 }
[10:19:21.203]                 NAMES <- toupper(added)
[10:19:21.203]                 for (kk in seq_along(NAMES)) {
[10:19:21.203]                   name <- added[[kk]]
[10:19:21.203]                   NAME <- NAMES[[kk]]
[10:19:21.203]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.203]                     next
[10:19:21.203]                   args[[name]] <- ""
[10:19:21.203]                 }
[10:19:21.203]                 NAMES <- toupper(removed)
[10:19:21.203]                 for (kk in seq_along(NAMES)) {
[10:19:21.203]                   name <- removed[[kk]]
[10:19:21.203]                   NAME <- NAMES[[kk]]
[10:19:21.203]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.203]                     next
[10:19:21.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.203]                 }
[10:19:21.203]                 if (length(args) > 0) 
[10:19:21.203]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.203]             }
[10:19:21.203]             else {
[10:19:21.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.203]             }
[10:19:21.203]             {
[10:19:21.203]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.203]                   0L) {
[10:19:21.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.203]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.203]                   base::options(opts)
[10:19:21.203]                 }
[10:19:21.203]                 {
[10:19:21.203]                   {
[10:19:21.203]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.203]                     NULL
[10:19:21.203]                   }
[10:19:21.203]                   options(future.plan = NULL)
[10:19:21.203]                   if (is.na(NA_character_)) 
[10:19:21.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.203]                     .init = FALSE)
[10:19:21.203]                 }
[10:19:21.203]             }
[10:19:21.203]         }
[10:19:21.203]     })
[10:19:21.203]     if (TRUE) {
[10:19:21.203]         base::sink(type = "output", split = FALSE)
[10:19:21.203]         if (TRUE) {
[10:19:21.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.203]         }
[10:19:21.203]         else {
[10:19:21.203]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.203]         }
[10:19:21.203]         base::close(...future.stdout)
[10:19:21.203]         ...future.stdout <- NULL
[10:19:21.203]     }
[10:19:21.203]     ...future.result$conditions <- ...future.conditions
[10:19:21.203]     ...future.result$finished <- base::Sys.time()
[10:19:21.203]     ...future.result
[10:19:21.203] }
[10:19:21.205] assign_globals() ...
[10:19:21.205] List of 5
[10:19:21.205]  $ ...future.FUN            :function (x, ...)  
[10:19:21.205]  $ MoreArgs                 : NULL
[10:19:21.205]  $ ...future.elements_ii    :List of 2
[10:19:21.205]   ..$ :List of 2
[10:19:21.205]   .. ..$ : int 1
[10:19:21.205]   .. ..$ : int 2
[10:19:21.205]   ..$ :List of 2
[10:19:21.205]   .. ..$ : int 4
[10:19:21.205]   .. ..$ : int 3
[10:19:21.205]  $ ...future.seeds_ii       : NULL
[10:19:21.205]  $ ...future.globals.maxSize: NULL
[10:19:21.205]  - attr(*, "where")=List of 5
[10:19:21.205]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.205]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.205]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.205]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.205]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.205]  - attr(*, "resolved")= logi FALSE
[10:19:21.205]  - attr(*, "total_size")= num 210
[10:19:21.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.205]  - attr(*, "already-done")= logi TRUE
[10:19:21.211] - copied ‘...future.FUN’ to environment
[10:19:21.211] - copied ‘MoreArgs’ to environment
[10:19:21.211] - copied ‘...future.elements_ii’ to environment
[10:19:21.211] - copied ‘...future.seeds_ii’ to environment
[10:19:21.211] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.211] assign_globals() ... done
[10:19:21.212] requestCore(): workers = 2
[10:19:21.215] MulticoreFuture started
[10:19:21.215] - Launch lazy future ... done
[10:19:21.215] plan(): Setting new future strategy stack:
[10:19:21.215] run() for ‘MulticoreFuture’ ... done
[10:19:21.216] Created future:
[10:19:21.216] List of future strategies:
[10:19:21.216] 1. sequential:
[10:19:21.216]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.216]    - tweaked: FALSE
[10:19:21.216]    - call: NULL
[10:19:21.217] plan(): nbrOfWorkers() = 1
[10:19:21.219] plan(): Setting new future strategy stack:
[10:19:21.219] List of future strategies:
[10:19:21.219] 1. multicore:
[10:19:21.219]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.219]    - tweaked: FALSE
[10:19:21.219]    - call: plan(strategy)
[10:19:21.222] plan(): nbrOfWorkers() = 2
[10:19:21.216] MulticoreFuture:
[10:19:21.216] Label: ‘future_mapply-1’
[10:19:21.216] Expression:
[10:19:21.216] {
[10:19:21.216]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.216]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.216]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.216]         on.exit(options(oopts), add = TRUE)
[10:19:21.216]     }
[10:19:21.216]     {
[10:19:21.216]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.216]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.216]         do.call(mapply, args = args)
[10:19:21.216]     }
[10:19:21.216] }
[10:19:21.216] Lazy evaluation: FALSE
[10:19:21.216] Asynchronous evaluation: TRUE
[10:19:21.216] Local evaluation: TRUE
[10:19:21.216] Environment: R_GlobalEnv
[10:19:21.216] Capture standard output: TRUE
[10:19:21.216] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.216] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.216] Packages: <none>
[10:19:21.216] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.216] Resolved: TRUE
[10:19:21.216] Value: <not collected>
[10:19:21.216] Conditions captured: <none>
[10:19:21.216] Early signaling: FALSE
[10:19:21.216] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.216] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.224] Chunk #1 of 2 ... DONE
[10:19:21.224] Chunk #2 of 2 ...
[10:19:21.224]  - Finding globals in '...' for chunk #2 ...
[10:19:21.224] getGlobalsAndPackages() ...
[10:19:21.225] Searching for globals...
[10:19:21.225] 
[10:19:21.225] Searching for globals ... DONE
[10:19:21.225] - globals: [0] <none>
[10:19:21.226] getGlobalsAndPackages() ... DONE
[10:19:21.226]    + additional globals found: [n=0] 
[10:19:21.226]    + additional namespaces needed: [n=0] 
[10:19:21.226]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:21.226]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.226]  - seeds: <none>
[10:19:21.227]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.227] getGlobalsAndPackages() ...
[10:19:21.227] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.227] Resolving globals: FALSE
[10:19:21.228] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:21.229] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.229] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.229] 
[10:19:21.230] getGlobalsAndPackages() ... DONE
[10:19:21.230] run() for ‘Future’ ...
[10:19:21.230] - state: ‘created’
[10:19:21.231] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.241] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.242]   - Field: ‘label’
[10:19:21.242]   - Field: ‘local’
[10:19:21.243]   - Field: ‘owner’
[10:19:21.243]   - Field: ‘envir’
[10:19:21.243]   - Field: ‘workers’
[10:19:21.244]   - Field: ‘packages’
[10:19:21.244]   - Field: ‘gc’
[10:19:21.244]   - Field: ‘job’
[10:19:21.245]   - Field: ‘conditions’
[10:19:21.245]   - Field: ‘expr’
[10:19:21.245]   - Field: ‘uuid’
[10:19:21.245]   - Field: ‘seed’
[10:19:21.246]   - Field: ‘version’
[10:19:21.246]   - Field: ‘result’
[10:19:21.246]   - Field: ‘asynchronous’
[10:19:21.247]   - Field: ‘calls’
[10:19:21.247]   - Field: ‘globals’
[10:19:21.247]   - Field: ‘stdout’
[10:19:21.247]   - Field: ‘earlySignal’
[10:19:21.248]   - Field: ‘lazy’
[10:19:21.248]   - Field: ‘state’
[10:19:21.248] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.248] - Launch lazy future ...
[10:19:21.249] Packages needed by the future expression (n = 0): <none>
[10:19:21.249] Packages needed by future strategies (n = 0): <none>
[10:19:21.250] {
[10:19:21.250]     {
[10:19:21.250]         {
[10:19:21.250]             ...future.startTime <- base::Sys.time()
[10:19:21.250]             {
[10:19:21.250]                 {
[10:19:21.250]                   {
[10:19:21.250]                     {
[10:19:21.250]                       base::local({
[10:19:21.250]                         has_future <- base::requireNamespace("future", 
[10:19:21.250]                           quietly = TRUE)
[10:19:21.250]                         if (has_future) {
[10:19:21.250]                           ns <- base::getNamespace("future")
[10:19:21.250]                           version <- ns[[".package"]][["version"]]
[10:19:21.250]                           if (is.null(version)) 
[10:19:21.250]                             version <- utils::packageVersion("future")
[10:19:21.250]                         }
[10:19:21.250]                         else {
[10:19:21.250]                           version <- NULL
[10:19:21.250]                         }
[10:19:21.250]                         if (!has_future || version < "1.8.0") {
[10:19:21.250]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.250]                             "", base::R.version$version.string), 
[10:19:21.250]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.250]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.250]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.250]                               "release", "version")], collapse = " "), 
[10:19:21.250]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.250]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.250]                             info)
[10:19:21.250]                           info <- base::paste(info, collapse = "; ")
[10:19:21.250]                           if (!has_future) {
[10:19:21.250]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.250]                               info)
[10:19:21.250]                           }
[10:19:21.250]                           else {
[10:19:21.250]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.250]                               info, version)
[10:19:21.250]                           }
[10:19:21.250]                           base::stop(msg)
[10:19:21.250]                         }
[10:19:21.250]                       })
[10:19:21.250]                     }
[10:19:21.250]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.250]                     base::options(mc.cores = 1L)
[10:19:21.250]                   }
[10:19:21.250]                   ...future.strategy.old <- future::plan("list")
[10:19:21.250]                   options(future.plan = NULL)
[10:19:21.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.250]                 }
[10:19:21.250]                 ...future.workdir <- getwd()
[10:19:21.250]             }
[10:19:21.250]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.250]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.250]         }
[10:19:21.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.250]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.250]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.250]             base::names(...future.oldOptions))
[10:19:21.250]     }
[10:19:21.250]     if (FALSE) {
[10:19:21.250]     }
[10:19:21.250]     else {
[10:19:21.250]         if (TRUE) {
[10:19:21.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.250]                 open = "w")
[10:19:21.250]         }
[10:19:21.250]         else {
[10:19:21.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.250]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.250]         }
[10:19:21.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.250]             base::sink(type = "output", split = FALSE)
[10:19:21.250]             base::close(...future.stdout)
[10:19:21.250]         }, add = TRUE)
[10:19:21.250]     }
[10:19:21.250]     ...future.frame <- base::sys.nframe()
[10:19:21.250]     ...future.conditions <- base::list()
[10:19:21.250]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.250]     if (FALSE) {
[10:19:21.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.250]     }
[10:19:21.250]     ...future.result <- base::tryCatch({
[10:19:21.250]         base::withCallingHandlers({
[10:19:21.250]             ...future.value <- base::withVisible(base::local({
[10:19:21.250]                 withCallingHandlers({
[10:19:21.250]                   {
[10:19:21.250]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.250]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.250]                       ...future.globals.maxSize)) {
[10:19:21.250]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.250]                       on.exit(options(oopts), add = TRUE)
[10:19:21.250]                     }
[10:19:21.250]                     {
[10:19:21.250]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.250]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.250]                         USE.NAMES = FALSE)
[10:19:21.250]                       do.call(mapply, args = args)
[10:19:21.250]                     }
[10:19:21.250]                   }
[10:19:21.250]                 }, immediateCondition = function(cond) {
[10:19:21.250]                   save_rds <- function (object, pathname, ...) 
[10:19:21.250]                   {
[10:19:21.250]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.250]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.250]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.250]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.250]                         fi_tmp[["mtime"]])
[10:19:21.250]                     }
[10:19:21.250]                     tryCatch({
[10:19:21.250]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.250]                     }, error = function(ex) {
[10:19:21.250]                       msg <- conditionMessage(ex)
[10:19:21.250]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.250]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.250]                         fi_tmp[["mtime"]], msg)
[10:19:21.250]                       ex$message <- msg
[10:19:21.250]                       stop(ex)
[10:19:21.250]                     })
[10:19:21.250]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.250]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.250]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.250]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.250]                       fi <- file.info(pathname)
[10:19:21.250]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.250]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.250]                         fi[["size"]], fi[["mtime"]])
[10:19:21.250]                       stop(msg)
[10:19:21.250]                     }
[10:19:21.250]                     invisible(pathname)
[10:19:21.250]                   }
[10:19:21.250]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.250]                     rootPath = tempdir()) 
[10:19:21.250]                   {
[10:19:21.250]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.250]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.250]                       tmpdir = path, fileext = ".rds")
[10:19:21.250]                     save_rds(obj, file)
[10:19:21.250]                   }
[10:19:21.250]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.250]                   {
[10:19:21.250]                     inherits <- base::inherits
[10:19:21.250]                     invokeRestart <- base::invokeRestart
[10:19:21.250]                     is.null <- base::is.null
[10:19:21.250]                     muffled <- FALSE
[10:19:21.250]                     if (inherits(cond, "message")) {
[10:19:21.250]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.250]                       if (muffled) 
[10:19:21.250]                         invokeRestart("muffleMessage")
[10:19:21.250]                     }
[10:19:21.250]                     else if (inherits(cond, "warning")) {
[10:19:21.250]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.250]                       if (muffled) 
[10:19:21.250]                         invokeRestart("muffleWarning")
[10:19:21.250]                     }
[10:19:21.250]                     else if (inherits(cond, "condition")) {
[10:19:21.250]                       if (!is.null(pattern)) {
[10:19:21.250]                         computeRestarts <- base::computeRestarts
[10:19:21.250]                         grepl <- base::grepl
[10:19:21.250]                         restarts <- computeRestarts(cond)
[10:19:21.250]                         for (restart in restarts) {
[10:19:21.250]                           name <- restart$name
[10:19:21.250]                           if (is.null(name)) 
[10:19:21.250]                             next
[10:19:21.250]                           if (!grepl(pattern, name)) 
[10:19:21.250]                             next
[10:19:21.250]                           invokeRestart(restart)
[10:19:21.250]                           muffled <- TRUE
[10:19:21.250]                           break
[10:19:21.250]                         }
[10:19:21.250]                       }
[10:19:21.250]                     }
[10:19:21.250]                     invisible(muffled)
[10:19:21.250]                   }
[10:19:21.250]                   muffleCondition(cond)
[10:19:21.250]                 })
[10:19:21.250]             }))
[10:19:21.250]             future::FutureResult(value = ...future.value$value, 
[10:19:21.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.250]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.250]                     ...future.globalenv.names))
[10:19:21.250]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.250]         }, condition = base::local({
[10:19:21.250]             c <- base::c
[10:19:21.250]             inherits <- base::inherits
[10:19:21.250]             invokeRestart <- base::invokeRestart
[10:19:21.250]             length <- base::length
[10:19:21.250]             list <- base::list
[10:19:21.250]             seq.int <- base::seq.int
[10:19:21.250]             signalCondition <- base::signalCondition
[10:19:21.250]             sys.calls <- base::sys.calls
[10:19:21.250]             `[[` <- base::`[[`
[10:19:21.250]             `+` <- base::`+`
[10:19:21.250]             `<<-` <- base::`<<-`
[10:19:21.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.250]                   3L)]
[10:19:21.250]             }
[10:19:21.250]             function(cond) {
[10:19:21.250]                 is_error <- inherits(cond, "error")
[10:19:21.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.250]                   NULL)
[10:19:21.250]                 if (is_error) {
[10:19:21.250]                   sessionInformation <- function() {
[10:19:21.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.250]                       search = base::search(), system = base::Sys.info())
[10:19:21.250]                   }
[10:19:21.250]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.250]                     cond$call), session = sessionInformation(), 
[10:19:21.250]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.250]                   signalCondition(cond)
[10:19:21.250]                 }
[10:19:21.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.250]                 "immediateCondition"))) {
[10:19:21.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.250]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.250]                   if (TRUE && !signal) {
[10:19:21.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.250]                     {
[10:19:21.250]                       inherits <- base::inherits
[10:19:21.250]                       invokeRestart <- base::invokeRestart
[10:19:21.250]                       is.null <- base::is.null
[10:19:21.250]                       muffled <- FALSE
[10:19:21.250]                       if (inherits(cond, "message")) {
[10:19:21.250]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.250]                         if (muffled) 
[10:19:21.250]                           invokeRestart("muffleMessage")
[10:19:21.250]                       }
[10:19:21.250]                       else if (inherits(cond, "warning")) {
[10:19:21.250]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.250]                         if (muffled) 
[10:19:21.250]                           invokeRestart("muffleWarning")
[10:19:21.250]                       }
[10:19:21.250]                       else if (inherits(cond, "condition")) {
[10:19:21.250]                         if (!is.null(pattern)) {
[10:19:21.250]                           computeRestarts <- base::computeRestarts
[10:19:21.250]                           grepl <- base::grepl
[10:19:21.250]                           restarts <- computeRestarts(cond)
[10:19:21.250]                           for (restart in restarts) {
[10:19:21.250]                             name <- restart$name
[10:19:21.250]                             if (is.null(name)) 
[10:19:21.250]                               next
[10:19:21.250]                             if (!grepl(pattern, name)) 
[10:19:21.250]                               next
[10:19:21.250]                             invokeRestart(restart)
[10:19:21.250]                             muffled <- TRUE
[10:19:21.250]                             break
[10:19:21.250]                           }
[10:19:21.250]                         }
[10:19:21.250]                       }
[10:19:21.250]                       invisible(muffled)
[10:19:21.250]                     }
[10:19:21.250]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.250]                   }
[10:19:21.250]                 }
[10:19:21.250]                 else {
[10:19:21.250]                   if (TRUE) {
[10:19:21.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.250]                     {
[10:19:21.250]                       inherits <- base::inherits
[10:19:21.250]                       invokeRestart <- base::invokeRestart
[10:19:21.250]                       is.null <- base::is.null
[10:19:21.250]                       muffled <- FALSE
[10:19:21.250]                       if (inherits(cond, "message")) {
[10:19:21.250]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.250]                         if (muffled) 
[10:19:21.250]                           invokeRestart("muffleMessage")
[10:19:21.250]                       }
[10:19:21.250]                       else if (inherits(cond, "warning")) {
[10:19:21.250]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.250]                         if (muffled) 
[10:19:21.250]                           invokeRestart("muffleWarning")
[10:19:21.250]                       }
[10:19:21.250]                       else if (inherits(cond, "condition")) {
[10:19:21.250]                         if (!is.null(pattern)) {
[10:19:21.250]                           computeRestarts <- base::computeRestarts
[10:19:21.250]                           grepl <- base::grepl
[10:19:21.250]                           restarts <- computeRestarts(cond)
[10:19:21.250]                           for (restart in restarts) {
[10:19:21.250]                             name <- restart$name
[10:19:21.250]                             if (is.null(name)) 
[10:19:21.250]                               next
[10:19:21.250]                             if (!grepl(pattern, name)) 
[10:19:21.250]                               next
[10:19:21.250]                             invokeRestart(restart)
[10:19:21.250]                             muffled <- TRUE
[10:19:21.250]                             break
[10:19:21.250]                           }
[10:19:21.250]                         }
[10:19:21.250]                       }
[10:19:21.250]                       invisible(muffled)
[10:19:21.250]                     }
[10:19:21.250]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.250]                   }
[10:19:21.250]                 }
[10:19:21.250]             }
[10:19:21.250]         }))
[10:19:21.250]     }, error = function(ex) {
[10:19:21.250]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.250]                 ...future.rng), started = ...future.startTime, 
[10:19:21.250]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.250]             version = "1.8"), class = "FutureResult")
[10:19:21.250]     }, finally = {
[10:19:21.250]         if (!identical(...future.workdir, getwd())) 
[10:19:21.250]             setwd(...future.workdir)
[10:19:21.250]         {
[10:19:21.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.250]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.250]             }
[10:19:21.250]             base::options(...future.oldOptions)
[10:19:21.250]             if (.Platform$OS.type == "windows") {
[10:19:21.250]                 old_names <- names(...future.oldEnvVars)
[10:19:21.250]                 envs <- base::Sys.getenv()
[10:19:21.250]                 names <- names(envs)
[10:19:21.250]                 common <- intersect(names, old_names)
[10:19:21.250]                 added <- setdiff(names, old_names)
[10:19:21.250]                 removed <- setdiff(old_names, names)
[10:19:21.250]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.250]                   envs[common]]
[10:19:21.250]                 NAMES <- toupper(changed)
[10:19:21.250]                 args <- list()
[10:19:21.250]                 for (kk in seq_along(NAMES)) {
[10:19:21.250]                   name <- changed[[kk]]
[10:19:21.250]                   NAME <- NAMES[[kk]]
[10:19:21.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.250]                     next
[10:19:21.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.250]                 }
[10:19:21.250]                 NAMES <- toupper(added)
[10:19:21.250]                 for (kk in seq_along(NAMES)) {
[10:19:21.250]                   name <- added[[kk]]
[10:19:21.250]                   NAME <- NAMES[[kk]]
[10:19:21.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.250]                     next
[10:19:21.250]                   args[[name]] <- ""
[10:19:21.250]                 }
[10:19:21.250]                 NAMES <- toupper(removed)
[10:19:21.250]                 for (kk in seq_along(NAMES)) {
[10:19:21.250]                   name <- removed[[kk]]
[10:19:21.250]                   NAME <- NAMES[[kk]]
[10:19:21.250]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.250]                     next
[10:19:21.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.250]                 }
[10:19:21.250]                 if (length(args) > 0) 
[10:19:21.250]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.250]             }
[10:19:21.250]             else {
[10:19:21.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.250]             }
[10:19:21.250]             {
[10:19:21.250]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.250]                   0L) {
[10:19:21.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.250]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.250]                   base::options(opts)
[10:19:21.250]                 }
[10:19:21.250]                 {
[10:19:21.250]                   {
[10:19:21.250]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.250]                     NULL
[10:19:21.250]                   }
[10:19:21.250]                   options(future.plan = NULL)
[10:19:21.250]                   if (is.na(NA_character_)) 
[10:19:21.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.250]                     .init = FALSE)
[10:19:21.250]                 }
[10:19:21.250]             }
[10:19:21.250]         }
[10:19:21.250]     })
[10:19:21.250]     if (TRUE) {
[10:19:21.250]         base::sink(type = "output", split = FALSE)
[10:19:21.250]         if (TRUE) {
[10:19:21.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.250]         }
[10:19:21.250]         else {
[10:19:21.250]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.250]         }
[10:19:21.250]         base::close(...future.stdout)
[10:19:21.250]         ...future.stdout <- NULL
[10:19:21.250]     }
[10:19:21.250]     ...future.result$conditions <- ...future.conditions
[10:19:21.250]     ...future.result$finished <- base::Sys.time()
[10:19:21.250]     ...future.result
[10:19:21.250] }
[10:19:21.253] assign_globals() ...
[10:19:21.253] List of 5
[10:19:21.253]  $ ...future.FUN            :function (x, ...)  
[10:19:21.253]  $ MoreArgs                 : NULL
[10:19:21.253]  $ ...future.elements_ii    :List of 2
[10:19:21.253]   ..$ :List of 2
[10:19:21.253]   .. ..$ : int 3
[10:19:21.253]   .. ..$ : int 4
[10:19:21.253]   ..$ :List of 2
[10:19:21.253]   .. ..$ : int 2
[10:19:21.253]   .. ..$ : int 1
[10:19:21.253]  $ ...future.seeds_ii       : NULL
[10:19:21.253]  $ ...future.globals.maxSize: NULL
[10:19:21.253]  - attr(*, "where")=List of 5
[10:19:21.253]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.253]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.253]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.253]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.253]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.253]  - attr(*, "resolved")= logi FALSE
[10:19:21.253]  - attr(*, "total_size")= num 210
[10:19:21.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.253]  - attr(*, "already-done")= logi TRUE
[10:19:21.262] - copied ‘...future.FUN’ to environment
[10:19:21.262] - copied ‘MoreArgs’ to environment
[10:19:21.262] - copied ‘...future.elements_ii’ to environment
[10:19:21.262] - copied ‘...future.seeds_ii’ to environment
[10:19:21.263] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.263] assign_globals() ... done
[10:19:21.263] requestCore(): workers = 2
[10:19:21.269] MulticoreFuture started
[10:19:21.269] - Launch lazy future ... done
[10:19:21.270] run() for ‘MulticoreFuture’ ... done
[10:19:21.270] plan(): Setting new future strategy stack:
[10:19:21.270] Created future:
[10:19:21.270] List of future strategies:
[10:19:21.270] 1. sequential:
[10:19:21.270]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.270]    - tweaked: FALSE
[10:19:21.270]    - call: NULL
[10:19:21.271] plan(): nbrOfWorkers() = 1
[10:19:21.273] plan(): Setting new future strategy stack:
[10:19:21.273] List of future strategies:
[10:19:21.273] 1. multicore:
[10:19:21.273]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.273]    - tweaked: FALSE
[10:19:21.273]    - call: plan(strategy)
[10:19:21.277] plan(): nbrOfWorkers() = 2
[10:19:21.270] MulticoreFuture:
[10:19:21.270] Label: ‘future_mapply-2’
[10:19:21.270] Expression:
[10:19:21.270] {
[10:19:21.270]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.270]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.270]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.270]         on.exit(options(oopts), add = TRUE)
[10:19:21.270]     }
[10:19:21.270]     {
[10:19:21.270]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.270]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.270]         do.call(mapply, args = args)
[10:19:21.270]     }
[10:19:21.270] }
[10:19:21.270] Lazy evaluation: FALSE
[10:19:21.270] Asynchronous evaluation: TRUE
[10:19:21.270] Local evaluation: TRUE
[10:19:21.270] Environment: R_GlobalEnv
[10:19:21.270] Capture standard output: TRUE
[10:19:21.270] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.270] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.270] Packages: <none>
[10:19:21.270] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.270] Resolved: TRUE
[10:19:21.270] Value: <not collected>
[10:19:21.270] Conditions captured: <none>
[10:19:21.270] Early signaling: FALSE
[10:19:21.270] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.270] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.278] Chunk #2 of 2 ... DONE
[10:19:21.278] Launching 2 futures (chunks) ... DONE
[10:19:21.278] Resolving 2 futures (chunks) ...
[10:19:21.278] resolve() on list ...
[10:19:21.278]  recursive: 0
[10:19:21.279]  length: 2
[10:19:21.279] 
[10:19:21.279] Future #1
[10:19:21.280] result() for MulticoreFuture ...
[10:19:21.282] result() for MulticoreFuture ...
[10:19:21.282] result() for MulticoreFuture ... done
[10:19:21.282] result() for MulticoreFuture ... done
[10:19:21.282] result() for MulticoreFuture ...
[10:19:21.283] result() for MulticoreFuture ... done
[10:19:21.283] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:21.283] - nx: 2
[10:19:21.283] - relay: TRUE
[10:19:21.283] - stdout: TRUE
[10:19:21.284] - signal: TRUE
[10:19:21.284] - resignal: FALSE
[10:19:21.284] - force: TRUE
[10:19:21.284] - relayed: [n=2] FALSE, FALSE
[10:19:21.284] - queued futures: [n=2] FALSE, FALSE
[10:19:21.284]  - until=1
[10:19:21.285]  - relaying element #1
[10:19:21.285] result() for MulticoreFuture ...
[10:19:21.285] result() for MulticoreFuture ... done
[10:19:21.285] result() for MulticoreFuture ...
[10:19:21.285] result() for MulticoreFuture ... done
[10:19:21.286] result() for MulticoreFuture ...
[10:19:21.286] result() for MulticoreFuture ... done
[10:19:21.286] result() for MulticoreFuture ...
[10:19:21.286] result() for MulticoreFuture ... done
[10:19:21.286] - relayed: [n=2] TRUE, FALSE
[10:19:21.286] - queued futures: [n=2] TRUE, FALSE
[10:19:21.287] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:21.287]  length: 1 (resolved future 1)
[10:19:21.287] Future #2
[10:19:21.287] result() for MulticoreFuture ...
[10:19:21.288] result() for MulticoreFuture ...
[10:19:21.288] result() for MulticoreFuture ... done
[10:19:21.289] result() for MulticoreFuture ... done
[10:19:21.289] result() for MulticoreFuture ...
[10:19:21.289] result() for MulticoreFuture ... done
[10:19:21.289] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:21.292] - nx: 2
[10:19:21.292] - relay: TRUE
[10:19:21.293] - stdout: TRUE
[10:19:21.293] - signal: TRUE
[10:19:21.293] - resignal: FALSE
[10:19:21.293] - force: TRUE
[10:19:21.293] - relayed: [n=2] TRUE, FALSE
[10:19:21.293] - queued futures: [n=2] TRUE, FALSE
[10:19:21.294]  - until=2
[10:19:21.294]  - relaying element #2
[10:19:21.294] result() for MulticoreFuture ...
[10:19:21.294] result() for MulticoreFuture ... done
[10:19:21.294] result() for MulticoreFuture ...
[10:19:21.294] result() for MulticoreFuture ... done
[10:19:21.295] result() for MulticoreFuture ...
[10:19:21.295] result() for MulticoreFuture ... done
[10:19:21.295] result() for MulticoreFuture ...
[10:19:21.295] result() for MulticoreFuture ... done
[10:19:21.295] - relayed: [n=2] TRUE, TRUE
[10:19:21.295] - queued futures: [n=2] TRUE, TRUE
[10:19:21.296] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:21.296]  length: 0 (resolved future 2)
[10:19:21.296] Relaying remaining futures
[10:19:21.296] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.296] - nx: 2
[10:19:21.296] - relay: TRUE
[10:19:21.296] - stdout: TRUE
[10:19:21.297] - signal: TRUE
[10:19:21.297] - resignal: FALSE
[10:19:21.297] - force: TRUE
[10:19:21.297] - relayed: [n=2] TRUE, TRUE
[10:19:21.297] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:21.297] - relayed: [n=2] TRUE, TRUE
[10:19:21.297] - queued futures: [n=2] TRUE, TRUE
[10:19:21.298] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.298] resolve() on list ... DONE
[10:19:21.298] result() for MulticoreFuture ...
[10:19:21.298] result() for MulticoreFuture ... done
[10:19:21.298] result() for MulticoreFuture ...
[10:19:21.298] result() for MulticoreFuture ... done
[10:19:21.298] result() for MulticoreFuture ...
[10:19:21.298] result() for MulticoreFuture ... done
[10:19:21.299] result() for MulticoreFuture ...
[10:19:21.299] result() for MulticoreFuture ... done
[10:19:21.299]  - Number of value chunks collected: 2
[10:19:21.299] Resolving 2 futures (chunks) ... DONE
[10:19:21.299] Reducing values from 2 chunks ...
[10:19:21.299]  - Number of values collected after concatenation: 4
[10:19:21.299]  - Number of values expected: 4
[10:19:21.299] Reducing values from 2 chunks ... DONE
[10:19:21.300] future_mapply() ... DONE
[10:19:21.300] future_mapply() ...
[10:19:21.302] Number of chunks: 2
[10:19:21.302] getGlobalsAndPackagesXApply() ...
[10:19:21.302]  - future.globals: TRUE
[10:19:21.302] getGlobalsAndPackages() ...
[10:19:21.302] Searching for globals...
[10:19:21.303] - globals found: [1] ‘FUN’
[10:19:21.303] Searching for globals ... DONE
[10:19:21.303] Resolving globals: FALSE
[10:19:21.304] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:21.304] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:21.304] - globals: [1] ‘FUN’
[10:19:21.304] 
[10:19:21.304] getGlobalsAndPackages() ... DONE
[10:19:21.304]  - globals found/used: [n=1] ‘FUN’
[10:19:21.305]  - needed namespaces: [n=0] 
[10:19:21.305] Finding globals ... DONE
[10:19:21.305] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.305] List of 2
[10:19:21.305]  $ ...future.FUN:function (x, ...)  
[10:19:21.305]  $ MoreArgs     : NULL
[10:19:21.305]  - attr(*, "where")=List of 2
[10:19:21.305]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.305]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.305]  - attr(*, "resolved")= logi FALSE
[10:19:21.305]  - attr(*, "total_size")= num NA
[10:19:21.308] Packages to be attached in all futures: [n=0] 
[10:19:21.308] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.308] Number of futures (= number of chunks): 2
[10:19:21.308] Launching 2 futures (chunks) ...
[10:19:21.308] Chunk #1 of 2 ...
[10:19:21.308]  - Finding globals in '...' for chunk #1 ...
[10:19:21.309] getGlobalsAndPackages() ...
[10:19:21.309] Searching for globals...
[10:19:21.309] 
[10:19:21.309] Searching for globals ... DONE
[10:19:21.309] - globals: [0] <none>
[10:19:21.309] getGlobalsAndPackages() ... DONE
[10:19:21.309]    + additional globals found: [n=0] 
[10:19:21.309]    + additional namespaces needed: [n=0] 
[10:19:21.310]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.310]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.310]  - seeds: <none>
[10:19:21.310]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.310] getGlobalsAndPackages() ...
[10:19:21.310] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.310] Resolving globals: FALSE
[10:19:21.311] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:21.311] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.311] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.311] 
[10:19:21.311] getGlobalsAndPackages() ... DONE
[10:19:21.312] run() for ‘Future’ ...
[10:19:21.312] - state: ‘created’
[10:19:21.312] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.313] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.314]   - Field: ‘label’
[10:19:21.314]   - Field: ‘local’
[10:19:21.314]   - Field: ‘owner’
[10:19:21.314]   - Field: ‘envir’
[10:19:21.314]   - Field: ‘workers’
[10:19:21.314]   - Field: ‘packages’
[10:19:21.314]   - Field: ‘gc’
[10:19:21.314]   - Field: ‘job’
[10:19:21.314]   - Field: ‘conditions’
[10:19:21.315]   - Field: ‘expr’
[10:19:21.315]   - Field: ‘uuid’
[10:19:21.315]   - Field: ‘seed’
[10:19:21.315]   - Field: ‘version’
[10:19:21.315]   - Field: ‘result’
[10:19:21.315]   - Field: ‘asynchronous’
[10:19:21.315]   - Field: ‘calls’
[10:19:21.315]   - Field: ‘globals’
[10:19:21.315]   - Field: ‘stdout’
[10:19:21.315]   - Field: ‘earlySignal’
[10:19:21.315]   - Field: ‘lazy’
[10:19:21.315]   - Field: ‘state’
[10:19:21.316] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.316] - Launch lazy future ...
[10:19:21.316] Packages needed by the future expression (n = 0): <none>
[10:19:21.316] Packages needed by future strategies (n = 0): <none>
[10:19:21.316] {
[10:19:21.316]     {
[10:19:21.316]         {
[10:19:21.316]             ...future.startTime <- base::Sys.time()
[10:19:21.316]             {
[10:19:21.316]                 {
[10:19:21.316]                   {
[10:19:21.316]                     {
[10:19:21.316]                       base::local({
[10:19:21.316]                         has_future <- base::requireNamespace("future", 
[10:19:21.316]                           quietly = TRUE)
[10:19:21.316]                         if (has_future) {
[10:19:21.316]                           ns <- base::getNamespace("future")
[10:19:21.316]                           version <- ns[[".package"]][["version"]]
[10:19:21.316]                           if (is.null(version)) 
[10:19:21.316]                             version <- utils::packageVersion("future")
[10:19:21.316]                         }
[10:19:21.316]                         else {
[10:19:21.316]                           version <- NULL
[10:19:21.316]                         }
[10:19:21.316]                         if (!has_future || version < "1.8.0") {
[10:19:21.316]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.316]                             "", base::R.version$version.string), 
[10:19:21.316]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.316]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.316]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.316]                               "release", "version")], collapse = " "), 
[10:19:21.316]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.316]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.316]                             info)
[10:19:21.316]                           info <- base::paste(info, collapse = "; ")
[10:19:21.316]                           if (!has_future) {
[10:19:21.316]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.316]                               info)
[10:19:21.316]                           }
[10:19:21.316]                           else {
[10:19:21.316]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.316]                               info, version)
[10:19:21.316]                           }
[10:19:21.316]                           base::stop(msg)
[10:19:21.316]                         }
[10:19:21.316]                       })
[10:19:21.316]                     }
[10:19:21.316]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.316]                     base::options(mc.cores = 1L)
[10:19:21.316]                   }
[10:19:21.316]                   ...future.strategy.old <- future::plan("list")
[10:19:21.316]                   options(future.plan = NULL)
[10:19:21.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.316]                 }
[10:19:21.316]                 ...future.workdir <- getwd()
[10:19:21.316]             }
[10:19:21.316]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.316]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.316]         }
[10:19:21.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.316]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.316]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.316]             base::names(...future.oldOptions))
[10:19:21.316]     }
[10:19:21.316]     if (FALSE) {
[10:19:21.316]     }
[10:19:21.316]     else {
[10:19:21.316]         if (TRUE) {
[10:19:21.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.316]                 open = "w")
[10:19:21.316]         }
[10:19:21.316]         else {
[10:19:21.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.316]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.316]         }
[10:19:21.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.316]             base::sink(type = "output", split = FALSE)
[10:19:21.316]             base::close(...future.stdout)
[10:19:21.316]         }, add = TRUE)
[10:19:21.316]     }
[10:19:21.316]     ...future.frame <- base::sys.nframe()
[10:19:21.316]     ...future.conditions <- base::list()
[10:19:21.316]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.316]     if (FALSE) {
[10:19:21.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.316]     }
[10:19:21.316]     ...future.result <- base::tryCatch({
[10:19:21.316]         base::withCallingHandlers({
[10:19:21.316]             ...future.value <- base::withVisible(base::local({
[10:19:21.316]                 withCallingHandlers({
[10:19:21.316]                   {
[10:19:21.316]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.316]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.316]                       ...future.globals.maxSize)) {
[10:19:21.316]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.316]                       on.exit(options(oopts), add = TRUE)
[10:19:21.316]                     }
[10:19:21.316]                     {
[10:19:21.316]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.316]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.316]                         USE.NAMES = FALSE)
[10:19:21.316]                       do.call(mapply, args = args)
[10:19:21.316]                     }
[10:19:21.316]                   }
[10:19:21.316]                 }, immediateCondition = function(cond) {
[10:19:21.316]                   save_rds <- function (object, pathname, ...) 
[10:19:21.316]                   {
[10:19:21.316]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.316]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.316]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.316]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.316]                         fi_tmp[["mtime"]])
[10:19:21.316]                     }
[10:19:21.316]                     tryCatch({
[10:19:21.316]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.316]                     }, error = function(ex) {
[10:19:21.316]                       msg <- conditionMessage(ex)
[10:19:21.316]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.316]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.316]                         fi_tmp[["mtime"]], msg)
[10:19:21.316]                       ex$message <- msg
[10:19:21.316]                       stop(ex)
[10:19:21.316]                     })
[10:19:21.316]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.316]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.316]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.316]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.316]                       fi <- file.info(pathname)
[10:19:21.316]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.316]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.316]                         fi[["size"]], fi[["mtime"]])
[10:19:21.316]                       stop(msg)
[10:19:21.316]                     }
[10:19:21.316]                     invisible(pathname)
[10:19:21.316]                   }
[10:19:21.316]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.316]                     rootPath = tempdir()) 
[10:19:21.316]                   {
[10:19:21.316]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.316]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.316]                       tmpdir = path, fileext = ".rds")
[10:19:21.316]                     save_rds(obj, file)
[10:19:21.316]                   }
[10:19:21.316]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.316]                   {
[10:19:21.316]                     inherits <- base::inherits
[10:19:21.316]                     invokeRestart <- base::invokeRestart
[10:19:21.316]                     is.null <- base::is.null
[10:19:21.316]                     muffled <- FALSE
[10:19:21.316]                     if (inherits(cond, "message")) {
[10:19:21.316]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.316]                       if (muffled) 
[10:19:21.316]                         invokeRestart("muffleMessage")
[10:19:21.316]                     }
[10:19:21.316]                     else if (inherits(cond, "warning")) {
[10:19:21.316]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.316]                       if (muffled) 
[10:19:21.316]                         invokeRestart("muffleWarning")
[10:19:21.316]                     }
[10:19:21.316]                     else if (inherits(cond, "condition")) {
[10:19:21.316]                       if (!is.null(pattern)) {
[10:19:21.316]                         computeRestarts <- base::computeRestarts
[10:19:21.316]                         grepl <- base::grepl
[10:19:21.316]                         restarts <- computeRestarts(cond)
[10:19:21.316]                         for (restart in restarts) {
[10:19:21.316]                           name <- restart$name
[10:19:21.316]                           if (is.null(name)) 
[10:19:21.316]                             next
[10:19:21.316]                           if (!grepl(pattern, name)) 
[10:19:21.316]                             next
[10:19:21.316]                           invokeRestart(restart)
[10:19:21.316]                           muffled <- TRUE
[10:19:21.316]                           break
[10:19:21.316]                         }
[10:19:21.316]                       }
[10:19:21.316]                     }
[10:19:21.316]                     invisible(muffled)
[10:19:21.316]                   }
[10:19:21.316]                   muffleCondition(cond)
[10:19:21.316]                 })
[10:19:21.316]             }))
[10:19:21.316]             future::FutureResult(value = ...future.value$value, 
[10:19:21.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.316]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.316]                     ...future.globalenv.names))
[10:19:21.316]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.316]         }, condition = base::local({
[10:19:21.316]             c <- base::c
[10:19:21.316]             inherits <- base::inherits
[10:19:21.316]             invokeRestart <- base::invokeRestart
[10:19:21.316]             length <- base::length
[10:19:21.316]             list <- base::list
[10:19:21.316]             seq.int <- base::seq.int
[10:19:21.316]             signalCondition <- base::signalCondition
[10:19:21.316]             sys.calls <- base::sys.calls
[10:19:21.316]             `[[` <- base::`[[`
[10:19:21.316]             `+` <- base::`+`
[10:19:21.316]             `<<-` <- base::`<<-`
[10:19:21.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.316]                   3L)]
[10:19:21.316]             }
[10:19:21.316]             function(cond) {
[10:19:21.316]                 is_error <- inherits(cond, "error")
[10:19:21.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.316]                   NULL)
[10:19:21.316]                 if (is_error) {
[10:19:21.316]                   sessionInformation <- function() {
[10:19:21.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.316]                       search = base::search(), system = base::Sys.info())
[10:19:21.316]                   }
[10:19:21.316]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.316]                     cond$call), session = sessionInformation(), 
[10:19:21.316]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.316]                   signalCondition(cond)
[10:19:21.316]                 }
[10:19:21.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.316]                 "immediateCondition"))) {
[10:19:21.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.316]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.316]                   if (TRUE && !signal) {
[10:19:21.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.316]                     {
[10:19:21.316]                       inherits <- base::inherits
[10:19:21.316]                       invokeRestart <- base::invokeRestart
[10:19:21.316]                       is.null <- base::is.null
[10:19:21.316]                       muffled <- FALSE
[10:19:21.316]                       if (inherits(cond, "message")) {
[10:19:21.316]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.316]                         if (muffled) 
[10:19:21.316]                           invokeRestart("muffleMessage")
[10:19:21.316]                       }
[10:19:21.316]                       else if (inherits(cond, "warning")) {
[10:19:21.316]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.316]                         if (muffled) 
[10:19:21.316]                           invokeRestart("muffleWarning")
[10:19:21.316]                       }
[10:19:21.316]                       else if (inherits(cond, "condition")) {
[10:19:21.316]                         if (!is.null(pattern)) {
[10:19:21.316]                           computeRestarts <- base::computeRestarts
[10:19:21.316]                           grepl <- base::grepl
[10:19:21.316]                           restarts <- computeRestarts(cond)
[10:19:21.316]                           for (restart in restarts) {
[10:19:21.316]                             name <- restart$name
[10:19:21.316]                             if (is.null(name)) 
[10:19:21.316]                               next
[10:19:21.316]                             if (!grepl(pattern, name)) 
[10:19:21.316]                               next
[10:19:21.316]                             invokeRestart(restart)
[10:19:21.316]                             muffled <- TRUE
[10:19:21.316]                             break
[10:19:21.316]                           }
[10:19:21.316]                         }
[10:19:21.316]                       }
[10:19:21.316]                       invisible(muffled)
[10:19:21.316]                     }
[10:19:21.316]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.316]                   }
[10:19:21.316]                 }
[10:19:21.316]                 else {
[10:19:21.316]                   if (TRUE) {
[10:19:21.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.316]                     {
[10:19:21.316]                       inherits <- base::inherits
[10:19:21.316]                       invokeRestart <- base::invokeRestart
[10:19:21.316]                       is.null <- base::is.null
[10:19:21.316]                       muffled <- FALSE
[10:19:21.316]                       if (inherits(cond, "message")) {
[10:19:21.316]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.316]                         if (muffled) 
[10:19:21.316]                           invokeRestart("muffleMessage")
[10:19:21.316]                       }
[10:19:21.316]                       else if (inherits(cond, "warning")) {
[10:19:21.316]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.316]                         if (muffled) 
[10:19:21.316]                           invokeRestart("muffleWarning")
[10:19:21.316]                       }
[10:19:21.316]                       else if (inherits(cond, "condition")) {
[10:19:21.316]                         if (!is.null(pattern)) {
[10:19:21.316]                           computeRestarts <- base::computeRestarts
[10:19:21.316]                           grepl <- base::grepl
[10:19:21.316]                           restarts <- computeRestarts(cond)
[10:19:21.316]                           for (restart in restarts) {
[10:19:21.316]                             name <- restart$name
[10:19:21.316]                             if (is.null(name)) 
[10:19:21.316]                               next
[10:19:21.316]                             if (!grepl(pattern, name)) 
[10:19:21.316]                               next
[10:19:21.316]                             invokeRestart(restart)
[10:19:21.316]                             muffled <- TRUE
[10:19:21.316]                             break
[10:19:21.316]                           }
[10:19:21.316]                         }
[10:19:21.316]                       }
[10:19:21.316]                       invisible(muffled)
[10:19:21.316]                     }
[10:19:21.316]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.316]                   }
[10:19:21.316]                 }
[10:19:21.316]             }
[10:19:21.316]         }))
[10:19:21.316]     }, error = function(ex) {
[10:19:21.316]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.316]                 ...future.rng), started = ...future.startTime, 
[10:19:21.316]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.316]             version = "1.8"), class = "FutureResult")
[10:19:21.316]     }, finally = {
[10:19:21.316]         if (!identical(...future.workdir, getwd())) 
[10:19:21.316]             setwd(...future.workdir)
[10:19:21.316]         {
[10:19:21.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.316]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.316]             }
[10:19:21.316]             base::options(...future.oldOptions)
[10:19:21.316]             if (.Platform$OS.type == "windows") {
[10:19:21.316]                 old_names <- names(...future.oldEnvVars)
[10:19:21.316]                 envs <- base::Sys.getenv()
[10:19:21.316]                 names <- names(envs)
[10:19:21.316]                 common <- intersect(names, old_names)
[10:19:21.316]                 added <- setdiff(names, old_names)
[10:19:21.316]                 removed <- setdiff(old_names, names)
[10:19:21.316]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.316]                   envs[common]]
[10:19:21.316]                 NAMES <- toupper(changed)
[10:19:21.316]                 args <- list()
[10:19:21.316]                 for (kk in seq_along(NAMES)) {
[10:19:21.316]                   name <- changed[[kk]]
[10:19:21.316]                   NAME <- NAMES[[kk]]
[10:19:21.316]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.316]                     next
[10:19:21.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.316]                 }
[10:19:21.316]                 NAMES <- toupper(added)
[10:19:21.316]                 for (kk in seq_along(NAMES)) {
[10:19:21.316]                   name <- added[[kk]]
[10:19:21.316]                   NAME <- NAMES[[kk]]
[10:19:21.316]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.316]                     next
[10:19:21.316]                   args[[name]] <- ""
[10:19:21.316]                 }
[10:19:21.316]                 NAMES <- toupper(removed)
[10:19:21.316]                 for (kk in seq_along(NAMES)) {
[10:19:21.316]                   name <- removed[[kk]]
[10:19:21.316]                   NAME <- NAMES[[kk]]
[10:19:21.316]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.316]                     next
[10:19:21.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.316]                 }
[10:19:21.316]                 if (length(args) > 0) 
[10:19:21.316]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.316]             }
[10:19:21.316]             else {
[10:19:21.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.316]             }
[10:19:21.316]             {
[10:19:21.316]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.316]                   0L) {
[10:19:21.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.316]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.316]                   base::options(opts)
[10:19:21.316]                 }
[10:19:21.316]                 {
[10:19:21.316]                   {
[10:19:21.316]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.316]                     NULL
[10:19:21.316]                   }
[10:19:21.316]                   options(future.plan = NULL)
[10:19:21.316]                   if (is.na(NA_character_)) 
[10:19:21.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.316]                     .init = FALSE)
[10:19:21.316]                 }
[10:19:21.316]             }
[10:19:21.316]         }
[10:19:21.316]     })
[10:19:21.316]     if (TRUE) {
[10:19:21.316]         base::sink(type = "output", split = FALSE)
[10:19:21.316]         if (TRUE) {
[10:19:21.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.316]         }
[10:19:21.316]         else {
[10:19:21.316]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.316]         }
[10:19:21.316]         base::close(...future.stdout)
[10:19:21.316]         ...future.stdout <- NULL
[10:19:21.316]     }
[10:19:21.316]     ...future.result$conditions <- ...future.conditions
[10:19:21.316]     ...future.result$finished <- base::Sys.time()
[10:19:21.316]     ...future.result
[10:19:21.316] }
[10:19:21.319] assign_globals() ...
[10:19:21.319] List of 5
[10:19:21.319]  $ ...future.FUN            :function (x, ...)  
[10:19:21.319]  $ MoreArgs                 : NULL
[10:19:21.319]  $ ...future.elements_ii    :List of 2
[10:19:21.319]   ..$ :List of 2
[10:19:21.319]   .. ..$ : int 1
[10:19:21.319]   .. ..$ : int 2
[10:19:21.319]   ..$ :List of 2
[10:19:21.319]   .. ..$ : int 4
[10:19:21.319]   .. ..$ : int 3
[10:19:21.319]  $ ...future.seeds_ii       : NULL
[10:19:21.319]  $ ...future.globals.maxSize: NULL
[10:19:21.319]  - attr(*, "where")=List of 5
[10:19:21.319]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.319]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.319]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.319]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.319]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.319]  - attr(*, "resolved")= logi FALSE
[10:19:21.319]  - attr(*, "total_size")= num 210
[10:19:21.319]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.319]  - attr(*, "already-done")= logi TRUE
[10:19:21.326] - copied ‘...future.FUN’ to environment
[10:19:21.326] - copied ‘MoreArgs’ to environment
[10:19:21.326] - copied ‘...future.elements_ii’ to environment
[10:19:21.326] - copied ‘...future.seeds_ii’ to environment
[10:19:21.327] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.327] assign_globals() ... done
[10:19:21.327] requestCore(): workers = 2
[10:19:21.329] MulticoreFuture started
[10:19:21.330] - Launch lazy future ... done
[10:19:21.330] plan(): Setting new future strategy stack:
[10:19:21.330] run() for ‘MulticoreFuture’ ... done
[10:19:21.331] Created future:
[10:19:21.330] List of future strategies:
[10:19:21.330] 1. sequential:
[10:19:21.330]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.330]    - tweaked: FALSE
[10:19:21.330]    - call: NULL
[10:19:21.332] plan(): nbrOfWorkers() = 1
[10:19:21.334] plan(): Setting new future strategy stack:
[10:19:21.334] List of future strategies:
[10:19:21.334] 1. multicore:
[10:19:21.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.334]    - tweaked: FALSE
[10:19:21.334]    - call: plan(strategy)
[10:19:21.337] plan(): nbrOfWorkers() = 2
[10:19:21.331] MulticoreFuture:
[10:19:21.331] Label: ‘future_mapply-1’
[10:19:21.331] Expression:
[10:19:21.331] {
[10:19:21.331]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.331]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.331]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.331]         on.exit(options(oopts), add = TRUE)
[10:19:21.331]     }
[10:19:21.331]     {
[10:19:21.331]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.331]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.331]         do.call(mapply, args = args)
[10:19:21.331]     }
[10:19:21.331] }
[10:19:21.331] Lazy evaluation: FALSE
[10:19:21.331] Asynchronous evaluation: TRUE
[10:19:21.331] Local evaluation: TRUE
[10:19:21.331] Environment: R_GlobalEnv
[10:19:21.331] Capture standard output: TRUE
[10:19:21.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.331] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.331] Packages: <none>
[10:19:21.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.331] Resolved: TRUE
[10:19:21.331] Value: <not collected>
[10:19:21.331] Conditions captured: <none>
[10:19:21.331] Early signaling: FALSE
[10:19:21.331] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.331] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.338] Chunk #1 of 2 ... DONE
[10:19:21.339] Chunk #2 of 2 ...
[10:19:21.339]  - Finding globals in '...' for chunk #2 ...
[10:19:21.339] getGlobalsAndPackages() ...
[10:19:21.339] Searching for globals...
[10:19:21.340] 
[10:19:21.340] Searching for globals ... DONE
[10:19:21.340] - globals: [0] <none>
[10:19:21.340] getGlobalsAndPackages() ... DONE
[10:19:21.341]    + additional globals found: [n=0] 
[10:19:21.341]    + additional namespaces needed: [n=0] 
[10:19:21.341]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:21.341]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.341]  - seeds: <none>
[10:19:21.341]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.342] getGlobalsAndPackages() ...
[10:19:21.342] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.342] Resolving globals: FALSE
[10:19:21.343] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:21.344] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.344] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.344] 
[10:19:21.344] getGlobalsAndPackages() ... DONE
[10:19:21.345] run() for ‘Future’ ...
[10:19:21.345] - state: ‘created’
[10:19:21.345] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.348] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.348] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.349]   - Field: ‘label’
[10:19:21.349]   - Field: ‘local’
[10:19:21.349]   - Field: ‘owner’
[10:19:21.349]   - Field: ‘envir’
[10:19:21.349]   - Field: ‘workers’
[10:19:21.350]   - Field: ‘packages’
[10:19:21.350]   - Field: ‘gc’
[10:19:21.350]   - Field: ‘job’
[10:19:21.350]   - Field: ‘conditions’
[10:19:21.350]   - Field: ‘expr’
[10:19:21.350]   - Field: ‘uuid’
[10:19:21.351]   - Field: ‘seed’
[10:19:21.351]   - Field: ‘version’
[10:19:21.351]   - Field: ‘result’
[10:19:21.351]   - Field: ‘asynchronous’
[10:19:21.351]   - Field: ‘calls’
[10:19:21.351]   - Field: ‘globals’
[10:19:21.352]   - Field: ‘stdout’
[10:19:21.352]   - Field: ‘earlySignal’
[10:19:21.352]   - Field: ‘lazy’
[10:19:21.352]   - Field: ‘state’
[10:19:21.352] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.353] - Launch lazy future ...
[10:19:21.353] Packages needed by the future expression (n = 0): <none>
[10:19:21.353] Packages needed by future strategies (n = 0): <none>
[10:19:21.354] {
[10:19:21.354]     {
[10:19:21.354]         {
[10:19:21.354]             ...future.startTime <- base::Sys.time()
[10:19:21.354]             {
[10:19:21.354]                 {
[10:19:21.354]                   {
[10:19:21.354]                     {
[10:19:21.354]                       base::local({
[10:19:21.354]                         has_future <- base::requireNamespace("future", 
[10:19:21.354]                           quietly = TRUE)
[10:19:21.354]                         if (has_future) {
[10:19:21.354]                           ns <- base::getNamespace("future")
[10:19:21.354]                           version <- ns[[".package"]][["version"]]
[10:19:21.354]                           if (is.null(version)) 
[10:19:21.354]                             version <- utils::packageVersion("future")
[10:19:21.354]                         }
[10:19:21.354]                         else {
[10:19:21.354]                           version <- NULL
[10:19:21.354]                         }
[10:19:21.354]                         if (!has_future || version < "1.8.0") {
[10:19:21.354]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.354]                             "", base::R.version$version.string), 
[10:19:21.354]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.354]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.354]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.354]                               "release", "version")], collapse = " "), 
[10:19:21.354]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.354]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.354]                             info)
[10:19:21.354]                           info <- base::paste(info, collapse = "; ")
[10:19:21.354]                           if (!has_future) {
[10:19:21.354]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.354]                               info)
[10:19:21.354]                           }
[10:19:21.354]                           else {
[10:19:21.354]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.354]                               info, version)
[10:19:21.354]                           }
[10:19:21.354]                           base::stop(msg)
[10:19:21.354]                         }
[10:19:21.354]                       })
[10:19:21.354]                     }
[10:19:21.354]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.354]                     base::options(mc.cores = 1L)
[10:19:21.354]                   }
[10:19:21.354]                   ...future.strategy.old <- future::plan("list")
[10:19:21.354]                   options(future.plan = NULL)
[10:19:21.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.354]                 }
[10:19:21.354]                 ...future.workdir <- getwd()
[10:19:21.354]             }
[10:19:21.354]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.354]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.354]         }
[10:19:21.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.354]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.354]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.354]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.354]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.354]             base::names(...future.oldOptions))
[10:19:21.354]     }
[10:19:21.354]     if (FALSE) {
[10:19:21.354]     }
[10:19:21.354]     else {
[10:19:21.354]         if (TRUE) {
[10:19:21.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.354]                 open = "w")
[10:19:21.354]         }
[10:19:21.354]         else {
[10:19:21.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.354]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.354]         }
[10:19:21.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.354]             base::sink(type = "output", split = FALSE)
[10:19:21.354]             base::close(...future.stdout)
[10:19:21.354]         }, add = TRUE)
[10:19:21.354]     }
[10:19:21.354]     ...future.frame <- base::sys.nframe()
[10:19:21.354]     ...future.conditions <- base::list()
[10:19:21.354]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.354]     if (FALSE) {
[10:19:21.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.354]     }
[10:19:21.354]     ...future.result <- base::tryCatch({
[10:19:21.354]         base::withCallingHandlers({
[10:19:21.354]             ...future.value <- base::withVisible(base::local({
[10:19:21.354]                 withCallingHandlers({
[10:19:21.354]                   {
[10:19:21.354]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.354]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.354]                       ...future.globals.maxSize)) {
[10:19:21.354]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.354]                       on.exit(options(oopts), add = TRUE)
[10:19:21.354]                     }
[10:19:21.354]                     {
[10:19:21.354]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.354]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.354]                         USE.NAMES = FALSE)
[10:19:21.354]                       do.call(mapply, args = args)
[10:19:21.354]                     }
[10:19:21.354]                   }
[10:19:21.354]                 }, immediateCondition = function(cond) {
[10:19:21.354]                   save_rds <- function (object, pathname, ...) 
[10:19:21.354]                   {
[10:19:21.354]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.354]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.354]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.354]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.354]                         fi_tmp[["mtime"]])
[10:19:21.354]                     }
[10:19:21.354]                     tryCatch({
[10:19:21.354]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.354]                     }, error = function(ex) {
[10:19:21.354]                       msg <- conditionMessage(ex)
[10:19:21.354]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.354]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.354]                         fi_tmp[["mtime"]], msg)
[10:19:21.354]                       ex$message <- msg
[10:19:21.354]                       stop(ex)
[10:19:21.354]                     })
[10:19:21.354]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.354]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.354]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.354]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.354]                       fi <- file.info(pathname)
[10:19:21.354]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.354]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.354]                         fi[["size"]], fi[["mtime"]])
[10:19:21.354]                       stop(msg)
[10:19:21.354]                     }
[10:19:21.354]                     invisible(pathname)
[10:19:21.354]                   }
[10:19:21.354]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.354]                     rootPath = tempdir()) 
[10:19:21.354]                   {
[10:19:21.354]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.354]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.354]                       tmpdir = path, fileext = ".rds")
[10:19:21.354]                     save_rds(obj, file)
[10:19:21.354]                   }
[10:19:21.354]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.354]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.354]                   {
[10:19:21.354]                     inherits <- base::inherits
[10:19:21.354]                     invokeRestart <- base::invokeRestart
[10:19:21.354]                     is.null <- base::is.null
[10:19:21.354]                     muffled <- FALSE
[10:19:21.354]                     if (inherits(cond, "message")) {
[10:19:21.354]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.354]                       if (muffled) 
[10:19:21.354]                         invokeRestart("muffleMessage")
[10:19:21.354]                     }
[10:19:21.354]                     else if (inherits(cond, "warning")) {
[10:19:21.354]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.354]                       if (muffled) 
[10:19:21.354]                         invokeRestart("muffleWarning")
[10:19:21.354]                     }
[10:19:21.354]                     else if (inherits(cond, "condition")) {
[10:19:21.354]                       if (!is.null(pattern)) {
[10:19:21.354]                         computeRestarts <- base::computeRestarts
[10:19:21.354]                         grepl <- base::grepl
[10:19:21.354]                         restarts <- computeRestarts(cond)
[10:19:21.354]                         for (restart in restarts) {
[10:19:21.354]                           name <- restart$name
[10:19:21.354]                           if (is.null(name)) 
[10:19:21.354]                             next
[10:19:21.354]                           if (!grepl(pattern, name)) 
[10:19:21.354]                             next
[10:19:21.354]                           invokeRestart(restart)
[10:19:21.354]                           muffled <- TRUE
[10:19:21.354]                           break
[10:19:21.354]                         }
[10:19:21.354]                       }
[10:19:21.354]                     }
[10:19:21.354]                     invisible(muffled)
[10:19:21.354]                   }
[10:19:21.354]                   muffleCondition(cond)
[10:19:21.354]                 })
[10:19:21.354]             }))
[10:19:21.354]             future::FutureResult(value = ...future.value$value, 
[10:19:21.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.354]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.354]                     ...future.globalenv.names))
[10:19:21.354]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.354]         }, condition = base::local({
[10:19:21.354]             c <- base::c
[10:19:21.354]             inherits <- base::inherits
[10:19:21.354]             invokeRestart <- base::invokeRestart
[10:19:21.354]             length <- base::length
[10:19:21.354]             list <- base::list
[10:19:21.354]             seq.int <- base::seq.int
[10:19:21.354]             signalCondition <- base::signalCondition
[10:19:21.354]             sys.calls <- base::sys.calls
[10:19:21.354]             `[[` <- base::`[[`
[10:19:21.354]             `+` <- base::`+`
[10:19:21.354]             `<<-` <- base::`<<-`
[10:19:21.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.354]                   3L)]
[10:19:21.354]             }
[10:19:21.354]             function(cond) {
[10:19:21.354]                 is_error <- inherits(cond, "error")
[10:19:21.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.354]                   NULL)
[10:19:21.354]                 if (is_error) {
[10:19:21.354]                   sessionInformation <- function() {
[10:19:21.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.354]                       search = base::search(), system = base::Sys.info())
[10:19:21.354]                   }
[10:19:21.354]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.354]                     cond$call), session = sessionInformation(), 
[10:19:21.354]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.354]                   signalCondition(cond)
[10:19:21.354]                 }
[10:19:21.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.354]                 "immediateCondition"))) {
[10:19:21.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.354]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.354]                   if (TRUE && !signal) {
[10:19:21.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.354]                     {
[10:19:21.354]                       inherits <- base::inherits
[10:19:21.354]                       invokeRestart <- base::invokeRestart
[10:19:21.354]                       is.null <- base::is.null
[10:19:21.354]                       muffled <- FALSE
[10:19:21.354]                       if (inherits(cond, "message")) {
[10:19:21.354]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.354]                         if (muffled) 
[10:19:21.354]                           invokeRestart("muffleMessage")
[10:19:21.354]                       }
[10:19:21.354]                       else if (inherits(cond, "warning")) {
[10:19:21.354]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.354]                         if (muffled) 
[10:19:21.354]                           invokeRestart("muffleWarning")
[10:19:21.354]                       }
[10:19:21.354]                       else if (inherits(cond, "condition")) {
[10:19:21.354]                         if (!is.null(pattern)) {
[10:19:21.354]                           computeRestarts <- base::computeRestarts
[10:19:21.354]                           grepl <- base::grepl
[10:19:21.354]                           restarts <- computeRestarts(cond)
[10:19:21.354]                           for (restart in restarts) {
[10:19:21.354]                             name <- restart$name
[10:19:21.354]                             if (is.null(name)) 
[10:19:21.354]                               next
[10:19:21.354]                             if (!grepl(pattern, name)) 
[10:19:21.354]                               next
[10:19:21.354]                             invokeRestart(restart)
[10:19:21.354]                             muffled <- TRUE
[10:19:21.354]                             break
[10:19:21.354]                           }
[10:19:21.354]                         }
[10:19:21.354]                       }
[10:19:21.354]                       invisible(muffled)
[10:19:21.354]                     }
[10:19:21.354]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.354]                   }
[10:19:21.354]                 }
[10:19:21.354]                 else {
[10:19:21.354]                   if (TRUE) {
[10:19:21.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.354]                     {
[10:19:21.354]                       inherits <- base::inherits
[10:19:21.354]                       invokeRestart <- base::invokeRestart
[10:19:21.354]                       is.null <- base::is.null
[10:19:21.354]                       muffled <- FALSE
[10:19:21.354]                       if (inherits(cond, "message")) {
[10:19:21.354]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.354]                         if (muffled) 
[10:19:21.354]                           invokeRestart("muffleMessage")
[10:19:21.354]                       }
[10:19:21.354]                       else if (inherits(cond, "warning")) {
[10:19:21.354]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.354]                         if (muffled) 
[10:19:21.354]                           invokeRestart("muffleWarning")
[10:19:21.354]                       }
[10:19:21.354]                       else if (inherits(cond, "condition")) {
[10:19:21.354]                         if (!is.null(pattern)) {
[10:19:21.354]                           computeRestarts <- base::computeRestarts
[10:19:21.354]                           grepl <- base::grepl
[10:19:21.354]                           restarts <- computeRestarts(cond)
[10:19:21.354]                           for (restart in restarts) {
[10:19:21.354]                             name <- restart$name
[10:19:21.354]                             if (is.null(name)) 
[10:19:21.354]                               next
[10:19:21.354]                             if (!grepl(pattern, name)) 
[10:19:21.354]                               next
[10:19:21.354]                             invokeRestart(restart)
[10:19:21.354]                             muffled <- TRUE
[10:19:21.354]                             break
[10:19:21.354]                           }
[10:19:21.354]                         }
[10:19:21.354]                       }
[10:19:21.354]                       invisible(muffled)
[10:19:21.354]                     }
[10:19:21.354]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.354]                   }
[10:19:21.354]                 }
[10:19:21.354]             }
[10:19:21.354]         }))
[10:19:21.354]     }, error = function(ex) {
[10:19:21.354]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.354]                 ...future.rng), started = ...future.startTime, 
[10:19:21.354]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.354]             version = "1.8"), class = "FutureResult")
[10:19:21.354]     }, finally = {
[10:19:21.354]         if (!identical(...future.workdir, getwd())) 
[10:19:21.354]             setwd(...future.workdir)
[10:19:21.354]         {
[10:19:21.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.354]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.354]             }
[10:19:21.354]             base::options(...future.oldOptions)
[10:19:21.354]             if (.Platform$OS.type == "windows") {
[10:19:21.354]                 old_names <- names(...future.oldEnvVars)
[10:19:21.354]                 envs <- base::Sys.getenv()
[10:19:21.354]                 names <- names(envs)
[10:19:21.354]                 common <- intersect(names, old_names)
[10:19:21.354]                 added <- setdiff(names, old_names)
[10:19:21.354]                 removed <- setdiff(old_names, names)
[10:19:21.354]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.354]                   envs[common]]
[10:19:21.354]                 NAMES <- toupper(changed)
[10:19:21.354]                 args <- list()
[10:19:21.354]                 for (kk in seq_along(NAMES)) {
[10:19:21.354]                   name <- changed[[kk]]
[10:19:21.354]                   NAME <- NAMES[[kk]]
[10:19:21.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.354]                     next
[10:19:21.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.354]                 }
[10:19:21.354]                 NAMES <- toupper(added)
[10:19:21.354]                 for (kk in seq_along(NAMES)) {
[10:19:21.354]                   name <- added[[kk]]
[10:19:21.354]                   NAME <- NAMES[[kk]]
[10:19:21.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.354]                     next
[10:19:21.354]                   args[[name]] <- ""
[10:19:21.354]                 }
[10:19:21.354]                 NAMES <- toupper(removed)
[10:19:21.354]                 for (kk in seq_along(NAMES)) {
[10:19:21.354]                   name <- removed[[kk]]
[10:19:21.354]                   NAME <- NAMES[[kk]]
[10:19:21.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.354]                     next
[10:19:21.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.354]                 }
[10:19:21.354]                 if (length(args) > 0) 
[10:19:21.354]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.354]             }
[10:19:21.354]             else {
[10:19:21.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.354]             }
[10:19:21.354]             {
[10:19:21.354]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.354]                   0L) {
[10:19:21.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.354]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.354]                   base::options(opts)
[10:19:21.354]                 }
[10:19:21.354]                 {
[10:19:21.354]                   {
[10:19:21.354]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.354]                     NULL
[10:19:21.354]                   }
[10:19:21.354]                   options(future.plan = NULL)
[10:19:21.354]                   if (is.na(NA_character_)) 
[10:19:21.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.354]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.354]                     .init = FALSE)
[10:19:21.354]                 }
[10:19:21.354]             }
[10:19:21.354]         }
[10:19:21.354]     })
[10:19:21.354]     if (TRUE) {
[10:19:21.354]         base::sink(type = "output", split = FALSE)
[10:19:21.354]         if (TRUE) {
[10:19:21.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.354]         }
[10:19:21.354]         else {
[10:19:21.354]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.354]         }
[10:19:21.354]         base::close(...future.stdout)
[10:19:21.354]         ...future.stdout <- NULL
[10:19:21.354]     }
[10:19:21.354]     ...future.result$conditions <- ...future.conditions
[10:19:21.354]     ...future.result$finished <- base::Sys.time()
[10:19:21.354]     ...future.result
[10:19:21.354] }
[10:19:21.359] assign_globals() ...
[10:19:21.359] List of 5
[10:19:21.359]  $ ...future.FUN            :function (x, ...)  
[10:19:21.359]  $ MoreArgs                 : NULL
[10:19:21.359]  $ ...future.elements_ii    :List of 2
[10:19:21.359]   ..$ :List of 2
[10:19:21.359]   .. ..$ : int 3
[10:19:21.359]   .. ..$ : int 4
[10:19:21.359]   ..$ :List of 2
[10:19:21.359]   .. ..$ : int 2
[10:19:21.359]   .. ..$ : int 1
[10:19:21.359]  $ ...future.seeds_ii       : NULL
[10:19:21.359]  $ ...future.globals.maxSize: NULL
[10:19:21.359]  - attr(*, "where")=List of 5
[10:19:21.359]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.359]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.359]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.359]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.359]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.359]  - attr(*, "resolved")= logi FALSE
[10:19:21.359]  - attr(*, "total_size")= num 210
[10:19:21.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.359]  - attr(*, "already-done")= logi TRUE
[10:19:21.371] - copied ‘...future.FUN’ to environment
[10:19:21.371] - copied ‘MoreArgs’ to environment
[10:19:21.371] - copied ‘...future.elements_ii’ to environment
[10:19:21.371] - copied ‘...future.seeds_ii’ to environment
[10:19:21.372] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.372] assign_globals() ... done
[10:19:21.372] requestCore(): workers = 2
[10:19:21.375] MulticoreFuture started
[10:19:21.375] - Launch lazy future ... done
[10:19:21.376] run() for ‘MulticoreFuture’ ... done
[10:19:21.376] plan(): Setting new future strategy stack:
[10:19:21.376] Created future:
[10:19:21.376] List of future strategies:
[10:19:21.376] 1. sequential:
[10:19:21.376]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.376]    - tweaked: FALSE
[10:19:21.376]    - call: NULL
[10:19:21.378] plan(): nbrOfWorkers() = 1
[10:19:21.381] plan(): Setting new future strategy stack:
[10:19:21.381] List of future strategies:
[10:19:21.381] 1. multicore:
[10:19:21.381]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.381]    - tweaked: FALSE
[10:19:21.381]    - call: plan(strategy)
[10:19:21.385] plan(): nbrOfWorkers() = 2
[10:19:21.377] MulticoreFuture:
[10:19:21.377] Label: ‘future_mapply-2’
[10:19:21.377] Expression:
[10:19:21.377] {
[10:19:21.377]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.377]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.377]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.377]         on.exit(options(oopts), add = TRUE)
[10:19:21.377]     }
[10:19:21.377]     {
[10:19:21.377]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.377]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.377]         do.call(mapply, args = args)
[10:19:21.377]     }
[10:19:21.377] }
[10:19:21.377] Lazy evaluation: FALSE
[10:19:21.377] Asynchronous evaluation: TRUE
[10:19:21.377] Local evaluation: TRUE
[10:19:21.377] Environment: R_GlobalEnv
[10:19:21.377] Capture standard output: TRUE
[10:19:21.377] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.377] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.377] Packages: <none>
[10:19:21.377] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.377] Resolved: TRUE
[10:19:21.377] Value: <not collected>
[10:19:21.377] Conditions captured: <none>
[10:19:21.377] Early signaling: FALSE
[10:19:21.377] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.377] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.386] Chunk #2 of 2 ... DONE
[10:19:21.386] Launching 2 futures (chunks) ... DONE
[10:19:21.386] Resolving 2 futures (chunks) ...
[10:19:21.387] resolve() on list ...
[10:19:21.387]  recursive: 0
[10:19:21.387]  length: 2
[10:19:21.387] 
[10:19:21.387] Future #1
[10:19:21.388] result() for MulticoreFuture ...
[10:19:21.389] result() for MulticoreFuture ...
[10:19:21.389] result() for MulticoreFuture ... done
[10:19:21.389] result() for MulticoreFuture ... done
[10:19:21.389] result() for MulticoreFuture ...
[10:19:21.389] result() for MulticoreFuture ... done
[10:19:21.390] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:21.390] - nx: 2
[10:19:21.390] - relay: TRUE
[10:19:21.390] - stdout: TRUE
[10:19:21.390] - signal: TRUE
[10:19:21.390] - resignal: FALSE
[10:19:21.391] - force: TRUE
[10:19:21.391] - relayed: [n=2] FALSE, FALSE
[10:19:21.391] - queued futures: [n=2] FALSE, FALSE
[10:19:21.391]  - until=1
[10:19:21.391]  - relaying element #1
[10:19:21.391] result() for MulticoreFuture ...
[10:19:21.392] result() for MulticoreFuture ... done
[10:19:21.392] result() for MulticoreFuture ...
[10:19:21.392] result() for MulticoreFuture ... done
[10:19:21.392] result() for MulticoreFuture ...
[10:19:21.392] result() for MulticoreFuture ... done
[10:19:21.392] result() for MulticoreFuture ...
[10:19:21.392] result() for MulticoreFuture ... done
[10:19:21.393] - relayed: [n=2] TRUE, FALSE
[10:19:21.393] - queued futures: [n=2] TRUE, FALSE
[10:19:21.393] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:21.393]  length: 1 (resolved future 1)
[10:19:21.393] Future #2
[10:19:21.394] result() for MulticoreFuture ...
[10:19:21.394] result() for MulticoreFuture ...
[10:19:21.394] result() for MulticoreFuture ... done
[10:19:21.395] result() for MulticoreFuture ... done
[10:19:21.395] result() for MulticoreFuture ...
[10:19:21.395] result() for MulticoreFuture ... done
[10:19:21.395] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:21.395] - nx: 2
[10:19:21.395] - relay: TRUE
[10:19:21.395] - stdout: TRUE
[10:19:21.395] - signal: TRUE
[10:19:21.395] - resignal: FALSE
[10:19:21.396] - force: TRUE
[10:19:21.396] - relayed: [n=2] TRUE, FALSE
[10:19:21.396] - queued futures: [n=2] TRUE, FALSE
[10:19:21.396]  - until=2
[10:19:21.396]  - relaying element #2
[10:19:21.396] result() for MulticoreFuture ...
[10:19:21.396] result() for MulticoreFuture ... done
[10:19:21.396] result() for MulticoreFuture ...
[10:19:21.396] result() for MulticoreFuture ... done
[10:19:21.397] result() for MulticoreFuture ...
[10:19:21.397] result() for MulticoreFuture ... done
[10:19:21.397] result() for MulticoreFuture ...
[10:19:21.397] result() for MulticoreFuture ... done
[10:19:21.397] - relayed: [n=2] TRUE, TRUE
[10:19:21.397] - queued futures: [n=2] TRUE, TRUE
[10:19:21.397] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:21.397]  length: 0 (resolved future 2)
[10:19:21.397] Relaying remaining futures
[10:19:21.398] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.398] - nx: 2
[10:19:21.398] - relay: TRUE
[10:19:21.398] - stdout: TRUE
[10:19:21.398] - signal: TRUE
[10:19:21.398] - resignal: FALSE
[10:19:21.398] - force: TRUE
[10:19:21.398] - relayed: [n=2] TRUE, TRUE
[10:19:21.398] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:21.399] - relayed: [n=2] TRUE, TRUE
[10:19:21.399] - queued futures: [n=2] TRUE, TRUE
[10:19:21.399] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.399] resolve() on list ... DONE
[10:19:21.399] result() for MulticoreFuture ...
[10:19:21.399] result() for MulticoreFuture ... done
[10:19:21.399] result() for MulticoreFuture ...
[10:19:21.399] result() for MulticoreFuture ... done
[10:19:21.399] result() for MulticoreFuture ...
[10:19:21.400] result() for MulticoreFuture ... done
[10:19:21.400] result() for MulticoreFuture ...
[10:19:21.400] result() for MulticoreFuture ... done
[10:19:21.400]  - Number of value chunks collected: 2
[10:19:21.400] Resolving 2 futures (chunks) ... DONE
[10:19:21.400] Reducing values from 2 chunks ...
[10:19:21.400]  - Number of values collected after concatenation: 4
[10:19:21.400]  - Number of values expected: 4
[10:19:21.400] Reducing values from 2 chunks ... DONE
[10:19:21.400] future_mapply() ... DONE
[10:19:21.401] future_mapply() ...
[10:19:21.403] Number of chunks: 2
[10:19:21.403] getGlobalsAndPackagesXApply() ...
[10:19:21.403]  - future.globals: TRUE
[10:19:21.403] getGlobalsAndPackages() ...
[10:19:21.403] Searching for globals...
[10:19:21.404] - globals found: [1] ‘FUN’
[10:19:21.404] Searching for globals ... DONE
[10:19:21.404] Resolving globals: FALSE
[10:19:21.405] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:21.405] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:21.405] - globals: [1] ‘FUN’
[10:19:21.405] 
[10:19:21.406] getGlobalsAndPackages() ... DONE
[10:19:21.406]  - globals found/used: [n=1] ‘FUN’
[10:19:21.406]  - needed namespaces: [n=0] 
[10:19:21.406] Finding globals ... DONE
[10:19:21.406] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.406] List of 2
[10:19:21.406]  $ ...future.FUN:function (x, ...)  
[10:19:21.406]  $ MoreArgs     : NULL
[10:19:21.406]  - attr(*, "where")=List of 2
[10:19:21.406]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.406]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.406]  - attr(*, "resolved")= logi FALSE
[10:19:21.406]  - attr(*, "total_size")= num NA
[10:19:21.411] Packages to be attached in all futures: [n=0] 
[10:19:21.411] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.412] Number of futures (= number of chunks): 2
[10:19:21.412] Launching 2 futures (chunks) ...
[10:19:21.412] Chunk #1 of 2 ...
[10:19:21.412]  - Finding globals in '...' for chunk #1 ...
[10:19:21.412] getGlobalsAndPackages() ...
[10:19:21.412] Searching for globals...
[10:19:21.413] 
[10:19:21.413] Searching for globals ... DONE
[10:19:21.413] - globals: [0] <none>
[10:19:21.413] getGlobalsAndPackages() ... DONE
[10:19:21.413]    + additional globals found: [n=0] 
[10:19:21.413]    + additional namespaces needed: [n=0] 
[10:19:21.414]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.414]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.414]  - seeds: <none>
[10:19:21.414]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.414] getGlobalsAndPackages() ...
[10:19:21.414] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.414] Resolving globals: FALSE
[10:19:21.415] The total size of the 5 globals is 265 bytes (265 bytes)
[10:19:21.415] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.416] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.416] 
[10:19:21.416] getGlobalsAndPackages() ... DONE
[10:19:21.416] run() for ‘Future’ ...
[10:19:21.416] - state: ‘created’
[10:19:21.416] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.418] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.418] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.418]   - Field: ‘label’
[10:19:21.418]   - Field: ‘local’
[10:19:21.418]   - Field: ‘owner’
[10:19:21.418]   - Field: ‘envir’
[10:19:21.419]   - Field: ‘workers’
[10:19:21.419]   - Field: ‘packages’
[10:19:21.419]   - Field: ‘gc’
[10:19:21.419]   - Field: ‘job’
[10:19:21.419]   - Field: ‘conditions’
[10:19:21.419]   - Field: ‘expr’
[10:19:21.419]   - Field: ‘uuid’
[10:19:21.419]   - Field: ‘seed’
[10:19:21.419]   - Field: ‘version’
[10:19:21.419]   - Field: ‘result’
[10:19:21.419]   - Field: ‘asynchronous’
[10:19:21.420]   - Field: ‘calls’
[10:19:21.420]   - Field: ‘globals’
[10:19:21.420]   - Field: ‘stdout’
[10:19:21.420]   - Field: ‘earlySignal’
[10:19:21.420]   - Field: ‘lazy’
[10:19:21.420]   - Field: ‘state’
[10:19:21.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.420] - Launch lazy future ...
[10:19:21.420] Packages needed by the future expression (n = 0): <none>
[10:19:21.421] Packages needed by future strategies (n = 0): <none>
[10:19:21.421] {
[10:19:21.421]     {
[10:19:21.421]         {
[10:19:21.421]             ...future.startTime <- base::Sys.time()
[10:19:21.421]             {
[10:19:21.421]                 {
[10:19:21.421]                   {
[10:19:21.421]                     {
[10:19:21.421]                       base::local({
[10:19:21.421]                         has_future <- base::requireNamespace("future", 
[10:19:21.421]                           quietly = TRUE)
[10:19:21.421]                         if (has_future) {
[10:19:21.421]                           ns <- base::getNamespace("future")
[10:19:21.421]                           version <- ns[[".package"]][["version"]]
[10:19:21.421]                           if (is.null(version)) 
[10:19:21.421]                             version <- utils::packageVersion("future")
[10:19:21.421]                         }
[10:19:21.421]                         else {
[10:19:21.421]                           version <- NULL
[10:19:21.421]                         }
[10:19:21.421]                         if (!has_future || version < "1.8.0") {
[10:19:21.421]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.421]                             "", base::R.version$version.string), 
[10:19:21.421]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.421]                               "release", "version")], collapse = " "), 
[10:19:21.421]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.421]                             info)
[10:19:21.421]                           info <- base::paste(info, collapse = "; ")
[10:19:21.421]                           if (!has_future) {
[10:19:21.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.421]                               info)
[10:19:21.421]                           }
[10:19:21.421]                           else {
[10:19:21.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.421]                               info, version)
[10:19:21.421]                           }
[10:19:21.421]                           base::stop(msg)
[10:19:21.421]                         }
[10:19:21.421]                       })
[10:19:21.421]                     }
[10:19:21.421]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.421]                     base::options(mc.cores = 1L)
[10:19:21.421]                   }
[10:19:21.421]                   ...future.strategy.old <- future::plan("list")
[10:19:21.421]                   options(future.plan = NULL)
[10:19:21.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.421]                 }
[10:19:21.421]                 ...future.workdir <- getwd()
[10:19:21.421]             }
[10:19:21.421]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.421]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.421]         }
[10:19:21.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.421]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.421]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.421]             base::names(...future.oldOptions))
[10:19:21.421]     }
[10:19:21.421]     if (FALSE) {
[10:19:21.421]     }
[10:19:21.421]     else {
[10:19:21.421]         if (TRUE) {
[10:19:21.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.421]                 open = "w")
[10:19:21.421]         }
[10:19:21.421]         else {
[10:19:21.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.421]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.421]         }
[10:19:21.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.421]             base::sink(type = "output", split = FALSE)
[10:19:21.421]             base::close(...future.stdout)
[10:19:21.421]         }, add = TRUE)
[10:19:21.421]     }
[10:19:21.421]     ...future.frame <- base::sys.nframe()
[10:19:21.421]     ...future.conditions <- base::list()
[10:19:21.421]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.421]     if (FALSE) {
[10:19:21.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.421]     }
[10:19:21.421]     ...future.result <- base::tryCatch({
[10:19:21.421]         base::withCallingHandlers({
[10:19:21.421]             ...future.value <- base::withVisible(base::local({
[10:19:21.421]                 withCallingHandlers({
[10:19:21.421]                   {
[10:19:21.421]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.421]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.421]                       ...future.globals.maxSize)) {
[10:19:21.421]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.421]                       on.exit(options(oopts), add = TRUE)
[10:19:21.421]                     }
[10:19:21.421]                     {
[10:19:21.421]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.421]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.421]                         USE.NAMES = FALSE)
[10:19:21.421]                       do.call(mapply, args = args)
[10:19:21.421]                     }
[10:19:21.421]                   }
[10:19:21.421]                 }, immediateCondition = function(cond) {
[10:19:21.421]                   save_rds <- function (object, pathname, ...) 
[10:19:21.421]                   {
[10:19:21.421]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.421]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.421]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.421]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.421]                         fi_tmp[["mtime"]])
[10:19:21.421]                     }
[10:19:21.421]                     tryCatch({
[10:19:21.421]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.421]                     }, error = function(ex) {
[10:19:21.421]                       msg <- conditionMessage(ex)
[10:19:21.421]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.421]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.421]                         fi_tmp[["mtime"]], msg)
[10:19:21.421]                       ex$message <- msg
[10:19:21.421]                       stop(ex)
[10:19:21.421]                     })
[10:19:21.421]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.421]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.421]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.421]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.421]                       fi <- file.info(pathname)
[10:19:21.421]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.421]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.421]                         fi[["size"]], fi[["mtime"]])
[10:19:21.421]                       stop(msg)
[10:19:21.421]                     }
[10:19:21.421]                     invisible(pathname)
[10:19:21.421]                   }
[10:19:21.421]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.421]                     rootPath = tempdir()) 
[10:19:21.421]                   {
[10:19:21.421]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.421]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.421]                       tmpdir = path, fileext = ".rds")
[10:19:21.421]                     save_rds(obj, file)
[10:19:21.421]                   }
[10:19:21.421]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.421]                   {
[10:19:21.421]                     inherits <- base::inherits
[10:19:21.421]                     invokeRestart <- base::invokeRestart
[10:19:21.421]                     is.null <- base::is.null
[10:19:21.421]                     muffled <- FALSE
[10:19:21.421]                     if (inherits(cond, "message")) {
[10:19:21.421]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.421]                       if (muffled) 
[10:19:21.421]                         invokeRestart("muffleMessage")
[10:19:21.421]                     }
[10:19:21.421]                     else if (inherits(cond, "warning")) {
[10:19:21.421]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.421]                       if (muffled) 
[10:19:21.421]                         invokeRestart("muffleWarning")
[10:19:21.421]                     }
[10:19:21.421]                     else if (inherits(cond, "condition")) {
[10:19:21.421]                       if (!is.null(pattern)) {
[10:19:21.421]                         computeRestarts <- base::computeRestarts
[10:19:21.421]                         grepl <- base::grepl
[10:19:21.421]                         restarts <- computeRestarts(cond)
[10:19:21.421]                         for (restart in restarts) {
[10:19:21.421]                           name <- restart$name
[10:19:21.421]                           if (is.null(name)) 
[10:19:21.421]                             next
[10:19:21.421]                           if (!grepl(pattern, name)) 
[10:19:21.421]                             next
[10:19:21.421]                           invokeRestart(restart)
[10:19:21.421]                           muffled <- TRUE
[10:19:21.421]                           break
[10:19:21.421]                         }
[10:19:21.421]                       }
[10:19:21.421]                     }
[10:19:21.421]                     invisible(muffled)
[10:19:21.421]                   }
[10:19:21.421]                   muffleCondition(cond)
[10:19:21.421]                 })
[10:19:21.421]             }))
[10:19:21.421]             future::FutureResult(value = ...future.value$value, 
[10:19:21.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.421]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.421]                     ...future.globalenv.names))
[10:19:21.421]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.421]         }, condition = base::local({
[10:19:21.421]             c <- base::c
[10:19:21.421]             inherits <- base::inherits
[10:19:21.421]             invokeRestart <- base::invokeRestart
[10:19:21.421]             length <- base::length
[10:19:21.421]             list <- base::list
[10:19:21.421]             seq.int <- base::seq.int
[10:19:21.421]             signalCondition <- base::signalCondition
[10:19:21.421]             sys.calls <- base::sys.calls
[10:19:21.421]             `[[` <- base::`[[`
[10:19:21.421]             `+` <- base::`+`
[10:19:21.421]             `<<-` <- base::`<<-`
[10:19:21.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.421]                   3L)]
[10:19:21.421]             }
[10:19:21.421]             function(cond) {
[10:19:21.421]                 is_error <- inherits(cond, "error")
[10:19:21.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.421]                   NULL)
[10:19:21.421]                 if (is_error) {
[10:19:21.421]                   sessionInformation <- function() {
[10:19:21.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.421]                       search = base::search(), system = base::Sys.info())
[10:19:21.421]                   }
[10:19:21.421]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.421]                     cond$call), session = sessionInformation(), 
[10:19:21.421]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.421]                   signalCondition(cond)
[10:19:21.421]                 }
[10:19:21.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.421]                 "immediateCondition"))) {
[10:19:21.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.421]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.421]                   if (TRUE && !signal) {
[10:19:21.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.421]                     {
[10:19:21.421]                       inherits <- base::inherits
[10:19:21.421]                       invokeRestart <- base::invokeRestart
[10:19:21.421]                       is.null <- base::is.null
[10:19:21.421]                       muffled <- FALSE
[10:19:21.421]                       if (inherits(cond, "message")) {
[10:19:21.421]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.421]                         if (muffled) 
[10:19:21.421]                           invokeRestart("muffleMessage")
[10:19:21.421]                       }
[10:19:21.421]                       else if (inherits(cond, "warning")) {
[10:19:21.421]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.421]                         if (muffled) 
[10:19:21.421]                           invokeRestart("muffleWarning")
[10:19:21.421]                       }
[10:19:21.421]                       else if (inherits(cond, "condition")) {
[10:19:21.421]                         if (!is.null(pattern)) {
[10:19:21.421]                           computeRestarts <- base::computeRestarts
[10:19:21.421]                           grepl <- base::grepl
[10:19:21.421]                           restarts <- computeRestarts(cond)
[10:19:21.421]                           for (restart in restarts) {
[10:19:21.421]                             name <- restart$name
[10:19:21.421]                             if (is.null(name)) 
[10:19:21.421]                               next
[10:19:21.421]                             if (!grepl(pattern, name)) 
[10:19:21.421]                               next
[10:19:21.421]                             invokeRestart(restart)
[10:19:21.421]                             muffled <- TRUE
[10:19:21.421]                             break
[10:19:21.421]                           }
[10:19:21.421]                         }
[10:19:21.421]                       }
[10:19:21.421]                       invisible(muffled)
[10:19:21.421]                     }
[10:19:21.421]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.421]                   }
[10:19:21.421]                 }
[10:19:21.421]                 else {
[10:19:21.421]                   if (TRUE) {
[10:19:21.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.421]                     {
[10:19:21.421]                       inherits <- base::inherits
[10:19:21.421]                       invokeRestart <- base::invokeRestart
[10:19:21.421]                       is.null <- base::is.null
[10:19:21.421]                       muffled <- FALSE
[10:19:21.421]                       if (inherits(cond, "message")) {
[10:19:21.421]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.421]                         if (muffled) 
[10:19:21.421]                           invokeRestart("muffleMessage")
[10:19:21.421]                       }
[10:19:21.421]                       else if (inherits(cond, "warning")) {
[10:19:21.421]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.421]                         if (muffled) 
[10:19:21.421]                           invokeRestart("muffleWarning")
[10:19:21.421]                       }
[10:19:21.421]                       else if (inherits(cond, "condition")) {
[10:19:21.421]                         if (!is.null(pattern)) {
[10:19:21.421]                           computeRestarts <- base::computeRestarts
[10:19:21.421]                           grepl <- base::grepl
[10:19:21.421]                           restarts <- computeRestarts(cond)
[10:19:21.421]                           for (restart in restarts) {
[10:19:21.421]                             name <- restart$name
[10:19:21.421]                             if (is.null(name)) 
[10:19:21.421]                               next
[10:19:21.421]                             if (!grepl(pattern, name)) 
[10:19:21.421]                               next
[10:19:21.421]                             invokeRestart(restart)
[10:19:21.421]                             muffled <- TRUE
[10:19:21.421]                             break
[10:19:21.421]                           }
[10:19:21.421]                         }
[10:19:21.421]                       }
[10:19:21.421]                       invisible(muffled)
[10:19:21.421]                     }
[10:19:21.421]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.421]                   }
[10:19:21.421]                 }
[10:19:21.421]             }
[10:19:21.421]         }))
[10:19:21.421]     }, error = function(ex) {
[10:19:21.421]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.421]                 ...future.rng), started = ...future.startTime, 
[10:19:21.421]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.421]             version = "1.8"), class = "FutureResult")
[10:19:21.421]     }, finally = {
[10:19:21.421]         if (!identical(...future.workdir, getwd())) 
[10:19:21.421]             setwd(...future.workdir)
[10:19:21.421]         {
[10:19:21.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.421]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.421]             }
[10:19:21.421]             base::options(...future.oldOptions)
[10:19:21.421]             if (.Platform$OS.type == "windows") {
[10:19:21.421]                 old_names <- names(...future.oldEnvVars)
[10:19:21.421]                 envs <- base::Sys.getenv()
[10:19:21.421]                 names <- names(envs)
[10:19:21.421]                 common <- intersect(names, old_names)
[10:19:21.421]                 added <- setdiff(names, old_names)
[10:19:21.421]                 removed <- setdiff(old_names, names)
[10:19:21.421]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.421]                   envs[common]]
[10:19:21.421]                 NAMES <- toupper(changed)
[10:19:21.421]                 args <- list()
[10:19:21.421]                 for (kk in seq_along(NAMES)) {
[10:19:21.421]                   name <- changed[[kk]]
[10:19:21.421]                   NAME <- NAMES[[kk]]
[10:19:21.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.421]                     next
[10:19:21.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.421]                 }
[10:19:21.421]                 NAMES <- toupper(added)
[10:19:21.421]                 for (kk in seq_along(NAMES)) {
[10:19:21.421]                   name <- added[[kk]]
[10:19:21.421]                   NAME <- NAMES[[kk]]
[10:19:21.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.421]                     next
[10:19:21.421]                   args[[name]] <- ""
[10:19:21.421]                 }
[10:19:21.421]                 NAMES <- toupper(removed)
[10:19:21.421]                 for (kk in seq_along(NAMES)) {
[10:19:21.421]                   name <- removed[[kk]]
[10:19:21.421]                   NAME <- NAMES[[kk]]
[10:19:21.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.421]                     next
[10:19:21.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.421]                 }
[10:19:21.421]                 if (length(args) > 0) 
[10:19:21.421]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.421]             }
[10:19:21.421]             else {
[10:19:21.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.421]             }
[10:19:21.421]             {
[10:19:21.421]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.421]                   0L) {
[10:19:21.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.421]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.421]                   base::options(opts)
[10:19:21.421]                 }
[10:19:21.421]                 {
[10:19:21.421]                   {
[10:19:21.421]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.421]                     NULL
[10:19:21.421]                   }
[10:19:21.421]                   options(future.plan = NULL)
[10:19:21.421]                   if (is.na(NA_character_)) 
[10:19:21.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.421]                     .init = FALSE)
[10:19:21.421]                 }
[10:19:21.421]             }
[10:19:21.421]         }
[10:19:21.421]     })
[10:19:21.421]     if (TRUE) {
[10:19:21.421]         base::sink(type = "output", split = FALSE)
[10:19:21.421]         if (TRUE) {
[10:19:21.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.421]         }
[10:19:21.421]         else {
[10:19:21.421]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.421]         }
[10:19:21.421]         base::close(...future.stdout)
[10:19:21.421]         ...future.stdout <- NULL
[10:19:21.421]     }
[10:19:21.421]     ...future.result$conditions <- ...future.conditions
[10:19:21.421]     ...future.result$finished <- base::Sys.time()
[10:19:21.421]     ...future.result
[10:19:21.421] }
[10:19:21.424] assign_globals() ...
[10:19:21.424] List of 5
[10:19:21.424]  $ ...future.FUN            :function (x, ...)  
[10:19:21.424]  $ MoreArgs                 : NULL
[10:19:21.424]  $ ...future.elements_ii    :List of 2
[10:19:21.424]   ..$ times:List of 2
[10:19:21.424]   .. ..$ : int 1
[10:19:21.424]   .. ..$ : int 2
[10:19:21.424]   ..$ x    :List of 2
[10:19:21.424]   .. ..$ : int 4
[10:19:21.424]   .. ..$ : int 3
[10:19:21.424]  $ ...future.seeds_ii       : NULL
[10:19:21.424]  $ ...future.globals.maxSize: NULL
[10:19:21.424]  - attr(*, "where")=List of 5
[10:19:21.424]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.424]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.424]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.424]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.424]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.424]  - attr(*, "resolved")= logi FALSE
[10:19:21.424]  - attr(*, "total_size")= num 265
[10:19:21.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.424]  - attr(*, "already-done")= logi TRUE
[10:19:21.429] - copied ‘...future.FUN’ to environment
[10:19:21.429] - copied ‘MoreArgs’ to environment
[10:19:21.429] - copied ‘...future.elements_ii’ to environment
[10:19:21.429] - copied ‘...future.seeds_ii’ to environment
[10:19:21.430] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.430] assign_globals() ... done
[10:19:21.430] requestCore(): workers = 2
[10:19:21.432] MulticoreFuture started
[10:19:21.432] - Launch lazy future ... done
[10:19:21.432] run() for ‘MulticoreFuture’ ... done
[10:19:21.433] Created future:
[10:19:21.433] plan(): Setting new future strategy stack:
[10:19:21.433] List of future strategies:
[10:19:21.433] 1. sequential:
[10:19:21.433]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.433]    - tweaked: FALSE
[10:19:21.433]    - call: NULL
[10:19:21.434] plan(): nbrOfWorkers() = 1
[10:19:21.436] plan(): Setting new future strategy stack:
[10:19:21.436] List of future strategies:
[10:19:21.436] 1. multicore:
[10:19:21.436]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.436]    - tweaked: FALSE
[10:19:21.436]    - call: plan(strategy)
[10:19:21.439] plan(): nbrOfWorkers() = 2
[10:19:21.433] MulticoreFuture:
[10:19:21.433] Label: ‘future_mapply-1’
[10:19:21.433] Expression:
[10:19:21.433] {
[10:19:21.433]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.433]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.433]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.433]         on.exit(options(oopts), add = TRUE)
[10:19:21.433]     }
[10:19:21.433]     {
[10:19:21.433]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.433]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.433]         do.call(mapply, args = args)
[10:19:21.433]     }
[10:19:21.433] }
[10:19:21.433] Lazy evaluation: FALSE
[10:19:21.433] Asynchronous evaluation: TRUE
[10:19:21.433] Local evaluation: TRUE
[10:19:21.433] Environment: R_GlobalEnv
[10:19:21.433] Capture standard output: TRUE
[10:19:21.433] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.433] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.433] Packages: <none>
[10:19:21.433] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.433] Resolved: TRUE
[10:19:21.433] Value: <not collected>
[10:19:21.433] Conditions captured: <none>
[10:19:21.433] Early signaling: FALSE
[10:19:21.433] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.433] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.440] Chunk #1 of 2 ... DONE
[10:19:21.441] Chunk #2 of 2 ...
[10:19:21.441]  - Finding globals in '...' for chunk #2 ...
[10:19:21.441] getGlobalsAndPackages() ...
[10:19:21.441] Searching for globals...
[10:19:21.442] 
[10:19:21.442] Searching for globals ... DONE
[10:19:21.442] - globals: [0] <none>
[10:19:21.442] getGlobalsAndPackages() ... DONE
[10:19:21.442]    + additional globals found: [n=0] 
[10:19:21.442]    + additional namespaces needed: [n=0] 
[10:19:21.443]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:21.443]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.443]  - seeds: <none>
[10:19:21.443]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.443] getGlobalsAndPackages() ...
[10:19:21.443] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.443] Resolving globals: FALSE
[10:19:21.444] The total size of the 5 globals is 265 bytes (265 bytes)
[10:19:21.445] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.445] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.445] 
[10:19:21.445] getGlobalsAndPackages() ... DONE
[10:19:21.446] run() for ‘Future’ ...
[10:19:21.450] - state: ‘created’
[10:19:21.450] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.454] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.454] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.455]   - Field: ‘label’
[10:19:21.455]   - Field: ‘local’
[10:19:21.455]   - Field: ‘owner’
[10:19:21.455]   - Field: ‘envir’
[10:19:21.456]   - Field: ‘workers’
[10:19:21.456]   - Field: ‘packages’
[10:19:21.456]   - Field: ‘gc’
[10:19:21.456]   - Field: ‘job’
[10:19:21.457]   - Field: ‘conditions’
[10:19:21.457]   - Field: ‘expr’
[10:19:21.457]   - Field: ‘uuid’
[10:19:21.457]   - Field: ‘seed’
[10:19:21.457]   - Field: ‘version’
[10:19:21.458]   - Field: ‘result’
[10:19:21.458]   - Field: ‘asynchronous’
[10:19:21.458]   - Field: ‘calls’
[10:19:21.458]   - Field: ‘globals’
[10:19:21.458]   - Field: ‘stdout’
[10:19:21.459]   - Field: ‘earlySignal’
[10:19:21.459]   - Field: ‘lazy’
[10:19:21.459]   - Field: ‘state’
[10:19:21.459] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.459] - Launch lazy future ...
[10:19:21.460] Packages needed by the future expression (n = 0): <none>
[10:19:21.460] Packages needed by future strategies (n = 0): <none>
[10:19:21.460] {
[10:19:21.460]     {
[10:19:21.460]         {
[10:19:21.460]             ...future.startTime <- base::Sys.time()
[10:19:21.460]             {
[10:19:21.460]                 {
[10:19:21.460]                   {
[10:19:21.460]                     {
[10:19:21.460]                       base::local({
[10:19:21.460]                         has_future <- base::requireNamespace("future", 
[10:19:21.460]                           quietly = TRUE)
[10:19:21.460]                         if (has_future) {
[10:19:21.460]                           ns <- base::getNamespace("future")
[10:19:21.460]                           version <- ns[[".package"]][["version"]]
[10:19:21.460]                           if (is.null(version)) 
[10:19:21.460]                             version <- utils::packageVersion("future")
[10:19:21.460]                         }
[10:19:21.460]                         else {
[10:19:21.460]                           version <- NULL
[10:19:21.460]                         }
[10:19:21.460]                         if (!has_future || version < "1.8.0") {
[10:19:21.460]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.460]                             "", base::R.version$version.string), 
[10:19:21.460]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.460]                               "release", "version")], collapse = " "), 
[10:19:21.460]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.460]                             info)
[10:19:21.460]                           info <- base::paste(info, collapse = "; ")
[10:19:21.460]                           if (!has_future) {
[10:19:21.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.460]                               info)
[10:19:21.460]                           }
[10:19:21.460]                           else {
[10:19:21.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.460]                               info, version)
[10:19:21.460]                           }
[10:19:21.460]                           base::stop(msg)
[10:19:21.460]                         }
[10:19:21.460]                       })
[10:19:21.460]                     }
[10:19:21.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.460]                     base::options(mc.cores = 1L)
[10:19:21.460]                   }
[10:19:21.460]                   ...future.strategy.old <- future::plan("list")
[10:19:21.460]                   options(future.plan = NULL)
[10:19:21.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.460]                 }
[10:19:21.460]                 ...future.workdir <- getwd()
[10:19:21.460]             }
[10:19:21.460]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.460]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.460]         }
[10:19:21.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.460]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.460]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.460]             base::names(...future.oldOptions))
[10:19:21.460]     }
[10:19:21.460]     if (FALSE) {
[10:19:21.460]     }
[10:19:21.460]     else {
[10:19:21.460]         if (TRUE) {
[10:19:21.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.460]                 open = "w")
[10:19:21.460]         }
[10:19:21.460]         else {
[10:19:21.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.460]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.460]         }
[10:19:21.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.460]             base::sink(type = "output", split = FALSE)
[10:19:21.460]             base::close(...future.stdout)
[10:19:21.460]         }, add = TRUE)
[10:19:21.460]     }
[10:19:21.460]     ...future.frame <- base::sys.nframe()
[10:19:21.460]     ...future.conditions <- base::list()
[10:19:21.460]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.460]     if (FALSE) {
[10:19:21.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.460]     }
[10:19:21.460]     ...future.result <- base::tryCatch({
[10:19:21.460]         base::withCallingHandlers({
[10:19:21.460]             ...future.value <- base::withVisible(base::local({
[10:19:21.460]                 withCallingHandlers({
[10:19:21.460]                   {
[10:19:21.460]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.460]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.460]                       ...future.globals.maxSize)) {
[10:19:21.460]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.460]                       on.exit(options(oopts), add = TRUE)
[10:19:21.460]                     }
[10:19:21.460]                     {
[10:19:21.460]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.460]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.460]                         USE.NAMES = FALSE)
[10:19:21.460]                       do.call(mapply, args = args)
[10:19:21.460]                     }
[10:19:21.460]                   }
[10:19:21.460]                 }, immediateCondition = function(cond) {
[10:19:21.460]                   save_rds <- function (object, pathname, ...) 
[10:19:21.460]                   {
[10:19:21.460]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.460]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.460]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.460]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.460]                         fi_tmp[["mtime"]])
[10:19:21.460]                     }
[10:19:21.460]                     tryCatch({
[10:19:21.460]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.460]                     }, error = function(ex) {
[10:19:21.460]                       msg <- conditionMessage(ex)
[10:19:21.460]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.460]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.460]                         fi_tmp[["mtime"]], msg)
[10:19:21.460]                       ex$message <- msg
[10:19:21.460]                       stop(ex)
[10:19:21.460]                     })
[10:19:21.460]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.460]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.460]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.460]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.460]                       fi <- file.info(pathname)
[10:19:21.460]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.460]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.460]                         fi[["size"]], fi[["mtime"]])
[10:19:21.460]                       stop(msg)
[10:19:21.460]                     }
[10:19:21.460]                     invisible(pathname)
[10:19:21.460]                   }
[10:19:21.460]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.460]                     rootPath = tempdir()) 
[10:19:21.460]                   {
[10:19:21.460]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.460]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.460]                       tmpdir = path, fileext = ".rds")
[10:19:21.460]                     save_rds(obj, file)
[10:19:21.460]                   }
[10:19:21.460]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.460]                   {
[10:19:21.460]                     inherits <- base::inherits
[10:19:21.460]                     invokeRestart <- base::invokeRestart
[10:19:21.460]                     is.null <- base::is.null
[10:19:21.460]                     muffled <- FALSE
[10:19:21.460]                     if (inherits(cond, "message")) {
[10:19:21.460]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.460]                       if (muffled) 
[10:19:21.460]                         invokeRestart("muffleMessage")
[10:19:21.460]                     }
[10:19:21.460]                     else if (inherits(cond, "warning")) {
[10:19:21.460]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.460]                       if (muffled) 
[10:19:21.460]                         invokeRestart("muffleWarning")
[10:19:21.460]                     }
[10:19:21.460]                     else if (inherits(cond, "condition")) {
[10:19:21.460]                       if (!is.null(pattern)) {
[10:19:21.460]                         computeRestarts <- base::computeRestarts
[10:19:21.460]                         grepl <- base::grepl
[10:19:21.460]                         restarts <- computeRestarts(cond)
[10:19:21.460]                         for (restart in restarts) {
[10:19:21.460]                           name <- restart$name
[10:19:21.460]                           if (is.null(name)) 
[10:19:21.460]                             next
[10:19:21.460]                           if (!grepl(pattern, name)) 
[10:19:21.460]                             next
[10:19:21.460]                           invokeRestart(restart)
[10:19:21.460]                           muffled <- TRUE
[10:19:21.460]                           break
[10:19:21.460]                         }
[10:19:21.460]                       }
[10:19:21.460]                     }
[10:19:21.460]                     invisible(muffled)
[10:19:21.460]                   }
[10:19:21.460]                   muffleCondition(cond)
[10:19:21.460]                 })
[10:19:21.460]             }))
[10:19:21.460]             future::FutureResult(value = ...future.value$value, 
[10:19:21.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.460]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.460]                     ...future.globalenv.names))
[10:19:21.460]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.460]         }, condition = base::local({
[10:19:21.460]             c <- base::c
[10:19:21.460]             inherits <- base::inherits
[10:19:21.460]             invokeRestart <- base::invokeRestart
[10:19:21.460]             length <- base::length
[10:19:21.460]             list <- base::list
[10:19:21.460]             seq.int <- base::seq.int
[10:19:21.460]             signalCondition <- base::signalCondition
[10:19:21.460]             sys.calls <- base::sys.calls
[10:19:21.460]             `[[` <- base::`[[`
[10:19:21.460]             `+` <- base::`+`
[10:19:21.460]             `<<-` <- base::`<<-`
[10:19:21.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.460]                   3L)]
[10:19:21.460]             }
[10:19:21.460]             function(cond) {
[10:19:21.460]                 is_error <- inherits(cond, "error")
[10:19:21.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.460]                   NULL)
[10:19:21.460]                 if (is_error) {
[10:19:21.460]                   sessionInformation <- function() {
[10:19:21.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.460]                       search = base::search(), system = base::Sys.info())
[10:19:21.460]                   }
[10:19:21.460]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.460]                     cond$call), session = sessionInformation(), 
[10:19:21.460]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.460]                   signalCondition(cond)
[10:19:21.460]                 }
[10:19:21.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.460]                 "immediateCondition"))) {
[10:19:21.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.460]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.460]                   if (TRUE && !signal) {
[10:19:21.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.460]                     {
[10:19:21.460]                       inherits <- base::inherits
[10:19:21.460]                       invokeRestart <- base::invokeRestart
[10:19:21.460]                       is.null <- base::is.null
[10:19:21.460]                       muffled <- FALSE
[10:19:21.460]                       if (inherits(cond, "message")) {
[10:19:21.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.460]                         if (muffled) 
[10:19:21.460]                           invokeRestart("muffleMessage")
[10:19:21.460]                       }
[10:19:21.460]                       else if (inherits(cond, "warning")) {
[10:19:21.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.460]                         if (muffled) 
[10:19:21.460]                           invokeRestart("muffleWarning")
[10:19:21.460]                       }
[10:19:21.460]                       else if (inherits(cond, "condition")) {
[10:19:21.460]                         if (!is.null(pattern)) {
[10:19:21.460]                           computeRestarts <- base::computeRestarts
[10:19:21.460]                           grepl <- base::grepl
[10:19:21.460]                           restarts <- computeRestarts(cond)
[10:19:21.460]                           for (restart in restarts) {
[10:19:21.460]                             name <- restart$name
[10:19:21.460]                             if (is.null(name)) 
[10:19:21.460]                               next
[10:19:21.460]                             if (!grepl(pattern, name)) 
[10:19:21.460]                               next
[10:19:21.460]                             invokeRestart(restart)
[10:19:21.460]                             muffled <- TRUE
[10:19:21.460]                             break
[10:19:21.460]                           }
[10:19:21.460]                         }
[10:19:21.460]                       }
[10:19:21.460]                       invisible(muffled)
[10:19:21.460]                     }
[10:19:21.460]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.460]                   }
[10:19:21.460]                 }
[10:19:21.460]                 else {
[10:19:21.460]                   if (TRUE) {
[10:19:21.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.460]                     {
[10:19:21.460]                       inherits <- base::inherits
[10:19:21.460]                       invokeRestart <- base::invokeRestart
[10:19:21.460]                       is.null <- base::is.null
[10:19:21.460]                       muffled <- FALSE
[10:19:21.460]                       if (inherits(cond, "message")) {
[10:19:21.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.460]                         if (muffled) 
[10:19:21.460]                           invokeRestart("muffleMessage")
[10:19:21.460]                       }
[10:19:21.460]                       else if (inherits(cond, "warning")) {
[10:19:21.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.460]                         if (muffled) 
[10:19:21.460]                           invokeRestart("muffleWarning")
[10:19:21.460]                       }
[10:19:21.460]                       else if (inherits(cond, "condition")) {
[10:19:21.460]                         if (!is.null(pattern)) {
[10:19:21.460]                           computeRestarts <- base::computeRestarts
[10:19:21.460]                           grepl <- base::grepl
[10:19:21.460]                           restarts <- computeRestarts(cond)
[10:19:21.460]                           for (restart in restarts) {
[10:19:21.460]                             name <- restart$name
[10:19:21.460]                             if (is.null(name)) 
[10:19:21.460]                               next
[10:19:21.460]                             if (!grepl(pattern, name)) 
[10:19:21.460]                               next
[10:19:21.460]                             invokeRestart(restart)
[10:19:21.460]                             muffled <- TRUE
[10:19:21.460]                             break
[10:19:21.460]                           }
[10:19:21.460]                         }
[10:19:21.460]                       }
[10:19:21.460]                       invisible(muffled)
[10:19:21.460]                     }
[10:19:21.460]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.460]                   }
[10:19:21.460]                 }
[10:19:21.460]             }
[10:19:21.460]         }))
[10:19:21.460]     }, error = function(ex) {
[10:19:21.460]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.460]                 ...future.rng), started = ...future.startTime, 
[10:19:21.460]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.460]             version = "1.8"), class = "FutureResult")
[10:19:21.460]     }, finally = {
[10:19:21.460]         if (!identical(...future.workdir, getwd())) 
[10:19:21.460]             setwd(...future.workdir)
[10:19:21.460]         {
[10:19:21.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.460]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.460]             }
[10:19:21.460]             base::options(...future.oldOptions)
[10:19:21.460]             if (.Platform$OS.type == "windows") {
[10:19:21.460]                 old_names <- names(...future.oldEnvVars)
[10:19:21.460]                 envs <- base::Sys.getenv()
[10:19:21.460]                 names <- names(envs)
[10:19:21.460]                 common <- intersect(names, old_names)
[10:19:21.460]                 added <- setdiff(names, old_names)
[10:19:21.460]                 removed <- setdiff(old_names, names)
[10:19:21.460]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.460]                   envs[common]]
[10:19:21.460]                 NAMES <- toupper(changed)
[10:19:21.460]                 args <- list()
[10:19:21.460]                 for (kk in seq_along(NAMES)) {
[10:19:21.460]                   name <- changed[[kk]]
[10:19:21.460]                   NAME <- NAMES[[kk]]
[10:19:21.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.460]                     next
[10:19:21.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.460]                 }
[10:19:21.460]                 NAMES <- toupper(added)
[10:19:21.460]                 for (kk in seq_along(NAMES)) {
[10:19:21.460]                   name <- added[[kk]]
[10:19:21.460]                   NAME <- NAMES[[kk]]
[10:19:21.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.460]                     next
[10:19:21.460]                   args[[name]] <- ""
[10:19:21.460]                 }
[10:19:21.460]                 NAMES <- toupper(removed)
[10:19:21.460]                 for (kk in seq_along(NAMES)) {
[10:19:21.460]                   name <- removed[[kk]]
[10:19:21.460]                   NAME <- NAMES[[kk]]
[10:19:21.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.460]                     next
[10:19:21.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.460]                 }
[10:19:21.460]                 if (length(args) > 0) 
[10:19:21.460]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.460]             }
[10:19:21.460]             else {
[10:19:21.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.460]             }
[10:19:21.460]             {
[10:19:21.460]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.460]                   0L) {
[10:19:21.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.460]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.460]                   base::options(opts)
[10:19:21.460]                 }
[10:19:21.460]                 {
[10:19:21.460]                   {
[10:19:21.460]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.460]                     NULL
[10:19:21.460]                   }
[10:19:21.460]                   options(future.plan = NULL)
[10:19:21.460]                   if (is.na(NA_character_)) 
[10:19:21.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.460]                     .init = FALSE)
[10:19:21.460]                 }
[10:19:21.460]             }
[10:19:21.460]         }
[10:19:21.460]     })
[10:19:21.460]     if (TRUE) {
[10:19:21.460]         base::sink(type = "output", split = FALSE)
[10:19:21.460]         if (TRUE) {
[10:19:21.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.460]         }
[10:19:21.460]         else {
[10:19:21.460]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.460]         }
[10:19:21.460]         base::close(...future.stdout)
[10:19:21.460]         ...future.stdout <- NULL
[10:19:21.460]     }
[10:19:21.460]     ...future.result$conditions <- ...future.conditions
[10:19:21.460]     ...future.result$finished <- base::Sys.time()
[10:19:21.460]     ...future.result
[10:19:21.460] }
[10:19:21.463] assign_globals() ...
[10:19:21.463] List of 5
[10:19:21.463]  $ ...future.FUN            :function (x, ...)  
[10:19:21.463]  $ MoreArgs                 : NULL
[10:19:21.463]  $ ...future.elements_ii    :List of 2
[10:19:21.463]   ..$ times:List of 2
[10:19:21.463]   .. ..$ : int 3
[10:19:21.463]   .. ..$ : int 4
[10:19:21.463]   ..$ x    :List of 2
[10:19:21.463]   .. ..$ : int 2
[10:19:21.463]   .. ..$ : int 1
[10:19:21.463]  $ ...future.seeds_ii       : NULL
[10:19:21.463]  $ ...future.globals.maxSize: NULL
[10:19:21.463]  - attr(*, "where")=List of 5
[10:19:21.463]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.463]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.463]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.463]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.463]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.463]  - attr(*, "resolved")= logi FALSE
[10:19:21.463]  - attr(*, "total_size")= num 265
[10:19:21.463]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.463]  - attr(*, "already-done")= logi TRUE
[10:19:21.471] - copied ‘...future.FUN’ to environment
[10:19:21.471] - copied ‘MoreArgs’ to environment
[10:19:21.471] - copied ‘...future.elements_ii’ to environment
[10:19:21.471] - copied ‘...future.seeds_ii’ to environment
[10:19:21.471] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.471] assign_globals() ... done
[10:19:21.472] requestCore(): workers = 2
[10:19:21.474] MulticoreFuture started
[10:19:21.474] - Launch lazy future ... done
[10:19:21.474] run() for ‘MulticoreFuture’ ... done
[10:19:21.475] Created future:
[10:19:21.475] plan(): Setting new future strategy stack:
[10:19:21.475] List of future strategies:
[10:19:21.475] 1. sequential:
[10:19:21.475]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.475]    - tweaked: FALSE
[10:19:21.475]    - call: NULL
[10:19:21.476] plan(): nbrOfWorkers() = 1
[10:19:21.478] plan(): Setting new future strategy stack:
[10:19:21.478] List of future strategies:
[10:19:21.478] 1. multicore:
[10:19:21.478]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.478]    - tweaked: FALSE
[10:19:21.478]    - call: plan(strategy)
[10:19:21.482] plan(): nbrOfWorkers() = 2
[10:19:21.475] MulticoreFuture:
[10:19:21.475] Label: ‘future_mapply-2’
[10:19:21.475] Expression:
[10:19:21.475] {
[10:19:21.475]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.475]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.475]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.475]         on.exit(options(oopts), add = TRUE)
[10:19:21.475]     }
[10:19:21.475]     {
[10:19:21.475]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.475]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.475]         do.call(mapply, args = args)
[10:19:21.475]     }
[10:19:21.475] }
[10:19:21.475] Lazy evaluation: FALSE
[10:19:21.475] Asynchronous evaluation: TRUE
[10:19:21.475] Local evaluation: TRUE
[10:19:21.475] Environment: R_GlobalEnv
[10:19:21.475] Capture standard output: TRUE
[10:19:21.475] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.475] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.475] Packages: <none>
[10:19:21.475] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.475] Resolved: TRUE
[10:19:21.475] Value: <not collected>
[10:19:21.475] Conditions captured: <none>
[10:19:21.475] Early signaling: FALSE
[10:19:21.475] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.475] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.483] Chunk #2 of 2 ... DONE
[10:19:21.483] Launching 2 futures (chunks) ... DONE
[10:19:21.483] Resolving 2 futures (chunks) ...
[10:19:21.483] resolve() on list ...
[10:19:21.483]  recursive: 0
[10:19:21.483]  length: 2
[10:19:21.484] 
[10:19:21.484] Future #1
[10:19:21.484] result() for MulticoreFuture ...
[10:19:21.485] result() for MulticoreFuture ...
[10:19:21.485] result() for MulticoreFuture ... done
[10:19:21.485] result() for MulticoreFuture ... done
[10:19:21.485] result() for MulticoreFuture ...
[10:19:21.486] result() for MulticoreFuture ... done
[10:19:21.486] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:21.486] - nx: 2
[10:19:21.486] - relay: TRUE
[10:19:21.486] - stdout: TRUE
[10:19:21.486] - signal: TRUE
[10:19:21.486] - resignal: FALSE
[10:19:21.487] - force: TRUE
[10:19:21.487] - relayed: [n=2] FALSE, FALSE
[10:19:21.487] - queued futures: [n=2] FALSE, FALSE
[10:19:21.487]  - until=1
[10:19:21.487]  - relaying element #1
[10:19:21.487] result() for MulticoreFuture ...
[10:19:21.487] result() for MulticoreFuture ... done
[10:19:21.488] result() for MulticoreFuture ...
[10:19:21.488] result() for MulticoreFuture ... done
[10:19:21.488] result() for MulticoreFuture ...
[10:19:21.488] result() for MulticoreFuture ... done
[10:19:21.488] result() for MulticoreFuture ...
[10:19:21.488] result() for MulticoreFuture ... done
[10:19:21.488] - relayed: [n=2] TRUE, FALSE
[10:19:21.489] - queued futures: [n=2] TRUE, FALSE
[10:19:21.489] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:21.489]  length: 1 (resolved future 1)
[10:19:21.489] Future #2
[10:19:21.489] result() for MulticoreFuture ...
[10:19:21.490] result() for MulticoreFuture ...
[10:19:21.490] result() for MulticoreFuture ... done
[10:19:21.490] result() for MulticoreFuture ... done
[10:19:21.491] result() for MulticoreFuture ...
[10:19:21.491] result() for MulticoreFuture ... done
[10:19:21.491] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:21.491] - nx: 2
[10:19:21.491] - relay: TRUE
[10:19:21.491] - stdout: TRUE
[10:19:21.491] - signal: TRUE
[10:19:21.491] - resignal: FALSE
[10:19:21.492] - force: TRUE
[10:19:21.492] - relayed: [n=2] TRUE, FALSE
[10:19:21.492] - queued futures: [n=2] TRUE, FALSE
[10:19:21.492]  - until=2
[10:19:21.492]  - relaying element #2
[10:19:21.492] result() for MulticoreFuture ...
[10:19:21.492] result() for MulticoreFuture ... done
[10:19:21.492] result() for MulticoreFuture ...
[10:19:21.493] result() for MulticoreFuture ... done
[10:19:21.493] result() for MulticoreFuture ...
[10:19:21.493] result() for MulticoreFuture ... done
[10:19:21.495] result() for MulticoreFuture ...
[10:19:21.496] result() for MulticoreFuture ... done
[10:19:21.496] - relayed: [n=2] TRUE, TRUE
[10:19:21.496] - queued futures: [n=2] TRUE, TRUE
[10:19:21.496] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:21.496]  length: 0 (resolved future 2)
[10:19:21.497] Relaying remaining futures
[10:19:21.497] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.497] - nx: 2
[10:19:21.497] - relay: TRUE
[10:19:21.497] - stdout: TRUE
[10:19:21.497] - signal: TRUE
[10:19:21.498] - resignal: FALSE
[10:19:21.498] - force: TRUE
[10:19:21.498] - relayed: [n=2] TRUE, TRUE
[10:19:21.498] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:21.498] - relayed: [n=2] TRUE, TRUE
[10:19:21.498] - queued futures: [n=2] TRUE, TRUE
[10:19:21.499] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.499] resolve() on list ... DONE
[10:19:21.499] result() for MulticoreFuture ...
[10:19:21.499] result() for MulticoreFuture ... done
[10:19:21.499] result() for MulticoreFuture ...
[10:19:21.499] result() for MulticoreFuture ... done
[10:19:21.499] result() for MulticoreFuture ...
[10:19:21.500] result() for MulticoreFuture ... done
[10:19:21.500] result() for MulticoreFuture ...
[10:19:21.500] result() for MulticoreFuture ... done
[10:19:21.500]  - Number of value chunks collected: 2
[10:19:21.500] Resolving 2 futures (chunks) ... DONE
[10:19:21.500] Reducing values from 2 chunks ...
[10:19:21.500]  - Number of values collected after concatenation: 4
[10:19:21.501]  - Number of values expected: 4
[10:19:21.501] Reducing values from 2 chunks ... DONE
[10:19:21.501] future_mapply() ... DONE
[10:19:21.501] future_mapply() ...
[10:19:21.503] Number of chunks: 2
[10:19:21.503] getGlobalsAndPackagesXApply() ...
[10:19:21.504]  - future.globals: TRUE
[10:19:21.504] getGlobalsAndPackages() ...
[10:19:21.504] Searching for globals...
[10:19:21.505] - globals found: [1] ‘FUN’
[10:19:21.505] Searching for globals ... DONE
[10:19:21.505] Resolving globals: FALSE
[10:19:21.505] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:21.506] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:21.506] - globals: [1] ‘FUN’
[10:19:21.506] 
[10:19:21.506] getGlobalsAndPackages() ... DONE
[10:19:21.506]  - globals found/used: [n=1] ‘FUN’
[10:19:21.506]  - needed namespaces: [n=0] 
[10:19:21.506] Finding globals ... DONE
[10:19:21.506] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.507] List of 2
[10:19:21.507]  $ ...future.FUN:function (x, ...)  
[10:19:21.507]  $ MoreArgs     :List of 1
[10:19:21.507]   ..$ x: num 42
[10:19:21.507]  - attr(*, "where")=List of 2
[10:19:21.507]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.507]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.507]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.507]  - attr(*, "resolved")= logi FALSE
[10:19:21.507]  - attr(*, "total_size")= num NA
[10:19:21.510] Packages to be attached in all futures: [n=0] 
[10:19:21.510] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.510] Number of futures (= number of chunks): 2
[10:19:21.510] Launching 2 futures (chunks) ...
[10:19:21.510] Chunk #1 of 2 ...
[10:19:21.511]  - Finding globals in '...' for chunk #1 ...
[10:19:21.511] getGlobalsAndPackages() ...
[10:19:21.511] Searching for globals...
[10:19:21.511] 
[10:19:21.511] Searching for globals ... DONE
[10:19:21.511] - globals: [0] <none>
[10:19:21.511] getGlobalsAndPackages() ... DONE
[10:19:21.511]    + additional globals found: [n=0] 
[10:19:21.512]    + additional namespaces needed: [n=0] 
[10:19:21.512]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.512]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.512]  - seeds: <none>
[10:19:21.512]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.512] getGlobalsAndPackages() ...
[10:19:21.512] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.512] Resolving globals: FALSE
[10:19:21.513] The total size of the 5 globals is 286 bytes (286 bytes)
[10:19:21.513] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[10:19:21.513] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.513] 
[10:19:21.513] getGlobalsAndPackages() ... DONE
[10:19:21.514] run() for ‘Future’ ...
[10:19:21.514] - state: ‘created’
[10:19:21.514] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.516] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.516] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.516]   - Field: ‘label’
[10:19:21.516]   - Field: ‘local’
[10:19:21.516]   - Field: ‘owner’
[10:19:21.516]   - Field: ‘envir’
[10:19:21.516]   - Field: ‘workers’
[10:19:21.516]   - Field: ‘packages’
[10:19:21.516]   - Field: ‘gc’
[10:19:21.516]   - Field: ‘job’
[10:19:21.517]   - Field: ‘conditions’
[10:19:21.517]   - Field: ‘expr’
[10:19:21.517]   - Field: ‘uuid’
[10:19:21.517]   - Field: ‘seed’
[10:19:21.517]   - Field: ‘version’
[10:19:21.517]   - Field: ‘result’
[10:19:21.517]   - Field: ‘asynchronous’
[10:19:21.517]   - Field: ‘calls’
[10:19:21.517]   - Field: ‘globals’
[10:19:21.517]   - Field: ‘stdout’
[10:19:21.517]   - Field: ‘earlySignal’
[10:19:21.517]   - Field: ‘lazy’
[10:19:21.518]   - Field: ‘state’
[10:19:21.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.518] - Launch lazy future ...
[10:19:21.518] Packages needed by the future expression (n = 0): <none>
[10:19:21.518] Packages needed by future strategies (n = 0): <none>
[10:19:21.519] {
[10:19:21.519]     {
[10:19:21.519]         {
[10:19:21.519]             ...future.startTime <- base::Sys.time()
[10:19:21.519]             {
[10:19:21.519]                 {
[10:19:21.519]                   {
[10:19:21.519]                     {
[10:19:21.519]                       base::local({
[10:19:21.519]                         has_future <- base::requireNamespace("future", 
[10:19:21.519]                           quietly = TRUE)
[10:19:21.519]                         if (has_future) {
[10:19:21.519]                           ns <- base::getNamespace("future")
[10:19:21.519]                           version <- ns[[".package"]][["version"]]
[10:19:21.519]                           if (is.null(version)) 
[10:19:21.519]                             version <- utils::packageVersion("future")
[10:19:21.519]                         }
[10:19:21.519]                         else {
[10:19:21.519]                           version <- NULL
[10:19:21.519]                         }
[10:19:21.519]                         if (!has_future || version < "1.8.0") {
[10:19:21.519]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.519]                             "", base::R.version$version.string), 
[10:19:21.519]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.519]                               "release", "version")], collapse = " "), 
[10:19:21.519]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.519]                             info)
[10:19:21.519]                           info <- base::paste(info, collapse = "; ")
[10:19:21.519]                           if (!has_future) {
[10:19:21.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.519]                               info)
[10:19:21.519]                           }
[10:19:21.519]                           else {
[10:19:21.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.519]                               info, version)
[10:19:21.519]                           }
[10:19:21.519]                           base::stop(msg)
[10:19:21.519]                         }
[10:19:21.519]                       })
[10:19:21.519]                     }
[10:19:21.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.519]                     base::options(mc.cores = 1L)
[10:19:21.519]                   }
[10:19:21.519]                   ...future.strategy.old <- future::plan("list")
[10:19:21.519]                   options(future.plan = NULL)
[10:19:21.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.519]                 }
[10:19:21.519]                 ...future.workdir <- getwd()
[10:19:21.519]             }
[10:19:21.519]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.519]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.519]         }
[10:19:21.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.519]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.519]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.519]             base::names(...future.oldOptions))
[10:19:21.519]     }
[10:19:21.519]     if (FALSE) {
[10:19:21.519]     }
[10:19:21.519]     else {
[10:19:21.519]         if (TRUE) {
[10:19:21.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.519]                 open = "w")
[10:19:21.519]         }
[10:19:21.519]         else {
[10:19:21.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.519]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.519]         }
[10:19:21.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.519]             base::sink(type = "output", split = FALSE)
[10:19:21.519]             base::close(...future.stdout)
[10:19:21.519]         }, add = TRUE)
[10:19:21.519]     }
[10:19:21.519]     ...future.frame <- base::sys.nframe()
[10:19:21.519]     ...future.conditions <- base::list()
[10:19:21.519]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.519]     if (FALSE) {
[10:19:21.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.519]     }
[10:19:21.519]     ...future.result <- base::tryCatch({
[10:19:21.519]         base::withCallingHandlers({
[10:19:21.519]             ...future.value <- base::withVisible(base::local({
[10:19:21.519]                 withCallingHandlers({
[10:19:21.519]                   {
[10:19:21.519]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.519]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.519]                       ...future.globals.maxSize)) {
[10:19:21.519]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.519]                       on.exit(options(oopts), add = TRUE)
[10:19:21.519]                     }
[10:19:21.519]                     {
[10:19:21.519]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.519]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.519]                         USE.NAMES = FALSE)
[10:19:21.519]                       do.call(mapply, args = args)
[10:19:21.519]                     }
[10:19:21.519]                   }
[10:19:21.519]                 }, immediateCondition = function(cond) {
[10:19:21.519]                   save_rds <- function (object, pathname, ...) 
[10:19:21.519]                   {
[10:19:21.519]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.519]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.519]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.519]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.519]                         fi_tmp[["mtime"]])
[10:19:21.519]                     }
[10:19:21.519]                     tryCatch({
[10:19:21.519]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.519]                     }, error = function(ex) {
[10:19:21.519]                       msg <- conditionMessage(ex)
[10:19:21.519]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.519]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.519]                         fi_tmp[["mtime"]], msg)
[10:19:21.519]                       ex$message <- msg
[10:19:21.519]                       stop(ex)
[10:19:21.519]                     })
[10:19:21.519]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.519]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.519]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.519]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.519]                       fi <- file.info(pathname)
[10:19:21.519]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.519]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.519]                         fi[["size"]], fi[["mtime"]])
[10:19:21.519]                       stop(msg)
[10:19:21.519]                     }
[10:19:21.519]                     invisible(pathname)
[10:19:21.519]                   }
[10:19:21.519]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.519]                     rootPath = tempdir()) 
[10:19:21.519]                   {
[10:19:21.519]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.519]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.519]                       tmpdir = path, fileext = ".rds")
[10:19:21.519]                     save_rds(obj, file)
[10:19:21.519]                   }
[10:19:21.519]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.519]                   {
[10:19:21.519]                     inherits <- base::inherits
[10:19:21.519]                     invokeRestart <- base::invokeRestart
[10:19:21.519]                     is.null <- base::is.null
[10:19:21.519]                     muffled <- FALSE
[10:19:21.519]                     if (inherits(cond, "message")) {
[10:19:21.519]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.519]                       if (muffled) 
[10:19:21.519]                         invokeRestart("muffleMessage")
[10:19:21.519]                     }
[10:19:21.519]                     else if (inherits(cond, "warning")) {
[10:19:21.519]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.519]                       if (muffled) 
[10:19:21.519]                         invokeRestart("muffleWarning")
[10:19:21.519]                     }
[10:19:21.519]                     else if (inherits(cond, "condition")) {
[10:19:21.519]                       if (!is.null(pattern)) {
[10:19:21.519]                         computeRestarts <- base::computeRestarts
[10:19:21.519]                         grepl <- base::grepl
[10:19:21.519]                         restarts <- computeRestarts(cond)
[10:19:21.519]                         for (restart in restarts) {
[10:19:21.519]                           name <- restart$name
[10:19:21.519]                           if (is.null(name)) 
[10:19:21.519]                             next
[10:19:21.519]                           if (!grepl(pattern, name)) 
[10:19:21.519]                             next
[10:19:21.519]                           invokeRestart(restart)
[10:19:21.519]                           muffled <- TRUE
[10:19:21.519]                           break
[10:19:21.519]                         }
[10:19:21.519]                       }
[10:19:21.519]                     }
[10:19:21.519]                     invisible(muffled)
[10:19:21.519]                   }
[10:19:21.519]                   muffleCondition(cond)
[10:19:21.519]                 })
[10:19:21.519]             }))
[10:19:21.519]             future::FutureResult(value = ...future.value$value, 
[10:19:21.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.519]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.519]                     ...future.globalenv.names))
[10:19:21.519]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.519]         }, condition = base::local({
[10:19:21.519]             c <- base::c
[10:19:21.519]             inherits <- base::inherits
[10:19:21.519]             invokeRestart <- base::invokeRestart
[10:19:21.519]             length <- base::length
[10:19:21.519]             list <- base::list
[10:19:21.519]             seq.int <- base::seq.int
[10:19:21.519]             signalCondition <- base::signalCondition
[10:19:21.519]             sys.calls <- base::sys.calls
[10:19:21.519]             `[[` <- base::`[[`
[10:19:21.519]             `+` <- base::`+`
[10:19:21.519]             `<<-` <- base::`<<-`
[10:19:21.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.519]                   3L)]
[10:19:21.519]             }
[10:19:21.519]             function(cond) {
[10:19:21.519]                 is_error <- inherits(cond, "error")
[10:19:21.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.519]                   NULL)
[10:19:21.519]                 if (is_error) {
[10:19:21.519]                   sessionInformation <- function() {
[10:19:21.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.519]                       search = base::search(), system = base::Sys.info())
[10:19:21.519]                   }
[10:19:21.519]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.519]                     cond$call), session = sessionInformation(), 
[10:19:21.519]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.519]                   signalCondition(cond)
[10:19:21.519]                 }
[10:19:21.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.519]                 "immediateCondition"))) {
[10:19:21.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.519]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.519]                   if (TRUE && !signal) {
[10:19:21.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.519]                     {
[10:19:21.519]                       inherits <- base::inherits
[10:19:21.519]                       invokeRestart <- base::invokeRestart
[10:19:21.519]                       is.null <- base::is.null
[10:19:21.519]                       muffled <- FALSE
[10:19:21.519]                       if (inherits(cond, "message")) {
[10:19:21.519]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.519]                         if (muffled) 
[10:19:21.519]                           invokeRestart("muffleMessage")
[10:19:21.519]                       }
[10:19:21.519]                       else if (inherits(cond, "warning")) {
[10:19:21.519]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.519]                         if (muffled) 
[10:19:21.519]                           invokeRestart("muffleWarning")
[10:19:21.519]                       }
[10:19:21.519]                       else if (inherits(cond, "condition")) {
[10:19:21.519]                         if (!is.null(pattern)) {
[10:19:21.519]                           computeRestarts <- base::computeRestarts
[10:19:21.519]                           grepl <- base::grepl
[10:19:21.519]                           restarts <- computeRestarts(cond)
[10:19:21.519]                           for (restart in restarts) {
[10:19:21.519]                             name <- restart$name
[10:19:21.519]                             if (is.null(name)) 
[10:19:21.519]                               next
[10:19:21.519]                             if (!grepl(pattern, name)) 
[10:19:21.519]                               next
[10:19:21.519]                             invokeRestart(restart)
[10:19:21.519]                             muffled <- TRUE
[10:19:21.519]                             break
[10:19:21.519]                           }
[10:19:21.519]                         }
[10:19:21.519]                       }
[10:19:21.519]                       invisible(muffled)
[10:19:21.519]                     }
[10:19:21.519]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.519]                   }
[10:19:21.519]                 }
[10:19:21.519]                 else {
[10:19:21.519]                   if (TRUE) {
[10:19:21.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.519]                     {
[10:19:21.519]                       inherits <- base::inherits
[10:19:21.519]                       invokeRestart <- base::invokeRestart
[10:19:21.519]                       is.null <- base::is.null
[10:19:21.519]                       muffled <- FALSE
[10:19:21.519]                       if (inherits(cond, "message")) {
[10:19:21.519]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.519]                         if (muffled) 
[10:19:21.519]                           invokeRestart("muffleMessage")
[10:19:21.519]                       }
[10:19:21.519]                       else if (inherits(cond, "warning")) {
[10:19:21.519]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.519]                         if (muffled) 
[10:19:21.519]                           invokeRestart("muffleWarning")
[10:19:21.519]                       }
[10:19:21.519]                       else if (inherits(cond, "condition")) {
[10:19:21.519]                         if (!is.null(pattern)) {
[10:19:21.519]                           computeRestarts <- base::computeRestarts
[10:19:21.519]                           grepl <- base::grepl
[10:19:21.519]                           restarts <- computeRestarts(cond)
[10:19:21.519]                           for (restart in restarts) {
[10:19:21.519]                             name <- restart$name
[10:19:21.519]                             if (is.null(name)) 
[10:19:21.519]                               next
[10:19:21.519]                             if (!grepl(pattern, name)) 
[10:19:21.519]                               next
[10:19:21.519]                             invokeRestart(restart)
[10:19:21.519]                             muffled <- TRUE
[10:19:21.519]                             break
[10:19:21.519]                           }
[10:19:21.519]                         }
[10:19:21.519]                       }
[10:19:21.519]                       invisible(muffled)
[10:19:21.519]                     }
[10:19:21.519]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.519]                   }
[10:19:21.519]                 }
[10:19:21.519]             }
[10:19:21.519]         }))
[10:19:21.519]     }, error = function(ex) {
[10:19:21.519]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.519]                 ...future.rng), started = ...future.startTime, 
[10:19:21.519]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.519]             version = "1.8"), class = "FutureResult")
[10:19:21.519]     }, finally = {
[10:19:21.519]         if (!identical(...future.workdir, getwd())) 
[10:19:21.519]             setwd(...future.workdir)
[10:19:21.519]         {
[10:19:21.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.519]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.519]             }
[10:19:21.519]             base::options(...future.oldOptions)
[10:19:21.519]             if (.Platform$OS.type == "windows") {
[10:19:21.519]                 old_names <- names(...future.oldEnvVars)
[10:19:21.519]                 envs <- base::Sys.getenv()
[10:19:21.519]                 names <- names(envs)
[10:19:21.519]                 common <- intersect(names, old_names)
[10:19:21.519]                 added <- setdiff(names, old_names)
[10:19:21.519]                 removed <- setdiff(old_names, names)
[10:19:21.519]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.519]                   envs[common]]
[10:19:21.519]                 NAMES <- toupper(changed)
[10:19:21.519]                 args <- list()
[10:19:21.519]                 for (kk in seq_along(NAMES)) {
[10:19:21.519]                   name <- changed[[kk]]
[10:19:21.519]                   NAME <- NAMES[[kk]]
[10:19:21.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.519]                     next
[10:19:21.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.519]                 }
[10:19:21.519]                 NAMES <- toupper(added)
[10:19:21.519]                 for (kk in seq_along(NAMES)) {
[10:19:21.519]                   name <- added[[kk]]
[10:19:21.519]                   NAME <- NAMES[[kk]]
[10:19:21.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.519]                     next
[10:19:21.519]                   args[[name]] <- ""
[10:19:21.519]                 }
[10:19:21.519]                 NAMES <- toupper(removed)
[10:19:21.519]                 for (kk in seq_along(NAMES)) {
[10:19:21.519]                   name <- removed[[kk]]
[10:19:21.519]                   NAME <- NAMES[[kk]]
[10:19:21.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.519]                     next
[10:19:21.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.519]                 }
[10:19:21.519]                 if (length(args) > 0) 
[10:19:21.519]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.519]             }
[10:19:21.519]             else {
[10:19:21.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.519]             }
[10:19:21.519]             {
[10:19:21.519]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.519]                   0L) {
[10:19:21.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.519]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.519]                   base::options(opts)
[10:19:21.519]                 }
[10:19:21.519]                 {
[10:19:21.519]                   {
[10:19:21.519]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.519]                     NULL
[10:19:21.519]                   }
[10:19:21.519]                   options(future.plan = NULL)
[10:19:21.519]                   if (is.na(NA_character_)) 
[10:19:21.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.519]                     .init = FALSE)
[10:19:21.519]                 }
[10:19:21.519]             }
[10:19:21.519]         }
[10:19:21.519]     })
[10:19:21.519]     if (TRUE) {
[10:19:21.519]         base::sink(type = "output", split = FALSE)
[10:19:21.519]         if (TRUE) {
[10:19:21.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.519]         }
[10:19:21.519]         else {
[10:19:21.519]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.519]         }
[10:19:21.519]         base::close(...future.stdout)
[10:19:21.519]         ...future.stdout <- NULL
[10:19:21.519]     }
[10:19:21.519]     ...future.result$conditions <- ...future.conditions
[10:19:21.519]     ...future.result$finished <- base::Sys.time()
[10:19:21.519]     ...future.result
[10:19:21.519] }
[10:19:21.521] assign_globals() ...
[10:19:21.521] List of 5
[10:19:21.521]  $ ...future.FUN            :function (x, ...)  
[10:19:21.521]  $ MoreArgs                 :List of 1
[10:19:21.521]   ..$ x: num 42
[10:19:21.521]  $ ...future.elements_ii    :List of 1
[10:19:21.521]   ..$ times:List of 2
[10:19:21.521]   .. ..$ : int 1
[10:19:21.521]   .. ..$ : int 2
[10:19:21.521]  $ ...future.seeds_ii       : NULL
[10:19:21.521]  $ ...future.globals.maxSize: NULL
[10:19:21.521]  - attr(*, "where")=List of 5
[10:19:21.521]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.521]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.521]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.521]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.521]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.521]  - attr(*, "resolved")= logi FALSE
[10:19:21.521]  - attr(*, "total_size")= num 286
[10:19:21.521]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.521]  - attr(*, "already-done")= logi TRUE
[10:19:21.528] - copied ‘...future.FUN’ to environment
[10:19:21.528] - copied ‘MoreArgs’ to environment
[10:19:21.528] - copied ‘...future.elements_ii’ to environment
[10:19:21.528] - copied ‘...future.seeds_ii’ to environment
[10:19:21.529] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.529] assign_globals() ... done
[10:19:21.529] requestCore(): workers = 2
[10:19:21.531] MulticoreFuture started
[10:19:21.532] - Launch lazy future ... done
[10:19:21.532] run() for ‘MulticoreFuture’ ... done
[10:19:21.532] plan(): Setting new future strategy stack:
[10:19:21.532] Created future:
[10:19:21.532] List of future strategies:
[10:19:21.532] 1. sequential:
[10:19:21.532]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.532]    - tweaked: FALSE
[10:19:21.532]    - call: NULL
[10:19:21.534] plan(): nbrOfWorkers() = 1
[10:19:21.536] plan(): Setting new future strategy stack:
[10:19:21.536] List of future strategies:
[10:19:21.536] 1. multicore:
[10:19:21.536]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.536]    - tweaked: FALSE
[10:19:21.536]    - call: plan(strategy)
[10:19:21.539] plan(): nbrOfWorkers() = 2
[10:19:21.532] MulticoreFuture:
[10:19:21.532] Label: ‘future_mapply-1’
[10:19:21.532] Expression:
[10:19:21.532] {
[10:19:21.532]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.532]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.532]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.532]         on.exit(options(oopts), add = TRUE)
[10:19:21.532]     }
[10:19:21.532]     {
[10:19:21.532]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.532]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.532]         do.call(mapply, args = args)
[10:19:21.532]     }
[10:19:21.532] }
[10:19:21.532] Lazy evaluation: FALSE
[10:19:21.532] Asynchronous evaluation: TRUE
[10:19:21.532] Local evaluation: TRUE
[10:19:21.532] Environment: R_GlobalEnv
[10:19:21.532] Capture standard output: TRUE
[10:19:21.532] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.532] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.532] Packages: <none>
[10:19:21.532] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.532] Resolved: TRUE
[10:19:21.532] Value: <not collected>
[10:19:21.532] Conditions captured: <none>
[10:19:21.532] Early signaling: FALSE
[10:19:21.532] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.532] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.541] Chunk #1 of 2 ... DONE
[10:19:21.541] Chunk #2 of 2 ...
[10:19:21.541]  - Finding globals in '...' for chunk #2 ...
[10:19:21.541] getGlobalsAndPackages() ...
[10:19:21.541] Searching for globals...
[10:19:21.542] 
[10:19:21.542] Searching for globals ... DONE
[10:19:21.542] - globals: [0] <none>
[10:19:21.542] getGlobalsAndPackages() ... DONE
[10:19:21.542]    + additional globals found: [n=0] 
[10:19:21.543]    + additional namespaces needed: [n=0] 
[10:19:21.543]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:21.543]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.543]  - seeds: <none>
[10:19:21.543]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.543] getGlobalsAndPackages() ...
[10:19:21.543] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.544] Resolving globals: FALSE
[10:19:21.544] The total size of the 5 globals is 286 bytes (286 bytes)
[10:19:21.545] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[10:19:21.545] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.546] 
[10:19:21.546] getGlobalsAndPackages() ... DONE
[10:19:21.546] run() for ‘Future’ ...
[10:19:21.546] - state: ‘created’
[10:19:21.546] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.549] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.549] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.549]   - Field: ‘label’
[10:19:21.549]   - Field: ‘local’
[10:19:21.549]   - Field: ‘owner’
[10:19:21.550]   - Field: ‘envir’
[10:19:21.550]   - Field: ‘workers’
[10:19:21.550]   - Field: ‘packages’
[10:19:21.550]   - Field: ‘gc’
[10:19:21.550]   - Field: ‘job’
[10:19:21.550]   - Field: ‘conditions’
[10:19:21.550]   - Field: ‘expr’
[10:19:21.551]   - Field: ‘uuid’
[10:19:21.551]   - Field: ‘seed’
[10:19:21.551]   - Field: ‘version’
[10:19:21.551]   - Field: ‘result’
[10:19:21.551]   - Field: ‘asynchronous’
[10:19:21.551]   - Field: ‘calls’
[10:19:21.551]   - Field: ‘globals’
[10:19:21.551]   - Field: ‘stdout’
[10:19:21.552]   - Field: ‘earlySignal’
[10:19:21.552]   - Field: ‘lazy’
[10:19:21.552]   - Field: ‘state’
[10:19:21.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.552] - Launch lazy future ...
[10:19:21.553] Packages needed by the future expression (n = 0): <none>
[10:19:21.553] Packages needed by future strategies (n = 0): <none>
[10:19:21.553] {
[10:19:21.553]     {
[10:19:21.553]         {
[10:19:21.553]             ...future.startTime <- base::Sys.time()
[10:19:21.553]             {
[10:19:21.553]                 {
[10:19:21.553]                   {
[10:19:21.553]                     {
[10:19:21.553]                       base::local({
[10:19:21.553]                         has_future <- base::requireNamespace("future", 
[10:19:21.553]                           quietly = TRUE)
[10:19:21.553]                         if (has_future) {
[10:19:21.553]                           ns <- base::getNamespace("future")
[10:19:21.553]                           version <- ns[[".package"]][["version"]]
[10:19:21.553]                           if (is.null(version)) 
[10:19:21.553]                             version <- utils::packageVersion("future")
[10:19:21.553]                         }
[10:19:21.553]                         else {
[10:19:21.553]                           version <- NULL
[10:19:21.553]                         }
[10:19:21.553]                         if (!has_future || version < "1.8.0") {
[10:19:21.553]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.553]                             "", base::R.version$version.string), 
[10:19:21.553]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.553]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.553]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.553]                               "release", "version")], collapse = " "), 
[10:19:21.553]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.553]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.553]                             info)
[10:19:21.553]                           info <- base::paste(info, collapse = "; ")
[10:19:21.553]                           if (!has_future) {
[10:19:21.553]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.553]                               info)
[10:19:21.553]                           }
[10:19:21.553]                           else {
[10:19:21.553]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.553]                               info, version)
[10:19:21.553]                           }
[10:19:21.553]                           base::stop(msg)
[10:19:21.553]                         }
[10:19:21.553]                       })
[10:19:21.553]                     }
[10:19:21.553]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.553]                     base::options(mc.cores = 1L)
[10:19:21.553]                   }
[10:19:21.553]                   ...future.strategy.old <- future::plan("list")
[10:19:21.553]                   options(future.plan = NULL)
[10:19:21.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.553]                 }
[10:19:21.553]                 ...future.workdir <- getwd()
[10:19:21.553]             }
[10:19:21.553]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.553]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.553]         }
[10:19:21.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.553]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.553]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.553]             base::names(...future.oldOptions))
[10:19:21.553]     }
[10:19:21.553]     if (FALSE) {
[10:19:21.553]     }
[10:19:21.553]     else {
[10:19:21.553]         if (TRUE) {
[10:19:21.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.553]                 open = "w")
[10:19:21.553]         }
[10:19:21.553]         else {
[10:19:21.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.553]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.553]         }
[10:19:21.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.553]             base::sink(type = "output", split = FALSE)
[10:19:21.553]             base::close(...future.stdout)
[10:19:21.553]         }, add = TRUE)
[10:19:21.553]     }
[10:19:21.553]     ...future.frame <- base::sys.nframe()
[10:19:21.553]     ...future.conditions <- base::list()
[10:19:21.553]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.553]     if (FALSE) {
[10:19:21.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.553]     }
[10:19:21.553]     ...future.result <- base::tryCatch({
[10:19:21.553]         base::withCallingHandlers({
[10:19:21.553]             ...future.value <- base::withVisible(base::local({
[10:19:21.553]                 withCallingHandlers({
[10:19:21.553]                   {
[10:19:21.553]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.553]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.553]                       ...future.globals.maxSize)) {
[10:19:21.553]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.553]                       on.exit(options(oopts), add = TRUE)
[10:19:21.553]                     }
[10:19:21.553]                     {
[10:19:21.553]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.553]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.553]                         USE.NAMES = FALSE)
[10:19:21.553]                       do.call(mapply, args = args)
[10:19:21.553]                     }
[10:19:21.553]                   }
[10:19:21.553]                 }, immediateCondition = function(cond) {
[10:19:21.553]                   save_rds <- function (object, pathname, ...) 
[10:19:21.553]                   {
[10:19:21.553]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.553]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.553]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.553]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.553]                         fi_tmp[["mtime"]])
[10:19:21.553]                     }
[10:19:21.553]                     tryCatch({
[10:19:21.553]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.553]                     }, error = function(ex) {
[10:19:21.553]                       msg <- conditionMessage(ex)
[10:19:21.553]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.553]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.553]                         fi_tmp[["mtime"]], msg)
[10:19:21.553]                       ex$message <- msg
[10:19:21.553]                       stop(ex)
[10:19:21.553]                     })
[10:19:21.553]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.553]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.553]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.553]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.553]                       fi <- file.info(pathname)
[10:19:21.553]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.553]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.553]                         fi[["size"]], fi[["mtime"]])
[10:19:21.553]                       stop(msg)
[10:19:21.553]                     }
[10:19:21.553]                     invisible(pathname)
[10:19:21.553]                   }
[10:19:21.553]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.553]                     rootPath = tempdir()) 
[10:19:21.553]                   {
[10:19:21.553]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.553]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.553]                       tmpdir = path, fileext = ".rds")
[10:19:21.553]                     save_rds(obj, file)
[10:19:21.553]                   }
[10:19:21.553]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.553]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.553]                   {
[10:19:21.553]                     inherits <- base::inherits
[10:19:21.553]                     invokeRestart <- base::invokeRestart
[10:19:21.553]                     is.null <- base::is.null
[10:19:21.553]                     muffled <- FALSE
[10:19:21.553]                     if (inherits(cond, "message")) {
[10:19:21.553]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.553]                       if (muffled) 
[10:19:21.553]                         invokeRestart("muffleMessage")
[10:19:21.553]                     }
[10:19:21.553]                     else if (inherits(cond, "warning")) {
[10:19:21.553]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.553]                       if (muffled) 
[10:19:21.553]                         invokeRestart("muffleWarning")
[10:19:21.553]                     }
[10:19:21.553]                     else if (inherits(cond, "condition")) {
[10:19:21.553]                       if (!is.null(pattern)) {
[10:19:21.553]                         computeRestarts <- base::computeRestarts
[10:19:21.553]                         grepl <- base::grepl
[10:19:21.553]                         restarts <- computeRestarts(cond)
[10:19:21.553]                         for (restart in restarts) {
[10:19:21.553]                           name <- restart$name
[10:19:21.553]                           if (is.null(name)) 
[10:19:21.553]                             next
[10:19:21.553]                           if (!grepl(pattern, name)) 
[10:19:21.553]                             next
[10:19:21.553]                           invokeRestart(restart)
[10:19:21.553]                           muffled <- TRUE
[10:19:21.553]                           break
[10:19:21.553]                         }
[10:19:21.553]                       }
[10:19:21.553]                     }
[10:19:21.553]                     invisible(muffled)
[10:19:21.553]                   }
[10:19:21.553]                   muffleCondition(cond)
[10:19:21.553]                 })
[10:19:21.553]             }))
[10:19:21.553]             future::FutureResult(value = ...future.value$value, 
[10:19:21.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.553]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.553]                     ...future.globalenv.names))
[10:19:21.553]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.553]         }, condition = base::local({
[10:19:21.553]             c <- base::c
[10:19:21.553]             inherits <- base::inherits
[10:19:21.553]             invokeRestart <- base::invokeRestart
[10:19:21.553]             length <- base::length
[10:19:21.553]             list <- base::list
[10:19:21.553]             seq.int <- base::seq.int
[10:19:21.553]             signalCondition <- base::signalCondition
[10:19:21.553]             sys.calls <- base::sys.calls
[10:19:21.553]             `[[` <- base::`[[`
[10:19:21.553]             `+` <- base::`+`
[10:19:21.553]             `<<-` <- base::`<<-`
[10:19:21.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.553]                   3L)]
[10:19:21.553]             }
[10:19:21.553]             function(cond) {
[10:19:21.553]                 is_error <- inherits(cond, "error")
[10:19:21.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.553]                   NULL)
[10:19:21.553]                 if (is_error) {
[10:19:21.553]                   sessionInformation <- function() {
[10:19:21.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.553]                       search = base::search(), system = base::Sys.info())
[10:19:21.553]                   }
[10:19:21.553]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.553]                     cond$call), session = sessionInformation(), 
[10:19:21.553]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.553]                   signalCondition(cond)
[10:19:21.553]                 }
[10:19:21.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.553]                 "immediateCondition"))) {
[10:19:21.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.553]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.553]                   if (TRUE && !signal) {
[10:19:21.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.553]                     {
[10:19:21.553]                       inherits <- base::inherits
[10:19:21.553]                       invokeRestart <- base::invokeRestart
[10:19:21.553]                       is.null <- base::is.null
[10:19:21.553]                       muffled <- FALSE
[10:19:21.553]                       if (inherits(cond, "message")) {
[10:19:21.553]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.553]                         if (muffled) 
[10:19:21.553]                           invokeRestart("muffleMessage")
[10:19:21.553]                       }
[10:19:21.553]                       else if (inherits(cond, "warning")) {
[10:19:21.553]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.553]                         if (muffled) 
[10:19:21.553]                           invokeRestart("muffleWarning")
[10:19:21.553]                       }
[10:19:21.553]                       else if (inherits(cond, "condition")) {
[10:19:21.553]                         if (!is.null(pattern)) {
[10:19:21.553]                           computeRestarts <- base::computeRestarts
[10:19:21.553]                           grepl <- base::grepl
[10:19:21.553]                           restarts <- computeRestarts(cond)
[10:19:21.553]                           for (restart in restarts) {
[10:19:21.553]                             name <- restart$name
[10:19:21.553]                             if (is.null(name)) 
[10:19:21.553]                               next
[10:19:21.553]                             if (!grepl(pattern, name)) 
[10:19:21.553]                               next
[10:19:21.553]                             invokeRestart(restart)
[10:19:21.553]                             muffled <- TRUE
[10:19:21.553]                             break
[10:19:21.553]                           }
[10:19:21.553]                         }
[10:19:21.553]                       }
[10:19:21.553]                       invisible(muffled)
[10:19:21.553]                     }
[10:19:21.553]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.553]                   }
[10:19:21.553]                 }
[10:19:21.553]                 else {
[10:19:21.553]                   if (TRUE) {
[10:19:21.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.553]                     {
[10:19:21.553]                       inherits <- base::inherits
[10:19:21.553]                       invokeRestart <- base::invokeRestart
[10:19:21.553]                       is.null <- base::is.null
[10:19:21.553]                       muffled <- FALSE
[10:19:21.553]                       if (inherits(cond, "message")) {
[10:19:21.553]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.553]                         if (muffled) 
[10:19:21.553]                           invokeRestart("muffleMessage")
[10:19:21.553]                       }
[10:19:21.553]                       else if (inherits(cond, "warning")) {
[10:19:21.553]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.553]                         if (muffled) 
[10:19:21.553]                           invokeRestart("muffleWarning")
[10:19:21.553]                       }
[10:19:21.553]                       else if (inherits(cond, "condition")) {
[10:19:21.553]                         if (!is.null(pattern)) {
[10:19:21.553]                           computeRestarts <- base::computeRestarts
[10:19:21.553]                           grepl <- base::grepl
[10:19:21.553]                           restarts <- computeRestarts(cond)
[10:19:21.553]                           for (restart in restarts) {
[10:19:21.553]                             name <- restart$name
[10:19:21.553]                             if (is.null(name)) 
[10:19:21.553]                               next
[10:19:21.553]                             if (!grepl(pattern, name)) 
[10:19:21.553]                               next
[10:19:21.553]                             invokeRestart(restart)
[10:19:21.553]                             muffled <- TRUE
[10:19:21.553]                             break
[10:19:21.553]                           }
[10:19:21.553]                         }
[10:19:21.553]                       }
[10:19:21.553]                       invisible(muffled)
[10:19:21.553]                     }
[10:19:21.553]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.553]                   }
[10:19:21.553]                 }
[10:19:21.553]             }
[10:19:21.553]         }))
[10:19:21.553]     }, error = function(ex) {
[10:19:21.553]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.553]                 ...future.rng), started = ...future.startTime, 
[10:19:21.553]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.553]             version = "1.8"), class = "FutureResult")
[10:19:21.553]     }, finally = {
[10:19:21.553]         if (!identical(...future.workdir, getwd())) 
[10:19:21.553]             setwd(...future.workdir)
[10:19:21.553]         {
[10:19:21.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.553]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.553]             }
[10:19:21.553]             base::options(...future.oldOptions)
[10:19:21.553]             if (.Platform$OS.type == "windows") {
[10:19:21.553]                 old_names <- names(...future.oldEnvVars)
[10:19:21.553]                 envs <- base::Sys.getenv()
[10:19:21.553]                 names <- names(envs)
[10:19:21.553]                 common <- intersect(names, old_names)
[10:19:21.553]                 added <- setdiff(names, old_names)
[10:19:21.553]                 removed <- setdiff(old_names, names)
[10:19:21.553]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.553]                   envs[common]]
[10:19:21.553]                 NAMES <- toupper(changed)
[10:19:21.553]                 args <- list()
[10:19:21.553]                 for (kk in seq_along(NAMES)) {
[10:19:21.553]                   name <- changed[[kk]]
[10:19:21.553]                   NAME <- NAMES[[kk]]
[10:19:21.553]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.553]                     next
[10:19:21.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.553]                 }
[10:19:21.553]                 NAMES <- toupper(added)
[10:19:21.553]                 for (kk in seq_along(NAMES)) {
[10:19:21.553]                   name <- added[[kk]]
[10:19:21.553]                   NAME <- NAMES[[kk]]
[10:19:21.553]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.553]                     next
[10:19:21.553]                   args[[name]] <- ""
[10:19:21.553]                 }
[10:19:21.553]                 NAMES <- toupper(removed)
[10:19:21.553]                 for (kk in seq_along(NAMES)) {
[10:19:21.553]                   name <- removed[[kk]]
[10:19:21.553]                   NAME <- NAMES[[kk]]
[10:19:21.553]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.553]                     next
[10:19:21.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.553]                 }
[10:19:21.553]                 if (length(args) > 0) 
[10:19:21.553]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.553]             }
[10:19:21.553]             else {
[10:19:21.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.553]             }
[10:19:21.553]             {
[10:19:21.553]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.553]                   0L) {
[10:19:21.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.553]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.553]                   base::options(opts)
[10:19:21.553]                 }
[10:19:21.553]                 {
[10:19:21.553]                   {
[10:19:21.553]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.553]                     NULL
[10:19:21.553]                   }
[10:19:21.553]                   options(future.plan = NULL)
[10:19:21.553]                   if (is.na(NA_character_)) 
[10:19:21.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.553]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.553]                     .init = FALSE)
[10:19:21.553]                 }
[10:19:21.553]             }
[10:19:21.553]         }
[10:19:21.553]     })
[10:19:21.553]     if (TRUE) {
[10:19:21.553]         base::sink(type = "output", split = FALSE)
[10:19:21.553]         if (TRUE) {
[10:19:21.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.553]         }
[10:19:21.553]         else {
[10:19:21.553]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.553]         }
[10:19:21.553]         base::close(...future.stdout)
[10:19:21.553]         ...future.stdout <- NULL
[10:19:21.553]     }
[10:19:21.553]     ...future.result$conditions <- ...future.conditions
[10:19:21.553]     ...future.result$finished <- base::Sys.time()
[10:19:21.553]     ...future.result
[10:19:21.553] }
[10:19:21.557] assign_globals() ...
[10:19:21.557] List of 5
[10:19:21.557]  $ ...future.FUN            :function (x, ...)  
[10:19:21.557]  $ MoreArgs                 :List of 1
[10:19:21.557]   ..$ x: num 42
[10:19:21.557]  $ ...future.elements_ii    :List of 1
[10:19:21.557]   ..$ times:List of 2
[10:19:21.557]   .. ..$ : int 3
[10:19:21.557]   .. ..$ : int 4
[10:19:21.557]  $ ...future.seeds_ii       : NULL
[10:19:21.557]  $ ...future.globals.maxSize: NULL
[10:19:21.557]  - attr(*, "where")=List of 5
[10:19:21.557]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.557]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.557]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.557]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.557]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.557]  - attr(*, "resolved")= logi FALSE
[10:19:21.557]  - attr(*, "total_size")= num 286
[10:19:21.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.557]  - attr(*, "already-done")= logi TRUE
[10:19:21.568] - copied ‘...future.FUN’ to environment
[10:19:21.569] - copied ‘MoreArgs’ to environment
[10:19:21.569] - copied ‘...future.elements_ii’ to environment
[10:19:21.569] - copied ‘...future.seeds_ii’ to environment
[10:19:21.569] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.569] assign_globals() ... done
[10:19:21.570] requestCore(): workers = 2
[10:19:21.572] MulticoreFuture started
[10:19:21.573] - Launch lazy future ... done
[10:19:21.573] run() for ‘MulticoreFuture’ ... done
[10:19:21.573] plan(): Setting new future strategy stack:
[10:19:21.574] Created future:
[10:19:21.574] List of future strategies:
[10:19:21.574] 1. sequential:
[10:19:21.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.574]    - tweaked: FALSE
[10:19:21.574]    - call: NULL
[10:19:21.575] plan(): nbrOfWorkers() = 1
[10:19:21.579] plan(): Setting new future strategy stack:
[10:19:21.579] List of future strategies:
[10:19:21.579] 1. multicore:
[10:19:21.579]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.579]    - tweaked: FALSE
[10:19:21.579]    - call: plan(strategy)
[10:19:21.583] plan(): nbrOfWorkers() = 2
[10:19:21.574] MulticoreFuture:
[10:19:21.574] Label: ‘future_mapply-2’
[10:19:21.574] Expression:
[10:19:21.574] {
[10:19:21.574]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.574]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.574]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.574]         on.exit(options(oopts), add = TRUE)
[10:19:21.574]     }
[10:19:21.574]     {
[10:19:21.574]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.574]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.574]         do.call(mapply, args = args)
[10:19:21.574]     }
[10:19:21.574] }
[10:19:21.574] Lazy evaluation: FALSE
[10:19:21.574] Asynchronous evaluation: TRUE
[10:19:21.574] Local evaluation: TRUE
[10:19:21.574] Environment: R_GlobalEnv
[10:19:21.574] Capture standard output: TRUE
[10:19:21.574] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.574] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.574] Packages: <none>
[10:19:21.574] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.574] Resolved: TRUE
[10:19:21.574] Value: <not collected>
[10:19:21.574] Conditions captured: <none>
[10:19:21.574] Early signaling: FALSE
[10:19:21.574] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.574] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.584] Chunk #2 of 2 ... DONE
[10:19:21.584] Launching 2 futures (chunks) ... DONE
[10:19:21.584] Resolving 2 futures (chunks) ...
[10:19:21.585] resolve() on list ...
[10:19:21.585]  recursive: 0
[10:19:21.585]  length: 2
[10:19:21.585] 
[10:19:21.586] Future #1
[10:19:21.586] result() for MulticoreFuture ...
[10:19:21.587] result() for MulticoreFuture ...
[10:19:21.587] result() for MulticoreFuture ... done
[10:19:21.587] result() for MulticoreFuture ... done
[10:19:21.587] result() for MulticoreFuture ...
[10:19:21.588] result() for MulticoreFuture ... done
[10:19:21.588] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:21.588] - nx: 2
[10:19:21.588] - relay: TRUE
[10:19:21.588] - stdout: TRUE
[10:19:21.588] - signal: TRUE
[10:19:21.589] - resignal: FALSE
[10:19:21.589] - force: TRUE
[10:19:21.589] - relayed: [n=2] FALSE, FALSE
[10:19:21.589] - queued futures: [n=2] FALSE, FALSE
[10:19:21.589]  - until=1
[10:19:21.589]  - relaying element #1
[10:19:21.590] result() for MulticoreFuture ...
[10:19:21.590] result() for MulticoreFuture ... done
[10:19:21.590] result() for MulticoreFuture ...
[10:19:21.590] result() for MulticoreFuture ... done
[10:19:21.590] result() for MulticoreFuture ...
[10:19:21.590] result() for MulticoreFuture ... done
[10:19:21.591] result() for MulticoreFuture ...
[10:19:21.591] result() for MulticoreFuture ... done
[10:19:21.591] - relayed: [n=2] TRUE, FALSE
[10:19:21.591] - queued futures: [n=2] TRUE, FALSE
[10:19:21.591] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:21.591]  length: 1 (resolved future 1)
[10:19:21.592] Future #2
[10:19:21.592] result() for MulticoreFuture ...
[10:19:21.592] result() for MulticoreFuture ...
[10:19:21.592] result() for MulticoreFuture ... done
[10:19:21.593] result() for MulticoreFuture ... done
[10:19:21.593] result() for MulticoreFuture ...
[10:19:21.593] result() for MulticoreFuture ... done
[10:19:21.593] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:21.593] - nx: 2
[10:19:21.593] - relay: TRUE
[10:19:21.593] - stdout: TRUE
[10:19:21.593] - signal: TRUE
[10:19:21.594] - resignal: FALSE
[10:19:21.594] - force: TRUE
[10:19:21.594] - relayed: [n=2] TRUE, FALSE
[10:19:21.594] - queued futures: [n=2] TRUE, FALSE
[10:19:21.594]  - until=2
[10:19:21.594]  - relaying element #2
[10:19:21.594] result() for MulticoreFuture ...
[10:19:21.594] result() for MulticoreFuture ... done
[10:19:21.594] result() for MulticoreFuture ...
[10:19:21.595] result() for MulticoreFuture ... done
[10:19:21.595] result() for MulticoreFuture ...
[10:19:21.595] result() for MulticoreFuture ... done
[10:19:21.595] result() for MulticoreFuture ...
[10:19:21.595] result() for MulticoreFuture ... done
[10:19:21.595] - relayed: [n=2] TRUE, TRUE
[10:19:21.595] - queued futures: [n=2] TRUE, TRUE
[10:19:21.595] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:21.595]  length: 0 (resolved future 2)
[10:19:21.596] Relaying remaining futures
[10:19:21.596] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.596] - nx: 2
[10:19:21.596] - relay: TRUE
[10:19:21.596] - stdout: TRUE
[10:19:21.596] - signal: TRUE
[10:19:21.596] - resignal: FALSE
[10:19:21.596] - force: TRUE
[10:19:21.596] - relayed: [n=2] TRUE, TRUE
[10:19:21.596] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:21.597] - relayed: [n=2] TRUE, TRUE
[10:19:21.597] - queued futures: [n=2] TRUE, TRUE
[10:19:21.597] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.597] resolve() on list ... DONE
[10:19:21.597] result() for MulticoreFuture ...
[10:19:21.597] result() for MulticoreFuture ... done
[10:19:21.597] result() for MulticoreFuture ...
[10:19:21.597] result() for MulticoreFuture ... done
[10:19:21.598] result() for MulticoreFuture ...
[10:19:21.598] result() for MulticoreFuture ... done
[10:19:21.598] result() for MulticoreFuture ...
[10:19:21.598] result() for MulticoreFuture ... done
[10:19:21.598]  - Number of value chunks collected: 2
[10:19:21.598] Resolving 2 futures (chunks) ... DONE
[10:19:21.598] Reducing values from 2 chunks ...
[10:19:21.598]  - Number of values collected after concatenation: 4
[10:19:21.598]  - Number of values expected: 4
[10:19:21.598] Reducing values from 2 chunks ... DONE
[10:19:21.599] future_mapply() ... DONE
[10:19:21.599] future_mapply() ...
[10:19:21.601] Number of chunks: 2
[10:19:21.601] getGlobalsAndPackagesXApply() ...
[10:19:21.601]  - future.globals: TRUE
[10:19:21.601] getGlobalsAndPackages() ...
[10:19:21.601] Searching for globals...
[10:19:21.603] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:19:21.603] Searching for globals ... DONE
[10:19:21.603] Resolving globals: FALSE
[10:19:21.604] The total size of the 1 globals is 414 bytes (414 bytes)
[10:19:21.604] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:19:21.604] - globals: [1] ‘FUN’
[10:19:21.604] 
[10:19:21.604] getGlobalsAndPackages() ... DONE
[10:19:21.605]  - globals found/used: [n=1] ‘FUN’
[10:19:21.605]  - needed namespaces: [n=0] 
[10:19:21.605] Finding globals ... DONE
[10:19:21.605] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.605] List of 2
[10:19:21.605]  $ ...future.FUN:function (x, y)  
[10:19:21.605]  $ MoreArgs     : NULL
[10:19:21.605]  - attr(*, "where")=List of 2
[10:19:21.605]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.605]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.605]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.605]  - attr(*, "resolved")= logi FALSE
[10:19:21.605]  - attr(*, "total_size")= num NA
[10:19:21.610] Packages to be attached in all futures: [n=0] 
[10:19:21.610] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.611] Number of futures (= number of chunks): 2
[10:19:21.611] Launching 2 futures (chunks) ...
[10:19:21.611] Chunk #1 of 2 ...
[10:19:21.611]  - Finding globals in '...' for chunk #1 ...
[10:19:21.611] getGlobalsAndPackages() ...
[10:19:21.611] Searching for globals...
[10:19:21.612] 
[10:19:21.612] Searching for globals ... DONE
[10:19:21.612] - globals: [0] <none>
[10:19:21.612] getGlobalsAndPackages() ... DONE
[10:19:21.612]    + additional globals found: [n=0] 
[10:19:21.612]    + additional namespaces needed: [n=0] 
[10:19:21.612]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.612]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.613]  - seeds: <none>
[10:19:21.613]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.613] getGlobalsAndPackages() ...
[10:19:21.613] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.613] Resolving globals: FALSE
[10:19:21.613] The total size of the 5 globals is 645 bytes (645 bytes)
[10:19:21.614] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 645 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.614] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.614] 
[10:19:21.614] getGlobalsAndPackages() ... DONE
[10:19:21.614] run() for ‘Future’ ...
[10:19:21.615] - state: ‘created’
[10:19:21.615] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.616] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.616] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.617]   - Field: ‘label’
[10:19:21.617]   - Field: ‘local’
[10:19:21.617]   - Field: ‘owner’
[10:19:21.617]   - Field: ‘envir’
[10:19:21.617]   - Field: ‘workers’
[10:19:21.617]   - Field: ‘packages’
[10:19:21.617]   - Field: ‘gc’
[10:19:21.617]   - Field: ‘job’
[10:19:21.617]   - Field: ‘conditions’
[10:19:21.617]   - Field: ‘expr’
[10:19:21.617]   - Field: ‘uuid’
[10:19:21.618]   - Field: ‘seed’
[10:19:21.618]   - Field: ‘version’
[10:19:21.618]   - Field: ‘result’
[10:19:21.618]   - Field: ‘asynchronous’
[10:19:21.618]   - Field: ‘calls’
[10:19:21.618]   - Field: ‘globals’
[10:19:21.618]   - Field: ‘stdout’
[10:19:21.618]   - Field: ‘earlySignal’
[10:19:21.618]   - Field: ‘lazy’
[10:19:21.618]   - Field: ‘state’
[10:19:21.618] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.618] - Launch lazy future ...
[10:19:21.619] Packages needed by the future expression (n = 0): <none>
[10:19:21.619] Packages needed by future strategies (n = 0): <none>
[10:19:21.619] {
[10:19:21.619]     {
[10:19:21.619]         {
[10:19:21.619]             ...future.startTime <- base::Sys.time()
[10:19:21.619]             {
[10:19:21.619]                 {
[10:19:21.619]                   {
[10:19:21.619]                     {
[10:19:21.619]                       base::local({
[10:19:21.619]                         has_future <- base::requireNamespace("future", 
[10:19:21.619]                           quietly = TRUE)
[10:19:21.619]                         if (has_future) {
[10:19:21.619]                           ns <- base::getNamespace("future")
[10:19:21.619]                           version <- ns[[".package"]][["version"]]
[10:19:21.619]                           if (is.null(version)) 
[10:19:21.619]                             version <- utils::packageVersion("future")
[10:19:21.619]                         }
[10:19:21.619]                         else {
[10:19:21.619]                           version <- NULL
[10:19:21.619]                         }
[10:19:21.619]                         if (!has_future || version < "1.8.0") {
[10:19:21.619]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.619]                             "", base::R.version$version.string), 
[10:19:21.619]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.619]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.619]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.619]                               "release", "version")], collapse = " "), 
[10:19:21.619]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.619]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.619]                             info)
[10:19:21.619]                           info <- base::paste(info, collapse = "; ")
[10:19:21.619]                           if (!has_future) {
[10:19:21.619]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.619]                               info)
[10:19:21.619]                           }
[10:19:21.619]                           else {
[10:19:21.619]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.619]                               info, version)
[10:19:21.619]                           }
[10:19:21.619]                           base::stop(msg)
[10:19:21.619]                         }
[10:19:21.619]                       })
[10:19:21.619]                     }
[10:19:21.619]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.619]                     base::options(mc.cores = 1L)
[10:19:21.619]                   }
[10:19:21.619]                   ...future.strategy.old <- future::plan("list")
[10:19:21.619]                   options(future.plan = NULL)
[10:19:21.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.619]                 }
[10:19:21.619]                 ...future.workdir <- getwd()
[10:19:21.619]             }
[10:19:21.619]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.619]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.619]         }
[10:19:21.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.619]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.619]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.619]             base::names(...future.oldOptions))
[10:19:21.619]     }
[10:19:21.619]     if (FALSE) {
[10:19:21.619]     }
[10:19:21.619]     else {
[10:19:21.619]         if (TRUE) {
[10:19:21.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.619]                 open = "w")
[10:19:21.619]         }
[10:19:21.619]         else {
[10:19:21.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.619]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.619]         }
[10:19:21.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.619]             base::sink(type = "output", split = FALSE)
[10:19:21.619]             base::close(...future.stdout)
[10:19:21.619]         }, add = TRUE)
[10:19:21.619]     }
[10:19:21.619]     ...future.frame <- base::sys.nframe()
[10:19:21.619]     ...future.conditions <- base::list()
[10:19:21.619]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.619]     if (FALSE) {
[10:19:21.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.619]     }
[10:19:21.619]     ...future.result <- base::tryCatch({
[10:19:21.619]         base::withCallingHandlers({
[10:19:21.619]             ...future.value <- base::withVisible(base::local({
[10:19:21.619]                 withCallingHandlers({
[10:19:21.619]                   {
[10:19:21.619]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.619]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.619]                       ...future.globals.maxSize)) {
[10:19:21.619]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.619]                       on.exit(options(oopts), add = TRUE)
[10:19:21.619]                     }
[10:19:21.619]                     {
[10:19:21.619]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.619]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.619]                         USE.NAMES = FALSE)
[10:19:21.619]                       do.call(mapply, args = args)
[10:19:21.619]                     }
[10:19:21.619]                   }
[10:19:21.619]                 }, immediateCondition = function(cond) {
[10:19:21.619]                   save_rds <- function (object, pathname, ...) 
[10:19:21.619]                   {
[10:19:21.619]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.619]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.619]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.619]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.619]                         fi_tmp[["mtime"]])
[10:19:21.619]                     }
[10:19:21.619]                     tryCatch({
[10:19:21.619]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.619]                     }, error = function(ex) {
[10:19:21.619]                       msg <- conditionMessage(ex)
[10:19:21.619]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.619]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.619]                         fi_tmp[["mtime"]], msg)
[10:19:21.619]                       ex$message <- msg
[10:19:21.619]                       stop(ex)
[10:19:21.619]                     })
[10:19:21.619]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.619]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.619]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.619]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.619]                       fi <- file.info(pathname)
[10:19:21.619]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.619]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.619]                         fi[["size"]], fi[["mtime"]])
[10:19:21.619]                       stop(msg)
[10:19:21.619]                     }
[10:19:21.619]                     invisible(pathname)
[10:19:21.619]                   }
[10:19:21.619]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.619]                     rootPath = tempdir()) 
[10:19:21.619]                   {
[10:19:21.619]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.619]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.619]                       tmpdir = path, fileext = ".rds")
[10:19:21.619]                     save_rds(obj, file)
[10:19:21.619]                   }
[10:19:21.619]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.619]                   {
[10:19:21.619]                     inherits <- base::inherits
[10:19:21.619]                     invokeRestart <- base::invokeRestart
[10:19:21.619]                     is.null <- base::is.null
[10:19:21.619]                     muffled <- FALSE
[10:19:21.619]                     if (inherits(cond, "message")) {
[10:19:21.619]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.619]                       if (muffled) 
[10:19:21.619]                         invokeRestart("muffleMessage")
[10:19:21.619]                     }
[10:19:21.619]                     else if (inherits(cond, "warning")) {
[10:19:21.619]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.619]                       if (muffled) 
[10:19:21.619]                         invokeRestart("muffleWarning")
[10:19:21.619]                     }
[10:19:21.619]                     else if (inherits(cond, "condition")) {
[10:19:21.619]                       if (!is.null(pattern)) {
[10:19:21.619]                         computeRestarts <- base::computeRestarts
[10:19:21.619]                         grepl <- base::grepl
[10:19:21.619]                         restarts <- computeRestarts(cond)
[10:19:21.619]                         for (restart in restarts) {
[10:19:21.619]                           name <- restart$name
[10:19:21.619]                           if (is.null(name)) 
[10:19:21.619]                             next
[10:19:21.619]                           if (!grepl(pattern, name)) 
[10:19:21.619]                             next
[10:19:21.619]                           invokeRestart(restart)
[10:19:21.619]                           muffled <- TRUE
[10:19:21.619]                           break
[10:19:21.619]                         }
[10:19:21.619]                       }
[10:19:21.619]                     }
[10:19:21.619]                     invisible(muffled)
[10:19:21.619]                   }
[10:19:21.619]                   muffleCondition(cond)
[10:19:21.619]                 })
[10:19:21.619]             }))
[10:19:21.619]             future::FutureResult(value = ...future.value$value, 
[10:19:21.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.619]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.619]                     ...future.globalenv.names))
[10:19:21.619]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.619]         }, condition = base::local({
[10:19:21.619]             c <- base::c
[10:19:21.619]             inherits <- base::inherits
[10:19:21.619]             invokeRestart <- base::invokeRestart
[10:19:21.619]             length <- base::length
[10:19:21.619]             list <- base::list
[10:19:21.619]             seq.int <- base::seq.int
[10:19:21.619]             signalCondition <- base::signalCondition
[10:19:21.619]             sys.calls <- base::sys.calls
[10:19:21.619]             `[[` <- base::`[[`
[10:19:21.619]             `+` <- base::`+`
[10:19:21.619]             `<<-` <- base::`<<-`
[10:19:21.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.619]                   3L)]
[10:19:21.619]             }
[10:19:21.619]             function(cond) {
[10:19:21.619]                 is_error <- inherits(cond, "error")
[10:19:21.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.619]                   NULL)
[10:19:21.619]                 if (is_error) {
[10:19:21.619]                   sessionInformation <- function() {
[10:19:21.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.619]                       search = base::search(), system = base::Sys.info())
[10:19:21.619]                   }
[10:19:21.619]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.619]                     cond$call), session = sessionInformation(), 
[10:19:21.619]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.619]                   signalCondition(cond)
[10:19:21.619]                 }
[10:19:21.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.619]                 "immediateCondition"))) {
[10:19:21.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.619]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.619]                   if (TRUE && !signal) {
[10:19:21.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.619]                     {
[10:19:21.619]                       inherits <- base::inherits
[10:19:21.619]                       invokeRestart <- base::invokeRestart
[10:19:21.619]                       is.null <- base::is.null
[10:19:21.619]                       muffled <- FALSE
[10:19:21.619]                       if (inherits(cond, "message")) {
[10:19:21.619]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.619]                         if (muffled) 
[10:19:21.619]                           invokeRestart("muffleMessage")
[10:19:21.619]                       }
[10:19:21.619]                       else if (inherits(cond, "warning")) {
[10:19:21.619]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.619]                         if (muffled) 
[10:19:21.619]                           invokeRestart("muffleWarning")
[10:19:21.619]                       }
[10:19:21.619]                       else if (inherits(cond, "condition")) {
[10:19:21.619]                         if (!is.null(pattern)) {
[10:19:21.619]                           computeRestarts <- base::computeRestarts
[10:19:21.619]                           grepl <- base::grepl
[10:19:21.619]                           restarts <- computeRestarts(cond)
[10:19:21.619]                           for (restart in restarts) {
[10:19:21.619]                             name <- restart$name
[10:19:21.619]                             if (is.null(name)) 
[10:19:21.619]                               next
[10:19:21.619]                             if (!grepl(pattern, name)) 
[10:19:21.619]                               next
[10:19:21.619]                             invokeRestart(restart)
[10:19:21.619]                             muffled <- TRUE
[10:19:21.619]                             break
[10:19:21.619]                           }
[10:19:21.619]                         }
[10:19:21.619]                       }
[10:19:21.619]                       invisible(muffled)
[10:19:21.619]                     }
[10:19:21.619]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.619]                   }
[10:19:21.619]                 }
[10:19:21.619]                 else {
[10:19:21.619]                   if (TRUE) {
[10:19:21.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.619]                     {
[10:19:21.619]                       inherits <- base::inherits
[10:19:21.619]                       invokeRestart <- base::invokeRestart
[10:19:21.619]                       is.null <- base::is.null
[10:19:21.619]                       muffled <- FALSE
[10:19:21.619]                       if (inherits(cond, "message")) {
[10:19:21.619]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.619]                         if (muffled) 
[10:19:21.619]                           invokeRestart("muffleMessage")
[10:19:21.619]                       }
[10:19:21.619]                       else if (inherits(cond, "warning")) {
[10:19:21.619]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.619]                         if (muffled) 
[10:19:21.619]                           invokeRestart("muffleWarning")
[10:19:21.619]                       }
[10:19:21.619]                       else if (inherits(cond, "condition")) {
[10:19:21.619]                         if (!is.null(pattern)) {
[10:19:21.619]                           computeRestarts <- base::computeRestarts
[10:19:21.619]                           grepl <- base::grepl
[10:19:21.619]                           restarts <- computeRestarts(cond)
[10:19:21.619]                           for (restart in restarts) {
[10:19:21.619]                             name <- restart$name
[10:19:21.619]                             if (is.null(name)) 
[10:19:21.619]                               next
[10:19:21.619]                             if (!grepl(pattern, name)) 
[10:19:21.619]                               next
[10:19:21.619]                             invokeRestart(restart)
[10:19:21.619]                             muffled <- TRUE
[10:19:21.619]                             break
[10:19:21.619]                           }
[10:19:21.619]                         }
[10:19:21.619]                       }
[10:19:21.619]                       invisible(muffled)
[10:19:21.619]                     }
[10:19:21.619]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.619]                   }
[10:19:21.619]                 }
[10:19:21.619]             }
[10:19:21.619]         }))
[10:19:21.619]     }, error = function(ex) {
[10:19:21.619]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.619]                 ...future.rng), started = ...future.startTime, 
[10:19:21.619]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.619]             version = "1.8"), class = "FutureResult")
[10:19:21.619]     }, finally = {
[10:19:21.619]         if (!identical(...future.workdir, getwd())) 
[10:19:21.619]             setwd(...future.workdir)
[10:19:21.619]         {
[10:19:21.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.619]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.619]             }
[10:19:21.619]             base::options(...future.oldOptions)
[10:19:21.619]             if (.Platform$OS.type == "windows") {
[10:19:21.619]                 old_names <- names(...future.oldEnvVars)
[10:19:21.619]                 envs <- base::Sys.getenv()
[10:19:21.619]                 names <- names(envs)
[10:19:21.619]                 common <- intersect(names, old_names)
[10:19:21.619]                 added <- setdiff(names, old_names)
[10:19:21.619]                 removed <- setdiff(old_names, names)
[10:19:21.619]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.619]                   envs[common]]
[10:19:21.619]                 NAMES <- toupper(changed)
[10:19:21.619]                 args <- list()
[10:19:21.619]                 for (kk in seq_along(NAMES)) {
[10:19:21.619]                   name <- changed[[kk]]
[10:19:21.619]                   NAME <- NAMES[[kk]]
[10:19:21.619]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.619]                     next
[10:19:21.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.619]                 }
[10:19:21.619]                 NAMES <- toupper(added)
[10:19:21.619]                 for (kk in seq_along(NAMES)) {
[10:19:21.619]                   name <- added[[kk]]
[10:19:21.619]                   NAME <- NAMES[[kk]]
[10:19:21.619]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.619]                     next
[10:19:21.619]                   args[[name]] <- ""
[10:19:21.619]                 }
[10:19:21.619]                 NAMES <- toupper(removed)
[10:19:21.619]                 for (kk in seq_along(NAMES)) {
[10:19:21.619]                   name <- removed[[kk]]
[10:19:21.619]                   NAME <- NAMES[[kk]]
[10:19:21.619]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.619]                     next
[10:19:21.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.619]                 }
[10:19:21.619]                 if (length(args) > 0) 
[10:19:21.619]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.619]             }
[10:19:21.619]             else {
[10:19:21.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.619]             }
[10:19:21.619]             {
[10:19:21.619]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.619]                   0L) {
[10:19:21.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.619]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.619]                   base::options(opts)
[10:19:21.619]                 }
[10:19:21.619]                 {
[10:19:21.619]                   {
[10:19:21.619]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.619]                     NULL
[10:19:21.619]                   }
[10:19:21.619]                   options(future.plan = NULL)
[10:19:21.619]                   if (is.na(NA_character_)) 
[10:19:21.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.619]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.619]                     .init = FALSE)
[10:19:21.619]                 }
[10:19:21.619]             }
[10:19:21.619]         }
[10:19:21.619]     })
[10:19:21.619]     if (TRUE) {
[10:19:21.619]         base::sink(type = "output", split = FALSE)
[10:19:21.619]         if (TRUE) {
[10:19:21.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.619]         }
[10:19:21.619]         else {
[10:19:21.619]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.619]         }
[10:19:21.619]         base::close(...future.stdout)
[10:19:21.619]         ...future.stdout <- NULL
[10:19:21.619]     }
[10:19:21.619]     ...future.result$conditions <- ...future.conditions
[10:19:21.619]     ...future.result$finished <- base::Sys.time()
[10:19:21.619]     ...future.result
[10:19:21.619] }
[10:19:21.622] assign_globals() ...
[10:19:21.622] List of 5
[10:19:21.622]  $ ...future.FUN            :function (x, y)  
[10:19:21.622]  $ MoreArgs                 : NULL
[10:19:21.622]  $ ...future.elements_ii    :List of 2
[10:19:21.622]   ..$ :List of 1
[10:19:21.622]   .. ..$ a: num 1
[10:19:21.622]   ..$ :List of 1
[10:19:21.622]   .. ..$ A: num 10
[10:19:21.622]  $ ...future.seeds_ii       : NULL
[10:19:21.622]  $ ...future.globals.maxSize: NULL
[10:19:21.622]  - attr(*, "where")=List of 5
[10:19:21.622]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.622]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.622]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.622]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.622]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.622]  - attr(*, "resolved")= logi FALSE
[10:19:21.622]  - attr(*, "total_size")= num 645
[10:19:21.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.622]  - attr(*, "already-done")= logi TRUE
[10:19:21.627] - reassign environment for ‘...future.FUN’
[10:19:21.627] - copied ‘...future.FUN’ to environment
[10:19:21.627] - copied ‘MoreArgs’ to environment
[10:19:21.627] - copied ‘...future.elements_ii’ to environment
[10:19:21.627] - copied ‘...future.seeds_ii’ to environment
[10:19:21.627] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.628] assign_globals() ... done
[10:19:21.628] requestCore(): workers = 2
[10:19:21.630] MulticoreFuture started
[10:19:21.630] - Launch lazy future ... done
[10:19:21.630] run() for ‘MulticoreFuture’ ... done
[10:19:21.631] Created future:
[10:19:21.631] plan(): Setting new future strategy stack:
[10:19:21.631] List of future strategies:
[10:19:21.631] 1. sequential:
[10:19:21.631]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.631]    - tweaked: FALSE
[10:19:21.631]    - call: NULL
[10:19:21.632] plan(): nbrOfWorkers() = 1
[10:19:21.634] plan(): Setting new future strategy stack:
[10:19:21.634] List of future strategies:
[10:19:21.634] 1. multicore:
[10:19:21.634]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.634]    - tweaked: FALSE
[10:19:21.634]    - call: plan(strategy)
[10:19:21.637] plan(): nbrOfWorkers() = 2
[10:19:21.631] MulticoreFuture:
[10:19:21.631] Label: ‘future_mapply-1’
[10:19:21.631] Expression:
[10:19:21.631] {
[10:19:21.631]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.631]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.631]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.631]         on.exit(options(oopts), add = TRUE)
[10:19:21.631]     }
[10:19:21.631]     {
[10:19:21.631]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.631]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.631]         do.call(mapply, args = args)
[10:19:21.631]     }
[10:19:21.631] }
[10:19:21.631] Lazy evaluation: FALSE
[10:19:21.631] Asynchronous evaluation: TRUE
[10:19:21.631] Local evaluation: TRUE
[10:19:21.631] Environment: R_GlobalEnv
[10:19:21.631] Capture standard output: TRUE
[10:19:21.631] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.631] Globals: 5 objects totaling 645 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.631] Packages: <none>
[10:19:21.631] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.631] Resolved: TRUE
[10:19:21.631] Value: <not collected>
[10:19:21.631] Conditions captured: <none>
[10:19:21.631] Early signaling: FALSE
[10:19:21.631] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.631] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.638] Chunk #1 of 2 ... DONE
[10:19:21.639] Chunk #2 of 2 ...
[10:19:21.639]  - Finding globals in '...' for chunk #2 ...
[10:19:21.639] getGlobalsAndPackages() ...
[10:19:21.639] Searching for globals...
[10:19:21.640] 
[10:19:21.640] Searching for globals ... DONE
[10:19:21.640] - globals: [0] <none>
[10:19:21.640] getGlobalsAndPackages() ... DONE
[10:19:21.640]    + additional globals found: [n=0] 
[10:19:21.640]    + additional namespaces needed: [n=0] 
[10:19:21.640]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:21.641]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.641]  - seeds: <none>
[10:19:21.641]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.645] getGlobalsAndPackages() ...
[10:19:21.645] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.646] Resolving globals: FALSE
[10:19:21.647] The total size of the 5 globals is 695 bytes (695 bytes)
[10:19:21.648] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 695 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.648] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.649] 
[10:19:21.649] getGlobalsAndPackages() ... DONE
[10:19:21.650] run() for ‘Future’ ...
[10:19:21.650] - state: ‘created’
[10:19:21.650] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.654] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.654]   - Field: ‘label’
[10:19:21.654]   - Field: ‘local’
[10:19:21.655]   - Field: ‘owner’
[10:19:21.655]   - Field: ‘envir’
[10:19:21.655]   - Field: ‘workers’
[10:19:21.655]   - Field: ‘packages’
[10:19:21.655]   - Field: ‘gc’
[10:19:21.655]   - Field: ‘job’
[10:19:21.656]   - Field: ‘conditions’
[10:19:21.656]   - Field: ‘expr’
[10:19:21.656]   - Field: ‘uuid’
[10:19:21.656]   - Field: ‘seed’
[10:19:21.656]   - Field: ‘version’
[10:19:21.657]   - Field: ‘result’
[10:19:21.657]   - Field: ‘asynchronous’
[10:19:21.657]   - Field: ‘calls’
[10:19:21.657]   - Field: ‘globals’
[10:19:21.657]   - Field: ‘stdout’
[10:19:21.657]   - Field: ‘earlySignal’
[10:19:21.657]   - Field: ‘lazy’
[10:19:21.658]   - Field: ‘state’
[10:19:21.658] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.658] - Launch lazy future ...
[10:19:21.658] Packages needed by the future expression (n = 0): <none>
[10:19:21.658] Packages needed by future strategies (n = 0): <none>
[10:19:21.659] {
[10:19:21.659]     {
[10:19:21.659]         {
[10:19:21.659]             ...future.startTime <- base::Sys.time()
[10:19:21.659]             {
[10:19:21.659]                 {
[10:19:21.659]                   {
[10:19:21.659]                     {
[10:19:21.659]                       base::local({
[10:19:21.659]                         has_future <- base::requireNamespace("future", 
[10:19:21.659]                           quietly = TRUE)
[10:19:21.659]                         if (has_future) {
[10:19:21.659]                           ns <- base::getNamespace("future")
[10:19:21.659]                           version <- ns[[".package"]][["version"]]
[10:19:21.659]                           if (is.null(version)) 
[10:19:21.659]                             version <- utils::packageVersion("future")
[10:19:21.659]                         }
[10:19:21.659]                         else {
[10:19:21.659]                           version <- NULL
[10:19:21.659]                         }
[10:19:21.659]                         if (!has_future || version < "1.8.0") {
[10:19:21.659]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.659]                             "", base::R.version$version.string), 
[10:19:21.659]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.659]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.659]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.659]                               "release", "version")], collapse = " "), 
[10:19:21.659]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.659]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.659]                             info)
[10:19:21.659]                           info <- base::paste(info, collapse = "; ")
[10:19:21.659]                           if (!has_future) {
[10:19:21.659]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.659]                               info)
[10:19:21.659]                           }
[10:19:21.659]                           else {
[10:19:21.659]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.659]                               info, version)
[10:19:21.659]                           }
[10:19:21.659]                           base::stop(msg)
[10:19:21.659]                         }
[10:19:21.659]                       })
[10:19:21.659]                     }
[10:19:21.659]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.659]                     base::options(mc.cores = 1L)
[10:19:21.659]                   }
[10:19:21.659]                   ...future.strategy.old <- future::plan("list")
[10:19:21.659]                   options(future.plan = NULL)
[10:19:21.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.659]                 }
[10:19:21.659]                 ...future.workdir <- getwd()
[10:19:21.659]             }
[10:19:21.659]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.659]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.659]         }
[10:19:21.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.659]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.659]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.659]             base::names(...future.oldOptions))
[10:19:21.659]     }
[10:19:21.659]     if (FALSE) {
[10:19:21.659]     }
[10:19:21.659]     else {
[10:19:21.659]         if (TRUE) {
[10:19:21.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.659]                 open = "w")
[10:19:21.659]         }
[10:19:21.659]         else {
[10:19:21.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.659]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.659]         }
[10:19:21.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.659]             base::sink(type = "output", split = FALSE)
[10:19:21.659]             base::close(...future.stdout)
[10:19:21.659]         }, add = TRUE)
[10:19:21.659]     }
[10:19:21.659]     ...future.frame <- base::sys.nframe()
[10:19:21.659]     ...future.conditions <- base::list()
[10:19:21.659]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.659]     if (FALSE) {
[10:19:21.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.659]     }
[10:19:21.659]     ...future.result <- base::tryCatch({
[10:19:21.659]         base::withCallingHandlers({
[10:19:21.659]             ...future.value <- base::withVisible(base::local({
[10:19:21.659]                 withCallingHandlers({
[10:19:21.659]                   {
[10:19:21.659]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.659]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.659]                       ...future.globals.maxSize)) {
[10:19:21.659]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.659]                       on.exit(options(oopts), add = TRUE)
[10:19:21.659]                     }
[10:19:21.659]                     {
[10:19:21.659]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.659]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.659]                         USE.NAMES = FALSE)
[10:19:21.659]                       do.call(mapply, args = args)
[10:19:21.659]                     }
[10:19:21.659]                   }
[10:19:21.659]                 }, immediateCondition = function(cond) {
[10:19:21.659]                   save_rds <- function (object, pathname, ...) 
[10:19:21.659]                   {
[10:19:21.659]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.659]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.659]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.659]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.659]                         fi_tmp[["mtime"]])
[10:19:21.659]                     }
[10:19:21.659]                     tryCatch({
[10:19:21.659]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.659]                     }, error = function(ex) {
[10:19:21.659]                       msg <- conditionMessage(ex)
[10:19:21.659]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.659]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.659]                         fi_tmp[["mtime"]], msg)
[10:19:21.659]                       ex$message <- msg
[10:19:21.659]                       stop(ex)
[10:19:21.659]                     })
[10:19:21.659]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.659]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.659]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.659]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.659]                       fi <- file.info(pathname)
[10:19:21.659]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.659]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.659]                         fi[["size"]], fi[["mtime"]])
[10:19:21.659]                       stop(msg)
[10:19:21.659]                     }
[10:19:21.659]                     invisible(pathname)
[10:19:21.659]                   }
[10:19:21.659]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.659]                     rootPath = tempdir()) 
[10:19:21.659]                   {
[10:19:21.659]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.659]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.659]                       tmpdir = path, fileext = ".rds")
[10:19:21.659]                     save_rds(obj, file)
[10:19:21.659]                   }
[10:19:21.659]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.659]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.659]                   {
[10:19:21.659]                     inherits <- base::inherits
[10:19:21.659]                     invokeRestart <- base::invokeRestart
[10:19:21.659]                     is.null <- base::is.null
[10:19:21.659]                     muffled <- FALSE
[10:19:21.659]                     if (inherits(cond, "message")) {
[10:19:21.659]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.659]                       if (muffled) 
[10:19:21.659]                         invokeRestart("muffleMessage")
[10:19:21.659]                     }
[10:19:21.659]                     else if (inherits(cond, "warning")) {
[10:19:21.659]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.659]                       if (muffled) 
[10:19:21.659]                         invokeRestart("muffleWarning")
[10:19:21.659]                     }
[10:19:21.659]                     else if (inherits(cond, "condition")) {
[10:19:21.659]                       if (!is.null(pattern)) {
[10:19:21.659]                         computeRestarts <- base::computeRestarts
[10:19:21.659]                         grepl <- base::grepl
[10:19:21.659]                         restarts <- computeRestarts(cond)
[10:19:21.659]                         for (restart in restarts) {
[10:19:21.659]                           name <- restart$name
[10:19:21.659]                           if (is.null(name)) 
[10:19:21.659]                             next
[10:19:21.659]                           if (!grepl(pattern, name)) 
[10:19:21.659]                             next
[10:19:21.659]                           invokeRestart(restart)
[10:19:21.659]                           muffled <- TRUE
[10:19:21.659]                           break
[10:19:21.659]                         }
[10:19:21.659]                       }
[10:19:21.659]                     }
[10:19:21.659]                     invisible(muffled)
[10:19:21.659]                   }
[10:19:21.659]                   muffleCondition(cond)
[10:19:21.659]                 })
[10:19:21.659]             }))
[10:19:21.659]             future::FutureResult(value = ...future.value$value, 
[10:19:21.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.659]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.659]                     ...future.globalenv.names))
[10:19:21.659]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.659]         }, condition = base::local({
[10:19:21.659]             c <- base::c
[10:19:21.659]             inherits <- base::inherits
[10:19:21.659]             invokeRestart <- base::invokeRestart
[10:19:21.659]             length <- base::length
[10:19:21.659]             list <- base::list
[10:19:21.659]             seq.int <- base::seq.int
[10:19:21.659]             signalCondition <- base::signalCondition
[10:19:21.659]             sys.calls <- base::sys.calls
[10:19:21.659]             `[[` <- base::`[[`
[10:19:21.659]             `+` <- base::`+`
[10:19:21.659]             `<<-` <- base::`<<-`
[10:19:21.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.659]                   3L)]
[10:19:21.659]             }
[10:19:21.659]             function(cond) {
[10:19:21.659]                 is_error <- inherits(cond, "error")
[10:19:21.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.659]                   NULL)
[10:19:21.659]                 if (is_error) {
[10:19:21.659]                   sessionInformation <- function() {
[10:19:21.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.659]                       search = base::search(), system = base::Sys.info())
[10:19:21.659]                   }
[10:19:21.659]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.659]                     cond$call), session = sessionInformation(), 
[10:19:21.659]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.659]                   signalCondition(cond)
[10:19:21.659]                 }
[10:19:21.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.659]                 "immediateCondition"))) {
[10:19:21.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.659]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.659]                   if (TRUE && !signal) {
[10:19:21.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.659]                     {
[10:19:21.659]                       inherits <- base::inherits
[10:19:21.659]                       invokeRestart <- base::invokeRestart
[10:19:21.659]                       is.null <- base::is.null
[10:19:21.659]                       muffled <- FALSE
[10:19:21.659]                       if (inherits(cond, "message")) {
[10:19:21.659]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.659]                         if (muffled) 
[10:19:21.659]                           invokeRestart("muffleMessage")
[10:19:21.659]                       }
[10:19:21.659]                       else if (inherits(cond, "warning")) {
[10:19:21.659]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.659]                         if (muffled) 
[10:19:21.659]                           invokeRestart("muffleWarning")
[10:19:21.659]                       }
[10:19:21.659]                       else if (inherits(cond, "condition")) {
[10:19:21.659]                         if (!is.null(pattern)) {
[10:19:21.659]                           computeRestarts <- base::computeRestarts
[10:19:21.659]                           grepl <- base::grepl
[10:19:21.659]                           restarts <- computeRestarts(cond)
[10:19:21.659]                           for (restart in restarts) {
[10:19:21.659]                             name <- restart$name
[10:19:21.659]                             if (is.null(name)) 
[10:19:21.659]                               next
[10:19:21.659]                             if (!grepl(pattern, name)) 
[10:19:21.659]                               next
[10:19:21.659]                             invokeRestart(restart)
[10:19:21.659]                             muffled <- TRUE
[10:19:21.659]                             break
[10:19:21.659]                           }
[10:19:21.659]                         }
[10:19:21.659]                       }
[10:19:21.659]                       invisible(muffled)
[10:19:21.659]                     }
[10:19:21.659]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.659]                   }
[10:19:21.659]                 }
[10:19:21.659]                 else {
[10:19:21.659]                   if (TRUE) {
[10:19:21.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.659]                     {
[10:19:21.659]                       inherits <- base::inherits
[10:19:21.659]                       invokeRestart <- base::invokeRestart
[10:19:21.659]                       is.null <- base::is.null
[10:19:21.659]                       muffled <- FALSE
[10:19:21.659]                       if (inherits(cond, "message")) {
[10:19:21.659]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.659]                         if (muffled) 
[10:19:21.659]                           invokeRestart("muffleMessage")
[10:19:21.659]                       }
[10:19:21.659]                       else if (inherits(cond, "warning")) {
[10:19:21.659]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.659]                         if (muffled) 
[10:19:21.659]                           invokeRestart("muffleWarning")
[10:19:21.659]                       }
[10:19:21.659]                       else if (inherits(cond, "condition")) {
[10:19:21.659]                         if (!is.null(pattern)) {
[10:19:21.659]                           computeRestarts <- base::computeRestarts
[10:19:21.659]                           grepl <- base::grepl
[10:19:21.659]                           restarts <- computeRestarts(cond)
[10:19:21.659]                           for (restart in restarts) {
[10:19:21.659]                             name <- restart$name
[10:19:21.659]                             if (is.null(name)) 
[10:19:21.659]                               next
[10:19:21.659]                             if (!grepl(pattern, name)) 
[10:19:21.659]                               next
[10:19:21.659]                             invokeRestart(restart)
[10:19:21.659]                             muffled <- TRUE
[10:19:21.659]                             break
[10:19:21.659]                           }
[10:19:21.659]                         }
[10:19:21.659]                       }
[10:19:21.659]                       invisible(muffled)
[10:19:21.659]                     }
[10:19:21.659]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.659]                   }
[10:19:21.659]                 }
[10:19:21.659]             }
[10:19:21.659]         }))
[10:19:21.659]     }, error = function(ex) {
[10:19:21.659]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.659]                 ...future.rng), started = ...future.startTime, 
[10:19:21.659]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.659]             version = "1.8"), class = "FutureResult")
[10:19:21.659]     }, finally = {
[10:19:21.659]         if (!identical(...future.workdir, getwd())) 
[10:19:21.659]             setwd(...future.workdir)
[10:19:21.659]         {
[10:19:21.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.659]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.659]             }
[10:19:21.659]             base::options(...future.oldOptions)
[10:19:21.659]             if (.Platform$OS.type == "windows") {
[10:19:21.659]                 old_names <- names(...future.oldEnvVars)
[10:19:21.659]                 envs <- base::Sys.getenv()
[10:19:21.659]                 names <- names(envs)
[10:19:21.659]                 common <- intersect(names, old_names)
[10:19:21.659]                 added <- setdiff(names, old_names)
[10:19:21.659]                 removed <- setdiff(old_names, names)
[10:19:21.659]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.659]                   envs[common]]
[10:19:21.659]                 NAMES <- toupper(changed)
[10:19:21.659]                 args <- list()
[10:19:21.659]                 for (kk in seq_along(NAMES)) {
[10:19:21.659]                   name <- changed[[kk]]
[10:19:21.659]                   NAME <- NAMES[[kk]]
[10:19:21.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.659]                     next
[10:19:21.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.659]                 }
[10:19:21.659]                 NAMES <- toupper(added)
[10:19:21.659]                 for (kk in seq_along(NAMES)) {
[10:19:21.659]                   name <- added[[kk]]
[10:19:21.659]                   NAME <- NAMES[[kk]]
[10:19:21.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.659]                     next
[10:19:21.659]                   args[[name]] <- ""
[10:19:21.659]                 }
[10:19:21.659]                 NAMES <- toupper(removed)
[10:19:21.659]                 for (kk in seq_along(NAMES)) {
[10:19:21.659]                   name <- removed[[kk]]
[10:19:21.659]                   NAME <- NAMES[[kk]]
[10:19:21.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.659]                     next
[10:19:21.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.659]                 }
[10:19:21.659]                 if (length(args) > 0) 
[10:19:21.659]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.659]             }
[10:19:21.659]             else {
[10:19:21.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.659]             }
[10:19:21.659]             {
[10:19:21.659]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.659]                   0L) {
[10:19:21.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.659]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.659]                   base::options(opts)
[10:19:21.659]                 }
[10:19:21.659]                 {
[10:19:21.659]                   {
[10:19:21.659]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.659]                     NULL
[10:19:21.659]                   }
[10:19:21.659]                   options(future.plan = NULL)
[10:19:21.659]                   if (is.na(NA_character_)) 
[10:19:21.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.659]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.659]                     .init = FALSE)
[10:19:21.659]                 }
[10:19:21.659]             }
[10:19:21.659]         }
[10:19:21.659]     })
[10:19:21.659]     if (TRUE) {
[10:19:21.659]         base::sink(type = "output", split = FALSE)
[10:19:21.659]         if (TRUE) {
[10:19:21.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.659]         }
[10:19:21.659]         else {
[10:19:21.659]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.659]         }
[10:19:21.659]         base::close(...future.stdout)
[10:19:21.659]         ...future.stdout <- NULL
[10:19:21.659]     }
[10:19:21.659]     ...future.result$conditions <- ...future.conditions
[10:19:21.659]     ...future.result$finished <- base::Sys.time()
[10:19:21.659]     ...future.result
[10:19:21.659] }
[10:19:21.662] assign_globals() ...
[10:19:21.662] List of 5
[10:19:21.662]  $ ...future.FUN            :function (x, y)  
[10:19:21.662]  $ MoreArgs                 : NULL
[10:19:21.662]  $ ...future.elements_ii    :List of 2
[10:19:21.662]   ..$ :List of 2
[10:19:21.662]   .. ..$ b: num 2
[10:19:21.662]   .. ..$ c: num 3
[10:19:21.662]   ..$ :List of 2
[10:19:21.662]   .. ..$ B: num 0
[10:19:21.662]   .. ..$ C: num -10
[10:19:21.662]  $ ...future.seeds_ii       : NULL
[10:19:21.662]  $ ...future.globals.maxSize: NULL
[10:19:21.662]  - attr(*, "where")=List of 5
[10:19:21.662]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.662]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.662]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.662]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.662]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.662]  - attr(*, "resolved")= logi FALSE
[10:19:21.662]  - attr(*, "total_size")= num 695
[10:19:21.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.662]  - attr(*, "already-done")= logi TRUE
[10:19:21.669] - reassign environment for ‘...future.FUN’
[10:19:21.669] - copied ‘...future.FUN’ to environment
[10:19:21.670] - copied ‘MoreArgs’ to environment
[10:19:21.670] - copied ‘...future.elements_ii’ to environment
[10:19:21.670] - copied ‘...future.seeds_ii’ to environment
[10:19:21.670] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.670] assign_globals() ... done
[10:19:21.670] requestCore(): workers = 2
[10:19:21.673] MulticoreFuture started
[10:19:21.673] - Launch lazy future ... done
[10:19:21.673] run() for ‘MulticoreFuture’ ... done
[10:19:21.673] Created future:
[10:19:21.674] plan(): Setting new future strategy stack:
[10:19:21.674] List of future strategies:
[10:19:21.674] 1. sequential:
[10:19:21.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.674]    - tweaked: FALSE
[10:19:21.674]    - call: NULL
[10:19:21.675] plan(): nbrOfWorkers() = 1
[10:19:21.677] plan(): Setting new future strategy stack:
[10:19:21.677] List of future strategies:
[10:19:21.677] 1. multicore:
[10:19:21.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.677]    - tweaked: FALSE
[10:19:21.677]    - call: plan(strategy)
[10:19:21.680] plan(): nbrOfWorkers() = 2
[10:19:21.674] MulticoreFuture:
[10:19:21.674] Label: ‘future_mapply-2’
[10:19:21.674] Expression:
[10:19:21.674] {
[10:19:21.674]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.674]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.674]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.674]         on.exit(options(oopts), add = TRUE)
[10:19:21.674]     }
[10:19:21.674]     {
[10:19:21.674]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.674]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.674]         do.call(mapply, args = args)
[10:19:21.674]     }
[10:19:21.674] }
[10:19:21.674] Lazy evaluation: FALSE
[10:19:21.674] Asynchronous evaluation: TRUE
[10:19:21.674] Local evaluation: TRUE
[10:19:21.674] Environment: R_GlobalEnv
[10:19:21.674] Capture standard output: TRUE
[10:19:21.674] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.674] Globals: 5 objects totaling 695 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.674] Packages: <none>
[10:19:21.674] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.674] Resolved: TRUE
[10:19:21.674] Value: <not collected>
[10:19:21.674] Conditions captured: <none>
[10:19:21.674] Early signaling: FALSE
[10:19:21.674] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.674] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.682] Chunk #2 of 2 ... DONE
[10:19:21.682] Launching 2 futures (chunks) ... DONE
[10:19:21.682] Resolving 2 futures (chunks) ...
[10:19:21.682] resolve() on list ...
[10:19:21.682]  recursive: 0
[10:19:21.682]  length: 2
[10:19:21.683] 
[10:19:21.683] Future #1
[10:19:21.683] result() for MulticoreFuture ...
[10:19:21.684] result() for MulticoreFuture ...
[10:19:21.684] result() for MulticoreFuture ... done
[10:19:21.684] result() for MulticoreFuture ... done
[10:19:21.684] result() for MulticoreFuture ...
[10:19:21.685] result() for MulticoreFuture ... done
[10:19:21.685] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:21.685] - nx: 2
[10:19:21.685] - relay: TRUE
[10:19:21.685] - stdout: TRUE
[10:19:21.685] - signal: TRUE
[10:19:21.685] - resignal: FALSE
[10:19:21.685] - force: TRUE
[10:19:21.686] - relayed: [n=2] FALSE, FALSE
[10:19:21.686] - queued futures: [n=2] FALSE, FALSE
[10:19:21.686]  - until=1
[10:19:21.686]  - relaying element #1
[10:19:21.686] result() for MulticoreFuture ...
[10:19:21.686] result() for MulticoreFuture ... done
[10:19:21.686] result() for MulticoreFuture ...
[10:19:21.687] result() for MulticoreFuture ... done
[10:19:21.687] result() for MulticoreFuture ...
[10:19:21.687] result() for MulticoreFuture ... done
[10:19:21.687] result() for MulticoreFuture ...
[10:19:21.687] result() for MulticoreFuture ... done
[10:19:21.687] - relayed: [n=2] TRUE, FALSE
[10:19:21.687] - queued futures: [n=2] TRUE, FALSE
[10:19:21.688] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:21.688]  length: 1 (resolved future 1)
[10:19:21.692] Future #2
[10:19:21.692] result() for MulticoreFuture ...
[10:19:21.693] result() for MulticoreFuture ...
[10:19:21.694] result() for MulticoreFuture ... done
[10:19:21.694] result() for MulticoreFuture ... done
[10:19:21.694] result() for MulticoreFuture ...
[10:19:21.694] result() for MulticoreFuture ... done
[10:19:21.695] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:21.695] - nx: 2
[10:19:21.695] - relay: TRUE
[10:19:21.695] - stdout: TRUE
[10:19:21.695] - signal: TRUE
[10:19:21.696] - resignal: FALSE
[10:19:21.696] - force: TRUE
[10:19:21.696] - relayed: [n=2] TRUE, FALSE
[10:19:21.696] - queued futures: [n=2] TRUE, FALSE
[10:19:21.696]  - until=2
[10:19:21.696]  - relaying element #2
[10:19:21.697] result() for MulticoreFuture ...
[10:19:21.697] result() for MulticoreFuture ... done
[10:19:21.697] result() for MulticoreFuture ...
[10:19:21.697] result() for MulticoreFuture ... done
[10:19:21.697] result() for MulticoreFuture ...
[10:19:21.697] result() for MulticoreFuture ... done
[10:19:21.698] result() for MulticoreFuture ...
[10:19:21.698] result() for MulticoreFuture ... done
[10:19:21.698] - relayed: [n=2] TRUE, TRUE
[10:19:21.698] - queued futures: [n=2] TRUE, TRUE
[10:19:21.698] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:21.698]  length: 0 (resolved future 2)
[10:19:21.698] Relaying remaining futures
[10:19:21.699] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.699] - nx: 2
[10:19:21.699] - relay: TRUE
[10:19:21.699] - stdout: TRUE
[10:19:21.699] - signal: TRUE
[10:19:21.699] - resignal: FALSE
[10:19:21.699] - force: TRUE
[10:19:21.699] - relayed: [n=2] TRUE, TRUE
[10:19:21.699] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:21.700] - relayed: [n=2] TRUE, TRUE
[10:19:21.700] - queued futures: [n=2] TRUE, TRUE
[10:19:21.700] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.700] resolve() on list ... DONE
[10:19:21.700] result() for MulticoreFuture ...
[10:19:21.700] result() for MulticoreFuture ... done
[10:19:21.700] result() for MulticoreFuture ...
[10:19:21.700] result() for MulticoreFuture ... done
[10:19:21.700] result() for MulticoreFuture ...
[10:19:21.701] result() for MulticoreFuture ... done
[10:19:21.701] result() for MulticoreFuture ...
[10:19:21.701] result() for MulticoreFuture ... done
[10:19:21.701]  - Number of value chunks collected: 2
[10:19:21.701] Resolving 2 futures (chunks) ... DONE
[10:19:21.701] Reducing values from 2 chunks ...
[10:19:21.701]  - Number of values collected after concatenation: 3
[10:19:21.701]  - Number of values expected: 3
[10:19:21.701] Reducing values from 2 chunks ... DONE
[10:19:21.702] future_mapply() ... DONE
- future_.mapply()
[10:19:21.702] future_mapply() ...
[10:19:21.704] Number of chunks: 2
[10:19:21.704] getGlobalsAndPackagesXApply() ...
[10:19:21.704]  - future.globals: TRUE
[10:19:21.704] getGlobalsAndPackages() ...
[10:19:21.705] Searching for globals...
[10:19:21.706] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:19:21.706] Searching for globals ... DONE
[10:19:21.706] Resolving globals: FALSE
[10:19:21.707] The total size of the 1 globals is 414 bytes (414 bytes)
[10:19:21.707] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:19:21.707] - globals: [1] ‘FUN’
[10:19:21.707] 
[10:19:21.707] getGlobalsAndPackages() ... DONE
[10:19:21.707]  - globals found/used: [n=1] ‘FUN’
[10:19:21.708]  - needed namespaces: [n=0] 
[10:19:21.708] Finding globals ... DONE
[10:19:21.708] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.708] List of 2
[10:19:21.708]  $ ...future.FUN:function (x, y)  
[10:19:21.708]  $ MoreArgs     : list()
[10:19:21.708]  - attr(*, "where")=List of 2
[10:19:21.708]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.708]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.708]  - attr(*, "resolved")= logi FALSE
[10:19:21.708]  - attr(*, "total_size")= num NA
[10:19:21.711] Packages to be attached in all futures: [n=0] 
[10:19:21.711] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.711] Number of futures (= number of chunks): 2
[10:19:21.711] Launching 2 futures (chunks) ...
[10:19:21.711] Chunk #1 of 2 ...
[10:19:21.711]  - Finding globals in '...' for chunk #1 ...
[10:19:21.712] getGlobalsAndPackages() ...
[10:19:21.712] Searching for globals...
[10:19:21.712] 
[10:19:21.712] Searching for globals ... DONE
[10:19:21.712] - globals: [0] <none>
[10:19:21.712] getGlobalsAndPackages() ... DONE
[10:19:21.712]    + additional globals found: [n=0] 
[10:19:21.712]    + additional namespaces needed: [n=0] 
[10:19:21.713]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.713]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.713]  - seeds: <none>
[10:19:21.713]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.713] getGlobalsAndPackages() ...
[10:19:21.713] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.713] Resolving globals: FALSE
[10:19:21.713] The total size of the 5 globals is 649 bytes (649 bytes)
[10:19:21.714] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 649 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:21.714] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.714] 
[10:19:21.714] getGlobalsAndPackages() ... DONE
[10:19:21.715] run() for ‘Future’ ...
[10:19:21.715] - state: ‘created’
[10:19:21.715] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.716] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.717]   - Field: ‘label’
[10:19:21.717]   - Field: ‘local’
[10:19:21.717]   - Field: ‘owner’
[10:19:21.719]   - Field: ‘envir’
[10:19:21.719]   - Field: ‘workers’
[10:19:21.719]   - Field: ‘packages’
[10:19:21.719]   - Field: ‘gc’
[10:19:21.719]   - Field: ‘job’
[10:19:21.719]   - Field: ‘conditions’
[10:19:21.719]   - Field: ‘expr’
[10:19:21.719]   - Field: ‘uuid’
[10:19:21.720]   - Field: ‘seed’
[10:19:21.720]   - Field: ‘version’
[10:19:21.720]   - Field: ‘result’
[10:19:21.720]   - Field: ‘asynchronous’
[10:19:21.720]   - Field: ‘calls’
[10:19:21.720]   - Field: ‘globals’
[10:19:21.720]   - Field: ‘stdout’
[10:19:21.720]   - Field: ‘earlySignal’
[10:19:21.720]   - Field: ‘lazy’
[10:19:21.720]   - Field: ‘state’
[10:19:21.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.721] - Launch lazy future ...
[10:19:21.721] Packages needed by the future expression (n = 0): <none>
[10:19:21.721] Packages needed by future strategies (n = 0): <none>
[10:19:21.722] {
[10:19:21.722]     {
[10:19:21.722]         {
[10:19:21.722]             ...future.startTime <- base::Sys.time()
[10:19:21.722]             {
[10:19:21.722]                 {
[10:19:21.722]                   {
[10:19:21.722]                     {
[10:19:21.722]                       base::local({
[10:19:21.722]                         has_future <- base::requireNamespace("future", 
[10:19:21.722]                           quietly = TRUE)
[10:19:21.722]                         if (has_future) {
[10:19:21.722]                           ns <- base::getNamespace("future")
[10:19:21.722]                           version <- ns[[".package"]][["version"]]
[10:19:21.722]                           if (is.null(version)) 
[10:19:21.722]                             version <- utils::packageVersion("future")
[10:19:21.722]                         }
[10:19:21.722]                         else {
[10:19:21.722]                           version <- NULL
[10:19:21.722]                         }
[10:19:21.722]                         if (!has_future || version < "1.8.0") {
[10:19:21.722]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.722]                             "", base::R.version$version.string), 
[10:19:21.722]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.722]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.722]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.722]                               "release", "version")], collapse = " "), 
[10:19:21.722]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.722]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.722]                             info)
[10:19:21.722]                           info <- base::paste(info, collapse = "; ")
[10:19:21.722]                           if (!has_future) {
[10:19:21.722]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.722]                               info)
[10:19:21.722]                           }
[10:19:21.722]                           else {
[10:19:21.722]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.722]                               info, version)
[10:19:21.722]                           }
[10:19:21.722]                           base::stop(msg)
[10:19:21.722]                         }
[10:19:21.722]                       })
[10:19:21.722]                     }
[10:19:21.722]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.722]                     base::options(mc.cores = 1L)
[10:19:21.722]                   }
[10:19:21.722]                   ...future.strategy.old <- future::plan("list")
[10:19:21.722]                   options(future.plan = NULL)
[10:19:21.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.722]                 }
[10:19:21.722]                 ...future.workdir <- getwd()
[10:19:21.722]             }
[10:19:21.722]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.722]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.722]         }
[10:19:21.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.722]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.722]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.722]             base::names(...future.oldOptions))
[10:19:21.722]     }
[10:19:21.722]     if (FALSE) {
[10:19:21.722]     }
[10:19:21.722]     else {
[10:19:21.722]         if (TRUE) {
[10:19:21.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.722]                 open = "w")
[10:19:21.722]         }
[10:19:21.722]         else {
[10:19:21.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.722]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.722]         }
[10:19:21.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.722]             base::sink(type = "output", split = FALSE)
[10:19:21.722]             base::close(...future.stdout)
[10:19:21.722]         }, add = TRUE)
[10:19:21.722]     }
[10:19:21.722]     ...future.frame <- base::sys.nframe()
[10:19:21.722]     ...future.conditions <- base::list()
[10:19:21.722]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.722]     if (FALSE) {
[10:19:21.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.722]     }
[10:19:21.722]     ...future.result <- base::tryCatch({
[10:19:21.722]         base::withCallingHandlers({
[10:19:21.722]             ...future.value <- base::withVisible(base::local({
[10:19:21.722]                 withCallingHandlers({
[10:19:21.722]                   {
[10:19:21.722]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.722]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.722]                       ...future.globals.maxSize)) {
[10:19:21.722]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.722]                       on.exit(options(oopts), add = TRUE)
[10:19:21.722]                     }
[10:19:21.722]                     {
[10:19:21.722]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.722]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.722]                         USE.NAMES = FALSE)
[10:19:21.722]                       do.call(mapply, args = args)
[10:19:21.722]                     }
[10:19:21.722]                   }
[10:19:21.722]                 }, immediateCondition = function(cond) {
[10:19:21.722]                   save_rds <- function (object, pathname, ...) 
[10:19:21.722]                   {
[10:19:21.722]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.722]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.722]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.722]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.722]                         fi_tmp[["mtime"]])
[10:19:21.722]                     }
[10:19:21.722]                     tryCatch({
[10:19:21.722]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.722]                     }, error = function(ex) {
[10:19:21.722]                       msg <- conditionMessage(ex)
[10:19:21.722]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.722]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.722]                         fi_tmp[["mtime"]], msg)
[10:19:21.722]                       ex$message <- msg
[10:19:21.722]                       stop(ex)
[10:19:21.722]                     })
[10:19:21.722]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.722]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.722]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.722]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.722]                       fi <- file.info(pathname)
[10:19:21.722]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.722]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.722]                         fi[["size"]], fi[["mtime"]])
[10:19:21.722]                       stop(msg)
[10:19:21.722]                     }
[10:19:21.722]                     invisible(pathname)
[10:19:21.722]                   }
[10:19:21.722]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.722]                     rootPath = tempdir()) 
[10:19:21.722]                   {
[10:19:21.722]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.722]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.722]                       tmpdir = path, fileext = ".rds")
[10:19:21.722]                     save_rds(obj, file)
[10:19:21.722]                   }
[10:19:21.722]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.722]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.722]                   {
[10:19:21.722]                     inherits <- base::inherits
[10:19:21.722]                     invokeRestart <- base::invokeRestart
[10:19:21.722]                     is.null <- base::is.null
[10:19:21.722]                     muffled <- FALSE
[10:19:21.722]                     if (inherits(cond, "message")) {
[10:19:21.722]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.722]                       if (muffled) 
[10:19:21.722]                         invokeRestart("muffleMessage")
[10:19:21.722]                     }
[10:19:21.722]                     else if (inherits(cond, "warning")) {
[10:19:21.722]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.722]                       if (muffled) 
[10:19:21.722]                         invokeRestart("muffleWarning")
[10:19:21.722]                     }
[10:19:21.722]                     else if (inherits(cond, "condition")) {
[10:19:21.722]                       if (!is.null(pattern)) {
[10:19:21.722]                         computeRestarts <- base::computeRestarts
[10:19:21.722]                         grepl <- base::grepl
[10:19:21.722]                         restarts <- computeRestarts(cond)
[10:19:21.722]                         for (restart in restarts) {
[10:19:21.722]                           name <- restart$name
[10:19:21.722]                           if (is.null(name)) 
[10:19:21.722]                             next
[10:19:21.722]                           if (!grepl(pattern, name)) 
[10:19:21.722]                             next
[10:19:21.722]                           invokeRestart(restart)
[10:19:21.722]                           muffled <- TRUE
[10:19:21.722]                           break
[10:19:21.722]                         }
[10:19:21.722]                       }
[10:19:21.722]                     }
[10:19:21.722]                     invisible(muffled)
[10:19:21.722]                   }
[10:19:21.722]                   muffleCondition(cond)
[10:19:21.722]                 })
[10:19:21.722]             }))
[10:19:21.722]             future::FutureResult(value = ...future.value$value, 
[10:19:21.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.722]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.722]                     ...future.globalenv.names))
[10:19:21.722]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.722]         }, condition = base::local({
[10:19:21.722]             c <- base::c
[10:19:21.722]             inherits <- base::inherits
[10:19:21.722]             invokeRestart <- base::invokeRestart
[10:19:21.722]             length <- base::length
[10:19:21.722]             list <- base::list
[10:19:21.722]             seq.int <- base::seq.int
[10:19:21.722]             signalCondition <- base::signalCondition
[10:19:21.722]             sys.calls <- base::sys.calls
[10:19:21.722]             `[[` <- base::`[[`
[10:19:21.722]             `+` <- base::`+`
[10:19:21.722]             `<<-` <- base::`<<-`
[10:19:21.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.722]                   3L)]
[10:19:21.722]             }
[10:19:21.722]             function(cond) {
[10:19:21.722]                 is_error <- inherits(cond, "error")
[10:19:21.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.722]                   NULL)
[10:19:21.722]                 if (is_error) {
[10:19:21.722]                   sessionInformation <- function() {
[10:19:21.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.722]                       search = base::search(), system = base::Sys.info())
[10:19:21.722]                   }
[10:19:21.722]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.722]                     cond$call), session = sessionInformation(), 
[10:19:21.722]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.722]                   signalCondition(cond)
[10:19:21.722]                 }
[10:19:21.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.722]                 "immediateCondition"))) {
[10:19:21.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.722]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.722]                   if (TRUE && !signal) {
[10:19:21.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.722]                     {
[10:19:21.722]                       inherits <- base::inherits
[10:19:21.722]                       invokeRestart <- base::invokeRestart
[10:19:21.722]                       is.null <- base::is.null
[10:19:21.722]                       muffled <- FALSE
[10:19:21.722]                       if (inherits(cond, "message")) {
[10:19:21.722]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.722]                         if (muffled) 
[10:19:21.722]                           invokeRestart("muffleMessage")
[10:19:21.722]                       }
[10:19:21.722]                       else if (inherits(cond, "warning")) {
[10:19:21.722]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.722]                         if (muffled) 
[10:19:21.722]                           invokeRestart("muffleWarning")
[10:19:21.722]                       }
[10:19:21.722]                       else if (inherits(cond, "condition")) {
[10:19:21.722]                         if (!is.null(pattern)) {
[10:19:21.722]                           computeRestarts <- base::computeRestarts
[10:19:21.722]                           grepl <- base::grepl
[10:19:21.722]                           restarts <- computeRestarts(cond)
[10:19:21.722]                           for (restart in restarts) {
[10:19:21.722]                             name <- restart$name
[10:19:21.722]                             if (is.null(name)) 
[10:19:21.722]                               next
[10:19:21.722]                             if (!grepl(pattern, name)) 
[10:19:21.722]                               next
[10:19:21.722]                             invokeRestart(restart)
[10:19:21.722]                             muffled <- TRUE
[10:19:21.722]                             break
[10:19:21.722]                           }
[10:19:21.722]                         }
[10:19:21.722]                       }
[10:19:21.722]                       invisible(muffled)
[10:19:21.722]                     }
[10:19:21.722]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.722]                   }
[10:19:21.722]                 }
[10:19:21.722]                 else {
[10:19:21.722]                   if (TRUE) {
[10:19:21.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.722]                     {
[10:19:21.722]                       inherits <- base::inherits
[10:19:21.722]                       invokeRestart <- base::invokeRestart
[10:19:21.722]                       is.null <- base::is.null
[10:19:21.722]                       muffled <- FALSE
[10:19:21.722]                       if (inherits(cond, "message")) {
[10:19:21.722]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.722]                         if (muffled) 
[10:19:21.722]                           invokeRestart("muffleMessage")
[10:19:21.722]                       }
[10:19:21.722]                       else if (inherits(cond, "warning")) {
[10:19:21.722]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.722]                         if (muffled) 
[10:19:21.722]                           invokeRestart("muffleWarning")
[10:19:21.722]                       }
[10:19:21.722]                       else if (inherits(cond, "condition")) {
[10:19:21.722]                         if (!is.null(pattern)) {
[10:19:21.722]                           computeRestarts <- base::computeRestarts
[10:19:21.722]                           grepl <- base::grepl
[10:19:21.722]                           restarts <- computeRestarts(cond)
[10:19:21.722]                           for (restart in restarts) {
[10:19:21.722]                             name <- restart$name
[10:19:21.722]                             if (is.null(name)) 
[10:19:21.722]                               next
[10:19:21.722]                             if (!grepl(pattern, name)) 
[10:19:21.722]                               next
[10:19:21.722]                             invokeRestart(restart)
[10:19:21.722]                             muffled <- TRUE
[10:19:21.722]                             break
[10:19:21.722]                           }
[10:19:21.722]                         }
[10:19:21.722]                       }
[10:19:21.722]                       invisible(muffled)
[10:19:21.722]                     }
[10:19:21.722]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.722]                   }
[10:19:21.722]                 }
[10:19:21.722]             }
[10:19:21.722]         }))
[10:19:21.722]     }, error = function(ex) {
[10:19:21.722]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.722]                 ...future.rng), started = ...future.startTime, 
[10:19:21.722]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.722]             version = "1.8"), class = "FutureResult")
[10:19:21.722]     }, finally = {
[10:19:21.722]         if (!identical(...future.workdir, getwd())) 
[10:19:21.722]             setwd(...future.workdir)
[10:19:21.722]         {
[10:19:21.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.722]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.722]             }
[10:19:21.722]             base::options(...future.oldOptions)
[10:19:21.722]             if (.Platform$OS.type == "windows") {
[10:19:21.722]                 old_names <- names(...future.oldEnvVars)
[10:19:21.722]                 envs <- base::Sys.getenv()
[10:19:21.722]                 names <- names(envs)
[10:19:21.722]                 common <- intersect(names, old_names)
[10:19:21.722]                 added <- setdiff(names, old_names)
[10:19:21.722]                 removed <- setdiff(old_names, names)
[10:19:21.722]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.722]                   envs[common]]
[10:19:21.722]                 NAMES <- toupper(changed)
[10:19:21.722]                 args <- list()
[10:19:21.722]                 for (kk in seq_along(NAMES)) {
[10:19:21.722]                   name <- changed[[kk]]
[10:19:21.722]                   NAME <- NAMES[[kk]]
[10:19:21.722]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.722]                     next
[10:19:21.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.722]                 }
[10:19:21.722]                 NAMES <- toupper(added)
[10:19:21.722]                 for (kk in seq_along(NAMES)) {
[10:19:21.722]                   name <- added[[kk]]
[10:19:21.722]                   NAME <- NAMES[[kk]]
[10:19:21.722]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.722]                     next
[10:19:21.722]                   args[[name]] <- ""
[10:19:21.722]                 }
[10:19:21.722]                 NAMES <- toupper(removed)
[10:19:21.722]                 for (kk in seq_along(NAMES)) {
[10:19:21.722]                   name <- removed[[kk]]
[10:19:21.722]                   NAME <- NAMES[[kk]]
[10:19:21.722]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.722]                     next
[10:19:21.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.722]                 }
[10:19:21.722]                 if (length(args) > 0) 
[10:19:21.722]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.722]             }
[10:19:21.722]             else {
[10:19:21.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.722]             }
[10:19:21.722]             {
[10:19:21.722]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.722]                   0L) {
[10:19:21.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.722]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.722]                   base::options(opts)
[10:19:21.722]                 }
[10:19:21.722]                 {
[10:19:21.722]                   {
[10:19:21.722]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.722]                     NULL
[10:19:21.722]                   }
[10:19:21.722]                   options(future.plan = NULL)
[10:19:21.722]                   if (is.na(NA_character_)) 
[10:19:21.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.722]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.722]                     .init = FALSE)
[10:19:21.722]                 }
[10:19:21.722]             }
[10:19:21.722]         }
[10:19:21.722]     })
[10:19:21.722]     if (TRUE) {
[10:19:21.722]         base::sink(type = "output", split = FALSE)
[10:19:21.722]         if (TRUE) {
[10:19:21.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.722]         }
[10:19:21.722]         else {
[10:19:21.722]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.722]         }
[10:19:21.722]         base::close(...future.stdout)
[10:19:21.722]         ...future.stdout <- NULL
[10:19:21.722]     }
[10:19:21.722]     ...future.result$conditions <- ...future.conditions
[10:19:21.722]     ...future.result$finished <- base::Sys.time()
[10:19:21.722]     ...future.result
[10:19:21.722] }
[10:19:21.724] assign_globals() ...
[10:19:21.724] List of 5
[10:19:21.724]  $ ...future.FUN            :function (x, y)  
[10:19:21.724]  $ MoreArgs                 : list()
[10:19:21.724]  $ ...future.elements_ii    :List of 2
[10:19:21.724]   ..$ :List of 1
[10:19:21.724]   .. ..$ a: num 1
[10:19:21.724]   ..$ :List of 1
[10:19:21.724]   .. ..$ A: num 10
[10:19:21.724]  $ ...future.seeds_ii       : NULL
[10:19:21.724]  $ ...future.globals.maxSize: NULL
[10:19:21.724]  - attr(*, "where")=List of 5
[10:19:21.724]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.724]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.724]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.724]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.724]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.724]  - attr(*, "resolved")= logi FALSE
[10:19:21.724]  - attr(*, "total_size")= num 649
[10:19:21.724]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.724]  - attr(*, "already-done")= logi TRUE
[10:19:21.729] - reassign environment for ‘...future.FUN’
[10:19:21.729] - copied ‘...future.FUN’ to environment
[10:19:21.729] - copied ‘MoreArgs’ to environment
[10:19:21.729] - copied ‘...future.elements_ii’ to environment
[10:19:21.729] - copied ‘...future.seeds_ii’ to environment
[10:19:21.730] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.730] assign_globals() ... done
[10:19:21.730] requestCore(): workers = 2
[10:19:21.732] MulticoreFuture started
[10:19:21.732] - Launch lazy future ... done
[10:19:21.732] run() for ‘MulticoreFuture’ ... done
[10:19:21.733] Created future:
[10:19:21.733] plan(): Setting new future strategy stack:
[10:19:21.733] List of future strategies:
[10:19:21.733] 1. sequential:
[10:19:21.733]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.733]    - tweaked: FALSE
[10:19:21.733]    - call: NULL
[10:19:21.734] plan(): nbrOfWorkers() = 1
[10:19:21.736] plan(): Setting new future strategy stack:
[10:19:21.736] List of future strategies:
[10:19:21.736] 1. multicore:
[10:19:21.736]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.736]    - tweaked: FALSE
[10:19:21.736]    - call: plan(strategy)
[10:19:21.739] plan(): nbrOfWorkers() = 2
[10:19:21.733] MulticoreFuture:
[10:19:21.733] Label: ‘future_.mapply-1’
[10:19:21.733] Expression:
[10:19:21.733] {
[10:19:21.733]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.733]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.733]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.733]         on.exit(options(oopts), add = TRUE)
[10:19:21.733]     }
[10:19:21.733]     {
[10:19:21.733]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.733]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.733]         do.call(mapply, args = args)
[10:19:21.733]     }
[10:19:21.733] }
[10:19:21.733] Lazy evaluation: FALSE
[10:19:21.733] Asynchronous evaluation: TRUE
[10:19:21.733] Local evaluation: TRUE
[10:19:21.733] Environment: R_GlobalEnv
[10:19:21.733] Capture standard output: TRUE
[10:19:21.733] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.733] Globals: 5 objects totaling 649 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.733] Packages: <none>
[10:19:21.733] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.733] Resolved: TRUE
[10:19:21.733] Value: <not collected>
[10:19:21.733] Conditions captured: <none>
[10:19:21.733] Early signaling: FALSE
[10:19:21.733] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.733] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.740] Chunk #1 of 2 ... DONE
[10:19:21.741] Chunk #2 of 2 ...
[10:19:21.741]  - Finding globals in '...' for chunk #2 ...
[10:19:21.741] getGlobalsAndPackages() ...
[10:19:21.741] Searching for globals...
[10:19:21.742] 
[10:19:21.742] Searching for globals ... DONE
[10:19:21.742] - globals: [0] <none>
[10:19:21.742] getGlobalsAndPackages() ... DONE
[10:19:21.742]    + additional globals found: [n=0] 
[10:19:21.742]    + additional namespaces needed: [n=0] 
[10:19:21.742]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:21.742]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:21.743]  - seeds: <none>
[10:19:21.743]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.743] getGlobalsAndPackages() ...
[10:19:21.743] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.743] Resolving globals: FALSE
[10:19:21.744] The total size of the 5 globals is 699 bytes (699 bytes)
[10:19:21.745] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 699 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:21.745] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.745] 
[10:19:21.745] getGlobalsAndPackages() ... DONE
[10:19:21.746] run() for ‘Future’ ...
[10:19:21.746] - state: ‘created’
[10:19:21.746] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.749] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.749]   - Field: ‘label’
[10:19:21.750]   - Field: ‘local’
[10:19:21.750]   - Field: ‘owner’
[10:19:21.750]   - Field: ‘envir’
[10:19:21.750]   - Field: ‘workers’
[10:19:21.750]   - Field: ‘packages’
[10:19:21.750]   - Field: ‘gc’
[10:19:21.750]   - Field: ‘job’
[10:19:21.750]   - Field: ‘conditions’
[10:19:21.751]   - Field: ‘expr’
[10:19:21.751]   - Field: ‘uuid’
[10:19:21.751]   - Field: ‘seed’
[10:19:21.751]   - Field: ‘version’
[10:19:21.751]   - Field: ‘result’
[10:19:21.751]   - Field: ‘asynchronous’
[10:19:21.751]   - Field: ‘calls’
[10:19:21.752]   - Field: ‘globals’
[10:19:21.752]   - Field: ‘stdout’
[10:19:21.752]   - Field: ‘earlySignal’
[10:19:21.752]   - Field: ‘lazy’
[10:19:21.752]   - Field: ‘state’
[10:19:21.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.752] - Launch lazy future ...
[10:19:21.753] Packages needed by the future expression (n = 0): <none>
[10:19:21.753] Packages needed by future strategies (n = 0): <none>
[10:19:21.754] {
[10:19:21.754]     {
[10:19:21.754]         {
[10:19:21.754]             ...future.startTime <- base::Sys.time()
[10:19:21.754]             {
[10:19:21.754]                 {
[10:19:21.754]                   {
[10:19:21.754]                     {
[10:19:21.754]                       base::local({
[10:19:21.754]                         has_future <- base::requireNamespace("future", 
[10:19:21.754]                           quietly = TRUE)
[10:19:21.754]                         if (has_future) {
[10:19:21.754]                           ns <- base::getNamespace("future")
[10:19:21.754]                           version <- ns[[".package"]][["version"]]
[10:19:21.754]                           if (is.null(version)) 
[10:19:21.754]                             version <- utils::packageVersion("future")
[10:19:21.754]                         }
[10:19:21.754]                         else {
[10:19:21.754]                           version <- NULL
[10:19:21.754]                         }
[10:19:21.754]                         if (!has_future || version < "1.8.0") {
[10:19:21.754]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.754]                             "", base::R.version$version.string), 
[10:19:21.754]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.754]                               "release", "version")], collapse = " "), 
[10:19:21.754]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.754]                             info)
[10:19:21.754]                           info <- base::paste(info, collapse = "; ")
[10:19:21.754]                           if (!has_future) {
[10:19:21.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.754]                               info)
[10:19:21.754]                           }
[10:19:21.754]                           else {
[10:19:21.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.754]                               info, version)
[10:19:21.754]                           }
[10:19:21.754]                           base::stop(msg)
[10:19:21.754]                         }
[10:19:21.754]                       })
[10:19:21.754]                     }
[10:19:21.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.754]                     base::options(mc.cores = 1L)
[10:19:21.754]                   }
[10:19:21.754]                   ...future.strategy.old <- future::plan("list")
[10:19:21.754]                   options(future.plan = NULL)
[10:19:21.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.754]                 }
[10:19:21.754]                 ...future.workdir <- getwd()
[10:19:21.754]             }
[10:19:21.754]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.754]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.754]         }
[10:19:21.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.754]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:21.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.754]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.754]             base::names(...future.oldOptions))
[10:19:21.754]     }
[10:19:21.754]     if (FALSE) {
[10:19:21.754]     }
[10:19:21.754]     else {
[10:19:21.754]         if (TRUE) {
[10:19:21.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.754]                 open = "w")
[10:19:21.754]         }
[10:19:21.754]         else {
[10:19:21.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.754]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.754]         }
[10:19:21.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.754]             base::sink(type = "output", split = FALSE)
[10:19:21.754]             base::close(...future.stdout)
[10:19:21.754]         }, add = TRUE)
[10:19:21.754]     }
[10:19:21.754]     ...future.frame <- base::sys.nframe()
[10:19:21.754]     ...future.conditions <- base::list()
[10:19:21.754]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.754]     if (FALSE) {
[10:19:21.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.754]     }
[10:19:21.754]     ...future.result <- base::tryCatch({
[10:19:21.754]         base::withCallingHandlers({
[10:19:21.754]             ...future.value <- base::withVisible(base::local({
[10:19:21.754]                 withCallingHandlers({
[10:19:21.754]                   {
[10:19:21.754]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.754]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.754]                       ...future.globals.maxSize)) {
[10:19:21.754]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.754]                       on.exit(options(oopts), add = TRUE)
[10:19:21.754]                     }
[10:19:21.754]                     {
[10:19:21.754]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.754]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.754]                         USE.NAMES = FALSE)
[10:19:21.754]                       do.call(mapply, args = args)
[10:19:21.754]                     }
[10:19:21.754]                   }
[10:19:21.754]                 }, immediateCondition = function(cond) {
[10:19:21.754]                   save_rds <- function (object, pathname, ...) 
[10:19:21.754]                   {
[10:19:21.754]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.754]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.754]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.754]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.754]                         fi_tmp[["mtime"]])
[10:19:21.754]                     }
[10:19:21.754]                     tryCatch({
[10:19:21.754]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.754]                     }, error = function(ex) {
[10:19:21.754]                       msg <- conditionMessage(ex)
[10:19:21.754]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.754]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.754]                         fi_tmp[["mtime"]], msg)
[10:19:21.754]                       ex$message <- msg
[10:19:21.754]                       stop(ex)
[10:19:21.754]                     })
[10:19:21.754]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.754]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.754]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.754]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.754]                       fi <- file.info(pathname)
[10:19:21.754]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.754]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.754]                         fi[["size"]], fi[["mtime"]])
[10:19:21.754]                       stop(msg)
[10:19:21.754]                     }
[10:19:21.754]                     invisible(pathname)
[10:19:21.754]                   }
[10:19:21.754]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.754]                     rootPath = tempdir()) 
[10:19:21.754]                   {
[10:19:21.754]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.754]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.754]                       tmpdir = path, fileext = ".rds")
[10:19:21.754]                     save_rds(obj, file)
[10:19:21.754]                   }
[10:19:21.754]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.754]                   {
[10:19:21.754]                     inherits <- base::inherits
[10:19:21.754]                     invokeRestart <- base::invokeRestart
[10:19:21.754]                     is.null <- base::is.null
[10:19:21.754]                     muffled <- FALSE
[10:19:21.754]                     if (inherits(cond, "message")) {
[10:19:21.754]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.754]                       if (muffled) 
[10:19:21.754]                         invokeRestart("muffleMessage")
[10:19:21.754]                     }
[10:19:21.754]                     else if (inherits(cond, "warning")) {
[10:19:21.754]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.754]                       if (muffled) 
[10:19:21.754]                         invokeRestart("muffleWarning")
[10:19:21.754]                     }
[10:19:21.754]                     else if (inherits(cond, "condition")) {
[10:19:21.754]                       if (!is.null(pattern)) {
[10:19:21.754]                         computeRestarts <- base::computeRestarts
[10:19:21.754]                         grepl <- base::grepl
[10:19:21.754]                         restarts <- computeRestarts(cond)
[10:19:21.754]                         for (restart in restarts) {
[10:19:21.754]                           name <- restart$name
[10:19:21.754]                           if (is.null(name)) 
[10:19:21.754]                             next
[10:19:21.754]                           if (!grepl(pattern, name)) 
[10:19:21.754]                             next
[10:19:21.754]                           invokeRestart(restart)
[10:19:21.754]                           muffled <- TRUE
[10:19:21.754]                           break
[10:19:21.754]                         }
[10:19:21.754]                       }
[10:19:21.754]                     }
[10:19:21.754]                     invisible(muffled)
[10:19:21.754]                   }
[10:19:21.754]                   muffleCondition(cond)
[10:19:21.754]                 })
[10:19:21.754]             }))
[10:19:21.754]             future::FutureResult(value = ...future.value$value, 
[10:19:21.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.754]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.754]                     ...future.globalenv.names))
[10:19:21.754]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.754]         }, condition = base::local({
[10:19:21.754]             c <- base::c
[10:19:21.754]             inherits <- base::inherits
[10:19:21.754]             invokeRestart <- base::invokeRestart
[10:19:21.754]             length <- base::length
[10:19:21.754]             list <- base::list
[10:19:21.754]             seq.int <- base::seq.int
[10:19:21.754]             signalCondition <- base::signalCondition
[10:19:21.754]             sys.calls <- base::sys.calls
[10:19:21.754]             `[[` <- base::`[[`
[10:19:21.754]             `+` <- base::`+`
[10:19:21.754]             `<<-` <- base::`<<-`
[10:19:21.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.754]                   3L)]
[10:19:21.754]             }
[10:19:21.754]             function(cond) {
[10:19:21.754]                 is_error <- inherits(cond, "error")
[10:19:21.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.754]                   NULL)
[10:19:21.754]                 if (is_error) {
[10:19:21.754]                   sessionInformation <- function() {
[10:19:21.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.754]                       search = base::search(), system = base::Sys.info())
[10:19:21.754]                   }
[10:19:21.754]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.754]                     cond$call), session = sessionInformation(), 
[10:19:21.754]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.754]                   signalCondition(cond)
[10:19:21.754]                 }
[10:19:21.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.754]                 "immediateCondition"))) {
[10:19:21.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.754]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.754]                   if (TRUE && !signal) {
[10:19:21.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.754]                     {
[10:19:21.754]                       inherits <- base::inherits
[10:19:21.754]                       invokeRestart <- base::invokeRestart
[10:19:21.754]                       is.null <- base::is.null
[10:19:21.754]                       muffled <- FALSE
[10:19:21.754]                       if (inherits(cond, "message")) {
[10:19:21.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.754]                         if (muffled) 
[10:19:21.754]                           invokeRestart("muffleMessage")
[10:19:21.754]                       }
[10:19:21.754]                       else if (inherits(cond, "warning")) {
[10:19:21.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.754]                         if (muffled) 
[10:19:21.754]                           invokeRestart("muffleWarning")
[10:19:21.754]                       }
[10:19:21.754]                       else if (inherits(cond, "condition")) {
[10:19:21.754]                         if (!is.null(pattern)) {
[10:19:21.754]                           computeRestarts <- base::computeRestarts
[10:19:21.754]                           grepl <- base::grepl
[10:19:21.754]                           restarts <- computeRestarts(cond)
[10:19:21.754]                           for (restart in restarts) {
[10:19:21.754]                             name <- restart$name
[10:19:21.754]                             if (is.null(name)) 
[10:19:21.754]                               next
[10:19:21.754]                             if (!grepl(pattern, name)) 
[10:19:21.754]                               next
[10:19:21.754]                             invokeRestart(restart)
[10:19:21.754]                             muffled <- TRUE
[10:19:21.754]                             break
[10:19:21.754]                           }
[10:19:21.754]                         }
[10:19:21.754]                       }
[10:19:21.754]                       invisible(muffled)
[10:19:21.754]                     }
[10:19:21.754]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.754]                   }
[10:19:21.754]                 }
[10:19:21.754]                 else {
[10:19:21.754]                   if (TRUE) {
[10:19:21.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.754]                     {
[10:19:21.754]                       inherits <- base::inherits
[10:19:21.754]                       invokeRestart <- base::invokeRestart
[10:19:21.754]                       is.null <- base::is.null
[10:19:21.754]                       muffled <- FALSE
[10:19:21.754]                       if (inherits(cond, "message")) {
[10:19:21.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.754]                         if (muffled) 
[10:19:21.754]                           invokeRestart("muffleMessage")
[10:19:21.754]                       }
[10:19:21.754]                       else if (inherits(cond, "warning")) {
[10:19:21.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.754]                         if (muffled) 
[10:19:21.754]                           invokeRestart("muffleWarning")
[10:19:21.754]                       }
[10:19:21.754]                       else if (inherits(cond, "condition")) {
[10:19:21.754]                         if (!is.null(pattern)) {
[10:19:21.754]                           computeRestarts <- base::computeRestarts
[10:19:21.754]                           grepl <- base::grepl
[10:19:21.754]                           restarts <- computeRestarts(cond)
[10:19:21.754]                           for (restart in restarts) {
[10:19:21.754]                             name <- restart$name
[10:19:21.754]                             if (is.null(name)) 
[10:19:21.754]                               next
[10:19:21.754]                             if (!grepl(pattern, name)) 
[10:19:21.754]                               next
[10:19:21.754]                             invokeRestart(restart)
[10:19:21.754]                             muffled <- TRUE
[10:19:21.754]                             break
[10:19:21.754]                           }
[10:19:21.754]                         }
[10:19:21.754]                       }
[10:19:21.754]                       invisible(muffled)
[10:19:21.754]                     }
[10:19:21.754]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.754]                   }
[10:19:21.754]                 }
[10:19:21.754]             }
[10:19:21.754]         }))
[10:19:21.754]     }, error = function(ex) {
[10:19:21.754]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.754]                 ...future.rng), started = ...future.startTime, 
[10:19:21.754]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.754]             version = "1.8"), class = "FutureResult")
[10:19:21.754]     }, finally = {
[10:19:21.754]         if (!identical(...future.workdir, getwd())) 
[10:19:21.754]             setwd(...future.workdir)
[10:19:21.754]         {
[10:19:21.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.754]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.754]             }
[10:19:21.754]             base::options(...future.oldOptions)
[10:19:21.754]             if (.Platform$OS.type == "windows") {
[10:19:21.754]                 old_names <- names(...future.oldEnvVars)
[10:19:21.754]                 envs <- base::Sys.getenv()
[10:19:21.754]                 names <- names(envs)
[10:19:21.754]                 common <- intersect(names, old_names)
[10:19:21.754]                 added <- setdiff(names, old_names)
[10:19:21.754]                 removed <- setdiff(old_names, names)
[10:19:21.754]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.754]                   envs[common]]
[10:19:21.754]                 NAMES <- toupper(changed)
[10:19:21.754]                 args <- list()
[10:19:21.754]                 for (kk in seq_along(NAMES)) {
[10:19:21.754]                   name <- changed[[kk]]
[10:19:21.754]                   NAME <- NAMES[[kk]]
[10:19:21.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.754]                     next
[10:19:21.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.754]                 }
[10:19:21.754]                 NAMES <- toupper(added)
[10:19:21.754]                 for (kk in seq_along(NAMES)) {
[10:19:21.754]                   name <- added[[kk]]
[10:19:21.754]                   NAME <- NAMES[[kk]]
[10:19:21.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.754]                     next
[10:19:21.754]                   args[[name]] <- ""
[10:19:21.754]                 }
[10:19:21.754]                 NAMES <- toupper(removed)
[10:19:21.754]                 for (kk in seq_along(NAMES)) {
[10:19:21.754]                   name <- removed[[kk]]
[10:19:21.754]                   NAME <- NAMES[[kk]]
[10:19:21.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.754]                     next
[10:19:21.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.754]                 }
[10:19:21.754]                 if (length(args) > 0) 
[10:19:21.754]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.754]             }
[10:19:21.754]             else {
[10:19:21.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.754]             }
[10:19:21.754]             {
[10:19:21.754]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.754]                   0L) {
[10:19:21.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.754]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.754]                   base::options(opts)
[10:19:21.754]                 }
[10:19:21.754]                 {
[10:19:21.754]                   {
[10:19:21.754]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.754]                     NULL
[10:19:21.754]                   }
[10:19:21.754]                   options(future.plan = NULL)
[10:19:21.754]                   if (is.na(NA_character_)) 
[10:19:21.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.754]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.754]                     .init = FALSE)
[10:19:21.754]                 }
[10:19:21.754]             }
[10:19:21.754]         }
[10:19:21.754]     })
[10:19:21.754]     if (TRUE) {
[10:19:21.754]         base::sink(type = "output", split = FALSE)
[10:19:21.754]         if (TRUE) {
[10:19:21.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.754]         }
[10:19:21.754]         else {
[10:19:21.754]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.754]         }
[10:19:21.754]         base::close(...future.stdout)
[10:19:21.754]         ...future.stdout <- NULL
[10:19:21.754]     }
[10:19:21.754]     ...future.result$conditions <- ...future.conditions
[10:19:21.754]     ...future.result$finished <- base::Sys.time()
[10:19:21.754]     ...future.result
[10:19:21.754] }
[10:19:21.760] assign_globals() ...
[10:19:21.760] List of 5
[10:19:21.760]  $ ...future.FUN            :function (x, y)  
[10:19:21.760]  $ MoreArgs                 : list()
[10:19:21.760]  $ ...future.elements_ii    :List of 2
[10:19:21.760]   ..$ :List of 2
[10:19:21.760]   .. ..$ b: num 2
[10:19:21.760]   .. ..$ c: num 3
[10:19:21.760]   ..$ :List of 2
[10:19:21.760]   .. ..$ B: num 0
[10:19:21.760]   .. ..$ C: num -10
[10:19:21.760]  $ ...future.seeds_ii       : NULL
[10:19:21.760]  $ ...future.globals.maxSize: NULL
[10:19:21.760]  - attr(*, "where")=List of 5
[10:19:21.760]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.760]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.760]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.760]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.760]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.760]  - attr(*, "resolved")= logi FALSE
[10:19:21.760]  - attr(*, "total_size")= num 699
[10:19:21.760]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.760]  - attr(*, "already-done")= logi TRUE
[10:19:21.771] - reassign environment for ‘...future.FUN’
[10:19:21.771] - copied ‘...future.FUN’ to environment
[10:19:21.771] - copied ‘MoreArgs’ to environment
[10:19:21.772] - copied ‘...future.elements_ii’ to environment
[10:19:21.772] - copied ‘...future.seeds_ii’ to environment
[10:19:21.772] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.772] assign_globals() ... done
[10:19:21.772] requestCore(): workers = 2
[10:19:21.775] MulticoreFuture started
[10:19:21.775] - Launch lazy future ... done
[10:19:21.775] run() for ‘MulticoreFuture’ ... done
[10:19:21.775] Created future:
[10:19:21.776] plan(): Setting new future strategy stack:
[10:19:21.776] List of future strategies:
[10:19:21.776] 1. sequential:
[10:19:21.776]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.776]    - tweaked: FALSE
[10:19:21.776]    - call: NULL
[10:19:21.777] plan(): nbrOfWorkers() = 1
[10:19:21.779] plan(): Setting new future strategy stack:
[10:19:21.779] List of future strategies:
[10:19:21.779] 1. multicore:
[10:19:21.779]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.779]    - tweaked: FALSE
[10:19:21.779]    - call: plan(strategy)
[10:19:21.782] plan(): nbrOfWorkers() = 2
[10:19:21.776] MulticoreFuture:
[10:19:21.776] Label: ‘future_.mapply-2’
[10:19:21.776] Expression:
[10:19:21.776] {
[10:19:21.776]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.776]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.776]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.776]         on.exit(options(oopts), add = TRUE)
[10:19:21.776]     }
[10:19:21.776]     {
[10:19:21.776]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.776]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.776]         do.call(mapply, args = args)
[10:19:21.776]     }
[10:19:21.776] }
[10:19:21.776] Lazy evaluation: FALSE
[10:19:21.776] Asynchronous evaluation: TRUE
[10:19:21.776] Local evaluation: TRUE
[10:19:21.776] Environment: R_GlobalEnv
[10:19:21.776] Capture standard output: TRUE
[10:19:21.776] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.776] Globals: 5 objects totaling 699 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.776] Packages: <none>
[10:19:21.776] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.776] Resolved: TRUE
[10:19:21.776] Value: <not collected>
[10:19:21.776] Conditions captured: <none>
[10:19:21.776] Early signaling: FALSE
[10:19:21.776] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.776] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.783] Chunk #2 of 2 ... DONE
[10:19:21.783] Launching 2 futures (chunks) ... DONE
[10:19:21.783] Resolving 2 futures (chunks) ...
[10:19:21.784] resolve() on list ...
[10:19:21.784]  recursive: 0
[10:19:21.784]  length: 2
[10:19:21.784] 
[10:19:21.784] Future #1
[10:19:21.784] result() for MulticoreFuture ...
[10:19:21.785] result() for MulticoreFuture ...
[10:19:21.785] result() for MulticoreFuture ... done
[10:19:21.786] result() for MulticoreFuture ... done
[10:19:21.786] result() for MulticoreFuture ...
[10:19:21.786] result() for MulticoreFuture ... done
[10:19:21.786] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:21.786] - nx: 2
[10:19:21.786] - relay: TRUE
[10:19:21.786] - stdout: TRUE
[10:19:21.787] - signal: TRUE
[10:19:21.787] - resignal: FALSE
[10:19:21.787] - force: TRUE
[10:19:21.787] - relayed: [n=2] FALSE, FALSE
[10:19:21.787] - queued futures: [n=2] FALSE, FALSE
[10:19:21.787]  - until=1
[10:19:21.787]  - relaying element #1
[10:19:21.787] result() for MulticoreFuture ...
[10:19:21.788] result() for MulticoreFuture ... done
[10:19:21.788] result() for MulticoreFuture ...
[10:19:21.788] result() for MulticoreFuture ... done
[10:19:21.788] result() for MulticoreFuture ...
[10:19:21.788] result() for MulticoreFuture ... done
[10:19:21.788] result() for MulticoreFuture ...
[10:19:21.789] result() for MulticoreFuture ... done
[10:19:21.789] - relayed: [n=2] TRUE, FALSE
[10:19:21.789] - queued futures: [n=2] TRUE, FALSE
[10:19:21.789] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:21.789]  length: 1 (resolved future 1)
[10:19:21.790] Future #2
[10:19:21.790] result() for MulticoreFuture ...
[10:19:21.790] result() for MulticoreFuture ...
[10:19:21.791] result() for MulticoreFuture ... done
[10:19:21.791] result() for MulticoreFuture ... done
[10:19:21.791] result() for MulticoreFuture ...
[10:19:21.791] result() for MulticoreFuture ... done
[10:19:21.791] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:21.791] - nx: 2
[10:19:21.792] - relay: TRUE
[10:19:21.792] - stdout: TRUE
[10:19:21.792] - signal: TRUE
[10:19:21.792] - resignal: FALSE
[10:19:21.792] - force: TRUE
[10:19:21.792] - relayed: [n=2] TRUE, FALSE
[10:19:21.792] - queued futures: [n=2] TRUE, FALSE
[10:19:21.792]  - until=2
[10:19:21.792]  - relaying element #2
[10:19:21.793] result() for MulticoreFuture ...
[10:19:21.793] result() for MulticoreFuture ... done
[10:19:21.793] result() for MulticoreFuture ...
[10:19:21.793] result() for MulticoreFuture ... done
[10:19:21.793] result() for MulticoreFuture ...
[10:19:21.793] result() for MulticoreFuture ... done
[10:19:21.793] result() for MulticoreFuture ...
[10:19:21.793] result() for MulticoreFuture ... done
[10:19:21.794] - relayed: [n=2] TRUE, TRUE
[10:19:21.794] - queued futures: [n=2] TRUE, TRUE
[10:19:21.794] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:21.794]  length: 0 (resolved future 2)
[10:19:21.794] Relaying remaining futures
[10:19:21.794] signalConditionsASAP(NULL, pos=0) ...
[10:19:21.794] - nx: 2
[10:19:21.794] - relay: TRUE
[10:19:21.794] - stdout: TRUE
[10:19:21.795] - signal: TRUE
[10:19:21.795] - resignal: FALSE
[10:19:21.795] - force: TRUE
[10:19:21.795] - relayed: [n=2] TRUE, TRUE
[10:19:21.795] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:21.795] - relayed: [n=2] TRUE, TRUE
[10:19:21.795] - queued futures: [n=2] TRUE, TRUE
[10:19:21.795] signalConditionsASAP(NULL, pos=0) ... done
[10:19:21.795] resolve() on list ... DONE
[10:19:21.796] result() for MulticoreFuture ...
[10:19:21.796] result() for MulticoreFuture ... done
[10:19:21.796] result() for MulticoreFuture ...
[10:19:21.796] result() for MulticoreFuture ... done
[10:19:21.796] result() for MulticoreFuture ...
[10:19:21.796] result() for MulticoreFuture ... done
[10:19:21.796] result() for MulticoreFuture ...
[10:19:21.796] result() for MulticoreFuture ... done
[10:19:21.796]  - Number of value chunks collected: 2
[10:19:21.797] Resolving 2 futures (chunks) ... DONE
[10:19:21.797] Reducing values from 2 chunks ...
[10:19:21.797]  - Number of values collected after concatenation: 3
[10:19:21.799]  - Number of values expected: 3
[10:19:21.800] Reducing values from 2 chunks ... DONE
[10:19:21.800] future_mapply() ... DONE
[10:19:21.800] future_mapply() ...
[10:19:21.803] Number of chunks: 5
[10:19:21.803] getGlobalsAndPackagesXApply() ...
[10:19:21.803]  - future.globals: TRUE
[10:19:21.803] getGlobalsAndPackages() ...
[10:19:21.804] Searching for globals...
[10:19:21.806] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:21.806] Searching for globals ... DONE
[10:19:21.806] Resolving globals: FALSE
[10:19:21.806] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:21.807] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:21.807] - globals: [1] ‘FUN’
[10:19:21.807] 
[10:19:21.807] getGlobalsAndPackages() ... DONE
[10:19:21.807]  - globals found/used: [n=1] ‘FUN’
[10:19:21.807]  - needed namespaces: [n=0] 
[10:19:21.807] Finding globals ... DONE
[10:19:21.808] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:21.808] List of 2
[10:19:21.808]  $ ...future.FUN:function (C, k)  
[10:19:21.808]  $ MoreArgs     : NULL
[10:19:21.808]  - attr(*, "where")=List of 2
[10:19:21.808]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:21.808]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:21.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.808]  - attr(*, "resolved")= logi FALSE
[10:19:21.808]  - attr(*, "total_size")= num NA
[10:19:21.811] Packages to be attached in all futures: [n=0] 
[10:19:21.811] getGlobalsAndPackagesXApply() ... DONE
[10:19:21.811] Number of futures (= number of chunks): 5
[10:19:21.811] Launching 5 futures (chunks) ...
[10:19:21.811] Chunk #1 of 5 ...
[10:19:21.811]  - Finding globals in '...' for chunk #1 ...
[10:19:21.811] getGlobalsAndPackages() ...
[10:19:21.811] Searching for globals...
[10:19:21.812] 
[10:19:21.812] Searching for globals ... DONE
[10:19:21.812] - globals: [0] <none>
[10:19:21.812] getGlobalsAndPackages() ... DONE
[10:19:21.812]    + additional globals found: [n=0] 
[10:19:21.812]    + additional namespaces needed: [n=0] 
[10:19:21.812]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:21.812]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:21.812]  - seeds: <none>
[10:19:21.813]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.813] getGlobalsAndPackages() ...
[10:19:21.813] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.813] Resolving globals: FALSE
[10:19:21.813] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:21.814] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.814] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.814] 
[10:19:21.814] getGlobalsAndPackages() ... DONE
[10:19:21.814] run() for ‘Future’ ...
[10:19:21.814] - state: ‘created’
[10:19:21.815] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.816] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.816] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.816]   - Field: ‘label’
[10:19:21.816]   - Field: ‘local’
[10:19:21.817]   - Field: ‘owner’
[10:19:21.817]   - Field: ‘envir’
[10:19:21.817]   - Field: ‘workers’
[10:19:21.817]   - Field: ‘packages’
[10:19:21.817]   - Field: ‘gc’
[10:19:21.817]   - Field: ‘job’
[10:19:21.817]   - Field: ‘conditions’
[10:19:21.817]   - Field: ‘expr’
[10:19:21.817]   - Field: ‘uuid’
[10:19:21.817]   - Field: ‘seed’
[10:19:21.817]   - Field: ‘version’
[10:19:21.818]   - Field: ‘result’
[10:19:21.818]   - Field: ‘asynchronous’
[10:19:21.818]   - Field: ‘calls’
[10:19:21.818]   - Field: ‘globals’
[10:19:21.818]   - Field: ‘stdout’
[10:19:21.818]   - Field: ‘earlySignal’
[10:19:21.818]   - Field: ‘lazy’
[10:19:21.818]   - Field: ‘state’
[10:19:21.818] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.818] - Launch lazy future ...
[10:19:21.819] Packages needed by the future expression (n = 0): <none>
[10:19:21.819] Packages needed by future strategies (n = 0): <none>
[10:19:21.819] {
[10:19:21.819]     {
[10:19:21.819]         {
[10:19:21.819]             ...future.startTime <- base::Sys.time()
[10:19:21.819]             {
[10:19:21.819]                 {
[10:19:21.819]                   {
[10:19:21.819]                     {
[10:19:21.819]                       base::local({
[10:19:21.819]                         has_future <- base::requireNamespace("future", 
[10:19:21.819]                           quietly = TRUE)
[10:19:21.819]                         if (has_future) {
[10:19:21.819]                           ns <- base::getNamespace("future")
[10:19:21.819]                           version <- ns[[".package"]][["version"]]
[10:19:21.819]                           if (is.null(version)) 
[10:19:21.819]                             version <- utils::packageVersion("future")
[10:19:21.819]                         }
[10:19:21.819]                         else {
[10:19:21.819]                           version <- NULL
[10:19:21.819]                         }
[10:19:21.819]                         if (!has_future || version < "1.8.0") {
[10:19:21.819]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.819]                             "", base::R.version$version.string), 
[10:19:21.819]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.819]                               "release", "version")], collapse = " "), 
[10:19:21.819]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.819]                             info)
[10:19:21.819]                           info <- base::paste(info, collapse = "; ")
[10:19:21.819]                           if (!has_future) {
[10:19:21.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.819]                               info)
[10:19:21.819]                           }
[10:19:21.819]                           else {
[10:19:21.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.819]                               info, version)
[10:19:21.819]                           }
[10:19:21.819]                           base::stop(msg)
[10:19:21.819]                         }
[10:19:21.819]                       })
[10:19:21.819]                     }
[10:19:21.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.819]                     base::options(mc.cores = 1L)
[10:19:21.819]                   }
[10:19:21.819]                   ...future.strategy.old <- future::plan("list")
[10:19:21.819]                   options(future.plan = NULL)
[10:19:21.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.819]                 }
[10:19:21.819]                 ...future.workdir <- getwd()
[10:19:21.819]             }
[10:19:21.819]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.819]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.819]         }
[10:19:21.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.819]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:21.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.819]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.819]             base::names(...future.oldOptions))
[10:19:21.819]     }
[10:19:21.819]     if (FALSE) {
[10:19:21.819]     }
[10:19:21.819]     else {
[10:19:21.819]         if (TRUE) {
[10:19:21.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.819]                 open = "w")
[10:19:21.819]         }
[10:19:21.819]         else {
[10:19:21.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.819]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.819]         }
[10:19:21.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.819]             base::sink(type = "output", split = FALSE)
[10:19:21.819]             base::close(...future.stdout)
[10:19:21.819]         }, add = TRUE)
[10:19:21.819]     }
[10:19:21.819]     ...future.frame <- base::sys.nframe()
[10:19:21.819]     ...future.conditions <- base::list()
[10:19:21.819]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.819]     if (FALSE) {
[10:19:21.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.819]     }
[10:19:21.819]     ...future.result <- base::tryCatch({
[10:19:21.819]         base::withCallingHandlers({
[10:19:21.819]             ...future.value <- base::withVisible(base::local({
[10:19:21.819]                 withCallingHandlers({
[10:19:21.819]                   {
[10:19:21.819]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.819]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.819]                       ...future.globals.maxSize)) {
[10:19:21.819]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.819]                       on.exit(options(oopts), add = TRUE)
[10:19:21.819]                     }
[10:19:21.819]                     {
[10:19:21.819]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.819]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.819]                         USE.NAMES = FALSE)
[10:19:21.819]                       do.call(mapply, args = args)
[10:19:21.819]                     }
[10:19:21.819]                   }
[10:19:21.819]                 }, immediateCondition = function(cond) {
[10:19:21.819]                   save_rds <- function (object, pathname, ...) 
[10:19:21.819]                   {
[10:19:21.819]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.819]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.819]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.819]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.819]                         fi_tmp[["mtime"]])
[10:19:21.819]                     }
[10:19:21.819]                     tryCatch({
[10:19:21.819]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.819]                     }, error = function(ex) {
[10:19:21.819]                       msg <- conditionMessage(ex)
[10:19:21.819]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.819]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.819]                         fi_tmp[["mtime"]], msg)
[10:19:21.819]                       ex$message <- msg
[10:19:21.819]                       stop(ex)
[10:19:21.819]                     })
[10:19:21.819]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.819]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.819]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.819]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.819]                       fi <- file.info(pathname)
[10:19:21.819]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.819]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.819]                         fi[["size"]], fi[["mtime"]])
[10:19:21.819]                       stop(msg)
[10:19:21.819]                     }
[10:19:21.819]                     invisible(pathname)
[10:19:21.819]                   }
[10:19:21.819]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.819]                     rootPath = tempdir()) 
[10:19:21.819]                   {
[10:19:21.819]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.819]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.819]                       tmpdir = path, fileext = ".rds")
[10:19:21.819]                     save_rds(obj, file)
[10:19:21.819]                   }
[10:19:21.819]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.819]                   {
[10:19:21.819]                     inherits <- base::inherits
[10:19:21.819]                     invokeRestart <- base::invokeRestart
[10:19:21.819]                     is.null <- base::is.null
[10:19:21.819]                     muffled <- FALSE
[10:19:21.819]                     if (inherits(cond, "message")) {
[10:19:21.819]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.819]                       if (muffled) 
[10:19:21.819]                         invokeRestart("muffleMessage")
[10:19:21.819]                     }
[10:19:21.819]                     else if (inherits(cond, "warning")) {
[10:19:21.819]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.819]                       if (muffled) 
[10:19:21.819]                         invokeRestart("muffleWarning")
[10:19:21.819]                     }
[10:19:21.819]                     else if (inherits(cond, "condition")) {
[10:19:21.819]                       if (!is.null(pattern)) {
[10:19:21.819]                         computeRestarts <- base::computeRestarts
[10:19:21.819]                         grepl <- base::grepl
[10:19:21.819]                         restarts <- computeRestarts(cond)
[10:19:21.819]                         for (restart in restarts) {
[10:19:21.819]                           name <- restart$name
[10:19:21.819]                           if (is.null(name)) 
[10:19:21.819]                             next
[10:19:21.819]                           if (!grepl(pattern, name)) 
[10:19:21.819]                             next
[10:19:21.819]                           invokeRestart(restart)
[10:19:21.819]                           muffled <- TRUE
[10:19:21.819]                           break
[10:19:21.819]                         }
[10:19:21.819]                       }
[10:19:21.819]                     }
[10:19:21.819]                     invisible(muffled)
[10:19:21.819]                   }
[10:19:21.819]                   muffleCondition(cond)
[10:19:21.819]                 })
[10:19:21.819]             }))
[10:19:21.819]             future::FutureResult(value = ...future.value$value, 
[10:19:21.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.819]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.819]                     ...future.globalenv.names))
[10:19:21.819]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.819]         }, condition = base::local({
[10:19:21.819]             c <- base::c
[10:19:21.819]             inherits <- base::inherits
[10:19:21.819]             invokeRestart <- base::invokeRestart
[10:19:21.819]             length <- base::length
[10:19:21.819]             list <- base::list
[10:19:21.819]             seq.int <- base::seq.int
[10:19:21.819]             signalCondition <- base::signalCondition
[10:19:21.819]             sys.calls <- base::sys.calls
[10:19:21.819]             `[[` <- base::`[[`
[10:19:21.819]             `+` <- base::`+`
[10:19:21.819]             `<<-` <- base::`<<-`
[10:19:21.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.819]                   3L)]
[10:19:21.819]             }
[10:19:21.819]             function(cond) {
[10:19:21.819]                 is_error <- inherits(cond, "error")
[10:19:21.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.819]                   NULL)
[10:19:21.819]                 if (is_error) {
[10:19:21.819]                   sessionInformation <- function() {
[10:19:21.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.819]                       search = base::search(), system = base::Sys.info())
[10:19:21.819]                   }
[10:19:21.819]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.819]                     cond$call), session = sessionInformation(), 
[10:19:21.819]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.819]                   signalCondition(cond)
[10:19:21.819]                 }
[10:19:21.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.819]                 "immediateCondition"))) {
[10:19:21.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.819]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.819]                   if (TRUE && !signal) {
[10:19:21.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.819]                     {
[10:19:21.819]                       inherits <- base::inherits
[10:19:21.819]                       invokeRestart <- base::invokeRestart
[10:19:21.819]                       is.null <- base::is.null
[10:19:21.819]                       muffled <- FALSE
[10:19:21.819]                       if (inherits(cond, "message")) {
[10:19:21.819]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.819]                         if (muffled) 
[10:19:21.819]                           invokeRestart("muffleMessage")
[10:19:21.819]                       }
[10:19:21.819]                       else if (inherits(cond, "warning")) {
[10:19:21.819]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.819]                         if (muffled) 
[10:19:21.819]                           invokeRestart("muffleWarning")
[10:19:21.819]                       }
[10:19:21.819]                       else if (inherits(cond, "condition")) {
[10:19:21.819]                         if (!is.null(pattern)) {
[10:19:21.819]                           computeRestarts <- base::computeRestarts
[10:19:21.819]                           grepl <- base::grepl
[10:19:21.819]                           restarts <- computeRestarts(cond)
[10:19:21.819]                           for (restart in restarts) {
[10:19:21.819]                             name <- restart$name
[10:19:21.819]                             if (is.null(name)) 
[10:19:21.819]                               next
[10:19:21.819]                             if (!grepl(pattern, name)) 
[10:19:21.819]                               next
[10:19:21.819]                             invokeRestart(restart)
[10:19:21.819]                             muffled <- TRUE
[10:19:21.819]                             break
[10:19:21.819]                           }
[10:19:21.819]                         }
[10:19:21.819]                       }
[10:19:21.819]                       invisible(muffled)
[10:19:21.819]                     }
[10:19:21.819]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.819]                   }
[10:19:21.819]                 }
[10:19:21.819]                 else {
[10:19:21.819]                   if (TRUE) {
[10:19:21.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.819]                     {
[10:19:21.819]                       inherits <- base::inherits
[10:19:21.819]                       invokeRestart <- base::invokeRestart
[10:19:21.819]                       is.null <- base::is.null
[10:19:21.819]                       muffled <- FALSE
[10:19:21.819]                       if (inherits(cond, "message")) {
[10:19:21.819]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.819]                         if (muffled) 
[10:19:21.819]                           invokeRestart("muffleMessage")
[10:19:21.819]                       }
[10:19:21.819]                       else if (inherits(cond, "warning")) {
[10:19:21.819]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.819]                         if (muffled) 
[10:19:21.819]                           invokeRestart("muffleWarning")
[10:19:21.819]                       }
[10:19:21.819]                       else if (inherits(cond, "condition")) {
[10:19:21.819]                         if (!is.null(pattern)) {
[10:19:21.819]                           computeRestarts <- base::computeRestarts
[10:19:21.819]                           grepl <- base::grepl
[10:19:21.819]                           restarts <- computeRestarts(cond)
[10:19:21.819]                           for (restart in restarts) {
[10:19:21.819]                             name <- restart$name
[10:19:21.819]                             if (is.null(name)) 
[10:19:21.819]                               next
[10:19:21.819]                             if (!grepl(pattern, name)) 
[10:19:21.819]                               next
[10:19:21.819]                             invokeRestart(restart)
[10:19:21.819]                             muffled <- TRUE
[10:19:21.819]                             break
[10:19:21.819]                           }
[10:19:21.819]                         }
[10:19:21.819]                       }
[10:19:21.819]                       invisible(muffled)
[10:19:21.819]                     }
[10:19:21.819]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.819]                   }
[10:19:21.819]                 }
[10:19:21.819]             }
[10:19:21.819]         }))
[10:19:21.819]     }, error = function(ex) {
[10:19:21.819]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.819]                 ...future.rng), started = ...future.startTime, 
[10:19:21.819]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.819]             version = "1.8"), class = "FutureResult")
[10:19:21.819]     }, finally = {
[10:19:21.819]         if (!identical(...future.workdir, getwd())) 
[10:19:21.819]             setwd(...future.workdir)
[10:19:21.819]         {
[10:19:21.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.819]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.819]             }
[10:19:21.819]             base::options(...future.oldOptions)
[10:19:21.819]             if (.Platform$OS.type == "windows") {
[10:19:21.819]                 old_names <- names(...future.oldEnvVars)
[10:19:21.819]                 envs <- base::Sys.getenv()
[10:19:21.819]                 names <- names(envs)
[10:19:21.819]                 common <- intersect(names, old_names)
[10:19:21.819]                 added <- setdiff(names, old_names)
[10:19:21.819]                 removed <- setdiff(old_names, names)
[10:19:21.819]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.819]                   envs[common]]
[10:19:21.819]                 NAMES <- toupper(changed)
[10:19:21.819]                 args <- list()
[10:19:21.819]                 for (kk in seq_along(NAMES)) {
[10:19:21.819]                   name <- changed[[kk]]
[10:19:21.819]                   NAME <- NAMES[[kk]]
[10:19:21.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.819]                     next
[10:19:21.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.819]                 }
[10:19:21.819]                 NAMES <- toupper(added)
[10:19:21.819]                 for (kk in seq_along(NAMES)) {
[10:19:21.819]                   name <- added[[kk]]
[10:19:21.819]                   NAME <- NAMES[[kk]]
[10:19:21.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.819]                     next
[10:19:21.819]                   args[[name]] <- ""
[10:19:21.819]                 }
[10:19:21.819]                 NAMES <- toupper(removed)
[10:19:21.819]                 for (kk in seq_along(NAMES)) {
[10:19:21.819]                   name <- removed[[kk]]
[10:19:21.819]                   NAME <- NAMES[[kk]]
[10:19:21.819]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.819]                     next
[10:19:21.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.819]                 }
[10:19:21.819]                 if (length(args) > 0) 
[10:19:21.819]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.819]             }
[10:19:21.819]             else {
[10:19:21.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.819]             }
[10:19:21.819]             {
[10:19:21.819]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.819]                   0L) {
[10:19:21.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.819]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.819]                   base::options(opts)
[10:19:21.819]                 }
[10:19:21.819]                 {
[10:19:21.819]                   {
[10:19:21.819]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.819]                     NULL
[10:19:21.819]                   }
[10:19:21.819]                   options(future.plan = NULL)
[10:19:21.819]                   if (is.na(NA_character_)) 
[10:19:21.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.819]                     .init = FALSE)
[10:19:21.819]                 }
[10:19:21.819]             }
[10:19:21.819]         }
[10:19:21.819]     })
[10:19:21.819]     if (TRUE) {
[10:19:21.819]         base::sink(type = "output", split = FALSE)
[10:19:21.819]         if (TRUE) {
[10:19:21.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.819]         }
[10:19:21.819]         else {
[10:19:21.819]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.819]         }
[10:19:21.819]         base::close(...future.stdout)
[10:19:21.819]         ...future.stdout <- NULL
[10:19:21.819]     }
[10:19:21.819]     ...future.result$conditions <- ...future.conditions
[10:19:21.819]     ...future.result$finished <- base::Sys.time()
[10:19:21.819]     ...future.result
[10:19:21.819] }
[10:19:21.822] assign_globals() ...
[10:19:21.822] List of 5
[10:19:21.822]  $ ...future.FUN            :function (C, k)  
[10:19:21.822]  $ MoreArgs                 : NULL
[10:19:21.822]  $ ...future.elements_ii    :List of 2
[10:19:21.822]   ..$ :List of 1
[10:19:21.822]   .. ..$ : chr "A"
[10:19:21.822]   ..$ :List of 1
[10:19:21.822]   .. ..$ : int 5
[10:19:21.822]  $ ...future.seeds_ii       : NULL
[10:19:21.822]  $ ...future.globals.maxSize: NULL
[10:19:21.822]  - attr(*, "where")=List of 5
[10:19:21.822]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.822]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.822]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.822]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.822]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.822]  - attr(*, "resolved")= logi FALSE
[10:19:21.822]  - attr(*, "total_size")= num 847
[10:19:21.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.822]  - attr(*, "already-done")= logi TRUE
[10:19:21.828] - reassign environment for ‘...future.FUN’
[10:19:21.829] - copied ‘...future.FUN’ to environment
[10:19:21.829] - copied ‘MoreArgs’ to environment
[10:19:21.829] - copied ‘...future.elements_ii’ to environment
[10:19:21.829] - copied ‘...future.seeds_ii’ to environment
[10:19:21.829] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.829] assign_globals() ... done
[10:19:21.829] requestCore(): workers = 2
[10:19:21.831] MulticoreFuture started
[10:19:21.832] - Launch lazy future ... done
[10:19:21.832] run() for ‘MulticoreFuture’ ... done
[10:19:21.832] plan(): Setting new future strategy stack:
[10:19:21.833] Created future:
[10:19:21.833] List of future strategies:
[10:19:21.833] 1. sequential:
[10:19:21.833]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.833]    - tweaked: FALSE
[10:19:21.833]    - call: NULL
[10:19:21.834] plan(): nbrOfWorkers() = 1
[10:19:21.836] plan(): Setting new future strategy stack:
[10:19:21.837] List of future strategies:
[10:19:21.837] 1. multicore:
[10:19:21.837]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.837]    - tweaked: FALSE
[10:19:21.837]    - call: plan(strategy)
[10:19:21.840] plan(): nbrOfWorkers() = 2
[10:19:21.833] MulticoreFuture:
[10:19:21.833] Label: ‘future_mapply-1’
[10:19:21.833] Expression:
[10:19:21.833] {
[10:19:21.833]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.833]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.833]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.833]         on.exit(options(oopts), add = TRUE)
[10:19:21.833]     }
[10:19:21.833]     {
[10:19:21.833]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.833]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.833]         do.call(mapply, args = args)
[10:19:21.833]     }
[10:19:21.833] }
[10:19:21.833] Lazy evaluation: FALSE
[10:19:21.833] Asynchronous evaluation: TRUE
[10:19:21.833] Local evaluation: TRUE
[10:19:21.833] Environment: R_GlobalEnv
[10:19:21.833] Capture standard output: TRUE
[10:19:21.833] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.833] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.833] Packages: <none>
[10:19:21.833] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.833] Resolved: TRUE
[10:19:21.833] Value: <not collected>
[10:19:21.833] Conditions captured: <none>
[10:19:21.833] Early signaling: FALSE
[10:19:21.833] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.833] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.841] Chunk #1 of 5 ... DONE
[10:19:21.841] Chunk #2 of 5 ...
[10:19:21.842]  - Finding globals in '...' for chunk #2 ...
[10:19:21.842] getGlobalsAndPackages() ...
[10:19:21.842] Searching for globals...
[10:19:21.843] 
[10:19:21.843] Searching for globals ... DONE
[10:19:21.843] - globals: [0] <none>
[10:19:21.843] getGlobalsAndPackages() ... DONE
[10:19:21.843]    + additional globals found: [n=0] 
[10:19:21.843]    + additional namespaces needed: [n=0] 
[10:19:21.844]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:21.844]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:21.844]  - seeds: <none>
[10:19:21.844]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.844] getGlobalsAndPackages() ...
[10:19:21.844] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.844] Resolving globals: FALSE
[10:19:21.845] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:21.846] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.846] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.846] 
[10:19:21.847] getGlobalsAndPackages() ... DONE
[10:19:21.847] run() for ‘Future’ ...
[10:19:21.847] - state: ‘created’
[10:19:21.847] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.850] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.850] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.850]   - Field: ‘label’
[10:19:21.850]   - Field: ‘local’
[10:19:21.850]   - Field: ‘owner’
[10:19:21.850]   - Field: ‘envir’
[10:19:21.851]   - Field: ‘workers’
[10:19:21.851]   - Field: ‘packages’
[10:19:21.851]   - Field: ‘gc’
[10:19:21.851]   - Field: ‘job’
[10:19:21.851]   - Field: ‘conditions’
[10:19:21.851]   - Field: ‘expr’
[10:19:21.851]   - Field: ‘uuid’
[10:19:21.852]   - Field: ‘seed’
[10:19:21.852]   - Field: ‘version’
[10:19:21.852]   - Field: ‘result’
[10:19:21.852]   - Field: ‘asynchronous’
[10:19:21.852]   - Field: ‘calls’
[10:19:21.852]   - Field: ‘globals’
[10:19:21.852]   - Field: ‘stdout’
[10:19:21.852]   - Field: ‘earlySignal’
[10:19:21.853]   - Field: ‘lazy’
[10:19:21.853]   - Field: ‘state’
[10:19:21.853] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.853] - Launch lazy future ...
[10:19:21.853] Packages needed by the future expression (n = 0): <none>
[10:19:21.854] Packages needed by future strategies (n = 0): <none>
[10:19:21.854] {
[10:19:21.854]     {
[10:19:21.854]         {
[10:19:21.854]             ...future.startTime <- base::Sys.time()
[10:19:21.854]             {
[10:19:21.854]                 {
[10:19:21.854]                   {
[10:19:21.854]                     {
[10:19:21.854]                       base::local({
[10:19:21.854]                         has_future <- base::requireNamespace("future", 
[10:19:21.854]                           quietly = TRUE)
[10:19:21.854]                         if (has_future) {
[10:19:21.854]                           ns <- base::getNamespace("future")
[10:19:21.854]                           version <- ns[[".package"]][["version"]]
[10:19:21.854]                           if (is.null(version)) 
[10:19:21.854]                             version <- utils::packageVersion("future")
[10:19:21.854]                         }
[10:19:21.854]                         else {
[10:19:21.854]                           version <- NULL
[10:19:21.854]                         }
[10:19:21.854]                         if (!has_future || version < "1.8.0") {
[10:19:21.854]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.854]                             "", base::R.version$version.string), 
[10:19:21.854]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.854]                               "release", "version")], collapse = " "), 
[10:19:21.854]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.854]                             info)
[10:19:21.854]                           info <- base::paste(info, collapse = "; ")
[10:19:21.854]                           if (!has_future) {
[10:19:21.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.854]                               info)
[10:19:21.854]                           }
[10:19:21.854]                           else {
[10:19:21.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.854]                               info, version)
[10:19:21.854]                           }
[10:19:21.854]                           base::stop(msg)
[10:19:21.854]                         }
[10:19:21.854]                       })
[10:19:21.854]                     }
[10:19:21.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.854]                     base::options(mc.cores = 1L)
[10:19:21.854]                   }
[10:19:21.854]                   ...future.strategy.old <- future::plan("list")
[10:19:21.854]                   options(future.plan = NULL)
[10:19:21.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.854]                 }
[10:19:21.854]                 ...future.workdir <- getwd()
[10:19:21.854]             }
[10:19:21.854]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.854]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.854]         }
[10:19:21.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.854]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:21.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.854]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.854]             base::names(...future.oldOptions))
[10:19:21.854]     }
[10:19:21.854]     if (FALSE) {
[10:19:21.854]     }
[10:19:21.854]     else {
[10:19:21.854]         if (TRUE) {
[10:19:21.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.854]                 open = "w")
[10:19:21.854]         }
[10:19:21.854]         else {
[10:19:21.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.854]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.854]         }
[10:19:21.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.854]             base::sink(type = "output", split = FALSE)
[10:19:21.854]             base::close(...future.stdout)
[10:19:21.854]         }, add = TRUE)
[10:19:21.854]     }
[10:19:21.854]     ...future.frame <- base::sys.nframe()
[10:19:21.854]     ...future.conditions <- base::list()
[10:19:21.854]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.854]     if (FALSE) {
[10:19:21.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.854]     }
[10:19:21.854]     ...future.result <- base::tryCatch({
[10:19:21.854]         base::withCallingHandlers({
[10:19:21.854]             ...future.value <- base::withVisible(base::local({
[10:19:21.854]                 withCallingHandlers({
[10:19:21.854]                   {
[10:19:21.854]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.854]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.854]                       ...future.globals.maxSize)) {
[10:19:21.854]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.854]                       on.exit(options(oopts), add = TRUE)
[10:19:21.854]                     }
[10:19:21.854]                     {
[10:19:21.854]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.854]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.854]                         USE.NAMES = FALSE)
[10:19:21.854]                       do.call(mapply, args = args)
[10:19:21.854]                     }
[10:19:21.854]                   }
[10:19:21.854]                 }, immediateCondition = function(cond) {
[10:19:21.854]                   save_rds <- function (object, pathname, ...) 
[10:19:21.854]                   {
[10:19:21.854]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.854]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.854]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.854]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.854]                         fi_tmp[["mtime"]])
[10:19:21.854]                     }
[10:19:21.854]                     tryCatch({
[10:19:21.854]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.854]                     }, error = function(ex) {
[10:19:21.854]                       msg <- conditionMessage(ex)
[10:19:21.854]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.854]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.854]                         fi_tmp[["mtime"]], msg)
[10:19:21.854]                       ex$message <- msg
[10:19:21.854]                       stop(ex)
[10:19:21.854]                     })
[10:19:21.854]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.854]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.854]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.854]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.854]                       fi <- file.info(pathname)
[10:19:21.854]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.854]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.854]                         fi[["size"]], fi[["mtime"]])
[10:19:21.854]                       stop(msg)
[10:19:21.854]                     }
[10:19:21.854]                     invisible(pathname)
[10:19:21.854]                   }
[10:19:21.854]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.854]                     rootPath = tempdir()) 
[10:19:21.854]                   {
[10:19:21.854]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.854]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.854]                       tmpdir = path, fileext = ".rds")
[10:19:21.854]                     save_rds(obj, file)
[10:19:21.854]                   }
[10:19:21.854]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.854]                   {
[10:19:21.854]                     inherits <- base::inherits
[10:19:21.854]                     invokeRestart <- base::invokeRestart
[10:19:21.854]                     is.null <- base::is.null
[10:19:21.854]                     muffled <- FALSE
[10:19:21.854]                     if (inherits(cond, "message")) {
[10:19:21.854]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.854]                       if (muffled) 
[10:19:21.854]                         invokeRestart("muffleMessage")
[10:19:21.854]                     }
[10:19:21.854]                     else if (inherits(cond, "warning")) {
[10:19:21.854]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.854]                       if (muffled) 
[10:19:21.854]                         invokeRestart("muffleWarning")
[10:19:21.854]                     }
[10:19:21.854]                     else if (inherits(cond, "condition")) {
[10:19:21.854]                       if (!is.null(pattern)) {
[10:19:21.854]                         computeRestarts <- base::computeRestarts
[10:19:21.854]                         grepl <- base::grepl
[10:19:21.854]                         restarts <- computeRestarts(cond)
[10:19:21.854]                         for (restart in restarts) {
[10:19:21.854]                           name <- restart$name
[10:19:21.854]                           if (is.null(name)) 
[10:19:21.854]                             next
[10:19:21.854]                           if (!grepl(pattern, name)) 
[10:19:21.854]                             next
[10:19:21.854]                           invokeRestart(restart)
[10:19:21.854]                           muffled <- TRUE
[10:19:21.854]                           break
[10:19:21.854]                         }
[10:19:21.854]                       }
[10:19:21.854]                     }
[10:19:21.854]                     invisible(muffled)
[10:19:21.854]                   }
[10:19:21.854]                   muffleCondition(cond)
[10:19:21.854]                 })
[10:19:21.854]             }))
[10:19:21.854]             future::FutureResult(value = ...future.value$value, 
[10:19:21.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.854]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.854]                     ...future.globalenv.names))
[10:19:21.854]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.854]         }, condition = base::local({
[10:19:21.854]             c <- base::c
[10:19:21.854]             inherits <- base::inherits
[10:19:21.854]             invokeRestart <- base::invokeRestart
[10:19:21.854]             length <- base::length
[10:19:21.854]             list <- base::list
[10:19:21.854]             seq.int <- base::seq.int
[10:19:21.854]             signalCondition <- base::signalCondition
[10:19:21.854]             sys.calls <- base::sys.calls
[10:19:21.854]             `[[` <- base::`[[`
[10:19:21.854]             `+` <- base::`+`
[10:19:21.854]             `<<-` <- base::`<<-`
[10:19:21.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.854]                   3L)]
[10:19:21.854]             }
[10:19:21.854]             function(cond) {
[10:19:21.854]                 is_error <- inherits(cond, "error")
[10:19:21.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.854]                   NULL)
[10:19:21.854]                 if (is_error) {
[10:19:21.854]                   sessionInformation <- function() {
[10:19:21.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.854]                       search = base::search(), system = base::Sys.info())
[10:19:21.854]                   }
[10:19:21.854]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.854]                     cond$call), session = sessionInformation(), 
[10:19:21.854]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.854]                   signalCondition(cond)
[10:19:21.854]                 }
[10:19:21.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.854]                 "immediateCondition"))) {
[10:19:21.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.854]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.854]                   if (TRUE && !signal) {
[10:19:21.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.854]                     {
[10:19:21.854]                       inherits <- base::inherits
[10:19:21.854]                       invokeRestart <- base::invokeRestart
[10:19:21.854]                       is.null <- base::is.null
[10:19:21.854]                       muffled <- FALSE
[10:19:21.854]                       if (inherits(cond, "message")) {
[10:19:21.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.854]                         if (muffled) 
[10:19:21.854]                           invokeRestart("muffleMessage")
[10:19:21.854]                       }
[10:19:21.854]                       else if (inherits(cond, "warning")) {
[10:19:21.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.854]                         if (muffled) 
[10:19:21.854]                           invokeRestart("muffleWarning")
[10:19:21.854]                       }
[10:19:21.854]                       else if (inherits(cond, "condition")) {
[10:19:21.854]                         if (!is.null(pattern)) {
[10:19:21.854]                           computeRestarts <- base::computeRestarts
[10:19:21.854]                           grepl <- base::grepl
[10:19:21.854]                           restarts <- computeRestarts(cond)
[10:19:21.854]                           for (restart in restarts) {
[10:19:21.854]                             name <- restart$name
[10:19:21.854]                             if (is.null(name)) 
[10:19:21.854]                               next
[10:19:21.854]                             if (!grepl(pattern, name)) 
[10:19:21.854]                               next
[10:19:21.854]                             invokeRestart(restart)
[10:19:21.854]                             muffled <- TRUE
[10:19:21.854]                             break
[10:19:21.854]                           }
[10:19:21.854]                         }
[10:19:21.854]                       }
[10:19:21.854]                       invisible(muffled)
[10:19:21.854]                     }
[10:19:21.854]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.854]                   }
[10:19:21.854]                 }
[10:19:21.854]                 else {
[10:19:21.854]                   if (TRUE) {
[10:19:21.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.854]                     {
[10:19:21.854]                       inherits <- base::inherits
[10:19:21.854]                       invokeRestart <- base::invokeRestart
[10:19:21.854]                       is.null <- base::is.null
[10:19:21.854]                       muffled <- FALSE
[10:19:21.854]                       if (inherits(cond, "message")) {
[10:19:21.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.854]                         if (muffled) 
[10:19:21.854]                           invokeRestart("muffleMessage")
[10:19:21.854]                       }
[10:19:21.854]                       else if (inherits(cond, "warning")) {
[10:19:21.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.854]                         if (muffled) 
[10:19:21.854]                           invokeRestart("muffleWarning")
[10:19:21.854]                       }
[10:19:21.854]                       else if (inherits(cond, "condition")) {
[10:19:21.854]                         if (!is.null(pattern)) {
[10:19:21.854]                           computeRestarts <- base::computeRestarts
[10:19:21.854]                           grepl <- base::grepl
[10:19:21.854]                           restarts <- computeRestarts(cond)
[10:19:21.854]                           for (restart in restarts) {
[10:19:21.854]                             name <- restart$name
[10:19:21.854]                             if (is.null(name)) 
[10:19:21.854]                               next
[10:19:21.854]                             if (!grepl(pattern, name)) 
[10:19:21.854]                               next
[10:19:21.854]                             invokeRestart(restart)
[10:19:21.854]                             muffled <- TRUE
[10:19:21.854]                             break
[10:19:21.854]                           }
[10:19:21.854]                         }
[10:19:21.854]                       }
[10:19:21.854]                       invisible(muffled)
[10:19:21.854]                     }
[10:19:21.854]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.854]                   }
[10:19:21.854]                 }
[10:19:21.854]             }
[10:19:21.854]         }))
[10:19:21.854]     }, error = function(ex) {
[10:19:21.854]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.854]                 ...future.rng), started = ...future.startTime, 
[10:19:21.854]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.854]             version = "1.8"), class = "FutureResult")
[10:19:21.854]     }, finally = {
[10:19:21.854]         if (!identical(...future.workdir, getwd())) 
[10:19:21.854]             setwd(...future.workdir)
[10:19:21.854]         {
[10:19:21.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.854]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.854]             }
[10:19:21.854]             base::options(...future.oldOptions)
[10:19:21.854]             if (.Platform$OS.type == "windows") {
[10:19:21.854]                 old_names <- names(...future.oldEnvVars)
[10:19:21.854]                 envs <- base::Sys.getenv()
[10:19:21.854]                 names <- names(envs)
[10:19:21.854]                 common <- intersect(names, old_names)
[10:19:21.854]                 added <- setdiff(names, old_names)
[10:19:21.854]                 removed <- setdiff(old_names, names)
[10:19:21.854]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.854]                   envs[common]]
[10:19:21.854]                 NAMES <- toupper(changed)
[10:19:21.854]                 args <- list()
[10:19:21.854]                 for (kk in seq_along(NAMES)) {
[10:19:21.854]                   name <- changed[[kk]]
[10:19:21.854]                   NAME <- NAMES[[kk]]
[10:19:21.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.854]                     next
[10:19:21.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.854]                 }
[10:19:21.854]                 NAMES <- toupper(added)
[10:19:21.854]                 for (kk in seq_along(NAMES)) {
[10:19:21.854]                   name <- added[[kk]]
[10:19:21.854]                   NAME <- NAMES[[kk]]
[10:19:21.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.854]                     next
[10:19:21.854]                   args[[name]] <- ""
[10:19:21.854]                 }
[10:19:21.854]                 NAMES <- toupper(removed)
[10:19:21.854]                 for (kk in seq_along(NAMES)) {
[10:19:21.854]                   name <- removed[[kk]]
[10:19:21.854]                   NAME <- NAMES[[kk]]
[10:19:21.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.854]                     next
[10:19:21.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.854]                 }
[10:19:21.854]                 if (length(args) > 0) 
[10:19:21.854]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.854]             }
[10:19:21.854]             else {
[10:19:21.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.854]             }
[10:19:21.854]             {
[10:19:21.854]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.854]                   0L) {
[10:19:21.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.854]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.854]                   base::options(opts)
[10:19:21.854]                 }
[10:19:21.854]                 {
[10:19:21.854]                   {
[10:19:21.854]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.854]                     NULL
[10:19:21.854]                   }
[10:19:21.854]                   options(future.plan = NULL)
[10:19:21.854]                   if (is.na(NA_character_)) 
[10:19:21.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.854]                     .init = FALSE)
[10:19:21.854]                 }
[10:19:21.854]             }
[10:19:21.854]         }
[10:19:21.854]     })
[10:19:21.854]     if (TRUE) {
[10:19:21.854]         base::sink(type = "output", split = FALSE)
[10:19:21.854]         if (TRUE) {
[10:19:21.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.854]         }
[10:19:21.854]         else {
[10:19:21.854]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.854]         }
[10:19:21.854]         base::close(...future.stdout)
[10:19:21.854]         ...future.stdout <- NULL
[10:19:21.854]     }
[10:19:21.854]     ...future.result$conditions <- ...future.conditions
[10:19:21.854]     ...future.result$finished <- base::Sys.time()
[10:19:21.854]     ...future.result
[10:19:21.854] }
[10:19:21.858] assign_globals() ...
[10:19:21.858] List of 5
[10:19:21.858]  $ ...future.FUN            :function (C, k)  
[10:19:21.858]  $ MoreArgs                 : NULL
[10:19:21.858]  $ ...future.elements_ii    :List of 2
[10:19:21.858]   ..$ :List of 1
[10:19:21.858]   .. ..$ : chr "B"
[10:19:21.858]   ..$ :List of 1
[10:19:21.858]   .. ..$ : int 4
[10:19:21.858]  $ ...future.seeds_ii       : NULL
[10:19:21.858]  $ ...future.globals.maxSize: NULL
[10:19:21.858]  - attr(*, "where")=List of 5
[10:19:21.858]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.858]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.858]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.858]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.858]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.858]  - attr(*, "resolved")= logi FALSE
[10:19:21.858]  - attr(*, "total_size")= num 847
[10:19:21.858]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.858]  - attr(*, "already-done")= logi TRUE
[10:19:21.872] - reassign environment for ‘...future.FUN’
[10:19:21.872] - copied ‘...future.FUN’ to environment
[10:19:21.872] - copied ‘MoreArgs’ to environment
[10:19:21.872] - copied ‘...future.elements_ii’ to environment
[10:19:21.872] - copied ‘...future.seeds_ii’ to environment
[10:19:21.872] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.872] assign_globals() ... done
[10:19:21.872] requestCore(): workers = 2
[10:19:21.875] MulticoreFuture started
[10:19:21.876] - Launch lazy future ... done
[10:19:21.876] plan(): Setting new future strategy stack:
[10:19:21.876] run() for ‘MulticoreFuture’ ... done
[10:19:21.877] Created future:
[10:19:21.877] List of future strategies:
[10:19:21.877] 1. sequential:
[10:19:21.877]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.877]    - tweaked: FALSE
[10:19:21.877]    - call: NULL
[10:19:21.878] plan(): nbrOfWorkers() = 1
[10:19:21.882] plan(): Setting new future strategy stack:
[10:19:21.882] List of future strategies:
[10:19:21.882] 1. multicore:
[10:19:21.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.882]    - tweaked: FALSE
[10:19:21.882]    - call: plan(strategy)
[10:19:21.886] plan(): nbrOfWorkers() = 2
[10:19:21.877] MulticoreFuture:
[10:19:21.877] Label: ‘future_mapply-2’
[10:19:21.877] Expression:
[10:19:21.877] {
[10:19:21.877]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.877]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.877]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.877]         on.exit(options(oopts), add = TRUE)
[10:19:21.877]     }
[10:19:21.877]     {
[10:19:21.877]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.877]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.877]         do.call(mapply, args = args)
[10:19:21.877]     }
[10:19:21.877] }
[10:19:21.877] Lazy evaluation: FALSE
[10:19:21.877] Asynchronous evaluation: TRUE
[10:19:21.877] Local evaluation: TRUE
[10:19:21.877] Environment: R_GlobalEnv
[10:19:21.877] Capture standard output: TRUE
[10:19:21.877] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.877] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.877] Packages: <none>
[10:19:21.877] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.877] Resolved: TRUE
[10:19:21.877] Value: <not collected>
[10:19:21.877] Conditions captured: <none>
[10:19:21.877] Early signaling: FALSE
[10:19:21.877] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.877] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.888] Chunk #2 of 5 ... DONE
[10:19:21.888] Chunk #3 of 5 ...
[10:19:21.888]  - Finding globals in '...' for chunk #3 ...
[10:19:21.889] getGlobalsAndPackages() ...
[10:19:21.889] Searching for globals...
[10:19:21.890] 
[10:19:21.890] Searching for globals ... DONE
[10:19:21.890] - globals: [0] <none>
[10:19:21.890] getGlobalsAndPackages() ... DONE
[10:19:21.890]    + additional globals found: [n=0] 
[10:19:21.891]    + additional namespaces needed: [n=0] 
[10:19:21.891]  - Finding globals in '...' for chunk #3 ... DONE
[10:19:21.891]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:21.891]  - seeds: <none>
[10:19:21.891]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.892] getGlobalsAndPackages() ...
[10:19:21.892] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.892] Resolving globals: FALSE
[10:19:21.893] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:21.894] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.894] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.895] 
[10:19:21.895] getGlobalsAndPackages() ... DONE
[10:19:21.895] run() for ‘Future’ ...
[10:19:21.896] - state: ‘created’
[10:19:21.896] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.898] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.899] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.899]   - Field: ‘label’
[10:19:21.899]   - Field: ‘local’
[10:19:21.899]   - Field: ‘owner’
[10:19:21.899]   - Field: ‘envir’
[10:19:21.899]   - Field: ‘workers’
[10:19:21.900]   - Field: ‘packages’
[10:19:21.900]   - Field: ‘gc’
[10:19:21.900]   - Field: ‘job’
[10:19:21.900]   - Field: ‘conditions’
[10:19:21.900]   - Field: ‘expr’
[10:19:21.900]   - Field: ‘uuid’
[10:19:21.900]   - Field: ‘seed’
[10:19:21.901]   - Field: ‘version’
[10:19:21.901]   - Field: ‘result’
[10:19:21.901]   - Field: ‘asynchronous’
[10:19:21.901]   - Field: ‘calls’
[10:19:21.901]   - Field: ‘globals’
[10:19:21.901]   - Field: ‘stdout’
[10:19:21.901]   - Field: ‘earlySignal’
[10:19:21.901]   - Field: ‘lazy’
[10:19:21.902]   - Field: ‘state’
[10:19:21.902] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.902] - Launch lazy future ...
[10:19:21.902] Packages needed by the future expression (n = 0): <none>
[10:19:21.902] Packages needed by future strategies (n = 0): <none>
[10:19:21.903] {
[10:19:21.903]     {
[10:19:21.903]         {
[10:19:21.903]             ...future.startTime <- base::Sys.time()
[10:19:21.903]             {
[10:19:21.903]                 {
[10:19:21.903]                   {
[10:19:21.903]                     {
[10:19:21.903]                       base::local({
[10:19:21.903]                         has_future <- base::requireNamespace("future", 
[10:19:21.903]                           quietly = TRUE)
[10:19:21.903]                         if (has_future) {
[10:19:21.903]                           ns <- base::getNamespace("future")
[10:19:21.903]                           version <- ns[[".package"]][["version"]]
[10:19:21.903]                           if (is.null(version)) 
[10:19:21.903]                             version <- utils::packageVersion("future")
[10:19:21.903]                         }
[10:19:21.903]                         else {
[10:19:21.903]                           version <- NULL
[10:19:21.903]                         }
[10:19:21.903]                         if (!has_future || version < "1.8.0") {
[10:19:21.903]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.903]                             "", base::R.version$version.string), 
[10:19:21.903]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.903]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.903]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.903]                               "release", "version")], collapse = " "), 
[10:19:21.903]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.903]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.903]                             info)
[10:19:21.903]                           info <- base::paste(info, collapse = "; ")
[10:19:21.903]                           if (!has_future) {
[10:19:21.903]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.903]                               info)
[10:19:21.903]                           }
[10:19:21.903]                           else {
[10:19:21.903]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.903]                               info, version)
[10:19:21.903]                           }
[10:19:21.903]                           base::stop(msg)
[10:19:21.903]                         }
[10:19:21.903]                       })
[10:19:21.903]                     }
[10:19:21.903]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.903]                     base::options(mc.cores = 1L)
[10:19:21.903]                   }
[10:19:21.903]                   ...future.strategy.old <- future::plan("list")
[10:19:21.903]                   options(future.plan = NULL)
[10:19:21.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.903]                 }
[10:19:21.903]                 ...future.workdir <- getwd()
[10:19:21.903]             }
[10:19:21.903]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.903]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.903]         }
[10:19:21.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.903]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:21.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.903]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.903]             base::names(...future.oldOptions))
[10:19:21.903]     }
[10:19:21.903]     if (FALSE) {
[10:19:21.903]     }
[10:19:21.903]     else {
[10:19:21.903]         if (TRUE) {
[10:19:21.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.903]                 open = "w")
[10:19:21.903]         }
[10:19:21.903]         else {
[10:19:21.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.903]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.903]         }
[10:19:21.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.903]             base::sink(type = "output", split = FALSE)
[10:19:21.903]             base::close(...future.stdout)
[10:19:21.903]         }, add = TRUE)
[10:19:21.903]     }
[10:19:21.903]     ...future.frame <- base::sys.nframe()
[10:19:21.903]     ...future.conditions <- base::list()
[10:19:21.903]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.903]     if (FALSE) {
[10:19:21.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.903]     }
[10:19:21.903]     ...future.result <- base::tryCatch({
[10:19:21.903]         base::withCallingHandlers({
[10:19:21.903]             ...future.value <- base::withVisible(base::local({
[10:19:21.903]                 withCallingHandlers({
[10:19:21.903]                   {
[10:19:21.903]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.903]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.903]                       ...future.globals.maxSize)) {
[10:19:21.903]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.903]                       on.exit(options(oopts), add = TRUE)
[10:19:21.903]                     }
[10:19:21.903]                     {
[10:19:21.903]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.903]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.903]                         USE.NAMES = FALSE)
[10:19:21.903]                       do.call(mapply, args = args)
[10:19:21.903]                     }
[10:19:21.903]                   }
[10:19:21.903]                 }, immediateCondition = function(cond) {
[10:19:21.903]                   save_rds <- function (object, pathname, ...) 
[10:19:21.903]                   {
[10:19:21.903]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.903]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.903]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.903]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.903]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.903]                         fi_tmp[["mtime"]])
[10:19:21.903]                     }
[10:19:21.903]                     tryCatch({
[10:19:21.903]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.903]                     }, error = function(ex) {
[10:19:21.903]                       msg <- conditionMessage(ex)
[10:19:21.903]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.903]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.903]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.903]                         fi_tmp[["mtime"]], msg)
[10:19:21.903]                       ex$message <- msg
[10:19:21.903]                       stop(ex)
[10:19:21.903]                     })
[10:19:21.903]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.903]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.903]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.903]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.903]                       fi <- file.info(pathname)
[10:19:21.903]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.903]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.903]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.903]                         fi[["size"]], fi[["mtime"]])
[10:19:21.903]                       stop(msg)
[10:19:21.903]                     }
[10:19:21.903]                     invisible(pathname)
[10:19:21.903]                   }
[10:19:21.903]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.903]                     rootPath = tempdir()) 
[10:19:21.903]                   {
[10:19:21.903]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.903]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.903]                       tmpdir = path, fileext = ".rds")
[10:19:21.903]                     save_rds(obj, file)
[10:19:21.903]                   }
[10:19:21.903]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.903]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.903]                   {
[10:19:21.903]                     inherits <- base::inherits
[10:19:21.903]                     invokeRestart <- base::invokeRestart
[10:19:21.903]                     is.null <- base::is.null
[10:19:21.903]                     muffled <- FALSE
[10:19:21.903]                     if (inherits(cond, "message")) {
[10:19:21.903]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.903]                       if (muffled) 
[10:19:21.903]                         invokeRestart("muffleMessage")
[10:19:21.903]                     }
[10:19:21.903]                     else if (inherits(cond, "warning")) {
[10:19:21.903]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.903]                       if (muffled) 
[10:19:21.903]                         invokeRestart("muffleWarning")
[10:19:21.903]                     }
[10:19:21.903]                     else if (inherits(cond, "condition")) {
[10:19:21.903]                       if (!is.null(pattern)) {
[10:19:21.903]                         computeRestarts <- base::computeRestarts
[10:19:21.903]                         grepl <- base::grepl
[10:19:21.903]                         restarts <- computeRestarts(cond)
[10:19:21.903]                         for (restart in restarts) {
[10:19:21.903]                           name <- restart$name
[10:19:21.903]                           if (is.null(name)) 
[10:19:21.903]                             next
[10:19:21.903]                           if (!grepl(pattern, name)) 
[10:19:21.903]                             next
[10:19:21.903]                           invokeRestart(restart)
[10:19:21.903]                           muffled <- TRUE
[10:19:21.903]                           break
[10:19:21.903]                         }
[10:19:21.903]                       }
[10:19:21.903]                     }
[10:19:21.903]                     invisible(muffled)
[10:19:21.903]                   }
[10:19:21.903]                   muffleCondition(cond)
[10:19:21.903]                 })
[10:19:21.903]             }))
[10:19:21.903]             future::FutureResult(value = ...future.value$value, 
[10:19:21.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.903]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.903]                     ...future.globalenv.names))
[10:19:21.903]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.903]         }, condition = base::local({
[10:19:21.903]             c <- base::c
[10:19:21.903]             inherits <- base::inherits
[10:19:21.903]             invokeRestart <- base::invokeRestart
[10:19:21.903]             length <- base::length
[10:19:21.903]             list <- base::list
[10:19:21.903]             seq.int <- base::seq.int
[10:19:21.903]             signalCondition <- base::signalCondition
[10:19:21.903]             sys.calls <- base::sys.calls
[10:19:21.903]             `[[` <- base::`[[`
[10:19:21.903]             `+` <- base::`+`
[10:19:21.903]             `<<-` <- base::`<<-`
[10:19:21.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.903]                   3L)]
[10:19:21.903]             }
[10:19:21.903]             function(cond) {
[10:19:21.903]                 is_error <- inherits(cond, "error")
[10:19:21.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.903]                   NULL)
[10:19:21.903]                 if (is_error) {
[10:19:21.903]                   sessionInformation <- function() {
[10:19:21.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.903]                       search = base::search(), system = base::Sys.info())
[10:19:21.903]                   }
[10:19:21.903]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.903]                     cond$call), session = sessionInformation(), 
[10:19:21.903]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.903]                   signalCondition(cond)
[10:19:21.903]                 }
[10:19:21.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.903]                 "immediateCondition"))) {
[10:19:21.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.903]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.903]                   if (TRUE && !signal) {
[10:19:21.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.903]                     {
[10:19:21.903]                       inherits <- base::inherits
[10:19:21.903]                       invokeRestart <- base::invokeRestart
[10:19:21.903]                       is.null <- base::is.null
[10:19:21.903]                       muffled <- FALSE
[10:19:21.903]                       if (inherits(cond, "message")) {
[10:19:21.903]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.903]                         if (muffled) 
[10:19:21.903]                           invokeRestart("muffleMessage")
[10:19:21.903]                       }
[10:19:21.903]                       else if (inherits(cond, "warning")) {
[10:19:21.903]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.903]                         if (muffled) 
[10:19:21.903]                           invokeRestart("muffleWarning")
[10:19:21.903]                       }
[10:19:21.903]                       else if (inherits(cond, "condition")) {
[10:19:21.903]                         if (!is.null(pattern)) {
[10:19:21.903]                           computeRestarts <- base::computeRestarts
[10:19:21.903]                           grepl <- base::grepl
[10:19:21.903]                           restarts <- computeRestarts(cond)
[10:19:21.903]                           for (restart in restarts) {
[10:19:21.903]                             name <- restart$name
[10:19:21.903]                             if (is.null(name)) 
[10:19:21.903]                               next
[10:19:21.903]                             if (!grepl(pattern, name)) 
[10:19:21.903]                               next
[10:19:21.903]                             invokeRestart(restart)
[10:19:21.903]                             muffled <- TRUE
[10:19:21.903]                             break
[10:19:21.903]                           }
[10:19:21.903]                         }
[10:19:21.903]                       }
[10:19:21.903]                       invisible(muffled)
[10:19:21.903]                     }
[10:19:21.903]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.903]                   }
[10:19:21.903]                 }
[10:19:21.903]                 else {
[10:19:21.903]                   if (TRUE) {
[10:19:21.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.903]                     {
[10:19:21.903]                       inherits <- base::inherits
[10:19:21.903]                       invokeRestart <- base::invokeRestart
[10:19:21.903]                       is.null <- base::is.null
[10:19:21.903]                       muffled <- FALSE
[10:19:21.903]                       if (inherits(cond, "message")) {
[10:19:21.903]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.903]                         if (muffled) 
[10:19:21.903]                           invokeRestart("muffleMessage")
[10:19:21.903]                       }
[10:19:21.903]                       else if (inherits(cond, "warning")) {
[10:19:21.903]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.903]                         if (muffled) 
[10:19:21.903]                           invokeRestart("muffleWarning")
[10:19:21.903]                       }
[10:19:21.903]                       else if (inherits(cond, "condition")) {
[10:19:21.903]                         if (!is.null(pattern)) {
[10:19:21.903]                           computeRestarts <- base::computeRestarts
[10:19:21.903]                           grepl <- base::grepl
[10:19:21.903]                           restarts <- computeRestarts(cond)
[10:19:21.903]                           for (restart in restarts) {
[10:19:21.903]                             name <- restart$name
[10:19:21.903]                             if (is.null(name)) 
[10:19:21.903]                               next
[10:19:21.903]                             if (!grepl(pattern, name)) 
[10:19:21.903]                               next
[10:19:21.903]                             invokeRestart(restart)
[10:19:21.903]                             muffled <- TRUE
[10:19:21.903]                             break
[10:19:21.903]                           }
[10:19:21.903]                         }
[10:19:21.903]                       }
[10:19:21.903]                       invisible(muffled)
[10:19:21.903]                     }
[10:19:21.903]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.903]                   }
[10:19:21.903]                 }
[10:19:21.903]             }
[10:19:21.903]         }))
[10:19:21.903]     }, error = function(ex) {
[10:19:21.903]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.903]                 ...future.rng), started = ...future.startTime, 
[10:19:21.903]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.903]             version = "1.8"), class = "FutureResult")
[10:19:21.903]     }, finally = {
[10:19:21.903]         if (!identical(...future.workdir, getwd())) 
[10:19:21.903]             setwd(...future.workdir)
[10:19:21.903]         {
[10:19:21.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.903]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.903]             }
[10:19:21.903]             base::options(...future.oldOptions)
[10:19:21.903]             if (.Platform$OS.type == "windows") {
[10:19:21.903]                 old_names <- names(...future.oldEnvVars)
[10:19:21.903]                 envs <- base::Sys.getenv()
[10:19:21.903]                 names <- names(envs)
[10:19:21.903]                 common <- intersect(names, old_names)
[10:19:21.903]                 added <- setdiff(names, old_names)
[10:19:21.903]                 removed <- setdiff(old_names, names)
[10:19:21.903]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.903]                   envs[common]]
[10:19:21.903]                 NAMES <- toupper(changed)
[10:19:21.903]                 args <- list()
[10:19:21.903]                 for (kk in seq_along(NAMES)) {
[10:19:21.903]                   name <- changed[[kk]]
[10:19:21.903]                   NAME <- NAMES[[kk]]
[10:19:21.903]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.903]                     next
[10:19:21.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.903]                 }
[10:19:21.903]                 NAMES <- toupper(added)
[10:19:21.903]                 for (kk in seq_along(NAMES)) {
[10:19:21.903]                   name <- added[[kk]]
[10:19:21.903]                   NAME <- NAMES[[kk]]
[10:19:21.903]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.903]                     next
[10:19:21.903]                   args[[name]] <- ""
[10:19:21.903]                 }
[10:19:21.903]                 NAMES <- toupper(removed)
[10:19:21.903]                 for (kk in seq_along(NAMES)) {
[10:19:21.903]                   name <- removed[[kk]]
[10:19:21.903]                   NAME <- NAMES[[kk]]
[10:19:21.903]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.903]                     next
[10:19:21.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.903]                 }
[10:19:21.903]                 if (length(args) > 0) 
[10:19:21.903]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.903]             }
[10:19:21.903]             else {
[10:19:21.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.903]             }
[10:19:21.903]             {
[10:19:21.903]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.903]                   0L) {
[10:19:21.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.903]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.903]                   base::options(opts)
[10:19:21.903]                 }
[10:19:21.903]                 {
[10:19:21.903]                   {
[10:19:21.903]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.903]                     NULL
[10:19:21.903]                   }
[10:19:21.903]                   options(future.plan = NULL)
[10:19:21.903]                   if (is.na(NA_character_)) 
[10:19:21.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.903]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.903]                     .init = FALSE)
[10:19:21.903]                 }
[10:19:21.903]             }
[10:19:21.903]         }
[10:19:21.903]     })
[10:19:21.903]     if (TRUE) {
[10:19:21.903]         base::sink(type = "output", split = FALSE)
[10:19:21.903]         if (TRUE) {
[10:19:21.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.903]         }
[10:19:21.903]         else {
[10:19:21.903]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.903]         }
[10:19:21.903]         base::close(...future.stdout)
[10:19:21.903]         ...future.stdout <- NULL
[10:19:21.903]     }
[10:19:21.903]     ...future.result$conditions <- ...future.conditions
[10:19:21.903]     ...future.result$finished <- base::Sys.time()
[10:19:21.903]     ...future.result
[10:19:21.903] }
[10:19:21.906] assign_globals() ...
[10:19:21.906] List of 5
[10:19:21.906]  $ ...future.FUN            :function (C, k)  
[10:19:21.906]  $ MoreArgs                 : NULL
[10:19:21.906]  $ ...future.elements_ii    :List of 2
[10:19:21.906]   ..$ :List of 1
[10:19:21.906]   .. ..$ : chr "C"
[10:19:21.906]   ..$ :List of 1
[10:19:21.906]   .. ..$ : int 3
[10:19:21.906]  $ ...future.seeds_ii       : NULL
[10:19:21.906]  $ ...future.globals.maxSize: NULL
[10:19:21.906]  - attr(*, "where")=List of 5
[10:19:21.906]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.906]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.906]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.906]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.906]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.906]  - attr(*, "resolved")= logi FALSE
[10:19:21.906]  - attr(*, "total_size")= num 847
[10:19:21.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.906]  - attr(*, "already-done")= logi TRUE
[10:19:21.913] - reassign environment for ‘...future.FUN’
[10:19:21.913] - copied ‘...future.FUN’ to environment
[10:19:21.913] - copied ‘MoreArgs’ to environment
[10:19:21.913] - copied ‘...future.elements_ii’ to environment
[10:19:21.913] - copied ‘...future.seeds_ii’ to environment
[10:19:21.914] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.914] assign_globals() ... done
[10:19:21.914] requestCore(): workers = 2
[10:19:21.914] Poll #1 (0): usedCores() = 2, workers = 2
[10:19:21.925] result() for MulticoreFuture ...
[10:19:21.925] result() for MulticoreFuture ...
[10:19:21.926] result() for MulticoreFuture ... done
[10:19:21.926] result() for MulticoreFuture ... done
[10:19:21.926] result() for MulticoreFuture ...
[10:19:21.926] result() for MulticoreFuture ... done
[10:19:21.929] MulticoreFuture started
[10:19:21.929] - Launch lazy future ... done
[10:19:21.929] run() for ‘MulticoreFuture’ ... done
[10:19:21.930] Created future:
[10:19:21.930] plan(): Setting new future strategy stack:
[10:19:21.930] List of future strategies:
[10:19:21.930] 1. sequential:
[10:19:21.930]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:21.930]    - tweaked: FALSE
[10:19:21.930]    - call: NULL
[10:19:21.931] plan(): nbrOfWorkers() = 1
[10:19:21.939] plan(): Setting new future strategy stack:
[10:19:21.939] List of future strategies:
[10:19:21.939] 1. multicore:
[10:19:21.939]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:21.939]    - tweaked: FALSE
[10:19:21.939]    - call: plan(strategy)
[10:19:21.930] MulticoreFuture:
[10:19:21.930] Label: ‘future_mapply-3’
[10:19:21.930] Expression:
[10:19:21.930] {
[10:19:21.930]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.930]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:21.930]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.930]         on.exit(options(oopts), add = TRUE)
[10:19:21.930]     }
[10:19:21.930]     {
[10:19:21.930]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.930]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:21.930]         do.call(mapply, args = args)
[10:19:21.930]     }
[10:19:21.930] }
[10:19:21.930] Lazy evaluation: FALSE
[10:19:21.930] Asynchronous evaluation: TRUE
[10:19:21.930] Local evaluation: TRUE
[10:19:21.930] Environment: R_GlobalEnv
[10:19:21.930] Capture standard output: TRUE
[10:19:21.930] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:21.930] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:21.930] Packages: <none>
[10:19:21.930] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:21.930] Resolved: FALSE
[10:19:21.930] Value: <not collected>
[10:19:21.930] Conditions captured: <none>
[10:19:21.930] Early signaling: FALSE
[10:19:21.930] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:21.930] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.945] plan(): nbrOfWorkers() = 2
[10:19:21.943] Chunk #3 of 5 ... DONE
[10:19:21.947] Chunk #4 of 5 ...
[10:19:21.948]  - Finding globals in '...' for chunk #4 ...
[10:19:21.948] getGlobalsAndPackages() ...
[10:19:21.948] Searching for globals...
[10:19:21.949] 
[10:19:21.950] Searching for globals ... DONE
[10:19:21.950] - globals: [0] <none>
[10:19:21.950] getGlobalsAndPackages() ... DONE
[10:19:21.950]    + additional globals found: [n=0] 
[10:19:21.950]    + additional namespaces needed: [n=0] 
[10:19:21.951]  - Finding globals in '...' for chunk #4 ... DONE
[10:19:21.951]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:21.951]  - seeds: <none>
[10:19:21.951]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.952] getGlobalsAndPackages() ...
[10:19:21.952] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.952] Resolving globals: FALSE
[10:19:21.953] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:21.954] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:21.955] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:21.955] 
[10:19:21.955] getGlobalsAndPackages() ... DONE
[10:19:21.956] run() for ‘Future’ ...
[10:19:21.956] - state: ‘created’
[10:19:21.956] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:21.960] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:21.960] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:21.960]   - Field: ‘label’
[10:19:21.960]   - Field: ‘local’
[10:19:21.961]   - Field: ‘owner’
[10:19:21.961]   - Field: ‘envir’
[10:19:21.961]   - Field: ‘workers’
[10:19:21.961]   - Field: ‘packages’
[10:19:21.961]   - Field: ‘gc’
[10:19:21.962]   - Field: ‘job’
[10:19:21.962]   - Field: ‘conditions’
[10:19:21.962]   - Field: ‘expr’
[10:19:21.962]   - Field: ‘uuid’
[10:19:21.962]   - Field: ‘seed’
[10:19:21.962]   - Field: ‘version’
[10:19:21.962]   - Field: ‘result’
[10:19:21.962]   - Field: ‘asynchronous’
[10:19:21.963]   - Field: ‘calls’
[10:19:21.963]   - Field: ‘globals’
[10:19:21.963]   - Field: ‘stdout’
[10:19:21.963]   - Field: ‘earlySignal’
[10:19:21.963]   - Field: ‘lazy’
[10:19:21.963]   - Field: ‘state’
[10:19:21.963] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:21.964] - Launch lazy future ...
[10:19:21.964] Packages needed by the future expression (n = 0): <none>
[10:19:21.964] Packages needed by future strategies (n = 0): <none>
[10:19:21.965] {
[10:19:21.965]     {
[10:19:21.965]         {
[10:19:21.965]             ...future.startTime <- base::Sys.time()
[10:19:21.965]             {
[10:19:21.965]                 {
[10:19:21.965]                   {
[10:19:21.965]                     {
[10:19:21.965]                       base::local({
[10:19:21.965]                         has_future <- base::requireNamespace("future", 
[10:19:21.965]                           quietly = TRUE)
[10:19:21.965]                         if (has_future) {
[10:19:21.965]                           ns <- base::getNamespace("future")
[10:19:21.965]                           version <- ns[[".package"]][["version"]]
[10:19:21.965]                           if (is.null(version)) 
[10:19:21.965]                             version <- utils::packageVersion("future")
[10:19:21.965]                         }
[10:19:21.965]                         else {
[10:19:21.965]                           version <- NULL
[10:19:21.965]                         }
[10:19:21.965]                         if (!has_future || version < "1.8.0") {
[10:19:21.965]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:21.965]                             "", base::R.version$version.string), 
[10:19:21.965]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:21.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:21.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:21.965]                               "release", "version")], collapse = " "), 
[10:19:21.965]                             hostname = base::Sys.info()[["nodename"]])
[10:19:21.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:21.965]                             info)
[10:19:21.965]                           info <- base::paste(info, collapse = "; ")
[10:19:21.965]                           if (!has_future) {
[10:19:21.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:21.965]                               info)
[10:19:21.965]                           }
[10:19:21.965]                           else {
[10:19:21.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:21.965]                               info, version)
[10:19:21.965]                           }
[10:19:21.965]                           base::stop(msg)
[10:19:21.965]                         }
[10:19:21.965]                       })
[10:19:21.965]                     }
[10:19:21.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:21.965]                     base::options(mc.cores = 1L)
[10:19:21.965]                   }
[10:19:21.965]                   ...future.strategy.old <- future::plan("list")
[10:19:21.965]                   options(future.plan = NULL)
[10:19:21.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:21.965]                 }
[10:19:21.965]                 ...future.workdir <- getwd()
[10:19:21.965]             }
[10:19:21.965]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:21.965]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:21.965]         }
[10:19:21.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:21.965]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:21.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:21.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:21.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:21.965]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:21.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:21.965]             base::names(...future.oldOptions))
[10:19:21.965]     }
[10:19:21.965]     if (FALSE) {
[10:19:21.965]     }
[10:19:21.965]     else {
[10:19:21.965]         if (TRUE) {
[10:19:21.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:21.965]                 open = "w")
[10:19:21.965]         }
[10:19:21.965]         else {
[10:19:21.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:21.965]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:21.965]         }
[10:19:21.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:21.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:21.965]             base::sink(type = "output", split = FALSE)
[10:19:21.965]             base::close(...future.stdout)
[10:19:21.965]         }, add = TRUE)
[10:19:21.965]     }
[10:19:21.965]     ...future.frame <- base::sys.nframe()
[10:19:21.965]     ...future.conditions <- base::list()
[10:19:21.965]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:21.965]     if (FALSE) {
[10:19:21.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:21.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:21.965]     }
[10:19:21.965]     ...future.result <- base::tryCatch({
[10:19:21.965]         base::withCallingHandlers({
[10:19:21.965]             ...future.value <- base::withVisible(base::local({
[10:19:21.965]                 withCallingHandlers({
[10:19:21.965]                   {
[10:19:21.965]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:21.965]                     if (!identical(...future.globals.maxSize.org, 
[10:19:21.965]                       ...future.globals.maxSize)) {
[10:19:21.965]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:21.965]                       on.exit(options(oopts), add = TRUE)
[10:19:21.965]                     }
[10:19:21.965]                     {
[10:19:21.965]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:21.965]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:21.965]                         USE.NAMES = FALSE)
[10:19:21.965]                       do.call(mapply, args = args)
[10:19:21.965]                     }
[10:19:21.965]                   }
[10:19:21.965]                 }, immediateCondition = function(cond) {
[10:19:21.965]                   save_rds <- function (object, pathname, ...) 
[10:19:21.965]                   {
[10:19:21.965]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:21.965]                     if (file_test("-f", pathname_tmp)) {
[10:19:21.965]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.965]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:21.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.965]                         fi_tmp[["mtime"]])
[10:19:21.965]                     }
[10:19:21.965]                     tryCatch({
[10:19:21.965]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:21.965]                     }, error = function(ex) {
[10:19:21.965]                       msg <- conditionMessage(ex)
[10:19:21.965]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.965]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:21.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.965]                         fi_tmp[["mtime"]], msg)
[10:19:21.965]                       ex$message <- msg
[10:19:21.965]                       stop(ex)
[10:19:21.965]                     })
[10:19:21.965]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:21.965]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:21.965]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:21.965]                       fi_tmp <- file.info(pathname_tmp)
[10:19:21.965]                       fi <- file.info(pathname)
[10:19:21.965]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:21.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:21.965]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:21.965]                         fi[["size"]], fi[["mtime"]])
[10:19:21.965]                       stop(msg)
[10:19:21.965]                     }
[10:19:21.965]                     invisible(pathname)
[10:19:21.965]                   }
[10:19:21.965]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:21.965]                     rootPath = tempdir()) 
[10:19:21.965]                   {
[10:19:21.965]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:21.965]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:21.965]                       tmpdir = path, fileext = ".rds")
[10:19:21.965]                     save_rds(obj, file)
[10:19:21.965]                   }
[10:19:21.965]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:21.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.965]                   {
[10:19:21.965]                     inherits <- base::inherits
[10:19:21.965]                     invokeRestart <- base::invokeRestart
[10:19:21.965]                     is.null <- base::is.null
[10:19:21.965]                     muffled <- FALSE
[10:19:21.965]                     if (inherits(cond, "message")) {
[10:19:21.965]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:21.965]                       if (muffled) 
[10:19:21.965]                         invokeRestart("muffleMessage")
[10:19:21.965]                     }
[10:19:21.965]                     else if (inherits(cond, "warning")) {
[10:19:21.965]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:21.965]                       if (muffled) 
[10:19:21.965]                         invokeRestart("muffleWarning")
[10:19:21.965]                     }
[10:19:21.965]                     else if (inherits(cond, "condition")) {
[10:19:21.965]                       if (!is.null(pattern)) {
[10:19:21.965]                         computeRestarts <- base::computeRestarts
[10:19:21.965]                         grepl <- base::grepl
[10:19:21.965]                         restarts <- computeRestarts(cond)
[10:19:21.965]                         for (restart in restarts) {
[10:19:21.965]                           name <- restart$name
[10:19:21.965]                           if (is.null(name)) 
[10:19:21.965]                             next
[10:19:21.965]                           if (!grepl(pattern, name)) 
[10:19:21.965]                             next
[10:19:21.965]                           invokeRestart(restart)
[10:19:21.965]                           muffled <- TRUE
[10:19:21.965]                           break
[10:19:21.965]                         }
[10:19:21.965]                       }
[10:19:21.965]                     }
[10:19:21.965]                     invisible(muffled)
[10:19:21.965]                   }
[10:19:21.965]                   muffleCondition(cond)
[10:19:21.965]                 })
[10:19:21.965]             }))
[10:19:21.965]             future::FutureResult(value = ...future.value$value, 
[10:19:21.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.965]                   ...future.rng), globalenv = if (FALSE) 
[10:19:21.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:21.965]                     ...future.globalenv.names))
[10:19:21.965]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:21.965]         }, condition = base::local({
[10:19:21.965]             c <- base::c
[10:19:21.965]             inherits <- base::inherits
[10:19:21.965]             invokeRestart <- base::invokeRestart
[10:19:21.965]             length <- base::length
[10:19:21.965]             list <- base::list
[10:19:21.965]             seq.int <- base::seq.int
[10:19:21.965]             signalCondition <- base::signalCondition
[10:19:21.965]             sys.calls <- base::sys.calls
[10:19:21.965]             `[[` <- base::`[[`
[10:19:21.965]             `+` <- base::`+`
[10:19:21.965]             `<<-` <- base::`<<-`
[10:19:21.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:21.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:21.965]                   3L)]
[10:19:21.965]             }
[10:19:21.965]             function(cond) {
[10:19:21.965]                 is_error <- inherits(cond, "error")
[10:19:21.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:21.965]                   NULL)
[10:19:21.965]                 if (is_error) {
[10:19:21.965]                   sessionInformation <- function() {
[10:19:21.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:21.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:21.965]                       search = base::search(), system = base::Sys.info())
[10:19:21.965]                   }
[10:19:21.965]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:21.965]                     cond$call), session = sessionInformation(), 
[10:19:21.965]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:21.965]                   signalCondition(cond)
[10:19:21.965]                 }
[10:19:21.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:21.965]                 "immediateCondition"))) {
[10:19:21.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:21.965]                   ...future.conditions[[length(...future.conditions) + 
[10:19:21.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:21.965]                   if (TRUE && !signal) {
[10:19:21.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.965]                     {
[10:19:21.965]                       inherits <- base::inherits
[10:19:21.965]                       invokeRestart <- base::invokeRestart
[10:19:21.965]                       is.null <- base::is.null
[10:19:21.965]                       muffled <- FALSE
[10:19:21.965]                       if (inherits(cond, "message")) {
[10:19:21.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.965]                         if (muffled) 
[10:19:21.965]                           invokeRestart("muffleMessage")
[10:19:21.965]                       }
[10:19:21.965]                       else if (inherits(cond, "warning")) {
[10:19:21.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.965]                         if (muffled) 
[10:19:21.965]                           invokeRestart("muffleWarning")
[10:19:21.965]                       }
[10:19:21.965]                       else if (inherits(cond, "condition")) {
[10:19:21.965]                         if (!is.null(pattern)) {
[10:19:21.965]                           computeRestarts <- base::computeRestarts
[10:19:21.965]                           grepl <- base::grepl
[10:19:21.965]                           restarts <- computeRestarts(cond)
[10:19:21.965]                           for (restart in restarts) {
[10:19:21.965]                             name <- restart$name
[10:19:21.965]                             if (is.null(name)) 
[10:19:21.965]                               next
[10:19:21.965]                             if (!grepl(pattern, name)) 
[10:19:21.965]                               next
[10:19:21.965]                             invokeRestart(restart)
[10:19:21.965]                             muffled <- TRUE
[10:19:21.965]                             break
[10:19:21.965]                           }
[10:19:21.965]                         }
[10:19:21.965]                       }
[10:19:21.965]                       invisible(muffled)
[10:19:21.965]                     }
[10:19:21.965]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.965]                   }
[10:19:21.965]                 }
[10:19:21.965]                 else {
[10:19:21.965]                   if (TRUE) {
[10:19:21.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:21.965]                     {
[10:19:21.965]                       inherits <- base::inherits
[10:19:21.965]                       invokeRestart <- base::invokeRestart
[10:19:21.965]                       is.null <- base::is.null
[10:19:21.965]                       muffled <- FALSE
[10:19:21.965]                       if (inherits(cond, "message")) {
[10:19:21.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:21.965]                         if (muffled) 
[10:19:21.965]                           invokeRestart("muffleMessage")
[10:19:21.965]                       }
[10:19:21.965]                       else if (inherits(cond, "warning")) {
[10:19:21.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:21.965]                         if (muffled) 
[10:19:21.965]                           invokeRestart("muffleWarning")
[10:19:21.965]                       }
[10:19:21.965]                       else if (inherits(cond, "condition")) {
[10:19:21.965]                         if (!is.null(pattern)) {
[10:19:21.965]                           computeRestarts <- base::computeRestarts
[10:19:21.965]                           grepl <- base::grepl
[10:19:21.965]                           restarts <- computeRestarts(cond)
[10:19:21.965]                           for (restart in restarts) {
[10:19:21.965]                             name <- restart$name
[10:19:21.965]                             if (is.null(name)) 
[10:19:21.965]                               next
[10:19:21.965]                             if (!grepl(pattern, name)) 
[10:19:21.965]                               next
[10:19:21.965]                             invokeRestart(restart)
[10:19:21.965]                             muffled <- TRUE
[10:19:21.965]                             break
[10:19:21.965]                           }
[10:19:21.965]                         }
[10:19:21.965]                       }
[10:19:21.965]                       invisible(muffled)
[10:19:21.965]                     }
[10:19:21.965]                     muffleCondition(cond, pattern = "^muffle")
[10:19:21.965]                   }
[10:19:21.965]                 }
[10:19:21.965]             }
[10:19:21.965]         }))
[10:19:21.965]     }, error = function(ex) {
[10:19:21.965]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:21.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:21.965]                 ...future.rng), started = ...future.startTime, 
[10:19:21.965]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:21.965]             version = "1.8"), class = "FutureResult")
[10:19:21.965]     }, finally = {
[10:19:21.965]         if (!identical(...future.workdir, getwd())) 
[10:19:21.965]             setwd(...future.workdir)
[10:19:21.965]         {
[10:19:21.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:21.965]                 ...future.oldOptions$nwarnings <- NULL
[10:19:21.965]             }
[10:19:21.965]             base::options(...future.oldOptions)
[10:19:21.965]             if (.Platform$OS.type == "windows") {
[10:19:21.965]                 old_names <- names(...future.oldEnvVars)
[10:19:21.965]                 envs <- base::Sys.getenv()
[10:19:21.965]                 names <- names(envs)
[10:19:21.965]                 common <- intersect(names, old_names)
[10:19:21.965]                 added <- setdiff(names, old_names)
[10:19:21.965]                 removed <- setdiff(old_names, names)
[10:19:21.965]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:21.965]                   envs[common]]
[10:19:21.965]                 NAMES <- toupper(changed)
[10:19:21.965]                 args <- list()
[10:19:21.965]                 for (kk in seq_along(NAMES)) {
[10:19:21.965]                   name <- changed[[kk]]
[10:19:21.965]                   NAME <- NAMES[[kk]]
[10:19:21.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.965]                     next
[10:19:21.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.965]                 }
[10:19:21.965]                 NAMES <- toupper(added)
[10:19:21.965]                 for (kk in seq_along(NAMES)) {
[10:19:21.965]                   name <- added[[kk]]
[10:19:21.965]                   NAME <- NAMES[[kk]]
[10:19:21.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.965]                     next
[10:19:21.965]                   args[[name]] <- ""
[10:19:21.965]                 }
[10:19:21.965]                 NAMES <- toupper(removed)
[10:19:21.965]                 for (kk in seq_along(NAMES)) {
[10:19:21.965]                   name <- removed[[kk]]
[10:19:21.965]                   NAME <- NAMES[[kk]]
[10:19:21.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:21.965]                     next
[10:19:21.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:21.965]                 }
[10:19:21.965]                 if (length(args) > 0) 
[10:19:21.965]                   base::do.call(base::Sys.setenv, args = args)
[10:19:21.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:21.965]             }
[10:19:21.965]             else {
[10:19:21.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:21.965]             }
[10:19:21.965]             {
[10:19:21.965]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:21.965]                   0L) {
[10:19:21.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:21.965]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:21.965]                   base::options(opts)
[10:19:21.965]                 }
[10:19:21.965]                 {
[10:19:21.965]                   {
[10:19:21.965]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:21.965]                     NULL
[10:19:21.965]                   }
[10:19:21.965]                   options(future.plan = NULL)
[10:19:21.965]                   if (is.na(NA_character_)) 
[10:19:21.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:21.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:21.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:21.965]                     .init = FALSE)
[10:19:21.965]                 }
[10:19:21.965]             }
[10:19:21.965]         }
[10:19:21.965]     })
[10:19:21.965]     if (TRUE) {
[10:19:21.965]         base::sink(type = "output", split = FALSE)
[10:19:21.965]         if (TRUE) {
[10:19:21.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:21.965]         }
[10:19:21.965]         else {
[10:19:21.965]             ...future.result["stdout"] <- base::list(NULL)
[10:19:21.965]         }
[10:19:21.965]         base::close(...future.stdout)
[10:19:21.965]         ...future.stdout <- NULL
[10:19:21.965]     }
[10:19:21.965]     ...future.result$conditions <- ...future.conditions
[10:19:21.965]     ...future.result$finished <- base::Sys.time()
[10:19:21.965]     ...future.result
[10:19:21.965] }
[10:19:21.968] assign_globals() ...
[10:19:21.968] List of 5
[10:19:21.968]  $ ...future.FUN            :function (C, k)  
[10:19:21.968]  $ MoreArgs                 : NULL
[10:19:21.968]  $ ...future.elements_ii    :List of 2
[10:19:21.968]   ..$ :List of 1
[10:19:21.968]   .. ..$ : chr "D"
[10:19:21.968]   ..$ :List of 1
[10:19:21.968]   .. ..$ : int 2
[10:19:21.968]  $ ...future.seeds_ii       : NULL
[10:19:21.968]  $ ...future.globals.maxSize: NULL
[10:19:21.968]  - attr(*, "where")=List of 5
[10:19:21.968]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:21.968]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:21.968]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:21.968]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:21.968]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:21.968]  - attr(*, "resolved")= logi FALSE
[10:19:21.968]  - attr(*, "total_size")= num 847
[10:19:21.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:21.968]  - attr(*, "already-done")= logi TRUE
[10:19:21.974] - reassign environment for ‘...future.FUN’
[10:19:21.974] - copied ‘...future.FUN’ to environment
[10:19:21.974] - copied ‘MoreArgs’ to environment
[10:19:21.975] - copied ‘...future.elements_ii’ to environment
[10:19:21.975] - copied ‘...future.seeds_ii’ to environment
[10:19:21.975] - copied ‘...future.globals.maxSize’ to environment
[10:19:21.975] assign_globals() ... done
[10:19:21.975] requestCore(): workers = 2
[10:19:21.975] Poll #1 (0): usedCores() = 2, workers = 2
[10:19:21.999] result() for MulticoreFuture ...
[10:19:22.000] result() for MulticoreFuture ...
[10:19:22.000] result() for MulticoreFuture ... done
[10:19:22.000] result() for MulticoreFuture ... done
[10:19:22.000] result() for MulticoreFuture ...
[10:19:22.000] result() for MulticoreFuture ... done
[10:19:22.003] MulticoreFuture started
[10:19:22.004] - Launch lazy future ... done
[10:19:22.004] run() for ‘MulticoreFuture’ ... done
[10:19:22.005] plan(): Setting new future strategy stack:
[10:19:22.005] Created future:
[10:19:22.005] List of future strategies:
[10:19:22.005] 1. sequential:
[10:19:22.005]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.005]    - tweaked: FALSE
[10:19:22.005]    - call: NULL
[10:19:22.007] plan(): nbrOfWorkers() = 1
[10:19:22.010] plan(): Setting new future strategy stack:
[10:19:22.010] List of future strategies:
[10:19:22.010] 1. multicore:
[10:19:22.010]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.010]    - tweaked: FALSE
[10:19:22.010]    - call: plan(strategy)
[10:19:22.013] plan(): nbrOfWorkers() = 2
[10:19:22.005] MulticoreFuture:
[10:19:22.005] Label: ‘future_mapply-4’
[10:19:22.005] Expression:
[10:19:22.005] {
[10:19:22.005]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.005]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.005]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.005]         on.exit(options(oopts), add = TRUE)
[10:19:22.005]     }
[10:19:22.005]     {
[10:19:22.005]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.005]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.005]         do.call(mapply, args = args)
[10:19:22.005]     }
[10:19:22.005] }
[10:19:22.005] Lazy evaluation: FALSE
[10:19:22.005] Asynchronous evaluation: TRUE
[10:19:22.005] Local evaluation: TRUE
[10:19:22.005] Environment: R_GlobalEnv
[10:19:22.005] Capture standard output: TRUE
[10:19:22.005] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.005] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.005] Packages: <none>
[10:19:22.005] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.005] Resolved: TRUE
[10:19:22.005] Value: <not collected>
[10:19:22.005] Conditions captured: <none>
[10:19:22.005] Early signaling: FALSE
[10:19:22.005] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.005] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.015] Chunk #4 of 5 ... DONE
[10:19:22.015] Chunk #5 of 5 ...
[10:19:22.015]  - Finding globals in '...' for chunk #5 ...
[10:19:22.015] getGlobalsAndPackages() ...
[10:19:22.015] Searching for globals...
[10:19:22.016] 
[10:19:22.016] Searching for globals ... DONE
[10:19:22.016] - globals: [0] <none>
[10:19:22.016] getGlobalsAndPackages() ... DONE
[10:19:22.017]    + additional globals found: [n=0] 
[10:19:22.017]    + additional namespaces needed: [n=0] 
[10:19:22.017]  - Finding globals in '...' for chunk #5 ... DONE
[10:19:22.017]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:22.017]  - seeds: <none>
[10:19:22.018]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.018] getGlobalsAndPackages() ...
[10:19:22.018] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.018] Resolving globals: FALSE
[10:19:22.019] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:22.020] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:22.020] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.020] 
[10:19:22.020] getGlobalsAndPackages() ... DONE
[10:19:22.021] run() for ‘Future’ ...
[10:19:22.021] - state: ‘created’
[10:19:22.021] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.024] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.024] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.024]   - Field: ‘label’
[10:19:22.024]   - Field: ‘local’
[10:19:22.024]   - Field: ‘owner’
[10:19:22.025]   - Field: ‘envir’
[10:19:22.025]   - Field: ‘workers’
[10:19:22.025]   - Field: ‘packages’
[10:19:22.025]   - Field: ‘gc’
[10:19:22.025]   - Field: ‘job’
[10:19:22.025]   - Field: ‘conditions’
[10:19:22.025]   - Field: ‘expr’
[10:19:22.025]   - Field: ‘uuid’
[10:19:22.026]   - Field: ‘seed’
[10:19:22.026]   - Field: ‘version’
[10:19:22.026]   - Field: ‘result’
[10:19:22.026]   - Field: ‘asynchronous’
[10:19:22.026]   - Field: ‘calls’
[10:19:22.026]   - Field: ‘globals’
[10:19:22.026]   - Field: ‘stdout’
[10:19:22.027]   - Field: ‘earlySignal’
[10:19:22.027]   - Field: ‘lazy’
[10:19:22.027]   - Field: ‘state’
[10:19:22.027] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.027] - Launch lazy future ...
[10:19:22.028] Packages needed by the future expression (n = 0): <none>
[10:19:22.028] Packages needed by future strategies (n = 0): <none>
[10:19:22.029] {
[10:19:22.029]     {
[10:19:22.029]         {
[10:19:22.029]             ...future.startTime <- base::Sys.time()
[10:19:22.029]             {
[10:19:22.029]                 {
[10:19:22.029]                   {
[10:19:22.029]                     {
[10:19:22.029]                       base::local({
[10:19:22.029]                         has_future <- base::requireNamespace("future", 
[10:19:22.029]                           quietly = TRUE)
[10:19:22.029]                         if (has_future) {
[10:19:22.029]                           ns <- base::getNamespace("future")
[10:19:22.029]                           version <- ns[[".package"]][["version"]]
[10:19:22.029]                           if (is.null(version)) 
[10:19:22.029]                             version <- utils::packageVersion("future")
[10:19:22.029]                         }
[10:19:22.029]                         else {
[10:19:22.029]                           version <- NULL
[10:19:22.029]                         }
[10:19:22.029]                         if (!has_future || version < "1.8.0") {
[10:19:22.029]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.029]                             "", base::R.version$version.string), 
[10:19:22.029]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.029]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.029]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.029]                               "release", "version")], collapse = " "), 
[10:19:22.029]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.029]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.029]                             info)
[10:19:22.029]                           info <- base::paste(info, collapse = "; ")
[10:19:22.029]                           if (!has_future) {
[10:19:22.029]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.029]                               info)
[10:19:22.029]                           }
[10:19:22.029]                           else {
[10:19:22.029]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.029]                               info, version)
[10:19:22.029]                           }
[10:19:22.029]                           base::stop(msg)
[10:19:22.029]                         }
[10:19:22.029]                       })
[10:19:22.029]                     }
[10:19:22.029]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.029]                     base::options(mc.cores = 1L)
[10:19:22.029]                   }
[10:19:22.029]                   ...future.strategy.old <- future::plan("list")
[10:19:22.029]                   options(future.plan = NULL)
[10:19:22.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.029]                 }
[10:19:22.029]                 ...future.workdir <- getwd()
[10:19:22.029]             }
[10:19:22.029]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.029]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.029]         }
[10:19:22.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.029]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:22.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.029]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.029]             base::names(...future.oldOptions))
[10:19:22.029]     }
[10:19:22.029]     if (FALSE) {
[10:19:22.029]     }
[10:19:22.029]     else {
[10:19:22.029]         if (TRUE) {
[10:19:22.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.029]                 open = "w")
[10:19:22.029]         }
[10:19:22.029]         else {
[10:19:22.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.029]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.029]         }
[10:19:22.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.029]             base::sink(type = "output", split = FALSE)
[10:19:22.029]             base::close(...future.stdout)
[10:19:22.029]         }, add = TRUE)
[10:19:22.029]     }
[10:19:22.029]     ...future.frame <- base::sys.nframe()
[10:19:22.029]     ...future.conditions <- base::list()
[10:19:22.029]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.029]     if (FALSE) {
[10:19:22.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.029]     }
[10:19:22.029]     ...future.result <- base::tryCatch({
[10:19:22.029]         base::withCallingHandlers({
[10:19:22.029]             ...future.value <- base::withVisible(base::local({
[10:19:22.029]                 withCallingHandlers({
[10:19:22.029]                   {
[10:19:22.029]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.029]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.029]                       ...future.globals.maxSize)) {
[10:19:22.029]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.029]                       on.exit(options(oopts), add = TRUE)
[10:19:22.029]                     }
[10:19:22.029]                     {
[10:19:22.029]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.029]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.029]                         USE.NAMES = FALSE)
[10:19:22.029]                       do.call(mapply, args = args)
[10:19:22.029]                     }
[10:19:22.029]                   }
[10:19:22.029]                 }, immediateCondition = function(cond) {
[10:19:22.029]                   save_rds <- function (object, pathname, ...) 
[10:19:22.029]                   {
[10:19:22.029]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.029]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.029]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.029]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.029]                         fi_tmp[["mtime"]])
[10:19:22.029]                     }
[10:19:22.029]                     tryCatch({
[10:19:22.029]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.029]                     }, error = function(ex) {
[10:19:22.029]                       msg <- conditionMessage(ex)
[10:19:22.029]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.029]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.029]                         fi_tmp[["mtime"]], msg)
[10:19:22.029]                       ex$message <- msg
[10:19:22.029]                       stop(ex)
[10:19:22.029]                     })
[10:19:22.029]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.029]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.029]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.029]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.029]                       fi <- file.info(pathname)
[10:19:22.029]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.029]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.029]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.029]                         fi[["size"]], fi[["mtime"]])
[10:19:22.029]                       stop(msg)
[10:19:22.029]                     }
[10:19:22.029]                     invisible(pathname)
[10:19:22.029]                   }
[10:19:22.029]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.029]                     rootPath = tempdir()) 
[10:19:22.029]                   {
[10:19:22.029]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.029]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.029]                       tmpdir = path, fileext = ".rds")
[10:19:22.029]                     save_rds(obj, file)
[10:19:22.029]                   }
[10:19:22.029]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.029]                   {
[10:19:22.029]                     inherits <- base::inherits
[10:19:22.029]                     invokeRestart <- base::invokeRestart
[10:19:22.029]                     is.null <- base::is.null
[10:19:22.029]                     muffled <- FALSE
[10:19:22.029]                     if (inherits(cond, "message")) {
[10:19:22.029]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.029]                       if (muffled) 
[10:19:22.029]                         invokeRestart("muffleMessage")
[10:19:22.029]                     }
[10:19:22.029]                     else if (inherits(cond, "warning")) {
[10:19:22.029]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.029]                       if (muffled) 
[10:19:22.029]                         invokeRestart("muffleWarning")
[10:19:22.029]                     }
[10:19:22.029]                     else if (inherits(cond, "condition")) {
[10:19:22.029]                       if (!is.null(pattern)) {
[10:19:22.029]                         computeRestarts <- base::computeRestarts
[10:19:22.029]                         grepl <- base::grepl
[10:19:22.029]                         restarts <- computeRestarts(cond)
[10:19:22.029]                         for (restart in restarts) {
[10:19:22.029]                           name <- restart$name
[10:19:22.029]                           if (is.null(name)) 
[10:19:22.029]                             next
[10:19:22.029]                           if (!grepl(pattern, name)) 
[10:19:22.029]                             next
[10:19:22.029]                           invokeRestart(restart)
[10:19:22.029]                           muffled <- TRUE
[10:19:22.029]                           break
[10:19:22.029]                         }
[10:19:22.029]                       }
[10:19:22.029]                     }
[10:19:22.029]                     invisible(muffled)
[10:19:22.029]                   }
[10:19:22.029]                   muffleCondition(cond)
[10:19:22.029]                 })
[10:19:22.029]             }))
[10:19:22.029]             future::FutureResult(value = ...future.value$value, 
[10:19:22.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.029]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.029]                     ...future.globalenv.names))
[10:19:22.029]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.029]         }, condition = base::local({
[10:19:22.029]             c <- base::c
[10:19:22.029]             inherits <- base::inherits
[10:19:22.029]             invokeRestart <- base::invokeRestart
[10:19:22.029]             length <- base::length
[10:19:22.029]             list <- base::list
[10:19:22.029]             seq.int <- base::seq.int
[10:19:22.029]             signalCondition <- base::signalCondition
[10:19:22.029]             sys.calls <- base::sys.calls
[10:19:22.029]             `[[` <- base::`[[`
[10:19:22.029]             `+` <- base::`+`
[10:19:22.029]             `<<-` <- base::`<<-`
[10:19:22.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.029]                   3L)]
[10:19:22.029]             }
[10:19:22.029]             function(cond) {
[10:19:22.029]                 is_error <- inherits(cond, "error")
[10:19:22.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.029]                   NULL)
[10:19:22.029]                 if (is_error) {
[10:19:22.029]                   sessionInformation <- function() {
[10:19:22.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.029]                       search = base::search(), system = base::Sys.info())
[10:19:22.029]                   }
[10:19:22.029]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.029]                     cond$call), session = sessionInformation(), 
[10:19:22.029]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.029]                   signalCondition(cond)
[10:19:22.029]                 }
[10:19:22.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.029]                 "immediateCondition"))) {
[10:19:22.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.029]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.029]                   if (TRUE && !signal) {
[10:19:22.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.029]                     {
[10:19:22.029]                       inherits <- base::inherits
[10:19:22.029]                       invokeRestart <- base::invokeRestart
[10:19:22.029]                       is.null <- base::is.null
[10:19:22.029]                       muffled <- FALSE
[10:19:22.029]                       if (inherits(cond, "message")) {
[10:19:22.029]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.029]                         if (muffled) 
[10:19:22.029]                           invokeRestart("muffleMessage")
[10:19:22.029]                       }
[10:19:22.029]                       else if (inherits(cond, "warning")) {
[10:19:22.029]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.029]                         if (muffled) 
[10:19:22.029]                           invokeRestart("muffleWarning")
[10:19:22.029]                       }
[10:19:22.029]                       else if (inherits(cond, "condition")) {
[10:19:22.029]                         if (!is.null(pattern)) {
[10:19:22.029]                           computeRestarts <- base::computeRestarts
[10:19:22.029]                           grepl <- base::grepl
[10:19:22.029]                           restarts <- computeRestarts(cond)
[10:19:22.029]                           for (restart in restarts) {
[10:19:22.029]                             name <- restart$name
[10:19:22.029]                             if (is.null(name)) 
[10:19:22.029]                               next
[10:19:22.029]                             if (!grepl(pattern, name)) 
[10:19:22.029]                               next
[10:19:22.029]                             invokeRestart(restart)
[10:19:22.029]                             muffled <- TRUE
[10:19:22.029]                             break
[10:19:22.029]                           }
[10:19:22.029]                         }
[10:19:22.029]                       }
[10:19:22.029]                       invisible(muffled)
[10:19:22.029]                     }
[10:19:22.029]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.029]                   }
[10:19:22.029]                 }
[10:19:22.029]                 else {
[10:19:22.029]                   if (TRUE) {
[10:19:22.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.029]                     {
[10:19:22.029]                       inherits <- base::inherits
[10:19:22.029]                       invokeRestart <- base::invokeRestart
[10:19:22.029]                       is.null <- base::is.null
[10:19:22.029]                       muffled <- FALSE
[10:19:22.029]                       if (inherits(cond, "message")) {
[10:19:22.029]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.029]                         if (muffled) 
[10:19:22.029]                           invokeRestart("muffleMessage")
[10:19:22.029]                       }
[10:19:22.029]                       else if (inherits(cond, "warning")) {
[10:19:22.029]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.029]                         if (muffled) 
[10:19:22.029]                           invokeRestart("muffleWarning")
[10:19:22.029]                       }
[10:19:22.029]                       else if (inherits(cond, "condition")) {
[10:19:22.029]                         if (!is.null(pattern)) {
[10:19:22.029]                           computeRestarts <- base::computeRestarts
[10:19:22.029]                           grepl <- base::grepl
[10:19:22.029]                           restarts <- computeRestarts(cond)
[10:19:22.029]                           for (restart in restarts) {
[10:19:22.029]                             name <- restart$name
[10:19:22.029]                             if (is.null(name)) 
[10:19:22.029]                               next
[10:19:22.029]                             if (!grepl(pattern, name)) 
[10:19:22.029]                               next
[10:19:22.029]                             invokeRestart(restart)
[10:19:22.029]                             muffled <- TRUE
[10:19:22.029]                             break
[10:19:22.029]                           }
[10:19:22.029]                         }
[10:19:22.029]                       }
[10:19:22.029]                       invisible(muffled)
[10:19:22.029]                     }
[10:19:22.029]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.029]                   }
[10:19:22.029]                 }
[10:19:22.029]             }
[10:19:22.029]         }))
[10:19:22.029]     }, error = function(ex) {
[10:19:22.029]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.029]                 ...future.rng), started = ...future.startTime, 
[10:19:22.029]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.029]             version = "1.8"), class = "FutureResult")
[10:19:22.029]     }, finally = {
[10:19:22.029]         if (!identical(...future.workdir, getwd())) 
[10:19:22.029]             setwd(...future.workdir)
[10:19:22.029]         {
[10:19:22.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.029]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.029]             }
[10:19:22.029]             base::options(...future.oldOptions)
[10:19:22.029]             if (.Platform$OS.type == "windows") {
[10:19:22.029]                 old_names <- names(...future.oldEnvVars)
[10:19:22.029]                 envs <- base::Sys.getenv()
[10:19:22.029]                 names <- names(envs)
[10:19:22.029]                 common <- intersect(names, old_names)
[10:19:22.029]                 added <- setdiff(names, old_names)
[10:19:22.029]                 removed <- setdiff(old_names, names)
[10:19:22.029]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.029]                   envs[common]]
[10:19:22.029]                 NAMES <- toupper(changed)
[10:19:22.029]                 args <- list()
[10:19:22.029]                 for (kk in seq_along(NAMES)) {
[10:19:22.029]                   name <- changed[[kk]]
[10:19:22.029]                   NAME <- NAMES[[kk]]
[10:19:22.029]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.029]                     next
[10:19:22.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.029]                 }
[10:19:22.029]                 NAMES <- toupper(added)
[10:19:22.029]                 for (kk in seq_along(NAMES)) {
[10:19:22.029]                   name <- added[[kk]]
[10:19:22.029]                   NAME <- NAMES[[kk]]
[10:19:22.029]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.029]                     next
[10:19:22.029]                   args[[name]] <- ""
[10:19:22.029]                 }
[10:19:22.029]                 NAMES <- toupper(removed)
[10:19:22.029]                 for (kk in seq_along(NAMES)) {
[10:19:22.029]                   name <- removed[[kk]]
[10:19:22.029]                   NAME <- NAMES[[kk]]
[10:19:22.029]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.029]                     next
[10:19:22.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.029]                 }
[10:19:22.029]                 if (length(args) > 0) 
[10:19:22.029]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.029]             }
[10:19:22.029]             else {
[10:19:22.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.029]             }
[10:19:22.029]             {
[10:19:22.029]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.029]                   0L) {
[10:19:22.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.029]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.029]                   base::options(opts)
[10:19:22.029]                 }
[10:19:22.029]                 {
[10:19:22.029]                   {
[10:19:22.029]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.029]                     NULL
[10:19:22.029]                   }
[10:19:22.029]                   options(future.plan = NULL)
[10:19:22.029]                   if (is.na(NA_character_)) 
[10:19:22.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.029]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.029]                     .init = FALSE)
[10:19:22.029]                 }
[10:19:22.029]             }
[10:19:22.029]         }
[10:19:22.029]     })
[10:19:22.029]     if (TRUE) {
[10:19:22.029]         base::sink(type = "output", split = FALSE)
[10:19:22.029]         if (TRUE) {
[10:19:22.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.029]         }
[10:19:22.029]         else {
[10:19:22.029]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.029]         }
[10:19:22.029]         base::close(...future.stdout)
[10:19:22.029]         ...future.stdout <- NULL
[10:19:22.029]     }
[10:19:22.029]     ...future.result$conditions <- ...future.conditions
[10:19:22.029]     ...future.result$finished <- base::Sys.time()
[10:19:22.029]     ...future.result
[10:19:22.029] }
[10:19:22.033] assign_globals() ...
[10:19:22.033] List of 5
[10:19:22.033]  $ ...future.FUN            :function (C, k)  
[10:19:22.033]  $ MoreArgs                 : NULL
[10:19:22.033]  $ ...future.elements_ii    :List of 2
[10:19:22.033]   ..$ :List of 1
[10:19:22.033]   .. ..$ : chr "E"
[10:19:22.033]   ..$ :List of 1
[10:19:22.033]   .. ..$ : int 1
[10:19:22.033]  $ ...future.seeds_ii       : NULL
[10:19:22.033]  $ ...future.globals.maxSize: NULL
[10:19:22.033]  - attr(*, "where")=List of 5
[10:19:22.033]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.033]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.033]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.033]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.033]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.033]  - attr(*, "resolved")= logi FALSE
[10:19:22.033]  - attr(*, "total_size")= num 847
[10:19:22.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.033]  - attr(*, "already-done")= logi TRUE
[10:19:22.045] - reassign environment for ‘...future.FUN’
[10:19:22.045] - copied ‘...future.FUN’ to environment
[10:19:22.045] - copied ‘MoreArgs’ to environment
[10:19:22.045] - copied ‘...future.elements_ii’ to environment
[10:19:22.045] - copied ‘...future.seeds_ii’ to environment
[10:19:22.045] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.045] assign_globals() ... done
[10:19:22.046] requestCore(): workers = 2
[10:19:22.046] Poll #1 (0): usedCores() = 2, workers = 2
[10:19:22.057] result() for MulticoreFuture ...
[10:19:22.058] result() for MulticoreFuture ...
[10:19:22.058] result() for MulticoreFuture ... done
[10:19:22.058] result() for MulticoreFuture ... done
[10:19:22.058] result() for MulticoreFuture ...
[10:19:22.059] result() for MulticoreFuture ... done
[10:19:22.062] MulticoreFuture started
[10:19:22.063] - Launch lazy future ... done
[10:19:22.063] plan(): Setting new future strategy stack:
[10:19:22.063] run() for ‘MulticoreFuture’ ... done
[10:19:22.064] Created future:
[10:19:22.064] List of future strategies:
[10:19:22.064] 1. sequential:
[10:19:22.064]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.064]    - tweaked: FALSE
[10:19:22.064]    - call: NULL
[10:19:22.066] plan(): nbrOfWorkers() = 1
[10:19:22.069] plan(): Setting new future strategy stack:
[10:19:22.069] List of future strategies:
[10:19:22.069] 1. multicore:
[10:19:22.069]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.069]    - tweaked: FALSE
[10:19:22.069]    - call: plan(strategy)
[10:19:22.073] plan(): nbrOfWorkers() = 2
[10:19:22.064] MulticoreFuture:
[10:19:22.064] Label: ‘future_mapply-5’
[10:19:22.064] Expression:
[10:19:22.064] {
[10:19:22.064]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.064]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.064]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.064]         on.exit(options(oopts), add = TRUE)
[10:19:22.064]     }
[10:19:22.064]     {
[10:19:22.064]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.064]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.064]         do.call(mapply, args = args)
[10:19:22.064]     }
[10:19:22.064] }
[10:19:22.064] Lazy evaluation: FALSE
[10:19:22.064] Asynchronous evaluation: TRUE
[10:19:22.064] Local evaluation: TRUE
[10:19:22.064] Environment: R_GlobalEnv
[10:19:22.064] Capture standard output: TRUE
[10:19:22.064] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.064] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.064] Packages: <none>
[10:19:22.064] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.064] Resolved: TRUE
[10:19:22.064] Value: <not collected>
[10:19:22.064] Conditions captured: <none>
[10:19:22.064] Early signaling: FALSE
[10:19:22.064] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.064] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.075] Chunk #5 of 5 ... DONE
[10:19:22.075] Launching 5 futures (chunks) ... DONE
[10:19:22.075] Resolving 5 futures (chunks) ...
[10:19:22.075] resolve() on list ...
[10:19:22.076]  recursive: 0
[10:19:22.076]  length: 5
[10:19:22.076] 
[10:19:22.076] Future #1
[10:19:22.076] result() for MulticoreFuture ...
[10:19:22.077] result() for MulticoreFuture ... done
[10:19:22.077] result() for MulticoreFuture ...
[10:19:22.077] result() for MulticoreFuture ... done
[10:19:22.077] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:22.077] - nx: 5
[10:19:22.077] - relay: TRUE
[10:19:22.078] - stdout: TRUE
[10:19:22.078] - signal: TRUE
[10:19:22.078] - resignal: FALSE
[10:19:22.078] - force: TRUE
[10:19:22.078] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:19:22.078] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:19:22.079]  - until=1
[10:19:22.079]  - relaying element #1
[10:19:22.079] result() for MulticoreFuture ...
[10:19:22.079] result() for MulticoreFuture ... done
[10:19:22.079] result() for MulticoreFuture ...
[10:19:22.079] result() for MulticoreFuture ... done
[10:19:22.080] result() for MulticoreFuture ...
[10:19:22.080] result() for MulticoreFuture ... done
[10:19:22.080] result() for MulticoreFuture ...
[10:19:22.080] result() for MulticoreFuture ... done
[10:19:22.080] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:22.081] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:22.081] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:22.081]  length: 4 (resolved future 1)
[10:19:22.081] Future #2
[10:19:22.081] result() for MulticoreFuture ...
[10:19:22.081] result() for MulticoreFuture ... done
[10:19:22.082] result() for MulticoreFuture ...
[10:19:22.082] result() for MulticoreFuture ... done
[10:19:22.082] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:22.082] - nx: 5
[10:19:22.082] - relay: TRUE
[10:19:22.082] - stdout: TRUE
[10:19:22.082] - signal: TRUE
[10:19:22.082] - resignal: FALSE
[10:19:22.082] - force: TRUE
[10:19:22.083] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:22.083] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:22.083]  - until=2
[10:19:22.083]  - relaying element #2
[10:19:22.083] result() for MulticoreFuture ...
[10:19:22.083] result() for MulticoreFuture ... done
[10:19:22.083] result() for MulticoreFuture ...
[10:19:22.083] result() for MulticoreFuture ... done
[10:19:22.084] result() for MulticoreFuture ...
[10:19:22.084] result() for MulticoreFuture ... done
[10:19:22.084] result() for MulticoreFuture ...
[10:19:22.084] result() for MulticoreFuture ... done
[10:19:22.084] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:22.084] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:22.084] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:22.085]  length: 3 (resolved future 2)
[10:19:22.085] Future #3
[10:19:22.085] result() for MulticoreFuture ...
[10:19:22.085] result() for MulticoreFuture ... done
[10:19:22.085] result() for MulticoreFuture ...
[10:19:22.085] result() for MulticoreFuture ... done
[10:19:22.085] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:19:22.086] - nx: 5
[10:19:22.086] - relay: TRUE
[10:19:22.086] - stdout: TRUE
[10:19:22.086] - signal: TRUE
[10:19:22.086] - resignal: FALSE
[10:19:22.086] - force: TRUE
[10:19:22.086] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:22.086] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:22.086]  - until=3
[10:19:22.087]  - relaying element #3
[10:19:22.087] result() for MulticoreFuture ...
[10:19:22.087] result() for MulticoreFuture ... done
[10:19:22.087] result() for MulticoreFuture ...
[10:19:22.087] result() for MulticoreFuture ... done
[10:19:22.087] result() for MulticoreFuture ...
[10:19:22.087] result() for MulticoreFuture ... done
[10:19:22.087] result() for MulticoreFuture ...
[10:19:22.088] result() for MulticoreFuture ... done
[10:19:22.088] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:22.088] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:22.088] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:19:22.088]  length: 2 (resolved future 3)
[10:19:22.088] Future #4
[10:19:22.089] result() for MulticoreFuture ...
[10:19:22.089] result() for MulticoreFuture ...
[10:19:22.090] result() for MulticoreFuture ... done
[10:19:22.090] result() for MulticoreFuture ... done
[10:19:22.090] result() for MulticoreFuture ...
[10:19:22.090] result() for MulticoreFuture ... done
[10:19:22.090] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:19:22.090] - nx: 5
[10:19:22.091] - relay: TRUE
[10:19:22.091] - stdout: TRUE
[10:19:22.091] - signal: TRUE
[10:19:22.091] - resignal: FALSE
[10:19:22.091] - force: TRUE
[10:19:22.091] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:22.092] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:22.092]  - until=4
[10:19:22.092]  - relaying element #4
[10:19:22.092] result() for MulticoreFuture ...
[10:19:22.092] result() for MulticoreFuture ... done
[10:19:22.092] result() for MulticoreFuture ...
[10:19:22.093] result() for MulticoreFuture ... done
[10:19:22.093] result() for MulticoreFuture ...
[10:19:22.093] result() for MulticoreFuture ... done
[10:19:22.093] result() for MulticoreFuture ...
[10:19:22.093] result() for MulticoreFuture ... done
[10:19:22.093] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:22.094] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:22.094] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:19:22.094]  length: 1 (resolved future 4)
[10:19:22.094] Future #5
[10:19:22.095] result() for MulticoreFuture ...
[10:19:22.095] result() for MulticoreFuture ...
[10:19:22.095] result() for MulticoreFuture ... done
[10:19:22.095] result() for MulticoreFuture ... done
[10:19:22.096] result() for MulticoreFuture ...
[10:19:22.096] result() for MulticoreFuture ... done
[10:19:22.096] signalConditionsASAP(MulticoreFuture, pos=5) ...
[10:19:22.096] - nx: 5
[10:19:22.096] - relay: TRUE
[10:19:22.096] - stdout: TRUE
[10:19:22.096] - signal: TRUE
[10:19:22.096] - resignal: FALSE
[10:19:22.097] - force: TRUE
[10:19:22.097] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:22.097] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:22.097]  - until=5
[10:19:22.097]  - relaying element #5
[10:19:22.097] result() for MulticoreFuture ...
[10:19:22.097] result() for MulticoreFuture ... done
[10:19:22.097] result() for MulticoreFuture ...
[10:19:22.097] result() for MulticoreFuture ... done
[10:19:22.100] result() for MulticoreFuture ...
[10:19:22.100] result() for MulticoreFuture ... done
[10:19:22.100] result() for MulticoreFuture ...
[10:19:22.100] result() for MulticoreFuture ... done
[10:19:22.101] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:22.101] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:22.101] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[10:19:22.101]  length: 0 (resolved future 5)
[10:19:22.101] Relaying remaining futures
[10:19:22.101] signalConditionsASAP(NULL, pos=0) ...
[10:19:22.101] - nx: 5
[10:19:22.102] - relay: TRUE
[10:19:22.102] - stdout: TRUE
[10:19:22.102] - signal: TRUE
[10:19:22.102] - resignal: FALSE
[10:19:22.102] - force: TRUE
[10:19:22.102] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:22.102] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[10:19:22.102] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:22.103] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:22.103] signalConditionsASAP(NULL, pos=0) ... done
[10:19:22.103] resolve() on list ... DONE
[10:19:22.103] result() for MulticoreFuture ...
[10:19:22.103] result() for MulticoreFuture ... done
[10:19:22.103] result() for MulticoreFuture ...
[10:19:22.103] result() for MulticoreFuture ... done
[10:19:22.104] result() for MulticoreFuture ...
[10:19:22.104] result() for MulticoreFuture ... done
[10:19:22.104] result() for MulticoreFuture ...
[10:19:22.104] result() for MulticoreFuture ... done
[10:19:22.104] result() for MulticoreFuture ...
[10:19:22.104] result() for MulticoreFuture ... done
[10:19:22.104] result() for MulticoreFuture ...
[10:19:22.104] result() for MulticoreFuture ... done
[10:19:22.105] result() for MulticoreFuture ...
[10:19:22.105] result() for MulticoreFuture ... done
[10:19:22.105] result() for MulticoreFuture ...
[10:19:22.105] result() for MulticoreFuture ... done
[10:19:22.105] result() for MulticoreFuture ...
[10:19:22.105] result() for MulticoreFuture ... done
[10:19:22.105] result() for MulticoreFuture ...
[10:19:22.105] result() for MulticoreFuture ... done
[10:19:22.106]  - Number of value chunks collected: 5
[10:19:22.106] Resolving 5 futures (chunks) ... DONE
[10:19:22.106] Reducing values from 5 chunks ...
[10:19:22.106]  - Number of values collected after concatenation: 5
[10:19:22.106]  - Number of values expected: 5
[10:19:22.106] Reducing values from 5 chunks ... DONE
[10:19:22.106] future_mapply() ... DONE
[10:19:22.107] future_mapply() ...
[10:19:22.109] Number of chunks: 2
[10:19:22.109] getGlobalsAndPackagesXApply() ...
[10:19:22.109]  - future.globals: TRUE
[10:19:22.109] getGlobalsAndPackages() ...
[10:19:22.109] Searching for globals...
[10:19:22.111] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:22.111] Searching for globals ... DONE
[10:19:22.111] Resolving globals: FALSE
[10:19:22.111] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:22.112] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:22.112] - globals: [1] ‘FUN’
[10:19:22.112] 
[10:19:22.112] getGlobalsAndPackages() ... DONE
[10:19:22.112]  - globals found/used: [n=1] ‘FUN’
[10:19:22.112]  - needed namespaces: [n=0] 
[10:19:22.112] Finding globals ... DONE
[10:19:22.112] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:22.113] List of 2
[10:19:22.113]  $ ...future.FUN:function (C, k)  
[10:19:22.113]  $ MoreArgs     : list()
[10:19:22.113]  - attr(*, "where")=List of 2
[10:19:22.113]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:22.113]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:22.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.113]  - attr(*, "resolved")= logi FALSE
[10:19:22.113]  - attr(*, "total_size")= num NA
[10:19:22.115] Packages to be attached in all futures: [n=0] 
[10:19:22.115] getGlobalsAndPackagesXApply() ... DONE
[10:19:22.115] Number of futures (= number of chunks): 2
[10:19:22.116] Launching 2 futures (chunks) ...
[10:19:22.116] Chunk #1 of 2 ...
[10:19:22.116]  - Finding globals in '...' for chunk #1 ...
[10:19:22.116] getGlobalsAndPackages() ...
[10:19:22.116] Searching for globals...
[10:19:22.116] 
[10:19:22.117] Searching for globals ... DONE
[10:19:22.117] - globals: [0] <none>
[10:19:22.117] getGlobalsAndPackages() ... DONE
[10:19:22.117]    + additional globals found: [n=0] 
[10:19:22.117]    + additional namespaces needed: [n=0] 
[10:19:22.117]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:22.117]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.117]  - seeds: <none>
[10:19:22.117]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.117] getGlobalsAndPackages() ...
[10:19:22.117] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.118] Resolving globals: FALSE
[10:19:22.118] The total size of the 5 globals is 880 bytes (880 bytes)
[10:19:22.118] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:22.119] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.119] 
[10:19:22.119] getGlobalsAndPackages() ... DONE
[10:19:22.119] run() for ‘Future’ ...
[10:19:22.119] - state: ‘created’
[10:19:22.119] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.121] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.121] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.121]   - Field: ‘label’
[10:19:22.121]   - Field: ‘local’
[10:19:22.121]   - Field: ‘owner’
[10:19:22.122]   - Field: ‘envir’
[10:19:22.122]   - Field: ‘workers’
[10:19:22.122]   - Field: ‘packages’
[10:19:22.122]   - Field: ‘gc’
[10:19:22.122]   - Field: ‘job’
[10:19:22.122]   - Field: ‘conditions’
[10:19:22.122]   - Field: ‘expr’
[10:19:22.122]   - Field: ‘uuid’
[10:19:22.122]   - Field: ‘seed’
[10:19:22.122]   - Field: ‘version’
[10:19:22.122]   - Field: ‘result’
[10:19:22.123]   - Field: ‘asynchronous’
[10:19:22.123]   - Field: ‘calls’
[10:19:22.123]   - Field: ‘globals’
[10:19:22.123]   - Field: ‘stdout’
[10:19:22.123]   - Field: ‘earlySignal’
[10:19:22.123]   - Field: ‘lazy’
[10:19:22.125]   - Field: ‘state’
[10:19:22.125] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.125] - Launch lazy future ...
[10:19:22.126] Packages needed by the future expression (n = 0): <none>
[10:19:22.126] Packages needed by future strategies (n = 0): <none>
[10:19:22.126] {
[10:19:22.126]     {
[10:19:22.126]         {
[10:19:22.126]             ...future.startTime <- base::Sys.time()
[10:19:22.126]             {
[10:19:22.126]                 {
[10:19:22.126]                   {
[10:19:22.126]                     {
[10:19:22.126]                       base::local({
[10:19:22.126]                         has_future <- base::requireNamespace("future", 
[10:19:22.126]                           quietly = TRUE)
[10:19:22.126]                         if (has_future) {
[10:19:22.126]                           ns <- base::getNamespace("future")
[10:19:22.126]                           version <- ns[[".package"]][["version"]]
[10:19:22.126]                           if (is.null(version)) 
[10:19:22.126]                             version <- utils::packageVersion("future")
[10:19:22.126]                         }
[10:19:22.126]                         else {
[10:19:22.126]                           version <- NULL
[10:19:22.126]                         }
[10:19:22.126]                         if (!has_future || version < "1.8.0") {
[10:19:22.126]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.126]                             "", base::R.version$version.string), 
[10:19:22.126]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.126]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.126]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.126]                               "release", "version")], collapse = " "), 
[10:19:22.126]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.126]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.126]                             info)
[10:19:22.126]                           info <- base::paste(info, collapse = "; ")
[10:19:22.126]                           if (!has_future) {
[10:19:22.126]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.126]                               info)
[10:19:22.126]                           }
[10:19:22.126]                           else {
[10:19:22.126]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.126]                               info, version)
[10:19:22.126]                           }
[10:19:22.126]                           base::stop(msg)
[10:19:22.126]                         }
[10:19:22.126]                       })
[10:19:22.126]                     }
[10:19:22.126]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.126]                     base::options(mc.cores = 1L)
[10:19:22.126]                   }
[10:19:22.126]                   ...future.strategy.old <- future::plan("list")
[10:19:22.126]                   options(future.plan = NULL)
[10:19:22.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.126]                 }
[10:19:22.126]                 ...future.workdir <- getwd()
[10:19:22.126]             }
[10:19:22.126]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.126]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.126]         }
[10:19:22.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.126]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.126]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.126]             base::names(...future.oldOptions))
[10:19:22.126]     }
[10:19:22.126]     if (FALSE) {
[10:19:22.126]     }
[10:19:22.126]     else {
[10:19:22.126]         if (TRUE) {
[10:19:22.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.126]                 open = "w")
[10:19:22.126]         }
[10:19:22.126]         else {
[10:19:22.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.126]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.126]         }
[10:19:22.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.126]             base::sink(type = "output", split = FALSE)
[10:19:22.126]             base::close(...future.stdout)
[10:19:22.126]         }, add = TRUE)
[10:19:22.126]     }
[10:19:22.126]     ...future.frame <- base::sys.nframe()
[10:19:22.126]     ...future.conditions <- base::list()
[10:19:22.126]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.126]     if (FALSE) {
[10:19:22.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.126]     }
[10:19:22.126]     ...future.result <- base::tryCatch({
[10:19:22.126]         base::withCallingHandlers({
[10:19:22.126]             ...future.value <- base::withVisible(base::local({
[10:19:22.126]                 withCallingHandlers({
[10:19:22.126]                   {
[10:19:22.126]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.126]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.126]                       ...future.globals.maxSize)) {
[10:19:22.126]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.126]                       on.exit(options(oopts), add = TRUE)
[10:19:22.126]                     }
[10:19:22.126]                     {
[10:19:22.126]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.126]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.126]                         USE.NAMES = FALSE)
[10:19:22.126]                       do.call(mapply, args = args)
[10:19:22.126]                     }
[10:19:22.126]                   }
[10:19:22.126]                 }, immediateCondition = function(cond) {
[10:19:22.126]                   save_rds <- function (object, pathname, ...) 
[10:19:22.126]                   {
[10:19:22.126]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.126]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.126]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.126]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.126]                         fi_tmp[["mtime"]])
[10:19:22.126]                     }
[10:19:22.126]                     tryCatch({
[10:19:22.126]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.126]                     }, error = function(ex) {
[10:19:22.126]                       msg <- conditionMessage(ex)
[10:19:22.126]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.126]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.126]                         fi_tmp[["mtime"]], msg)
[10:19:22.126]                       ex$message <- msg
[10:19:22.126]                       stop(ex)
[10:19:22.126]                     })
[10:19:22.126]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.126]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.126]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.126]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.126]                       fi <- file.info(pathname)
[10:19:22.126]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.126]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.126]                         fi[["size"]], fi[["mtime"]])
[10:19:22.126]                       stop(msg)
[10:19:22.126]                     }
[10:19:22.126]                     invisible(pathname)
[10:19:22.126]                   }
[10:19:22.126]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.126]                     rootPath = tempdir()) 
[10:19:22.126]                   {
[10:19:22.126]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.126]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.126]                       tmpdir = path, fileext = ".rds")
[10:19:22.126]                     save_rds(obj, file)
[10:19:22.126]                   }
[10:19:22.126]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.126]                   {
[10:19:22.126]                     inherits <- base::inherits
[10:19:22.126]                     invokeRestart <- base::invokeRestart
[10:19:22.126]                     is.null <- base::is.null
[10:19:22.126]                     muffled <- FALSE
[10:19:22.126]                     if (inherits(cond, "message")) {
[10:19:22.126]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.126]                       if (muffled) 
[10:19:22.126]                         invokeRestart("muffleMessage")
[10:19:22.126]                     }
[10:19:22.126]                     else if (inherits(cond, "warning")) {
[10:19:22.126]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.126]                       if (muffled) 
[10:19:22.126]                         invokeRestart("muffleWarning")
[10:19:22.126]                     }
[10:19:22.126]                     else if (inherits(cond, "condition")) {
[10:19:22.126]                       if (!is.null(pattern)) {
[10:19:22.126]                         computeRestarts <- base::computeRestarts
[10:19:22.126]                         grepl <- base::grepl
[10:19:22.126]                         restarts <- computeRestarts(cond)
[10:19:22.126]                         for (restart in restarts) {
[10:19:22.126]                           name <- restart$name
[10:19:22.126]                           if (is.null(name)) 
[10:19:22.126]                             next
[10:19:22.126]                           if (!grepl(pattern, name)) 
[10:19:22.126]                             next
[10:19:22.126]                           invokeRestart(restart)
[10:19:22.126]                           muffled <- TRUE
[10:19:22.126]                           break
[10:19:22.126]                         }
[10:19:22.126]                       }
[10:19:22.126]                     }
[10:19:22.126]                     invisible(muffled)
[10:19:22.126]                   }
[10:19:22.126]                   muffleCondition(cond)
[10:19:22.126]                 })
[10:19:22.126]             }))
[10:19:22.126]             future::FutureResult(value = ...future.value$value, 
[10:19:22.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.126]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.126]                     ...future.globalenv.names))
[10:19:22.126]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.126]         }, condition = base::local({
[10:19:22.126]             c <- base::c
[10:19:22.126]             inherits <- base::inherits
[10:19:22.126]             invokeRestart <- base::invokeRestart
[10:19:22.126]             length <- base::length
[10:19:22.126]             list <- base::list
[10:19:22.126]             seq.int <- base::seq.int
[10:19:22.126]             signalCondition <- base::signalCondition
[10:19:22.126]             sys.calls <- base::sys.calls
[10:19:22.126]             `[[` <- base::`[[`
[10:19:22.126]             `+` <- base::`+`
[10:19:22.126]             `<<-` <- base::`<<-`
[10:19:22.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.126]                   3L)]
[10:19:22.126]             }
[10:19:22.126]             function(cond) {
[10:19:22.126]                 is_error <- inherits(cond, "error")
[10:19:22.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.126]                   NULL)
[10:19:22.126]                 if (is_error) {
[10:19:22.126]                   sessionInformation <- function() {
[10:19:22.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.126]                       search = base::search(), system = base::Sys.info())
[10:19:22.126]                   }
[10:19:22.126]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.126]                     cond$call), session = sessionInformation(), 
[10:19:22.126]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.126]                   signalCondition(cond)
[10:19:22.126]                 }
[10:19:22.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.126]                 "immediateCondition"))) {
[10:19:22.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.126]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.126]                   if (TRUE && !signal) {
[10:19:22.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.126]                     {
[10:19:22.126]                       inherits <- base::inherits
[10:19:22.126]                       invokeRestart <- base::invokeRestart
[10:19:22.126]                       is.null <- base::is.null
[10:19:22.126]                       muffled <- FALSE
[10:19:22.126]                       if (inherits(cond, "message")) {
[10:19:22.126]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.126]                         if (muffled) 
[10:19:22.126]                           invokeRestart("muffleMessage")
[10:19:22.126]                       }
[10:19:22.126]                       else if (inherits(cond, "warning")) {
[10:19:22.126]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.126]                         if (muffled) 
[10:19:22.126]                           invokeRestart("muffleWarning")
[10:19:22.126]                       }
[10:19:22.126]                       else if (inherits(cond, "condition")) {
[10:19:22.126]                         if (!is.null(pattern)) {
[10:19:22.126]                           computeRestarts <- base::computeRestarts
[10:19:22.126]                           grepl <- base::grepl
[10:19:22.126]                           restarts <- computeRestarts(cond)
[10:19:22.126]                           for (restart in restarts) {
[10:19:22.126]                             name <- restart$name
[10:19:22.126]                             if (is.null(name)) 
[10:19:22.126]                               next
[10:19:22.126]                             if (!grepl(pattern, name)) 
[10:19:22.126]                               next
[10:19:22.126]                             invokeRestart(restart)
[10:19:22.126]                             muffled <- TRUE
[10:19:22.126]                             break
[10:19:22.126]                           }
[10:19:22.126]                         }
[10:19:22.126]                       }
[10:19:22.126]                       invisible(muffled)
[10:19:22.126]                     }
[10:19:22.126]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.126]                   }
[10:19:22.126]                 }
[10:19:22.126]                 else {
[10:19:22.126]                   if (TRUE) {
[10:19:22.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.126]                     {
[10:19:22.126]                       inherits <- base::inherits
[10:19:22.126]                       invokeRestart <- base::invokeRestart
[10:19:22.126]                       is.null <- base::is.null
[10:19:22.126]                       muffled <- FALSE
[10:19:22.126]                       if (inherits(cond, "message")) {
[10:19:22.126]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.126]                         if (muffled) 
[10:19:22.126]                           invokeRestart("muffleMessage")
[10:19:22.126]                       }
[10:19:22.126]                       else if (inherits(cond, "warning")) {
[10:19:22.126]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.126]                         if (muffled) 
[10:19:22.126]                           invokeRestart("muffleWarning")
[10:19:22.126]                       }
[10:19:22.126]                       else if (inherits(cond, "condition")) {
[10:19:22.126]                         if (!is.null(pattern)) {
[10:19:22.126]                           computeRestarts <- base::computeRestarts
[10:19:22.126]                           grepl <- base::grepl
[10:19:22.126]                           restarts <- computeRestarts(cond)
[10:19:22.126]                           for (restart in restarts) {
[10:19:22.126]                             name <- restart$name
[10:19:22.126]                             if (is.null(name)) 
[10:19:22.126]                               next
[10:19:22.126]                             if (!grepl(pattern, name)) 
[10:19:22.126]                               next
[10:19:22.126]                             invokeRestart(restart)
[10:19:22.126]                             muffled <- TRUE
[10:19:22.126]                             break
[10:19:22.126]                           }
[10:19:22.126]                         }
[10:19:22.126]                       }
[10:19:22.126]                       invisible(muffled)
[10:19:22.126]                     }
[10:19:22.126]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.126]                   }
[10:19:22.126]                 }
[10:19:22.126]             }
[10:19:22.126]         }))
[10:19:22.126]     }, error = function(ex) {
[10:19:22.126]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.126]                 ...future.rng), started = ...future.startTime, 
[10:19:22.126]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.126]             version = "1.8"), class = "FutureResult")
[10:19:22.126]     }, finally = {
[10:19:22.126]         if (!identical(...future.workdir, getwd())) 
[10:19:22.126]             setwd(...future.workdir)
[10:19:22.126]         {
[10:19:22.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.126]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.126]             }
[10:19:22.126]             base::options(...future.oldOptions)
[10:19:22.126]             if (.Platform$OS.type == "windows") {
[10:19:22.126]                 old_names <- names(...future.oldEnvVars)
[10:19:22.126]                 envs <- base::Sys.getenv()
[10:19:22.126]                 names <- names(envs)
[10:19:22.126]                 common <- intersect(names, old_names)
[10:19:22.126]                 added <- setdiff(names, old_names)
[10:19:22.126]                 removed <- setdiff(old_names, names)
[10:19:22.126]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.126]                   envs[common]]
[10:19:22.126]                 NAMES <- toupper(changed)
[10:19:22.126]                 args <- list()
[10:19:22.126]                 for (kk in seq_along(NAMES)) {
[10:19:22.126]                   name <- changed[[kk]]
[10:19:22.126]                   NAME <- NAMES[[kk]]
[10:19:22.126]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.126]                     next
[10:19:22.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.126]                 }
[10:19:22.126]                 NAMES <- toupper(added)
[10:19:22.126]                 for (kk in seq_along(NAMES)) {
[10:19:22.126]                   name <- added[[kk]]
[10:19:22.126]                   NAME <- NAMES[[kk]]
[10:19:22.126]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.126]                     next
[10:19:22.126]                   args[[name]] <- ""
[10:19:22.126]                 }
[10:19:22.126]                 NAMES <- toupper(removed)
[10:19:22.126]                 for (kk in seq_along(NAMES)) {
[10:19:22.126]                   name <- removed[[kk]]
[10:19:22.126]                   NAME <- NAMES[[kk]]
[10:19:22.126]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.126]                     next
[10:19:22.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.126]                 }
[10:19:22.126]                 if (length(args) > 0) 
[10:19:22.126]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.126]             }
[10:19:22.126]             else {
[10:19:22.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.126]             }
[10:19:22.126]             {
[10:19:22.126]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.126]                   0L) {
[10:19:22.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.126]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.126]                   base::options(opts)
[10:19:22.126]                 }
[10:19:22.126]                 {
[10:19:22.126]                   {
[10:19:22.126]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.126]                     NULL
[10:19:22.126]                   }
[10:19:22.126]                   options(future.plan = NULL)
[10:19:22.126]                   if (is.na(NA_character_)) 
[10:19:22.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.126]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.126]                     .init = FALSE)
[10:19:22.126]                 }
[10:19:22.126]             }
[10:19:22.126]         }
[10:19:22.126]     })
[10:19:22.126]     if (TRUE) {
[10:19:22.126]         base::sink(type = "output", split = FALSE)
[10:19:22.126]         if (TRUE) {
[10:19:22.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.126]         }
[10:19:22.126]         else {
[10:19:22.126]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.126]         }
[10:19:22.126]         base::close(...future.stdout)
[10:19:22.126]         ...future.stdout <- NULL
[10:19:22.126]     }
[10:19:22.126]     ...future.result$conditions <- ...future.conditions
[10:19:22.126]     ...future.result$finished <- base::Sys.time()
[10:19:22.126]     ...future.result
[10:19:22.126] }
[10:19:22.129] assign_globals() ...
[10:19:22.129] List of 5
[10:19:22.129]  $ ...future.FUN            :function (C, k)  
[10:19:22.129]  $ MoreArgs                 : list()
[10:19:22.129]  $ ...future.elements_ii    :List of 2
[10:19:22.129]   ..$ :List of 2
[10:19:22.129]   .. ..$ : chr "A"
[10:19:22.129]   .. ..$ : chr "B"
[10:19:22.129]   ..$ :List of 2
[10:19:22.129]   .. ..$ : int 5
[10:19:22.129]   .. ..$ : int 4
[10:19:22.129]  $ ...future.seeds_ii       : NULL
[10:19:22.129]  $ ...future.globals.maxSize: NULL
[10:19:22.129]  - attr(*, "where")=List of 5
[10:19:22.129]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.129]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.129]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.129]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.129]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.129]  - attr(*, "resolved")= logi FALSE
[10:19:22.129]  - attr(*, "total_size")= num 880
[10:19:22.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.129]  - attr(*, "already-done")= logi TRUE
[10:19:22.135] - reassign environment for ‘...future.FUN’
[10:19:22.135] - copied ‘...future.FUN’ to environment
[10:19:22.135] - copied ‘MoreArgs’ to environment
[10:19:22.135] - copied ‘...future.elements_ii’ to environment
[10:19:22.135] - copied ‘...future.seeds_ii’ to environment
[10:19:22.136] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.136] assign_globals() ... done
[10:19:22.136] requestCore(): workers = 2
[10:19:22.138] MulticoreFuture started
[10:19:22.139] - Launch lazy future ... done
[10:19:22.139] run() for ‘MulticoreFuture’ ... done
[10:19:22.139] Created future:
[10:19:22.139] plan(): Setting new future strategy stack:
[10:19:22.139] List of future strategies:
[10:19:22.139] 1. sequential:
[10:19:22.139]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.139]    - tweaked: FALSE
[10:19:22.139]    - call: NULL
[10:19:22.140] plan(): nbrOfWorkers() = 1
[10:19:22.143] plan(): Setting new future strategy stack:
[10:19:22.143] List of future strategies:
[10:19:22.143] 1. multicore:
[10:19:22.143]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.143]    - tweaked: FALSE
[10:19:22.143]    - call: plan(strategy)
[10:19:22.146] plan(): nbrOfWorkers() = 2
[10:19:22.139] MulticoreFuture:
[10:19:22.139] Label: ‘future_.mapply-1’
[10:19:22.139] Expression:
[10:19:22.139] {
[10:19:22.139]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.139]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.139]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.139]         on.exit(options(oopts), add = TRUE)
[10:19:22.139]     }
[10:19:22.139]     {
[10:19:22.139]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.139]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.139]         do.call(mapply, args = args)
[10:19:22.139]     }
[10:19:22.139] }
[10:19:22.139] Lazy evaluation: FALSE
[10:19:22.139] Asynchronous evaluation: TRUE
[10:19:22.139] Local evaluation: TRUE
[10:19:22.139] Environment: R_GlobalEnv
[10:19:22.139] Capture standard output: TRUE
[10:19:22.139] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.139] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.139] Packages: <none>
[10:19:22.139] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.139] Resolved: TRUE
[10:19:22.139] Value: <not collected>
[10:19:22.139] Conditions captured: <none>
[10:19:22.139] Early signaling: FALSE
[10:19:22.139] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.139] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.147] Chunk #1 of 2 ... DONE
[10:19:22.147] Chunk #2 of 2 ...
[10:19:22.148]  - Finding globals in '...' for chunk #2 ...
[10:19:22.148] getGlobalsAndPackages() ...
[10:19:22.148] Searching for globals...
[10:19:22.148] 
[10:19:22.149] Searching for globals ... DONE
[10:19:22.149] - globals: [0] <none>
[10:19:22.149] getGlobalsAndPackages() ... DONE
[10:19:22.149]    + additional globals found: [n=0] 
[10:19:22.149]    + additional namespaces needed: [n=0] 
[10:19:22.149]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:22.149]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.149]  - seeds: <none>
[10:19:22.150]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.150] getGlobalsAndPackages() ...
[10:19:22.150] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.150] Resolving globals: FALSE
[10:19:22.151] The total size of the 5 globals is 909 bytes (909 bytes)
[10:19:22.152] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:22.152] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.152] 
[10:19:22.152] getGlobalsAndPackages() ... DONE
[10:19:22.153] run() for ‘Future’ ...
[10:19:22.153] - state: ‘created’
[10:19:22.153] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.156] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.156] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.156]   - Field: ‘label’
[10:19:22.156]   - Field: ‘local’
[10:19:22.156]   - Field: ‘owner’
[10:19:22.156]   - Field: ‘envir’
[10:19:22.157]   - Field: ‘workers’
[10:19:22.157]   - Field: ‘packages’
[10:19:22.157]   - Field: ‘gc’
[10:19:22.157]   - Field: ‘job’
[10:19:22.157]   - Field: ‘conditions’
[10:19:22.157]   - Field: ‘expr’
[10:19:22.157]   - Field: ‘uuid’
[10:19:22.158]   - Field: ‘seed’
[10:19:22.158]   - Field: ‘version’
[10:19:22.158]   - Field: ‘result’
[10:19:22.158]   - Field: ‘asynchronous’
[10:19:22.158]   - Field: ‘calls’
[10:19:22.158]   - Field: ‘globals’
[10:19:22.159]   - Field: ‘stdout’
[10:19:22.159]   - Field: ‘earlySignal’
[10:19:22.159]   - Field: ‘lazy’
[10:19:22.159]   - Field: ‘state’
[10:19:22.159] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.159] - Launch lazy future ...
[10:19:22.160] Packages needed by the future expression (n = 0): <none>
[10:19:22.160] Packages needed by future strategies (n = 0): <none>
[10:19:22.161] {
[10:19:22.161]     {
[10:19:22.161]         {
[10:19:22.161]             ...future.startTime <- base::Sys.time()
[10:19:22.161]             {
[10:19:22.161]                 {
[10:19:22.161]                   {
[10:19:22.161]                     {
[10:19:22.161]                       base::local({
[10:19:22.161]                         has_future <- base::requireNamespace("future", 
[10:19:22.161]                           quietly = TRUE)
[10:19:22.161]                         if (has_future) {
[10:19:22.161]                           ns <- base::getNamespace("future")
[10:19:22.161]                           version <- ns[[".package"]][["version"]]
[10:19:22.161]                           if (is.null(version)) 
[10:19:22.161]                             version <- utils::packageVersion("future")
[10:19:22.161]                         }
[10:19:22.161]                         else {
[10:19:22.161]                           version <- NULL
[10:19:22.161]                         }
[10:19:22.161]                         if (!has_future || version < "1.8.0") {
[10:19:22.161]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.161]                             "", base::R.version$version.string), 
[10:19:22.161]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.161]                               "release", "version")], collapse = " "), 
[10:19:22.161]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.161]                             info)
[10:19:22.161]                           info <- base::paste(info, collapse = "; ")
[10:19:22.161]                           if (!has_future) {
[10:19:22.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.161]                               info)
[10:19:22.161]                           }
[10:19:22.161]                           else {
[10:19:22.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.161]                               info, version)
[10:19:22.161]                           }
[10:19:22.161]                           base::stop(msg)
[10:19:22.161]                         }
[10:19:22.161]                       })
[10:19:22.161]                     }
[10:19:22.161]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.161]                     base::options(mc.cores = 1L)
[10:19:22.161]                   }
[10:19:22.161]                   ...future.strategy.old <- future::plan("list")
[10:19:22.161]                   options(future.plan = NULL)
[10:19:22.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.161]                 }
[10:19:22.161]                 ...future.workdir <- getwd()
[10:19:22.161]             }
[10:19:22.161]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.161]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.161]         }
[10:19:22.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.161]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.161]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.161]             base::names(...future.oldOptions))
[10:19:22.161]     }
[10:19:22.161]     if (FALSE) {
[10:19:22.161]     }
[10:19:22.161]     else {
[10:19:22.161]         if (TRUE) {
[10:19:22.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.161]                 open = "w")
[10:19:22.161]         }
[10:19:22.161]         else {
[10:19:22.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.161]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.161]         }
[10:19:22.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.161]             base::sink(type = "output", split = FALSE)
[10:19:22.161]             base::close(...future.stdout)
[10:19:22.161]         }, add = TRUE)
[10:19:22.161]     }
[10:19:22.161]     ...future.frame <- base::sys.nframe()
[10:19:22.161]     ...future.conditions <- base::list()
[10:19:22.161]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.161]     if (FALSE) {
[10:19:22.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.161]     }
[10:19:22.161]     ...future.result <- base::tryCatch({
[10:19:22.161]         base::withCallingHandlers({
[10:19:22.161]             ...future.value <- base::withVisible(base::local({
[10:19:22.161]                 withCallingHandlers({
[10:19:22.161]                   {
[10:19:22.161]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.161]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.161]                       ...future.globals.maxSize)) {
[10:19:22.161]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.161]                       on.exit(options(oopts), add = TRUE)
[10:19:22.161]                     }
[10:19:22.161]                     {
[10:19:22.161]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.161]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.161]                         USE.NAMES = FALSE)
[10:19:22.161]                       do.call(mapply, args = args)
[10:19:22.161]                     }
[10:19:22.161]                   }
[10:19:22.161]                 }, immediateCondition = function(cond) {
[10:19:22.161]                   save_rds <- function (object, pathname, ...) 
[10:19:22.161]                   {
[10:19:22.161]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.161]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.161]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.161]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.161]                         fi_tmp[["mtime"]])
[10:19:22.161]                     }
[10:19:22.161]                     tryCatch({
[10:19:22.161]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.161]                     }, error = function(ex) {
[10:19:22.161]                       msg <- conditionMessage(ex)
[10:19:22.161]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.161]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.161]                         fi_tmp[["mtime"]], msg)
[10:19:22.161]                       ex$message <- msg
[10:19:22.161]                       stop(ex)
[10:19:22.161]                     })
[10:19:22.161]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.161]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.161]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.161]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.161]                       fi <- file.info(pathname)
[10:19:22.161]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.161]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.161]                         fi[["size"]], fi[["mtime"]])
[10:19:22.161]                       stop(msg)
[10:19:22.161]                     }
[10:19:22.161]                     invisible(pathname)
[10:19:22.161]                   }
[10:19:22.161]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.161]                     rootPath = tempdir()) 
[10:19:22.161]                   {
[10:19:22.161]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.161]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.161]                       tmpdir = path, fileext = ".rds")
[10:19:22.161]                     save_rds(obj, file)
[10:19:22.161]                   }
[10:19:22.161]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.161]                   {
[10:19:22.161]                     inherits <- base::inherits
[10:19:22.161]                     invokeRestart <- base::invokeRestart
[10:19:22.161]                     is.null <- base::is.null
[10:19:22.161]                     muffled <- FALSE
[10:19:22.161]                     if (inherits(cond, "message")) {
[10:19:22.161]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.161]                       if (muffled) 
[10:19:22.161]                         invokeRestart("muffleMessage")
[10:19:22.161]                     }
[10:19:22.161]                     else if (inherits(cond, "warning")) {
[10:19:22.161]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.161]                       if (muffled) 
[10:19:22.161]                         invokeRestart("muffleWarning")
[10:19:22.161]                     }
[10:19:22.161]                     else if (inherits(cond, "condition")) {
[10:19:22.161]                       if (!is.null(pattern)) {
[10:19:22.161]                         computeRestarts <- base::computeRestarts
[10:19:22.161]                         grepl <- base::grepl
[10:19:22.161]                         restarts <- computeRestarts(cond)
[10:19:22.161]                         for (restart in restarts) {
[10:19:22.161]                           name <- restart$name
[10:19:22.161]                           if (is.null(name)) 
[10:19:22.161]                             next
[10:19:22.161]                           if (!grepl(pattern, name)) 
[10:19:22.161]                             next
[10:19:22.161]                           invokeRestart(restart)
[10:19:22.161]                           muffled <- TRUE
[10:19:22.161]                           break
[10:19:22.161]                         }
[10:19:22.161]                       }
[10:19:22.161]                     }
[10:19:22.161]                     invisible(muffled)
[10:19:22.161]                   }
[10:19:22.161]                   muffleCondition(cond)
[10:19:22.161]                 })
[10:19:22.161]             }))
[10:19:22.161]             future::FutureResult(value = ...future.value$value, 
[10:19:22.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.161]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.161]                     ...future.globalenv.names))
[10:19:22.161]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.161]         }, condition = base::local({
[10:19:22.161]             c <- base::c
[10:19:22.161]             inherits <- base::inherits
[10:19:22.161]             invokeRestart <- base::invokeRestart
[10:19:22.161]             length <- base::length
[10:19:22.161]             list <- base::list
[10:19:22.161]             seq.int <- base::seq.int
[10:19:22.161]             signalCondition <- base::signalCondition
[10:19:22.161]             sys.calls <- base::sys.calls
[10:19:22.161]             `[[` <- base::`[[`
[10:19:22.161]             `+` <- base::`+`
[10:19:22.161]             `<<-` <- base::`<<-`
[10:19:22.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.161]                   3L)]
[10:19:22.161]             }
[10:19:22.161]             function(cond) {
[10:19:22.161]                 is_error <- inherits(cond, "error")
[10:19:22.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.161]                   NULL)
[10:19:22.161]                 if (is_error) {
[10:19:22.161]                   sessionInformation <- function() {
[10:19:22.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.161]                       search = base::search(), system = base::Sys.info())
[10:19:22.161]                   }
[10:19:22.161]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.161]                     cond$call), session = sessionInformation(), 
[10:19:22.161]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.161]                   signalCondition(cond)
[10:19:22.161]                 }
[10:19:22.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.161]                 "immediateCondition"))) {
[10:19:22.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.161]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.161]                   if (TRUE && !signal) {
[10:19:22.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.161]                     {
[10:19:22.161]                       inherits <- base::inherits
[10:19:22.161]                       invokeRestart <- base::invokeRestart
[10:19:22.161]                       is.null <- base::is.null
[10:19:22.161]                       muffled <- FALSE
[10:19:22.161]                       if (inherits(cond, "message")) {
[10:19:22.161]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.161]                         if (muffled) 
[10:19:22.161]                           invokeRestart("muffleMessage")
[10:19:22.161]                       }
[10:19:22.161]                       else if (inherits(cond, "warning")) {
[10:19:22.161]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.161]                         if (muffled) 
[10:19:22.161]                           invokeRestart("muffleWarning")
[10:19:22.161]                       }
[10:19:22.161]                       else if (inherits(cond, "condition")) {
[10:19:22.161]                         if (!is.null(pattern)) {
[10:19:22.161]                           computeRestarts <- base::computeRestarts
[10:19:22.161]                           grepl <- base::grepl
[10:19:22.161]                           restarts <- computeRestarts(cond)
[10:19:22.161]                           for (restart in restarts) {
[10:19:22.161]                             name <- restart$name
[10:19:22.161]                             if (is.null(name)) 
[10:19:22.161]                               next
[10:19:22.161]                             if (!grepl(pattern, name)) 
[10:19:22.161]                               next
[10:19:22.161]                             invokeRestart(restart)
[10:19:22.161]                             muffled <- TRUE
[10:19:22.161]                             break
[10:19:22.161]                           }
[10:19:22.161]                         }
[10:19:22.161]                       }
[10:19:22.161]                       invisible(muffled)
[10:19:22.161]                     }
[10:19:22.161]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.161]                   }
[10:19:22.161]                 }
[10:19:22.161]                 else {
[10:19:22.161]                   if (TRUE) {
[10:19:22.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.161]                     {
[10:19:22.161]                       inherits <- base::inherits
[10:19:22.161]                       invokeRestart <- base::invokeRestart
[10:19:22.161]                       is.null <- base::is.null
[10:19:22.161]                       muffled <- FALSE
[10:19:22.161]                       if (inherits(cond, "message")) {
[10:19:22.161]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.161]                         if (muffled) 
[10:19:22.161]                           invokeRestart("muffleMessage")
[10:19:22.161]                       }
[10:19:22.161]                       else if (inherits(cond, "warning")) {
[10:19:22.161]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.161]                         if (muffled) 
[10:19:22.161]                           invokeRestart("muffleWarning")
[10:19:22.161]                       }
[10:19:22.161]                       else if (inherits(cond, "condition")) {
[10:19:22.161]                         if (!is.null(pattern)) {
[10:19:22.161]                           computeRestarts <- base::computeRestarts
[10:19:22.161]                           grepl <- base::grepl
[10:19:22.161]                           restarts <- computeRestarts(cond)
[10:19:22.161]                           for (restart in restarts) {
[10:19:22.161]                             name <- restart$name
[10:19:22.161]                             if (is.null(name)) 
[10:19:22.161]                               next
[10:19:22.161]                             if (!grepl(pattern, name)) 
[10:19:22.161]                               next
[10:19:22.161]                             invokeRestart(restart)
[10:19:22.161]                             muffled <- TRUE
[10:19:22.161]                             break
[10:19:22.161]                           }
[10:19:22.161]                         }
[10:19:22.161]                       }
[10:19:22.161]                       invisible(muffled)
[10:19:22.161]                     }
[10:19:22.161]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.161]                   }
[10:19:22.161]                 }
[10:19:22.161]             }
[10:19:22.161]         }))
[10:19:22.161]     }, error = function(ex) {
[10:19:22.161]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.161]                 ...future.rng), started = ...future.startTime, 
[10:19:22.161]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.161]             version = "1.8"), class = "FutureResult")
[10:19:22.161]     }, finally = {
[10:19:22.161]         if (!identical(...future.workdir, getwd())) 
[10:19:22.161]             setwd(...future.workdir)
[10:19:22.161]         {
[10:19:22.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.161]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.161]             }
[10:19:22.161]             base::options(...future.oldOptions)
[10:19:22.161]             if (.Platform$OS.type == "windows") {
[10:19:22.161]                 old_names <- names(...future.oldEnvVars)
[10:19:22.161]                 envs <- base::Sys.getenv()
[10:19:22.161]                 names <- names(envs)
[10:19:22.161]                 common <- intersect(names, old_names)
[10:19:22.161]                 added <- setdiff(names, old_names)
[10:19:22.161]                 removed <- setdiff(old_names, names)
[10:19:22.161]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.161]                   envs[common]]
[10:19:22.161]                 NAMES <- toupper(changed)
[10:19:22.161]                 args <- list()
[10:19:22.161]                 for (kk in seq_along(NAMES)) {
[10:19:22.161]                   name <- changed[[kk]]
[10:19:22.161]                   NAME <- NAMES[[kk]]
[10:19:22.161]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.161]                     next
[10:19:22.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.161]                 }
[10:19:22.161]                 NAMES <- toupper(added)
[10:19:22.161]                 for (kk in seq_along(NAMES)) {
[10:19:22.161]                   name <- added[[kk]]
[10:19:22.161]                   NAME <- NAMES[[kk]]
[10:19:22.161]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.161]                     next
[10:19:22.161]                   args[[name]] <- ""
[10:19:22.161]                 }
[10:19:22.161]                 NAMES <- toupper(removed)
[10:19:22.161]                 for (kk in seq_along(NAMES)) {
[10:19:22.161]                   name <- removed[[kk]]
[10:19:22.161]                   NAME <- NAMES[[kk]]
[10:19:22.161]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.161]                     next
[10:19:22.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.161]                 }
[10:19:22.161]                 if (length(args) > 0) 
[10:19:22.161]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.161]             }
[10:19:22.161]             else {
[10:19:22.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.161]             }
[10:19:22.161]             {
[10:19:22.161]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.161]                   0L) {
[10:19:22.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.161]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.161]                   base::options(opts)
[10:19:22.161]                 }
[10:19:22.161]                 {
[10:19:22.161]                   {
[10:19:22.161]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.161]                     NULL
[10:19:22.161]                   }
[10:19:22.161]                   options(future.plan = NULL)
[10:19:22.161]                   if (is.na(NA_character_)) 
[10:19:22.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.161]                     .init = FALSE)
[10:19:22.161]                 }
[10:19:22.161]             }
[10:19:22.161]         }
[10:19:22.161]     })
[10:19:22.161]     if (TRUE) {
[10:19:22.161]         base::sink(type = "output", split = FALSE)
[10:19:22.161]         if (TRUE) {
[10:19:22.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.161]         }
[10:19:22.161]         else {
[10:19:22.161]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.161]         }
[10:19:22.161]         base::close(...future.stdout)
[10:19:22.161]         ...future.stdout <- NULL
[10:19:22.161]     }
[10:19:22.161]     ...future.result$conditions <- ...future.conditions
[10:19:22.161]     ...future.result$finished <- base::Sys.time()
[10:19:22.161]     ...future.result
[10:19:22.161] }
[10:19:22.164] assign_globals() ...
[10:19:22.164] List of 5
[10:19:22.164]  $ ...future.FUN            :function (C, k)  
[10:19:22.164]  $ MoreArgs                 : list()
[10:19:22.164]  $ ...future.elements_ii    :List of 2
[10:19:22.164]   ..$ :List of 3
[10:19:22.164]   .. ..$ : chr "C"
[10:19:22.164]   .. ..$ : chr "D"
[10:19:22.164]   .. ..$ : chr "E"
[10:19:22.164]   ..$ :List of 3
[10:19:22.164]   .. ..$ : int 3
[10:19:22.164]   .. ..$ : int 2
[10:19:22.164]   .. ..$ : int 1
[10:19:22.164]  $ ...future.seeds_ii       : NULL
[10:19:22.164]  $ ...future.globals.maxSize: NULL
[10:19:22.164]  - attr(*, "where")=List of 5
[10:19:22.164]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.164]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.164]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.164]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.164]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.164]  - attr(*, "resolved")= logi FALSE
[10:19:22.164]  - attr(*, "total_size")= num 909
[10:19:22.164]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.164]  - attr(*, "already-done")= logi TRUE
[10:19:22.179] - reassign environment for ‘...future.FUN’
[10:19:22.179] - copied ‘...future.FUN’ to environment
[10:19:22.179] - copied ‘MoreArgs’ to environment
[10:19:22.179] - copied ‘...future.elements_ii’ to environment
[10:19:22.180] - copied ‘...future.seeds_ii’ to environment
[10:19:22.180] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.180] assign_globals() ... done
[10:19:22.180] requestCore(): workers = 2
[10:19:22.182] MulticoreFuture started
[10:19:22.183] - Launch lazy future ... done
[10:19:22.183] run() for ‘MulticoreFuture’ ... done
[10:19:22.184] plan(): Setting new future strategy stack:
[10:19:22.184] Created future:
[10:19:22.184] List of future strategies:
[10:19:22.184] 1. sequential:
[10:19:22.184]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.184]    - tweaked: FALSE
[10:19:22.184]    - call: NULL
[10:19:22.185] plan(): nbrOfWorkers() = 1
[10:19:22.188] plan(): Setting new future strategy stack:
[10:19:22.188] List of future strategies:
[10:19:22.188] 1. multicore:
[10:19:22.188]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.188]    - tweaked: FALSE
[10:19:22.188]    - call: plan(strategy)
[10:19:22.192] plan(): nbrOfWorkers() = 2
[10:19:22.184] MulticoreFuture:
[10:19:22.184] Label: ‘future_.mapply-2’
[10:19:22.184] Expression:
[10:19:22.184] {
[10:19:22.184]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.184]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.184]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.184]         on.exit(options(oopts), add = TRUE)
[10:19:22.184]     }
[10:19:22.184]     {
[10:19:22.184]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.184]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.184]         do.call(mapply, args = args)
[10:19:22.184]     }
[10:19:22.184] }
[10:19:22.184] Lazy evaluation: FALSE
[10:19:22.184] Asynchronous evaluation: TRUE
[10:19:22.184] Local evaluation: TRUE
[10:19:22.184] Environment: R_GlobalEnv
[10:19:22.184] Capture standard output: TRUE
[10:19:22.184] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.184] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.184] Packages: <none>
[10:19:22.184] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.184] Resolved: TRUE
[10:19:22.184] Value: <not collected>
[10:19:22.184] Conditions captured: <none>
[10:19:22.184] Early signaling: FALSE
[10:19:22.184] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.184] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.193] Chunk #2 of 2 ... DONE
[10:19:22.193] Launching 2 futures (chunks) ... DONE
[10:19:22.193] Resolving 2 futures (chunks) ...
[10:19:22.193] resolve() on list ...
[10:19:22.194]  recursive: 0
[10:19:22.194]  length: 2
[10:19:22.194] 
[10:19:22.194] Future #1
[10:19:22.195] result() for MulticoreFuture ...
[10:19:22.195] result() for MulticoreFuture ...
[10:19:22.196] result() for MulticoreFuture ... done
[10:19:22.196] result() for MulticoreFuture ... done
[10:19:22.196] result() for MulticoreFuture ...
[10:19:22.196] result() for MulticoreFuture ... done
[10:19:22.196] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:22.196] - nx: 2
[10:19:22.197] - relay: TRUE
[10:19:22.197] - stdout: TRUE
[10:19:22.197] - signal: TRUE
[10:19:22.197] - resignal: FALSE
[10:19:22.197] - force: TRUE
[10:19:22.197] - relayed: [n=2] FALSE, FALSE
[10:19:22.197] - queued futures: [n=2] FALSE, FALSE
[10:19:22.198]  - until=1
[10:19:22.198]  - relaying element #1
[10:19:22.198] result() for MulticoreFuture ...
[10:19:22.198] result() for MulticoreFuture ... done
[10:19:22.198] result() for MulticoreFuture ...
[10:19:22.198] result() for MulticoreFuture ... done
[10:19:22.198] result() for MulticoreFuture ...
[10:19:22.198] result() for MulticoreFuture ... done
[10:19:22.199] result() for MulticoreFuture ...
[10:19:22.199] result() for MulticoreFuture ... done
[10:19:22.199] - relayed: [n=2] TRUE, FALSE
[10:19:22.199] - queued futures: [n=2] TRUE, FALSE
[10:19:22.199] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:22.199]  length: 1 (resolved future 1)
[10:19:22.200] Future #2
[10:19:22.200] result() for MulticoreFuture ...
[10:19:22.200] result() for MulticoreFuture ...
[10:19:22.200] result() for MulticoreFuture ... done
[10:19:22.201] result() for MulticoreFuture ... done
[10:19:22.201] result() for MulticoreFuture ...
[10:19:22.201] result() for MulticoreFuture ... done
[10:19:22.201] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:22.201] - nx: 2
[10:19:22.201] - relay: TRUE
[10:19:22.201] - stdout: TRUE
[10:19:22.201] - signal: TRUE
[10:19:22.202] - resignal: FALSE
[10:19:22.202] - force: TRUE
[10:19:22.202] - relayed: [n=2] TRUE, FALSE
[10:19:22.202] - queued futures: [n=2] TRUE, FALSE
[10:19:22.202]  - until=2
[10:19:22.202]  - relaying element #2
[10:19:22.202] result() for MulticoreFuture ...
[10:19:22.202] result() for MulticoreFuture ... done
[10:19:22.203] result() for MulticoreFuture ...
[10:19:22.203] result() for MulticoreFuture ... done
[10:19:22.203] result() for MulticoreFuture ...
[10:19:22.203] result() for MulticoreFuture ... done
[10:19:22.203] result() for MulticoreFuture ...
[10:19:22.203] result() for MulticoreFuture ... done
[10:19:22.203] - relayed: [n=2] TRUE, TRUE
[10:19:22.203] - queued futures: [n=2] TRUE, TRUE
[10:19:22.203] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:22.204]  length: 0 (resolved future 2)
[10:19:22.204] Relaying remaining futures
[10:19:22.204] signalConditionsASAP(NULL, pos=0) ...
[10:19:22.204] - nx: 2
[10:19:22.204] - relay: TRUE
[10:19:22.204] - stdout: TRUE
[10:19:22.204] - signal: TRUE
[10:19:22.204] - resignal: FALSE
[10:19:22.204] - force: TRUE
[10:19:22.205] - relayed: [n=2] TRUE, TRUE
[10:19:22.205] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:22.205] - relayed: [n=2] TRUE, TRUE
[10:19:22.205] - queued futures: [n=2] TRUE, TRUE
[10:19:22.205] signalConditionsASAP(NULL, pos=0) ... done
[10:19:22.205] resolve() on list ... DONE
[10:19:22.205] result() for MulticoreFuture ...
[10:19:22.205] result() for MulticoreFuture ... done
[10:19:22.206] result() for MulticoreFuture ...
[10:19:22.206] result() for MulticoreFuture ... done
[10:19:22.206] result() for MulticoreFuture ...
[10:19:22.206] result() for MulticoreFuture ... done
[10:19:22.206] result() for MulticoreFuture ...
[10:19:22.206] result() for MulticoreFuture ... done
[10:19:22.206]  - Number of value chunks collected: 2
[10:19:22.206] Resolving 2 futures (chunks) ... DONE
[10:19:22.206] Reducing values from 2 chunks ...
[10:19:22.207]  - Number of values collected after concatenation: 5
[10:19:22.207]  - Number of values expected: 5
[10:19:22.207] Reducing values from 2 chunks ... DONE
[10:19:22.207] future_mapply() ... DONE
[10:19:22.207] future_mapply() ...
[10:19:22.210] Number of chunks: 3
[10:19:22.212] Index remapping (attribute 'ordering'): [n = 5] 2, 1, 4, 3, 5
[10:19:22.212] getGlobalsAndPackagesXApply() ...
[10:19:22.212]  - future.globals: TRUE
[10:19:22.213] getGlobalsAndPackages() ...
[10:19:22.213] Searching for globals...
[10:19:22.215] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:22.215] Searching for globals ... DONE
[10:19:22.215] Resolving globals: FALSE
[10:19:22.216] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:22.216] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:22.216] - globals: [1] ‘FUN’
[10:19:22.216] 
[10:19:22.216] getGlobalsAndPackages() ... DONE
[10:19:22.217]  - globals found/used: [n=1] ‘FUN’
[10:19:22.217]  - needed namespaces: [n=0] 
[10:19:22.217] Finding globals ... DONE
[10:19:22.217] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:22.217] List of 2
[10:19:22.217]  $ ...future.FUN:function (C, k)  
[10:19:22.217]  $ MoreArgs     : NULL
[10:19:22.217]  - attr(*, "where")=List of 2
[10:19:22.217]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:22.217]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:22.217]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.217]  - attr(*, "resolved")= logi FALSE
[10:19:22.217]  - attr(*, "total_size")= num NA
[10:19:22.221] Packages to be attached in all futures: [n=0] 
[10:19:22.221] getGlobalsAndPackagesXApply() ... DONE
[10:19:22.221] Number of futures (= number of chunks): 3
[10:19:22.221] Launching 3 futures (chunks) ...
[10:19:22.221] Chunk #1 of 3 ...
[10:19:22.221]  - Finding globals in '...' for chunk #1 ...
[10:19:22.222] getGlobalsAndPackages() ...
[10:19:22.222] Searching for globals...
[10:19:22.222] 
[10:19:22.222] Searching for globals ... DONE
[10:19:22.222] - globals: [0] <none>
[10:19:22.222] getGlobalsAndPackages() ... DONE
[10:19:22.222]    + additional globals found: [n=0] 
[10:19:22.222]    + additional namespaces needed: [n=0] 
[10:19:22.222]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:22.223]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:19:22.223]  - seeds: <none>
[10:19:22.223]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.223] getGlobalsAndPackages() ...
[10:19:22.223] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.223] Resolving globals: FALSE
[10:19:22.223] The total size of the 5 globals is 876 bytes (876 bytes)
[10:19:22.224] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:22.224] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.224] 
[10:19:22.224] getGlobalsAndPackages() ... DONE
[10:19:22.225] run() for ‘Future’ ...
[10:19:22.225] - state: ‘created’
[10:19:22.225] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.226] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.227]   - Field: ‘label’
[10:19:22.227]   - Field: ‘local’
[10:19:22.227]   - Field: ‘owner’
[10:19:22.227]   - Field: ‘envir’
[10:19:22.227]   - Field: ‘workers’
[10:19:22.227]   - Field: ‘packages’
[10:19:22.227]   - Field: ‘gc’
[10:19:22.227]   - Field: ‘job’
[10:19:22.227]   - Field: ‘conditions’
[10:19:22.227]   - Field: ‘expr’
[10:19:22.228]   - Field: ‘uuid’
[10:19:22.228]   - Field: ‘seed’
[10:19:22.228]   - Field: ‘version’
[10:19:22.228]   - Field: ‘result’
[10:19:22.228]   - Field: ‘asynchronous’
[10:19:22.228]   - Field: ‘calls’
[10:19:22.228]   - Field: ‘globals’
[10:19:22.228]   - Field: ‘stdout’
[10:19:22.228]   - Field: ‘earlySignal’
[10:19:22.228]   - Field: ‘lazy’
[10:19:22.228]   - Field: ‘state’
[10:19:22.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.229] - Launch lazy future ...
[10:19:22.229] Packages needed by the future expression (n = 0): <none>
[10:19:22.229] Packages needed by future strategies (n = 0): <none>
[10:19:22.229] {
[10:19:22.229]     {
[10:19:22.229]         {
[10:19:22.229]             ...future.startTime <- base::Sys.time()
[10:19:22.229]             {
[10:19:22.229]                 {
[10:19:22.229]                   {
[10:19:22.229]                     {
[10:19:22.229]                       base::local({
[10:19:22.229]                         has_future <- base::requireNamespace("future", 
[10:19:22.229]                           quietly = TRUE)
[10:19:22.229]                         if (has_future) {
[10:19:22.229]                           ns <- base::getNamespace("future")
[10:19:22.229]                           version <- ns[[".package"]][["version"]]
[10:19:22.229]                           if (is.null(version)) 
[10:19:22.229]                             version <- utils::packageVersion("future")
[10:19:22.229]                         }
[10:19:22.229]                         else {
[10:19:22.229]                           version <- NULL
[10:19:22.229]                         }
[10:19:22.229]                         if (!has_future || version < "1.8.0") {
[10:19:22.229]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.229]                             "", base::R.version$version.string), 
[10:19:22.229]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.229]                               "release", "version")], collapse = " "), 
[10:19:22.229]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.229]                             info)
[10:19:22.229]                           info <- base::paste(info, collapse = "; ")
[10:19:22.229]                           if (!has_future) {
[10:19:22.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.229]                               info)
[10:19:22.229]                           }
[10:19:22.229]                           else {
[10:19:22.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.229]                               info, version)
[10:19:22.229]                           }
[10:19:22.229]                           base::stop(msg)
[10:19:22.229]                         }
[10:19:22.229]                       })
[10:19:22.229]                     }
[10:19:22.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.229]                     base::options(mc.cores = 1L)
[10:19:22.229]                   }
[10:19:22.229]                   ...future.strategy.old <- future::plan("list")
[10:19:22.229]                   options(future.plan = NULL)
[10:19:22.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.229]                 }
[10:19:22.229]                 ...future.workdir <- getwd()
[10:19:22.229]             }
[10:19:22.229]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.229]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.229]         }
[10:19:22.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.229]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:19:22.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.229]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.229]             base::names(...future.oldOptions))
[10:19:22.229]     }
[10:19:22.229]     if (FALSE) {
[10:19:22.229]     }
[10:19:22.229]     else {
[10:19:22.229]         if (TRUE) {
[10:19:22.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.229]                 open = "w")
[10:19:22.229]         }
[10:19:22.229]         else {
[10:19:22.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.229]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.229]         }
[10:19:22.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.229]             base::sink(type = "output", split = FALSE)
[10:19:22.229]             base::close(...future.stdout)
[10:19:22.229]         }, add = TRUE)
[10:19:22.229]     }
[10:19:22.229]     ...future.frame <- base::sys.nframe()
[10:19:22.229]     ...future.conditions <- base::list()
[10:19:22.229]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.229]     if (FALSE) {
[10:19:22.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.229]     }
[10:19:22.229]     ...future.result <- base::tryCatch({
[10:19:22.229]         base::withCallingHandlers({
[10:19:22.229]             ...future.value <- base::withVisible(base::local({
[10:19:22.229]                 withCallingHandlers({
[10:19:22.229]                   {
[10:19:22.229]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.229]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.229]                       ...future.globals.maxSize)) {
[10:19:22.229]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.229]                       on.exit(options(oopts), add = TRUE)
[10:19:22.229]                     }
[10:19:22.229]                     {
[10:19:22.229]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.229]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.229]                         USE.NAMES = FALSE)
[10:19:22.229]                       do.call(mapply, args = args)
[10:19:22.229]                     }
[10:19:22.229]                   }
[10:19:22.229]                 }, immediateCondition = function(cond) {
[10:19:22.229]                   save_rds <- function (object, pathname, ...) 
[10:19:22.229]                   {
[10:19:22.229]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.229]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.229]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.229]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.229]                         fi_tmp[["mtime"]])
[10:19:22.229]                     }
[10:19:22.229]                     tryCatch({
[10:19:22.229]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.229]                     }, error = function(ex) {
[10:19:22.229]                       msg <- conditionMessage(ex)
[10:19:22.229]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.229]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.229]                         fi_tmp[["mtime"]], msg)
[10:19:22.229]                       ex$message <- msg
[10:19:22.229]                       stop(ex)
[10:19:22.229]                     })
[10:19:22.229]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.229]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.229]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.229]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.229]                       fi <- file.info(pathname)
[10:19:22.229]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.229]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.229]                         fi[["size"]], fi[["mtime"]])
[10:19:22.229]                       stop(msg)
[10:19:22.229]                     }
[10:19:22.229]                     invisible(pathname)
[10:19:22.229]                   }
[10:19:22.229]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.229]                     rootPath = tempdir()) 
[10:19:22.229]                   {
[10:19:22.229]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.229]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.229]                       tmpdir = path, fileext = ".rds")
[10:19:22.229]                     save_rds(obj, file)
[10:19:22.229]                   }
[10:19:22.229]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.229]                   {
[10:19:22.229]                     inherits <- base::inherits
[10:19:22.229]                     invokeRestart <- base::invokeRestart
[10:19:22.229]                     is.null <- base::is.null
[10:19:22.229]                     muffled <- FALSE
[10:19:22.229]                     if (inherits(cond, "message")) {
[10:19:22.229]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.229]                       if (muffled) 
[10:19:22.229]                         invokeRestart("muffleMessage")
[10:19:22.229]                     }
[10:19:22.229]                     else if (inherits(cond, "warning")) {
[10:19:22.229]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.229]                       if (muffled) 
[10:19:22.229]                         invokeRestart("muffleWarning")
[10:19:22.229]                     }
[10:19:22.229]                     else if (inherits(cond, "condition")) {
[10:19:22.229]                       if (!is.null(pattern)) {
[10:19:22.229]                         computeRestarts <- base::computeRestarts
[10:19:22.229]                         grepl <- base::grepl
[10:19:22.229]                         restarts <- computeRestarts(cond)
[10:19:22.229]                         for (restart in restarts) {
[10:19:22.229]                           name <- restart$name
[10:19:22.229]                           if (is.null(name)) 
[10:19:22.229]                             next
[10:19:22.229]                           if (!grepl(pattern, name)) 
[10:19:22.229]                             next
[10:19:22.229]                           invokeRestart(restart)
[10:19:22.229]                           muffled <- TRUE
[10:19:22.229]                           break
[10:19:22.229]                         }
[10:19:22.229]                       }
[10:19:22.229]                     }
[10:19:22.229]                     invisible(muffled)
[10:19:22.229]                   }
[10:19:22.229]                   muffleCondition(cond)
[10:19:22.229]                 })
[10:19:22.229]             }))
[10:19:22.229]             future::FutureResult(value = ...future.value$value, 
[10:19:22.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.229]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.229]                     ...future.globalenv.names))
[10:19:22.229]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.229]         }, condition = base::local({
[10:19:22.229]             c <- base::c
[10:19:22.229]             inherits <- base::inherits
[10:19:22.229]             invokeRestart <- base::invokeRestart
[10:19:22.229]             length <- base::length
[10:19:22.229]             list <- base::list
[10:19:22.229]             seq.int <- base::seq.int
[10:19:22.229]             signalCondition <- base::signalCondition
[10:19:22.229]             sys.calls <- base::sys.calls
[10:19:22.229]             `[[` <- base::`[[`
[10:19:22.229]             `+` <- base::`+`
[10:19:22.229]             `<<-` <- base::`<<-`
[10:19:22.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.229]                   3L)]
[10:19:22.229]             }
[10:19:22.229]             function(cond) {
[10:19:22.229]                 is_error <- inherits(cond, "error")
[10:19:22.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.229]                   NULL)
[10:19:22.229]                 if (is_error) {
[10:19:22.229]                   sessionInformation <- function() {
[10:19:22.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.229]                       search = base::search(), system = base::Sys.info())
[10:19:22.229]                   }
[10:19:22.229]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.229]                     cond$call), session = sessionInformation(), 
[10:19:22.229]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.229]                   signalCondition(cond)
[10:19:22.229]                 }
[10:19:22.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.229]                 "immediateCondition"))) {
[10:19:22.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.229]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.229]                   if (TRUE && !signal) {
[10:19:22.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.229]                     {
[10:19:22.229]                       inherits <- base::inherits
[10:19:22.229]                       invokeRestart <- base::invokeRestart
[10:19:22.229]                       is.null <- base::is.null
[10:19:22.229]                       muffled <- FALSE
[10:19:22.229]                       if (inherits(cond, "message")) {
[10:19:22.229]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.229]                         if (muffled) 
[10:19:22.229]                           invokeRestart("muffleMessage")
[10:19:22.229]                       }
[10:19:22.229]                       else if (inherits(cond, "warning")) {
[10:19:22.229]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.229]                         if (muffled) 
[10:19:22.229]                           invokeRestart("muffleWarning")
[10:19:22.229]                       }
[10:19:22.229]                       else if (inherits(cond, "condition")) {
[10:19:22.229]                         if (!is.null(pattern)) {
[10:19:22.229]                           computeRestarts <- base::computeRestarts
[10:19:22.229]                           grepl <- base::grepl
[10:19:22.229]                           restarts <- computeRestarts(cond)
[10:19:22.229]                           for (restart in restarts) {
[10:19:22.229]                             name <- restart$name
[10:19:22.229]                             if (is.null(name)) 
[10:19:22.229]                               next
[10:19:22.229]                             if (!grepl(pattern, name)) 
[10:19:22.229]                               next
[10:19:22.229]                             invokeRestart(restart)
[10:19:22.229]                             muffled <- TRUE
[10:19:22.229]                             break
[10:19:22.229]                           }
[10:19:22.229]                         }
[10:19:22.229]                       }
[10:19:22.229]                       invisible(muffled)
[10:19:22.229]                     }
[10:19:22.229]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.229]                   }
[10:19:22.229]                 }
[10:19:22.229]                 else {
[10:19:22.229]                   if (TRUE) {
[10:19:22.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.229]                     {
[10:19:22.229]                       inherits <- base::inherits
[10:19:22.229]                       invokeRestart <- base::invokeRestart
[10:19:22.229]                       is.null <- base::is.null
[10:19:22.229]                       muffled <- FALSE
[10:19:22.229]                       if (inherits(cond, "message")) {
[10:19:22.229]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.229]                         if (muffled) 
[10:19:22.229]                           invokeRestart("muffleMessage")
[10:19:22.229]                       }
[10:19:22.229]                       else if (inherits(cond, "warning")) {
[10:19:22.229]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.229]                         if (muffled) 
[10:19:22.229]                           invokeRestart("muffleWarning")
[10:19:22.229]                       }
[10:19:22.229]                       else if (inherits(cond, "condition")) {
[10:19:22.229]                         if (!is.null(pattern)) {
[10:19:22.229]                           computeRestarts <- base::computeRestarts
[10:19:22.229]                           grepl <- base::grepl
[10:19:22.229]                           restarts <- computeRestarts(cond)
[10:19:22.229]                           for (restart in restarts) {
[10:19:22.229]                             name <- restart$name
[10:19:22.229]                             if (is.null(name)) 
[10:19:22.229]                               next
[10:19:22.229]                             if (!grepl(pattern, name)) 
[10:19:22.229]                               next
[10:19:22.229]                             invokeRestart(restart)
[10:19:22.229]                             muffled <- TRUE
[10:19:22.229]                             break
[10:19:22.229]                           }
[10:19:22.229]                         }
[10:19:22.229]                       }
[10:19:22.229]                       invisible(muffled)
[10:19:22.229]                     }
[10:19:22.229]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.229]                   }
[10:19:22.229]                 }
[10:19:22.229]             }
[10:19:22.229]         }))
[10:19:22.229]     }, error = function(ex) {
[10:19:22.229]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.229]                 ...future.rng), started = ...future.startTime, 
[10:19:22.229]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.229]             version = "1.8"), class = "FutureResult")
[10:19:22.229]     }, finally = {
[10:19:22.229]         if (!identical(...future.workdir, getwd())) 
[10:19:22.229]             setwd(...future.workdir)
[10:19:22.229]         {
[10:19:22.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.229]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.229]             }
[10:19:22.229]             base::options(...future.oldOptions)
[10:19:22.229]             if (.Platform$OS.type == "windows") {
[10:19:22.229]                 old_names <- names(...future.oldEnvVars)
[10:19:22.229]                 envs <- base::Sys.getenv()
[10:19:22.229]                 names <- names(envs)
[10:19:22.229]                 common <- intersect(names, old_names)
[10:19:22.229]                 added <- setdiff(names, old_names)
[10:19:22.229]                 removed <- setdiff(old_names, names)
[10:19:22.229]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.229]                   envs[common]]
[10:19:22.229]                 NAMES <- toupper(changed)
[10:19:22.229]                 args <- list()
[10:19:22.229]                 for (kk in seq_along(NAMES)) {
[10:19:22.229]                   name <- changed[[kk]]
[10:19:22.229]                   NAME <- NAMES[[kk]]
[10:19:22.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.229]                     next
[10:19:22.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.229]                 }
[10:19:22.229]                 NAMES <- toupper(added)
[10:19:22.229]                 for (kk in seq_along(NAMES)) {
[10:19:22.229]                   name <- added[[kk]]
[10:19:22.229]                   NAME <- NAMES[[kk]]
[10:19:22.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.229]                     next
[10:19:22.229]                   args[[name]] <- ""
[10:19:22.229]                 }
[10:19:22.229]                 NAMES <- toupper(removed)
[10:19:22.229]                 for (kk in seq_along(NAMES)) {
[10:19:22.229]                   name <- removed[[kk]]
[10:19:22.229]                   NAME <- NAMES[[kk]]
[10:19:22.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.229]                     next
[10:19:22.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.229]                 }
[10:19:22.229]                 if (length(args) > 0) 
[10:19:22.229]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.229]             }
[10:19:22.229]             else {
[10:19:22.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.229]             }
[10:19:22.229]             {
[10:19:22.229]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.229]                   0L) {
[10:19:22.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.229]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.229]                   base::options(opts)
[10:19:22.229]                 }
[10:19:22.229]                 {
[10:19:22.229]                   {
[10:19:22.229]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.229]                     NULL
[10:19:22.229]                   }
[10:19:22.229]                   options(future.plan = NULL)
[10:19:22.229]                   if (is.na(NA_character_)) 
[10:19:22.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.229]                     .init = FALSE)
[10:19:22.229]                 }
[10:19:22.229]             }
[10:19:22.229]         }
[10:19:22.229]     })
[10:19:22.229]     if (TRUE) {
[10:19:22.229]         base::sink(type = "output", split = FALSE)
[10:19:22.229]         if (TRUE) {
[10:19:22.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.229]         }
[10:19:22.229]         else {
[10:19:22.229]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.229]         }
[10:19:22.229]         base::close(...future.stdout)
[10:19:22.229]         ...future.stdout <- NULL
[10:19:22.229]     }
[10:19:22.229]     ...future.result$conditions <- ...future.conditions
[10:19:22.229]     ...future.result$finished <- base::Sys.time()
[10:19:22.229]     ...future.result
[10:19:22.229] }
[10:19:22.232] assign_globals() ...
[10:19:22.232] List of 5
[10:19:22.232]  $ ...future.FUN            :function (C, k)  
[10:19:22.232]  $ MoreArgs                 : NULL
[10:19:22.232]  $ ...future.elements_ii    :List of 2
[10:19:22.232]   ..$ :List of 2
[10:19:22.232]   .. ..$ : chr "B"
[10:19:22.232]   .. ..$ : chr "A"
[10:19:22.232]   ..$ :List of 2
[10:19:22.232]   .. ..$ : int 4
[10:19:22.232]   .. ..$ : int 5
[10:19:22.232]  $ ...future.seeds_ii       : NULL
[10:19:22.232]  $ ...future.globals.maxSize: NULL
[10:19:22.232]  - attr(*, "where")=List of 5
[10:19:22.232]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.232]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.232]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.232]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.232]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.232]  - attr(*, "resolved")= logi FALSE
[10:19:22.232]  - attr(*, "total_size")= num 876
[10:19:22.232]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.232]  - attr(*, "already-done")= logi TRUE
[10:19:22.239] - reassign environment for ‘...future.FUN’
[10:19:22.240] - copied ‘...future.FUN’ to environment
[10:19:22.240] - copied ‘MoreArgs’ to environment
[10:19:22.240] - copied ‘...future.elements_ii’ to environment
[10:19:22.240] - copied ‘...future.seeds_ii’ to environment
[10:19:22.240] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.240] assign_globals() ... done
[10:19:22.240] requestCore(): workers = 2
[10:19:22.243] MulticoreFuture started
[10:19:22.243] - Launch lazy future ... done
[10:19:22.244] plan(): Setting new future strategy stack:
[10:19:22.244] run() for ‘MulticoreFuture’ ... done
[10:19:22.244] Created future:
[10:19:22.244] List of future strategies:
[10:19:22.244] 1. sequential:
[10:19:22.244]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.244]    - tweaked: FALSE
[10:19:22.244]    - call: NULL
[10:19:22.246] plan(): nbrOfWorkers() = 1
[10:19:22.249] plan(): Setting new future strategy stack:
[10:19:22.249] List of future strategies:
[10:19:22.249] 1. multicore:
[10:19:22.249]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.249]    - tweaked: FALSE
[10:19:22.249]    - call: plan(strategy)
[10:19:22.254] plan(): nbrOfWorkers() = 2
[10:19:22.245] MulticoreFuture:
[10:19:22.245] Label: ‘future_mapply-1’
[10:19:22.245] Expression:
[10:19:22.245] {
[10:19:22.245]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.245]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.245]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.245]         on.exit(options(oopts), add = TRUE)
[10:19:22.245]     }
[10:19:22.245]     {
[10:19:22.245]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.245]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.245]         do.call(mapply, args = args)
[10:19:22.245]     }
[10:19:22.245] }
[10:19:22.245] Lazy evaluation: FALSE
[10:19:22.245] Asynchronous evaluation: TRUE
[10:19:22.245] Local evaluation: TRUE
[10:19:22.245] Environment: R_GlobalEnv
[10:19:22.245] Capture standard output: TRUE
[10:19:22.245] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.245] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.245] Packages: <none>
[10:19:22.245] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.245] Resolved: TRUE
[10:19:22.245] Value: <not collected>
[10:19:22.245] Conditions captured: <none>
[10:19:22.245] Early signaling: FALSE
[10:19:22.245] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.245] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.255] Chunk #1 of 3 ... DONE
[10:19:22.255] Chunk #2 of 3 ...
[10:19:22.256]  - Finding globals in '...' for chunk #2 ...
[10:19:22.256] getGlobalsAndPackages() ...
[10:19:22.256] Searching for globals...
[10:19:22.257] 
[10:19:22.257] Searching for globals ... DONE
[10:19:22.257] - globals: [0] <none>
[10:19:22.257] getGlobalsAndPackages() ... DONE
[10:19:22.258]    + additional globals found: [n=0] 
[10:19:22.258]    + additional namespaces needed: [n=0] 
[10:19:22.258]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:22.258]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:19:22.258]  - seeds: <none>
[10:19:22.258]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.259] getGlobalsAndPackages() ...
[10:19:22.259] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.259] Resolving globals: FALSE
[10:19:22.260] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:22.261] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:22.261] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.261] 
[10:19:22.261] getGlobalsAndPackages() ... DONE
[10:19:22.262] run() for ‘Future’ ...
[10:19:22.262] - state: ‘created’
[10:19:22.262] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.265] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.265] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.265]   - Field: ‘label’
[10:19:22.265]   - Field: ‘local’
[10:19:22.265]   - Field: ‘owner’
[10:19:22.265]   - Field: ‘envir’
[10:19:22.265]   - Field: ‘workers’
[10:19:22.266]   - Field: ‘packages’
[10:19:22.266]   - Field: ‘gc’
[10:19:22.266]   - Field: ‘job’
[10:19:22.266]   - Field: ‘conditions’
[10:19:22.266]   - Field: ‘expr’
[10:19:22.266]   - Field: ‘uuid’
[10:19:22.266]   - Field: ‘seed’
[10:19:22.266]   - Field: ‘version’
[10:19:22.267]   - Field: ‘result’
[10:19:22.267]   - Field: ‘asynchronous’
[10:19:22.267]   - Field: ‘calls’
[10:19:22.267]   - Field: ‘globals’
[10:19:22.267]   - Field: ‘stdout’
[10:19:22.267]   - Field: ‘earlySignal’
[10:19:22.267]   - Field: ‘lazy’
[10:19:22.267]   - Field: ‘state’
[10:19:22.267] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.268] - Launch lazy future ...
[10:19:22.268] Packages needed by the future expression (n = 0): <none>
[10:19:22.268] Packages needed by future strategies (n = 0): <none>
[10:19:22.269] {
[10:19:22.269]     {
[10:19:22.269]         {
[10:19:22.269]             ...future.startTime <- base::Sys.time()
[10:19:22.269]             {
[10:19:22.269]                 {
[10:19:22.269]                   {
[10:19:22.269]                     {
[10:19:22.269]                       base::local({
[10:19:22.269]                         has_future <- base::requireNamespace("future", 
[10:19:22.269]                           quietly = TRUE)
[10:19:22.269]                         if (has_future) {
[10:19:22.269]                           ns <- base::getNamespace("future")
[10:19:22.269]                           version <- ns[[".package"]][["version"]]
[10:19:22.269]                           if (is.null(version)) 
[10:19:22.269]                             version <- utils::packageVersion("future")
[10:19:22.269]                         }
[10:19:22.269]                         else {
[10:19:22.269]                           version <- NULL
[10:19:22.269]                         }
[10:19:22.269]                         if (!has_future || version < "1.8.0") {
[10:19:22.269]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.269]                             "", base::R.version$version.string), 
[10:19:22.269]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.269]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.269]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.269]                               "release", "version")], collapse = " "), 
[10:19:22.269]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.269]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.269]                             info)
[10:19:22.269]                           info <- base::paste(info, collapse = "; ")
[10:19:22.269]                           if (!has_future) {
[10:19:22.269]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.269]                               info)
[10:19:22.269]                           }
[10:19:22.269]                           else {
[10:19:22.269]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.269]                               info, version)
[10:19:22.269]                           }
[10:19:22.269]                           base::stop(msg)
[10:19:22.269]                         }
[10:19:22.269]                       })
[10:19:22.269]                     }
[10:19:22.269]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.269]                     base::options(mc.cores = 1L)
[10:19:22.269]                   }
[10:19:22.269]                   ...future.strategy.old <- future::plan("list")
[10:19:22.269]                   options(future.plan = NULL)
[10:19:22.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.269]                 }
[10:19:22.269]                 ...future.workdir <- getwd()
[10:19:22.269]             }
[10:19:22.269]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.269]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.269]         }
[10:19:22.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.269]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:19:22.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.269]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.269]             base::names(...future.oldOptions))
[10:19:22.269]     }
[10:19:22.269]     if (FALSE) {
[10:19:22.269]     }
[10:19:22.269]     else {
[10:19:22.269]         if (TRUE) {
[10:19:22.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.269]                 open = "w")
[10:19:22.269]         }
[10:19:22.269]         else {
[10:19:22.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.269]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.269]         }
[10:19:22.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.269]             base::sink(type = "output", split = FALSE)
[10:19:22.269]             base::close(...future.stdout)
[10:19:22.269]         }, add = TRUE)
[10:19:22.269]     }
[10:19:22.269]     ...future.frame <- base::sys.nframe()
[10:19:22.269]     ...future.conditions <- base::list()
[10:19:22.269]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.269]     if (FALSE) {
[10:19:22.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.269]     }
[10:19:22.269]     ...future.result <- base::tryCatch({
[10:19:22.269]         base::withCallingHandlers({
[10:19:22.269]             ...future.value <- base::withVisible(base::local({
[10:19:22.269]                 withCallingHandlers({
[10:19:22.269]                   {
[10:19:22.269]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.269]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.269]                       ...future.globals.maxSize)) {
[10:19:22.269]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.269]                       on.exit(options(oopts), add = TRUE)
[10:19:22.269]                     }
[10:19:22.269]                     {
[10:19:22.269]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.269]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.269]                         USE.NAMES = FALSE)
[10:19:22.269]                       do.call(mapply, args = args)
[10:19:22.269]                     }
[10:19:22.269]                   }
[10:19:22.269]                 }, immediateCondition = function(cond) {
[10:19:22.269]                   save_rds <- function (object, pathname, ...) 
[10:19:22.269]                   {
[10:19:22.269]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.269]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.269]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.269]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.269]                         fi_tmp[["mtime"]])
[10:19:22.269]                     }
[10:19:22.269]                     tryCatch({
[10:19:22.269]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.269]                     }, error = function(ex) {
[10:19:22.269]                       msg <- conditionMessage(ex)
[10:19:22.269]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.269]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.269]                         fi_tmp[["mtime"]], msg)
[10:19:22.269]                       ex$message <- msg
[10:19:22.269]                       stop(ex)
[10:19:22.269]                     })
[10:19:22.269]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.269]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.269]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.269]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.269]                       fi <- file.info(pathname)
[10:19:22.269]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.269]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.269]                         fi[["size"]], fi[["mtime"]])
[10:19:22.269]                       stop(msg)
[10:19:22.269]                     }
[10:19:22.269]                     invisible(pathname)
[10:19:22.269]                   }
[10:19:22.269]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.269]                     rootPath = tempdir()) 
[10:19:22.269]                   {
[10:19:22.269]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.269]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.269]                       tmpdir = path, fileext = ".rds")
[10:19:22.269]                     save_rds(obj, file)
[10:19:22.269]                   }
[10:19:22.269]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.269]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.269]                   {
[10:19:22.269]                     inherits <- base::inherits
[10:19:22.269]                     invokeRestart <- base::invokeRestart
[10:19:22.269]                     is.null <- base::is.null
[10:19:22.269]                     muffled <- FALSE
[10:19:22.269]                     if (inherits(cond, "message")) {
[10:19:22.269]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.269]                       if (muffled) 
[10:19:22.269]                         invokeRestart("muffleMessage")
[10:19:22.269]                     }
[10:19:22.269]                     else if (inherits(cond, "warning")) {
[10:19:22.269]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.269]                       if (muffled) 
[10:19:22.269]                         invokeRestart("muffleWarning")
[10:19:22.269]                     }
[10:19:22.269]                     else if (inherits(cond, "condition")) {
[10:19:22.269]                       if (!is.null(pattern)) {
[10:19:22.269]                         computeRestarts <- base::computeRestarts
[10:19:22.269]                         grepl <- base::grepl
[10:19:22.269]                         restarts <- computeRestarts(cond)
[10:19:22.269]                         for (restart in restarts) {
[10:19:22.269]                           name <- restart$name
[10:19:22.269]                           if (is.null(name)) 
[10:19:22.269]                             next
[10:19:22.269]                           if (!grepl(pattern, name)) 
[10:19:22.269]                             next
[10:19:22.269]                           invokeRestart(restart)
[10:19:22.269]                           muffled <- TRUE
[10:19:22.269]                           break
[10:19:22.269]                         }
[10:19:22.269]                       }
[10:19:22.269]                     }
[10:19:22.269]                     invisible(muffled)
[10:19:22.269]                   }
[10:19:22.269]                   muffleCondition(cond)
[10:19:22.269]                 })
[10:19:22.269]             }))
[10:19:22.269]             future::FutureResult(value = ...future.value$value, 
[10:19:22.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.269]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.269]                     ...future.globalenv.names))
[10:19:22.269]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.269]         }, condition = base::local({
[10:19:22.269]             c <- base::c
[10:19:22.269]             inherits <- base::inherits
[10:19:22.269]             invokeRestart <- base::invokeRestart
[10:19:22.269]             length <- base::length
[10:19:22.269]             list <- base::list
[10:19:22.269]             seq.int <- base::seq.int
[10:19:22.269]             signalCondition <- base::signalCondition
[10:19:22.269]             sys.calls <- base::sys.calls
[10:19:22.269]             `[[` <- base::`[[`
[10:19:22.269]             `+` <- base::`+`
[10:19:22.269]             `<<-` <- base::`<<-`
[10:19:22.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.269]                   3L)]
[10:19:22.269]             }
[10:19:22.269]             function(cond) {
[10:19:22.269]                 is_error <- inherits(cond, "error")
[10:19:22.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.269]                   NULL)
[10:19:22.269]                 if (is_error) {
[10:19:22.269]                   sessionInformation <- function() {
[10:19:22.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.269]                       search = base::search(), system = base::Sys.info())
[10:19:22.269]                   }
[10:19:22.269]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.269]                     cond$call), session = sessionInformation(), 
[10:19:22.269]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.269]                   signalCondition(cond)
[10:19:22.269]                 }
[10:19:22.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.269]                 "immediateCondition"))) {
[10:19:22.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.269]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.269]                   if (TRUE && !signal) {
[10:19:22.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.269]                     {
[10:19:22.269]                       inherits <- base::inherits
[10:19:22.269]                       invokeRestart <- base::invokeRestart
[10:19:22.269]                       is.null <- base::is.null
[10:19:22.269]                       muffled <- FALSE
[10:19:22.269]                       if (inherits(cond, "message")) {
[10:19:22.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.269]                         if (muffled) 
[10:19:22.269]                           invokeRestart("muffleMessage")
[10:19:22.269]                       }
[10:19:22.269]                       else if (inherits(cond, "warning")) {
[10:19:22.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.269]                         if (muffled) 
[10:19:22.269]                           invokeRestart("muffleWarning")
[10:19:22.269]                       }
[10:19:22.269]                       else if (inherits(cond, "condition")) {
[10:19:22.269]                         if (!is.null(pattern)) {
[10:19:22.269]                           computeRestarts <- base::computeRestarts
[10:19:22.269]                           grepl <- base::grepl
[10:19:22.269]                           restarts <- computeRestarts(cond)
[10:19:22.269]                           for (restart in restarts) {
[10:19:22.269]                             name <- restart$name
[10:19:22.269]                             if (is.null(name)) 
[10:19:22.269]                               next
[10:19:22.269]                             if (!grepl(pattern, name)) 
[10:19:22.269]                               next
[10:19:22.269]                             invokeRestart(restart)
[10:19:22.269]                             muffled <- TRUE
[10:19:22.269]                             break
[10:19:22.269]                           }
[10:19:22.269]                         }
[10:19:22.269]                       }
[10:19:22.269]                       invisible(muffled)
[10:19:22.269]                     }
[10:19:22.269]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.269]                   }
[10:19:22.269]                 }
[10:19:22.269]                 else {
[10:19:22.269]                   if (TRUE) {
[10:19:22.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.269]                     {
[10:19:22.269]                       inherits <- base::inherits
[10:19:22.269]                       invokeRestart <- base::invokeRestart
[10:19:22.269]                       is.null <- base::is.null
[10:19:22.269]                       muffled <- FALSE
[10:19:22.269]                       if (inherits(cond, "message")) {
[10:19:22.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.269]                         if (muffled) 
[10:19:22.269]                           invokeRestart("muffleMessage")
[10:19:22.269]                       }
[10:19:22.269]                       else if (inherits(cond, "warning")) {
[10:19:22.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.269]                         if (muffled) 
[10:19:22.269]                           invokeRestart("muffleWarning")
[10:19:22.269]                       }
[10:19:22.269]                       else if (inherits(cond, "condition")) {
[10:19:22.269]                         if (!is.null(pattern)) {
[10:19:22.269]                           computeRestarts <- base::computeRestarts
[10:19:22.269]                           grepl <- base::grepl
[10:19:22.269]                           restarts <- computeRestarts(cond)
[10:19:22.269]                           for (restart in restarts) {
[10:19:22.269]                             name <- restart$name
[10:19:22.269]                             if (is.null(name)) 
[10:19:22.269]                               next
[10:19:22.269]                             if (!grepl(pattern, name)) 
[10:19:22.269]                               next
[10:19:22.269]                             invokeRestart(restart)
[10:19:22.269]                             muffled <- TRUE
[10:19:22.269]                             break
[10:19:22.269]                           }
[10:19:22.269]                         }
[10:19:22.269]                       }
[10:19:22.269]                       invisible(muffled)
[10:19:22.269]                     }
[10:19:22.269]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.269]                   }
[10:19:22.269]                 }
[10:19:22.269]             }
[10:19:22.269]         }))
[10:19:22.269]     }, error = function(ex) {
[10:19:22.269]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.269]                 ...future.rng), started = ...future.startTime, 
[10:19:22.269]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.269]             version = "1.8"), class = "FutureResult")
[10:19:22.269]     }, finally = {
[10:19:22.269]         if (!identical(...future.workdir, getwd())) 
[10:19:22.269]             setwd(...future.workdir)
[10:19:22.269]         {
[10:19:22.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.269]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.269]             }
[10:19:22.269]             base::options(...future.oldOptions)
[10:19:22.269]             if (.Platform$OS.type == "windows") {
[10:19:22.269]                 old_names <- names(...future.oldEnvVars)
[10:19:22.269]                 envs <- base::Sys.getenv()
[10:19:22.269]                 names <- names(envs)
[10:19:22.269]                 common <- intersect(names, old_names)
[10:19:22.269]                 added <- setdiff(names, old_names)
[10:19:22.269]                 removed <- setdiff(old_names, names)
[10:19:22.269]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.269]                   envs[common]]
[10:19:22.269]                 NAMES <- toupper(changed)
[10:19:22.269]                 args <- list()
[10:19:22.269]                 for (kk in seq_along(NAMES)) {
[10:19:22.269]                   name <- changed[[kk]]
[10:19:22.269]                   NAME <- NAMES[[kk]]
[10:19:22.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.269]                     next
[10:19:22.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.269]                 }
[10:19:22.269]                 NAMES <- toupper(added)
[10:19:22.269]                 for (kk in seq_along(NAMES)) {
[10:19:22.269]                   name <- added[[kk]]
[10:19:22.269]                   NAME <- NAMES[[kk]]
[10:19:22.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.269]                     next
[10:19:22.269]                   args[[name]] <- ""
[10:19:22.269]                 }
[10:19:22.269]                 NAMES <- toupper(removed)
[10:19:22.269]                 for (kk in seq_along(NAMES)) {
[10:19:22.269]                   name <- removed[[kk]]
[10:19:22.269]                   NAME <- NAMES[[kk]]
[10:19:22.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.269]                     next
[10:19:22.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.269]                 }
[10:19:22.269]                 if (length(args) > 0) 
[10:19:22.269]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.269]             }
[10:19:22.269]             else {
[10:19:22.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.269]             }
[10:19:22.269]             {
[10:19:22.269]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.269]                   0L) {
[10:19:22.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.269]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.269]                   base::options(opts)
[10:19:22.269]                 }
[10:19:22.269]                 {
[10:19:22.269]                   {
[10:19:22.269]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.269]                     NULL
[10:19:22.269]                   }
[10:19:22.269]                   options(future.plan = NULL)
[10:19:22.269]                   if (is.na(NA_character_)) 
[10:19:22.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.269]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.269]                     .init = FALSE)
[10:19:22.269]                 }
[10:19:22.269]             }
[10:19:22.269]         }
[10:19:22.269]     })
[10:19:22.269]     if (TRUE) {
[10:19:22.269]         base::sink(type = "output", split = FALSE)
[10:19:22.269]         if (TRUE) {
[10:19:22.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.269]         }
[10:19:22.269]         else {
[10:19:22.269]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.269]         }
[10:19:22.269]         base::close(...future.stdout)
[10:19:22.269]         ...future.stdout <- NULL
[10:19:22.269]     }
[10:19:22.269]     ...future.result$conditions <- ...future.conditions
[10:19:22.269]     ...future.result$finished <- base::Sys.time()
[10:19:22.269]     ...future.result
[10:19:22.269] }
[10:19:22.272] assign_globals() ...
[10:19:22.272] List of 5
[10:19:22.272]  $ ...future.FUN            :function (C, k)  
[10:19:22.272]  $ MoreArgs                 : NULL
[10:19:22.272]  $ ...future.elements_ii    :List of 2
[10:19:22.272]   ..$ :List of 1
[10:19:22.272]   .. ..$ : chr "D"
[10:19:22.272]   ..$ :List of 1
[10:19:22.272]   .. ..$ : int 2
[10:19:22.272]  $ ...future.seeds_ii       : NULL
[10:19:22.272]  $ ...future.globals.maxSize: NULL
[10:19:22.272]  - attr(*, "where")=List of 5
[10:19:22.272]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.272]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.272]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.272]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.272]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.272]  - attr(*, "resolved")= logi FALSE
[10:19:22.272]  - attr(*, "total_size")= num 847
[10:19:22.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.272]  - attr(*, "already-done")= logi TRUE
[10:19:22.279] - reassign environment for ‘...future.FUN’
[10:19:22.279] - copied ‘...future.FUN’ to environment
[10:19:22.280] - copied ‘MoreArgs’ to environment
[10:19:22.280] - copied ‘...future.elements_ii’ to environment
[10:19:22.280] - copied ‘...future.seeds_ii’ to environment
[10:19:22.280] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.280] assign_globals() ... done
[10:19:22.280] requestCore(): workers = 2
[10:19:22.287] MulticoreFuture started
[10:19:22.287] - Launch lazy future ... done
[10:19:22.288] plan(): Setting new future strategy stack:
[10:19:22.288] run() for ‘MulticoreFuture’ ... done
[10:19:22.288] Created future:
[10:19:22.288] List of future strategies:
[10:19:22.288] 1. sequential:
[10:19:22.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.288]    - tweaked: FALSE
[10:19:22.288]    - call: NULL
[10:19:22.290] plan(): nbrOfWorkers() = 1
[10:19:22.293] plan(): Setting new future strategy stack:
[10:19:22.293] List of future strategies:
[10:19:22.293] 1. multicore:
[10:19:22.293]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.293]    - tweaked: FALSE
[10:19:22.293]    - call: plan(strategy)
[10:19:22.297] plan(): nbrOfWorkers() = 2
[10:19:22.289] MulticoreFuture:
[10:19:22.289] Label: ‘future_mapply-2’
[10:19:22.289] Expression:
[10:19:22.289] {
[10:19:22.289]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.289]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.289]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.289]         on.exit(options(oopts), add = TRUE)
[10:19:22.289]     }
[10:19:22.289]     {
[10:19:22.289]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.289]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.289]         do.call(mapply, args = args)
[10:19:22.289]     }
[10:19:22.289] }
[10:19:22.289] Lazy evaluation: FALSE
[10:19:22.289] Asynchronous evaluation: TRUE
[10:19:22.289] Local evaluation: TRUE
[10:19:22.289] Environment: R_GlobalEnv
[10:19:22.289] Capture standard output: TRUE
[10:19:22.289] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.289] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.289] Packages: <none>
[10:19:22.289] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.289] Resolved: TRUE
[10:19:22.289] Value: <not collected>
[10:19:22.289] Conditions captured: <none>
[10:19:22.289] Early signaling: FALSE
[10:19:22.289] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.289] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.298] Chunk #2 of 3 ... DONE
[10:19:22.299] Chunk #3 of 3 ...
[10:19:22.299]  - Finding globals in '...' for chunk #3 ...
[10:19:22.299] getGlobalsAndPackages() ...
[10:19:22.299] Searching for globals...
[10:19:22.300] 
[10:19:22.300] Searching for globals ... DONE
[10:19:22.301] - globals: [0] <none>
[10:19:22.301] getGlobalsAndPackages() ... DONE
[10:19:22.301]    + additional globals found: [n=0] 
[10:19:22.301]    + additional namespaces needed: [n=0] 
[10:19:22.301]  - Finding globals in '...' for chunk #3 ... DONE
[10:19:22.301]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:19:22.302]  - seeds: <none>
[10:19:22.302]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.302] getGlobalsAndPackages() ...
[10:19:22.302] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.303] Resolving globals: FALSE
[10:19:22.303] The total size of the 5 globals is 876 bytes (876 bytes)
[10:19:22.304] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:22.305] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.305] 
[10:19:22.305] getGlobalsAndPackages() ... DONE
[10:19:22.306] run() for ‘Future’ ...
[10:19:22.306] - state: ‘created’
[10:19:22.306] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.309] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.309] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.309]   - Field: ‘label’
[10:19:22.309]   - Field: ‘local’
[10:19:22.310]   - Field: ‘owner’
[10:19:22.310]   - Field: ‘envir’
[10:19:22.310]   - Field: ‘workers’
[10:19:22.310]   - Field: ‘packages’
[10:19:22.310]   - Field: ‘gc’
[10:19:22.310]   - Field: ‘job’
[10:19:22.310]   - Field: ‘conditions’
[10:19:22.311]   - Field: ‘expr’
[10:19:22.311]   - Field: ‘uuid’
[10:19:22.311]   - Field: ‘seed’
[10:19:22.311]   - Field: ‘version’
[10:19:22.311]   - Field: ‘result’
[10:19:22.311]   - Field: ‘asynchronous’
[10:19:22.311]   - Field: ‘calls’
[10:19:22.311]   - Field: ‘globals’
[10:19:22.312]   - Field: ‘stdout’
[10:19:22.312]   - Field: ‘earlySignal’
[10:19:22.312]   - Field: ‘lazy’
[10:19:22.312]   - Field: ‘state’
[10:19:22.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.312] - Launch lazy future ...
[10:19:22.313] Packages needed by the future expression (n = 0): <none>
[10:19:22.313] Packages needed by future strategies (n = 0): <none>
[10:19:22.313] {
[10:19:22.313]     {
[10:19:22.313]         {
[10:19:22.313]             ...future.startTime <- base::Sys.time()
[10:19:22.313]             {
[10:19:22.313]                 {
[10:19:22.313]                   {
[10:19:22.313]                     {
[10:19:22.313]                       base::local({
[10:19:22.313]                         has_future <- base::requireNamespace("future", 
[10:19:22.313]                           quietly = TRUE)
[10:19:22.313]                         if (has_future) {
[10:19:22.313]                           ns <- base::getNamespace("future")
[10:19:22.313]                           version <- ns[[".package"]][["version"]]
[10:19:22.313]                           if (is.null(version)) 
[10:19:22.313]                             version <- utils::packageVersion("future")
[10:19:22.313]                         }
[10:19:22.313]                         else {
[10:19:22.313]                           version <- NULL
[10:19:22.313]                         }
[10:19:22.313]                         if (!has_future || version < "1.8.0") {
[10:19:22.313]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.313]                             "", base::R.version$version.string), 
[10:19:22.313]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.313]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.313]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.313]                               "release", "version")], collapse = " "), 
[10:19:22.313]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.313]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.313]                             info)
[10:19:22.313]                           info <- base::paste(info, collapse = "; ")
[10:19:22.313]                           if (!has_future) {
[10:19:22.313]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.313]                               info)
[10:19:22.313]                           }
[10:19:22.313]                           else {
[10:19:22.313]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.313]                               info, version)
[10:19:22.313]                           }
[10:19:22.313]                           base::stop(msg)
[10:19:22.313]                         }
[10:19:22.313]                       })
[10:19:22.313]                     }
[10:19:22.313]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.313]                     base::options(mc.cores = 1L)
[10:19:22.313]                   }
[10:19:22.313]                   ...future.strategy.old <- future::plan("list")
[10:19:22.313]                   options(future.plan = NULL)
[10:19:22.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.313]                 }
[10:19:22.313]                 ...future.workdir <- getwd()
[10:19:22.313]             }
[10:19:22.313]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.313]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.313]         }
[10:19:22.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.313]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:19:22.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.313]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.313]             base::names(...future.oldOptions))
[10:19:22.313]     }
[10:19:22.313]     if (FALSE) {
[10:19:22.313]     }
[10:19:22.313]     else {
[10:19:22.313]         if (TRUE) {
[10:19:22.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.313]                 open = "w")
[10:19:22.313]         }
[10:19:22.313]         else {
[10:19:22.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.313]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.313]         }
[10:19:22.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.313]             base::sink(type = "output", split = FALSE)
[10:19:22.313]             base::close(...future.stdout)
[10:19:22.313]         }, add = TRUE)
[10:19:22.313]     }
[10:19:22.313]     ...future.frame <- base::sys.nframe()
[10:19:22.313]     ...future.conditions <- base::list()
[10:19:22.313]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.313]     if (FALSE) {
[10:19:22.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.313]     }
[10:19:22.313]     ...future.result <- base::tryCatch({
[10:19:22.313]         base::withCallingHandlers({
[10:19:22.313]             ...future.value <- base::withVisible(base::local({
[10:19:22.313]                 withCallingHandlers({
[10:19:22.313]                   {
[10:19:22.313]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.313]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.313]                       ...future.globals.maxSize)) {
[10:19:22.313]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.313]                       on.exit(options(oopts), add = TRUE)
[10:19:22.313]                     }
[10:19:22.313]                     {
[10:19:22.313]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.313]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.313]                         USE.NAMES = FALSE)
[10:19:22.313]                       do.call(mapply, args = args)
[10:19:22.313]                     }
[10:19:22.313]                   }
[10:19:22.313]                 }, immediateCondition = function(cond) {
[10:19:22.313]                   save_rds <- function (object, pathname, ...) 
[10:19:22.313]                   {
[10:19:22.313]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.313]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.313]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.313]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.313]                         fi_tmp[["mtime"]])
[10:19:22.313]                     }
[10:19:22.313]                     tryCatch({
[10:19:22.313]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.313]                     }, error = function(ex) {
[10:19:22.313]                       msg <- conditionMessage(ex)
[10:19:22.313]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.313]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.313]                         fi_tmp[["mtime"]], msg)
[10:19:22.313]                       ex$message <- msg
[10:19:22.313]                       stop(ex)
[10:19:22.313]                     })
[10:19:22.313]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.313]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.313]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.313]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.313]                       fi <- file.info(pathname)
[10:19:22.313]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.313]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.313]                         fi[["size"]], fi[["mtime"]])
[10:19:22.313]                       stop(msg)
[10:19:22.313]                     }
[10:19:22.313]                     invisible(pathname)
[10:19:22.313]                   }
[10:19:22.313]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.313]                     rootPath = tempdir()) 
[10:19:22.313]                   {
[10:19:22.313]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.313]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.313]                       tmpdir = path, fileext = ".rds")
[10:19:22.313]                     save_rds(obj, file)
[10:19:22.313]                   }
[10:19:22.313]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.313]                   {
[10:19:22.313]                     inherits <- base::inherits
[10:19:22.313]                     invokeRestart <- base::invokeRestart
[10:19:22.313]                     is.null <- base::is.null
[10:19:22.313]                     muffled <- FALSE
[10:19:22.313]                     if (inherits(cond, "message")) {
[10:19:22.313]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.313]                       if (muffled) 
[10:19:22.313]                         invokeRestart("muffleMessage")
[10:19:22.313]                     }
[10:19:22.313]                     else if (inherits(cond, "warning")) {
[10:19:22.313]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.313]                       if (muffled) 
[10:19:22.313]                         invokeRestart("muffleWarning")
[10:19:22.313]                     }
[10:19:22.313]                     else if (inherits(cond, "condition")) {
[10:19:22.313]                       if (!is.null(pattern)) {
[10:19:22.313]                         computeRestarts <- base::computeRestarts
[10:19:22.313]                         grepl <- base::grepl
[10:19:22.313]                         restarts <- computeRestarts(cond)
[10:19:22.313]                         for (restart in restarts) {
[10:19:22.313]                           name <- restart$name
[10:19:22.313]                           if (is.null(name)) 
[10:19:22.313]                             next
[10:19:22.313]                           if (!grepl(pattern, name)) 
[10:19:22.313]                             next
[10:19:22.313]                           invokeRestart(restart)
[10:19:22.313]                           muffled <- TRUE
[10:19:22.313]                           break
[10:19:22.313]                         }
[10:19:22.313]                       }
[10:19:22.313]                     }
[10:19:22.313]                     invisible(muffled)
[10:19:22.313]                   }
[10:19:22.313]                   muffleCondition(cond)
[10:19:22.313]                 })
[10:19:22.313]             }))
[10:19:22.313]             future::FutureResult(value = ...future.value$value, 
[10:19:22.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.313]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.313]                     ...future.globalenv.names))
[10:19:22.313]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.313]         }, condition = base::local({
[10:19:22.313]             c <- base::c
[10:19:22.313]             inherits <- base::inherits
[10:19:22.313]             invokeRestart <- base::invokeRestart
[10:19:22.313]             length <- base::length
[10:19:22.313]             list <- base::list
[10:19:22.313]             seq.int <- base::seq.int
[10:19:22.313]             signalCondition <- base::signalCondition
[10:19:22.313]             sys.calls <- base::sys.calls
[10:19:22.313]             `[[` <- base::`[[`
[10:19:22.313]             `+` <- base::`+`
[10:19:22.313]             `<<-` <- base::`<<-`
[10:19:22.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.313]                   3L)]
[10:19:22.313]             }
[10:19:22.313]             function(cond) {
[10:19:22.313]                 is_error <- inherits(cond, "error")
[10:19:22.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.313]                   NULL)
[10:19:22.313]                 if (is_error) {
[10:19:22.313]                   sessionInformation <- function() {
[10:19:22.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.313]                       search = base::search(), system = base::Sys.info())
[10:19:22.313]                   }
[10:19:22.313]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.313]                     cond$call), session = sessionInformation(), 
[10:19:22.313]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.313]                   signalCondition(cond)
[10:19:22.313]                 }
[10:19:22.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.313]                 "immediateCondition"))) {
[10:19:22.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.313]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.313]                   if (TRUE && !signal) {
[10:19:22.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.313]                     {
[10:19:22.313]                       inherits <- base::inherits
[10:19:22.313]                       invokeRestart <- base::invokeRestart
[10:19:22.313]                       is.null <- base::is.null
[10:19:22.313]                       muffled <- FALSE
[10:19:22.313]                       if (inherits(cond, "message")) {
[10:19:22.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.313]                         if (muffled) 
[10:19:22.313]                           invokeRestart("muffleMessage")
[10:19:22.313]                       }
[10:19:22.313]                       else if (inherits(cond, "warning")) {
[10:19:22.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.313]                         if (muffled) 
[10:19:22.313]                           invokeRestart("muffleWarning")
[10:19:22.313]                       }
[10:19:22.313]                       else if (inherits(cond, "condition")) {
[10:19:22.313]                         if (!is.null(pattern)) {
[10:19:22.313]                           computeRestarts <- base::computeRestarts
[10:19:22.313]                           grepl <- base::grepl
[10:19:22.313]                           restarts <- computeRestarts(cond)
[10:19:22.313]                           for (restart in restarts) {
[10:19:22.313]                             name <- restart$name
[10:19:22.313]                             if (is.null(name)) 
[10:19:22.313]                               next
[10:19:22.313]                             if (!grepl(pattern, name)) 
[10:19:22.313]                               next
[10:19:22.313]                             invokeRestart(restart)
[10:19:22.313]                             muffled <- TRUE
[10:19:22.313]                             break
[10:19:22.313]                           }
[10:19:22.313]                         }
[10:19:22.313]                       }
[10:19:22.313]                       invisible(muffled)
[10:19:22.313]                     }
[10:19:22.313]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.313]                   }
[10:19:22.313]                 }
[10:19:22.313]                 else {
[10:19:22.313]                   if (TRUE) {
[10:19:22.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.313]                     {
[10:19:22.313]                       inherits <- base::inherits
[10:19:22.313]                       invokeRestart <- base::invokeRestart
[10:19:22.313]                       is.null <- base::is.null
[10:19:22.313]                       muffled <- FALSE
[10:19:22.313]                       if (inherits(cond, "message")) {
[10:19:22.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.313]                         if (muffled) 
[10:19:22.313]                           invokeRestart("muffleMessage")
[10:19:22.313]                       }
[10:19:22.313]                       else if (inherits(cond, "warning")) {
[10:19:22.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.313]                         if (muffled) 
[10:19:22.313]                           invokeRestart("muffleWarning")
[10:19:22.313]                       }
[10:19:22.313]                       else if (inherits(cond, "condition")) {
[10:19:22.313]                         if (!is.null(pattern)) {
[10:19:22.313]                           computeRestarts <- base::computeRestarts
[10:19:22.313]                           grepl <- base::grepl
[10:19:22.313]                           restarts <- computeRestarts(cond)
[10:19:22.313]                           for (restart in restarts) {
[10:19:22.313]                             name <- restart$name
[10:19:22.313]                             if (is.null(name)) 
[10:19:22.313]                               next
[10:19:22.313]                             if (!grepl(pattern, name)) 
[10:19:22.313]                               next
[10:19:22.313]                             invokeRestart(restart)
[10:19:22.313]                             muffled <- TRUE
[10:19:22.313]                             break
[10:19:22.313]                           }
[10:19:22.313]                         }
[10:19:22.313]                       }
[10:19:22.313]                       invisible(muffled)
[10:19:22.313]                     }
[10:19:22.313]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.313]                   }
[10:19:22.313]                 }
[10:19:22.313]             }
[10:19:22.313]         }))
[10:19:22.313]     }, error = function(ex) {
[10:19:22.313]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.313]                 ...future.rng), started = ...future.startTime, 
[10:19:22.313]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.313]             version = "1.8"), class = "FutureResult")
[10:19:22.313]     }, finally = {
[10:19:22.313]         if (!identical(...future.workdir, getwd())) 
[10:19:22.313]             setwd(...future.workdir)
[10:19:22.313]         {
[10:19:22.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.313]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.313]             }
[10:19:22.313]             base::options(...future.oldOptions)
[10:19:22.313]             if (.Platform$OS.type == "windows") {
[10:19:22.313]                 old_names <- names(...future.oldEnvVars)
[10:19:22.313]                 envs <- base::Sys.getenv()
[10:19:22.313]                 names <- names(envs)
[10:19:22.313]                 common <- intersect(names, old_names)
[10:19:22.313]                 added <- setdiff(names, old_names)
[10:19:22.313]                 removed <- setdiff(old_names, names)
[10:19:22.313]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.313]                   envs[common]]
[10:19:22.313]                 NAMES <- toupper(changed)
[10:19:22.313]                 args <- list()
[10:19:22.313]                 for (kk in seq_along(NAMES)) {
[10:19:22.313]                   name <- changed[[kk]]
[10:19:22.313]                   NAME <- NAMES[[kk]]
[10:19:22.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.313]                     next
[10:19:22.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.313]                 }
[10:19:22.313]                 NAMES <- toupper(added)
[10:19:22.313]                 for (kk in seq_along(NAMES)) {
[10:19:22.313]                   name <- added[[kk]]
[10:19:22.313]                   NAME <- NAMES[[kk]]
[10:19:22.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.313]                     next
[10:19:22.313]                   args[[name]] <- ""
[10:19:22.313]                 }
[10:19:22.313]                 NAMES <- toupper(removed)
[10:19:22.313]                 for (kk in seq_along(NAMES)) {
[10:19:22.313]                   name <- removed[[kk]]
[10:19:22.313]                   NAME <- NAMES[[kk]]
[10:19:22.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.313]                     next
[10:19:22.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.313]                 }
[10:19:22.313]                 if (length(args) > 0) 
[10:19:22.313]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.313]             }
[10:19:22.313]             else {
[10:19:22.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.313]             }
[10:19:22.313]             {
[10:19:22.313]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.313]                   0L) {
[10:19:22.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.313]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.313]                   base::options(opts)
[10:19:22.313]                 }
[10:19:22.313]                 {
[10:19:22.313]                   {
[10:19:22.313]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.313]                     NULL
[10:19:22.313]                   }
[10:19:22.313]                   options(future.plan = NULL)
[10:19:22.313]                   if (is.na(NA_character_)) 
[10:19:22.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.313]                     .init = FALSE)
[10:19:22.313]                 }
[10:19:22.313]             }
[10:19:22.313]         }
[10:19:22.313]     })
[10:19:22.313]     if (TRUE) {
[10:19:22.313]         base::sink(type = "output", split = FALSE)
[10:19:22.313]         if (TRUE) {
[10:19:22.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.313]         }
[10:19:22.313]         else {
[10:19:22.313]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.313]         }
[10:19:22.313]         base::close(...future.stdout)
[10:19:22.313]         ...future.stdout <- NULL
[10:19:22.313]     }
[10:19:22.313]     ...future.result$conditions <- ...future.conditions
[10:19:22.313]     ...future.result$finished <- base::Sys.time()
[10:19:22.313]     ...future.result
[10:19:22.313] }
[10:19:22.316] assign_globals() ...
[10:19:22.316] List of 5
[10:19:22.316]  $ ...future.FUN            :function (C, k)  
[10:19:22.316]  $ MoreArgs                 : NULL
[10:19:22.316]  $ ...future.elements_ii    :List of 2
[10:19:22.316]   ..$ :List of 2
[10:19:22.316]   .. ..$ : chr "C"
[10:19:22.316]   .. ..$ : chr "E"
[10:19:22.316]   ..$ :List of 2
[10:19:22.316]   .. ..$ : int 3
[10:19:22.316]   .. ..$ : int 1
[10:19:22.316]  $ ...future.seeds_ii       : NULL
[10:19:22.316]  $ ...future.globals.maxSize: NULL
[10:19:22.316]  - attr(*, "where")=List of 5
[10:19:22.316]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.316]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.316]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.316]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.316]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.316]  - attr(*, "resolved")= logi FALSE
[10:19:22.316]  - attr(*, "total_size")= num 876
[10:19:22.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.316]  - attr(*, "already-done")= logi TRUE
[10:19:22.323] - reassign environment for ‘...future.FUN’
[10:19:22.323] - copied ‘...future.FUN’ to environment
[10:19:22.323] - copied ‘MoreArgs’ to environment
[10:19:22.323] - copied ‘...future.elements_ii’ to environment
[10:19:22.323] - copied ‘...future.seeds_ii’ to environment
[10:19:22.324] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.324] assign_globals() ... done
[10:19:22.324] requestCore(): workers = 2
[10:19:22.324] Poll #1 (0): usedCores() = 2, workers = 2
[10:19:22.335] result() for MulticoreFuture ...
[10:19:22.336] result() for MulticoreFuture ...
[10:19:22.336] result() for MulticoreFuture ... done
[10:19:22.336] result() for MulticoreFuture ... done
[10:19:22.336] result() for MulticoreFuture ...
[10:19:22.336] result() for MulticoreFuture ... done
[10:19:22.338] MulticoreFuture started
[10:19:22.339] - Launch lazy future ... done
[10:19:22.339] run() for ‘MulticoreFuture’ ... done
[10:19:22.340] Created future:
[10:19:22.340] plan(): Setting new future strategy stack:
[10:19:22.340] List of future strategies:
[10:19:22.340] 1. sequential:
[10:19:22.340]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.340]    - tweaked: FALSE
[10:19:22.340]    - call: NULL
[10:19:22.341] plan(): nbrOfWorkers() = 1
[10:19:22.350] plan(): Setting new future strategy stack:
[10:19:22.350] List of future strategies:
[10:19:22.350] 1. multicore:
[10:19:22.350]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.350]    - tweaked: FALSE
[10:19:22.350]    - call: plan(strategy)
[10:19:22.355] plan(): nbrOfWorkers() = 2
[10:19:22.340] MulticoreFuture:
[10:19:22.340] Label: ‘future_mapply-3’
[10:19:22.340] Expression:
[10:19:22.340] {
[10:19:22.340]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.340]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.340]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.340]         on.exit(options(oopts), add = TRUE)
[10:19:22.340]     }
[10:19:22.340]     {
[10:19:22.340]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.340]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.340]         do.call(mapply, args = args)
[10:19:22.340]     }
[10:19:22.340] }
[10:19:22.340] Lazy evaluation: FALSE
[10:19:22.340] Asynchronous evaluation: TRUE
[10:19:22.340] Local evaluation: TRUE
[10:19:22.340] Environment: R_GlobalEnv
[10:19:22.340] Capture standard output: TRUE
[10:19:22.340] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.340] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.340] Packages: <none>
[10:19:22.340] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.340] Resolved: TRUE
[10:19:22.340] Value: <not collected>
[10:19:22.340] Conditions captured: <none>
[10:19:22.340] Early signaling: FALSE
[10:19:22.340] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.340] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.356] Chunk #3 of 3 ... DONE
[10:19:22.356] Launching 3 futures (chunks) ... DONE
[10:19:22.357] Resolving 3 futures (chunks) ...
[10:19:22.357] resolve() on list ...
[10:19:22.357]  recursive: 0
[10:19:22.357]  length: 3
[10:19:22.357] 
[10:19:22.358] Future #1
[10:19:22.358] result() for MulticoreFuture ...
[10:19:22.358] result() for MulticoreFuture ... done
[10:19:22.358] result() for MulticoreFuture ...
[10:19:22.358] result() for MulticoreFuture ... done
[10:19:22.359] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:22.359] - nx: 3
[10:19:22.359] - relay: TRUE
[10:19:22.359] - stdout: TRUE
[10:19:22.360] - signal: TRUE
[10:19:22.360] - resignal: FALSE
[10:19:22.360] - force: TRUE
[10:19:22.360] - relayed: [n=3] FALSE, FALSE, FALSE
[10:19:22.360] - queued futures: [n=3] FALSE, FALSE, FALSE
[10:19:22.361]  - until=1
[10:19:22.361]  - relaying element #1
[10:19:22.361] result() for MulticoreFuture ...
[10:19:22.361] result() for MulticoreFuture ... done
[10:19:22.362] result() for MulticoreFuture ...
[10:19:22.362] result() for MulticoreFuture ... done
[10:19:22.362] result() for MulticoreFuture ...
[10:19:22.362] result() for MulticoreFuture ... done
[10:19:22.363] result() for MulticoreFuture ...
[10:19:22.363] result() for MulticoreFuture ... done
[10:19:22.363] - relayed: [n=3] TRUE, FALSE, FALSE
[10:19:22.363] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:19:22.363] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:22.364]  length: 2 (resolved future 1)
[10:19:22.364] Future #2
[10:19:22.364] result() for MulticoreFuture ...
[10:19:22.365] result() for MulticoreFuture ...
[10:19:22.366] result() for MulticoreFuture ... done
[10:19:22.366] result() for MulticoreFuture ... done
[10:19:22.366] result() for MulticoreFuture ...
[10:19:22.366] result() for MulticoreFuture ... done
[10:19:22.366] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:22.367] - nx: 3
[10:19:22.367] - relay: TRUE
[10:19:22.367] - stdout: TRUE
[10:19:22.367] - signal: TRUE
[10:19:22.367] - resignal: FALSE
[10:19:22.367] - force: TRUE
[10:19:22.367] - relayed: [n=3] TRUE, FALSE, FALSE
[10:19:22.368] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:19:22.368]  - until=2
[10:19:22.368]  - relaying element #2
[10:19:22.368] result() for MulticoreFuture ...
[10:19:22.368] result() for MulticoreFuture ... done
[10:19:22.368] result() for MulticoreFuture ...
[10:19:22.368] result() for MulticoreFuture ... done
[10:19:22.369] result() for MulticoreFuture ...
[10:19:22.369] result() for MulticoreFuture ... done
[10:19:22.369] result() for MulticoreFuture ...
[10:19:22.369] result() for MulticoreFuture ... done
[10:19:22.369] - relayed: [n=3] TRUE, TRUE, FALSE
[10:19:22.369] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:19:22.369] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:22.370]  length: 1 (resolved future 2)
[10:19:22.370] Future #3
[10:19:22.370] result() for MulticoreFuture ...
[10:19:22.371] result() for MulticoreFuture ...
[10:19:22.371] result() for MulticoreFuture ... done
[10:19:22.371] result() for MulticoreFuture ... done
[10:19:22.371] result() for MulticoreFuture ...
[10:19:22.371] result() for MulticoreFuture ... done
[10:19:22.372] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:19:22.372] - nx: 3
[10:19:22.372] - relay: TRUE
[10:19:22.372] - stdout: TRUE
[10:19:22.372] - signal: TRUE
[10:19:22.372] - resignal: FALSE
[10:19:22.372] - force: TRUE
[10:19:22.372] - relayed: [n=3] TRUE, TRUE, FALSE
[10:19:22.373] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:19:22.373]  - until=3
[10:19:22.373]  - relaying element #3
[10:19:22.373] result() for MulticoreFuture ...
[10:19:22.373] result() for MulticoreFuture ... done
[10:19:22.373] result() for MulticoreFuture ...
[10:19:22.374] result() for MulticoreFuture ... done
[10:19:22.374] result() for MulticoreFuture ...
[10:19:22.374] result() for MulticoreFuture ... done
[10:19:22.374] result() for MulticoreFuture ...
[10:19:22.374] result() for MulticoreFuture ... done
[10:19:22.374] - relayed: [n=3] TRUE, TRUE, TRUE
[10:19:22.374] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:19:22.375] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:19:22.375]  length: 0 (resolved future 3)
[10:19:22.375] Relaying remaining futures
[10:19:22.375] signalConditionsASAP(NULL, pos=0) ...
[10:19:22.375] - nx: 3
[10:19:22.375] - relay: TRUE
[10:19:22.375] - stdout: TRUE
[10:19:22.375] - signal: TRUE
[10:19:22.375] - resignal: FALSE
[10:19:22.375] - force: TRUE
[10:19:22.375] - relayed: [n=3] TRUE, TRUE, TRUE
[10:19:22.376] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[10:19:22.376] - relayed: [n=3] TRUE, TRUE, TRUE
[10:19:22.376] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:19:22.376] signalConditionsASAP(NULL, pos=0) ... done
[10:19:22.376] resolve() on list ... DONE
[10:19:22.376] result() for MulticoreFuture ...
[10:19:22.376] result() for MulticoreFuture ... done
[10:19:22.376] result() for MulticoreFuture ...
[10:19:22.376] result() for MulticoreFuture ... done
[10:19:22.377] result() for MulticoreFuture ...
[10:19:22.377] result() for MulticoreFuture ... done
[10:19:22.377] result() for MulticoreFuture ...
[10:19:22.377] result() for MulticoreFuture ... done
[10:19:22.377] result() for MulticoreFuture ...
[10:19:22.377] result() for MulticoreFuture ... done
[10:19:22.377] result() for MulticoreFuture ...
[10:19:22.377] result() for MulticoreFuture ... done
[10:19:22.377]  - Number of value chunks collected: 3
[10:19:22.377] Resolving 3 futures (chunks) ... DONE
[10:19:22.378] Reducing values from 3 chunks ...
[10:19:22.378]  - Number of values collected after concatenation: 5
[10:19:22.378]  - Number of values expected: 5
[10:19:22.378] Reverse index remapping (attribute 'ordering'): [n = 5] 2, 1, 4, 3, 5
[10:19:22.378] Reducing values from 3 chunks ... DONE
[10:19:22.378] future_mapply() ... DONE
[10:19:22.378] future_mapply() ...
[10:19:22.380] Number of chunks: 2
[10:19:22.381] getGlobalsAndPackagesXApply() ...
[10:19:22.381]  - future.globals: TRUE
[10:19:22.381] getGlobalsAndPackages() ...
[10:19:22.381] Searching for globals...
[10:19:22.382] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:22.382] Searching for globals ... DONE
[10:19:22.383] Resolving globals: FALSE
[10:19:22.383] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:22.383] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:22.383] - globals: [1] ‘FUN’
[10:19:22.384] 
[10:19:22.384] getGlobalsAndPackages() ... DONE
[10:19:22.384]  - globals found/used: [n=1] ‘FUN’
[10:19:22.384]  - needed namespaces: [n=0] 
[10:19:22.384] Finding globals ... DONE
[10:19:22.384] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:22.386] List of 2
[10:19:22.386]  $ ...future.FUN:function (C, k)  
[10:19:22.386]  $ MoreArgs     : list()
[10:19:22.386]  - attr(*, "where")=List of 2
[10:19:22.386]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:22.386]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:22.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.386]  - attr(*, "resolved")= logi FALSE
[10:19:22.386]  - attr(*, "total_size")= num NA
[10:19:22.390] Packages to be attached in all futures: [n=0] 
[10:19:22.390] getGlobalsAndPackagesXApply() ... DONE
[10:19:22.390] Number of futures (= number of chunks): 2
[10:19:22.390] Launching 2 futures (chunks) ...
[10:19:22.390] Chunk #1 of 2 ...
[10:19:22.390]  - Finding globals in '...' for chunk #1 ...
[10:19:22.390] getGlobalsAndPackages() ...
[10:19:22.390] Searching for globals...
[10:19:22.391] 
[10:19:22.391] Searching for globals ... DONE
[10:19:22.391] - globals: [0] <none>
[10:19:22.391] getGlobalsAndPackages() ... DONE
[10:19:22.391]    + additional globals found: [n=0] 
[10:19:22.391]    + additional namespaces needed: [n=0] 
[10:19:22.391]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:22.392]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.392]  - seeds: <none>
[10:19:22.392]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.392] getGlobalsAndPackages() ...
[10:19:22.392] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.392] Resolving globals: FALSE
[10:19:22.393] The total size of the 5 globals is 880 bytes (880 bytes)
[10:19:22.393] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:22.393] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.393] 
[10:19:22.393] getGlobalsAndPackages() ... DONE
[10:19:22.394] run() for ‘Future’ ...
[10:19:22.394] - state: ‘created’
[10:19:22.394] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.396] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.396] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.396]   - Field: ‘label’
[10:19:22.396]   - Field: ‘local’
[10:19:22.396]   - Field: ‘owner’
[10:19:22.396]   - Field: ‘envir’
[10:19:22.396]   - Field: ‘workers’
[10:19:22.396]   - Field: ‘packages’
[10:19:22.396]   - Field: ‘gc’
[10:19:22.396]   - Field: ‘job’
[10:19:22.396]   - Field: ‘conditions’
[10:19:22.397]   - Field: ‘expr’
[10:19:22.397]   - Field: ‘uuid’
[10:19:22.397]   - Field: ‘seed’
[10:19:22.397]   - Field: ‘version’
[10:19:22.397]   - Field: ‘result’
[10:19:22.397]   - Field: ‘asynchronous’
[10:19:22.397]   - Field: ‘calls’
[10:19:22.397]   - Field: ‘globals’
[10:19:22.397]   - Field: ‘stdout’
[10:19:22.397]   - Field: ‘earlySignal’
[10:19:22.397]   - Field: ‘lazy’
[10:19:22.397]   - Field: ‘state’
[10:19:22.398] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.398] - Launch lazy future ...
[10:19:22.398] Packages needed by the future expression (n = 0): <none>
[10:19:22.398] Packages needed by future strategies (n = 0): <none>
[10:19:22.398] {
[10:19:22.398]     {
[10:19:22.398]         {
[10:19:22.398]             ...future.startTime <- base::Sys.time()
[10:19:22.398]             {
[10:19:22.398]                 {
[10:19:22.398]                   {
[10:19:22.398]                     {
[10:19:22.398]                       base::local({
[10:19:22.398]                         has_future <- base::requireNamespace("future", 
[10:19:22.398]                           quietly = TRUE)
[10:19:22.398]                         if (has_future) {
[10:19:22.398]                           ns <- base::getNamespace("future")
[10:19:22.398]                           version <- ns[[".package"]][["version"]]
[10:19:22.398]                           if (is.null(version)) 
[10:19:22.398]                             version <- utils::packageVersion("future")
[10:19:22.398]                         }
[10:19:22.398]                         else {
[10:19:22.398]                           version <- NULL
[10:19:22.398]                         }
[10:19:22.398]                         if (!has_future || version < "1.8.0") {
[10:19:22.398]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.398]                             "", base::R.version$version.string), 
[10:19:22.398]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.398]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.398]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.398]                               "release", "version")], collapse = " "), 
[10:19:22.398]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.398]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.398]                             info)
[10:19:22.398]                           info <- base::paste(info, collapse = "; ")
[10:19:22.398]                           if (!has_future) {
[10:19:22.398]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.398]                               info)
[10:19:22.398]                           }
[10:19:22.398]                           else {
[10:19:22.398]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.398]                               info, version)
[10:19:22.398]                           }
[10:19:22.398]                           base::stop(msg)
[10:19:22.398]                         }
[10:19:22.398]                       })
[10:19:22.398]                     }
[10:19:22.398]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.398]                     base::options(mc.cores = 1L)
[10:19:22.398]                   }
[10:19:22.398]                   ...future.strategy.old <- future::plan("list")
[10:19:22.398]                   options(future.plan = NULL)
[10:19:22.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.398]                 }
[10:19:22.398]                 ...future.workdir <- getwd()
[10:19:22.398]             }
[10:19:22.398]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.398]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.398]         }
[10:19:22.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.398]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.398]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.398]             base::names(...future.oldOptions))
[10:19:22.398]     }
[10:19:22.398]     if (FALSE) {
[10:19:22.398]     }
[10:19:22.398]     else {
[10:19:22.398]         if (TRUE) {
[10:19:22.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.398]                 open = "w")
[10:19:22.398]         }
[10:19:22.398]         else {
[10:19:22.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.398]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.398]         }
[10:19:22.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.398]             base::sink(type = "output", split = FALSE)
[10:19:22.398]             base::close(...future.stdout)
[10:19:22.398]         }, add = TRUE)
[10:19:22.398]     }
[10:19:22.398]     ...future.frame <- base::sys.nframe()
[10:19:22.398]     ...future.conditions <- base::list()
[10:19:22.398]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.398]     if (FALSE) {
[10:19:22.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.398]     }
[10:19:22.398]     ...future.result <- base::tryCatch({
[10:19:22.398]         base::withCallingHandlers({
[10:19:22.398]             ...future.value <- base::withVisible(base::local({
[10:19:22.398]                 withCallingHandlers({
[10:19:22.398]                   {
[10:19:22.398]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.398]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.398]                       ...future.globals.maxSize)) {
[10:19:22.398]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.398]                       on.exit(options(oopts), add = TRUE)
[10:19:22.398]                     }
[10:19:22.398]                     {
[10:19:22.398]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.398]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.398]                         USE.NAMES = FALSE)
[10:19:22.398]                       do.call(mapply, args = args)
[10:19:22.398]                     }
[10:19:22.398]                   }
[10:19:22.398]                 }, immediateCondition = function(cond) {
[10:19:22.398]                   save_rds <- function (object, pathname, ...) 
[10:19:22.398]                   {
[10:19:22.398]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.398]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.398]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.398]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.398]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.398]                         fi_tmp[["mtime"]])
[10:19:22.398]                     }
[10:19:22.398]                     tryCatch({
[10:19:22.398]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.398]                     }, error = function(ex) {
[10:19:22.398]                       msg <- conditionMessage(ex)
[10:19:22.398]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.398]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.398]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.398]                         fi_tmp[["mtime"]], msg)
[10:19:22.398]                       ex$message <- msg
[10:19:22.398]                       stop(ex)
[10:19:22.398]                     })
[10:19:22.398]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.398]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.398]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.398]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.398]                       fi <- file.info(pathname)
[10:19:22.398]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.398]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.398]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.398]                         fi[["size"]], fi[["mtime"]])
[10:19:22.398]                       stop(msg)
[10:19:22.398]                     }
[10:19:22.398]                     invisible(pathname)
[10:19:22.398]                   }
[10:19:22.398]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.398]                     rootPath = tempdir()) 
[10:19:22.398]                   {
[10:19:22.398]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.398]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.398]                       tmpdir = path, fileext = ".rds")
[10:19:22.398]                     save_rds(obj, file)
[10:19:22.398]                   }
[10:19:22.398]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.398]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.398]                   {
[10:19:22.398]                     inherits <- base::inherits
[10:19:22.398]                     invokeRestart <- base::invokeRestart
[10:19:22.398]                     is.null <- base::is.null
[10:19:22.398]                     muffled <- FALSE
[10:19:22.398]                     if (inherits(cond, "message")) {
[10:19:22.398]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.398]                       if (muffled) 
[10:19:22.398]                         invokeRestart("muffleMessage")
[10:19:22.398]                     }
[10:19:22.398]                     else if (inherits(cond, "warning")) {
[10:19:22.398]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.398]                       if (muffled) 
[10:19:22.398]                         invokeRestart("muffleWarning")
[10:19:22.398]                     }
[10:19:22.398]                     else if (inherits(cond, "condition")) {
[10:19:22.398]                       if (!is.null(pattern)) {
[10:19:22.398]                         computeRestarts <- base::computeRestarts
[10:19:22.398]                         grepl <- base::grepl
[10:19:22.398]                         restarts <- computeRestarts(cond)
[10:19:22.398]                         for (restart in restarts) {
[10:19:22.398]                           name <- restart$name
[10:19:22.398]                           if (is.null(name)) 
[10:19:22.398]                             next
[10:19:22.398]                           if (!grepl(pattern, name)) 
[10:19:22.398]                             next
[10:19:22.398]                           invokeRestart(restart)
[10:19:22.398]                           muffled <- TRUE
[10:19:22.398]                           break
[10:19:22.398]                         }
[10:19:22.398]                       }
[10:19:22.398]                     }
[10:19:22.398]                     invisible(muffled)
[10:19:22.398]                   }
[10:19:22.398]                   muffleCondition(cond)
[10:19:22.398]                 })
[10:19:22.398]             }))
[10:19:22.398]             future::FutureResult(value = ...future.value$value, 
[10:19:22.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.398]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.398]                     ...future.globalenv.names))
[10:19:22.398]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.398]         }, condition = base::local({
[10:19:22.398]             c <- base::c
[10:19:22.398]             inherits <- base::inherits
[10:19:22.398]             invokeRestart <- base::invokeRestart
[10:19:22.398]             length <- base::length
[10:19:22.398]             list <- base::list
[10:19:22.398]             seq.int <- base::seq.int
[10:19:22.398]             signalCondition <- base::signalCondition
[10:19:22.398]             sys.calls <- base::sys.calls
[10:19:22.398]             `[[` <- base::`[[`
[10:19:22.398]             `+` <- base::`+`
[10:19:22.398]             `<<-` <- base::`<<-`
[10:19:22.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.398]                   3L)]
[10:19:22.398]             }
[10:19:22.398]             function(cond) {
[10:19:22.398]                 is_error <- inherits(cond, "error")
[10:19:22.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.398]                   NULL)
[10:19:22.398]                 if (is_error) {
[10:19:22.398]                   sessionInformation <- function() {
[10:19:22.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.398]                       search = base::search(), system = base::Sys.info())
[10:19:22.398]                   }
[10:19:22.398]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.398]                     cond$call), session = sessionInformation(), 
[10:19:22.398]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.398]                   signalCondition(cond)
[10:19:22.398]                 }
[10:19:22.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.398]                 "immediateCondition"))) {
[10:19:22.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.398]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.398]                   if (TRUE && !signal) {
[10:19:22.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.398]                     {
[10:19:22.398]                       inherits <- base::inherits
[10:19:22.398]                       invokeRestart <- base::invokeRestart
[10:19:22.398]                       is.null <- base::is.null
[10:19:22.398]                       muffled <- FALSE
[10:19:22.398]                       if (inherits(cond, "message")) {
[10:19:22.398]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.398]                         if (muffled) 
[10:19:22.398]                           invokeRestart("muffleMessage")
[10:19:22.398]                       }
[10:19:22.398]                       else if (inherits(cond, "warning")) {
[10:19:22.398]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.398]                         if (muffled) 
[10:19:22.398]                           invokeRestart("muffleWarning")
[10:19:22.398]                       }
[10:19:22.398]                       else if (inherits(cond, "condition")) {
[10:19:22.398]                         if (!is.null(pattern)) {
[10:19:22.398]                           computeRestarts <- base::computeRestarts
[10:19:22.398]                           grepl <- base::grepl
[10:19:22.398]                           restarts <- computeRestarts(cond)
[10:19:22.398]                           for (restart in restarts) {
[10:19:22.398]                             name <- restart$name
[10:19:22.398]                             if (is.null(name)) 
[10:19:22.398]                               next
[10:19:22.398]                             if (!grepl(pattern, name)) 
[10:19:22.398]                               next
[10:19:22.398]                             invokeRestart(restart)
[10:19:22.398]                             muffled <- TRUE
[10:19:22.398]                             break
[10:19:22.398]                           }
[10:19:22.398]                         }
[10:19:22.398]                       }
[10:19:22.398]                       invisible(muffled)
[10:19:22.398]                     }
[10:19:22.398]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.398]                   }
[10:19:22.398]                 }
[10:19:22.398]                 else {
[10:19:22.398]                   if (TRUE) {
[10:19:22.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.398]                     {
[10:19:22.398]                       inherits <- base::inherits
[10:19:22.398]                       invokeRestart <- base::invokeRestart
[10:19:22.398]                       is.null <- base::is.null
[10:19:22.398]                       muffled <- FALSE
[10:19:22.398]                       if (inherits(cond, "message")) {
[10:19:22.398]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.398]                         if (muffled) 
[10:19:22.398]                           invokeRestart("muffleMessage")
[10:19:22.398]                       }
[10:19:22.398]                       else if (inherits(cond, "warning")) {
[10:19:22.398]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.398]                         if (muffled) 
[10:19:22.398]                           invokeRestart("muffleWarning")
[10:19:22.398]                       }
[10:19:22.398]                       else if (inherits(cond, "condition")) {
[10:19:22.398]                         if (!is.null(pattern)) {
[10:19:22.398]                           computeRestarts <- base::computeRestarts
[10:19:22.398]                           grepl <- base::grepl
[10:19:22.398]                           restarts <- computeRestarts(cond)
[10:19:22.398]                           for (restart in restarts) {
[10:19:22.398]                             name <- restart$name
[10:19:22.398]                             if (is.null(name)) 
[10:19:22.398]                               next
[10:19:22.398]                             if (!grepl(pattern, name)) 
[10:19:22.398]                               next
[10:19:22.398]                             invokeRestart(restart)
[10:19:22.398]                             muffled <- TRUE
[10:19:22.398]                             break
[10:19:22.398]                           }
[10:19:22.398]                         }
[10:19:22.398]                       }
[10:19:22.398]                       invisible(muffled)
[10:19:22.398]                     }
[10:19:22.398]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.398]                   }
[10:19:22.398]                 }
[10:19:22.398]             }
[10:19:22.398]         }))
[10:19:22.398]     }, error = function(ex) {
[10:19:22.398]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.398]                 ...future.rng), started = ...future.startTime, 
[10:19:22.398]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.398]             version = "1.8"), class = "FutureResult")
[10:19:22.398]     }, finally = {
[10:19:22.398]         if (!identical(...future.workdir, getwd())) 
[10:19:22.398]             setwd(...future.workdir)
[10:19:22.398]         {
[10:19:22.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.398]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.398]             }
[10:19:22.398]             base::options(...future.oldOptions)
[10:19:22.398]             if (.Platform$OS.type == "windows") {
[10:19:22.398]                 old_names <- names(...future.oldEnvVars)
[10:19:22.398]                 envs <- base::Sys.getenv()
[10:19:22.398]                 names <- names(envs)
[10:19:22.398]                 common <- intersect(names, old_names)
[10:19:22.398]                 added <- setdiff(names, old_names)
[10:19:22.398]                 removed <- setdiff(old_names, names)
[10:19:22.398]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.398]                   envs[common]]
[10:19:22.398]                 NAMES <- toupper(changed)
[10:19:22.398]                 args <- list()
[10:19:22.398]                 for (kk in seq_along(NAMES)) {
[10:19:22.398]                   name <- changed[[kk]]
[10:19:22.398]                   NAME <- NAMES[[kk]]
[10:19:22.398]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.398]                     next
[10:19:22.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.398]                 }
[10:19:22.398]                 NAMES <- toupper(added)
[10:19:22.398]                 for (kk in seq_along(NAMES)) {
[10:19:22.398]                   name <- added[[kk]]
[10:19:22.398]                   NAME <- NAMES[[kk]]
[10:19:22.398]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.398]                     next
[10:19:22.398]                   args[[name]] <- ""
[10:19:22.398]                 }
[10:19:22.398]                 NAMES <- toupper(removed)
[10:19:22.398]                 for (kk in seq_along(NAMES)) {
[10:19:22.398]                   name <- removed[[kk]]
[10:19:22.398]                   NAME <- NAMES[[kk]]
[10:19:22.398]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.398]                     next
[10:19:22.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.398]                 }
[10:19:22.398]                 if (length(args) > 0) 
[10:19:22.398]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.398]             }
[10:19:22.398]             else {
[10:19:22.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.398]             }
[10:19:22.398]             {
[10:19:22.398]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.398]                   0L) {
[10:19:22.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.398]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.398]                   base::options(opts)
[10:19:22.398]                 }
[10:19:22.398]                 {
[10:19:22.398]                   {
[10:19:22.398]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.398]                     NULL
[10:19:22.398]                   }
[10:19:22.398]                   options(future.plan = NULL)
[10:19:22.398]                   if (is.na(NA_character_)) 
[10:19:22.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.398]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.398]                     .init = FALSE)
[10:19:22.398]                 }
[10:19:22.398]             }
[10:19:22.398]         }
[10:19:22.398]     })
[10:19:22.398]     if (TRUE) {
[10:19:22.398]         base::sink(type = "output", split = FALSE)
[10:19:22.398]         if (TRUE) {
[10:19:22.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.398]         }
[10:19:22.398]         else {
[10:19:22.398]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.398]         }
[10:19:22.398]         base::close(...future.stdout)
[10:19:22.398]         ...future.stdout <- NULL
[10:19:22.398]     }
[10:19:22.398]     ...future.result$conditions <- ...future.conditions
[10:19:22.398]     ...future.result$finished <- base::Sys.time()
[10:19:22.398]     ...future.result
[10:19:22.398] }
[10:19:22.401] assign_globals() ...
[10:19:22.401] List of 5
[10:19:22.401]  $ ...future.FUN            :function (C, k)  
[10:19:22.401]  $ MoreArgs                 : list()
[10:19:22.401]  $ ...future.elements_ii    :List of 2
[10:19:22.401]   ..$ :List of 2
[10:19:22.401]   .. ..$ : chr "A"
[10:19:22.401]   .. ..$ : chr "B"
[10:19:22.401]   ..$ :List of 2
[10:19:22.401]   .. ..$ : int 5
[10:19:22.401]   .. ..$ : int 4
[10:19:22.401]  $ ...future.seeds_ii       : NULL
[10:19:22.401]  $ ...future.globals.maxSize: NULL
[10:19:22.401]  - attr(*, "where")=List of 5
[10:19:22.401]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.401]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.401]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.401]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.401]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.401]  - attr(*, "resolved")= logi FALSE
[10:19:22.401]  - attr(*, "total_size")= num 880
[10:19:22.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.401]  - attr(*, "already-done")= logi TRUE
[10:19:22.406] - reassign environment for ‘...future.FUN’
[10:19:22.407] - copied ‘...future.FUN’ to environment
[10:19:22.407] - copied ‘MoreArgs’ to environment
[10:19:22.407] - copied ‘...future.elements_ii’ to environment
[10:19:22.407] - copied ‘...future.seeds_ii’ to environment
[10:19:22.407] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.407] assign_globals() ... done
[10:19:22.407] requestCore(): workers = 2
[10:19:22.412] MulticoreFuture started
[10:19:22.412] - Launch lazy future ... done
[10:19:22.413] run() for ‘MulticoreFuture’ ... done
[10:19:22.413] plan(): Setting new future strategy stack:
[10:19:22.414] Created future:
[10:19:22.414] List of future strategies:
[10:19:22.414] 1. sequential:
[10:19:22.414]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.414]    - tweaked: FALSE
[10:19:22.414]    - call: NULL
[10:19:22.416] plan(): nbrOfWorkers() = 1
[10:19:22.418] plan(): Setting new future strategy stack:
[10:19:22.419] List of future strategies:
[10:19:22.419] 1. multicore:
[10:19:22.419]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.419]    - tweaked: FALSE
[10:19:22.419]    - call: plan(strategy)
[10:19:22.423] plan(): nbrOfWorkers() = 2
[10:19:22.414] MulticoreFuture:
[10:19:22.414] Label: ‘future_.mapply-1’
[10:19:22.414] Expression:
[10:19:22.414] {
[10:19:22.414]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.414]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.414]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.414]         on.exit(options(oopts), add = TRUE)
[10:19:22.414]     }
[10:19:22.414]     {
[10:19:22.414]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.414]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.414]         do.call(mapply, args = args)
[10:19:22.414]     }
[10:19:22.414] }
[10:19:22.414] Lazy evaluation: FALSE
[10:19:22.414] Asynchronous evaluation: TRUE
[10:19:22.414] Local evaluation: TRUE
[10:19:22.414] Environment: R_GlobalEnv
[10:19:22.414] Capture standard output: TRUE
[10:19:22.414] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.414] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.414] Packages: <none>
[10:19:22.414] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.414] Resolved: TRUE
[10:19:22.414] Value: <not collected>
[10:19:22.414] Conditions captured: <none>
[10:19:22.414] Early signaling: FALSE
[10:19:22.414] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.414] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.425] Chunk #1 of 2 ... DONE
[10:19:22.425] Chunk #2 of 2 ...
[10:19:22.425]  - Finding globals in '...' for chunk #2 ...
[10:19:22.425] getGlobalsAndPackages() ...
[10:19:22.426] Searching for globals...
[10:19:22.426] 
[10:19:22.427] Searching for globals ... DONE
[10:19:22.427] - globals: [0] <none>
[10:19:22.427] getGlobalsAndPackages() ... DONE
[10:19:22.427]    + additional globals found: [n=0] 
[10:19:22.427]    + additional namespaces needed: [n=0] 
[10:19:22.428]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:22.428]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.428]  - seeds: <none>
[10:19:22.428]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.428] getGlobalsAndPackages() ...
[10:19:22.429] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.429] Resolving globals: FALSE
[10:19:22.430] The total size of the 5 globals is 909 bytes (909 bytes)
[10:19:22.431] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:22.431] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.432] 
[10:19:22.432] getGlobalsAndPackages() ... DONE
[10:19:22.432] run() for ‘Future’ ...
[10:19:22.433] - state: ‘created’
[10:19:22.433] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.436] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.436]   - Field: ‘label’
[10:19:22.436]   - Field: ‘local’
[10:19:22.436]   - Field: ‘owner’
[10:19:22.437]   - Field: ‘envir’
[10:19:22.437]   - Field: ‘workers’
[10:19:22.437]   - Field: ‘packages’
[10:19:22.437]   - Field: ‘gc’
[10:19:22.437]   - Field: ‘job’
[10:19:22.437]   - Field: ‘conditions’
[10:19:22.437]   - Field: ‘expr’
[10:19:22.438]   - Field: ‘uuid’
[10:19:22.438]   - Field: ‘seed’
[10:19:22.438]   - Field: ‘version’
[10:19:22.438]   - Field: ‘result’
[10:19:22.438]   - Field: ‘asynchronous’
[10:19:22.438]   - Field: ‘calls’
[10:19:22.438]   - Field: ‘globals’
[10:19:22.438]   - Field: ‘stdout’
[10:19:22.439]   - Field: ‘earlySignal’
[10:19:22.439]   - Field: ‘lazy’
[10:19:22.439]   - Field: ‘state’
[10:19:22.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.439] - Launch lazy future ...
[10:19:22.439] Packages needed by the future expression (n = 0): <none>
[10:19:22.440] Packages needed by future strategies (n = 0): <none>
[10:19:22.440] {
[10:19:22.440]     {
[10:19:22.440]         {
[10:19:22.440]             ...future.startTime <- base::Sys.time()
[10:19:22.440]             {
[10:19:22.440]                 {
[10:19:22.440]                   {
[10:19:22.440]                     {
[10:19:22.440]                       base::local({
[10:19:22.440]                         has_future <- base::requireNamespace("future", 
[10:19:22.440]                           quietly = TRUE)
[10:19:22.440]                         if (has_future) {
[10:19:22.440]                           ns <- base::getNamespace("future")
[10:19:22.440]                           version <- ns[[".package"]][["version"]]
[10:19:22.440]                           if (is.null(version)) 
[10:19:22.440]                             version <- utils::packageVersion("future")
[10:19:22.440]                         }
[10:19:22.440]                         else {
[10:19:22.440]                           version <- NULL
[10:19:22.440]                         }
[10:19:22.440]                         if (!has_future || version < "1.8.0") {
[10:19:22.440]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.440]                             "", base::R.version$version.string), 
[10:19:22.440]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.440]                               "release", "version")], collapse = " "), 
[10:19:22.440]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.440]                             info)
[10:19:22.440]                           info <- base::paste(info, collapse = "; ")
[10:19:22.440]                           if (!has_future) {
[10:19:22.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.440]                               info)
[10:19:22.440]                           }
[10:19:22.440]                           else {
[10:19:22.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.440]                               info, version)
[10:19:22.440]                           }
[10:19:22.440]                           base::stop(msg)
[10:19:22.440]                         }
[10:19:22.440]                       })
[10:19:22.440]                     }
[10:19:22.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.440]                     base::options(mc.cores = 1L)
[10:19:22.440]                   }
[10:19:22.440]                   ...future.strategy.old <- future::plan("list")
[10:19:22.440]                   options(future.plan = NULL)
[10:19:22.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.440]                 }
[10:19:22.440]                 ...future.workdir <- getwd()
[10:19:22.440]             }
[10:19:22.440]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.440]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.440]         }
[10:19:22.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.440]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.440]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.440]             base::names(...future.oldOptions))
[10:19:22.440]     }
[10:19:22.440]     if (FALSE) {
[10:19:22.440]     }
[10:19:22.440]     else {
[10:19:22.440]         if (TRUE) {
[10:19:22.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.440]                 open = "w")
[10:19:22.440]         }
[10:19:22.440]         else {
[10:19:22.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.440]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.440]         }
[10:19:22.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.440]             base::sink(type = "output", split = FALSE)
[10:19:22.440]             base::close(...future.stdout)
[10:19:22.440]         }, add = TRUE)
[10:19:22.440]     }
[10:19:22.440]     ...future.frame <- base::sys.nframe()
[10:19:22.440]     ...future.conditions <- base::list()
[10:19:22.440]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.440]     if (FALSE) {
[10:19:22.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.440]     }
[10:19:22.440]     ...future.result <- base::tryCatch({
[10:19:22.440]         base::withCallingHandlers({
[10:19:22.440]             ...future.value <- base::withVisible(base::local({
[10:19:22.440]                 withCallingHandlers({
[10:19:22.440]                   {
[10:19:22.440]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.440]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.440]                       ...future.globals.maxSize)) {
[10:19:22.440]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.440]                       on.exit(options(oopts), add = TRUE)
[10:19:22.440]                     }
[10:19:22.440]                     {
[10:19:22.440]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.440]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.440]                         USE.NAMES = FALSE)
[10:19:22.440]                       do.call(mapply, args = args)
[10:19:22.440]                     }
[10:19:22.440]                   }
[10:19:22.440]                 }, immediateCondition = function(cond) {
[10:19:22.440]                   save_rds <- function (object, pathname, ...) 
[10:19:22.440]                   {
[10:19:22.440]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.440]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.440]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.440]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.440]                         fi_tmp[["mtime"]])
[10:19:22.440]                     }
[10:19:22.440]                     tryCatch({
[10:19:22.440]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.440]                     }, error = function(ex) {
[10:19:22.440]                       msg <- conditionMessage(ex)
[10:19:22.440]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.440]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.440]                         fi_tmp[["mtime"]], msg)
[10:19:22.440]                       ex$message <- msg
[10:19:22.440]                       stop(ex)
[10:19:22.440]                     })
[10:19:22.440]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.440]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.440]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.440]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.440]                       fi <- file.info(pathname)
[10:19:22.440]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.440]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.440]                         fi[["size"]], fi[["mtime"]])
[10:19:22.440]                       stop(msg)
[10:19:22.440]                     }
[10:19:22.440]                     invisible(pathname)
[10:19:22.440]                   }
[10:19:22.440]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.440]                     rootPath = tempdir()) 
[10:19:22.440]                   {
[10:19:22.440]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.440]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.440]                       tmpdir = path, fileext = ".rds")
[10:19:22.440]                     save_rds(obj, file)
[10:19:22.440]                   }
[10:19:22.440]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.440]                   {
[10:19:22.440]                     inherits <- base::inherits
[10:19:22.440]                     invokeRestart <- base::invokeRestart
[10:19:22.440]                     is.null <- base::is.null
[10:19:22.440]                     muffled <- FALSE
[10:19:22.440]                     if (inherits(cond, "message")) {
[10:19:22.440]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.440]                       if (muffled) 
[10:19:22.440]                         invokeRestart("muffleMessage")
[10:19:22.440]                     }
[10:19:22.440]                     else if (inherits(cond, "warning")) {
[10:19:22.440]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.440]                       if (muffled) 
[10:19:22.440]                         invokeRestart("muffleWarning")
[10:19:22.440]                     }
[10:19:22.440]                     else if (inherits(cond, "condition")) {
[10:19:22.440]                       if (!is.null(pattern)) {
[10:19:22.440]                         computeRestarts <- base::computeRestarts
[10:19:22.440]                         grepl <- base::grepl
[10:19:22.440]                         restarts <- computeRestarts(cond)
[10:19:22.440]                         for (restart in restarts) {
[10:19:22.440]                           name <- restart$name
[10:19:22.440]                           if (is.null(name)) 
[10:19:22.440]                             next
[10:19:22.440]                           if (!grepl(pattern, name)) 
[10:19:22.440]                             next
[10:19:22.440]                           invokeRestart(restart)
[10:19:22.440]                           muffled <- TRUE
[10:19:22.440]                           break
[10:19:22.440]                         }
[10:19:22.440]                       }
[10:19:22.440]                     }
[10:19:22.440]                     invisible(muffled)
[10:19:22.440]                   }
[10:19:22.440]                   muffleCondition(cond)
[10:19:22.440]                 })
[10:19:22.440]             }))
[10:19:22.440]             future::FutureResult(value = ...future.value$value, 
[10:19:22.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.440]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.440]                     ...future.globalenv.names))
[10:19:22.440]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.440]         }, condition = base::local({
[10:19:22.440]             c <- base::c
[10:19:22.440]             inherits <- base::inherits
[10:19:22.440]             invokeRestart <- base::invokeRestart
[10:19:22.440]             length <- base::length
[10:19:22.440]             list <- base::list
[10:19:22.440]             seq.int <- base::seq.int
[10:19:22.440]             signalCondition <- base::signalCondition
[10:19:22.440]             sys.calls <- base::sys.calls
[10:19:22.440]             `[[` <- base::`[[`
[10:19:22.440]             `+` <- base::`+`
[10:19:22.440]             `<<-` <- base::`<<-`
[10:19:22.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.440]                   3L)]
[10:19:22.440]             }
[10:19:22.440]             function(cond) {
[10:19:22.440]                 is_error <- inherits(cond, "error")
[10:19:22.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.440]                   NULL)
[10:19:22.440]                 if (is_error) {
[10:19:22.440]                   sessionInformation <- function() {
[10:19:22.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.440]                       search = base::search(), system = base::Sys.info())
[10:19:22.440]                   }
[10:19:22.440]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.440]                     cond$call), session = sessionInformation(), 
[10:19:22.440]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.440]                   signalCondition(cond)
[10:19:22.440]                 }
[10:19:22.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.440]                 "immediateCondition"))) {
[10:19:22.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.440]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.440]                   if (TRUE && !signal) {
[10:19:22.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.440]                     {
[10:19:22.440]                       inherits <- base::inherits
[10:19:22.440]                       invokeRestart <- base::invokeRestart
[10:19:22.440]                       is.null <- base::is.null
[10:19:22.440]                       muffled <- FALSE
[10:19:22.440]                       if (inherits(cond, "message")) {
[10:19:22.440]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.440]                         if (muffled) 
[10:19:22.440]                           invokeRestart("muffleMessage")
[10:19:22.440]                       }
[10:19:22.440]                       else if (inherits(cond, "warning")) {
[10:19:22.440]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.440]                         if (muffled) 
[10:19:22.440]                           invokeRestart("muffleWarning")
[10:19:22.440]                       }
[10:19:22.440]                       else if (inherits(cond, "condition")) {
[10:19:22.440]                         if (!is.null(pattern)) {
[10:19:22.440]                           computeRestarts <- base::computeRestarts
[10:19:22.440]                           grepl <- base::grepl
[10:19:22.440]                           restarts <- computeRestarts(cond)
[10:19:22.440]                           for (restart in restarts) {
[10:19:22.440]                             name <- restart$name
[10:19:22.440]                             if (is.null(name)) 
[10:19:22.440]                               next
[10:19:22.440]                             if (!grepl(pattern, name)) 
[10:19:22.440]                               next
[10:19:22.440]                             invokeRestart(restart)
[10:19:22.440]                             muffled <- TRUE
[10:19:22.440]                             break
[10:19:22.440]                           }
[10:19:22.440]                         }
[10:19:22.440]                       }
[10:19:22.440]                       invisible(muffled)
[10:19:22.440]                     }
[10:19:22.440]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.440]                   }
[10:19:22.440]                 }
[10:19:22.440]                 else {
[10:19:22.440]                   if (TRUE) {
[10:19:22.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.440]                     {
[10:19:22.440]                       inherits <- base::inherits
[10:19:22.440]                       invokeRestart <- base::invokeRestart
[10:19:22.440]                       is.null <- base::is.null
[10:19:22.440]                       muffled <- FALSE
[10:19:22.440]                       if (inherits(cond, "message")) {
[10:19:22.440]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.440]                         if (muffled) 
[10:19:22.440]                           invokeRestart("muffleMessage")
[10:19:22.440]                       }
[10:19:22.440]                       else if (inherits(cond, "warning")) {
[10:19:22.440]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.440]                         if (muffled) 
[10:19:22.440]                           invokeRestart("muffleWarning")
[10:19:22.440]                       }
[10:19:22.440]                       else if (inherits(cond, "condition")) {
[10:19:22.440]                         if (!is.null(pattern)) {
[10:19:22.440]                           computeRestarts <- base::computeRestarts
[10:19:22.440]                           grepl <- base::grepl
[10:19:22.440]                           restarts <- computeRestarts(cond)
[10:19:22.440]                           for (restart in restarts) {
[10:19:22.440]                             name <- restart$name
[10:19:22.440]                             if (is.null(name)) 
[10:19:22.440]                               next
[10:19:22.440]                             if (!grepl(pattern, name)) 
[10:19:22.440]                               next
[10:19:22.440]                             invokeRestart(restart)
[10:19:22.440]                             muffled <- TRUE
[10:19:22.440]                             break
[10:19:22.440]                           }
[10:19:22.440]                         }
[10:19:22.440]                       }
[10:19:22.440]                       invisible(muffled)
[10:19:22.440]                     }
[10:19:22.440]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.440]                   }
[10:19:22.440]                 }
[10:19:22.440]             }
[10:19:22.440]         }))
[10:19:22.440]     }, error = function(ex) {
[10:19:22.440]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.440]                 ...future.rng), started = ...future.startTime, 
[10:19:22.440]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.440]             version = "1.8"), class = "FutureResult")
[10:19:22.440]     }, finally = {
[10:19:22.440]         if (!identical(...future.workdir, getwd())) 
[10:19:22.440]             setwd(...future.workdir)
[10:19:22.440]         {
[10:19:22.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.440]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.440]             }
[10:19:22.440]             base::options(...future.oldOptions)
[10:19:22.440]             if (.Platform$OS.type == "windows") {
[10:19:22.440]                 old_names <- names(...future.oldEnvVars)
[10:19:22.440]                 envs <- base::Sys.getenv()
[10:19:22.440]                 names <- names(envs)
[10:19:22.440]                 common <- intersect(names, old_names)
[10:19:22.440]                 added <- setdiff(names, old_names)
[10:19:22.440]                 removed <- setdiff(old_names, names)
[10:19:22.440]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.440]                   envs[common]]
[10:19:22.440]                 NAMES <- toupper(changed)
[10:19:22.440]                 args <- list()
[10:19:22.440]                 for (kk in seq_along(NAMES)) {
[10:19:22.440]                   name <- changed[[kk]]
[10:19:22.440]                   NAME <- NAMES[[kk]]
[10:19:22.440]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.440]                     next
[10:19:22.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.440]                 }
[10:19:22.440]                 NAMES <- toupper(added)
[10:19:22.440]                 for (kk in seq_along(NAMES)) {
[10:19:22.440]                   name <- added[[kk]]
[10:19:22.440]                   NAME <- NAMES[[kk]]
[10:19:22.440]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.440]                     next
[10:19:22.440]                   args[[name]] <- ""
[10:19:22.440]                 }
[10:19:22.440]                 NAMES <- toupper(removed)
[10:19:22.440]                 for (kk in seq_along(NAMES)) {
[10:19:22.440]                   name <- removed[[kk]]
[10:19:22.440]                   NAME <- NAMES[[kk]]
[10:19:22.440]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.440]                     next
[10:19:22.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.440]                 }
[10:19:22.440]                 if (length(args) > 0) 
[10:19:22.440]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.440]             }
[10:19:22.440]             else {
[10:19:22.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.440]             }
[10:19:22.440]             {
[10:19:22.440]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.440]                   0L) {
[10:19:22.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.440]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.440]                   base::options(opts)
[10:19:22.440]                 }
[10:19:22.440]                 {
[10:19:22.440]                   {
[10:19:22.440]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.440]                     NULL
[10:19:22.440]                   }
[10:19:22.440]                   options(future.plan = NULL)
[10:19:22.440]                   if (is.na(NA_character_)) 
[10:19:22.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.440]                     .init = FALSE)
[10:19:22.440]                 }
[10:19:22.440]             }
[10:19:22.440]         }
[10:19:22.440]     })
[10:19:22.440]     if (TRUE) {
[10:19:22.440]         base::sink(type = "output", split = FALSE)
[10:19:22.440]         if (TRUE) {
[10:19:22.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.440]         }
[10:19:22.440]         else {
[10:19:22.440]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.440]         }
[10:19:22.440]         base::close(...future.stdout)
[10:19:22.440]         ...future.stdout <- NULL
[10:19:22.440]     }
[10:19:22.440]     ...future.result$conditions <- ...future.conditions
[10:19:22.440]     ...future.result$finished <- base::Sys.time()
[10:19:22.440]     ...future.result
[10:19:22.440] }
[10:19:22.443] assign_globals() ...
[10:19:22.443] List of 5
[10:19:22.443]  $ ...future.FUN            :function (C, k)  
[10:19:22.443]  $ MoreArgs                 : list()
[10:19:22.443]  $ ...future.elements_ii    :List of 2
[10:19:22.443]   ..$ :List of 3
[10:19:22.443]   .. ..$ : chr "C"
[10:19:22.443]   .. ..$ : chr "D"
[10:19:22.443]   .. ..$ : chr "E"
[10:19:22.443]   ..$ :List of 3
[10:19:22.443]   .. ..$ : int 3
[10:19:22.443]   .. ..$ : int 2
[10:19:22.443]   .. ..$ : int 1
[10:19:22.443]  $ ...future.seeds_ii       : NULL
[10:19:22.443]  $ ...future.globals.maxSize: NULL
[10:19:22.443]  - attr(*, "where")=List of 5
[10:19:22.443]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.443]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.443]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.443]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.443]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.443]  - attr(*, "resolved")= logi FALSE
[10:19:22.443]  - attr(*, "total_size")= num 909
[10:19:22.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.443]  - attr(*, "already-done")= logi TRUE
[10:19:22.451] - reassign environment for ‘...future.FUN’
[10:19:22.451] - copied ‘...future.FUN’ to environment
[10:19:22.451] - copied ‘MoreArgs’ to environment
[10:19:22.451] - copied ‘...future.elements_ii’ to environment
[10:19:22.452] - copied ‘...future.seeds_ii’ to environment
[10:19:22.452] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.452] assign_globals() ... done
[10:19:22.452] requestCore(): workers = 2
[10:19:22.454] MulticoreFuture started
[10:19:22.455] - Launch lazy future ... done
[10:19:22.455] run() for ‘MulticoreFuture’ ... done
[10:19:22.455] Created future:
[10:19:22.455] plan(): Setting new future strategy stack:
[10:19:22.456] List of future strategies:
[10:19:22.456] 1. sequential:
[10:19:22.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.456]    - tweaked: FALSE
[10:19:22.456]    - call: NULL
[10:19:22.456] plan(): nbrOfWorkers() = 1
[10:19:22.464] plan(): Setting new future strategy stack:
[10:19:22.464] List of future strategies:
[10:19:22.464] 1. multicore:
[10:19:22.464]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.464]    - tweaked: FALSE
[10:19:22.464]    - call: plan(strategy)
[10:19:22.469] plan(): nbrOfWorkers() = 2
[10:19:22.455] MulticoreFuture:
[10:19:22.455] Label: ‘future_.mapply-2’
[10:19:22.455] Expression:
[10:19:22.455] {
[10:19:22.455]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.455]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.455]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.455]         on.exit(options(oopts), add = TRUE)
[10:19:22.455]     }
[10:19:22.455]     {
[10:19:22.455]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.455]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.455]         do.call(mapply, args = args)
[10:19:22.455]     }
[10:19:22.455] }
[10:19:22.455] Lazy evaluation: FALSE
[10:19:22.455] Asynchronous evaluation: TRUE
[10:19:22.455] Local evaluation: TRUE
[10:19:22.455] Environment: R_GlobalEnv
[10:19:22.455] Capture standard output: TRUE
[10:19:22.455] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.455] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.455] Packages: <none>
[10:19:22.455] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.455] Resolved: FALSE
[10:19:22.455] Value: <not collected>
[10:19:22.455] Conditions captured: <none>
[10:19:22.455] Early signaling: FALSE
[10:19:22.455] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.455] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.470] Chunk #2 of 2 ... DONE
[10:19:22.471] Launching 2 futures (chunks) ... DONE
[10:19:22.471] Resolving 2 futures (chunks) ...
[10:19:22.471] resolve() on list ...
[10:19:22.471]  recursive: 0
[10:19:22.472]  length: 2
[10:19:22.472] 
[10:19:22.472] Future #1
[10:19:22.472] result() for MulticoreFuture ...
[10:19:22.473] result() for MulticoreFuture ...
[10:19:22.474] result() for MulticoreFuture ... done
[10:19:22.474] result() for MulticoreFuture ... done
[10:19:22.474] result() for MulticoreFuture ...
[10:19:22.474] result() for MulticoreFuture ... done
[10:19:22.475] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:22.475] - nx: 2
[10:19:22.475] - relay: TRUE
[10:19:22.475] - stdout: TRUE
[10:19:22.476] - signal: TRUE
[10:19:22.476] - resignal: FALSE
[10:19:22.476] - force: TRUE
[10:19:22.476] - relayed: [n=2] FALSE, FALSE
[10:19:22.477] - queued futures: [n=2] FALSE, FALSE
[10:19:22.477]  - until=1
[10:19:22.477]  - relaying element #1
[10:19:22.477] result() for MulticoreFuture ...
[10:19:22.477] result() for MulticoreFuture ... done
[10:19:22.478] result() for MulticoreFuture ...
[10:19:22.478] result() for MulticoreFuture ... done
[10:19:22.478] result() for MulticoreFuture ...
[10:19:22.478] result() for MulticoreFuture ... done
[10:19:22.479] result() for MulticoreFuture ...
[10:19:22.479] result() for MulticoreFuture ... done
[10:19:22.479] - relayed: [n=2] TRUE, FALSE
[10:19:22.479] - queued futures: [n=2] TRUE, FALSE
[10:19:22.479] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:22.480]  length: 1 (resolved future 1)
[10:19:22.480] Future #2
[10:19:22.480] result() for MulticoreFuture ...
[10:19:22.481] result() for MulticoreFuture ...
[10:19:22.481] result() for MulticoreFuture ... done
[10:19:22.482] result() for MulticoreFuture ... done
[10:19:22.482] result() for MulticoreFuture ...
[10:19:22.482] result() for MulticoreFuture ... done
[10:19:22.482] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:22.482] - nx: 2
[10:19:22.483] - relay: TRUE
[10:19:22.483] - stdout: TRUE
[10:19:22.483] - signal: TRUE
[10:19:22.483] - resignal: FALSE
[10:19:22.483] - force: TRUE
[10:19:22.483] - relayed: [n=2] TRUE, FALSE
[10:19:22.483] - queued futures: [n=2] TRUE, FALSE
[10:19:22.483]  - until=2
[10:19:22.483]  - relaying element #2
[10:19:22.484] result() for MulticoreFuture ...
[10:19:22.484] result() for MulticoreFuture ... done
[10:19:22.484] result() for MulticoreFuture ...
[10:19:22.484] result() for MulticoreFuture ... done
[10:19:22.484] result() for MulticoreFuture ...
[10:19:22.484] result() for MulticoreFuture ... done
[10:19:22.484] result() for MulticoreFuture ...
[10:19:22.484] result() for MulticoreFuture ... done
[10:19:22.484] - relayed: [n=2] TRUE, TRUE
[10:19:22.485] - queued futures: [n=2] TRUE, TRUE
[10:19:22.485] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:22.485]  length: 0 (resolved future 2)
[10:19:22.485] Relaying remaining futures
[10:19:22.485] signalConditionsASAP(NULL, pos=0) ...
[10:19:22.485] - nx: 2
[10:19:22.485] - relay: TRUE
[10:19:22.485] - stdout: TRUE
[10:19:22.485] - signal: TRUE
[10:19:22.485] - resignal: FALSE
[10:19:22.485] - force: TRUE
[10:19:22.486] - relayed: [n=2] TRUE, TRUE
[10:19:22.486] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:22.486] - relayed: [n=2] TRUE, TRUE
[10:19:22.486] - queued futures: [n=2] TRUE, TRUE
[10:19:22.486] signalConditionsASAP(NULL, pos=0) ... done
[10:19:22.486] resolve() on list ... DONE
[10:19:22.486] result() for MulticoreFuture ...
[10:19:22.486] result() for MulticoreFuture ... done
[10:19:22.486] result() for MulticoreFuture ...
[10:19:22.487] result() for MulticoreFuture ... done
[10:19:22.487] result() for MulticoreFuture ...
[10:19:22.487] result() for MulticoreFuture ... done
[10:19:22.487] result() for MulticoreFuture ...
[10:19:22.487] result() for MulticoreFuture ... done
[10:19:22.487]  - Number of value chunks collected: 2
[10:19:22.487] Resolving 2 futures (chunks) ... DONE
[10:19:22.487] Reducing values from 2 chunks ...
[10:19:22.487]  - Number of values collected after concatenation: 5
[10:19:22.487]  - Number of values expected: 5
[10:19:22.488] Reducing values from 2 chunks ... DONE
[10:19:22.488] future_mapply() ... DONE
[10:19:22.488] future_mapply() ...
[10:19:22.490] Number of chunks: 2
[10:19:22.490] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:19:22.490] getGlobalsAndPackagesXApply() ...
[10:19:22.490]  - future.globals: TRUE
[10:19:22.491] getGlobalsAndPackages() ...
[10:19:22.491] Searching for globals...
[10:19:22.492] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:22.492] Searching for globals ... DONE
[10:19:22.492] Resolving globals: FALSE
[10:19:22.493] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:22.493] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:22.493] - globals: [1] ‘FUN’
[10:19:22.493] 
[10:19:22.494] getGlobalsAndPackages() ... DONE
[10:19:22.494]  - globals found/used: [n=1] ‘FUN’
[10:19:22.494]  - needed namespaces: [n=0] 
[10:19:22.494] Finding globals ... DONE
[10:19:22.494] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:22.494] List of 2
[10:19:22.494]  $ ...future.FUN:function (C, k)  
[10:19:22.494]  $ MoreArgs     : NULL
[10:19:22.494]  - attr(*, "where")=List of 2
[10:19:22.494]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:22.494]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:22.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.494]  - attr(*, "resolved")= logi FALSE
[10:19:22.494]  - attr(*, "total_size")= num NA
[10:19:22.497] Packages to be attached in all futures: [n=0] 
[10:19:22.497] getGlobalsAndPackagesXApply() ... DONE
[10:19:22.497] Number of futures (= number of chunks): 2
[10:19:22.497] Launching 2 futures (chunks) ...
[10:19:22.500] Chunk #1 of 2 ...
[10:19:22.500]  - Finding globals in '...' for chunk #1 ...
[10:19:22.500] getGlobalsAndPackages() ...
[10:19:22.500] Searching for globals...
[10:19:22.500] 
[10:19:22.501] Searching for globals ... DONE
[10:19:22.501] - globals: [0] <none>
[10:19:22.501] getGlobalsAndPackages() ... DONE
[10:19:22.501]    + additional globals found: [n=0] 
[10:19:22.501]    + additional namespaces needed: [n=0] 
[10:19:22.501]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:22.501]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.501]  - seeds: <none>
[10:19:22.501]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.501] getGlobalsAndPackages() ...
[10:19:22.502] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.502] Resolving globals: FALSE
[10:19:22.502] The total size of the 5 globals is 876 bytes (876 bytes)
[10:19:22.503] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:22.503] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.503] 
[10:19:22.503] getGlobalsAndPackages() ... DONE
[10:19:22.503] run() for ‘Future’ ...
[10:19:22.503] - state: ‘created’
[10:19:22.504] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.505] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.506]   - Field: ‘label’
[10:19:22.506]   - Field: ‘local’
[10:19:22.506]   - Field: ‘owner’
[10:19:22.506]   - Field: ‘envir’
[10:19:22.506]   - Field: ‘workers’
[10:19:22.506]   - Field: ‘packages’
[10:19:22.506]   - Field: ‘gc’
[10:19:22.506]   - Field: ‘job’
[10:19:22.506]   - Field: ‘conditions’
[10:19:22.507]   - Field: ‘expr’
[10:19:22.507]   - Field: ‘uuid’
[10:19:22.507]   - Field: ‘seed’
[10:19:22.507]   - Field: ‘version’
[10:19:22.507]   - Field: ‘result’
[10:19:22.507]   - Field: ‘asynchronous’
[10:19:22.507]   - Field: ‘calls’
[10:19:22.507]   - Field: ‘globals’
[10:19:22.507]   - Field: ‘stdout’
[10:19:22.507]   - Field: ‘earlySignal’
[10:19:22.507]   - Field: ‘lazy’
[10:19:22.508]   - Field: ‘state’
[10:19:22.508] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.508] - Launch lazy future ...
[10:19:22.508] Packages needed by the future expression (n = 0): <none>
[10:19:22.508] Packages needed by future strategies (n = 0): <none>
[10:19:22.509] {
[10:19:22.509]     {
[10:19:22.509]         {
[10:19:22.509]             ...future.startTime <- base::Sys.time()
[10:19:22.509]             {
[10:19:22.509]                 {
[10:19:22.509]                   {
[10:19:22.509]                     {
[10:19:22.509]                       base::local({
[10:19:22.509]                         has_future <- base::requireNamespace("future", 
[10:19:22.509]                           quietly = TRUE)
[10:19:22.509]                         if (has_future) {
[10:19:22.509]                           ns <- base::getNamespace("future")
[10:19:22.509]                           version <- ns[[".package"]][["version"]]
[10:19:22.509]                           if (is.null(version)) 
[10:19:22.509]                             version <- utils::packageVersion("future")
[10:19:22.509]                         }
[10:19:22.509]                         else {
[10:19:22.509]                           version <- NULL
[10:19:22.509]                         }
[10:19:22.509]                         if (!has_future || version < "1.8.0") {
[10:19:22.509]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.509]                             "", base::R.version$version.string), 
[10:19:22.509]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.509]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.509]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.509]                               "release", "version")], collapse = " "), 
[10:19:22.509]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.509]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.509]                             info)
[10:19:22.509]                           info <- base::paste(info, collapse = "; ")
[10:19:22.509]                           if (!has_future) {
[10:19:22.509]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.509]                               info)
[10:19:22.509]                           }
[10:19:22.509]                           else {
[10:19:22.509]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.509]                               info, version)
[10:19:22.509]                           }
[10:19:22.509]                           base::stop(msg)
[10:19:22.509]                         }
[10:19:22.509]                       })
[10:19:22.509]                     }
[10:19:22.509]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.509]                     base::options(mc.cores = 1L)
[10:19:22.509]                   }
[10:19:22.509]                   ...future.strategy.old <- future::plan("list")
[10:19:22.509]                   options(future.plan = NULL)
[10:19:22.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.509]                 }
[10:19:22.509]                 ...future.workdir <- getwd()
[10:19:22.509]             }
[10:19:22.509]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.509]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.509]         }
[10:19:22.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.509]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.509]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.509]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.509]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.509]             base::names(...future.oldOptions))
[10:19:22.509]     }
[10:19:22.509]     if (FALSE) {
[10:19:22.509]     }
[10:19:22.509]     else {
[10:19:22.509]         if (TRUE) {
[10:19:22.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.509]                 open = "w")
[10:19:22.509]         }
[10:19:22.509]         else {
[10:19:22.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.509]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.509]         }
[10:19:22.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.509]             base::sink(type = "output", split = FALSE)
[10:19:22.509]             base::close(...future.stdout)
[10:19:22.509]         }, add = TRUE)
[10:19:22.509]     }
[10:19:22.509]     ...future.frame <- base::sys.nframe()
[10:19:22.509]     ...future.conditions <- base::list()
[10:19:22.509]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.509]     if (FALSE) {
[10:19:22.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.509]     }
[10:19:22.509]     ...future.result <- base::tryCatch({
[10:19:22.509]         base::withCallingHandlers({
[10:19:22.509]             ...future.value <- base::withVisible(base::local({
[10:19:22.509]                 withCallingHandlers({
[10:19:22.509]                   {
[10:19:22.509]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.509]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.509]                       ...future.globals.maxSize)) {
[10:19:22.509]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.509]                       on.exit(options(oopts), add = TRUE)
[10:19:22.509]                     }
[10:19:22.509]                     {
[10:19:22.509]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.509]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.509]                         USE.NAMES = FALSE)
[10:19:22.509]                       do.call(mapply, args = args)
[10:19:22.509]                     }
[10:19:22.509]                   }
[10:19:22.509]                 }, immediateCondition = function(cond) {
[10:19:22.509]                   save_rds <- function (object, pathname, ...) 
[10:19:22.509]                   {
[10:19:22.509]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.509]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.509]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.509]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.509]                         fi_tmp[["mtime"]])
[10:19:22.509]                     }
[10:19:22.509]                     tryCatch({
[10:19:22.509]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.509]                     }, error = function(ex) {
[10:19:22.509]                       msg <- conditionMessage(ex)
[10:19:22.509]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.509]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.509]                         fi_tmp[["mtime"]], msg)
[10:19:22.509]                       ex$message <- msg
[10:19:22.509]                       stop(ex)
[10:19:22.509]                     })
[10:19:22.509]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.509]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.509]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.509]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.509]                       fi <- file.info(pathname)
[10:19:22.509]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.509]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.509]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.509]                         fi[["size"]], fi[["mtime"]])
[10:19:22.509]                       stop(msg)
[10:19:22.509]                     }
[10:19:22.509]                     invisible(pathname)
[10:19:22.509]                   }
[10:19:22.509]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.509]                     rootPath = tempdir()) 
[10:19:22.509]                   {
[10:19:22.509]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.509]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.509]                       tmpdir = path, fileext = ".rds")
[10:19:22.509]                     save_rds(obj, file)
[10:19:22.509]                   }
[10:19:22.509]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.509]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.509]                   {
[10:19:22.509]                     inherits <- base::inherits
[10:19:22.509]                     invokeRestart <- base::invokeRestart
[10:19:22.509]                     is.null <- base::is.null
[10:19:22.509]                     muffled <- FALSE
[10:19:22.509]                     if (inherits(cond, "message")) {
[10:19:22.509]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.509]                       if (muffled) 
[10:19:22.509]                         invokeRestart("muffleMessage")
[10:19:22.509]                     }
[10:19:22.509]                     else if (inherits(cond, "warning")) {
[10:19:22.509]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.509]                       if (muffled) 
[10:19:22.509]                         invokeRestart("muffleWarning")
[10:19:22.509]                     }
[10:19:22.509]                     else if (inherits(cond, "condition")) {
[10:19:22.509]                       if (!is.null(pattern)) {
[10:19:22.509]                         computeRestarts <- base::computeRestarts
[10:19:22.509]                         grepl <- base::grepl
[10:19:22.509]                         restarts <- computeRestarts(cond)
[10:19:22.509]                         for (restart in restarts) {
[10:19:22.509]                           name <- restart$name
[10:19:22.509]                           if (is.null(name)) 
[10:19:22.509]                             next
[10:19:22.509]                           if (!grepl(pattern, name)) 
[10:19:22.509]                             next
[10:19:22.509]                           invokeRestart(restart)
[10:19:22.509]                           muffled <- TRUE
[10:19:22.509]                           break
[10:19:22.509]                         }
[10:19:22.509]                       }
[10:19:22.509]                     }
[10:19:22.509]                     invisible(muffled)
[10:19:22.509]                   }
[10:19:22.509]                   muffleCondition(cond)
[10:19:22.509]                 })
[10:19:22.509]             }))
[10:19:22.509]             future::FutureResult(value = ...future.value$value, 
[10:19:22.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.509]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.509]                     ...future.globalenv.names))
[10:19:22.509]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.509]         }, condition = base::local({
[10:19:22.509]             c <- base::c
[10:19:22.509]             inherits <- base::inherits
[10:19:22.509]             invokeRestart <- base::invokeRestart
[10:19:22.509]             length <- base::length
[10:19:22.509]             list <- base::list
[10:19:22.509]             seq.int <- base::seq.int
[10:19:22.509]             signalCondition <- base::signalCondition
[10:19:22.509]             sys.calls <- base::sys.calls
[10:19:22.509]             `[[` <- base::`[[`
[10:19:22.509]             `+` <- base::`+`
[10:19:22.509]             `<<-` <- base::`<<-`
[10:19:22.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.509]                   3L)]
[10:19:22.509]             }
[10:19:22.509]             function(cond) {
[10:19:22.509]                 is_error <- inherits(cond, "error")
[10:19:22.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.509]                   NULL)
[10:19:22.509]                 if (is_error) {
[10:19:22.509]                   sessionInformation <- function() {
[10:19:22.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.509]                       search = base::search(), system = base::Sys.info())
[10:19:22.509]                   }
[10:19:22.509]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.509]                     cond$call), session = sessionInformation(), 
[10:19:22.509]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.509]                   signalCondition(cond)
[10:19:22.509]                 }
[10:19:22.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.509]                 "immediateCondition"))) {
[10:19:22.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.509]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.509]                   if (TRUE && !signal) {
[10:19:22.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.509]                     {
[10:19:22.509]                       inherits <- base::inherits
[10:19:22.509]                       invokeRestart <- base::invokeRestart
[10:19:22.509]                       is.null <- base::is.null
[10:19:22.509]                       muffled <- FALSE
[10:19:22.509]                       if (inherits(cond, "message")) {
[10:19:22.509]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.509]                         if (muffled) 
[10:19:22.509]                           invokeRestart("muffleMessage")
[10:19:22.509]                       }
[10:19:22.509]                       else if (inherits(cond, "warning")) {
[10:19:22.509]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.509]                         if (muffled) 
[10:19:22.509]                           invokeRestart("muffleWarning")
[10:19:22.509]                       }
[10:19:22.509]                       else if (inherits(cond, "condition")) {
[10:19:22.509]                         if (!is.null(pattern)) {
[10:19:22.509]                           computeRestarts <- base::computeRestarts
[10:19:22.509]                           grepl <- base::grepl
[10:19:22.509]                           restarts <- computeRestarts(cond)
[10:19:22.509]                           for (restart in restarts) {
[10:19:22.509]                             name <- restart$name
[10:19:22.509]                             if (is.null(name)) 
[10:19:22.509]                               next
[10:19:22.509]                             if (!grepl(pattern, name)) 
[10:19:22.509]                               next
[10:19:22.509]                             invokeRestart(restart)
[10:19:22.509]                             muffled <- TRUE
[10:19:22.509]                             break
[10:19:22.509]                           }
[10:19:22.509]                         }
[10:19:22.509]                       }
[10:19:22.509]                       invisible(muffled)
[10:19:22.509]                     }
[10:19:22.509]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.509]                   }
[10:19:22.509]                 }
[10:19:22.509]                 else {
[10:19:22.509]                   if (TRUE) {
[10:19:22.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.509]                     {
[10:19:22.509]                       inherits <- base::inherits
[10:19:22.509]                       invokeRestart <- base::invokeRestart
[10:19:22.509]                       is.null <- base::is.null
[10:19:22.509]                       muffled <- FALSE
[10:19:22.509]                       if (inherits(cond, "message")) {
[10:19:22.509]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.509]                         if (muffled) 
[10:19:22.509]                           invokeRestart("muffleMessage")
[10:19:22.509]                       }
[10:19:22.509]                       else if (inherits(cond, "warning")) {
[10:19:22.509]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.509]                         if (muffled) 
[10:19:22.509]                           invokeRestart("muffleWarning")
[10:19:22.509]                       }
[10:19:22.509]                       else if (inherits(cond, "condition")) {
[10:19:22.509]                         if (!is.null(pattern)) {
[10:19:22.509]                           computeRestarts <- base::computeRestarts
[10:19:22.509]                           grepl <- base::grepl
[10:19:22.509]                           restarts <- computeRestarts(cond)
[10:19:22.509]                           for (restart in restarts) {
[10:19:22.509]                             name <- restart$name
[10:19:22.509]                             if (is.null(name)) 
[10:19:22.509]                               next
[10:19:22.509]                             if (!grepl(pattern, name)) 
[10:19:22.509]                               next
[10:19:22.509]                             invokeRestart(restart)
[10:19:22.509]                             muffled <- TRUE
[10:19:22.509]                             break
[10:19:22.509]                           }
[10:19:22.509]                         }
[10:19:22.509]                       }
[10:19:22.509]                       invisible(muffled)
[10:19:22.509]                     }
[10:19:22.509]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.509]                   }
[10:19:22.509]                 }
[10:19:22.509]             }
[10:19:22.509]         }))
[10:19:22.509]     }, error = function(ex) {
[10:19:22.509]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.509]                 ...future.rng), started = ...future.startTime, 
[10:19:22.509]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.509]             version = "1.8"), class = "FutureResult")
[10:19:22.509]     }, finally = {
[10:19:22.509]         if (!identical(...future.workdir, getwd())) 
[10:19:22.509]             setwd(...future.workdir)
[10:19:22.509]         {
[10:19:22.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.509]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.509]             }
[10:19:22.509]             base::options(...future.oldOptions)
[10:19:22.509]             if (.Platform$OS.type == "windows") {
[10:19:22.509]                 old_names <- names(...future.oldEnvVars)
[10:19:22.509]                 envs <- base::Sys.getenv()
[10:19:22.509]                 names <- names(envs)
[10:19:22.509]                 common <- intersect(names, old_names)
[10:19:22.509]                 added <- setdiff(names, old_names)
[10:19:22.509]                 removed <- setdiff(old_names, names)
[10:19:22.509]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.509]                   envs[common]]
[10:19:22.509]                 NAMES <- toupper(changed)
[10:19:22.509]                 args <- list()
[10:19:22.509]                 for (kk in seq_along(NAMES)) {
[10:19:22.509]                   name <- changed[[kk]]
[10:19:22.509]                   NAME <- NAMES[[kk]]
[10:19:22.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.509]                     next
[10:19:22.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.509]                 }
[10:19:22.509]                 NAMES <- toupper(added)
[10:19:22.509]                 for (kk in seq_along(NAMES)) {
[10:19:22.509]                   name <- added[[kk]]
[10:19:22.509]                   NAME <- NAMES[[kk]]
[10:19:22.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.509]                     next
[10:19:22.509]                   args[[name]] <- ""
[10:19:22.509]                 }
[10:19:22.509]                 NAMES <- toupper(removed)
[10:19:22.509]                 for (kk in seq_along(NAMES)) {
[10:19:22.509]                   name <- removed[[kk]]
[10:19:22.509]                   NAME <- NAMES[[kk]]
[10:19:22.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.509]                     next
[10:19:22.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.509]                 }
[10:19:22.509]                 if (length(args) > 0) 
[10:19:22.509]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.509]             }
[10:19:22.509]             else {
[10:19:22.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.509]             }
[10:19:22.509]             {
[10:19:22.509]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.509]                   0L) {
[10:19:22.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.509]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.509]                   base::options(opts)
[10:19:22.509]                 }
[10:19:22.509]                 {
[10:19:22.509]                   {
[10:19:22.509]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.509]                     NULL
[10:19:22.509]                   }
[10:19:22.509]                   options(future.plan = NULL)
[10:19:22.509]                   if (is.na(NA_character_)) 
[10:19:22.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.509]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.509]                     .init = FALSE)
[10:19:22.509]                 }
[10:19:22.509]             }
[10:19:22.509]         }
[10:19:22.509]     })
[10:19:22.509]     if (TRUE) {
[10:19:22.509]         base::sink(type = "output", split = FALSE)
[10:19:22.509]         if (TRUE) {
[10:19:22.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.509]         }
[10:19:22.509]         else {
[10:19:22.509]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.509]         }
[10:19:22.509]         base::close(...future.stdout)
[10:19:22.509]         ...future.stdout <- NULL
[10:19:22.509]     }
[10:19:22.509]     ...future.result$conditions <- ...future.conditions
[10:19:22.509]     ...future.result$finished <- base::Sys.time()
[10:19:22.509]     ...future.result
[10:19:22.509] }
[10:19:22.511] assign_globals() ...
[10:19:22.511] List of 5
[10:19:22.511]  $ ...future.FUN            :function (C, k)  
[10:19:22.511]  $ MoreArgs                 : NULL
[10:19:22.511]  $ ...future.elements_ii    :List of 2
[10:19:22.511]   ..$ :List of 2
[10:19:22.511]   .. ..$ : chr "E"
[10:19:22.511]   .. ..$ : chr "D"
[10:19:22.511]   ..$ :List of 2
[10:19:22.511]   .. ..$ : int 1
[10:19:22.511]   .. ..$ : int 2
[10:19:22.511]  $ ...future.seeds_ii       : NULL
[10:19:22.511]  $ ...future.globals.maxSize: NULL
[10:19:22.511]  - attr(*, "where")=List of 5
[10:19:22.511]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.511]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.511]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.511]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.511]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.511]  - attr(*, "resolved")= logi FALSE
[10:19:22.511]  - attr(*, "total_size")= num 876
[10:19:22.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.511]  - attr(*, "already-done")= logi TRUE
[10:19:22.516] - reassign environment for ‘...future.FUN’
[10:19:22.517] - copied ‘...future.FUN’ to environment
[10:19:22.517] - copied ‘MoreArgs’ to environment
[10:19:22.517] - copied ‘...future.elements_ii’ to environment
[10:19:22.517] - copied ‘...future.seeds_ii’ to environment
[10:19:22.517] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.517] assign_globals() ... done
[10:19:22.517] requestCore(): workers = 2
[10:19:22.519] MulticoreFuture started
[10:19:22.520] - Launch lazy future ... done
[10:19:22.520] run() for ‘MulticoreFuture’ ... done
[10:19:22.520] Created future:
[10:19:22.520] plan(): Setting new future strategy stack:
[10:19:22.521] List of future strategies:
[10:19:22.521] 1. sequential:
[10:19:22.521]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.521]    - tweaked: FALSE
[10:19:22.521]    - call: NULL
[10:19:22.522] plan(): nbrOfWorkers() = 1
[10:19:22.524] plan(): Setting new future strategy stack:
[10:19:22.524] List of future strategies:
[10:19:22.524] 1. multicore:
[10:19:22.524]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.524]    - tweaked: FALSE
[10:19:22.524]    - call: plan(strategy)
[10:19:22.527] plan(): nbrOfWorkers() = 2
[10:19:22.520] MulticoreFuture:
[10:19:22.520] Label: ‘future_mapply-1’
[10:19:22.520] Expression:
[10:19:22.520] {
[10:19:22.520]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.520]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.520]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.520]         on.exit(options(oopts), add = TRUE)
[10:19:22.520]     }
[10:19:22.520]     {
[10:19:22.520]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.520]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.520]         do.call(mapply, args = args)
[10:19:22.520]     }
[10:19:22.520] }
[10:19:22.520] Lazy evaluation: FALSE
[10:19:22.520] Asynchronous evaluation: TRUE
[10:19:22.520] Local evaluation: TRUE
[10:19:22.520] Environment: R_GlobalEnv
[10:19:22.520] Capture standard output: TRUE
[10:19:22.520] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.520] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.520] Packages: <none>
[10:19:22.520] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.520] Resolved: TRUE
[10:19:22.520] Value: <not collected>
[10:19:22.520] Conditions captured: <none>
[10:19:22.520] Early signaling: FALSE
[10:19:22.520] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.520] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.528] Chunk #1 of 2 ... DONE
[10:19:22.528] Chunk #2 of 2 ...
[10:19:22.529]  - Finding globals in '...' for chunk #2 ...
[10:19:22.529] getGlobalsAndPackages() ...
[10:19:22.529] Searching for globals...
[10:19:22.529] 
[10:19:22.530] Searching for globals ... DONE
[10:19:22.530] - globals: [0] <none>
[10:19:22.530] getGlobalsAndPackages() ... DONE
[10:19:22.530]    + additional globals found: [n=0] 
[10:19:22.530]    + additional namespaces needed: [n=0] 
[10:19:22.530]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:22.530]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.530]  - seeds: <none>
[10:19:22.534]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.534] getGlobalsAndPackages() ...
[10:19:22.535] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.536] Resolving globals: FALSE
[10:19:22.537] The total size of the 5 globals is 905 bytes (905 bytes)
[10:19:22.538] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 905 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:22.538] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.539] 
[10:19:22.539] getGlobalsAndPackages() ... DONE
[10:19:22.540] run() for ‘Future’ ...
[10:19:22.540] - state: ‘created’
[10:19:22.540] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.544] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.544] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.544]   - Field: ‘label’
[10:19:22.544]   - Field: ‘local’
[10:19:22.544]   - Field: ‘owner’
[10:19:22.545]   - Field: ‘envir’
[10:19:22.545]   - Field: ‘workers’
[10:19:22.545]   - Field: ‘packages’
[10:19:22.545]   - Field: ‘gc’
[10:19:22.545]   - Field: ‘job’
[10:19:22.546]   - Field: ‘conditions’
[10:19:22.546]   - Field: ‘expr’
[10:19:22.546]   - Field: ‘uuid’
[10:19:22.546]   - Field: ‘seed’
[10:19:22.547]   - Field: ‘version’
[10:19:22.547]   - Field: ‘result’
[10:19:22.547]   - Field: ‘asynchronous’
[10:19:22.547]   - Field: ‘calls’
[10:19:22.547]   - Field: ‘globals’
[10:19:22.547]   - Field: ‘stdout’
[10:19:22.548]   - Field: ‘earlySignal’
[10:19:22.548]   - Field: ‘lazy’
[10:19:22.548]   - Field: ‘state’
[10:19:22.548] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.548] - Launch lazy future ...
[10:19:22.549] Packages needed by the future expression (n = 0): <none>
[10:19:22.549] Packages needed by future strategies (n = 0): <none>
[10:19:22.549] {
[10:19:22.549]     {
[10:19:22.549]         {
[10:19:22.549]             ...future.startTime <- base::Sys.time()
[10:19:22.549]             {
[10:19:22.549]                 {
[10:19:22.549]                   {
[10:19:22.549]                     {
[10:19:22.549]                       base::local({
[10:19:22.549]                         has_future <- base::requireNamespace("future", 
[10:19:22.549]                           quietly = TRUE)
[10:19:22.549]                         if (has_future) {
[10:19:22.549]                           ns <- base::getNamespace("future")
[10:19:22.549]                           version <- ns[[".package"]][["version"]]
[10:19:22.549]                           if (is.null(version)) 
[10:19:22.549]                             version <- utils::packageVersion("future")
[10:19:22.549]                         }
[10:19:22.549]                         else {
[10:19:22.549]                           version <- NULL
[10:19:22.549]                         }
[10:19:22.549]                         if (!has_future || version < "1.8.0") {
[10:19:22.549]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.549]                             "", base::R.version$version.string), 
[10:19:22.549]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.549]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.549]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.549]                               "release", "version")], collapse = " "), 
[10:19:22.549]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.549]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.549]                             info)
[10:19:22.549]                           info <- base::paste(info, collapse = "; ")
[10:19:22.549]                           if (!has_future) {
[10:19:22.549]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.549]                               info)
[10:19:22.549]                           }
[10:19:22.549]                           else {
[10:19:22.549]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.549]                               info, version)
[10:19:22.549]                           }
[10:19:22.549]                           base::stop(msg)
[10:19:22.549]                         }
[10:19:22.549]                       })
[10:19:22.549]                     }
[10:19:22.549]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.549]                     base::options(mc.cores = 1L)
[10:19:22.549]                   }
[10:19:22.549]                   ...future.strategy.old <- future::plan("list")
[10:19:22.549]                   options(future.plan = NULL)
[10:19:22.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.549]                 }
[10:19:22.549]                 ...future.workdir <- getwd()
[10:19:22.549]             }
[10:19:22.549]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.549]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.549]         }
[10:19:22.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.549]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.549]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.549]             base::names(...future.oldOptions))
[10:19:22.549]     }
[10:19:22.549]     if (FALSE) {
[10:19:22.549]     }
[10:19:22.549]     else {
[10:19:22.549]         if (TRUE) {
[10:19:22.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.549]                 open = "w")
[10:19:22.549]         }
[10:19:22.549]         else {
[10:19:22.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.549]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.549]         }
[10:19:22.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.549]             base::sink(type = "output", split = FALSE)
[10:19:22.549]             base::close(...future.stdout)
[10:19:22.549]         }, add = TRUE)
[10:19:22.549]     }
[10:19:22.549]     ...future.frame <- base::sys.nframe()
[10:19:22.549]     ...future.conditions <- base::list()
[10:19:22.549]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.549]     if (FALSE) {
[10:19:22.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.549]     }
[10:19:22.549]     ...future.result <- base::tryCatch({
[10:19:22.549]         base::withCallingHandlers({
[10:19:22.549]             ...future.value <- base::withVisible(base::local({
[10:19:22.549]                 withCallingHandlers({
[10:19:22.549]                   {
[10:19:22.549]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.549]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.549]                       ...future.globals.maxSize)) {
[10:19:22.549]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.549]                       on.exit(options(oopts), add = TRUE)
[10:19:22.549]                     }
[10:19:22.549]                     {
[10:19:22.549]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.549]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.549]                         USE.NAMES = FALSE)
[10:19:22.549]                       do.call(mapply, args = args)
[10:19:22.549]                     }
[10:19:22.549]                   }
[10:19:22.549]                 }, immediateCondition = function(cond) {
[10:19:22.549]                   save_rds <- function (object, pathname, ...) 
[10:19:22.549]                   {
[10:19:22.549]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.549]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.549]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.549]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.549]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.549]                         fi_tmp[["mtime"]])
[10:19:22.549]                     }
[10:19:22.549]                     tryCatch({
[10:19:22.549]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.549]                     }, error = function(ex) {
[10:19:22.549]                       msg <- conditionMessage(ex)
[10:19:22.549]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.549]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.549]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.549]                         fi_tmp[["mtime"]], msg)
[10:19:22.549]                       ex$message <- msg
[10:19:22.549]                       stop(ex)
[10:19:22.549]                     })
[10:19:22.549]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.549]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.549]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.549]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.549]                       fi <- file.info(pathname)
[10:19:22.549]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.549]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.549]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.549]                         fi[["size"]], fi[["mtime"]])
[10:19:22.549]                       stop(msg)
[10:19:22.549]                     }
[10:19:22.549]                     invisible(pathname)
[10:19:22.549]                   }
[10:19:22.549]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.549]                     rootPath = tempdir()) 
[10:19:22.549]                   {
[10:19:22.549]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.549]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.549]                       tmpdir = path, fileext = ".rds")
[10:19:22.549]                     save_rds(obj, file)
[10:19:22.549]                   }
[10:19:22.549]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.549]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.549]                   {
[10:19:22.549]                     inherits <- base::inherits
[10:19:22.549]                     invokeRestart <- base::invokeRestart
[10:19:22.549]                     is.null <- base::is.null
[10:19:22.549]                     muffled <- FALSE
[10:19:22.549]                     if (inherits(cond, "message")) {
[10:19:22.549]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.549]                       if (muffled) 
[10:19:22.549]                         invokeRestart("muffleMessage")
[10:19:22.549]                     }
[10:19:22.549]                     else if (inherits(cond, "warning")) {
[10:19:22.549]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.549]                       if (muffled) 
[10:19:22.549]                         invokeRestart("muffleWarning")
[10:19:22.549]                     }
[10:19:22.549]                     else if (inherits(cond, "condition")) {
[10:19:22.549]                       if (!is.null(pattern)) {
[10:19:22.549]                         computeRestarts <- base::computeRestarts
[10:19:22.549]                         grepl <- base::grepl
[10:19:22.549]                         restarts <- computeRestarts(cond)
[10:19:22.549]                         for (restart in restarts) {
[10:19:22.549]                           name <- restart$name
[10:19:22.549]                           if (is.null(name)) 
[10:19:22.549]                             next
[10:19:22.549]                           if (!grepl(pattern, name)) 
[10:19:22.549]                             next
[10:19:22.549]                           invokeRestart(restart)
[10:19:22.549]                           muffled <- TRUE
[10:19:22.549]                           break
[10:19:22.549]                         }
[10:19:22.549]                       }
[10:19:22.549]                     }
[10:19:22.549]                     invisible(muffled)
[10:19:22.549]                   }
[10:19:22.549]                   muffleCondition(cond)
[10:19:22.549]                 })
[10:19:22.549]             }))
[10:19:22.549]             future::FutureResult(value = ...future.value$value, 
[10:19:22.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.549]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.549]                     ...future.globalenv.names))
[10:19:22.549]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.549]         }, condition = base::local({
[10:19:22.549]             c <- base::c
[10:19:22.549]             inherits <- base::inherits
[10:19:22.549]             invokeRestart <- base::invokeRestart
[10:19:22.549]             length <- base::length
[10:19:22.549]             list <- base::list
[10:19:22.549]             seq.int <- base::seq.int
[10:19:22.549]             signalCondition <- base::signalCondition
[10:19:22.549]             sys.calls <- base::sys.calls
[10:19:22.549]             `[[` <- base::`[[`
[10:19:22.549]             `+` <- base::`+`
[10:19:22.549]             `<<-` <- base::`<<-`
[10:19:22.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.549]                   3L)]
[10:19:22.549]             }
[10:19:22.549]             function(cond) {
[10:19:22.549]                 is_error <- inherits(cond, "error")
[10:19:22.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.549]                   NULL)
[10:19:22.549]                 if (is_error) {
[10:19:22.549]                   sessionInformation <- function() {
[10:19:22.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.549]                       search = base::search(), system = base::Sys.info())
[10:19:22.549]                   }
[10:19:22.549]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.549]                     cond$call), session = sessionInformation(), 
[10:19:22.549]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.549]                   signalCondition(cond)
[10:19:22.549]                 }
[10:19:22.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.549]                 "immediateCondition"))) {
[10:19:22.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.549]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.549]                   if (TRUE && !signal) {
[10:19:22.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.549]                     {
[10:19:22.549]                       inherits <- base::inherits
[10:19:22.549]                       invokeRestart <- base::invokeRestart
[10:19:22.549]                       is.null <- base::is.null
[10:19:22.549]                       muffled <- FALSE
[10:19:22.549]                       if (inherits(cond, "message")) {
[10:19:22.549]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.549]                         if (muffled) 
[10:19:22.549]                           invokeRestart("muffleMessage")
[10:19:22.549]                       }
[10:19:22.549]                       else if (inherits(cond, "warning")) {
[10:19:22.549]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.549]                         if (muffled) 
[10:19:22.549]                           invokeRestart("muffleWarning")
[10:19:22.549]                       }
[10:19:22.549]                       else if (inherits(cond, "condition")) {
[10:19:22.549]                         if (!is.null(pattern)) {
[10:19:22.549]                           computeRestarts <- base::computeRestarts
[10:19:22.549]                           grepl <- base::grepl
[10:19:22.549]                           restarts <- computeRestarts(cond)
[10:19:22.549]                           for (restart in restarts) {
[10:19:22.549]                             name <- restart$name
[10:19:22.549]                             if (is.null(name)) 
[10:19:22.549]                               next
[10:19:22.549]                             if (!grepl(pattern, name)) 
[10:19:22.549]                               next
[10:19:22.549]                             invokeRestart(restart)
[10:19:22.549]                             muffled <- TRUE
[10:19:22.549]                             break
[10:19:22.549]                           }
[10:19:22.549]                         }
[10:19:22.549]                       }
[10:19:22.549]                       invisible(muffled)
[10:19:22.549]                     }
[10:19:22.549]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.549]                   }
[10:19:22.549]                 }
[10:19:22.549]                 else {
[10:19:22.549]                   if (TRUE) {
[10:19:22.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.549]                     {
[10:19:22.549]                       inherits <- base::inherits
[10:19:22.549]                       invokeRestart <- base::invokeRestart
[10:19:22.549]                       is.null <- base::is.null
[10:19:22.549]                       muffled <- FALSE
[10:19:22.549]                       if (inherits(cond, "message")) {
[10:19:22.549]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.549]                         if (muffled) 
[10:19:22.549]                           invokeRestart("muffleMessage")
[10:19:22.549]                       }
[10:19:22.549]                       else if (inherits(cond, "warning")) {
[10:19:22.549]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.549]                         if (muffled) 
[10:19:22.549]                           invokeRestart("muffleWarning")
[10:19:22.549]                       }
[10:19:22.549]                       else if (inherits(cond, "condition")) {
[10:19:22.549]                         if (!is.null(pattern)) {
[10:19:22.549]                           computeRestarts <- base::computeRestarts
[10:19:22.549]                           grepl <- base::grepl
[10:19:22.549]                           restarts <- computeRestarts(cond)
[10:19:22.549]                           for (restart in restarts) {
[10:19:22.549]                             name <- restart$name
[10:19:22.549]                             if (is.null(name)) 
[10:19:22.549]                               next
[10:19:22.549]                             if (!grepl(pattern, name)) 
[10:19:22.549]                               next
[10:19:22.549]                             invokeRestart(restart)
[10:19:22.549]                             muffled <- TRUE
[10:19:22.549]                             break
[10:19:22.549]                           }
[10:19:22.549]                         }
[10:19:22.549]                       }
[10:19:22.549]                       invisible(muffled)
[10:19:22.549]                     }
[10:19:22.549]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.549]                   }
[10:19:22.549]                 }
[10:19:22.549]             }
[10:19:22.549]         }))
[10:19:22.549]     }, error = function(ex) {
[10:19:22.549]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.549]                 ...future.rng), started = ...future.startTime, 
[10:19:22.549]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.549]             version = "1.8"), class = "FutureResult")
[10:19:22.549]     }, finally = {
[10:19:22.549]         if (!identical(...future.workdir, getwd())) 
[10:19:22.549]             setwd(...future.workdir)
[10:19:22.549]         {
[10:19:22.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.549]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.549]             }
[10:19:22.549]             base::options(...future.oldOptions)
[10:19:22.549]             if (.Platform$OS.type == "windows") {
[10:19:22.549]                 old_names <- names(...future.oldEnvVars)
[10:19:22.549]                 envs <- base::Sys.getenv()
[10:19:22.549]                 names <- names(envs)
[10:19:22.549]                 common <- intersect(names, old_names)
[10:19:22.549]                 added <- setdiff(names, old_names)
[10:19:22.549]                 removed <- setdiff(old_names, names)
[10:19:22.549]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.549]                   envs[common]]
[10:19:22.549]                 NAMES <- toupper(changed)
[10:19:22.549]                 args <- list()
[10:19:22.549]                 for (kk in seq_along(NAMES)) {
[10:19:22.549]                   name <- changed[[kk]]
[10:19:22.549]                   NAME <- NAMES[[kk]]
[10:19:22.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.549]                     next
[10:19:22.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.549]                 }
[10:19:22.549]                 NAMES <- toupper(added)
[10:19:22.549]                 for (kk in seq_along(NAMES)) {
[10:19:22.549]                   name <- added[[kk]]
[10:19:22.549]                   NAME <- NAMES[[kk]]
[10:19:22.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.549]                     next
[10:19:22.549]                   args[[name]] <- ""
[10:19:22.549]                 }
[10:19:22.549]                 NAMES <- toupper(removed)
[10:19:22.549]                 for (kk in seq_along(NAMES)) {
[10:19:22.549]                   name <- removed[[kk]]
[10:19:22.549]                   NAME <- NAMES[[kk]]
[10:19:22.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.549]                     next
[10:19:22.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.549]                 }
[10:19:22.549]                 if (length(args) > 0) 
[10:19:22.549]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.549]             }
[10:19:22.549]             else {
[10:19:22.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.549]             }
[10:19:22.549]             {
[10:19:22.549]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.549]                   0L) {
[10:19:22.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.549]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.549]                   base::options(opts)
[10:19:22.549]                 }
[10:19:22.549]                 {
[10:19:22.549]                   {
[10:19:22.549]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.549]                     NULL
[10:19:22.549]                   }
[10:19:22.549]                   options(future.plan = NULL)
[10:19:22.549]                   if (is.na(NA_character_)) 
[10:19:22.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.549]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.549]                     .init = FALSE)
[10:19:22.549]                 }
[10:19:22.549]             }
[10:19:22.549]         }
[10:19:22.549]     })
[10:19:22.549]     if (TRUE) {
[10:19:22.549]         base::sink(type = "output", split = FALSE)
[10:19:22.549]         if (TRUE) {
[10:19:22.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.549]         }
[10:19:22.549]         else {
[10:19:22.549]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.549]         }
[10:19:22.549]         base::close(...future.stdout)
[10:19:22.549]         ...future.stdout <- NULL
[10:19:22.549]     }
[10:19:22.549]     ...future.result$conditions <- ...future.conditions
[10:19:22.549]     ...future.result$finished <- base::Sys.time()
[10:19:22.549]     ...future.result
[10:19:22.549] }
[10:19:22.552] assign_globals() ...
[10:19:22.552] List of 5
[10:19:22.552]  $ ...future.FUN            :function (C, k)  
[10:19:22.552]  $ MoreArgs                 : NULL
[10:19:22.552]  $ ...future.elements_ii    :List of 2
[10:19:22.552]   ..$ :List of 3
[10:19:22.552]   .. ..$ : chr "C"
[10:19:22.552]   .. ..$ : chr "B"
[10:19:22.552]   .. ..$ : chr "A"
[10:19:22.552]   ..$ :List of 3
[10:19:22.552]   .. ..$ : int 3
[10:19:22.552]   .. ..$ : int 4
[10:19:22.552]   .. ..$ : int 5
[10:19:22.552]  $ ...future.seeds_ii       : NULL
[10:19:22.552]  $ ...future.globals.maxSize: NULL
[10:19:22.552]  - attr(*, "where")=List of 5
[10:19:22.552]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.552]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.552]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.552]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.552]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.552]  - attr(*, "resolved")= logi FALSE
[10:19:22.552]  - attr(*, "total_size")= num 905
[10:19:22.552]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.552]  - attr(*, "already-done")= logi TRUE
[10:19:22.560] - reassign environment for ‘...future.FUN’
[10:19:22.560] - copied ‘...future.FUN’ to environment
[10:19:22.560] - copied ‘MoreArgs’ to environment
[10:19:22.561] - copied ‘...future.elements_ii’ to environment
[10:19:22.561] - copied ‘...future.seeds_ii’ to environment
[10:19:22.561] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.561] assign_globals() ... done
[10:19:22.561] requestCore(): workers = 2
[10:19:22.563] MulticoreFuture started
[10:19:22.564] - Launch lazy future ... done
[10:19:22.564] run() for ‘MulticoreFuture’ ... done
[10:19:22.564] Created future:
[10:19:22.564] plan(): Setting new future strategy stack:
[10:19:22.565] List of future strategies:
[10:19:22.565] 1. sequential:
[10:19:22.565]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.565]    - tweaked: FALSE
[10:19:22.565]    - call: NULL
[10:19:22.566] plan(): nbrOfWorkers() = 1
[10:19:22.568] plan(): Setting new future strategy stack:
[10:19:22.568] List of future strategies:
[10:19:22.568] 1. multicore:
[10:19:22.568]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.568]    - tweaked: FALSE
[10:19:22.568]    - call: plan(strategy)
[10:19:22.571] plan(): nbrOfWorkers() = 2
[10:19:22.565] MulticoreFuture:
[10:19:22.565] Label: ‘future_mapply-2’
[10:19:22.565] Expression:
[10:19:22.565] {
[10:19:22.565]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.565]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.565]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.565]         on.exit(options(oopts), add = TRUE)
[10:19:22.565]     }
[10:19:22.565]     {
[10:19:22.565]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.565]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.565]         do.call(mapply, args = args)
[10:19:22.565]     }
[10:19:22.565] }
[10:19:22.565] Lazy evaluation: FALSE
[10:19:22.565] Asynchronous evaluation: TRUE
[10:19:22.565] Local evaluation: TRUE
[10:19:22.565] Environment: R_GlobalEnv
[10:19:22.565] Capture standard output: TRUE
[10:19:22.565] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.565] Globals: 5 objects totaling 905 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.565] Packages: <none>
[10:19:22.565] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.565] Resolved: TRUE
[10:19:22.565] Value: <not collected>
[10:19:22.565] Conditions captured: <none>
[10:19:22.565] Early signaling: FALSE
[10:19:22.565] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.565] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.572] Chunk #2 of 2 ... DONE
[10:19:22.573] Launching 2 futures (chunks) ... DONE
[10:19:22.573] Resolving 2 futures (chunks) ...
[10:19:22.573] resolve() on list ...
[10:19:22.573]  recursive: 0
[10:19:22.573]  length: 2
[10:19:22.573] 
[10:19:22.574] Future #1
[10:19:22.574] result() for MulticoreFuture ...
[10:19:22.575] result() for MulticoreFuture ...
[10:19:22.575] result() for MulticoreFuture ... done
[10:19:22.575] result() for MulticoreFuture ... done
[10:19:22.575] result() for MulticoreFuture ...
[10:19:22.575] result() for MulticoreFuture ... done
[10:19:22.575] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:22.576] - nx: 2
[10:19:22.576] - relay: TRUE
[10:19:22.576] - stdout: TRUE
[10:19:22.576] - signal: TRUE
[10:19:22.576] - resignal: FALSE
[10:19:22.576] - force: TRUE
[10:19:22.576] - relayed: [n=2] FALSE, FALSE
[10:19:22.577] - queued futures: [n=2] FALSE, FALSE
[10:19:22.580]  - until=1
[10:19:22.581]  - relaying element #1
[10:19:22.581] result() for MulticoreFuture ...
[10:19:22.582] result() for MulticoreFuture ... done
[10:19:22.582] result() for MulticoreFuture ...
[10:19:22.582] result() for MulticoreFuture ... done
[10:19:22.583] result() for MulticoreFuture ...
[10:19:22.583] result() for MulticoreFuture ... done
[10:19:22.583] result() for MulticoreFuture ...
[10:19:22.583] result() for MulticoreFuture ... done
[10:19:22.584] - relayed: [n=2] TRUE, FALSE
[10:19:22.584] - queued futures: [n=2] TRUE, FALSE
[10:19:22.584] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:22.584]  length: 1 (resolved future 1)
[10:19:22.585] Future #2
[10:19:22.585] result() for MulticoreFuture ...
[10:19:22.586] result() for MulticoreFuture ...
[10:19:22.586] result() for MulticoreFuture ... done
[10:19:22.587] result() for MulticoreFuture ... done
[10:19:22.587] result() for MulticoreFuture ...
[10:19:22.587] result() for MulticoreFuture ... done
[10:19:22.587] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:22.587] - nx: 2
[10:19:22.588] - relay: TRUE
[10:19:22.588] - stdout: TRUE
[10:19:22.588] - signal: TRUE
[10:19:22.588] - resignal: FALSE
[10:19:22.588] - force: TRUE
[10:19:22.588] - relayed: [n=2] TRUE, FALSE
[10:19:22.588] - queued futures: [n=2] TRUE, FALSE
[10:19:22.589]  - until=2
[10:19:22.589]  - relaying element #2
[10:19:22.589] result() for MulticoreFuture ...
[10:19:22.589] result() for MulticoreFuture ... done
[10:19:22.589] result() for MulticoreFuture ...
[10:19:22.589] result() for MulticoreFuture ... done
[10:19:22.589] result() for MulticoreFuture ...
[10:19:22.590] result() for MulticoreFuture ... done
[10:19:22.590] result() for MulticoreFuture ...
[10:19:22.590] result() for MulticoreFuture ... done
[10:19:22.590] - relayed: [n=2] TRUE, TRUE
[10:19:22.590] - queued futures: [n=2] TRUE, TRUE
[10:19:22.590] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:22.591]  length: 0 (resolved future 2)
[10:19:22.591] Relaying remaining futures
[10:19:22.591] signalConditionsASAP(NULL, pos=0) ...
[10:19:22.591] - nx: 2
[10:19:22.591] - relay: TRUE
[10:19:22.591] - stdout: TRUE
[10:19:22.591] - signal: TRUE
[10:19:22.591] - resignal: FALSE
[10:19:22.591] - force: TRUE
[10:19:22.592] - relayed: [n=2] TRUE, TRUE
[10:19:22.592] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:22.592] - relayed: [n=2] TRUE, TRUE
[10:19:22.592] - queued futures: [n=2] TRUE, TRUE
[10:19:22.592] signalConditionsASAP(NULL, pos=0) ... done
[10:19:22.592] resolve() on list ... DONE
[10:19:22.592] result() for MulticoreFuture ...
[10:19:22.592] result() for MulticoreFuture ... done
[10:19:22.592] result() for MulticoreFuture ...
[10:19:22.593] result() for MulticoreFuture ... done
[10:19:22.593] result() for MulticoreFuture ...
[10:19:22.593] result() for MulticoreFuture ... done
[10:19:22.593] result() for MulticoreFuture ...
[10:19:22.593] result() for MulticoreFuture ... done
[10:19:22.593]  - Number of value chunks collected: 2
[10:19:22.593] Resolving 2 futures (chunks) ... DONE
[10:19:22.593] Reducing values from 2 chunks ...
[10:19:22.593]  - Number of values collected after concatenation: 5
[10:19:22.594]  - Number of values expected: 5
[10:19:22.594] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:19:22.594] Reducing values from 2 chunks ... DONE
[10:19:22.594] future_mapply() ... DONE
[10:19:22.594] future_mapply() ...
[10:19:22.596] Number of chunks: 2
[10:19:22.596] getGlobalsAndPackagesXApply() ...
[10:19:22.597]  - future.globals: TRUE
[10:19:22.597] getGlobalsAndPackages() ...
[10:19:22.597] Searching for globals...
[10:19:22.598] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:22.598] Searching for globals ... DONE
[10:19:22.598] Resolving globals: FALSE
[10:19:22.599] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:22.599] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:22.599] - globals: [1] ‘FUN’
[10:19:22.599] 
[10:19:22.600] getGlobalsAndPackages() ... DONE
[10:19:22.600]  - globals found/used: [n=1] ‘FUN’
[10:19:22.600]  - needed namespaces: [n=0] 
[10:19:22.600] Finding globals ... DONE
[10:19:22.600] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:22.600] List of 2
[10:19:22.600]  $ ...future.FUN:function (C, k)  
[10:19:22.600]  $ MoreArgs     : list()
[10:19:22.600]  - attr(*, "where")=List of 2
[10:19:22.600]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:22.600]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:22.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.600]  - attr(*, "resolved")= logi FALSE
[10:19:22.600]  - attr(*, "total_size")= num NA
[10:19:22.603] Packages to be attached in all futures: [n=0] 
[10:19:22.603] getGlobalsAndPackagesXApply() ... DONE
[10:19:22.603] Number of futures (= number of chunks): 2
[10:19:22.603] Launching 2 futures (chunks) ...
[10:19:22.604] Chunk #1 of 2 ...
[10:19:22.604]  - Finding globals in '...' for chunk #1 ...
[10:19:22.604] getGlobalsAndPackages() ...
[10:19:22.604] Searching for globals...
[10:19:22.604] 
[10:19:22.604] Searching for globals ... DONE
[10:19:22.604] - globals: [0] <none>
[10:19:22.604] getGlobalsAndPackages() ... DONE
[10:19:22.605]    + additional globals found: [n=0] 
[10:19:22.605]    + additional namespaces needed: [n=0] 
[10:19:22.605]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:22.605]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.605]  - seeds: <none>
[10:19:22.605]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.605] getGlobalsAndPackages() ...
[10:19:22.605] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.605] Resolving globals: FALSE
[10:19:22.608] The total size of the 5 globals is 880 bytes (880 bytes)
[10:19:22.608] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:22.608] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.609] 
[10:19:22.609] getGlobalsAndPackages() ... DONE
[10:19:22.609] run() for ‘Future’ ...
[10:19:22.609] - state: ‘created’
[10:19:22.609] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.611] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.611]   - Field: ‘label’
[10:19:22.611]   - Field: ‘local’
[10:19:22.612]   - Field: ‘owner’
[10:19:22.612]   - Field: ‘envir’
[10:19:22.612]   - Field: ‘workers’
[10:19:22.612]   - Field: ‘packages’
[10:19:22.612]   - Field: ‘gc’
[10:19:22.612]   - Field: ‘job’
[10:19:22.612]   - Field: ‘conditions’
[10:19:22.612]   - Field: ‘expr’
[10:19:22.612]   - Field: ‘uuid’
[10:19:22.612]   - Field: ‘seed’
[10:19:22.612]   - Field: ‘version’
[10:19:22.613]   - Field: ‘result’
[10:19:22.613]   - Field: ‘asynchronous’
[10:19:22.613]   - Field: ‘calls’
[10:19:22.613]   - Field: ‘globals’
[10:19:22.613]   - Field: ‘stdout’
[10:19:22.613]   - Field: ‘earlySignal’
[10:19:22.613]   - Field: ‘lazy’
[10:19:22.613]   - Field: ‘state’
[10:19:22.613] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.613] - Launch lazy future ...
[10:19:22.614] Packages needed by the future expression (n = 0): <none>
[10:19:22.614] Packages needed by future strategies (n = 0): <none>
[10:19:22.614] {
[10:19:22.614]     {
[10:19:22.614]         {
[10:19:22.614]             ...future.startTime <- base::Sys.time()
[10:19:22.614]             {
[10:19:22.614]                 {
[10:19:22.614]                   {
[10:19:22.614]                     {
[10:19:22.614]                       base::local({
[10:19:22.614]                         has_future <- base::requireNamespace("future", 
[10:19:22.614]                           quietly = TRUE)
[10:19:22.614]                         if (has_future) {
[10:19:22.614]                           ns <- base::getNamespace("future")
[10:19:22.614]                           version <- ns[[".package"]][["version"]]
[10:19:22.614]                           if (is.null(version)) 
[10:19:22.614]                             version <- utils::packageVersion("future")
[10:19:22.614]                         }
[10:19:22.614]                         else {
[10:19:22.614]                           version <- NULL
[10:19:22.614]                         }
[10:19:22.614]                         if (!has_future || version < "1.8.0") {
[10:19:22.614]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.614]                             "", base::R.version$version.string), 
[10:19:22.614]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.614]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.614]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.614]                               "release", "version")], collapse = " "), 
[10:19:22.614]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.614]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.614]                             info)
[10:19:22.614]                           info <- base::paste(info, collapse = "; ")
[10:19:22.614]                           if (!has_future) {
[10:19:22.614]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.614]                               info)
[10:19:22.614]                           }
[10:19:22.614]                           else {
[10:19:22.614]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.614]                               info, version)
[10:19:22.614]                           }
[10:19:22.614]                           base::stop(msg)
[10:19:22.614]                         }
[10:19:22.614]                       })
[10:19:22.614]                     }
[10:19:22.614]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.614]                     base::options(mc.cores = 1L)
[10:19:22.614]                   }
[10:19:22.614]                   ...future.strategy.old <- future::plan("list")
[10:19:22.614]                   options(future.plan = NULL)
[10:19:22.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.614]                 }
[10:19:22.614]                 ...future.workdir <- getwd()
[10:19:22.614]             }
[10:19:22.614]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.614]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.614]         }
[10:19:22.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.614]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.614]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.614]             base::names(...future.oldOptions))
[10:19:22.614]     }
[10:19:22.614]     if (FALSE) {
[10:19:22.614]     }
[10:19:22.614]     else {
[10:19:22.614]         if (TRUE) {
[10:19:22.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.614]                 open = "w")
[10:19:22.614]         }
[10:19:22.614]         else {
[10:19:22.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.614]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.614]         }
[10:19:22.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.614]             base::sink(type = "output", split = FALSE)
[10:19:22.614]             base::close(...future.stdout)
[10:19:22.614]         }, add = TRUE)
[10:19:22.614]     }
[10:19:22.614]     ...future.frame <- base::sys.nframe()
[10:19:22.614]     ...future.conditions <- base::list()
[10:19:22.614]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.614]     if (FALSE) {
[10:19:22.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.614]     }
[10:19:22.614]     ...future.result <- base::tryCatch({
[10:19:22.614]         base::withCallingHandlers({
[10:19:22.614]             ...future.value <- base::withVisible(base::local({
[10:19:22.614]                 withCallingHandlers({
[10:19:22.614]                   {
[10:19:22.614]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.614]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.614]                       ...future.globals.maxSize)) {
[10:19:22.614]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.614]                       on.exit(options(oopts), add = TRUE)
[10:19:22.614]                     }
[10:19:22.614]                     {
[10:19:22.614]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.614]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.614]                         USE.NAMES = FALSE)
[10:19:22.614]                       do.call(mapply, args = args)
[10:19:22.614]                     }
[10:19:22.614]                   }
[10:19:22.614]                 }, immediateCondition = function(cond) {
[10:19:22.614]                   save_rds <- function (object, pathname, ...) 
[10:19:22.614]                   {
[10:19:22.614]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.614]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.614]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.614]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.614]                         fi_tmp[["mtime"]])
[10:19:22.614]                     }
[10:19:22.614]                     tryCatch({
[10:19:22.614]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.614]                     }, error = function(ex) {
[10:19:22.614]                       msg <- conditionMessage(ex)
[10:19:22.614]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.614]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.614]                         fi_tmp[["mtime"]], msg)
[10:19:22.614]                       ex$message <- msg
[10:19:22.614]                       stop(ex)
[10:19:22.614]                     })
[10:19:22.614]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.614]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.614]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.614]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.614]                       fi <- file.info(pathname)
[10:19:22.614]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.614]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.614]                         fi[["size"]], fi[["mtime"]])
[10:19:22.614]                       stop(msg)
[10:19:22.614]                     }
[10:19:22.614]                     invisible(pathname)
[10:19:22.614]                   }
[10:19:22.614]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.614]                     rootPath = tempdir()) 
[10:19:22.614]                   {
[10:19:22.614]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.614]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.614]                       tmpdir = path, fileext = ".rds")
[10:19:22.614]                     save_rds(obj, file)
[10:19:22.614]                   }
[10:19:22.614]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.614]                   {
[10:19:22.614]                     inherits <- base::inherits
[10:19:22.614]                     invokeRestart <- base::invokeRestart
[10:19:22.614]                     is.null <- base::is.null
[10:19:22.614]                     muffled <- FALSE
[10:19:22.614]                     if (inherits(cond, "message")) {
[10:19:22.614]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.614]                       if (muffled) 
[10:19:22.614]                         invokeRestart("muffleMessage")
[10:19:22.614]                     }
[10:19:22.614]                     else if (inherits(cond, "warning")) {
[10:19:22.614]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.614]                       if (muffled) 
[10:19:22.614]                         invokeRestart("muffleWarning")
[10:19:22.614]                     }
[10:19:22.614]                     else if (inherits(cond, "condition")) {
[10:19:22.614]                       if (!is.null(pattern)) {
[10:19:22.614]                         computeRestarts <- base::computeRestarts
[10:19:22.614]                         grepl <- base::grepl
[10:19:22.614]                         restarts <- computeRestarts(cond)
[10:19:22.614]                         for (restart in restarts) {
[10:19:22.614]                           name <- restart$name
[10:19:22.614]                           if (is.null(name)) 
[10:19:22.614]                             next
[10:19:22.614]                           if (!grepl(pattern, name)) 
[10:19:22.614]                             next
[10:19:22.614]                           invokeRestart(restart)
[10:19:22.614]                           muffled <- TRUE
[10:19:22.614]                           break
[10:19:22.614]                         }
[10:19:22.614]                       }
[10:19:22.614]                     }
[10:19:22.614]                     invisible(muffled)
[10:19:22.614]                   }
[10:19:22.614]                   muffleCondition(cond)
[10:19:22.614]                 })
[10:19:22.614]             }))
[10:19:22.614]             future::FutureResult(value = ...future.value$value, 
[10:19:22.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.614]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.614]                     ...future.globalenv.names))
[10:19:22.614]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.614]         }, condition = base::local({
[10:19:22.614]             c <- base::c
[10:19:22.614]             inherits <- base::inherits
[10:19:22.614]             invokeRestart <- base::invokeRestart
[10:19:22.614]             length <- base::length
[10:19:22.614]             list <- base::list
[10:19:22.614]             seq.int <- base::seq.int
[10:19:22.614]             signalCondition <- base::signalCondition
[10:19:22.614]             sys.calls <- base::sys.calls
[10:19:22.614]             `[[` <- base::`[[`
[10:19:22.614]             `+` <- base::`+`
[10:19:22.614]             `<<-` <- base::`<<-`
[10:19:22.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.614]                   3L)]
[10:19:22.614]             }
[10:19:22.614]             function(cond) {
[10:19:22.614]                 is_error <- inherits(cond, "error")
[10:19:22.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.614]                   NULL)
[10:19:22.614]                 if (is_error) {
[10:19:22.614]                   sessionInformation <- function() {
[10:19:22.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.614]                       search = base::search(), system = base::Sys.info())
[10:19:22.614]                   }
[10:19:22.614]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.614]                     cond$call), session = sessionInformation(), 
[10:19:22.614]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.614]                   signalCondition(cond)
[10:19:22.614]                 }
[10:19:22.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.614]                 "immediateCondition"))) {
[10:19:22.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.614]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.614]                   if (TRUE && !signal) {
[10:19:22.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.614]                     {
[10:19:22.614]                       inherits <- base::inherits
[10:19:22.614]                       invokeRestart <- base::invokeRestart
[10:19:22.614]                       is.null <- base::is.null
[10:19:22.614]                       muffled <- FALSE
[10:19:22.614]                       if (inherits(cond, "message")) {
[10:19:22.614]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.614]                         if (muffled) 
[10:19:22.614]                           invokeRestart("muffleMessage")
[10:19:22.614]                       }
[10:19:22.614]                       else if (inherits(cond, "warning")) {
[10:19:22.614]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.614]                         if (muffled) 
[10:19:22.614]                           invokeRestart("muffleWarning")
[10:19:22.614]                       }
[10:19:22.614]                       else if (inherits(cond, "condition")) {
[10:19:22.614]                         if (!is.null(pattern)) {
[10:19:22.614]                           computeRestarts <- base::computeRestarts
[10:19:22.614]                           grepl <- base::grepl
[10:19:22.614]                           restarts <- computeRestarts(cond)
[10:19:22.614]                           for (restart in restarts) {
[10:19:22.614]                             name <- restart$name
[10:19:22.614]                             if (is.null(name)) 
[10:19:22.614]                               next
[10:19:22.614]                             if (!grepl(pattern, name)) 
[10:19:22.614]                               next
[10:19:22.614]                             invokeRestart(restart)
[10:19:22.614]                             muffled <- TRUE
[10:19:22.614]                             break
[10:19:22.614]                           }
[10:19:22.614]                         }
[10:19:22.614]                       }
[10:19:22.614]                       invisible(muffled)
[10:19:22.614]                     }
[10:19:22.614]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.614]                   }
[10:19:22.614]                 }
[10:19:22.614]                 else {
[10:19:22.614]                   if (TRUE) {
[10:19:22.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.614]                     {
[10:19:22.614]                       inherits <- base::inherits
[10:19:22.614]                       invokeRestart <- base::invokeRestart
[10:19:22.614]                       is.null <- base::is.null
[10:19:22.614]                       muffled <- FALSE
[10:19:22.614]                       if (inherits(cond, "message")) {
[10:19:22.614]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.614]                         if (muffled) 
[10:19:22.614]                           invokeRestart("muffleMessage")
[10:19:22.614]                       }
[10:19:22.614]                       else if (inherits(cond, "warning")) {
[10:19:22.614]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.614]                         if (muffled) 
[10:19:22.614]                           invokeRestart("muffleWarning")
[10:19:22.614]                       }
[10:19:22.614]                       else if (inherits(cond, "condition")) {
[10:19:22.614]                         if (!is.null(pattern)) {
[10:19:22.614]                           computeRestarts <- base::computeRestarts
[10:19:22.614]                           grepl <- base::grepl
[10:19:22.614]                           restarts <- computeRestarts(cond)
[10:19:22.614]                           for (restart in restarts) {
[10:19:22.614]                             name <- restart$name
[10:19:22.614]                             if (is.null(name)) 
[10:19:22.614]                               next
[10:19:22.614]                             if (!grepl(pattern, name)) 
[10:19:22.614]                               next
[10:19:22.614]                             invokeRestart(restart)
[10:19:22.614]                             muffled <- TRUE
[10:19:22.614]                             break
[10:19:22.614]                           }
[10:19:22.614]                         }
[10:19:22.614]                       }
[10:19:22.614]                       invisible(muffled)
[10:19:22.614]                     }
[10:19:22.614]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.614]                   }
[10:19:22.614]                 }
[10:19:22.614]             }
[10:19:22.614]         }))
[10:19:22.614]     }, error = function(ex) {
[10:19:22.614]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.614]                 ...future.rng), started = ...future.startTime, 
[10:19:22.614]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.614]             version = "1.8"), class = "FutureResult")
[10:19:22.614]     }, finally = {
[10:19:22.614]         if (!identical(...future.workdir, getwd())) 
[10:19:22.614]             setwd(...future.workdir)
[10:19:22.614]         {
[10:19:22.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.614]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.614]             }
[10:19:22.614]             base::options(...future.oldOptions)
[10:19:22.614]             if (.Platform$OS.type == "windows") {
[10:19:22.614]                 old_names <- names(...future.oldEnvVars)
[10:19:22.614]                 envs <- base::Sys.getenv()
[10:19:22.614]                 names <- names(envs)
[10:19:22.614]                 common <- intersect(names, old_names)
[10:19:22.614]                 added <- setdiff(names, old_names)
[10:19:22.614]                 removed <- setdiff(old_names, names)
[10:19:22.614]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.614]                   envs[common]]
[10:19:22.614]                 NAMES <- toupper(changed)
[10:19:22.614]                 args <- list()
[10:19:22.614]                 for (kk in seq_along(NAMES)) {
[10:19:22.614]                   name <- changed[[kk]]
[10:19:22.614]                   NAME <- NAMES[[kk]]
[10:19:22.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.614]                     next
[10:19:22.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.614]                 }
[10:19:22.614]                 NAMES <- toupper(added)
[10:19:22.614]                 for (kk in seq_along(NAMES)) {
[10:19:22.614]                   name <- added[[kk]]
[10:19:22.614]                   NAME <- NAMES[[kk]]
[10:19:22.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.614]                     next
[10:19:22.614]                   args[[name]] <- ""
[10:19:22.614]                 }
[10:19:22.614]                 NAMES <- toupper(removed)
[10:19:22.614]                 for (kk in seq_along(NAMES)) {
[10:19:22.614]                   name <- removed[[kk]]
[10:19:22.614]                   NAME <- NAMES[[kk]]
[10:19:22.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.614]                     next
[10:19:22.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.614]                 }
[10:19:22.614]                 if (length(args) > 0) 
[10:19:22.614]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.614]             }
[10:19:22.614]             else {
[10:19:22.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.614]             }
[10:19:22.614]             {
[10:19:22.614]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.614]                   0L) {
[10:19:22.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.614]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.614]                   base::options(opts)
[10:19:22.614]                 }
[10:19:22.614]                 {
[10:19:22.614]                   {
[10:19:22.614]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.614]                     NULL
[10:19:22.614]                   }
[10:19:22.614]                   options(future.plan = NULL)
[10:19:22.614]                   if (is.na(NA_character_)) 
[10:19:22.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.614]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.614]                     .init = FALSE)
[10:19:22.614]                 }
[10:19:22.614]             }
[10:19:22.614]         }
[10:19:22.614]     })
[10:19:22.614]     if (TRUE) {
[10:19:22.614]         base::sink(type = "output", split = FALSE)
[10:19:22.614]         if (TRUE) {
[10:19:22.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.614]         }
[10:19:22.614]         else {
[10:19:22.614]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.614]         }
[10:19:22.614]         base::close(...future.stdout)
[10:19:22.614]         ...future.stdout <- NULL
[10:19:22.614]     }
[10:19:22.614]     ...future.result$conditions <- ...future.conditions
[10:19:22.614]     ...future.result$finished <- base::Sys.time()
[10:19:22.614]     ...future.result
[10:19:22.614] }
[10:19:22.617] assign_globals() ...
[10:19:22.617] List of 5
[10:19:22.617]  $ ...future.FUN            :function (C, k)  
[10:19:22.617]  $ MoreArgs                 : list()
[10:19:22.617]  $ ...future.elements_ii    :List of 2
[10:19:22.617]   ..$ :List of 2
[10:19:22.617]   .. ..$ : chr "A"
[10:19:22.617]   .. ..$ : chr "B"
[10:19:22.617]   ..$ :List of 2
[10:19:22.617]   .. ..$ : int 5
[10:19:22.617]   .. ..$ : int 4
[10:19:22.617]  $ ...future.seeds_ii       : NULL
[10:19:22.617]  $ ...future.globals.maxSize: NULL
[10:19:22.617]  - attr(*, "where")=List of 5
[10:19:22.617]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.617]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.617]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.617]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.617]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.617]  - attr(*, "resolved")= logi FALSE
[10:19:22.617]  - attr(*, "total_size")= num 880
[10:19:22.617]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.617]  - attr(*, "already-done")= logi TRUE
[10:19:22.622] - reassign environment for ‘...future.FUN’
[10:19:22.622] - copied ‘...future.FUN’ to environment
[10:19:22.622] - copied ‘MoreArgs’ to environment
[10:19:22.623] - copied ‘...future.elements_ii’ to environment
[10:19:22.623] - copied ‘...future.seeds_ii’ to environment
[10:19:22.623] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.623] assign_globals() ... done
[10:19:22.623] requestCore(): workers = 2
[10:19:22.625] MulticoreFuture started
[10:19:22.626] - Launch lazy future ... done
[10:19:22.626] run() for ‘MulticoreFuture’ ... done
[10:19:22.626] Created future:
[10:19:22.626] plan(): Setting new future strategy stack:
[10:19:22.626] List of future strategies:
[10:19:22.626] 1. sequential:
[10:19:22.626]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.626]    - tweaked: FALSE
[10:19:22.626]    - call: NULL
[10:19:22.627] plan(): nbrOfWorkers() = 1
[10:19:22.630] plan(): Setting new future strategy stack:
[10:19:22.630] List of future strategies:
[10:19:22.630] 1. multicore:
[10:19:22.630]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.630]    - tweaked: FALSE
[10:19:22.630]    - call: plan(strategy)
[10:19:22.633] plan(): nbrOfWorkers() = 2
[10:19:22.626] MulticoreFuture:
[10:19:22.626] Label: ‘future_.mapply-1’
[10:19:22.626] Expression:
[10:19:22.626] {
[10:19:22.626]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.626]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.626]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.626]         on.exit(options(oopts), add = TRUE)
[10:19:22.626]     }
[10:19:22.626]     {
[10:19:22.626]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.626]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.626]         do.call(mapply, args = args)
[10:19:22.626]     }
[10:19:22.626] }
[10:19:22.626] Lazy evaluation: FALSE
[10:19:22.626] Asynchronous evaluation: TRUE
[10:19:22.626] Local evaluation: TRUE
[10:19:22.626] Environment: R_GlobalEnv
[10:19:22.626] Capture standard output: TRUE
[10:19:22.626] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.626] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.626] Packages: <none>
[10:19:22.626] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.626] Resolved: TRUE
[10:19:22.626] Value: <not collected>
[10:19:22.626] Conditions captured: <none>
[10:19:22.626] Early signaling: FALSE
[10:19:22.626] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.626] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.634] Chunk #1 of 2 ... DONE
[10:19:22.635] Chunk #2 of 2 ...
[10:19:22.635]  - Finding globals in '...' for chunk #2 ...
[10:19:22.635] getGlobalsAndPackages() ...
[10:19:22.635] Searching for globals...
[10:19:22.636] 
[10:19:22.636] Searching for globals ... DONE
[10:19:22.636] - globals: [0] <none>
[10:19:22.636] getGlobalsAndPackages() ... DONE
[10:19:22.636]    + additional globals found: [n=0] 
[10:19:22.636]    + additional namespaces needed: [n=0] 
[10:19:22.636]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:22.637]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.637]  - seeds: <none>
[10:19:22.637]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.637] getGlobalsAndPackages() ...
[10:19:22.637] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.637] Resolving globals: FALSE
[10:19:22.638] The total size of the 5 globals is 909 bytes (909 bytes)
[10:19:22.639] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:22.639] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.639] 
[10:19:22.639] getGlobalsAndPackages() ... DONE
[10:19:22.640] run() for ‘Future’ ...
[10:19:22.640] - state: ‘created’
[10:19:22.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.648] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.649]   - Field: ‘label’
[10:19:22.649]   - Field: ‘local’
[10:19:22.649]   - Field: ‘owner’
[10:19:22.650]   - Field: ‘envir’
[10:19:22.650]   - Field: ‘workers’
[10:19:22.650]   - Field: ‘packages’
[10:19:22.650]   - Field: ‘gc’
[10:19:22.650]   - Field: ‘job’
[10:19:22.651]   - Field: ‘conditions’
[10:19:22.651]   - Field: ‘expr’
[10:19:22.651]   - Field: ‘uuid’
[10:19:22.651]   - Field: ‘seed’
[10:19:22.652]   - Field: ‘version’
[10:19:22.652]   - Field: ‘result’
[10:19:22.652]   - Field: ‘asynchronous’
[10:19:22.652]   - Field: ‘calls’
[10:19:22.652]   - Field: ‘globals’
[10:19:22.653]   - Field: ‘stdout’
[10:19:22.653]   - Field: ‘earlySignal’
[10:19:22.653]   - Field: ‘lazy’
[10:19:22.653]   - Field: ‘state’
[10:19:22.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.653] - Launch lazy future ...
[10:19:22.654] Packages needed by the future expression (n = 0): <none>
[10:19:22.654] Packages needed by future strategies (n = 0): <none>
[10:19:22.655] {
[10:19:22.655]     {
[10:19:22.655]         {
[10:19:22.655]             ...future.startTime <- base::Sys.time()
[10:19:22.655]             {
[10:19:22.655]                 {
[10:19:22.655]                   {
[10:19:22.655]                     {
[10:19:22.655]                       base::local({
[10:19:22.655]                         has_future <- base::requireNamespace("future", 
[10:19:22.655]                           quietly = TRUE)
[10:19:22.655]                         if (has_future) {
[10:19:22.655]                           ns <- base::getNamespace("future")
[10:19:22.655]                           version <- ns[[".package"]][["version"]]
[10:19:22.655]                           if (is.null(version)) 
[10:19:22.655]                             version <- utils::packageVersion("future")
[10:19:22.655]                         }
[10:19:22.655]                         else {
[10:19:22.655]                           version <- NULL
[10:19:22.655]                         }
[10:19:22.655]                         if (!has_future || version < "1.8.0") {
[10:19:22.655]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.655]                             "", base::R.version$version.string), 
[10:19:22.655]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.655]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.655]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.655]                               "release", "version")], collapse = " "), 
[10:19:22.655]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.655]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.655]                             info)
[10:19:22.655]                           info <- base::paste(info, collapse = "; ")
[10:19:22.655]                           if (!has_future) {
[10:19:22.655]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.655]                               info)
[10:19:22.655]                           }
[10:19:22.655]                           else {
[10:19:22.655]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.655]                               info, version)
[10:19:22.655]                           }
[10:19:22.655]                           base::stop(msg)
[10:19:22.655]                         }
[10:19:22.655]                       })
[10:19:22.655]                     }
[10:19:22.655]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.655]                     base::options(mc.cores = 1L)
[10:19:22.655]                   }
[10:19:22.655]                   ...future.strategy.old <- future::plan("list")
[10:19:22.655]                   options(future.plan = NULL)
[10:19:22.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.655]                 }
[10:19:22.655]                 ...future.workdir <- getwd()
[10:19:22.655]             }
[10:19:22.655]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.655]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.655]         }
[10:19:22.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.655]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.655]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.655]             base::names(...future.oldOptions))
[10:19:22.655]     }
[10:19:22.655]     if (FALSE) {
[10:19:22.655]     }
[10:19:22.655]     else {
[10:19:22.655]         if (TRUE) {
[10:19:22.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.655]                 open = "w")
[10:19:22.655]         }
[10:19:22.655]         else {
[10:19:22.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.655]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.655]         }
[10:19:22.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.655]             base::sink(type = "output", split = FALSE)
[10:19:22.655]             base::close(...future.stdout)
[10:19:22.655]         }, add = TRUE)
[10:19:22.655]     }
[10:19:22.655]     ...future.frame <- base::sys.nframe()
[10:19:22.655]     ...future.conditions <- base::list()
[10:19:22.655]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.655]     if (FALSE) {
[10:19:22.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.655]     }
[10:19:22.655]     ...future.result <- base::tryCatch({
[10:19:22.655]         base::withCallingHandlers({
[10:19:22.655]             ...future.value <- base::withVisible(base::local({
[10:19:22.655]                 withCallingHandlers({
[10:19:22.655]                   {
[10:19:22.655]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.655]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.655]                       ...future.globals.maxSize)) {
[10:19:22.655]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.655]                       on.exit(options(oopts), add = TRUE)
[10:19:22.655]                     }
[10:19:22.655]                     {
[10:19:22.655]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.655]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.655]                         USE.NAMES = FALSE)
[10:19:22.655]                       do.call(mapply, args = args)
[10:19:22.655]                     }
[10:19:22.655]                   }
[10:19:22.655]                 }, immediateCondition = function(cond) {
[10:19:22.655]                   save_rds <- function (object, pathname, ...) 
[10:19:22.655]                   {
[10:19:22.655]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.655]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.655]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.655]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.655]                         fi_tmp[["mtime"]])
[10:19:22.655]                     }
[10:19:22.655]                     tryCatch({
[10:19:22.655]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.655]                     }, error = function(ex) {
[10:19:22.655]                       msg <- conditionMessage(ex)
[10:19:22.655]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.655]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.655]                         fi_tmp[["mtime"]], msg)
[10:19:22.655]                       ex$message <- msg
[10:19:22.655]                       stop(ex)
[10:19:22.655]                     })
[10:19:22.655]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.655]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.655]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.655]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.655]                       fi <- file.info(pathname)
[10:19:22.655]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.655]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.655]                         fi[["size"]], fi[["mtime"]])
[10:19:22.655]                       stop(msg)
[10:19:22.655]                     }
[10:19:22.655]                     invisible(pathname)
[10:19:22.655]                   }
[10:19:22.655]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.655]                     rootPath = tempdir()) 
[10:19:22.655]                   {
[10:19:22.655]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.655]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.655]                       tmpdir = path, fileext = ".rds")
[10:19:22.655]                     save_rds(obj, file)
[10:19:22.655]                   }
[10:19:22.655]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.655]                   {
[10:19:22.655]                     inherits <- base::inherits
[10:19:22.655]                     invokeRestart <- base::invokeRestart
[10:19:22.655]                     is.null <- base::is.null
[10:19:22.655]                     muffled <- FALSE
[10:19:22.655]                     if (inherits(cond, "message")) {
[10:19:22.655]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.655]                       if (muffled) 
[10:19:22.655]                         invokeRestart("muffleMessage")
[10:19:22.655]                     }
[10:19:22.655]                     else if (inherits(cond, "warning")) {
[10:19:22.655]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.655]                       if (muffled) 
[10:19:22.655]                         invokeRestart("muffleWarning")
[10:19:22.655]                     }
[10:19:22.655]                     else if (inherits(cond, "condition")) {
[10:19:22.655]                       if (!is.null(pattern)) {
[10:19:22.655]                         computeRestarts <- base::computeRestarts
[10:19:22.655]                         grepl <- base::grepl
[10:19:22.655]                         restarts <- computeRestarts(cond)
[10:19:22.655]                         for (restart in restarts) {
[10:19:22.655]                           name <- restart$name
[10:19:22.655]                           if (is.null(name)) 
[10:19:22.655]                             next
[10:19:22.655]                           if (!grepl(pattern, name)) 
[10:19:22.655]                             next
[10:19:22.655]                           invokeRestart(restart)
[10:19:22.655]                           muffled <- TRUE
[10:19:22.655]                           break
[10:19:22.655]                         }
[10:19:22.655]                       }
[10:19:22.655]                     }
[10:19:22.655]                     invisible(muffled)
[10:19:22.655]                   }
[10:19:22.655]                   muffleCondition(cond)
[10:19:22.655]                 })
[10:19:22.655]             }))
[10:19:22.655]             future::FutureResult(value = ...future.value$value, 
[10:19:22.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.655]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.655]                     ...future.globalenv.names))
[10:19:22.655]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.655]         }, condition = base::local({
[10:19:22.655]             c <- base::c
[10:19:22.655]             inherits <- base::inherits
[10:19:22.655]             invokeRestart <- base::invokeRestart
[10:19:22.655]             length <- base::length
[10:19:22.655]             list <- base::list
[10:19:22.655]             seq.int <- base::seq.int
[10:19:22.655]             signalCondition <- base::signalCondition
[10:19:22.655]             sys.calls <- base::sys.calls
[10:19:22.655]             `[[` <- base::`[[`
[10:19:22.655]             `+` <- base::`+`
[10:19:22.655]             `<<-` <- base::`<<-`
[10:19:22.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.655]                   3L)]
[10:19:22.655]             }
[10:19:22.655]             function(cond) {
[10:19:22.655]                 is_error <- inherits(cond, "error")
[10:19:22.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.655]                   NULL)
[10:19:22.655]                 if (is_error) {
[10:19:22.655]                   sessionInformation <- function() {
[10:19:22.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.655]                       search = base::search(), system = base::Sys.info())
[10:19:22.655]                   }
[10:19:22.655]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.655]                     cond$call), session = sessionInformation(), 
[10:19:22.655]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.655]                   signalCondition(cond)
[10:19:22.655]                 }
[10:19:22.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.655]                 "immediateCondition"))) {
[10:19:22.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.655]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.655]                   if (TRUE && !signal) {
[10:19:22.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.655]                     {
[10:19:22.655]                       inherits <- base::inherits
[10:19:22.655]                       invokeRestart <- base::invokeRestart
[10:19:22.655]                       is.null <- base::is.null
[10:19:22.655]                       muffled <- FALSE
[10:19:22.655]                       if (inherits(cond, "message")) {
[10:19:22.655]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.655]                         if (muffled) 
[10:19:22.655]                           invokeRestart("muffleMessage")
[10:19:22.655]                       }
[10:19:22.655]                       else if (inherits(cond, "warning")) {
[10:19:22.655]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.655]                         if (muffled) 
[10:19:22.655]                           invokeRestart("muffleWarning")
[10:19:22.655]                       }
[10:19:22.655]                       else if (inherits(cond, "condition")) {
[10:19:22.655]                         if (!is.null(pattern)) {
[10:19:22.655]                           computeRestarts <- base::computeRestarts
[10:19:22.655]                           grepl <- base::grepl
[10:19:22.655]                           restarts <- computeRestarts(cond)
[10:19:22.655]                           for (restart in restarts) {
[10:19:22.655]                             name <- restart$name
[10:19:22.655]                             if (is.null(name)) 
[10:19:22.655]                               next
[10:19:22.655]                             if (!grepl(pattern, name)) 
[10:19:22.655]                               next
[10:19:22.655]                             invokeRestart(restart)
[10:19:22.655]                             muffled <- TRUE
[10:19:22.655]                             break
[10:19:22.655]                           }
[10:19:22.655]                         }
[10:19:22.655]                       }
[10:19:22.655]                       invisible(muffled)
[10:19:22.655]                     }
[10:19:22.655]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.655]                   }
[10:19:22.655]                 }
[10:19:22.655]                 else {
[10:19:22.655]                   if (TRUE) {
[10:19:22.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.655]                     {
[10:19:22.655]                       inherits <- base::inherits
[10:19:22.655]                       invokeRestart <- base::invokeRestart
[10:19:22.655]                       is.null <- base::is.null
[10:19:22.655]                       muffled <- FALSE
[10:19:22.655]                       if (inherits(cond, "message")) {
[10:19:22.655]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.655]                         if (muffled) 
[10:19:22.655]                           invokeRestart("muffleMessage")
[10:19:22.655]                       }
[10:19:22.655]                       else if (inherits(cond, "warning")) {
[10:19:22.655]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.655]                         if (muffled) 
[10:19:22.655]                           invokeRestart("muffleWarning")
[10:19:22.655]                       }
[10:19:22.655]                       else if (inherits(cond, "condition")) {
[10:19:22.655]                         if (!is.null(pattern)) {
[10:19:22.655]                           computeRestarts <- base::computeRestarts
[10:19:22.655]                           grepl <- base::grepl
[10:19:22.655]                           restarts <- computeRestarts(cond)
[10:19:22.655]                           for (restart in restarts) {
[10:19:22.655]                             name <- restart$name
[10:19:22.655]                             if (is.null(name)) 
[10:19:22.655]                               next
[10:19:22.655]                             if (!grepl(pattern, name)) 
[10:19:22.655]                               next
[10:19:22.655]                             invokeRestart(restart)
[10:19:22.655]                             muffled <- TRUE
[10:19:22.655]                             break
[10:19:22.655]                           }
[10:19:22.655]                         }
[10:19:22.655]                       }
[10:19:22.655]                       invisible(muffled)
[10:19:22.655]                     }
[10:19:22.655]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.655]                   }
[10:19:22.655]                 }
[10:19:22.655]             }
[10:19:22.655]         }))
[10:19:22.655]     }, error = function(ex) {
[10:19:22.655]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.655]                 ...future.rng), started = ...future.startTime, 
[10:19:22.655]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.655]             version = "1.8"), class = "FutureResult")
[10:19:22.655]     }, finally = {
[10:19:22.655]         if (!identical(...future.workdir, getwd())) 
[10:19:22.655]             setwd(...future.workdir)
[10:19:22.655]         {
[10:19:22.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.655]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.655]             }
[10:19:22.655]             base::options(...future.oldOptions)
[10:19:22.655]             if (.Platform$OS.type == "windows") {
[10:19:22.655]                 old_names <- names(...future.oldEnvVars)
[10:19:22.655]                 envs <- base::Sys.getenv()
[10:19:22.655]                 names <- names(envs)
[10:19:22.655]                 common <- intersect(names, old_names)
[10:19:22.655]                 added <- setdiff(names, old_names)
[10:19:22.655]                 removed <- setdiff(old_names, names)
[10:19:22.655]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.655]                   envs[common]]
[10:19:22.655]                 NAMES <- toupper(changed)
[10:19:22.655]                 args <- list()
[10:19:22.655]                 for (kk in seq_along(NAMES)) {
[10:19:22.655]                   name <- changed[[kk]]
[10:19:22.655]                   NAME <- NAMES[[kk]]
[10:19:22.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.655]                     next
[10:19:22.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.655]                 }
[10:19:22.655]                 NAMES <- toupper(added)
[10:19:22.655]                 for (kk in seq_along(NAMES)) {
[10:19:22.655]                   name <- added[[kk]]
[10:19:22.655]                   NAME <- NAMES[[kk]]
[10:19:22.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.655]                     next
[10:19:22.655]                   args[[name]] <- ""
[10:19:22.655]                 }
[10:19:22.655]                 NAMES <- toupper(removed)
[10:19:22.655]                 for (kk in seq_along(NAMES)) {
[10:19:22.655]                   name <- removed[[kk]]
[10:19:22.655]                   NAME <- NAMES[[kk]]
[10:19:22.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.655]                     next
[10:19:22.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.655]                 }
[10:19:22.655]                 if (length(args) > 0) 
[10:19:22.655]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.655]             }
[10:19:22.655]             else {
[10:19:22.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.655]             }
[10:19:22.655]             {
[10:19:22.655]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.655]                   0L) {
[10:19:22.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.655]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.655]                   base::options(opts)
[10:19:22.655]                 }
[10:19:22.655]                 {
[10:19:22.655]                   {
[10:19:22.655]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.655]                     NULL
[10:19:22.655]                   }
[10:19:22.655]                   options(future.plan = NULL)
[10:19:22.655]                   if (is.na(NA_character_)) 
[10:19:22.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.655]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.655]                     .init = FALSE)
[10:19:22.655]                 }
[10:19:22.655]             }
[10:19:22.655]         }
[10:19:22.655]     })
[10:19:22.655]     if (TRUE) {
[10:19:22.655]         base::sink(type = "output", split = FALSE)
[10:19:22.655]         if (TRUE) {
[10:19:22.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.655]         }
[10:19:22.655]         else {
[10:19:22.655]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.655]         }
[10:19:22.655]         base::close(...future.stdout)
[10:19:22.655]         ...future.stdout <- NULL
[10:19:22.655]     }
[10:19:22.655]     ...future.result$conditions <- ...future.conditions
[10:19:22.655]     ...future.result$finished <- base::Sys.time()
[10:19:22.655]     ...future.result
[10:19:22.655] }
[10:19:22.658] assign_globals() ...
[10:19:22.658] List of 5
[10:19:22.658]  $ ...future.FUN            :function (C, k)  
[10:19:22.658]  $ MoreArgs                 : list()
[10:19:22.658]  $ ...future.elements_ii    :List of 2
[10:19:22.658]   ..$ :List of 3
[10:19:22.658]   .. ..$ : chr "C"
[10:19:22.658]   .. ..$ : chr "D"
[10:19:22.658]   .. ..$ : chr "E"
[10:19:22.658]   ..$ :List of 3
[10:19:22.658]   .. ..$ : int 3
[10:19:22.658]   .. ..$ : int 2
[10:19:22.658]   .. ..$ : int 1
[10:19:22.658]  $ ...future.seeds_ii       : NULL
[10:19:22.658]  $ ...future.globals.maxSize: NULL
[10:19:22.658]  - attr(*, "where")=List of 5
[10:19:22.658]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.658]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.658]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.658]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.658]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.658]  - attr(*, "resolved")= logi FALSE
[10:19:22.658]  - attr(*, "total_size")= num 909
[10:19:22.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.658]  - attr(*, "already-done")= logi TRUE
[10:19:22.667] - reassign environment for ‘...future.FUN’
[10:19:22.667] - copied ‘...future.FUN’ to environment
[10:19:22.667] - copied ‘MoreArgs’ to environment
[10:19:22.667] - copied ‘...future.elements_ii’ to environment
[10:19:22.667] - copied ‘...future.seeds_ii’ to environment
[10:19:22.668] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.668] assign_globals() ... done
[10:19:22.668] requestCore(): workers = 2
[10:19:22.670] MulticoreFuture started
[10:19:22.670] - Launch lazy future ... done
[10:19:22.671] run() for ‘MulticoreFuture’ ... done
[10:19:22.671] Created future:
[10:19:22.671] plan(): Setting new future strategy stack:
[10:19:22.671] List of future strategies:
[10:19:22.671] 1. sequential:
[10:19:22.671]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.671]    - tweaked: FALSE
[10:19:22.671]    - call: NULL
[10:19:22.672] plan(): nbrOfWorkers() = 1
[10:19:22.675] plan(): Setting new future strategy stack:
[10:19:22.675] List of future strategies:
[10:19:22.675] 1. multicore:
[10:19:22.675]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.675]    - tweaked: FALSE
[10:19:22.675]    - call: plan(strategy)
[10:19:22.678] plan(): nbrOfWorkers() = 2
[10:19:22.671] MulticoreFuture:
[10:19:22.671] Label: ‘future_.mapply-2’
[10:19:22.671] Expression:
[10:19:22.671] {
[10:19:22.671]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.671]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.671]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.671]         on.exit(options(oopts), add = TRUE)
[10:19:22.671]     }
[10:19:22.671]     {
[10:19:22.671]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.671]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.671]         do.call(mapply, args = args)
[10:19:22.671]     }
[10:19:22.671] }
[10:19:22.671] Lazy evaluation: FALSE
[10:19:22.671] Asynchronous evaluation: TRUE
[10:19:22.671] Local evaluation: TRUE
[10:19:22.671] Environment: R_GlobalEnv
[10:19:22.671] Capture standard output: TRUE
[10:19:22.671] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.671] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.671] Packages: <none>
[10:19:22.671] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.671] Resolved: TRUE
[10:19:22.671] Value: <not collected>
[10:19:22.671] Conditions captured: <none>
[10:19:22.671] Early signaling: FALSE
[10:19:22.671] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.671] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.679] Chunk #2 of 2 ... DONE
[10:19:22.679] Launching 2 futures (chunks) ... DONE
[10:19:22.679] Resolving 2 futures (chunks) ...
[10:19:22.680] resolve() on list ...
[10:19:22.680]  recursive: 0
[10:19:22.680]  length: 2
[10:19:22.680] 
[10:19:22.680] Future #1
[10:19:22.681] result() for MulticoreFuture ...
[10:19:22.682] result() for MulticoreFuture ...
[10:19:22.682] result() for MulticoreFuture ... done
[10:19:22.682] result() for MulticoreFuture ... done
[10:19:22.682] result() for MulticoreFuture ...
[10:19:22.682] result() for MulticoreFuture ... done
[10:19:22.682] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:22.682] - nx: 2
[10:19:22.683] - relay: TRUE
[10:19:22.683] - stdout: TRUE
[10:19:22.683] - signal: TRUE
[10:19:22.683] - resignal: FALSE
[10:19:22.683] - force: TRUE
[10:19:22.683] - relayed: [n=2] FALSE, FALSE
[10:19:22.683] - queued futures: [n=2] FALSE, FALSE
[10:19:22.684]  - until=1
[10:19:22.684]  - relaying element #1
[10:19:22.684] result() for MulticoreFuture ...
[10:19:22.684] result() for MulticoreFuture ... done
[10:19:22.684] result() for MulticoreFuture ...
[10:19:22.684] result() for MulticoreFuture ... done
[10:19:22.685] result() for MulticoreFuture ...
[10:19:22.685] result() for MulticoreFuture ... done
[10:19:22.685] result() for MulticoreFuture ...
[10:19:22.685] result() for MulticoreFuture ... done
[10:19:22.685] - relayed: [n=2] TRUE, FALSE
[10:19:22.685] - queued futures: [n=2] TRUE, FALSE
[10:19:22.685] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:22.686]  length: 1 (resolved future 1)
[10:19:22.690] Future #2
[10:19:22.690] result() for MulticoreFuture ...
[10:19:22.691] result() for MulticoreFuture ...
[10:19:22.692] result() for MulticoreFuture ... done
[10:19:22.692] result() for MulticoreFuture ... done
[10:19:22.692] result() for MulticoreFuture ...
[10:19:22.692] result() for MulticoreFuture ... done
[10:19:22.693] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:22.693] - nx: 2
[10:19:22.693] - relay: TRUE
[10:19:22.693] - stdout: TRUE
[10:19:22.693] - signal: TRUE
[10:19:22.694] - resignal: FALSE
[10:19:22.694] - force: TRUE
[10:19:22.694] - relayed: [n=2] TRUE, FALSE
[10:19:22.694] - queued futures: [n=2] TRUE, FALSE
[10:19:22.694]  - until=2
[10:19:22.694]  - relaying element #2
[10:19:22.695] result() for MulticoreFuture ...
[10:19:22.695] result() for MulticoreFuture ... done
[10:19:22.695] result() for MulticoreFuture ...
[10:19:22.695] result() for MulticoreFuture ... done
[10:19:22.695] result() for MulticoreFuture ...
[10:19:22.695] result() for MulticoreFuture ... done
[10:19:22.695] result() for MulticoreFuture ...
[10:19:22.696] result() for MulticoreFuture ... done
[10:19:22.696] - relayed: [n=2] TRUE, TRUE
[10:19:22.696] - queued futures: [n=2] TRUE, TRUE
[10:19:22.696] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:22.696]  length: 0 (resolved future 2)
[10:19:22.696] Relaying remaining futures
[10:19:22.696] signalConditionsASAP(NULL, pos=0) ...
[10:19:22.697] - nx: 2
[10:19:22.697] - relay: TRUE
[10:19:22.697] - stdout: TRUE
[10:19:22.697] - signal: TRUE
[10:19:22.697] - resignal: FALSE
[10:19:22.697] - force: TRUE
[10:19:22.697] - relayed: [n=2] TRUE, TRUE
[10:19:22.697] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:22.698] - relayed: [n=2] TRUE, TRUE
[10:19:22.698] - queued futures: [n=2] TRUE, TRUE
[10:19:22.698] signalConditionsASAP(NULL, pos=0) ... done
[10:19:22.698] resolve() on list ... DONE
[10:19:22.698] result() for MulticoreFuture ...
[10:19:22.698] result() for MulticoreFuture ... done
[10:19:22.699] result() for MulticoreFuture ...
[10:19:22.699] result() for MulticoreFuture ... done
[10:19:22.699] result() for MulticoreFuture ...
[10:19:22.699] result() for MulticoreFuture ... done
[10:19:22.699] result() for MulticoreFuture ...
[10:19:22.699] result() for MulticoreFuture ... done
[10:19:22.699]  - Number of value chunks collected: 2
[10:19:22.699] Resolving 2 futures (chunks) ... DONE
[10:19:22.699] Reducing values from 2 chunks ...
[10:19:22.700]  - Number of values collected after concatenation: 5
[10:19:22.700]  - Number of values expected: 5
[10:19:22.700] Reducing values from 2 chunks ... DONE
[10:19:22.700] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[10:19:22.700] future_mapply() ...
[10:19:22.702] Number of chunks: 1
[10:19:22.702] getGlobalsAndPackagesXApply() ...
[10:19:22.702]  - future.globals: TRUE
[10:19:22.703] getGlobalsAndPackages() ...
[10:19:22.703] Searching for globals...
[10:19:22.704] - globals found: [1] ‘FUN’
[10:19:22.704] Searching for globals ... DONE
[10:19:22.704] Resolving globals: FALSE
[10:19:22.704] The total size of the 1 globals is 185 bytes (185 bytes)
[10:19:22.705] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:19:22.705] - globals: [1] ‘FUN’
[10:19:22.705] 
[10:19:22.705] getGlobalsAndPackages() ... DONE
[10:19:22.705]  - globals found/used: [n=1] ‘FUN’
[10:19:22.705]  - needed namespaces: [n=0] 
[10:19:22.705] Finding globals ... DONE
[10:19:22.706] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:22.706] List of 2
[10:19:22.706]  $ ...future.FUN:function (x)  
[10:19:22.706]  $ MoreArgs     : NULL
[10:19:22.706]  - attr(*, "where")=List of 2
[10:19:22.706]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:22.706]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:22.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.706]  - attr(*, "resolved")= logi FALSE
[10:19:22.706]  - attr(*, "total_size")= num NA
[10:19:22.709] Packages to be attached in all futures: [n=0] 
[10:19:22.709] getGlobalsAndPackagesXApply() ... DONE
[10:19:22.709] Number of futures (= number of chunks): 1
[10:19:22.709] Launching 1 futures (chunks) ...
[10:19:22.709] Chunk #1 of 1 ...
[10:19:22.709]  - Finding globals in '...' for chunk #1 ...
[10:19:22.709] getGlobalsAndPackages() ...
[10:19:22.709] Searching for globals...
[10:19:22.710] 
[10:19:22.710] Searching for globals ... DONE
[10:19:22.710] - globals: [0] <none>
[10:19:22.710] getGlobalsAndPackages() ... DONE
[10:19:22.710]    + additional globals found: [n=0] 
[10:19:22.710]    + additional namespaces needed: [n=0] 
[10:19:22.710]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:22.710]  - seeds: <none>
[10:19:22.710]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.711] getGlobalsAndPackages() ...
[10:19:22.711] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.711] Resolving globals: FALSE
[10:19:22.711] The total size of the 5 globals is 366 bytes (366 bytes)
[10:19:22.712] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 366 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:22.712] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.712] 
[10:19:22.712] getGlobalsAndPackages() ... DONE
[10:19:22.712] run() for ‘Future’ ...
[10:19:22.712] - state: ‘created’
[10:19:22.713] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.717] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.717]   - Field: ‘label’
[10:19:22.717]   - Field: ‘local’
[10:19:22.717]   - Field: ‘owner’
[10:19:22.717]   - Field: ‘envir’
[10:19:22.717]   - Field: ‘workers’
[10:19:22.717]   - Field: ‘packages’
[10:19:22.717]   - Field: ‘gc’
[10:19:22.718]   - Field: ‘job’
[10:19:22.718]   - Field: ‘conditions’
[10:19:22.718]   - Field: ‘expr’
[10:19:22.718]   - Field: ‘uuid’
[10:19:22.718]   - Field: ‘seed’
[10:19:22.718]   - Field: ‘version’
[10:19:22.718]   - Field: ‘result’
[10:19:22.718]   - Field: ‘asynchronous’
[10:19:22.718]   - Field: ‘calls’
[10:19:22.718]   - Field: ‘globals’
[10:19:22.718]   - Field: ‘stdout’
[10:19:22.719]   - Field: ‘earlySignal’
[10:19:22.719]   - Field: ‘lazy’
[10:19:22.719]   - Field: ‘state’
[10:19:22.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.719] - Launch lazy future ...
[10:19:22.719] Packages needed by the future expression (n = 0): <none>
[10:19:22.719] Packages needed by future strategies (n = 0): <none>
[10:19:22.720] {
[10:19:22.720]     {
[10:19:22.720]         {
[10:19:22.720]             ...future.startTime <- base::Sys.time()
[10:19:22.720]             {
[10:19:22.720]                 {
[10:19:22.720]                   {
[10:19:22.720]                     {
[10:19:22.720]                       base::local({
[10:19:22.720]                         has_future <- base::requireNamespace("future", 
[10:19:22.720]                           quietly = TRUE)
[10:19:22.720]                         if (has_future) {
[10:19:22.720]                           ns <- base::getNamespace("future")
[10:19:22.720]                           version <- ns[[".package"]][["version"]]
[10:19:22.720]                           if (is.null(version)) 
[10:19:22.720]                             version <- utils::packageVersion("future")
[10:19:22.720]                         }
[10:19:22.720]                         else {
[10:19:22.720]                           version <- NULL
[10:19:22.720]                         }
[10:19:22.720]                         if (!has_future || version < "1.8.0") {
[10:19:22.720]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.720]                             "", base::R.version$version.string), 
[10:19:22.720]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.720]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.720]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.720]                               "release", "version")], collapse = " "), 
[10:19:22.720]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.720]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.720]                             info)
[10:19:22.720]                           info <- base::paste(info, collapse = "; ")
[10:19:22.720]                           if (!has_future) {
[10:19:22.720]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.720]                               info)
[10:19:22.720]                           }
[10:19:22.720]                           else {
[10:19:22.720]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.720]                               info, version)
[10:19:22.720]                           }
[10:19:22.720]                           base::stop(msg)
[10:19:22.720]                         }
[10:19:22.720]                       })
[10:19:22.720]                     }
[10:19:22.720]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.720]                     base::options(mc.cores = 1L)
[10:19:22.720]                   }
[10:19:22.720]                   ...future.strategy.old <- future::plan("list")
[10:19:22.720]                   options(future.plan = NULL)
[10:19:22.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.720]                 }
[10:19:22.720]                 ...future.workdir <- getwd()
[10:19:22.720]             }
[10:19:22.720]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.720]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.720]         }
[10:19:22.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.720]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:22.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.720]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.720]             base::names(...future.oldOptions))
[10:19:22.720]     }
[10:19:22.720]     if (FALSE) {
[10:19:22.720]     }
[10:19:22.720]     else {
[10:19:22.720]         if (TRUE) {
[10:19:22.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.720]                 open = "w")
[10:19:22.720]         }
[10:19:22.720]         else {
[10:19:22.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.720]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.720]         }
[10:19:22.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.720]             base::sink(type = "output", split = FALSE)
[10:19:22.720]             base::close(...future.stdout)
[10:19:22.720]         }, add = TRUE)
[10:19:22.720]     }
[10:19:22.720]     ...future.frame <- base::sys.nframe()
[10:19:22.720]     ...future.conditions <- base::list()
[10:19:22.720]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.720]     if (FALSE) {
[10:19:22.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.720]     }
[10:19:22.720]     ...future.result <- base::tryCatch({
[10:19:22.720]         base::withCallingHandlers({
[10:19:22.720]             ...future.value <- base::withVisible(base::local({
[10:19:22.720]                 withCallingHandlers({
[10:19:22.720]                   {
[10:19:22.720]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.720]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.720]                       ...future.globals.maxSize)) {
[10:19:22.720]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.720]                       on.exit(options(oopts), add = TRUE)
[10:19:22.720]                     }
[10:19:22.720]                     {
[10:19:22.720]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.720]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.720]                         USE.NAMES = FALSE)
[10:19:22.720]                       do.call(mapply, args = args)
[10:19:22.720]                     }
[10:19:22.720]                   }
[10:19:22.720]                 }, immediateCondition = function(cond) {
[10:19:22.720]                   save_rds <- function (object, pathname, ...) 
[10:19:22.720]                   {
[10:19:22.720]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.720]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.720]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.720]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.720]                         fi_tmp[["mtime"]])
[10:19:22.720]                     }
[10:19:22.720]                     tryCatch({
[10:19:22.720]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.720]                     }, error = function(ex) {
[10:19:22.720]                       msg <- conditionMessage(ex)
[10:19:22.720]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.720]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.720]                         fi_tmp[["mtime"]], msg)
[10:19:22.720]                       ex$message <- msg
[10:19:22.720]                       stop(ex)
[10:19:22.720]                     })
[10:19:22.720]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.720]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.720]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.720]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.720]                       fi <- file.info(pathname)
[10:19:22.720]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.720]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.720]                         fi[["size"]], fi[["mtime"]])
[10:19:22.720]                       stop(msg)
[10:19:22.720]                     }
[10:19:22.720]                     invisible(pathname)
[10:19:22.720]                   }
[10:19:22.720]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.720]                     rootPath = tempdir()) 
[10:19:22.720]                   {
[10:19:22.720]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.720]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.720]                       tmpdir = path, fileext = ".rds")
[10:19:22.720]                     save_rds(obj, file)
[10:19:22.720]                   }
[10:19:22.720]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.720]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.720]                   {
[10:19:22.720]                     inherits <- base::inherits
[10:19:22.720]                     invokeRestart <- base::invokeRestart
[10:19:22.720]                     is.null <- base::is.null
[10:19:22.720]                     muffled <- FALSE
[10:19:22.720]                     if (inherits(cond, "message")) {
[10:19:22.720]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.720]                       if (muffled) 
[10:19:22.720]                         invokeRestart("muffleMessage")
[10:19:22.720]                     }
[10:19:22.720]                     else if (inherits(cond, "warning")) {
[10:19:22.720]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.720]                       if (muffled) 
[10:19:22.720]                         invokeRestart("muffleWarning")
[10:19:22.720]                     }
[10:19:22.720]                     else if (inherits(cond, "condition")) {
[10:19:22.720]                       if (!is.null(pattern)) {
[10:19:22.720]                         computeRestarts <- base::computeRestarts
[10:19:22.720]                         grepl <- base::grepl
[10:19:22.720]                         restarts <- computeRestarts(cond)
[10:19:22.720]                         for (restart in restarts) {
[10:19:22.720]                           name <- restart$name
[10:19:22.720]                           if (is.null(name)) 
[10:19:22.720]                             next
[10:19:22.720]                           if (!grepl(pattern, name)) 
[10:19:22.720]                             next
[10:19:22.720]                           invokeRestart(restart)
[10:19:22.720]                           muffled <- TRUE
[10:19:22.720]                           break
[10:19:22.720]                         }
[10:19:22.720]                       }
[10:19:22.720]                     }
[10:19:22.720]                     invisible(muffled)
[10:19:22.720]                   }
[10:19:22.720]                   muffleCondition(cond)
[10:19:22.720]                 })
[10:19:22.720]             }))
[10:19:22.720]             future::FutureResult(value = ...future.value$value, 
[10:19:22.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.720]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.720]                     ...future.globalenv.names))
[10:19:22.720]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.720]         }, condition = base::local({
[10:19:22.720]             c <- base::c
[10:19:22.720]             inherits <- base::inherits
[10:19:22.720]             invokeRestart <- base::invokeRestart
[10:19:22.720]             length <- base::length
[10:19:22.720]             list <- base::list
[10:19:22.720]             seq.int <- base::seq.int
[10:19:22.720]             signalCondition <- base::signalCondition
[10:19:22.720]             sys.calls <- base::sys.calls
[10:19:22.720]             `[[` <- base::`[[`
[10:19:22.720]             `+` <- base::`+`
[10:19:22.720]             `<<-` <- base::`<<-`
[10:19:22.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.720]                   3L)]
[10:19:22.720]             }
[10:19:22.720]             function(cond) {
[10:19:22.720]                 is_error <- inherits(cond, "error")
[10:19:22.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.720]                   NULL)
[10:19:22.720]                 if (is_error) {
[10:19:22.720]                   sessionInformation <- function() {
[10:19:22.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.720]                       search = base::search(), system = base::Sys.info())
[10:19:22.720]                   }
[10:19:22.720]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.720]                     cond$call), session = sessionInformation(), 
[10:19:22.720]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.720]                   signalCondition(cond)
[10:19:22.720]                 }
[10:19:22.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.720]                 "immediateCondition"))) {
[10:19:22.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.720]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.720]                   if (TRUE && !signal) {
[10:19:22.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.720]                     {
[10:19:22.720]                       inherits <- base::inherits
[10:19:22.720]                       invokeRestart <- base::invokeRestart
[10:19:22.720]                       is.null <- base::is.null
[10:19:22.720]                       muffled <- FALSE
[10:19:22.720]                       if (inherits(cond, "message")) {
[10:19:22.720]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.720]                         if (muffled) 
[10:19:22.720]                           invokeRestart("muffleMessage")
[10:19:22.720]                       }
[10:19:22.720]                       else if (inherits(cond, "warning")) {
[10:19:22.720]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.720]                         if (muffled) 
[10:19:22.720]                           invokeRestart("muffleWarning")
[10:19:22.720]                       }
[10:19:22.720]                       else if (inherits(cond, "condition")) {
[10:19:22.720]                         if (!is.null(pattern)) {
[10:19:22.720]                           computeRestarts <- base::computeRestarts
[10:19:22.720]                           grepl <- base::grepl
[10:19:22.720]                           restarts <- computeRestarts(cond)
[10:19:22.720]                           for (restart in restarts) {
[10:19:22.720]                             name <- restart$name
[10:19:22.720]                             if (is.null(name)) 
[10:19:22.720]                               next
[10:19:22.720]                             if (!grepl(pattern, name)) 
[10:19:22.720]                               next
[10:19:22.720]                             invokeRestart(restart)
[10:19:22.720]                             muffled <- TRUE
[10:19:22.720]                             break
[10:19:22.720]                           }
[10:19:22.720]                         }
[10:19:22.720]                       }
[10:19:22.720]                       invisible(muffled)
[10:19:22.720]                     }
[10:19:22.720]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.720]                   }
[10:19:22.720]                 }
[10:19:22.720]                 else {
[10:19:22.720]                   if (TRUE) {
[10:19:22.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.720]                     {
[10:19:22.720]                       inherits <- base::inherits
[10:19:22.720]                       invokeRestart <- base::invokeRestart
[10:19:22.720]                       is.null <- base::is.null
[10:19:22.720]                       muffled <- FALSE
[10:19:22.720]                       if (inherits(cond, "message")) {
[10:19:22.720]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.720]                         if (muffled) 
[10:19:22.720]                           invokeRestart("muffleMessage")
[10:19:22.720]                       }
[10:19:22.720]                       else if (inherits(cond, "warning")) {
[10:19:22.720]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.720]                         if (muffled) 
[10:19:22.720]                           invokeRestart("muffleWarning")
[10:19:22.720]                       }
[10:19:22.720]                       else if (inherits(cond, "condition")) {
[10:19:22.720]                         if (!is.null(pattern)) {
[10:19:22.720]                           computeRestarts <- base::computeRestarts
[10:19:22.720]                           grepl <- base::grepl
[10:19:22.720]                           restarts <- computeRestarts(cond)
[10:19:22.720]                           for (restart in restarts) {
[10:19:22.720]                             name <- restart$name
[10:19:22.720]                             if (is.null(name)) 
[10:19:22.720]                               next
[10:19:22.720]                             if (!grepl(pattern, name)) 
[10:19:22.720]                               next
[10:19:22.720]                             invokeRestart(restart)
[10:19:22.720]                             muffled <- TRUE
[10:19:22.720]                             break
[10:19:22.720]                           }
[10:19:22.720]                         }
[10:19:22.720]                       }
[10:19:22.720]                       invisible(muffled)
[10:19:22.720]                     }
[10:19:22.720]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.720]                   }
[10:19:22.720]                 }
[10:19:22.720]             }
[10:19:22.720]         }))
[10:19:22.720]     }, error = function(ex) {
[10:19:22.720]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.720]                 ...future.rng), started = ...future.startTime, 
[10:19:22.720]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.720]             version = "1.8"), class = "FutureResult")
[10:19:22.720]     }, finally = {
[10:19:22.720]         if (!identical(...future.workdir, getwd())) 
[10:19:22.720]             setwd(...future.workdir)
[10:19:22.720]         {
[10:19:22.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.720]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.720]             }
[10:19:22.720]             base::options(...future.oldOptions)
[10:19:22.720]             if (.Platform$OS.type == "windows") {
[10:19:22.720]                 old_names <- names(...future.oldEnvVars)
[10:19:22.720]                 envs <- base::Sys.getenv()
[10:19:22.720]                 names <- names(envs)
[10:19:22.720]                 common <- intersect(names, old_names)
[10:19:22.720]                 added <- setdiff(names, old_names)
[10:19:22.720]                 removed <- setdiff(old_names, names)
[10:19:22.720]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.720]                   envs[common]]
[10:19:22.720]                 NAMES <- toupper(changed)
[10:19:22.720]                 args <- list()
[10:19:22.720]                 for (kk in seq_along(NAMES)) {
[10:19:22.720]                   name <- changed[[kk]]
[10:19:22.720]                   NAME <- NAMES[[kk]]
[10:19:22.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.720]                     next
[10:19:22.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.720]                 }
[10:19:22.720]                 NAMES <- toupper(added)
[10:19:22.720]                 for (kk in seq_along(NAMES)) {
[10:19:22.720]                   name <- added[[kk]]
[10:19:22.720]                   NAME <- NAMES[[kk]]
[10:19:22.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.720]                     next
[10:19:22.720]                   args[[name]] <- ""
[10:19:22.720]                 }
[10:19:22.720]                 NAMES <- toupper(removed)
[10:19:22.720]                 for (kk in seq_along(NAMES)) {
[10:19:22.720]                   name <- removed[[kk]]
[10:19:22.720]                   NAME <- NAMES[[kk]]
[10:19:22.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.720]                     next
[10:19:22.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.720]                 }
[10:19:22.720]                 if (length(args) > 0) 
[10:19:22.720]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.720]             }
[10:19:22.720]             else {
[10:19:22.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.720]             }
[10:19:22.720]             {
[10:19:22.720]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.720]                   0L) {
[10:19:22.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.720]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.720]                   base::options(opts)
[10:19:22.720]                 }
[10:19:22.720]                 {
[10:19:22.720]                   {
[10:19:22.720]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.720]                     NULL
[10:19:22.720]                   }
[10:19:22.720]                   options(future.plan = NULL)
[10:19:22.720]                   if (is.na(NA_character_)) 
[10:19:22.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.720]                     .init = FALSE)
[10:19:22.720]                 }
[10:19:22.720]             }
[10:19:22.720]         }
[10:19:22.720]     })
[10:19:22.720]     if (TRUE) {
[10:19:22.720]         base::sink(type = "output", split = FALSE)
[10:19:22.720]         if (TRUE) {
[10:19:22.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.720]         }
[10:19:22.720]         else {
[10:19:22.720]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.720]         }
[10:19:22.720]         base::close(...future.stdout)
[10:19:22.720]         ...future.stdout <- NULL
[10:19:22.720]     }
[10:19:22.720]     ...future.result$conditions <- ...future.conditions
[10:19:22.720]     ...future.result$finished <- base::Sys.time()
[10:19:22.720]     ...future.result
[10:19:22.720] }
[10:19:22.722] assign_globals() ...
[10:19:22.723] List of 5
[10:19:22.723]  $ ...future.FUN            :function (x)  
[10:19:22.723]  $ MoreArgs                 : NULL
[10:19:22.723]  $ ...future.elements_ii    :List of 1
[10:19:22.723]   ..$ :List of 1
[10:19:22.723]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:19:22.723]  $ ...future.seeds_ii       : NULL
[10:19:22.723]  $ ...future.globals.maxSize: NULL
[10:19:22.723]  - attr(*, "where")=List of 5
[10:19:22.723]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.723]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.723]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.723]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.723]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.723]  - attr(*, "resolved")= logi FALSE
[10:19:22.723]  - attr(*, "total_size")= num 366
[10:19:22.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.723]  - attr(*, "already-done")= logi TRUE
[10:19:22.727] - copied ‘...future.FUN’ to environment
[10:19:22.727] - copied ‘MoreArgs’ to environment
[10:19:22.727] - copied ‘...future.elements_ii’ to environment
[10:19:22.727] - copied ‘...future.seeds_ii’ to environment
[10:19:22.728] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.728] assign_globals() ... done
[10:19:22.728] requestCore(): workers = 2
[10:19:22.730] MulticoreFuture started
[10:19:22.730] - Launch lazy future ... done
[10:19:22.731] run() for ‘MulticoreFuture’ ... done
[10:19:22.731] Created future:
[10:19:22.731] plan(): Setting new future strategy stack:
[10:19:22.731] List of future strategies:
[10:19:22.731] 1. sequential:
[10:19:22.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.731]    - tweaked: FALSE
[10:19:22.731]    - call: NULL
[10:19:22.732] plan(): nbrOfWorkers() = 1
[10:19:22.734] plan(): Setting new future strategy stack:
[10:19:22.735] List of future strategies:
[10:19:22.735] 1. multicore:
[10:19:22.735]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.735]    - tweaked: FALSE
[10:19:22.735]    - call: plan(strategy)
[10:19:22.738] plan(): nbrOfWorkers() = 2
[10:19:22.731] MulticoreFuture:
[10:19:22.731] Label: ‘future_mapply-1’
[10:19:22.731] Expression:
[10:19:22.731] {
[10:19:22.731]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.731]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.731]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.731]         on.exit(options(oopts), add = TRUE)
[10:19:22.731]     }
[10:19:22.731]     {
[10:19:22.731]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.731]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.731]         do.call(mapply, args = args)
[10:19:22.731]     }
[10:19:22.731] }
[10:19:22.731] Lazy evaluation: FALSE
[10:19:22.731] Asynchronous evaluation: TRUE
[10:19:22.731] Local evaluation: TRUE
[10:19:22.731] Environment: R_GlobalEnv
[10:19:22.731] Capture standard output: TRUE
[10:19:22.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.731] Globals: 5 objects totaling 366 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.731] Packages: <none>
[10:19:22.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.731] Resolved: TRUE
[10:19:22.731] Value: <not collected>
[10:19:22.731] Conditions captured: <none>
[10:19:22.731] Early signaling: FALSE
[10:19:22.731] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.731] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.739] Chunk #1 of 1 ... DONE
[10:19:22.739] Launching 1 futures (chunks) ... DONE
[10:19:22.739] Resolving 1 futures (chunks) ...
[10:19:22.739] resolve() on list ...
[10:19:22.739]  recursive: 0
[10:19:22.740]  length: 1
[10:19:22.740] 
[10:19:22.740] Future #1
[10:19:22.740] result() for MulticoreFuture ...
[10:19:22.741] result() for MulticoreFuture ...
[10:19:22.741] result() for MulticoreFuture ... done
[10:19:22.741] result() for MulticoreFuture ... done
[10:19:22.742] result() for MulticoreFuture ...
[10:19:22.742] result() for MulticoreFuture ... done
[10:19:22.742] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:22.742] - nx: 1
[10:19:22.742] - relay: TRUE
[10:19:22.742] - stdout: TRUE
[10:19:22.742] - signal: TRUE
[10:19:22.743] - resignal: FALSE
[10:19:22.743] - force: TRUE
[10:19:22.743] - relayed: [n=1] FALSE
[10:19:22.743] - queued futures: [n=1] FALSE
[10:19:22.743]  - until=1
[10:19:22.743]  - relaying element #1
[10:19:22.743] result() for MulticoreFuture ...
[10:19:22.743] result() for MulticoreFuture ... done
[10:19:22.744] result() for MulticoreFuture ...
[10:19:22.744] result() for MulticoreFuture ... done
[10:19:22.744] result() for MulticoreFuture ...
[10:19:22.744] result() for MulticoreFuture ... done
[10:19:22.744] result() for MulticoreFuture ...
[10:19:22.744] result() for MulticoreFuture ... done
[10:19:22.744] - relayed: [n=1] TRUE
[10:19:22.744] - queued futures: [n=1] TRUE
[10:19:22.745] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:22.745]  length: 0 (resolved future 1)
[10:19:22.745] Relaying remaining futures
[10:19:22.745] signalConditionsASAP(NULL, pos=0) ...
[10:19:22.745] - nx: 1
[10:19:22.745] - relay: TRUE
[10:19:22.745] - stdout: TRUE
[10:19:22.745] - signal: TRUE
[10:19:22.745] - resignal: FALSE
[10:19:22.746] - force: TRUE
[10:19:22.746] - relayed: [n=1] TRUE
[10:19:22.746] - queued futures: [n=1] TRUE
 - flush all
[10:19:22.746] - relayed: [n=1] TRUE
[10:19:22.746] - queued futures: [n=1] TRUE
[10:19:22.746] signalConditionsASAP(NULL, pos=0) ... done
[10:19:22.746] resolve() on list ... DONE
[10:19:22.746] result() for MulticoreFuture ...
[10:19:22.747] result() for MulticoreFuture ... done
[10:19:22.747] result() for MulticoreFuture ...
[10:19:22.747] result() for MulticoreFuture ... done
[10:19:22.747]  - Number of value chunks collected: 1
[10:19:22.747] Resolving 1 futures (chunks) ... DONE
[10:19:22.747] Reducing values from 1 chunks ...
[10:19:22.747]  - Number of values collected after concatenation: 1
[10:19:22.747]  - Number of values expected: 1
[10:19:22.747] Reducing values from 1 chunks ... DONE
[10:19:22.748] future_mapply() ... DONE
[10:19:22.753] future_mapply() ...
[10:19:22.755] Number of chunks: 1
[10:19:22.755] getGlobalsAndPackagesXApply() ...
[10:19:22.755]  - future.globals: TRUE
[10:19:22.756] getGlobalsAndPackages() ...
[10:19:22.756] Searching for globals...
[10:19:22.757] - globals found: [1] ‘FUN’
[10:19:22.757] Searching for globals ... DONE
[10:19:22.758] Resolving globals: FALSE
[10:19:22.758] The total size of the 1 globals is 185 bytes (185 bytes)
[10:19:22.758] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:19:22.759] - globals: [1] ‘FUN’
[10:19:22.759] 
[10:19:22.759] getGlobalsAndPackages() ... DONE
[10:19:22.759]  - globals found/used: [n=1] ‘FUN’
[10:19:22.759]  - needed namespaces: [n=0] 
[10:19:22.759] Finding globals ... DONE
[10:19:22.759] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:22.760] List of 2
[10:19:22.760]  $ ...future.FUN:function (x)  
[10:19:22.760]  $ MoreArgs     : list()
[10:19:22.760]  - attr(*, "where")=List of 2
[10:19:22.760]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:22.760]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:22.760]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.760]  - attr(*, "resolved")= logi FALSE
[10:19:22.760]  - attr(*, "total_size")= num NA
[10:19:22.763] Packages to be attached in all futures: [n=0] 
[10:19:22.763] getGlobalsAndPackagesXApply() ... DONE
[10:19:22.763] Number of futures (= number of chunks): 1
[10:19:22.764] Launching 1 futures (chunks) ...
[10:19:22.764] Chunk #1 of 1 ...
[10:19:22.764]  - Finding globals in '...' for chunk #1 ...
[10:19:22.764] getGlobalsAndPackages() ...
[10:19:22.764] Searching for globals...
[10:19:22.764] 
[10:19:22.765] Searching for globals ... DONE
[10:19:22.765] - globals: [0] <none>
[10:19:22.765] getGlobalsAndPackages() ... DONE
[10:19:22.765]    + additional globals found: [n=0] 
[10:19:22.765]    + additional namespaces needed: [n=0] 
[10:19:22.765]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:22.765]  - seeds: <none>
[10:19:22.765]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.765] getGlobalsAndPackages() ...
[10:19:22.765] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.766] Resolving globals: FALSE
[10:19:22.766] The total size of the 5 globals is 370 bytes (370 bytes)
[10:19:22.767] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 370 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:22.767] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.767] 
[10:19:22.767] getGlobalsAndPackages() ... DONE
[10:19:22.767] run() for ‘Future’ ...
[10:19:22.767] - state: ‘created’
[10:19:22.767] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.769] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.769]   - Field: ‘label’
[10:19:22.770]   - Field: ‘local’
[10:19:22.770]   - Field: ‘owner’
[10:19:22.770]   - Field: ‘envir’
[10:19:22.770]   - Field: ‘workers’
[10:19:22.770]   - Field: ‘packages’
[10:19:22.770]   - Field: ‘gc’
[10:19:22.770]   - Field: ‘job’
[10:19:22.770]   - Field: ‘conditions’
[10:19:22.770]   - Field: ‘expr’
[10:19:22.770]   - Field: ‘uuid’
[10:19:22.770]   - Field: ‘seed’
[10:19:22.771]   - Field: ‘version’
[10:19:22.771]   - Field: ‘result’
[10:19:22.771]   - Field: ‘asynchronous’
[10:19:22.771]   - Field: ‘calls’
[10:19:22.771]   - Field: ‘globals’
[10:19:22.771]   - Field: ‘stdout’
[10:19:22.771]   - Field: ‘earlySignal’
[10:19:22.771]   - Field: ‘lazy’
[10:19:22.771]   - Field: ‘state’
[10:19:22.771] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.771] - Launch lazy future ...
[10:19:22.772] Packages needed by the future expression (n = 0): <none>
[10:19:22.772] Packages needed by future strategies (n = 0): <none>
[10:19:22.772] {
[10:19:22.772]     {
[10:19:22.772]         {
[10:19:22.772]             ...future.startTime <- base::Sys.time()
[10:19:22.772]             {
[10:19:22.772]                 {
[10:19:22.772]                   {
[10:19:22.772]                     {
[10:19:22.772]                       base::local({
[10:19:22.772]                         has_future <- base::requireNamespace("future", 
[10:19:22.772]                           quietly = TRUE)
[10:19:22.772]                         if (has_future) {
[10:19:22.772]                           ns <- base::getNamespace("future")
[10:19:22.772]                           version <- ns[[".package"]][["version"]]
[10:19:22.772]                           if (is.null(version)) 
[10:19:22.772]                             version <- utils::packageVersion("future")
[10:19:22.772]                         }
[10:19:22.772]                         else {
[10:19:22.772]                           version <- NULL
[10:19:22.772]                         }
[10:19:22.772]                         if (!has_future || version < "1.8.0") {
[10:19:22.772]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.772]                             "", base::R.version$version.string), 
[10:19:22.772]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.772]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.772]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.772]                               "release", "version")], collapse = " "), 
[10:19:22.772]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.772]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.772]                             info)
[10:19:22.772]                           info <- base::paste(info, collapse = "; ")
[10:19:22.772]                           if (!has_future) {
[10:19:22.772]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.772]                               info)
[10:19:22.772]                           }
[10:19:22.772]                           else {
[10:19:22.772]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.772]                               info, version)
[10:19:22.772]                           }
[10:19:22.772]                           base::stop(msg)
[10:19:22.772]                         }
[10:19:22.772]                       })
[10:19:22.772]                     }
[10:19:22.772]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.772]                     base::options(mc.cores = 1L)
[10:19:22.772]                   }
[10:19:22.772]                   ...future.strategy.old <- future::plan("list")
[10:19:22.772]                   options(future.plan = NULL)
[10:19:22.772]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.772]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.772]                 }
[10:19:22.772]                 ...future.workdir <- getwd()
[10:19:22.772]             }
[10:19:22.772]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.772]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.772]         }
[10:19:22.772]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.772]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:22.772]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.772]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.772]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.772]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.772]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.772]             base::names(...future.oldOptions))
[10:19:22.772]     }
[10:19:22.772]     if (FALSE) {
[10:19:22.772]     }
[10:19:22.772]     else {
[10:19:22.772]         if (TRUE) {
[10:19:22.772]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.772]                 open = "w")
[10:19:22.772]         }
[10:19:22.772]         else {
[10:19:22.772]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.772]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.772]         }
[10:19:22.772]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.772]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.772]             base::sink(type = "output", split = FALSE)
[10:19:22.772]             base::close(...future.stdout)
[10:19:22.772]         }, add = TRUE)
[10:19:22.772]     }
[10:19:22.772]     ...future.frame <- base::sys.nframe()
[10:19:22.772]     ...future.conditions <- base::list()
[10:19:22.772]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.772]     if (FALSE) {
[10:19:22.772]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.772]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.772]     }
[10:19:22.772]     ...future.result <- base::tryCatch({
[10:19:22.772]         base::withCallingHandlers({
[10:19:22.772]             ...future.value <- base::withVisible(base::local({
[10:19:22.772]                 withCallingHandlers({
[10:19:22.772]                   {
[10:19:22.772]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.772]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.772]                       ...future.globals.maxSize)) {
[10:19:22.772]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.772]                       on.exit(options(oopts), add = TRUE)
[10:19:22.772]                     }
[10:19:22.772]                     {
[10:19:22.772]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.772]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.772]                         USE.NAMES = FALSE)
[10:19:22.772]                       do.call(mapply, args = args)
[10:19:22.772]                     }
[10:19:22.772]                   }
[10:19:22.772]                 }, immediateCondition = function(cond) {
[10:19:22.772]                   save_rds <- function (object, pathname, ...) 
[10:19:22.772]                   {
[10:19:22.772]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.772]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.772]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.772]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.772]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.772]                         fi_tmp[["mtime"]])
[10:19:22.772]                     }
[10:19:22.772]                     tryCatch({
[10:19:22.772]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.772]                     }, error = function(ex) {
[10:19:22.772]                       msg <- conditionMessage(ex)
[10:19:22.772]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.772]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.772]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.772]                         fi_tmp[["mtime"]], msg)
[10:19:22.772]                       ex$message <- msg
[10:19:22.772]                       stop(ex)
[10:19:22.772]                     })
[10:19:22.772]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.772]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.772]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.772]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.772]                       fi <- file.info(pathname)
[10:19:22.772]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.772]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.772]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.772]                         fi[["size"]], fi[["mtime"]])
[10:19:22.772]                       stop(msg)
[10:19:22.772]                     }
[10:19:22.772]                     invisible(pathname)
[10:19:22.772]                   }
[10:19:22.772]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.772]                     rootPath = tempdir()) 
[10:19:22.772]                   {
[10:19:22.772]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.772]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.772]                       tmpdir = path, fileext = ".rds")
[10:19:22.772]                     save_rds(obj, file)
[10:19:22.772]                   }
[10:19:22.772]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.772]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.772]                   {
[10:19:22.772]                     inherits <- base::inherits
[10:19:22.772]                     invokeRestart <- base::invokeRestart
[10:19:22.772]                     is.null <- base::is.null
[10:19:22.772]                     muffled <- FALSE
[10:19:22.772]                     if (inherits(cond, "message")) {
[10:19:22.772]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.772]                       if (muffled) 
[10:19:22.772]                         invokeRestart("muffleMessage")
[10:19:22.772]                     }
[10:19:22.772]                     else if (inherits(cond, "warning")) {
[10:19:22.772]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.772]                       if (muffled) 
[10:19:22.772]                         invokeRestart("muffleWarning")
[10:19:22.772]                     }
[10:19:22.772]                     else if (inherits(cond, "condition")) {
[10:19:22.772]                       if (!is.null(pattern)) {
[10:19:22.772]                         computeRestarts <- base::computeRestarts
[10:19:22.772]                         grepl <- base::grepl
[10:19:22.772]                         restarts <- computeRestarts(cond)
[10:19:22.772]                         for (restart in restarts) {
[10:19:22.772]                           name <- restart$name
[10:19:22.772]                           if (is.null(name)) 
[10:19:22.772]                             next
[10:19:22.772]                           if (!grepl(pattern, name)) 
[10:19:22.772]                             next
[10:19:22.772]                           invokeRestart(restart)
[10:19:22.772]                           muffled <- TRUE
[10:19:22.772]                           break
[10:19:22.772]                         }
[10:19:22.772]                       }
[10:19:22.772]                     }
[10:19:22.772]                     invisible(muffled)
[10:19:22.772]                   }
[10:19:22.772]                   muffleCondition(cond)
[10:19:22.772]                 })
[10:19:22.772]             }))
[10:19:22.772]             future::FutureResult(value = ...future.value$value, 
[10:19:22.772]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.772]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.772]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.772]                     ...future.globalenv.names))
[10:19:22.772]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.772]         }, condition = base::local({
[10:19:22.772]             c <- base::c
[10:19:22.772]             inherits <- base::inherits
[10:19:22.772]             invokeRestart <- base::invokeRestart
[10:19:22.772]             length <- base::length
[10:19:22.772]             list <- base::list
[10:19:22.772]             seq.int <- base::seq.int
[10:19:22.772]             signalCondition <- base::signalCondition
[10:19:22.772]             sys.calls <- base::sys.calls
[10:19:22.772]             `[[` <- base::`[[`
[10:19:22.772]             `+` <- base::`+`
[10:19:22.772]             `<<-` <- base::`<<-`
[10:19:22.772]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.772]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.772]                   3L)]
[10:19:22.772]             }
[10:19:22.772]             function(cond) {
[10:19:22.772]                 is_error <- inherits(cond, "error")
[10:19:22.772]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.772]                   NULL)
[10:19:22.772]                 if (is_error) {
[10:19:22.772]                   sessionInformation <- function() {
[10:19:22.772]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.772]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.772]                       search = base::search(), system = base::Sys.info())
[10:19:22.772]                   }
[10:19:22.772]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.772]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.772]                     cond$call), session = sessionInformation(), 
[10:19:22.772]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.772]                   signalCondition(cond)
[10:19:22.772]                 }
[10:19:22.772]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.772]                 "immediateCondition"))) {
[10:19:22.772]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.772]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.772]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.772]                   if (TRUE && !signal) {
[10:19:22.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.772]                     {
[10:19:22.772]                       inherits <- base::inherits
[10:19:22.772]                       invokeRestart <- base::invokeRestart
[10:19:22.772]                       is.null <- base::is.null
[10:19:22.772]                       muffled <- FALSE
[10:19:22.772]                       if (inherits(cond, "message")) {
[10:19:22.772]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.772]                         if (muffled) 
[10:19:22.772]                           invokeRestart("muffleMessage")
[10:19:22.772]                       }
[10:19:22.772]                       else if (inherits(cond, "warning")) {
[10:19:22.772]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.772]                         if (muffled) 
[10:19:22.772]                           invokeRestart("muffleWarning")
[10:19:22.772]                       }
[10:19:22.772]                       else if (inherits(cond, "condition")) {
[10:19:22.772]                         if (!is.null(pattern)) {
[10:19:22.772]                           computeRestarts <- base::computeRestarts
[10:19:22.772]                           grepl <- base::grepl
[10:19:22.772]                           restarts <- computeRestarts(cond)
[10:19:22.772]                           for (restart in restarts) {
[10:19:22.772]                             name <- restart$name
[10:19:22.772]                             if (is.null(name)) 
[10:19:22.772]                               next
[10:19:22.772]                             if (!grepl(pattern, name)) 
[10:19:22.772]                               next
[10:19:22.772]                             invokeRestart(restart)
[10:19:22.772]                             muffled <- TRUE
[10:19:22.772]                             break
[10:19:22.772]                           }
[10:19:22.772]                         }
[10:19:22.772]                       }
[10:19:22.772]                       invisible(muffled)
[10:19:22.772]                     }
[10:19:22.772]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.772]                   }
[10:19:22.772]                 }
[10:19:22.772]                 else {
[10:19:22.772]                   if (TRUE) {
[10:19:22.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.772]                     {
[10:19:22.772]                       inherits <- base::inherits
[10:19:22.772]                       invokeRestart <- base::invokeRestart
[10:19:22.772]                       is.null <- base::is.null
[10:19:22.772]                       muffled <- FALSE
[10:19:22.772]                       if (inherits(cond, "message")) {
[10:19:22.772]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.772]                         if (muffled) 
[10:19:22.772]                           invokeRestart("muffleMessage")
[10:19:22.772]                       }
[10:19:22.772]                       else if (inherits(cond, "warning")) {
[10:19:22.772]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.772]                         if (muffled) 
[10:19:22.772]                           invokeRestart("muffleWarning")
[10:19:22.772]                       }
[10:19:22.772]                       else if (inherits(cond, "condition")) {
[10:19:22.772]                         if (!is.null(pattern)) {
[10:19:22.772]                           computeRestarts <- base::computeRestarts
[10:19:22.772]                           grepl <- base::grepl
[10:19:22.772]                           restarts <- computeRestarts(cond)
[10:19:22.772]                           for (restart in restarts) {
[10:19:22.772]                             name <- restart$name
[10:19:22.772]                             if (is.null(name)) 
[10:19:22.772]                               next
[10:19:22.772]                             if (!grepl(pattern, name)) 
[10:19:22.772]                               next
[10:19:22.772]                             invokeRestart(restart)
[10:19:22.772]                             muffled <- TRUE
[10:19:22.772]                             break
[10:19:22.772]                           }
[10:19:22.772]                         }
[10:19:22.772]                       }
[10:19:22.772]                       invisible(muffled)
[10:19:22.772]                     }
[10:19:22.772]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.772]                   }
[10:19:22.772]                 }
[10:19:22.772]             }
[10:19:22.772]         }))
[10:19:22.772]     }, error = function(ex) {
[10:19:22.772]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.772]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.772]                 ...future.rng), started = ...future.startTime, 
[10:19:22.772]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.772]             version = "1.8"), class = "FutureResult")
[10:19:22.772]     }, finally = {
[10:19:22.772]         if (!identical(...future.workdir, getwd())) 
[10:19:22.772]             setwd(...future.workdir)
[10:19:22.772]         {
[10:19:22.772]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.772]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.772]             }
[10:19:22.772]             base::options(...future.oldOptions)
[10:19:22.772]             if (.Platform$OS.type == "windows") {
[10:19:22.772]                 old_names <- names(...future.oldEnvVars)
[10:19:22.772]                 envs <- base::Sys.getenv()
[10:19:22.772]                 names <- names(envs)
[10:19:22.772]                 common <- intersect(names, old_names)
[10:19:22.772]                 added <- setdiff(names, old_names)
[10:19:22.772]                 removed <- setdiff(old_names, names)
[10:19:22.772]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.772]                   envs[common]]
[10:19:22.772]                 NAMES <- toupper(changed)
[10:19:22.772]                 args <- list()
[10:19:22.772]                 for (kk in seq_along(NAMES)) {
[10:19:22.772]                   name <- changed[[kk]]
[10:19:22.772]                   NAME <- NAMES[[kk]]
[10:19:22.772]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.772]                     next
[10:19:22.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.772]                 }
[10:19:22.772]                 NAMES <- toupper(added)
[10:19:22.772]                 for (kk in seq_along(NAMES)) {
[10:19:22.772]                   name <- added[[kk]]
[10:19:22.772]                   NAME <- NAMES[[kk]]
[10:19:22.772]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.772]                     next
[10:19:22.772]                   args[[name]] <- ""
[10:19:22.772]                 }
[10:19:22.772]                 NAMES <- toupper(removed)
[10:19:22.772]                 for (kk in seq_along(NAMES)) {
[10:19:22.772]                   name <- removed[[kk]]
[10:19:22.772]                   NAME <- NAMES[[kk]]
[10:19:22.772]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.772]                     next
[10:19:22.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.772]                 }
[10:19:22.772]                 if (length(args) > 0) 
[10:19:22.772]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.772]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.772]             }
[10:19:22.772]             else {
[10:19:22.772]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.772]             }
[10:19:22.772]             {
[10:19:22.772]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.772]                   0L) {
[10:19:22.772]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.772]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.772]                   base::options(opts)
[10:19:22.772]                 }
[10:19:22.772]                 {
[10:19:22.772]                   {
[10:19:22.772]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.772]                     NULL
[10:19:22.772]                   }
[10:19:22.772]                   options(future.plan = NULL)
[10:19:22.772]                   if (is.na(NA_character_)) 
[10:19:22.772]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.772]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.772]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.772]                     .init = FALSE)
[10:19:22.772]                 }
[10:19:22.772]             }
[10:19:22.772]         }
[10:19:22.772]     })
[10:19:22.772]     if (TRUE) {
[10:19:22.772]         base::sink(type = "output", split = FALSE)
[10:19:22.772]         if (TRUE) {
[10:19:22.772]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.772]         }
[10:19:22.772]         else {
[10:19:22.772]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.772]         }
[10:19:22.772]         base::close(...future.stdout)
[10:19:22.772]         ...future.stdout <- NULL
[10:19:22.772]     }
[10:19:22.772]     ...future.result$conditions <- ...future.conditions
[10:19:22.772]     ...future.result$finished <- base::Sys.time()
[10:19:22.772]     ...future.result
[10:19:22.772] }
[10:19:22.775] assign_globals() ...
[10:19:22.775] List of 5
[10:19:22.775]  $ ...future.FUN            :function (x)  
[10:19:22.775]  $ MoreArgs                 : list()
[10:19:22.775]  $ ...future.elements_ii    :List of 1
[10:19:22.775]   ..$ :List of 1
[10:19:22.775]   .. ..$ : Date[1:1], format: "2018-06-01"
[10:19:22.775]  $ ...future.seeds_ii       : NULL
[10:19:22.775]  $ ...future.globals.maxSize: NULL
[10:19:22.775]  - attr(*, "where")=List of 5
[10:19:22.775]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.775]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.775]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.775]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.775]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.775]  - attr(*, "resolved")= logi FALSE
[10:19:22.775]  - attr(*, "total_size")= num 370
[10:19:22.775]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.775]  - attr(*, "already-done")= logi TRUE
[10:19:22.782] - copied ‘...future.FUN’ to environment
[10:19:22.782] - copied ‘MoreArgs’ to environment
[10:19:22.782] - copied ‘...future.elements_ii’ to environment
[10:19:22.782] - copied ‘...future.seeds_ii’ to environment
[10:19:22.782] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.782] assign_globals() ... done
[10:19:22.782] requestCore(): workers = 2
[10:19:22.785] MulticoreFuture started
[10:19:22.786] - Launch lazy future ... done
[10:19:22.786] plan(): Setting new future strategy stack:
[10:19:22.786] run() for ‘MulticoreFuture’ ... done
[10:19:22.787] Created future:
[10:19:22.787] List of future strategies:
[10:19:22.787] 1. sequential:
[10:19:22.787]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.787]    - tweaked: FALSE
[10:19:22.787]    - call: NULL
[10:19:22.789] plan(): nbrOfWorkers() = 1
[10:19:22.792] plan(): Setting new future strategy stack:
[10:19:22.792] List of future strategies:
[10:19:22.792] 1. multicore:
[10:19:22.792]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.792]    - tweaked: FALSE
[10:19:22.792]    - call: plan(strategy)
[10:19:22.797] plan(): nbrOfWorkers() = 2
[10:19:22.787] MulticoreFuture:
[10:19:22.787] Label: ‘future_.mapply-1’
[10:19:22.787] Expression:
[10:19:22.787] {
[10:19:22.787]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.787]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.787]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.787]         on.exit(options(oopts), add = TRUE)
[10:19:22.787]     }
[10:19:22.787]     {
[10:19:22.787]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.787]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.787]         do.call(mapply, args = args)
[10:19:22.787]     }
[10:19:22.787] }
[10:19:22.787] Lazy evaluation: FALSE
[10:19:22.787] Asynchronous evaluation: TRUE
[10:19:22.787] Local evaluation: TRUE
[10:19:22.787] Environment: R_GlobalEnv
[10:19:22.787] Capture standard output: TRUE
[10:19:22.787] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.787] Globals: 5 objects totaling 370 bytes (function ‘...future.FUN’ of 185 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.787] Packages: <none>
[10:19:22.787] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.787] Resolved: TRUE
[10:19:22.787] Value: <not collected>
[10:19:22.787] Conditions captured: <none>
[10:19:22.787] Early signaling: FALSE
[10:19:22.787] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.787] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.798] Chunk #1 of 1 ... DONE
[10:19:22.798] Launching 1 futures (chunks) ... DONE
[10:19:22.799] Resolving 1 futures (chunks) ...
[10:19:22.799] resolve() on list ...
[10:19:22.799]  recursive: 0
[10:19:22.799]  length: 1
[10:19:22.799] 
[10:19:22.800] Future #1
[10:19:22.800] result() for MulticoreFuture ...
[10:19:22.801] result() for MulticoreFuture ...
[10:19:22.801] result() for MulticoreFuture ... done
[10:19:22.801] result() for MulticoreFuture ... done
[10:19:22.802] result() for MulticoreFuture ...
[10:19:22.802] result() for MulticoreFuture ... done
[10:19:22.802] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:22.802] - nx: 1
[10:19:22.803] - relay: TRUE
[10:19:22.803] - stdout: TRUE
[10:19:22.803] - signal: TRUE
[10:19:22.803] - resignal: FALSE
[10:19:22.803] - force: TRUE
[10:19:22.803] - relayed: [n=1] FALSE
[10:19:22.804] - queued futures: [n=1] FALSE
[10:19:22.804]  - until=1
[10:19:22.804]  - relaying element #1
[10:19:22.804] result() for MulticoreFuture ...
[10:19:22.804] result() for MulticoreFuture ... done
[10:19:22.804] result() for MulticoreFuture ...
[10:19:22.805] result() for MulticoreFuture ... done
[10:19:22.805] result() for MulticoreFuture ...
[10:19:22.805] result() for MulticoreFuture ... done
[10:19:22.805] result() for MulticoreFuture ...
[10:19:22.805] result() for MulticoreFuture ... done
[10:19:22.805] - relayed: [n=1] TRUE
[10:19:22.806] - queued futures: [n=1] TRUE
[10:19:22.806] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:22.806]  length: 0 (resolved future 1)
[10:19:22.806] Relaying remaining futures
[10:19:22.806] signalConditionsASAP(NULL, pos=0) ...
[10:19:22.806] - nx: 1
[10:19:22.806] - relay: TRUE
[10:19:22.806] - stdout: TRUE
[10:19:22.807] - signal: TRUE
[10:19:22.807] - resignal: FALSE
[10:19:22.807] - force: TRUE
[10:19:22.807] - relayed: [n=1] TRUE
[10:19:22.807] - queued futures: [n=1] TRUE
 - flush all
[10:19:22.807] - relayed: [n=1] TRUE
[10:19:22.807] - queued futures: [n=1] TRUE
[10:19:22.807] signalConditionsASAP(NULL, pos=0) ... done
[10:19:22.807] resolve() on list ... DONE
[10:19:22.808] result() for MulticoreFuture ...
[10:19:22.808] result() for MulticoreFuture ... done
[10:19:22.808] result() for MulticoreFuture ...
[10:19:22.808] result() for MulticoreFuture ... done
[10:19:22.808]  - Number of value chunks collected: 1
[10:19:22.808] Resolving 1 futures (chunks) ... DONE
[10:19:22.808] Reducing values from 1 chunks ...
[10:19:22.808]  - Number of values collected after concatenation: 1
[10:19:22.808]  - Number of values expected: 1
[10:19:22.809] Reducing values from 1 chunks ... DONE
[10:19:22.809] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[10:19:22.809] future_mapply() ...
[10:19:22.811] Number of chunks: 2
[10:19:22.811] getGlobalsAndPackagesXApply() ...
[10:19:22.811]  - future.globals: TRUE
[10:19:22.812] getGlobalsAndPackages() ...
[10:19:22.812] Searching for globals...
[10:19:22.813] - globals found: [1] ‘FUN’
[10:19:22.813] Searching for globals ... DONE
[10:19:22.813] Resolving globals: FALSE
[10:19:22.813] The total size of the 1 globals is 326 bytes (326 bytes)
[10:19:22.814] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:19:22.814] - globals: [1] ‘FUN’
[10:19:22.814] 
[10:19:22.814] getGlobalsAndPackages() ... DONE
[10:19:22.814]  - globals found/used: [n=1] ‘FUN’
[10:19:22.814]  - needed namespaces: [n=0] 
[10:19:22.815] Finding globals ... DONE
[10:19:22.815] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:22.815] List of 2
[10:19:22.815]  $ ...future.FUN:function (x, y)  
[10:19:22.815]  $ MoreArgs     :List of 1
[10:19:22.815]   ..$ y: int [1:2] 3 4
[10:19:22.815]  - attr(*, "where")=List of 2
[10:19:22.815]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:22.815]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:22.815]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.815]  - attr(*, "resolved")= logi FALSE
[10:19:22.815]  - attr(*, "total_size")= num NA
[10:19:22.818] Packages to be attached in all futures: [n=0] 
[10:19:22.818] getGlobalsAndPackagesXApply() ... DONE
[10:19:22.818] Number of futures (= number of chunks): 2
[10:19:22.819] Launching 2 futures (chunks) ...
[10:19:22.819] Chunk #1 of 2 ...
[10:19:22.819]  - Finding globals in '...' for chunk #1 ...
[10:19:22.819] getGlobalsAndPackages() ...
[10:19:22.819] Searching for globals...
[10:19:22.819] 
[10:19:22.819] Searching for globals ... DONE
[10:19:22.819] - globals: [0] <none>
[10:19:22.820] getGlobalsAndPackages() ... DONE
[10:19:22.820]    + additional globals found: [n=0] 
[10:19:22.820]    + additional namespaces needed: [n=0] 
[10:19:22.820]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:22.820]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.820]  - seeds: <none>
[10:19:22.823]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.823] getGlobalsAndPackages() ...
[10:19:22.823] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.823] Resolving globals: FALSE
[10:19:22.824] The total size of the 5 globals is 656 bytes (656 bytes)
[10:19:22.824] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:22.825] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.825] 
[10:19:22.825] getGlobalsAndPackages() ... DONE
[10:19:22.825] run() for ‘Future’ ...
[10:19:22.825] - state: ‘created’
[10:19:22.826] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.828] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.828] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.828]   - Field: ‘label’
[10:19:22.828]   - Field: ‘local’
[10:19:22.828]   - Field: ‘owner’
[10:19:22.829]   - Field: ‘envir’
[10:19:22.829]   - Field: ‘workers’
[10:19:22.829]   - Field: ‘packages’
[10:19:22.829]   - Field: ‘gc’
[10:19:22.829]   - Field: ‘job’
[10:19:22.829]   - Field: ‘conditions’
[10:19:22.829]   - Field: ‘expr’
[10:19:22.829]   - Field: ‘uuid’
[10:19:22.830]   - Field: ‘seed’
[10:19:22.830]   - Field: ‘version’
[10:19:22.830]   - Field: ‘result’
[10:19:22.830]   - Field: ‘asynchronous’
[10:19:22.830]   - Field: ‘calls’
[10:19:22.830]   - Field: ‘globals’
[10:19:22.830]   - Field: ‘stdout’
[10:19:22.830]   - Field: ‘earlySignal’
[10:19:22.831]   - Field: ‘lazy’
[10:19:22.831]   - Field: ‘state’
[10:19:22.831] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.831] - Launch lazy future ...
[10:19:22.831] Packages needed by the future expression (n = 0): <none>
[10:19:22.831] Packages needed by future strategies (n = 0): <none>
[10:19:22.832] {
[10:19:22.832]     {
[10:19:22.832]         {
[10:19:22.832]             ...future.startTime <- base::Sys.time()
[10:19:22.832]             {
[10:19:22.832]                 {
[10:19:22.832]                   {
[10:19:22.832]                     {
[10:19:22.832]                       base::local({
[10:19:22.832]                         has_future <- base::requireNamespace("future", 
[10:19:22.832]                           quietly = TRUE)
[10:19:22.832]                         if (has_future) {
[10:19:22.832]                           ns <- base::getNamespace("future")
[10:19:22.832]                           version <- ns[[".package"]][["version"]]
[10:19:22.832]                           if (is.null(version)) 
[10:19:22.832]                             version <- utils::packageVersion("future")
[10:19:22.832]                         }
[10:19:22.832]                         else {
[10:19:22.832]                           version <- NULL
[10:19:22.832]                         }
[10:19:22.832]                         if (!has_future || version < "1.8.0") {
[10:19:22.832]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.832]                             "", base::R.version$version.string), 
[10:19:22.832]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.832]                               "release", "version")], collapse = " "), 
[10:19:22.832]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.832]                             info)
[10:19:22.832]                           info <- base::paste(info, collapse = "; ")
[10:19:22.832]                           if (!has_future) {
[10:19:22.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.832]                               info)
[10:19:22.832]                           }
[10:19:22.832]                           else {
[10:19:22.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.832]                               info, version)
[10:19:22.832]                           }
[10:19:22.832]                           base::stop(msg)
[10:19:22.832]                         }
[10:19:22.832]                       })
[10:19:22.832]                     }
[10:19:22.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.832]                     base::options(mc.cores = 1L)
[10:19:22.832]                   }
[10:19:22.832]                   ...future.strategy.old <- future::plan("list")
[10:19:22.832]                   options(future.plan = NULL)
[10:19:22.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.832]                 }
[10:19:22.832]                 ...future.workdir <- getwd()
[10:19:22.832]             }
[10:19:22.832]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.832]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.832]         }
[10:19:22.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.832]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.832]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.832]             base::names(...future.oldOptions))
[10:19:22.832]     }
[10:19:22.832]     if (FALSE) {
[10:19:22.832]     }
[10:19:22.832]     else {
[10:19:22.832]         if (TRUE) {
[10:19:22.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.832]                 open = "w")
[10:19:22.832]         }
[10:19:22.832]         else {
[10:19:22.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.832]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.832]         }
[10:19:22.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.832]             base::sink(type = "output", split = FALSE)
[10:19:22.832]             base::close(...future.stdout)
[10:19:22.832]         }, add = TRUE)
[10:19:22.832]     }
[10:19:22.832]     ...future.frame <- base::sys.nframe()
[10:19:22.832]     ...future.conditions <- base::list()
[10:19:22.832]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.832]     if (FALSE) {
[10:19:22.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.832]     }
[10:19:22.832]     ...future.result <- base::tryCatch({
[10:19:22.832]         base::withCallingHandlers({
[10:19:22.832]             ...future.value <- base::withVisible(base::local({
[10:19:22.832]                 withCallingHandlers({
[10:19:22.832]                   {
[10:19:22.832]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.832]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.832]                       ...future.globals.maxSize)) {
[10:19:22.832]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.832]                       on.exit(options(oopts), add = TRUE)
[10:19:22.832]                     }
[10:19:22.832]                     {
[10:19:22.832]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.832]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.832]                         USE.NAMES = FALSE)
[10:19:22.832]                       do.call(mapply, args = args)
[10:19:22.832]                     }
[10:19:22.832]                   }
[10:19:22.832]                 }, immediateCondition = function(cond) {
[10:19:22.832]                   save_rds <- function (object, pathname, ...) 
[10:19:22.832]                   {
[10:19:22.832]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.832]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.832]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.832]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.832]                         fi_tmp[["mtime"]])
[10:19:22.832]                     }
[10:19:22.832]                     tryCatch({
[10:19:22.832]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.832]                     }, error = function(ex) {
[10:19:22.832]                       msg <- conditionMessage(ex)
[10:19:22.832]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.832]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.832]                         fi_tmp[["mtime"]], msg)
[10:19:22.832]                       ex$message <- msg
[10:19:22.832]                       stop(ex)
[10:19:22.832]                     })
[10:19:22.832]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.832]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.832]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.832]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.832]                       fi <- file.info(pathname)
[10:19:22.832]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.832]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.832]                         fi[["size"]], fi[["mtime"]])
[10:19:22.832]                       stop(msg)
[10:19:22.832]                     }
[10:19:22.832]                     invisible(pathname)
[10:19:22.832]                   }
[10:19:22.832]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.832]                     rootPath = tempdir()) 
[10:19:22.832]                   {
[10:19:22.832]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.832]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.832]                       tmpdir = path, fileext = ".rds")
[10:19:22.832]                     save_rds(obj, file)
[10:19:22.832]                   }
[10:19:22.832]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.832]                   {
[10:19:22.832]                     inherits <- base::inherits
[10:19:22.832]                     invokeRestart <- base::invokeRestart
[10:19:22.832]                     is.null <- base::is.null
[10:19:22.832]                     muffled <- FALSE
[10:19:22.832]                     if (inherits(cond, "message")) {
[10:19:22.832]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.832]                       if (muffled) 
[10:19:22.832]                         invokeRestart("muffleMessage")
[10:19:22.832]                     }
[10:19:22.832]                     else if (inherits(cond, "warning")) {
[10:19:22.832]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.832]                       if (muffled) 
[10:19:22.832]                         invokeRestart("muffleWarning")
[10:19:22.832]                     }
[10:19:22.832]                     else if (inherits(cond, "condition")) {
[10:19:22.832]                       if (!is.null(pattern)) {
[10:19:22.832]                         computeRestarts <- base::computeRestarts
[10:19:22.832]                         grepl <- base::grepl
[10:19:22.832]                         restarts <- computeRestarts(cond)
[10:19:22.832]                         for (restart in restarts) {
[10:19:22.832]                           name <- restart$name
[10:19:22.832]                           if (is.null(name)) 
[10:19:22.832]                             next
[10:19:22.832]                           if (!grepl(pattern, name)) 
[10:19:22.832]                             next
[10:19:22.832]                           invokeRestart(restart)
[10:19:22.832]                           muffled <- TRUE
[10:19:22.832]                           break
[10:19:22.832]                         }
[10:19:22.832]                       }
[10:19:22.832]                     }
[10:19:22.832]                     invisible(muffled)
[10:19:22.832]                   }
[10:19:22.832]                   muffleCondition(cond)
[10:19:22.832]                 })
[10:19:22.832]             }))
[10:19:22.832]             future::FutureResult(value = ...future.value$value, 
[10:19:22.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.832]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.832]                     ...future.globalenv.names))
[10:19:22.832]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.832]         }, condition = base::local({
[10:19:22.832]             c <- base::c
[10:19:22.832]             inherits <- base::inherits
[10:19:22.832]             invokeRestart <- base::invokeRestart
[10:19:22.832]             length <- base::length
[10:19:22.832]             list <- base::list
[10:19:22.832]             seq.int <- base::seq.int
[10:19:22.832]             signalCondition <- base::signalCondition
[10:19:22.832]             sys.calls <- base::sys.calls
[10:19:22.832]             `[[` <- base::`[[`
[10:19:22.832]             `+` <- base::`+`
[10:19:22.832]             `<<-` <- base::`<<-`
[10:19:22.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.832]                   3L)]
[10:19:22.832]             }
[10:19:22.832]             function(cond) {
[10:19:22.832]                 is_error <- inherits(cond, "error")
[10:19:22.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.832]                   NULL)
[10:19:22.832]                 if (is_error) {
[10:19:22.832]                   sessionInformation <- function() {
[10:19:22.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.832]                       search = base::search(), system = base::Sys.info())
[10:19:22.832]                   }
[10:19:22.832]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.832]                     cond$call), session = sessionInformation(), 
[10:19:22.832]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.832]                   signalCondition(cond)
[10:19:22.832]                 }
[10:19:22.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.832]                 "immediateCondition"))) {
[10:19:22.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.832]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.832]                   if (TRUE && !signal) {
[10:19:22.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.832]                     {
[10:19:22.832]                       inherits <- base::inherits
[10:19:22.832]                       invokeRestart <- base::invokeRestart
[10:19:22.832]                       is.null <- base::is.null
[10:19:22.832]                       muffled <- FALSE
[10:19:22.832]                       if (inherits(cond, "message")) {
[10:19:22.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.832]                         if (muffled) 
[10:19:22.832]                           invokeRestart("muffleMessage")
[10:19:22.832]                       }
[10:19:22.832]                       else if (inherits(cond, "warning")) {
[10:19:22.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.832]                         if (muffled) 
[10:19:22.832]                           invokeRestart("muffleWarning")
[10:19:22.832]                       }
[10:19:22.832]                       else if (inherits(cond, "condition")) {
[10:19:22.832]                         if (!is.null(pattern)) {
[10:19:22.832]                           computeRestarts <- base::computeRestarts
[10:19:22.832]                           grepl <- base::grepl
[10:19:22.832]                           restarts <- computeRestarts(cond)
[10:19:22.832]                           for (restart in restarts) {
[10:19:22.832]                             name <- restart$name
[10:19:22.832]                             if (is.null(name)) 
[10:19:22.832]                               next
[10:19:22.832]                             if (!grepl(pattern, name)) 
[10:19:22.832]                               next
[10:19:22.832]                             invokeRestart(restart)
[10:19:22.832]                             muffled <- TRUE
[10:19:22.832]                             break
[10:19:22.832]                           }
[10:19:22.832]                         }
[10:19:22.832]                       }
[10:19:22.832]                       invisible(muffled)
[10:19:22.832]                     }
[10:19:22.832]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.832]                   }
[10:19:22.832]                 }
[10:19:22.832]                 else {
[10:19:22.832]                   if (TRUE) {
[10:19:22.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.832]                     {
[10:19:22.832]                       inherits <- base::inherits
[10:19:22.832]                       invokeRestart <- base::invokeRestart
[10:19:22.832]                       is.null <- base::is.null
[10:19:22.832]                       muffled <- FALSE
[10:19:22.832]                       if (inherits(cond, "message")) {
[10:19:22.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.832]                         if (muffled) 
[10:19:22.832]                           invokeRestart("muffleMessage")
[10:19:22.832]                       }
[10:19:22.832]                       else if (inherits(cond, "warning")) {
[10:19:22.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.832]                         if (muffled) 
[10:19:22.832]                           invokeRestart("muffleWarning")
[10:19:22.832]                       }
[10:19:22.832]                       else if (inherits(cond, "condition")) {
[10:19:22.832]                         if (!is.null(pattern)) {
[10:19:22.832]                           computeRestarts <- base::computeRestarts
[10:19:22.832]                           grepl <- base::grepl
[10:19:22.832]                           restarts <- computeRestarts(cond)
[10:19:22.832]                           for (restart in restarts) {
[10:19:22.832]                             name <- restart$name
[10:19:22.832]                             if (is.null(name)) 
[10:19:22.832]                               next
[10:19:22.832]                             if (!grepl(pattern, name)) 
[10:19:22.832]                               next
[10:19:22.832]                             invokeRestart(restart)
[10:19:22.832]                             muffled <- TRUE
[10:19:22.832]                             break
[10:19:22.832]                           }
[10:19:22.832]                         }
[10:19:22.832]                       }
[10:19:22.832]                       invisible(muffled)
[10:19:22.832]                     }
[10:19:22.832]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.832]                   }
[10:19:22.832]                 }
[10:19:22.832]             }
[10:19:22.832]         }))
[10:19:22.832]     }, error = function(ex) {
[10:19:22.832]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.832]                 ...future.rng), started = ...future.startTime, 
[10:19:22.832]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.832]             version = "1.8"), class = "FutureResult")
[10:19:22.832]     }, finally = {
[10:19:22.832]         if (!identical(...future.workdir, getwd())) 
[10:19:22.832]             setwd(...future.workdir)
[10:19:22.832]         {
[10:19:22.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.832]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.832]             }
[10:19:22.832]             base::options(...future.oldOptions)
[10:19:22.832]             if (.Platform$OS.type == "windows") {
[10:19:22.832]                 old_names <- names(...future.oldEnvVars)
[10:19:22.832]                 envs <- base::Sys.getenv()
[10:19:22.832]                 names <- names(envs)
[10:19:22.832]                 common <- intersect(names, old_names)
[10:19:22.832]                 added <- setdiff(names, old_names)
[10:19:22.832]                 removed <- setdiff(old_names, names)
[10:19:22.832]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.832]                   envs[common]]
[10:19:22.832]                 NAMES <- toupper(changed)
[10:19:22.832]                 args <- list()
[10:19:22.832]                 for (kk in seq_along(NAMES)) {
[10:19:22.832]                   name <- changed[[kk]]
[10:19:22.832]                   NAME <- NAMES[[kk]]
[10:19:22.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.832]                     next
[10:19:22.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.832]                 }
[10:19:22.832]                 NAMES <- toupper(added)
[10:19:22.832]                 for (kk in seq_along(NAMES)) {
[10:19:22.832]                   name <- added[[kk]]
[10:19:22.832]                   NAME <- NAMES[[kk]]
[10:19:22.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.832]                     next
[10:19:22.832]                   args[[name]] <- ""
[10:19:22.832]                 }
[10:19:22.832]                 NAMES <- toupper(removed)
[10:19:22.832]                 for (kk in seq_along(NAMES)) {
[10:19:22.832]                   name <- removed[[kk]]
[10:19:22.832]                   NAME <- NAMES[[kk]]
[10:19:22.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.832]                     next
[10:19:22.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.832]                 }
[10:19:22.832]                 if (length(args) > 0) 
[10:19:22.832]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.832]             }
[10:19:22.832]             else {
[10:19:22.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.832]             }
[10:19:22.832]             {
[10:19:22.832]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.832]                   0L) {
[10:19:22.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.832]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.832]                   base::options(opts)
[10:19:22.832]                 }
[10:19:22.832]                 {
[10:19:22.832]                   {
[10:19:22.832]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.832]                     NULL
[10:19:22.832]                   }
[10:19:22.832]                   options(future.plan = NULL)
[10:19:22.832]                   if (is.na(NA_character_)) 
[10:19:22.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.832]                     .init = FALSE)
[10:19:22.832]                 }
[10:19:22.832]             }
[10:19:22.832]         }
[10:19:22.832]     })
[10:19:22.832]     if (TRUE) {
[10:19:22.832]         base::sink(type = "output", split = FALSE)
[10:19:22.832]         if (TRUE) {
[10:19:22.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.832]         }
[10:19:22.832]         else {
[10:19:22.832]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.832]         }
[10:19:22.832]         base::close(...future.stdout)
[10:19:22.832]         ...future.stdout <- NULL
[10:19:22.832]     }
[10:19:22.832]     ...future.result$conditions <- ...future.conditions
[10:19:22.832]     ...future.result$finished <- base::Sys.time()
[10:19:22.832]     ...future.result
[10:19:22.832] }
[10:19:22.835] assign_globals() ...
[10:19:22.835] List of 5
[10:19:22.835]  $ ...future.FUN            :function (x, y)  
[10:19:22.835]  $ MoreArgs                 :List of 1
[10:19:22.835]   ..$ y: int [1:2] 3 4
[10:19:22.835]  $ ...future.elements_ii    :List of 1
[10:19:22.835]   ..$ x:List of 1
[10:19:22.835]   .. ..$ : int 1
[10:19:22.835]  $ ...future.seeds_ii       : NULL
[10:19:22.835]  $ ...future.globals.maxSize: NULL
[10:19:22.835]  - attr(*, "where")=List of 5
[10:19:22.835]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.835]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.835]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.835]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.835]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.835]  - attr(*, "resolved")= logi FALSE
[10:19:22.835]  - attr(*, "total_size")= num 656
[10:19:22.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.835]  - attr(*, "already-done")= logi TRUE
[10:19:22.841] - reassign environment for ‘...future.FUN’
[10:19:22.841] - copied ‘...future.FUN’ to environment
[10:19:22.841] - copied ‘MoreArgs’ to environment
[10:19:22.841] - copied ‘...future.elements_ii’ to environment
[10:19:22.841] - copied ‘...future.seeds_ii’ to environment
[10:19:22.841] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.841] assign_globals() ... done
[10:19:22.841] requestCore(): workers = 2
[10:19:22.844] MulticoreFuture started
[10:19:22.844] - Launch lazy future ... done
[10:19:22.844] run() for ‘MulticoreFuture’ ... done
[10:19:22.845] Created future:
[10:19:22.845] plan(): Setting new future strategy stack:
[10:19:22.845] List of future strategies:
[10:19:22.845] 1. sequential:
[10:19:22.845]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.845]    - tweaked: FALSE
[10:19:22.845]    - call: NULL
[10:19:22.846] plan(): nbrOfWorkers() = 1
[10:19:22.848] plan(): Setting new future strategy stack:
[10:19:22.849] List of future strategies:
[10:19:22.849] 1. multicore:
[10:19:22.849]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.849]    - tweaked: FALSE
[10:19:22.849]    - call: plan(strategy)
[10:19:22.852] plan(): nbrOfWorkers() = 2
[10:19:22.845] MulticoreFuture:
[10:19:22.845] Label: ‘future_mapply-1’
[10:19:22.845] Expression:
[10:19:22.845] {
[10:19:22.845]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.845]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.845]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.845]         on.exit(options(oopts), add = TRUE)
[10:19:22.845]     }
[10:19:22.845]     {
[10:19:22.845]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.845]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.845]         do.call(mapply, args = args)
[10:19:22.845]     }
[10:19:22.845] }
[10:19:22.845] Lazy evaluation: FALSE
[10:19:22.845] Asynchronous evaluation: TRUE
[10:19:22.845] Local evaluation: TRUE
[10:19:22.845] Environment: R_GlobalEnv
[10:19:22.845] Capture standard output: TRUE
[10:19:22.845] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.845] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.845] Packages: <none>
[10:19:22.845] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.845] Resolved: TRUE
[10:19:22.845] Value: <not collected>
[10:19:22.845] Conditions captured: <none>
[10:19:22.845] Early signaling: FALSE
[10:19:22.845] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.845] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.853] Chunk #1 of 2 ... DONE
[10:19:22.853] Chunk #2 of 2 ...
[10:19:22.854]  - Finding globals in '...' for chunk #2 ...
[10:19:22.854] getGlobalsAndPackages() ...
[10:19:22.854] Searching for globals...
[10:19:22.854] 
[10:19:22.855] Searching for globals ... DONE
[10:19:22.855] - globals: [0] <none>
[10:19:22.855] getGlobalsAndPackages() ... DONE
[10:19:22.855]    + additional globals found: [n=0] 
[10:19:22.855]    + additional namespaces needed: [n=0] 
[10:19:22.855]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:22.856]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.856]  - seeds: <none>
[10:19:22.856]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.856] getGlobalsAndPackages() ...
[10:19:22.856] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.856] Resolving globals: FALSE
[10:19:22.857] The total size of the 5 globals is 656 bytes (656 bytes)
[10:19:22.858] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:22.858] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.858] 
[10:19:22.859] getGlobalsAndPackages() ... DONE
[10:19:22.859] run() for ‘Future’ ...
[10:19:22.859] - state: ‘created’
[10:19:22.859] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.862] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.866]   - Field: ‘label’
[10:19:22.867]   - Field: ‘local’
[10:19:22.867]   - Field: ‘owner’
[10:19:22.867]   - Field: ‘envir’
[10:19:22.868]   - Field: ‘workers’
[10:19:22.868]   - Field: ‘packages’
[10:19:22.868]   - Field: ‘gc’
[10:19:22.869]   - Field: ‘job’
[10:19:22.869]   - Field: ‘conditions’
[10:19:22.869]   - Field: ‘expr’
[10:19:22.869]   - Field: ‘uuid’
[10:19:22.870]   - Field: ‘seed’
[10:19:22.870]   - Field: ‘version’
[10:19:22.870]   - Field: ‘result’
[10:19:22.870]   - Field: ‘asynchronous’
[10:19:22.871]   - Field: ‘calls’
[10:19:22.871]   - Field: ‘globals’
[10:19:22.871]   - Field: ‘stdout’
[10:19:22.871]   - Field: ‘earlySignal’
[10:19:22.872]   - Field: ‘lazy’
[10:19:22.872]   - Field: ‘state’
[10:19:22.872] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.872] - Launch lazy future ...
[10:19:22.873] Packages needed by the future expression (n = 0): <none>
[10:19:22.873] Packages needed by future strategies (n = 0): <none>
[10:19:22.874] {
[10:19:22.874]     {
[10:19:22.874]         {
[10:19:22.874]             ...future.startTime <- base::Sys.time()
[10:19:22.874]             {
[10:19:22.874]                 {
[10:19:22.874]                   {
[10:19:22.874]                     {
[10:19:22.874]                       base::local({
[10:19:22.874]                         has_future <- base::requireNamespace("future", 
[10:19:22.874]                           quietly = TRUE)
[10:19:22.874]                         if (has_future) {
[10:19:22.874]                           ns <- base::getNamespace("future")
[10:19:22.874]                           version <- ns[[".package"]][["version"]]
[10:19:22.874]                           if (is.null(version)) 
[10:19:22.874]                             version <- utils::packageVersion("future")
[10:19:22.874]                         }
[10:19:22.874]                         else {
[10:19:22.874]                           version <- NULL
[10:19:22.874]                         }
[10:19:22.874]                         if (!has_future || version < "1.8.0") {
[10:19:22.874]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.874]                             "", base::R.version$version.string), 
[10:19:22.874]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.874]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.874]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.874]                               "release", "version")], collapse = " "), 
[10:19:22.874]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.874]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.874]                             info)
[10:19:22.874]                           info <- base::paste(info, collapse = "; ")
[10:19:22.874]                           if (!has_future) {
[10:19:22.874]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.874]                               info)
[10:19:22.874]                           }
[10:19:22.874]                           else {
[10:19:22.874]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.874]                               info, version)
[10:19:22.874]                           }
[10:19:22.874]                           base::stop(msg)
[10:19:22.874]                         }
[10:19:22.874]                       })
[10:19:22.874]                     }
[10:19:22.874]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.874]                     base::options(mc.cores = 1L)
[10:19:22.874]                   }
[10:19:22.874]                   ...future.strategy.old <- future::plan("list")
[10:19:22.874]                   options(future.plan = NULL)
[10:19:22.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.874]                 }
[10:19:22.874]                 ...future.workdir <- getwd()
[10:19:22.874]             }
[10:19:22.874]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.874]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.874]         }
[10:19:22.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.874]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.874]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.874]             base::names(...future.oldOptions))
[10:19:22.874]     }
[10:19:22.874]     if (FALSE) {
[10:19:22.874]     }
[10:19:22.874]     else {
[10:19:22.874]         if (TRUE) {
[10:19:22.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.874]                 open = "w")
[10:19:22.874]         }
[10:19:22.874]         else {
[10:19:22.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.874]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.874]         }
[10:19:22.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.874]             base::sink(type = "output", split = FALSE)
[10:19:22.874]             base::close(...future.stdout)
[10:19:22.874]         }, add = TRUE)
[10:19:22.874]     }
[10:19:22.874]     ...future.frame <- base::sys.nframe()
[10:19:22.874]     ...future.conditions <- base::list()
[10:19:22.874]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.874]     if (FALSE) {
[10:19:22.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.874]     }
[10:19:22.874]     ...future.result <- base::tryCatch({
[10:19:22.874]         base::withCallingHandlers({
[10:19:22.874]             ...future.value <- base::withVisible(base::local({
[10:19:22.874]                 withCallingHandlers({
[10:19:22.874]                   {
[10:19:22.874]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.874]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.874]                       ...future.globals.maxSize)) {
[10:19:22.874]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.874]                       on.exit(options(oopts), add = TRUE)
[10:19:22.874]                     }
[10:19:22.874]                     {
[10:19:22.874]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.874]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.874]                         USE.NAMES = FALSE)
[10:19:22.874]                       do.call(mapply, args = args)
[10:19:22.874]                     }
[10:19:22.874]                   }
[10:19:22.874]                 }, immediateCondition = function(cond) {
[10:19:22.874]                   save_rds <- function (object, pathname, ...) 
[10:19:22.874]                   {
[10:19:22.874]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.874]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.874]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.874]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.874]                         fi_tmp[["mtime"]])
[10:19:22.874]                     }
[10:19:22.874]                     tryCatch({
[10:19:22.874]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.874]                     }, error = function(ex) {
[10:19:22.874]                       msg <- conditionMessage(ex)
[10:19:22.874]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.874]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.874]                         fi_tmp[["mtime"]], msg)
[10:19:22.874]                       ex$message <- msg
[10:19:22.874]                       stop(ex)
[10:19:22.874]                     })
[10:19:22.874]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.874]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.874]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.874]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.874]                       fi <- file.info(pathname)
[10:19:22.874]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.874]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.874]                         fi[["size"]], fi[["mtime"]])
[10:19:22.874]                       stop(msg)
[10:19:22.874]                     }
[10:19:22.874]                     invisible(pathname)
[10:19:22.874]                   }
[10:19:22.874]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.874]                     rootPath = tempdir()) 
[10:19:22.874]                   {
[10:19:22.874]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.874]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.874]                       tmpdir = path, fileext = ".rds")
[10:19:22.874]                     save_rds(obj, file)
[10:19:22.874]                   }
[10:19:22.874]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.874]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.874]                   {
[10:19:22.874]                     inherits <- base::inherits
[10:19:22.874]                     invokeRestart <- base::invokeRestart
[10:19:22.874]                     is.null <- base::is.null
[10:19:22.874]                     muffled <- FALSE
[10:19:22.874]                     if (inherits(cond, "message")) {
[10:19:22.874]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.874]                       if (muffled) 
[10:19:22.874]                         invokeRestart("muffleMessage")
[10:19:22.874]                     }
[10:19:22.874]                     else if (inherits(cond, "warning")) {
[10:19:22.874]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.874]                       if (muffled) 
[10:19:22.874]                         invokeRestart("muffleWarning")
[10:19:22.874]                     }
[10:19:22.874]                     else if (inherits(cond, "condition")) {
[10:19:22.874]                       if (!is.null(pattern)) {
[10:19:22.874]                         computeRestarts <- base::computeRestarts
[10:19:22.874]                         grepl <- base::grepl
[10:19:22.874]                         restarts <- computeRestarts(cond)
[10:19:22.874]                         for (restart in restarts) {
[10:19:22.874]                           name <- restart$name
[10:19:22.874]                           if (is.null(name)) 
[10:19:22.874]                             next
[10:19:22.874]                           if (!grepl(pattern, name)) 
[10:19:22.874]                             next
[10:19:22.874]                           invokeRestart(restart)
[10:19:22.874]                           muffled <- TRUE
[10:19:22.874]                           break
[10:19:22.874]                         }
[10:19:22.874]                       }
[10:19:22.874]                     }
[10:19:22.874]                     invisible(muffled)
[10:19:22.874]                   }
[10:19:22.874]                   muffleCondition(cond)
[10:19:22.874]                 })
[10:19:22.874]             }))
[10:19:22.874]             future::FutureResult(value = ...future.value$value, 
[10:19:22.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.874]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.874]                     ...future.globalenv.names))
[10:19:22.874]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.874]         }, condition = base::local({
[10:19:22.874]             c <- base::c
[10:19:22.874]             inherits <- base::inherits
[10:19:22.874]             invokeRestart <- base::invokeRestart
[10:19:22.874]             length <- base::length
[10:19:22.874]             list <- base::list
[10:19:22.874]             seq.int <- base::seq.int
[10:19:22.874]             signalCondition <- base::signalCondition
[10:19:22.874]             sys.calls <- base::sys.calls
[10:19:22.874]             `[[` <- base::`[[`
[10:19:22.874]             `+` <- base::`+`
[10:19:22.874]             `<<-` <- base::`<<-`
[10:19:22.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.874]                   3L)]
[10:19:22.874]             }
[10:19:22.874]             function(cond) {
[10:19:22.874]                 is_error <- inherits(cond, "error")
[10:19:22.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.874]                   NULL)
[10:19:22.874]                 if (is_error) {
[10:19:22.874]                   sessionInformation <- function() {
[10:19:22.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.874]                       search = base::search(), system = base::Sys.info())
[10:19:22.874]                   }
[10:19:22.874]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.874]                     cond$call), session = sessionInformation(), 
[10:19:22.874]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.874]                   signalCondition(cond)
[10:19:22.874]                 }
[10:19:22.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.874]                 "immediateCondition"))) {
[10:19:22.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.874]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.874]                   if (TRUE && !signal) {
[10:19:22.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.874]                     {
[10:19:22.874]                       inherits <- base::inherits
[10:19:22.874]                       invokeRestart <- base::invokeRestart
[10:19:22.874]                       is.null <- base::is.null
[10:19:22.874]                       muffled <- FALSE
[10:19:22.874]                       if (inherits(cond, "message")) {
[10:19:22.874]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.874]                         if (muffled) 
[10:19:22.874]                           invokeRestart("muffleMessage")
[10:19:22.874]                       }
[10:19:22.874]                       else if (inherits(cond, "warning")) {
[10:19:22.874]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.874]                         if (muffled) 
[10:19:22.874]                           invokeRestart("muffleWarning")
[10:19:22.874]                       }
[10:19:22.874]                       else if (inherits(cond, "condition")) {
[10:19:22.874]                         if (!is.null(pattern)) {
[10:19:22.874]                           computeRestarts <- base::computeRestarts
[10:19:22.874]                           grepl <- base::grepl
[10:19:22.874]                           restarts <- computeRestarts(cond)
[10:19:22.874]                           for (restart in restarts) {
[10:19:22.874]                             name <- restart$name
[10:19:22.874]                             if (is.null(name)) 
[10:19:22.874]                               next
[10:19:22.874]                             if (!grepl(pattern, name)) 
[10:19:22.874]                               next
[10:19:22.874]                             invokeRestart(restart)
[10:19:22.874]                             muffled <- TRUE
[10:19:22.874]                             break
[10:19:22.874]                           }
[10:19:22.874]                         }
[10:19:22.874]                       }
[10:19:22.874]                       invisible(muffled)
[10:19:22.874]                     }
[10:19:22.874]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.874]                   }
[10:19:22.874]                 }
[10:19:22.874]                 else {
[10:19:22.874]                   if (TRUE) {
[10:19:22.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.874]                     {
[10:19:22.874]                       inherits <- base::inherits
[10:19:22.874]                       invokeRestart <- base::invokeRestart
[10:19:22.874]                       is.null <- base::is.null
[10:19:22.874]                       muffled <- FALSE
[10:19:22.874]                       if (inherits(cond, "message")) {
[10:19:22.874]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.874]                         if (muffled) 
[10:19:22.874]                           invokeRestart("muffleMessage")
[10:19:22.874]                       }
[10:19:22.874]                       else if (inherits(cond, "warning")) {
[10:19:22.874]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.874]                         if (muffled) 
[10:19:22.874]                           invokeRestart("muffleWarning")
[10:19:22.874]                       }
[10:19:22.874]                       else if (inherits(cond, "condition")) {
[10:19:22.874]                         if (!is.null(pattern)) {
[10:19:22.874]                           computeRestarts <- base::computeRestarts
[10:19:22.874]                           grepl <- base::grepl
[10:19:22.874]                           restarts <- computeRestarts(cond)
[10:19:22.874]                           for (restart in restarts) {
[10:19:22.874]                             name <- restart$name
[10:19:22.874]                             if (is.null(name)) 
[10:19:22.874]                               next
[10:19:22.874]                             if (!grepl(pattern, name)) 
[10:19:22.874]                               next
[10:19:22.874]                             invokeRestart(restart)
[10:19:22.874]                             muffled <- TRUE
[10:19:22.874]                             break
[10:19:22.874]                           }
[10:19:22.874]                         }
[10:19:22.874]                       }
[10:19:22.874]                       invisible(muffled)
[10:19:22.874]                     }
[10:19:22.874]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.874]                   }
[10:19:22.874]                 }
[10:19:22.874]             }
[10:19:22.874]         }))
[10:19:22.874]     }, error = function(ex) {
[10:19:22.874]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.874]                 ...future.rng), started = ...future.startTime, 
[10:19:22.874]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.874]             version = "1.8"), class = "FutureResult")
[10:19:22.874]     }, finally = {
[10:19:22.874]         if (!identical(...future.workdir, getwd())) 
[10:19:22.874]             setwd(...future.workdir)
[10:19:22.874]         {
[10:19:22.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.874]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.874]             }
[10:19:22.874]             base::options(...future.oldOptions)
[10:19:22.874]             if (.Platform$OS.type == "windows") {
[10:19:22.874]                 old_names <- names(...future.oldEnvVars)
[10:19:22.874]                 envs <- base::Sys.getenv()
[10:19:22.874]                 names <- names(envs)
[10:19:22.874]                 common <- intersect(names, old_names)
[10:19:22.874]                 added <- setdiff(names, old_names)
[10:19:22.874]                 removed <- setdiff(old_names, names)
[10:19:22.874]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.874]                   envs[common]]
[10:19:22.874]                 NAMES <- toupper(changed)
[10:19:22.874]                 args <- list()
[10:19:22.874]                 for (kk in seq_along(NAMES)) {
[10:19:22.874]                   name <- changed[[kk]]
[10:19:22.874]                   NAME <- NAMES[[kk]]
[10:19:22.874]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.874]                     next
[10:19:22.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.874]                 }
[10:19:22.874]                 NAMES <- toupper(added)
[10:19:22.874]                 for (kk in seq_along(NAMES)) {
[10:19:22.874]                   name <- added[[kk]]
[10:19:22.874]                   NAME <- NAMES[[kk]]
[10:19:22.874]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.874]                     next
[10:19:22.874]                   args[[name]] <- ""
[10:19:22.874]                 }
[10:19:22.874]                 NAMES <- toupper(removed)
[10:19:22.874]                 for (kk in seq_along(NAMES)) {
[10:19:22.874]                   name <- removed[[kk]]
[10:19:22.874]                   NAME <- NAMES[[kk]]
[10:19:22.874]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.874]                     next
[10:19:22.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.874]                 }
[10:19:22.874]                 if (length(args) > 0) 
[10:19:22.874]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.874]             }
[10:19:22.874]             else {
[10:19:22.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.874]             }
[10:19:22.874]             {
[10:19:22.874]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.874]                   0L) {
[10:19:22.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.874]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.874]                   base::options(opts)
[10:19:22.874]                 }
[10:19:22.874]                 {
[10:19:22.874]                   {
[10:19:22.874]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.874]                     NULL
[10:19:22.874]                   }
[10:19:22.874]                   options(future.plan = NULL)
[10:19:22.874]                   if (is.na(NA_character_)) 
[10:19:22.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.874]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.874]                     .init = FALSE)
[10:19:22.874]                 }
[10:19:22.874]             }
[10:19:22.874]         }
[10:19:22.874]     })
[10:19:22.874]     if (TRUE) {
[10:19:22.874]         base::sink(type = "output", split = FALSE)
[10:19:22.874]         if (TRUE) {
[10:19:22.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.874]         }
[10:19:22.874]         else {
[10:19:22.874]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.874]         }
[10:19:22.874]         base::close(...future.stdout)
[10:19:22.874]         ...future.stdout <- NULL
[10:19:22.874]     }
[10:19:22.874]     ...future.result$conditions <- ...future.conditions
[10:19:22.874]     ...future.result$finished <- base::Sys.time()
[10:19:22.874]     ...future.result
[10:19:22.874] }
[10:19:22.877] assign_globals() ...
[10:19:22.877] List of 5
[10:19:22.877]  $ ...future.FUN            :function (x, y)  
[10:19:22.877]  $ MoreArgs                 :List of 1
[10:19:22.877]   ..$ y: int [1:2] 3 4
[10:19:22.877]  $ ...future.elements_ii    :List of 1
[10:19:22.877]   ..$ x:List of 1
[10:19:22.877]   .. ..$ : int 2
[10:19:22.877]  $ ...future.seeds_ii       : NULL
[10:19:22.877]  $ ...future.globals.maxSize: NULL
[10:19:22.877]  - attr(*, "where")=List of 5
[10:19:22.877]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.877]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.877]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.877]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.877]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.877]  - attr(*, "resolved")= logi FALSE
[10:19:22.877]  - attr(*, "total_size")= num 656
[10:19:22.877]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.877]  - attr(*, "already-done")= logi TRUE
[10:19:22.885] - reassign environment for ‘...future.FUN’
[10:19:22.885] - copied ‘...future.FUN’ to environment
[10:19:22.886] - copied ‘MoreArgs’ to environment
[10:19:22.886] - copied ‘...future.elements_ii’ to environment
[10:19:22.886] - copied ‘...future.seeds_ii’ to environment
[10:19:22.886] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.886] assign_globals() ... done
[10:19:22.886] requestCore(): workers = 2
[10:19:22.889] MulticoreFuture started
[10:19:22.889] - Launch lazy future ... done
[10:19:22.889] run() for ‘MulticoreFuture’ ... done
[10:19:22.890] Created future:
[10:19:22.890] plan(): Setting new future strategy stack:
[10:19:22.890] List of future strategies:
[10:19:22.890] 1. sequential:
[10:19:22.890]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.890]    - tweaked: FALSE
[10:19:22.890]    - call: NULL
[10:19:22.891] plan(): nbrOfWorkers() = 1
[10:19:22.893] plan(): Setting new future strategy stack:
[10:19:22.894] List of future strategies:
[10:19:22.894] 1. multicore:
[10:19:22.894]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.894]    - tweaked: FALSE
[10:19:22.894]    - call: plan(strategy)
[10:19:22.897] plan(): nbrOfWorkers() = 2
[10:19:22.890] MulticoreFuture:
[10:19:22.890] Label: ‘future_mapply-2’
[10:19:22.890] Expression:
[10:19:22.890] {
[10:19:22.890]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.890]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.890]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.890]         on.exit(options(oopts), add = TRUE)
[10:19:22.890]     }
[10:19:22.890]     {
[10:19:22.890]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:22.890]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.890]         do.call(mapply, args = args)
[10:19:22.890]     }
[10:19:22.890] }
[10:19:22.890] Lazy evaluation: FALSE
[10:19:22.890] Asynchronous evaluation: TRUE
[10:19:22.890] Local evaluation: TRUE
[10:19:22.890] Environment: R_GlobalEnv
[10:19:22.890] Capture standard output: TRUE
[10:19:22.890] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.890] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.890] Packages: <none>
[10:19:22.890] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:22.890] Resolved: TRUE
[10:19:22.890] Value: <not collected>
[10:19:22.890] Conditions captured: <none>
[10:19:22.890] Early signaling: FALSE
[10:19:22.890] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.890] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.898] Chunk #2 of 2 ... DONE
[10:19:22.898] Launching 2 futures (chunks) ... DONE
[10:19:22.898] Resolving 2 futures (chunks) ...
[10:19:22.898] resolve() on list ...
[10:19:22.898]  recursive: 0
[10:19:22.899]  length: 2
[10:19:22.899] 
[10:19:22.899] Future #1
[10:19:22.899] result() for MulticoreFuture ...
[10:19:22.900] result() for MulticoreFuture ...
[10:19:22.900] result() for MulticoreFuture ... done
[10:19:22.900] result() for MulticoreFuture ... done
[10:19:22.900] result() for MulticoreFuture ...
[10:19:22.901] result() for MulticoreFuture ... done
[10:19:22.901] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:22.901] - nx: 2
[10:19:22.901] - relay: TRUE
[10:19:22.901] - stdout: TRUE
[10:19:22.901] - signal: TRUE
[10:19:22.901] - resignal: FALSE
[10:19:22.902] - force: TRUE
[10:19:22.902] - relayed: [n=2] FALSE, FALSE
[10:19:22.902] - queued futures: [n=2] FALSE, FALSE
[10:19:22.902]  - until=1
[10:19:22.902]  - relaying element #1
[10:19:22.902] result() for MulticoreFuture ...
[10:19:22.902] result() for MulticoreFuture ... done
[10:19:22.903] result() for MulticoreFuture ...
[10:19:22.903] result() for MulticoreFuture ... done
[10:19:22.903] result() for MulticoreFuture ...
[10:19:22.903] result() for MulticoreFuture ... done
[10:19:22.903] result() for MulticoreFuture ...
[10:19:22.903] result() for MulticoreFuture ... done
[10:19:22.904] - relayed: [n=2] TRUE, FALSE
[10:19:22.904] - queued futures: [n=2] TRUE, FALSE
[10:19:22.904] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:22.904]  length: 1 (resolved future 1)
[10:19:22.904] Future #2
[10:19:22.905] result() for MulticoreFuture ...
[10:19:22.905] result() for MulticoreFuture ...
[10:19:22.906] result() for MulticoreFuture ... done
[10:19:22.906] result() for MulticoreFuture ... done
[10:19:22.906] result() for MulticoreFuture ...
[10:19:22.906] result() for MulticoreFuture ... done
[10:19:22.906] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:22.906] - nx: 2
[10:19:22.906] - relay: TRUE
[10:19:22.907] - stdout: TRUE
[10:19:22.907] - signal: TRUE
[10:19:22.907] - resignal: FALSE
[10:19:22.907] - force: TRUE
[10:19:22.907] - relayed: [n=2] TRUE, FALSE
[10:19:22.907] - queued futures: [n=2] TRUE, FALSE
[10:19:22.907]  - until=2
[10:19:22.907]  - relaying element #2
[10:19:22.908] result() for MulticoreFuture ...
[10:19:22.908] result() for MulticoreFuture ... done
[10:19:22.908] result() for MulticoreFuture ...
[10:19:22.908] result() for MulticoreFuture ... done
[10:19:22.908] result() for MulticoreFuture ...
[10:19:22.908] result() for MulticoreFuture ... done
[10:19:22.908] result() for MulticoreFuture ...
[10:19:22.908] result() for MulticoreFuture ... done
[10:19:22.909] - relayed: [n=2] TRUE, TRUE
[10:19:22.909] - queued futures: [n=2] TRUE, TRUE
[10:19:22.909] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:22.909]  length: 0 (resolved future 2)
[10:19:22.909] Relaying remaining futures
[10:19:22.909] signalConditionsASAP(NULL, pos=0) ...
[10:19:22.909] - nx: 2
[10:19:22.912] - relay: TRUE
[10:19:22.912] - stdout: TRUE
[10:19:22.913] - signal: TRUE
[10:19:22.913] - resignal: FALSE
[10:19:22.913] - force: TRUE
[10:19:22.913] - relayed: [n=2] TRUE, TRUE
[10:19:22.913] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:22.913] - relayed: [n=2] TRUE, TRUE
[10:19:22.914] - queued futures: [n=2] TRUE, TRUE
[10:19:22.914] signalConditionsASAP(NULL, pos=0) ... done
[10:19:22.914] resolve() on list ... DONE
[10:19:22.914] result() for MulticoreFuture ...
[10:19:22.914] result() for MulticoreFuture ... done
[10:19:22.915] result() for MulticoreFuture ...
[10:19:22.915] result() for MulticoreFuture ... done
[10:19:22.915] result() for MulticoreFuture ...
[10:19:22.915] result() for MulticoreFuture ... done
[10:19:22.915] result() for MulticoreFuture ...
[10:19:22.915] result() for MulticoreFuture ... done
[10:19:22.916]  - Number of value chunks collected: 2
[10:19:22.916] Resolving 2 futures (chunks) ... DONE
[10:19:22.916] Reducing values from 2 chunks ...
[10:19:22.916]  - Number of values collected after concatenation: 2
[10:19:22.916]  - Number of values expected: 2
[10:19:22.916] Reducing values from 2 chunks ... DONE
[10:19:22.917] future_mapply() ... DONE
[10:19:22.917] future_mapply() ...
[10:19:22.917] Generating random seeds ...
[10:19:22.917] Generating random seed streams for 2 elements ...
[10:19:22.917] Generating random seed streams for 2 elements ... DONE
[10:19:22.917] Generating random seeds ... DONE
[10:19:22.917] Will set RNG state on exit: 10407, -549175997, -232555833, 1490418050, -581190600, -867280384, 946656183
[10:19:22.920] Number of chunks: 2
[10:19:22.920] getGlobalsAndPackagesXApply() ...
[10:19:22.920]  - future.globals: TRUE
[10:19:22.920] getGlobalsAndPackages() ...
[10:19:22.921] Searching for globals...
[10:19:22.922] - globals found: [1] ‘FUN’
[10:19:22.922] Searching for globals ... DONE
[10:19:22.922] Resolving globals: FALSE
[10:19:22.923] The total size of the 1 globals is 326 bytes (326 bytes)
[10:19:22.923] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:19:22.923] - globals: [1] ‘FUN’
[10:19:22.924] 
[10:19:22.924] getGlobalsAndPackages() ... DONE
[10:19:22.924]  - globals found/used: [n=1] ‘FUN’
[10:19:22.924]  - needed namespaces: [n=0] 
[10:19:22.924] Finding globals ... DONE
[10:19:22.924] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:22.924] List of 2
[10:19:22.924]  $ ...future.FUN:function (x, y)  
[10:19:22.924]  $ MoreArgs     :List of 1
[10:19:22.924]   ..$ y: int [1:2] 3 4
[10:19:22.924]  - attr(*, "where")=List of 2
[10:19:22.924]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:22.924]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:22.924]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.924]  - attr(*, "resolved")= logi FALSE
[10:19:22.924]  - attr(*, "total_size")= num NA
[10:19:22.928] Packages to be attached in all futures: [n=0] 
[10:19:22.928] getGlobalsAndPackagesXApply() ... DONE
[10:19:22.928] Number of futures (= number of chunks): 2
[10:19:22.928] Launching 2 futures (chunks) ...
[10:19:22.928] Chunk #1 of 2 ...
[10:19:22.928]  - Finding globals in '...' for chunk #1 ...
[10:19:22.928] getGlobalsAndPackages() ...
[10:19:22.929] Searching for globals...
[10:19:22.929] 
[10:19:22.929] Searching for globals ... DONE
[10:19:22.929] - globals: [0] <none>
[10:19:22.929] getGlobalsAndPackages() ... DONE
[10:19:22.929]    + additional globals found: [n=0] 
[10:19:22.929]    + additional namespaces needed: [n=0] 
[10:19:22.929]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:22.929]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.930]  - seeds: [1] <seeds>
[10:19:22.930]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.930] getGlobalsAndPackages() ...
[10:19:22.930] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.930] Resolving globals: FALSE
[10:19:22.930] The total size of the 5 globals is 696 bytes (696 bytes)
[10:19:22.931] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:22.931] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.931] 
[10:19:22.931] getGlobalsAndPackages() ... DONE
[10:19:22.932] run() for ‘Future’ ...
[10:19:22.932] - state: ‘created’
[10:19:22.932] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.933] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.934] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.934]   - Field: ‘label’
[10:19:22.934]   - Field: ‘local’
[10:19:22.934]   - Field: ‘owner’
[10:19:22.934]   - Field: ‘envir’
[10:19:22.934]   - Field: ‘workers’
[10:19:22.934]   - Field: ‘packages’
[10:19:22.934]   - Field: ‘gc’
[10:19:22.934]   - Field: ‘job’
[10:19:22.934]   - Field: ‘conditions’
[10:19:22.935]   - Field: ‘expr’
[10:19:22.935]   - Field: ‘uuid’
[10:19:22.935]   - Field: ‘seed’
[10:19:22.935]   - Field: ‘version’
[10:19:22.935]   - Field: ‘result’
[10:19:22.935]   - Field: ‘asynchronous’
[10:19:22.935]   - Field: ‘calls’
[10:19:22.935]   - Field: ‘globals’
[10:19:22.935]   - Field: ‘stdout’
[10:19:22.935]   - Field: ‘earlySignal’
[10:19:22.935]   - Field: ‘lazy’
[10:19:22.935]   - Field: ‘state’
[10:19:22.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.936] - Launch lazy future ...
[10:19:22.936] Packages needed by the future expression (n = 0): <none>
[10:19:22.936] Packages needed by future strategies (n = 0): <none>
[10:19:22.939] {
[10:19:22.939]     {
[10:19:22.939]         {
[10:19:22.939]             ...future.startTime <- base::Sys.time()
[10:19:22.939]             {
[10:19:22.939]                 {
[10:19:22.939]                   {
[10:19:22.939]                     {
[10:19:22.939]                       base::local({
[10:19:22.939]                         has_future <- base::requireNamespace("future", 
[10:19:22.939]                           quietly = TRUE)
[10:19:22.939]                         if (has_future) {
[10:19:22.939]                           ns <- base::getNamespace("future")
[10:19:22.939]                           version <- ns[[".package"]][["version"]]
[10:19:22.939]                           if (is.null(version)) 
[10:19:22.939]                             version <- utils::packageVersion("future")
[10:19:22.939]                         }
[10:19:22.939]                         else {
[10:19:22.939]                           version <- NULL
[10:19:22.939]                         }
[10:19:22.939]                         if (!has_future || version < "1.8.0") {
[10:19:22.939]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.939]                             "", base::R.version$version.string), 
[10:19:22.939]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.939]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.939]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.939]                               "release", "version")], collapse = " "), 
[10:19:22.939]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.939]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.939]                             info)
[10:19:22.939]                           info <- base::paste(info, collapse = "; ")
[10:19:22.939]                           if (!has_future) {
[10:19:22.939]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.939]                               info)
[10:19:22.939]                           }
[10:19:22.939]                           else {
[10:19:22.939]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.939]                               info, version)
[10:19:22.939]                           }
[10:19:22.939]                           base::stop(msg)
[10:19:22.939]                         }
[10:19:22.939]                       })
[10:19:22.939]                     }
[10:19:22.939]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.939]                     base::options(mc.cores = 1L)
[10:19:22.939]                   }
[10:19:22.939]                   ...future.strategy.old <- future::plan("list")
[10:19:22.939]                   options(future.plan = NULL)
[10:19:22.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.939]                 }
[10:19:22.939]                 ...future.workdir <- getwd()
[10:19:22.939]             }
[10:19:22.939]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.939]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.939]         }
[10:19:22.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.939]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.939]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.939]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.939]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.939]             base::names(...future.oldOptions))
[10:19:22.939]     }
[10:19:22.939]     if (FALSE) {
[10:19:22.939]     }
[10:19:22.939]     else {
[10:19:22.939]         if (TRUE) {
[10:19:22.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.939]                 open = "w")
[10:19:22.939]         }
[10:19:22.939]         else {
[10:19:22.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.939]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.939]         }
[10:19:22.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.939]             base::sink(type = "output", split = FALSE)
[10:19:22.939]             base::close(...future.stdout)
[10:19:22.939]         }, add = TRUE)
[10:19:22.939]     }
[10:19:22.939]     ...future.frame <- base::sys.nframe()
[10:19:22.939]     ...future.conditions <- base::list()
[10:19:22.939]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.939]     if (FALSE) {
[10:19:22.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.939]     }
[10:19:22.939]     ...future.result <- base::tryCatch({
[10:19:22.939]         base::withCallingHandlers({
[10:19:22.939]             ...future.value <- base::withVisible(base::local({
[10:19:22.939]                 withCallingHandlers({
[10:19:22.939]                   {
[10:19:22.939]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.939]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.939]                       ...future.globals.maxSize)) {
[10:19:22.939]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.939]                       on.exit(options(oopts), add = TRUE)
[10:19:22.939]                     }
[10:19:22.939]                     {
[10:19:22.939]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:22.939]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:22.939]                           envir = globalenv(), inherits = FALSE)
[10:19:22.939]                         ...future.FUN(...)
[10:19:22.939]                       }
[10:19:22.939]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:22.939]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:22.939]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.939]                         USE.NAMES = FALSE)
[10:19:22.939]                       do.call(mapply, args = args)
[10:19:22.939]                     }
[10:19:22.939]                   }
[10:19:22.939]                 }, immediateCondition = function(cond) {
[10:19:22.939]                   save_rds <- function (object, pathname, ...) 
[10:19:22.939]                   {
[10:19:22.939]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.939]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.939]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.939]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.939]                         fi_tmp[["mtime"]])
[10:19:22.939]                     }
[10:19:22.939]                     tryCatch({
[10:19:22.939]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.939]                     }, error = function(ex) {
[10:19:22.939]                       msg <- conditionMessage(ex)
[10:19:22.939]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.939]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.939]                         fi_tmp[["mtime"]], msg)
[10:19:22.939]                       ex$message <- msg
[10:19:22.939]                       stop(ex)
[10:19:22.939]                     })
[10:19:22.939]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.939]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.939]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.939]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.939]                       fi <- file.info(pathname)
[10:19:22.939]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.939]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.939]                         fi[["size"]], fi[["mtime"]])
[10:19:22.939]                       stop(msg)
[10:19:22.939]                     }
[10:19:22.939]                     invisible(pathname)
[10:19:22.939]                   }
[10:19:22.939]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.939]                     rootPath = tempdir()) 
[10:19:22.939]                   {
[10:19:22.939]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.939]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.939]                       tmpdir = path, fileext = ".rds")
[10:19:22.939]                     save_rds(obj, file)
[10:19:22.939]                   }
[10:19:22.939]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.939]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.939]                   {
[10:19:22.939]                     inherits <- base::inherits
[10:19:22.939]                     invokeRestart <- base::invokeRestart
[10:19:22.939]                     is.null <- base::is.null
[10:19:22.939]                     muffled <- FALSE
[10:19:22.939]                     if (inherits(cond, "message")) {
[10:19:22.939]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.939]                       if (muffled) 
[10:19:22.939]                         invokeRestart("muffleMessage")
[10:19:22.939]                     }
[10:19:22.939]                     else if (inherits(cond, "warning")) {
[10:19:22.939]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.939]                       if (muffled) 
[10:19:22.939]                         invokeRestart("muffleWarning")
[10:19:22.939]                     }
[10:19:22.939]                     else if (inherits(cond, "condition")) {
[10:19:22.939]                       if (!is.null(pattern)) {
[10:19:22.939]                         computeRestarts <- base::computeRestarts
[10:19:22.939]                         grepl <- base::grepl
[10:19:22.939]                         restarts <- computeRestarts(cond)
[10:19:22.939]                         for (restart in restarts) {
[10:19:22.939]                           name <- restart$name
[10:19:22.939]                           if (is.null(name)) 
[10:19:22.939]                             next
[10:19:22.939]                           if (!grepl(pattern, name)) 
[10:19:22.939]                             next
[10:19:22.939]                           invokeRestart(restart)
[10:19:22.939]                           muffled <- TRUE
[10:19:22.939]                           break
[10:19:22.939]                         }
[10:19:22.939]                       }
[10:19:22.939]                     }
[10:19:22.939]                     invisible(muffled)
[10:19:22.939]                   }
[10:19:22.939]                   muffleCondition(cond)
[10:19:22.939]                 })
[10:19:22.939]             }))
[10:19:22.939]             future::FutureResult(value = ...future.value$value, 
[10:19:22.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.939]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.939]                     ...future.globalenv.names))
[10:19:22.939]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.939]         }, condition = base::local({
[10:19:22.939]             c <- base::c
[10:19:22.939]             inherits <- base::inherits
[10:19:22.939]             invokeRestart <- base::invokeRestart
[10:19:22.939]             length <- base::length
[10:19:22.939]             list <- base::list
[10:19:22.939]             seq.int <- base::seq.int
[10:19:22.939]             signalCondition <- base::signalCondition
[10:19:22.939]             sys.calls <- base::sys.calls
[10:19:22.939]             `[[` <- base::`[[`
[10:19:22.939]             `+` <- base::`+`
[10:19:22.939]             `<<-` <- base::`<<-`
[10:19:22.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.939]                   3L)]
[10:19:22.939]             }
[10:19:22.939]             function(cond) {
[10:19:22.939]                 is_error <- inherits(cond, "error")
[10:19:22.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.939]                   NULL)
[10:19:22.939]                 if (is_error) {
[10:19:22.939]                   sessionInformation <- function() {
[10:19:22.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.939]                       search = base::search(), system = base::Sys.info())
[10:19:22.939]                   }
[10:19:22.939]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.939]                     cond$call), session = sessionInformation(), 
[10:19:22.939]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.939]                   signalCondition(cond)
[10:19:22.939]                 }
[10:19:22.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.939]                 "immediateCondition"))) {
[10:19:22.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.939]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.939]                   if (TRUE && !signal) {
[10:19:22.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.939]                     {
[10:19:22.939]                       inherits <- base::inherits
[10:19:22.939]                       invokeRestart <- base::invokeRestart
[10:19:22.939]                       is.null <- base::is.null
[10:19:22.939]                       muffled <- FALSE
[10:19:22.939]                       if (inherits(cond, "message")) {
[10:19:22.939]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.939]                         if (muffled) 
[10:19:22.939]                           invokeRestart("muffleMessage")
[10:19:22.939]                       }
[10:19:22.939]                       else if (inherits(cond, "warning")) {
[10:19:22.939]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.939]                         if (muffled) 
[10:19:22.939]                           invokeRestart("muffleWarning")
[10:19:22.939]                       }
[10:19:22.939]                       else if (inherits(cond, "condition")) {
[10:19:22.939]                         if (!is.null(pattern)) {
[10:19:22.939]                           computeRestarts <- base::computeRestarts
[10:19:22.939]                           grepl <- base::grepl
[10:19:22.939]                           restarts <- computeRestarts(cond)
[10:19:22.939]                           for (restart in restarts) {
[10:19:22.939]                             name <- restart$name
[10:19:22.939]                             if (is.null(name)) 
[10:19:22.939]                               next
[10:19:22.939]                             if (!grepl(pattern, name)) 
[10:19:22.939]                               next
[10:19:22.939]                             invokeRestart(restart)
[10:19:22.939]                             muffled <- TRUE
[10:19:22.939]                             break
[10:19:22.939]                           }
[10:19:22.939]                         }
[10:19:22.939]                       }
[10:19:22.939]                       invisible(muffled)
[10:19:22.939]                     }
[10:19:22.939]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.939]                   }
[10:19:22.939]                 }
[10:19:22.939]                 else {
[10:19:22.939]                   if (TRUE) {
[10:19:22.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.939]                     {
[10:19:22.939]                       inherits <- base::inherits
[10:19:22.939]                       invokeRestart <- base::invokeRestart
[10:19:22.939]                       is.null <- base::is.null
[10:19:22.939]                       muffled <- FALSE
[10:19:22.939]                       if (inherits(cond, "message")) {
[10:19:22.939]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.939]                         if (muffled) 
[10:19:22.939]                           invokeRestart("muffleMessage")
[10:19:22.939]                       }
[10:19:22.939]                       else if (inherits(cond, "warning")) {
[10:19:22.939]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.939]                         if (muffled) 
[10:19:22.939]                           invokeRestart("muffleWarning")
[10:19:22.939]                       }
[10:19:22.939]                       else if (inherits(cond, "condition")) {
[10:19:22.939]                         if (!is.null(pattern)) {
[10:19:22.939]                           computeRestarts <- base::computeRestarts
[10:19:22.939]                           grepl <- base::grepl
[10:19:22.939]                           restarts <- computeRestarts(cond)
[10:19:22.939]                           for (restart in restarts) {
[10:19:22.939]                             name <- restart$name
[10:19:22.939]                             if (is.null(name)) 
[10:19:22.939]                               next
[10:19:22.939]                             if (!grepl(pattern, name)) 
[10:19:22.939]                               next
[10:19:22.939]                             invokeRestart(restart)
[10:19:22.939]                             muffled <- TRUE
[10:19:22.939]                             break
[10:19:22.939]                           }
[10:19:22.939]                         }
[10:19:22.939]                       }
[10:19:22.939]                       invisible(muffled)
[10:19:22.939]                     }
[10:19:22.939]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.939]                   }
[10:19:22.939]                 }
[10:19:22.939]             }
[10:19:22.939]         }))
[10:19:22.939]     }, error = function(ex) {
[10:19:22.939]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.939]                 ...future.rng), started = ...future.startTime, 
[10:19:22.939]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.939]             version = "1.8"), class = "FutureResult")
[10:19:22.939]     }, finally = {
[10:19:22.939]         if (!identical(...future.workdir, getwd())) 
[10:19:22.939]             setwd(...future.workdir)
[10:19:22.939]         {
[10:19:22.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.939]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.939]             }
[10:19:22.939]             base::options(...future.oldOptions)
[10:19:22.939]             if (.Platform$OS.type == "windows") {
[10:19:22.939]                 old_names <- names(...future.oldEnvVars)
[10:19:22.939]                 envs <- base::Sys.getenv()
[10:19:22.939]                 names <- names(envs)
[10:19:22.939]                 common <- intersect(names, old_names)
[10:19:22.939]                 added <- setdiff(names, old_names)
[10:19:22.939]                 removed <- setdiff(old_names, names)
[10:19:22.939]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.939]                   envs[common]]
[10:19:22.939]                 NAMES <- toupper(changed)
[10:19:22.939]                 args <- list()
[10:19:22.939]                 for (kk in seq_along(NAMES)) {
[10:19:22.939]                   name <- changed[[kk]]
[10:19:22.939]                   NAME <- NAMES[[kk]]
[10:19:22.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.939]                     next
[10:19:22.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.939]                 }
[10:19:22.939]                 NAMES <- toupper(added)
[10:19:22.939]                 for (kk in seq_along(NAMES)) {
[10:19:22.939]                   name <- added[[kk]]
[10:19:22.939]                   NAME <- NAMES[[kk]]
[10:19:22.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.939]                     next
[10:19:22.939]                   args[[name]] <- ""
[10:19:22.939]                 }
[10:19:22.939]                 NAMES <- toupper(removed)
[10:19:22.939]                 for (kk in seq_along(NAMES)) {
[10:19:22.939]                   name <- removed[[kk]]
[10:19:22.939]                   NAME <- NAMES[[kk]]
[10:19:22.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.939]                     next
[10:19:22.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.939]                 }
[10:19:22.939]                 if (length(args) > 0) 
[10:19:22.939]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.939]             }
[10:19:22.939]             else {
[10:19:22.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.939]             }
[10:19:22.939]             {
[10:19:22.939]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.939]                   0L) {
[10:19:22.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.939]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.939]                   base::options(opts)
[10:19:22.939]                 }
[10:19:22.939]                 {
[10:19:22.939]                   {
[10:19:22.939]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.939]                     NULL
[10:19:22.939]                   }
[10:19:22.939]                   options(future.plan = NULL)
[10:19:22.939]                   if (is.na(NA_character_)) 
[10:19:22.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.939]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.939]                     .init = FALSE)
[10:19:22.939]                 }
[10:19:22.939]             }
[10:19:22.939]         }
[10:19:22.939]     })
[10:19:22.939]     if (TRUE) {
[10:19:22.939]         base::sink(type = "output", split = FALSE)
[10:19:22.939]         if (TRUE) {
[10:19:22.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.939]         }
[10:19:22.939]         else {
[10:19:22.939]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.939]         }
[10:19:22.939]         base::close(...future.stdout)
[10:19:22.939]         ...future.stdout <- NULL
[10:19:22.939]     }
[10:19:22.939]     ...future.result$conditions <- ...future.conditions
[10:19:22.939]     ...future.result$finished <- base::Sys.time()
[10:19:22.939]     ...future.result
[10:19:22.939] }
[10:19:22.941] assign_globals() ...
[10:19:22.941] List of 5
[10:19:22.941]  $ ...future.FUN            :function (x, y)  
[10:19:22.941]  $ MoreArgs                 :List of 1
[10:19:22.941]   ..$ y: int [1:2] 3 4
[10:19:22.941]  $ ...future.elements_ii    :List of 1
[10:19:22.941]   ..$ x:List of 1
[10:19:22.941]   .. ..$ : int 1
[10:19:22.941]  $ ...future.seeds_ii       :List of 1
[10:19:22.941]   ..$ : int [1:7] 10407 -2071481005 1163498513 1317974871 766601402 -1701250117 1359550312
[10:19:22.941]  $ ...future.globals.maxSize: NULL
[10:19:22.941]  - attr(*, "where")=List of 5
[10:19:22.941]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.941]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.941]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.941]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.941]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.941]  - attr(*, "resolved")= logi FALSE
[10:19:22.941]  - attr(*, "total_size")= num 696
[10:19:22.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.941]  - attr(*, "already-done")= logi TRUE
[10:19:22.948] - reassign environment for ‘...future.FUN’
[10:19:22.948] - copied ‘...future.FUN’ to environment
[10:19:22.948] - copied ‘MoreArgs’ to environment
[10:19:22.948] - copied ‘...future.elements_ii’ to environment
[10:19:22.948] - copied ‘...future.seeds_ii’ to environment
[10:19:22.948] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.948] assign_globals() ... done
[10:19:22.948] requestCore(): workers = 2
[10:19:22.951] MulticoreFuture started
[10:19:22.951] - Launch lazy future ... done
[10:19:22.952] run() for ‘MulticoreFuture’ ... done
[10:19:22.952] plan(): Setting new future strategy stack:
[10:19:22.952] Created future:
[10:19:22.952] List of future strategies:
[10:19:22.952] 1. sequential:
[10:19:22.952]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.952]    - tweaked: FALSE
[10:19:22.952]    - call: NULL
[10:19:22.953] plan(): nbrOfWorkers() = 1
[10:19:22.956] plan(): Setting new future strategy stack:
[10:19:22.956] List of future strategies:
[10:19:22.956] 1. multicore:
[10:19:22.956]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:22.956]    - tweaked: FALSE
[10:19:22.956]    - call: plan(strategy)
[10:19:22.960] plan(): nbrOfWorkers() = 2
[10:19:22.952] MulticoreFuture:
[10:19:22.952] Label: ‘future_mapply-1’
[10:19:22.952] Expression:
[10:19:22.952] {
[10:19:22.952]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.952]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.952]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.952]         on.exit(options(oopts), add = TRUE)
[10:19:22.952]     }
[10:19:22.952]     {
[10:19:22.952]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:22.952]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:22.952]                 inherits = FALSE)
[10:19:22.952]             ...future.FUN(...)
[10:19:22.952]         }
[10:19:22.952]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:22.952]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:22.952]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.952]         do.call(mapply, args = args)
[10:19:22.952]     }
[10:19:22.952] }
[10:19:22.952] Lazy evaluation: FALSE
[10:19:22.952] Asynchronous evaluation: TRUE
[10:19:22.952] Local evaluation: TRUE
[10:19:22.952] Environment: R_GlobalEnv
[10:19:22.952] Capture standard output: TRUE
[10:19:22.952] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.952] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.952] Packages: <none>
[10:19:22.952] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:22.952] Resolved: TRUE
[10:19:22.952] Value: <not collected>
[10:19:22.952] Conditions captured: <none>
[10:19:22.952] Early signaling: FALSE
[10:19:22.952] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.952] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.961] Chunk #1 of 2 ... DONE
[10:19:22.961] Chunk #2 of 2 ...
[10:19:22.962]  - Finding globals in '...' for chunk #2 ...
[10:19:22.962] getGlobalsAndPackages() ...
[10:19:22.962] Searching for globals...
[10:19:22.963] 
[10:19:22.963] Searching for globals ... DONE
[10:19:22.963] - globals: [0] <none>
[10:19:22.963] getGlobalsAndPackages() ... DONE
[10:19:22.963]    + additional globals found: [n=0] 
[10:19:22.963]    + additional namespaces needed: [n=0] 
[10:19:22.963]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:22.964]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:22.964]  - seeds: [1] <seeds>
[10:19:22.964]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.964] getGlobalsAndPackages() ...
[10:19:22.964] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.965] Resolving globals: FALSE
[10:19:22.965] The total size of the 5 globals is 696 bytes (696 bytes)
[10:19:22.966] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:22.966] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:22.966] 
[10:19:22.967] getGlobalsAndPackages() ... DONE
[10:19:22.967] run() for ‘Future’ ...
[10:19:22.967] - state: ‘created’
[10:19:22.967] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:22.970] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:22.970] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:22.970]   - Field: ‘label’
[10:19:22.970]   - Field: ‘local’
[10:19:22.970]   - Field: ‘owner’
[10:19:22.971]   - Field: ‘envir’
[10:19:22.971]   - Field: ‘workers’
[10:19:22.971]   - Field: ‘packages’
[10:19:22.971]   - Field: ‘gc’
[10:19:22.971]   - Field: ‘job’
[10:19:22.971]   - Field: ‘conditions’
[10:19:22.971]   - Field: ‘expr’
[10:19:22.972]   - Field: ‘uuid’
[10:19:22.972]   - Field: ‘seed’
[10:19:22.972]   - Field: ‘version’
[10:19:22.972]   - Field: ‘result’
[10:19:22.972]   - Field: ‘asynchronous’
[10:19:22.972]   - Field: ‘calls’
[10:19:22.972]   - Field: ‘globals’
[10:19:22.973]   - Field: ‘stdout’
[10:19:22.973]   - Field: ‘earlySignal’
[10:19:22.973]   - Field: ‘lazy’
[10:19:22.973]   - Field: ‘state’
[10:19:22.973] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:22.973] - Launch lazy future ...
[10:19:22.974] Packages needed by the future expression (n = 0): <none>
[10:19:22.974] Packages needed by future strategies (n = 0): <none>
[10:19:22.975] {
[10:19:22.975]     {
[10:19:22.975]         {
[10:19:22.975]             ...future.startTime <- base::Sys.time()
[10:19:22.975]             {
[10:19:22.975]                 {
[10:19:22.975]                   {
[10:19:22.975]                     {
[10:19:22.975]                       base::local({
[10:19:22.975]                         has_future <- base::requireNamespace("future", 
[10:19:22.975]                           quietly = TRUE)
[10:19:22.975]                         if (has_future) {
[10:19:22.975]                           ns <- base::getNamespace("future")
[10:19:22.975]                           version <- ns[[".package"]][["version"]]
[10:19:22.975]                           if (is.null(version)) 
[10:19:22.975]                             version <- utils::packageVersion("future")
[10:19:22.975]                         }
[10:19:22.975]                         else {
[10:19:22.975]                           version <- NULL
[10:19:22.975]                         }
[10:19:22.975]                         if (!has_future || version < "1.8.0") {
[10:19:22.975]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:22.975]                             "", base::R.version$version.string), 
[10:19:22.975]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:22.975]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:22.975]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:22.975]                               "release", "version")], collapse = " "), 
[10:19:22.975]                             hostname = base::Sys.info()[["nodename"]])
[10:19:22.975]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:22.975]                             info)
[10:19:22.975]                           info <- base::paste(info, collapse = "; ")
[10:19:22.975]                           if (!has_future) {
[10:19:22.975]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:22.975]                               info)
[10:19:22.975]                           }
[10:19:22.975]                           else {
[10:19:22.975]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:22.975]                               info, version)
[10:19:22.975]                           }
[10:19:22.975]                           base::stop(msg)
[10:19:22.975]                         }
[10:19:22.975]                       })
[10:19:22.975]                     }
[10:19:22.975]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:22.975]                     base::options(mc.cores = 1L)
[10:19:22.975]                   }
[10:19:22.975]                   ...future.strategy.old <- future::plan("list")
[10:19:22.975]                   options(future.plan = NULL)
[10:19:22.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:22.975]                 }
[10:19:22.975]                 ...future.workdir <- getwd()
[10:19:22.975]             }
[10:19:22.975]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:22.975]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:22.975]         }
[10:19:22.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:22.975]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:22.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:22.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:22.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:22.975]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:22.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:22.975]             base::names(...future.oldOptions))
[10:19:22.975]     }
[10:19:22.975]     if (FALSE) {
[10:19:22.975]     }
[10:19:22.975]     else {
[10:19:22.975]         if (TRUE) {
[10:19:22.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:22.975]                 open = "w")
[10:19:22.975]         }
[10:19:22.975]         else {
[10:19:22.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:22.975]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:22.975]         }
[10:19:22.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:22.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:22.975]             base::sink(type = "output", split = FALSE)
[10:19:22.975]             base::close(...future.stdout)
[10:19:22.975]         }, add = TRUE)
[10:19:22.975]     }
[10:19:22.975]     ...future.frame <- base::sys.nframe()
[10:19:22.975]     ...future.conditions <- base::list()
[10:19:22.975]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:22.975]     if (FALSE) {
[10:19:22.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:22.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:22.975]     }
[10:19:22.975]     ...future.result <- base::tryCatch({
[10:19:22.975]         base::withCallingHandlers({
[10:19:22.975]             ...future.value <- base::withVisible(base::local({
[10:19:22.975]                 withCallingHandlers({
[10:19:22.975]                   {
[10:19:22.975]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.975]                     if (!identical(...future.globals.maxSize.org, 
[10:19:22.975]                       ...future.globals.maxSize)) {
[10:19:22.975]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.975]                       on.exit(options(oopts), add = TRUE)
[10:19:22.975]                     }
[10:19:22.975]                     {
[10:19:22.975]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:22.975]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:22.975]                           envir = globalenv(), inherits = FALSE)
[10:19:22.975]                         ...future.FUN(...)
[10:19:22.975]                       }
[10:19:22.975]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:22.975]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:22.975]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:22.975]                         USE.NAMES = FALSE)
[10:19:22.975]                       do.call(mapply, args = args)
[10:19:22.975]                     }
[10:19:22.975]                   }
[10:19:22.975]                 }, immediateCondition = function(cond) {
[10:19:22.975]                   save_rds <- function (object, pathname, ...) 
[10:19:22.975]                   {
[10:19:22.975]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:22.975]                     if (file_test("-f", pathname_tmp)) {
[10:19:22.975]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.975]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:22.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.975]                         fi_tmp[["mtime"]])
[10:19:22.975]                     }
[10:19:22.975]                     tryCatch({
[10:19:22.975]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:22.975]                     }, error = function(ex) {
[10:19:22.975]                       msg <- conditionMessage(ex)
[10:19:22.975]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.975]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:22.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.975]                         fi_tmp[["mtime"]], msg)
[10:19:22.975]                       ex$message <- msg
[10:19:22.975]                       stop(ex)
[10:19:22.975]                     })
[10:19:22.975]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:22.975]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:22.975]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:22.975]                       fi_tmp <- file.info(pathname_tmp)
[10:19:22.975]                       fi <- file.info(pathname)
[10:19:22.975]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:22.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:22.975]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:22.975]                         fi[["size"]], fi[["mtime"]])
[10:19:22.975]                       stop(msg)
[10:19:22.975]                     }
[10:19:22.975]                     invisible(pathname)
[10:19:22.975]                   }
[10:19:22.975]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:22.975]                     rootPath = tempdir()) 
[10:19:22.975]                   {
[10:19:22.975]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:22.975]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:22.975]                       tmpdir = path, fileext = ".rds")
[10:19:22.975]                     save_rds(obj, file)
[10:19:22.975]                   }
[10:19:22.975]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:22.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.975]                   {
[10:19:22.975]                     inherits <- base::inherits
[10:19:22.975]                     invokeRestart <- base::invokeRestart
[10:19:22.975]                     is.null <- base::is.null
[10:19:22.975]                     muffled <- FALSE
[10:19:22.975]                     if (inherits(cond, "message")) {
[10:19:22.975]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:22.975]                       if (muffled) 
[10:19:22.975]                         invokeRestart("muffleMessage")
[10:19:22.975]                     }
[10:19:22.975]                     else if (inherits(cond, "warning")) {
[10:19:22.975]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:22.975]                       if (muffled) 
[10:19:22.975]                         invokeRestart("muffleWarning")
[10:19:22.975]                     }
[10:19:22.975]                     else if (inherits(cond, "condition")) {
[10:19:22.975]                       if (!is.null(pattern)) {
[10:19:22.975]                         computeRestarts <- base::computeRestarts
[10:19:22.975]                         grepl <- base::grepl
[10:19:22.975]                         restarts <- computeRestarts(cond)
[10:19:22.975]                         for (restart in restarts) {
[10:19:22.975]                           name <- restart$name
[10:19:22.975]                           if (is.null(name)) 
[10:19:22.975]                             next
[10:19:22.975]                           if (!grepl(pattern, name)) 
[10:19:22.975]                             next
[10:19:22.975]                           invokeRestart(restart)
[10:19:22.975]                           muffled <- TRUE
[10:19:22.975]                           break
[10:19:22.975]                         }
[10:19:22.975]                       }
[10:19:22.975]                     }
[10:19:22.975]                     invisible(muffled)
[10:19:22.975]                   }
[10:19:22.975]                   muffleCondition(cond)
[10:19:22.975]                 })
[10:19:22.975]             }))
[10:19:22.975]             future::FutureResult(value = ...future.value$value, 
[10:19:22.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.975]                   ...future.rng), globalenv = if (FALSE) 
[10:19:22.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:22.975]                     ...future.globalenv.names))
[10:19:22.975]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:22.975]         }, condition = base::local({
[10:19:22.975]             c <- base::c
[10:19:22.975]             inherits <- base::inherits
[10:19:22.975]             invokeRestart <- base::invokeRestart
[10:19:22.975]             length <- base::length
[10:19:22.975]             list <- base::list
[10:19:22.975]             seq.int <- base::seq.int
[10:19:22.975]             signalCondition <- base::signalCondition
[10:19:22.975]             sys.calls <- base::sys.calls
[10:19:22.975]             `[[` <- base::`[[`
[10:19:22.975]             `+` <- base::`+`
[10:19:22.975]             `<<-` <- base::`<<-`
[10:19:22.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:22.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:22.975]                   3L)]
[10:19:22.975]             }
[10:19:22.975]             function(cond) {
[10:19:22.975]                 is_error <- inherits(cond, "error")
[10:19:22.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:22.975]                   NULL)
[10:19:22.975]                 if (is_error) {
[10:19:22.975]                   sessionInformation <- function() {
[10:19:22.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:22.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:22.975]                       search = base::search(), system = base::Sys.info())
[10:19:22.975]                   }
[10:19:22.975]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:22.975]                     cond$call), session = sessionInformation(), 
[10:19:22.975]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:22.975]                   signalCondition(cond)
[10:19:22.975]                 }
[10:19:22.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:22.975]                 "immediateCondition"))) {
[10:19:22.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:22.975]                   ...future.conditions[[length(...future.conditions) + 
[10:19:22.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:22.975]                   if (TRUE && !signal) {
[10:19:22.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.975]                     {
[10:19:22.975]                       inherits <- base::inherits
[10:19:22.975]                       invokeRestart <- base::invokeRestart
[10:19:22.975]                       is.null <- base::is.null
[10:19:22.975]                       muffled <- FALSE
[10:19:22.975]                       if (inherits(cond, "message")) {
[10:19:22.975]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.975]                         if (muffled) 
[10:19:22.975]                           invokeRestart("muffleMessage")
[10:19:22.975]                       }
[10:19:22.975]                       else if (inherits(cond, "warning")) {
[10:19:22.975]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.975]                         if (muffled) 
[10:19:22.975]                           invokeRestart("muffleWarning")
[10:19:22.975]                       }
[10:19:22.975]                       else if (inherits(cond, "condition")) {
[10:19:22.975]                         if (!is.null(pattern)) {
[10:19:22.975]                           computeRestarts <- base::computeRestarts
[10:19:22.975]                           grepl <- base::grepl
[10:19:22.975]                           restarts <- computeRestarts(cond)
[10:19:22.975]                           for (restart in restarts) {
[10:19:22.975]                             name <- restart$name
[10:19:22.975]                             if (is.null(name)) 
[10:19:22.975]                               next
[10:19:22.975]                             if (!grepl(pattern, name)) 
[10:19:22.975]                               next
[10:19:22.975]                             invokeRestart(restart)
[10:19:22.975]                             muffled <- TRUE
[10:19:22.975]                             break
[10:19:22.975]                           }
[10:19:22.975]                         }
[10:19:22.975]                       }
[10:19:22.975]                       invisible(muffled)
[10:19:22.975]                     }
[10:19:22.975]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.975]                   }
[10:19:22.975]                 }
[10:19:22.975]                 else {
[10:19:22.975]                   if (TRUE) {
[10:19:22.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:22.975]                     {
[10:19:22.975]                       inherits <- base::inherits
[10:19:22.975]                       invokeRestart <- base::invokeRestart
[10:19:22.975]                       is.null <- base::is.null
[10:19:22.975]                       muffled <- FALSE
[10:19:22.975]                       if (inherits(cond, "message")) {
[10:19:22.975]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:22.975]                         if (muffled) 
[10:19:22.975]                           invokeRestart("muffleMessage")
[10:19:22.975]                       }
[10:19:22.975]                       else if (inherits(cond, "warning")) {
[10:19:22.975]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:22.975]                         if (muffled) 
[10:19:22.975]                           invokeRestart("muffleWarning")
[10:19:22.975]                       }
[10:19:22.975]                       else if (inherits(cond, "condition")) {
[10:19:22.975]                         if (!is.null(pattern)) {
[10:19:22.975]                           computeRestarts <- base::computeRestarts
[10:19:22.975]                           grepl <- base::grepl
[10:19:22.975]                           restarts <- computeRestarts(cond)
[10:19:22.975]                           for (restart in restarts) {
[10:19:22.975]                             name <- restart$name
[10:19:22.975]                             if (is.null(name)) 
[10:19:22.975]                               next
[10:19:22.975]                             if (!grepl(pattern, name)) 
[10:19:22.975]                               next
[10:19:22.975]                             invokeRestart(restart)
[10:19:22.975]                             muffled <- TRUE
[10:19:22.975]                             break
[10:19:22.975]                           }
[10:19:22.975]                         }
[10:19:22.975]                       }
[10:19:22.975]                       invisible(muffled)
[10:19:22.975]                     }
[10:19:22.975]                     muffleCondition(cond, pattern = "^muffle")
[10:19:22.975]                   }
[10:19:22.975]                 }
[10:19:22.975]             }
[10:19:22.975]         }))
[10:19:22.975]     }, error = function(ex) {
[10:19:22.975]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:22.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:22.975]                 ...future.rng), started = ...future.startTime, 
[10:19:22.975]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:22.975]             version = "1.8"), class = "FutureResult")
[10:19:22.975]     }, finally = {
[10:19:22.975]         if (!identical(...future.workdir, getwd())) 
[10:19:22.975]             setwd(...future.workdir)
[10:19:22.975]         {
[10:19:22.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:22.975]                 ...future.oldOptions$nwarnings <- NULL
[10:19:22.975]             }
[10:19:22.975]             base::options(...future.oldOptions)
[10:19:22.975]             if (.Platform$OS.type == "windows") {
[10:19:22.975]                 old_names <- names(...future.oldEnvVars)
[10:19:22.975]                 envs <- base::Sys.getenv()
[10:19:22.975]                 names <- names(envs)
[10:19:22.975]                 common <- intersect(names, old_names)
[10:19:22.975]                 added <- setdiff(names, old_names)
[10:19:22.975]                 removed <- setdiff(old_names, names)
[10:19:22.975]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:22.975]                   envs[common]]
[10:19:22.975]                 NAMES <- toupper(changed)
[10:19:22.975]                 args <- list()
[10:19:22.975]                 for (kk in seq_along(NAMES)) {
[10:19:22.975]                   name <- changed[[kk]]
[10:19:22.975]                   NAME <- NAMES[[kk]]
[10:19:22.975]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.975]                     next
[10:19:22.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.975]                 }
[10:19:22.975]                 NAMES <- toupper(added)
[10:19:22.975]                 for (kk in seq_along(NAMES)) {
[10:19:22.975]                   name <- added[[kk]]
[10:19:22.975]                   NAME <- NAMES[[kk]]
[10:19:22.975]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.975]                     next
[10:19:22.975]                   args[[name]] <- ""
[10:19:22.975]                 }
[10:19:22.975]                 NAMES <- toupper(removed)
[10:19:22.975]                 for (kk in seq_along(NAMES)) {
[10:19:22.975]                   name <- removed[[kk]]
[10:19:22.975]                   NAME <- NAMES[[kk]]
[10:19:22.975]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:22.975]                     next
[10:19:22.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:22.975]                 }
[10:19:22.975]                 if (length(args) > 0) 
[10:19:22.975]                   base::do.call(base::Sys.setenv, args = args)
[10:19:22.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:22.975]             }
[10:19:22.975]             else {
[10:19:22.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:22.975]             }
[10:19:22.975]             {
[10:19:22.975]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:22.975]                   0L) {
[10:19:22.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:22.975]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:22.975]                   base::options(opts)
[10:19:22.975]                 }
[10:19:22.975]                 {
[10:19:22.975]                   {
[10:19:22.975]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:22.975]                     NULL
[10:19:22.975]                   }
[10:19:22.975]                   options(future.plan = NULL)
[10:19:22.975]                   if (is.na(NA_character_)) 
[10:19:22.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:22.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:22.975]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:22.975]                     .init = FALSE)
[10:19:22.975]                 }
[10:19:22.975]             }
[10:19:22.975]         }
[10:19:22.975]     })
[10:19:22.975]     if (TRUE) {
[10:19:22.975]         base::sink(type = "output", split = FALSE)
[10:19:22.975]         if (TRUE) {
[10:19:22.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:22.975]         }
[10:19:22.975]         else {
[10:19:22.975]             ...future.result["stdout"] <- base::list(NULL)
[10:19:22.975]         }
[10:19:22.975]         base::close(...future.stdout)
[10:19:22.975]         ...future.stdout <- NULL
[10:19:22.975]     }
[10:19:22.975]     ...future.result$conditions <- ...future.conditions
[10:19:22.975]     ...future.result$finished <- base::Sys.time()
[10:19:22.975]     ...future.result
[10:19:22.975] }
[10:19:22.978] assign_globals() ...
[10:19:22.978] List of 5
[10:19:22.978]  $ ...future.FUN            :function (x, y)  
[10:19:22.978]  $ MoreArgs                 :List of 1
[10:19:22.978]   ..$ y: int [1:2] 3 4
[10:19:22.978]  $ ...future.elements_ii    :List of 1
[10:19:22.978]   ..$ x:List of 1
[10:19:22.978]   .. ..$ : int 2
[10:19:22.978]  $ ...future.seeds_ii       :List of 1
[10:19:22.978]   ..$ : int [1:7] 10407 490025702 628450387 -323446155 1051938252 1723416212 64290390
[10:19:22.978]  $ ...future.globals.maxSize: NULL
[10:19:22.978]  - attr(*, "where")=List of 5
[10:19:22.978]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:22.978]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:22.978]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:22.978]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:22.978]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:22.978]  - attr(*, "resolved")= logi FALSE
[10:19:22.978]  - attr(*, "total_size")= num 696
[10:19:22.978]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:22.978]  - attr(*, "already-done")= logi TRUE
[10:19:22.991] - reassign environment for ‘...future.FUN’
[10:19:22.992] - copied ‘...future.FUN’ to environment
[10:19:22.992] - copied ‘MoreArgs’ to environment
[10:19:22.992] - copied ‘...future.elements_ii’ to environment
[10:19:22.992] - copied ‘...future.seeds_ii’ to environment
[10:19:22.992] - copied ‘...future.globals.maxSize’ to environment
[10:19:22.992] assign_globals() ... done
[10:19:22.992] requestCore(): workers = 2
[10:19:22.995] MulticoreFuture started
[10:19:22.996] - Launch lazy future ... done
[10:19:22.996] plan(): Setting new future strategy stack:
[10:19:22.996] run() for ‘MulticoreFuture’ ... done
[10:19:22.997] Created future:
[10:19:22.997] List of future strategies:
[10:19:22.997] 1. sequential:
[10:19:22.997]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:22.997]    - tweaked: FALSE
[10:19:22.997]    - call: NULL
[10:19:22.998] plan(): nbrOfWorkers() = 1
[10:19:23.002] plan(): Setting new future strategy stack:
[10:19:23.002] List of future strategies:
[10:19:23.002] 1. multicore:
[10:19:23.002]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.002]    - tweaked: FALSE
[10:19:23.002]    - call: plan(strategy)
[10:19:23.006] plan(): nbrOfWorkers() = 2
[10:19:22.997] MulticoreFuture:
[10:19:22.997] Label: ‘future_mapply-2’
[10:19:22.997] Expression:
[10:19:22.997] {
[10:19:22.997]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:22.997]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:22.997]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:22.997]         on.exit(options(oopts), add = TRUE)
[10:19:22.997]     }
[10:19:22.997]     {
[10:19:22.997]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:22.997]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:22.997]                 inherits = FALSE)
[10:19:22.997]             ...future.FUN(...)
[10:19:22.997]         }
[10:19:22.997]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:22.997]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:22.997]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:22.997]         do.call(mapply, args = args)
[10:19:22.997]     }
[10:19:22.997] }
[10:19:22.997] Lazy evaluation: FALSE
[10:19:22.997] Asynchronous evaluation: TRUE
[10:19:22.997] Local evaluation: TRUE
[10:19:22.997] Environment: R_GlobalEnv
[10:19:22.997] Capture standard output: TRUE
[10:19:22.997] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:22.997] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:22.997] Packages: <none>
[10:19:22.997] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:22.997] Resolved: TRUE
[10:19:22.997] Value: <not collected>
[10:19:22.997] Conditions captured: <none>
[10:19:22.997] Early signaling: FALSE
[10:19:22.997] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:22.997] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.007] Chunk #2 of 2 ... DONE
[10:19:23.007] Launching 2 futures (chunks) ... DONE
[10:19:23.008] Resolving 2 futures (chunks) ...
[10:19:23.008] resolve() on list ...
[10:19:23.008]  recursive: 0
[10:19:23.008]  length: 2
[10:19:23.008] 
[10:19:23.009] Future #1
[10:19:23.009] result() for MulticoreFuture ...
[10:19:23.010] result() for MulticoreFuture ...
[10:19:23.010] result() for MulticoreFuture ... done
[10:19:23.010] result() for MulticoreFuture ... done
[10:19:23.010] result() for MulticoreFuture ...
[10:19:23.010] result() for MulticoreFuture ... done
[10:19:23.011] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:23.011] - nx: 2
[10:19:23.011] - relay: TRUE
[10:19:23.011] - stdout: TRUE
[10:19:23.011] - signal: TRUE
[10:19:23.011] - resignal: FALSE
[10:19:23.012] - force: TRUE
[10:19:23.012] - relayed: [n=2] FALSE, FALSE
[10:19:23.012] - queued futures: [n=2] FALSE, FALSE
[10:19:23.012]  - until=1
[10:19:23.012]  - relaying element #1
[10:19:23.012] result() for MulticoreFuture ...
[10:19:23.013] result() for MulticoreFuture ... done
[10:19:23.013] result() for MulticoreFuture ...
[10:19:23.013] result() for MulticoreFuture ... done
[10:19:23.013] result() for MulticoreFuture ...
[10:19:23.013] result() for MulticoreFuture ... done
[10:19:23.013] result() for MulticoreFuture ...
[10:19:23.014] result() for MulticoreFuture ... done
[10:19:23.014] - relayed: [n=2] TRUE, FALSE
[10:19:23.014] - queued futures: [n=2] TRUE, FALSE
[10:19:23.014] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:23.014]  length: 1 (resolved future 1)
[10:19:23.014] Future #2
[10:19:23.015] result() for MulticoreFuture ...
[10:19:23.015] result() for MulticoreFuture ...
[10:19:23.015] result() for MulticoreFuture ... done
[10:19:23.015] result() for MulticoreFuture ... done
[10:19:23.016] result() for MulticoreFuture ...
[10:19:23.016] result() for MulticoreFuture ... done
[10:19:23.016] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:23.016] - nx: 2
[10:19:23.016] - relay: TRUE
[10:19:23.016] - stdout: TRUE
[10:19:23.016] - signal: TRUE
[10:19:23.017] - resignal: FALSE
[10:19:23.017] - force: TRUE
[10:19:23.017] - relayed: [n=2] TRUE, FALSE
[10:19:23.017] - queued futures: [n=2] TRUE, FALSE
[10:19:23.017]  - until=2
[10:19:23.017]  - relaying element #2
[10:19:23.017] result() for MulticoreFuture ...
[10:19:23.017] result() for MulticoreFuture ... done
[10:19:23.017] result() for MulticoreFuture ...
[10:19:23.017] result() for MulticoreFuture ... done
[10:19:23.018] result() for MulticoreFuture ...
[10:19:23.018] result() for MulticoreFuture ... done
[10:19:23.018] result() for MulticoreFuture ...
[10:19:23.018] result() for MulticoreFuture ... done
[10:19:23.018] - relayed: [n=2] TRUE, TRUE
[10:19:23.018] - queued futures: [n=2] TRUE, TRUE
[10:19:23.018] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:23.018]  length: 0 (resolved future 2)
[10:19:23.019] Relaying remaining futures
[10:19:23.019] signalConditionsASAP(NULL, pos=0) ...
[10:19:23.019] - nx: 2
[10:19:23.019] - relay: TRUE
[10:19:23.019] - stdout: TRUE
[10:19:23.019] - signal: TRUE
[10:19:23.019] - resignal: FALSE
[10:19:23.019] - force: TRUE
[10:19:23.019] - relayed: [n=2] TRUE, TRUE
[10:19:23.019] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:23.020] - relayed: [n=2] TRUE, TRUE
[10:19:23.020] - queued futures: [n=2] TRUE, TRUE
[10:19:23.020] signalConditionsASAP(NULL, pos=0) ... done
[10:19:23.020] resolve() on list ... DONE
[10:19:23.020] result() for MulticoreFuture ...
[10:19:23.020] result() for MulticoreFuture ... done
[10:19:23.020] result() for MulticoreFuture ...
[10:19:23.020] result() for MulticoreFuture ... done
[10:19:23.020] result() for MulticoreFuture ...
[10:19:23.021] result() for MulticoreFuture ... done
[10:19:23.021] result() for MulticoreFuture ...
[10:19:23.021] result() for MulticoreFuture ... done
[10:19:23.021]  - Number of value chunks collected: 2
[10:19:23.021] Resolving 2 futures (chunks) ... DONE
[10:19:23.021] Reducing values from 2 chunks ...
[10:19:23.021]  - Number of values collected after concatenation: 2
[10:19:23.021]  - Number of values expected: 2
[10:19:23.021] Reducing values from 2 chunks ... DONE
[10:19:23.022] future_mapply() ... DONE
[10:19:23.022] future_mapply() ...
[10:19:23.024] Number of chunks: 2
[10:19:23.024] getGlobalsAndPackagesXApply() ...
[10:19:23.024]  - future.globals: TRUE
[10:19:23.024] getGlobalsAndPackages() ...
[10:19:23.025] Searching for globals...
[10:19:23.028] - globals found: [1] ‘FUN’
[10:19:23.029] Searching for globals ... DONE
[10:19:23.029] Resolving globals: FALSE
[10:19:23.029] The total size of the 1 globals is 326 bytes (326 bytes)
[10:19:23.030] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:19:23.030] - globals: [1] ‘FUN’
[10:19:23.030] 
[10:19:23.030] getGlobalsAndPackages() ... DONE
[10:19:23.030]  - globals found/used: [n=1] ‘FUN’
[10:19:23.030]  - needed namespaces: [n=0] 
[10:19:23.030] Finding globals ... DONE
[10:19:23.031] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:23.031] List of 2
[10:19:23.031]  $ ...future.FUN:function (x, y)  
[10:19:23.031]  $ MoreArgs     :List of 1
[10:19:23.031]   ..$ y: int [1:2] 3 4
[10:19:23.031]  - attr(*, "where")=List of 2
[10:19:23.031]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:23.031]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:23.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.031]  - attr(*, "resolved")= logi FALSE
[10:19:23.031]  - attr(*, "total_size")= num NA
[10:19:23.035] Packages to be attached in all futures: [n=0] 
[10:19:23.035] getGlobalsAndPackagesXApply() ... DONE
[10:19:23.035] Number of futures (= number of chunks): 2
[10:19:23.036] Launching 2 futures (chunks) ...
[10:19:23.036] Chunk #1 of 2 ...
[10:19:23.036]  - Finding globals in '...' for chunk #1 ...
[10:19:23.036] getGlobalsAndPackages() ...
[10:19:23.036] Searching for globals...
[10:19:23.036] 
[10:19:23.036] Searching for globals ... DONE
[10:19:23.037] - globals: [0] <none>
[10:19:23.037] getGlobalsAndPackages() ... DONE
[10:19:23.037]    + additional globals found: [n=0] 
[10:19:23.037]    + additional namespaces needed: [n=0] 
[10:19:23.037]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:23.037]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.037]  - seeds: <none>
[10:19:23.037]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.037] getGlobalsAndPackages() ...
[10:19:23.037] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.037] Resolving globals: FALSE
[10:19:23.038] The total size of the 5 globals is 656 bytes (656 bytes)
[10:19:23.038] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:23.038] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.039] 
[10:19:23.039] getGlobalsAndPackages() ... DONE
[10:19:23.039] run() for ‘Future’ ...
[10:19:23.039] - state: ‘created’
[10:19:23.039] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.041] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.041]   - Field: ‘label’
[10:19:23.041]   - Field: ‘local’
[10:19:23.041]   - Field: ‘owner’
[10:19:23.041]   - Field: ‘envir’
[10:19:23.042]   - Field: ‘workers’
[10:19:23.042]   - Field: ‘packages’
[10:19:23.042]   - Field: ‘gc’
[10:19:23.042]   - Field: ‘job’
[10:19:23.042]   - Field: ‘conditions’
[10:19:23.042]   - Field: ‘expr’
[10:19:23.042]   - Field: ‘uuid’
[10:19:23.042]   - Field: ‘seed’
[10:19:23.042]   - Field: ‘version’
[10:19:23.042]   - Field: ‘result’
[10:19:23.042]   - Field: ‘asynchronous’
[10:19:23.043]   - Field: ‘calls’
[10:19:23.043]   - Field: ‘globals’
[10:19:23.043]   - Field: ‘stdout’
[10:19:23.043]   - Field: ‘earlySignal’
[10:19:23.043]   - Field: ‘lazy’
[10:19:23.043]   - Field: ‘state’
[10:19:23.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.043] - Launch lazy future ...
[10:19:23.043] Packages needed by the future expression (n = 0): <none>
[10:19:23.044] Packages needed by future strategies (n = 0): <none>
[10:19:23.044] {
[10:19:23.044]     {
[10:19:23.044]         {
[10:19:23.044]             ...future.startTime <- base::Sys.time()
[10:19:23.044]             {
[10:19:23.044]                 {
[10:19:23.044]                   {
[10:19:23.044]                     {
[10:19:23.044]                       base::local({
[10:19:23.044]                         has_future <- base::requireNamespace("future", 
[10:19:23.044]                           quietly = TRUE)
[10:19:23.044]                         if (has_future) {
[10:19:23.044]                           ns <- base::getNamespace("future")
[10:19:23.044]                           version <- ns[[".package"]][["version"]]
[10:19:23.044]                           if (is.null(version)) 
[10:19:23.044]                             version <- utils::packageVersion("future")
[10:19:23.044]                         }
[10:19:23.044]                         else {
[10:19:23.044]                           version <- NULL
[10:19:23.044]                         }
[10:19:23.044]                         if (!has_future || version < "1.8.0") {
[10:19:23.044]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.044]                             "", base::R.version$version.string), 
[10:19:23.044]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:23.044]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:23.044]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.044]                               "release", "version")], collapse = " "), 
[10:19:23.044]                             hostname = base::Sys.info()[["nodename"]])
[10:19:23.044]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.044]                             info)
[10:19:23.044]                           info <- base::paste(info, collapse = "; ")
[10:19:23.044]                           if (!has_future) {
[10:19:23.044]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.044]                               info)
[10:19:23.044]                           }
[10:19:23.044]                           else {
[10:19:23.044]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.044]                               info, version)
[10:19:23.044]                           }
[10:19:23.044]                           base::stop(msg)
[10:19:23.044]                         }
[10:19:23.044]                       })
[10:19:23.044]                     }
[10:19:23.044]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.044]                     base::options(mc.cores = 1L)
[10:19:23.044]                   }
[10:19:23.044]                   ...future.strategy.old <- future::plan("list")
[10:19:23.044]                   options(future.plan = NULL)
[10:19:23.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.044]                 }
[10:19:23.044]                 ...future.workdir <- getwd()
[10:19:23.044]             }
[10:19:23.044]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.044]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.044]         }
[10:19:23.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.044]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.044]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.044]             base::names(...future.oldOptions))
[10:19:23.044]     }
[10:19:23.044]     if (FALSE) {
[10:19:23.044]     }
[10:19:23.044]     else {
[10:19:23.044]         if (TRUE) {
[10:19:23.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.044]                 open = "w")
[10:19:23.044]         }
[10:19:23.044]         else {
[10:19:23.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.044]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.044]         }
[10:19:23.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.044]             base::sink(type = "output", split = FALSE)
[10:19:23.044]             base::close(...future.stdout)
[10:19:23.044]         }, add = TRUE)
[10:19:23.044]     }
[10:19:23.044]     ...future.frame <- base::sys.nframe()
[10:19:23.044]     ...future.conditions <- base::list()
[10:19:23.044]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.044]     if (FALSE) {
[10:19:23.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.044]     }
[10:19:23.044]     ...future.result <- base::tryCatch({
[10:19:23.044]         base::withCallingHandlers({
[10:19:23.044]             ...future.value <- base::withVisible(base::local({
[10:19:23.044]                 withCallingHandlers({
[10:19:23.044]                   {
[10:19:23.044]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.044]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.044]                       ...future.globals.maxSize)) {
[10:19:23.044]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.044]                       on.exit(options(oopts), add = TRUE)
[10:19:23.044]                     }
[10:19:23.044]                     {
[10:19:23.044]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.044]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.044]                         USE.NAMES = FALSE)
[10:19:23.044]                       do.call(mapply, args = args)
[10:19:23.044]                     }
[10:19:23.044]                   }
[10:19:23.044]                 }, immediateCondition = function(cond) {
[10:19:23.044]                   save_rds <- function (object, pathname, ...) 
[10:19:23.044]                   {
[10:19:23.044]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.044]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.044]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.044]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.044]                         fi_tmp[["mtime"]])
[10:19:23.044]                     }
[10:19:23.044]                     tryCatch({
[10:19:23.044]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.044]                     }, error = function(ex) {
[10:19:23.044]                       msg <- conditionMessage(ex)
[10:19:23.044]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.044]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.044]                         fi_tmp[["mtime"]], msg)
[10:19:23.044]                       ex$message <- msg
[10:19:23.044]                       stop(ex)
[10:19:23.044]                     })
[10:19:23.044]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.044]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.044]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.044]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.044]                       fi <- file.info(pathname)
[10:19:23.044]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.044]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.044]                         fi[["size"]], fi[["mtime"]])
[10:19:23.044]                       stop(msg)
[10:19:23.044]                     }
[10:19:23.044]                     invisible(pathname)
[10:19:23.044]                   }
[10:19:23.044]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.044]                     rootPath = tempdir()) 
[10:19:23.044]                   {
[10:19:23.044]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.044]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.044]                       tmpdir = path, fileext = ".rds")
[10:19:23.044]                     save_rds(obj, file)
[10:19:23.044]                   }
[10:19:23.044]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.044]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.044]                   {
[10:19:23.044]                     inherits <- base::inherits
[10:19:23.044]                     invokeRestart <- base::invokeRestart
[10:19:23.044]                     is.null <- base::is.null
[10:19:23.044]                     muffled <- FALSE
[10:19:23.044]                     if (inherits(cond, "message")) {
[10:19:23.044]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.044]                       if (muffled) 
[10:19:23.044]                         invokeRestart("muffleMessage")
[10:19:23.044]                     }
[10:19:23.044]                     else if (inherits(cond, "warning")) {
[10:19:23.044]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.044]                       if (muffled) 
[10:19:23.044]                         invokeRestart("muffleWarning")
[10:19:23.044]                     }
[10:19:23.044]                     else if (inherits(cond, "condition")) {
[10:19:23.044]                       if (!is.null(pattern)) {
[10:19:23.044]                         computeRestarts <- base::computeRestarts
[10:19:23.044]                         grepl <- base::grepl
[10:19:23.044]                         restarts <- computeRestarts(cond)
[10:19:23.044]                         for (restart in restarts) {
[10:19:23.044]                           name <- restart$name
[10:19:23.044]                           if (is.null(name)) 
[10:19:23.044]                             next
[10:19:23.044]                           if (!grepl(pattern, name)) 
[10:19:23.044]                             next
[10:19:23.044]                           invokeRestart(restart)
[10:19:23.044]                           muffled <- TRUE
[10:19:23.044]                           break
[10:19:23.044]                         }
[10:19:23.044]                       }
[10:19:23.044]                     }
[10:19:23.044]                     invisible(muffled)
[10:19:23.044]                   }
[10:19:23.044]                   muffleCondition(cond)
[10:19:23.044]                 })
[10:19:23.044]             }))
[10:19:23.044]             future::FutureResult(value = ...future.value$value, 
[10:19:23.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.044]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.044]                     ...future.globalenv.names))
[10:19:23.044]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.044]         }, condition = base::local({
[10:19:23.044]             c <- base::c
[10:19:23.044]             inherits <- base::inherits
[10:19:23.044]             invokeRestart <- base::invokeRestart
[10:19:23.044]             length <- base::length
[10:19:23.044]             list <- base::list
[10:19:23.044]             seq.int <- base::seq.int
[10:19:23.044]             signalCondition <- base::signalCondition
[10:19:23.044]             sys.calls <- base::sys.calls
[10:19:23.044]             `[[` <- base::`[[`
[10:19:23.044]             `+` <- base::`+`
[10:19:23.044]             `<<-` <- base::`<<-`
[10:19:23.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.044]                   3L)]
[10:19:23.044]             }
[10:19:23.044]             function(cond) {
[10:19:23.044]                 is_error <- inherits(cond, "error")
[10:19:23.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.044]                   NULL)
[10:19:23.044]                 if (is_error) {
[10:19:23.044]                   sessionInformation <- function() {
[10:19:23.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.044]                       search = base::search(), system = base::Sys.info())
[10:19:23.044]                   }
[10:19:23.044]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.044]                     cond$call), session = sessionInformation(), 
[10:19:23.044]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.044]                   signalCondition(cond)
[10:19:23.044]                 }
[10:19:23.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.044]                 "immediateCondition"))) {
[10:19:23.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.044]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.044]                   if (TRUE && !signal) {
[10:19:23.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.044]                     {
[10:19:23.044]                       inherits <- base::inherits
[10:19:23.044]                       invokeRestart <- base::invokeRestart
[10:19:23.044]                       is.null <- base::is.null
[10:19:23.044]                       muffled <- FALSE
[10:19:23.044]                       if (inherits(cond, "message")) {
[10:19:23.044]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.044]                         if (muffled) 
[10:19:23.044]                           invokeRestart("muffleMessage")
[10:19:23.044]                       }
[10:19:23.044]                       else if (inherits(cond, "warning")) {
[10:19:23.044]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.044]                         if (muffled) 
[10:19:23.044]                           invokeRestart("muffleWarning")
[10:19:23.044]                       }
[10:19:23.044]                       else if (inherits(cond, "condition")) {
[10:19:23.044]                         if (!is.null(pattern)) {
[10:19:23.044]                           computeRestarts <- base::computeRestarts
[10:19:23.044]                           grepl <- base::grepl
[10:19:23.044]                           restarts <- computeRestarts(cond)
[10:19:23.044]                           for (restart in restarts) {
[10:19:23.044]                             name <- restart$name
[10:19:23.044]                             if (is.null(name)) 
[10:19:23.044]                               next
[10:19:23.044]                             if (!grepl(pattern, name)) 
[10:19:23.044]                               next
[10:19:23.044]                             invokeRestart(restart)
[10:19:23.044]                             muffled <- TRUE
[10:19:23.044]                             break
[10:19:23.044]                           }
[10:19:23.044]                         }
[10:19:23.044]                       }
[10:19:23.044]                       invisible(muffled)
[10:19:23.044]                     }
[10:19:23.044]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.044]                   }
[10:19:23.044]                 }
[10:19:23.044]                 else {
[10:19:23.044]                   if (TRUE) {
[10:19:23.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.044]                     {
[10:19:23.044]                       inherits <- base::inherits
[10:19:23.044]                       invokeRestart <- base::invokeRestart
[10:19:23.044]                       is.null <- base::is.null
[10:19:23.044]                       muffled <- FALSE
[10:19:23.044]                       if (inherits(cond, "message")) {
[10:19:23.044]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.044]                         if (muffled) 
[10:19:23.044]                           invokeRestart("muffleMessage")
[10:19:23.044]                       }
[10:19:23.044]                       else if (inherits(cond, "warning")) {
[10:19:23.044]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.044]                         if (muffled) 
[10:19:23.044]                           invokeRestart("muffleWarning")
[10:19:23.044]                       }
[10:19:23.044]                       else if (inherits(cond, "condition")) {
[10:19:23.044]                         if (!is.null(pattern)) {
[10:19:23.044]                           computeRestarts <- base::computeRestarts
[10:19:23.044]                           grepl <- base::grepl
[10:19:23.044]                           restarts <- computeRestarts(cond)
[10:19:23.044]                           for (restart in restarts) {
[10:19:23.044]                             name <- restart$name
[10:19:23.044]                             if (is.null(name)) 
[10:19:23.044]                               next
[10:19:23.044]                             if (!grepl(pattern, name)) 
[10:19:23.044]                               next
[10:19:23.044]                             invokeRestart(restart)
[10:19:23.044]                             muffled <- TRUE
[10:19:23.044]                             break
[10:19:23.044]                           }
[10:19:23.044]                         }
[10:19:23.044]                       }
[10:19:23.044]                       invisible(muffled)
[10:19:23.044]                     }
[10:19:23.044]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.044]                   }
[10:19:23.044]                 }
[10:19:23.044]             }
[10:19:23.044]         }))
[10:19:23.044]     }, error = function(ex) {
[10:19:23.044]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.044]                 ...future.rng), started = ...future.startTime, 
[10:19:23.044]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.044]             version = "1.8"), class = "FutureResult")
[10:19:23.044]     }, finally = {
[10:19:23.044]         if (!identical(...future.workdir, getwd())) 
[10:19:23.044]             setwd(...future.workdir)
[10:19:23.044]         {
[10:19:23.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.044]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.044]             }
[10:19:23.044]             base::options(...future.oldOptions)
[10:19:23.044]             if (.Platform$OS.type == "windows") {
[10:19:23.044]                 old_names <- names(...future.oldEnvVars)
[10:19:23.044]                 envs <- base::Sys.getenv()
[10:19:23.044]                 names <- names(envs)
[10:19:23.044]                 common <- intersect(names, old_names)
[10:19:23.044]                 added <- setdiff(names, old_names)
[10:19:23.044]                 removed <- setdiff(old_names, names)
[10:19:23.044]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.044]                   envs[common]]
[10:19:23.044]                 NAMES <- toupper(changed)
[10:19:23.044]                 args <- list()
[10:19:23.044]                 for (kk in seq_along(NAMES)) {
[10:19:23.044]                   name <- changed[[kk]]
[10:19:23.044]                   NAME <- NAMES[[kk]]
[10:19:23.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.044]                     next
[10:19:23.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.044]                 }
[10:19:23.044]                 NAMES <- toupper(added)
[10:19:23.044]                 for (kk in seq_along(NAMES)) {
[10:19:23.044]                   name <- added[[kk]]
[10:19:23.044]                   NAME <- NAMES[[kk]]
[10:19:23.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.044]                     next
[10:19:23.044]                   args[[name]] <- ""
[10:19:23.044]                 }
[10:19:23.044]                 NAMES <- toupper(removed)
[10:19:23.044]                 for (kk in seq_along(NAMES)) {
[10:19:23.044]                   name <- removed[[kk]]
[10:19:23.044]                   NAME <- NAMES[[kk]]
[10:19:23.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.044]                     next
[10:19:23.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.044]                 }
[10:19:23.044]                 if (length(args) > 0) 
[10:19:23.044]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.044]             }
[10:19:23.044]             else {
[10:19:23.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.044]             }
[10:19:23.044]             {
[10:19:23.044]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.044]                   0L) {
[10:19:23.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.044]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.044]                   base::options(opts)
[10:19:23.044]                 }
[10:19:23.044]                 {
[10:19:23.044]                   {
[10:19:23.044]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.044]                     NULL
[10:19:23.044]                   }
[10:19:23.044]                   options(future.plan = NULL)
[10:19:23.044]                   if (is.na(NA_character_)) 
[10:19:23.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.044]                     .init = FALSE)
[10:19:23.044]                 }
[10:19:23.044]             }
[10:19:23.044]         }
[10:19:23.044]     })
[10:19:23.044]     if (TRUE) {
[10:19:23.044]         base::sink(type = "output", split = FALSE)
[10:19:23.044]         if (TRUE) {
[10:19:23.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.044]         }
[10:19:23.044]         else {
[10:19:23.044]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.044]         }
[10:19:23.044]         base::close(...future.stdout)
[10:19:23.044]         ...future.stdout <- NULL
[10:19:23.044]     }
[10:19:23.044]     ...future.result$conditions <- ...future.conditions
[10:19:23.044]     ...future.result$finished <- base::Sys.time()
[10:19:23.044]     ...future.result
[10:19:23.044] }
[10:19:23.047] assign_globals() ...
[10:19:23.047] List of 5
[10:19:23.047]  $ ...future.FUN            :function (x, y)  
[10:19:23.047]  $ MoreArgs                 :List of 1
[10:19:23.047]   ..$ y: int [1:2] 3 4
[10:19:23.047]  $ ...future.elements_ii    :List of 1
[10:19:23.047]   ..$ x:List of 1
[10:19:23.047]   .. ..$ : int 1
[10:19:23.047]  $ ...future.seeds_ii       : NULL
[10:19:23.047]  $ ...future.globals.maxSize: NULL
[10:19:23.047]  - attr(*, "where")=List of 5
[10:19:23.047]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.047]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.047]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.047]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.047]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.047]  - attr(*, "resolved")= logi FALSE
[10:19:23.047]  - attr(*, "total_size")= num 656
[10:19:23.047]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.047]  - attr(*, "already-done")= logi TRUE
[10:19:23.054] - reassign environment for ‘...future.FUN’
[10:19:23.054] - copied ‘...future.FUN’ to environment
[10:19:23.054] - copied ‘MoreArgs’ to environment
[10:19:23.054] - copied ‘...future.elements_ii’ to environment
[10:19:23.054] - copied ‘...future.seeds_ii’ to environment
[10:19:23.054] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.054] assign_globals() ... done
[10:19:23.055] requestCore(): workers = 2
[10:19:23.057] MulticoreFuture started
[10:19:23.058] - Launch lazy future ... done
[10:19:23.058] plan(): Setting new future strategy stack:
[10:19:23.058] run() for ‘MulticoreFuture’ ... done
[10:19:23.059] Created future:
[10:19:23.059] List of future strategies:
[10:19:23.059] 1. sequential:
[10:19:23.059]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.059]    - tweaked: FALSE
[10:19:23.059]    - call: NULL
[10:19:23.061] plan(): nbrOfWorkers() = 1
[10:19:23.064] plan(): Setting new future strategy stack:
[10:19:23.064] List of future strategies:
[10:19:23.064] 1. multicore:
[10:19:23.064]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.064]    - tweaked: FALSE
[10:19:23.064]    - call: plan(strategy)
[10:19:23.068] plan(): nbrOfWorkers() = 2
[10:19:23.059] MulticoreFuture:
[10:19:23.059] Label: ‘future_.mapply-1’
[10:19:23.059] Expression:
[10:19:23.059] {
[10:19:23.059]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.059]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.059]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.059]         on.exit(options(oopts), add = TRUE)
[10:19:23.059]     }
[10:19:23.059]     {
[10:19:23.059]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.059]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.059]         do.call(mapply, args = args)
[10:19:23.059]     }
[10:19:23.059] }
[10:19:23.059] Lazy evaluation: FALSE
[10:19:23.059] Asynchronous evaluation: TRUE
[10:19:23.059] Local evaluation: TRUE
[10:19:23.059] Environment: R_GlobalEnv
[10:19:23.059] Capture standard output: TRUE
[10:19:23.059] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.059] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.059] Packages: <none>
[10:19:23.059] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:23.059] Resolved: TRUE
[10:19:23.059] Value: <not collected>
[10:19:23.059] Conditions captured: <none>
[10:19:23.059] Early signaling: FALSE
[10:19:23.059] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.059] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.070] Chunk #1 of 2 ... DONE
[10:19:23.070] Chunk #2 of 2 ...
[10:19:23.070]  - Finding globals in '...' for chunk #2 ...
[10:19:23.071] getGlobalsAndPackages() ...
[10:19:23.071] Searching for globals...
[10:19:23.071] 
[10:19:23.072] Searching for globals ... DONE
[10:19:23.072] - globals: [0] <none>
[10:19:23.072] getGlobalsAndPackages() ... DONE
[10:19:23.072]    + additional globals found: [n=0] 
[10:19:23.072]    + additional namespaces needed: [n=0] 
[10:19:23.072]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:23.073]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.073]  - seeds: <none>
[10:19:23.073]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.073] getGlobalsAndPackages() ...
[10:19:23.074] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.074] Resolving globals: FALSE
[10:19:23.075] The total size of the 5 globals is 656 bytes (656 bytes)
[10:19:23.076] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:23.076] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.076] 
[10:19:23.077] getGlobalsAndPackages() ... DONE
[10:19:23.077] run() for ‘Future’ ...
[10:19:23.077] - state: ‘created’
[10:19:23.077] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.080] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.080]   - Field: ‘label’
[10:19:23.080]   - Field: ‘local’
[10:19:23.081]   - Field: ‘owner’
[10:19:23.081]   - Field: ‘envir’
[10:19:23.081]   - Field: ‘workers’
[10:19:23.081]   - Field: ‘packages’
[10:19:23.081]   - Field: ‘gc’
[10:19:23.081]   - Field: ‘job’
[10:19:23.081]   - Field: ‘conditions’
[10:19:23.082]   - Field: ‘expr’
[10:19:23.082]   - Field: ‘uuid’
[10:19:23.082]   - Field: ‘seed’
[10:19:23.082]   - Field: ‘version’
[10:19:23.082]   - Field: ‘result’
[10:19:23.082]   - Field: ‘asynchronous’
[10:19:23.082]   - Field: ‘calls’
[10:19:23.082]   - Field: ‘globals’
[10:19:23.082]   - Field: ‘stdout’
[10:19:23.083]   - Field: ‘earlySignal’
[10:19:23.083]   - Field: ‘lazy’
[10:19:23.083]   - Field: ‘state’
[10:19:23.083] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.083] - Launch lazy future ...
[10:19:23.083] Packages needed by the future expression (n = 0): <none>
[10:19:23.084] Packages needed by future strategies (n = 0): <none>
[10:19:23.084] {
[10:19:23.084]     {
[10:19:23.084]         {
[10:19:23.084]             ...future.startTime <- base::Sys.time()
[10:19:23.084]             {
[10:19:23.084]                 {
[10:19:23.084]                   {
[10:19:23.084]                     {
[10:19:23.084]                       base::local({
[10:19:23.084]                         has_future <- base::requireNamespace("future", 
[10:19:23.084]                           quietly = TRUE)
[10:19:23.084]                         if (has_future) {
[10:19:23.084]                           ns <- base::getNamespace("future")
[10:19:23.084]                           version <- ns[[".package"]][["version"]]
[10:19:23.084]                           if (is.null(version)) 
[10:19:23.084]                             version <- utils::packageVersion("future")
[10:19:23.084]                         }
[10:19:23.084]                         else {
[10:19:23.084]                           version <- NULL
[10:19:23.084]                         }
[10:19:23.084]                         if (!has_future || version < "1.8.0") {
[10:19:23.084]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.084]                             "", base::R.version$version.string), 
[10:19:23.084]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:23.084]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:23.084]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.084]                               "release", "version")], collapse = " "), 
[10:19:23.084]                             hostname = base::Sys.info()[["nodename"]])
[10:19:23.084]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.084]                             info)
[10:19:23.084]                           info <- base::paste(info, collapse = "; ")
[10:19:23.084]                           if (!has_future) {
[10:19:23.084]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.084]                               info)
[10:19:23.084]                           }
[10:19:23.084]                           else {
[10:19:23.084]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.084]                               info, version)
[10:19:23.084]                           }
[10:19:23.084]                           base::stop(msg)
[10:19:23.084]                         }
[10:19:23.084]                       })
[10:19:23.084]                     }
[10:19:23.084]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.084]                     base::options(mc.cores = 1L)
[10:19:23.084]                   }
[10:19:23.084]                   ...future.strategy.old <- future::plan("list")
[10:19:23.084]                   options(future.plan = NULL)
[10:19:23.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.084]                 }
[10:19:23.084]                 ...future.workdir <- getwd()
[10:19:23.084]             }
[10:19:23.084]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.084]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.084]         }
[10:19:23.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.084]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.084]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.084]             base::names(...future.oldOptions))
[10:19:23.084]     }
[10:19:23.084]     if (FALSE) {
[10:19:23.084]     }
[10:19:23.084]     else {
[10:19:23.084]         if (TRUE) {
[10:19:23.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.084]                 open = "w")
[10:19:23.084]         }
[10:19:23.084]         else {
[10:19:23.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.084]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.084]         }
[10:19:23.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.084]             base::sink(type = "output", split = FALSE)
[10:19:23.084]             base::close(...future.stdout)
[10:19:23.084]         }, add = TRUE)
[10:19:23.084]     }
[10:19:23.084]     ...future.frame <- base::sys.nframe()
[10:19:23.084]     ...future.conditions <- base::list()
[10:19:23.084]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.084]     if (FALSE) {
[10:19:23.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.084]     }
[10:19:23.084]     ...future.result <- base::tryCatch({
[10:19:23.084]         base::withCallingHandlers({
[10:19:23.084]             ...future.value <- base::withVisible(base::local({
[10:19:23.084]                 withCallingHandlers({
[10:19:23.084]                   {
[10:19:23.084]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.084]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.084]                       ...future.globals.maxSize)) {
[10:19:23.084]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.084]                       on.exit(options(oopts), add = TRUE)
[10:19:23.084]                     }
[10:19:23.084]                     {
[10:19:23.084]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.084]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.084]                         USE.NAMES = FALSE)
[10:19:23.084]                       do.call(mapply, args = args)
[10:19:23.084]                     }
[10:19:23.084]                   }
[10:19:23.084]                 }, immediateCondition = function(cond) {
[10:19:23.084]                   save_rds <- function (object, pathname, ...) 
[10:19:23.084]                   {
[10:19:23.084]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.084]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.084]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.084]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.084]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.084]                         fi_tmp[["mtime"]])
[10:19:23.084]                     }
[10:19:23.084]                     tryCatch({
[10:19:23.084]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.084]                     }, error = function(ex) {
[10:19:23.084]                       msg <- conditionMessage(ex)
[10:19:23.084]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.084]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.084]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.084]                         fi_tmp[["mtime"]], msg)
[10:19:23.084]                       ex$message <- msg
[10:19:23.084]                       stop(ex)
[10:19:23.084]                     })
[10:19:23.084]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.084]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.084]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.084]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.084]                       fi <- file.info(pathname)
[10:19:23.084]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.084]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.084]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.084]                         fi[["size"]], fi[["mtime"]])
[10:19:23.084]                       stop(msg)
[10:19:23.084]                     }
[10:19:23.084]                     invisible(pathname)
[10:19:23.084]                   }
[10:19:23.084]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.084]                     rootPath = tempdir()) 
[10:19:23.084]                   {
[10:19:23.084]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.084]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.084]                       tmpdir = path, fileext = ".rds")
[10:19:23.084]                     save_rds(obj, file)
[10:19:23.084]                   }
[10:19:23.084]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.084]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.084]                   {
[10:19:23.084]                     inherits <- base::inherits
[10:19:23.084]                     invokeRestart <- base::invokeRestart
[10:19:23.084]                     is.null <- base::is.null
[10:19:23.084]                     muffled <- FALSE
[10:19:23.084]                     if (inherits(cond, "message")) {
[10:19:23.084]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.084]                       if (muffled) 
[10:19:23.084]                         invokeRestart("muffleMessage")
[10:19:23.084]                     }
[10:19:23.084]                     else if (inherits(cond, "warning")) {
[10:19:23.084]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.084]                       if (muffled) 
[10:19:23.084]                         invokeRestart("muffleWarning")
[10:19:23.084]                     }
[10:19:23.084]                     else if (inherits(cond, "condition")) {
[10:19:23.084]                       if (!is.null(pattern)) {
[10:19:23.084]                         computeRestarts <- base::computeRestarts
[10:19:23.084]                         grepl <- base::grepl
[10:19:23.084]                         restarts <- computeRestarts(cond)
[10:19:23.084]                         for (restart in restarts) {
[10:19:23.084]                           name <- restart$name
[10:19:23.084]                           if (is.null(name)) 
[10:19:23.084]                             next
[10:19:23.084]                           if (!grepl(pattern, name)) 
[10:19:23.084]                             next
[10:19:23.084]                           invokeRestart(restart)
[10:19:23.084]                           muffled <- TRUE
[10:19:23.084]                           break
[10:19:23.084]                         }
[10:19:23.084]                       }
[10:19:23.084]                     }
[10:19:23.084]                     invisible(muffled)
[10:19:23.084]                   }
[10:19:23.084]                   muffleCondition(cond)
[10:19:23.084]                 })
[10:19:23.084]             }))
[10:19:23.084]             future::FutureResult(value = ...future.value$value, 
[10:19:23.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.084]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.084]                     ...future.globalenv.names))
[10:19:23.084]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.084]         }, condition = base::local({
[10:19:23.084]             c <- base::c
[10:19:23.084]             inherits <- base::inherits
[10:19:23.084]             invokeRestart <- base::invokeRestart
[10:19:23.084]             length <- base::length
[10:19:23.084]             list <- base::list
[10:19:23.084]             seq.int <- base::seq.int
[10:19:23.084]             signalCondition <- base::signalCondition
[10:19:23.084]             sys.calls <- base::sys.calls
[10:19:23.084]             `[[` <- base::`[[`
[10:19:23.084]             `+` <- base::`+`
[10:19:23.084]             `<<-` <- base::`<<-`
[10:19:23.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.084]                   3L)]
[10:19:23.084]             }
[10:19:23.084]             function(cond) {
[10:19:23.084]                 is_error <- inherits(cond, "error")
[10:19:23.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.084]                   NULL)
[10:19:23.084]                 if (is_error) {
[10:19:23.084]                   sessionInformation <- function() {
[10:19:23.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.084]                       search = base::search(), system = base::Sys.info())
[10:19:23.084]                   }
[10:19:23.084]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.084]                     cond$call), session = sessionInformation(), 
[10:19:23.084]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.084]                   signalCondition(cond)
[10:19:23.084]                 }
[10:19:23.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.084]                 "immediateCondition"))) {
[10:19:23.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.084]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.084]                   if (TRUE && !signal) {
[10:19:23.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.084]                     {
[10:19:23.084]                       inherits <- base::inherits
[10:19:23.084]                       invokeRestart <- base::invokeRestart
[10:19:23.084]                       is.null <- base::is.null
[10:19:23.084]                       muffled <- FALSE
[10:19:23.084]                       if (inherits(cond, "message")) {
[10:19:23.084]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.084]                         if (muffled) 
[10:19:23.084]                           invokeRestart("muffleMessage")
[10:19:23.084]                       }
[10:19:23.084]                       else if (inherits(cond, "warning")) {
[10:19:23.084]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.084]                         if (muffled) 
[10:19:23.084]                           invokeRestart("muffleWarning")
[10:19:23.084]                       }
[10:19:23.084]                       else if (inherits(cond, "condition")) {
[10:19:23.084]                         if (!is.null(pattern)) {
[10:19:23.084]                           computeRestarts <- base::computeRestarts
[10:19:23.084]                           grepl <- base::grepl
[10:19:23.084]                           restarts <- computeRestarts(cond)
[10:19:23.084]                           for (restart in restarts) {
[10:19:23.084]                             name <- restart$name
[10:19:23.084]                             if (is.null(name)) 
[10:19:23.084]                               next
[10:19:23.084]                             if (!grepl(pattern, name)) 
[10:19:23.084]                               next
[10:19:23.084]                             invokeRestart(restart)
[10:19:23.084]                             muffled <- TRUE
[10:19:23.084]                             break
[10:19:23.084]                           }
[10:19:23.084]                         }
[10:19:23.084]                       }
[10:19:23.084]                       invisible(muffled)
[10:19:23.084]                     }
[10:19:23.084]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.084]                   }
[10:19:23.084]                 }
[10:19:23.084]                 else {
[10:19:23.084]                   if (TRUE) {
[10:19:23.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.084]                     {
[10:19:23.084]                       inherits <- base::inherits
[10:19:23.084]                       invokeRestart <- base::invokeRestart
[10:19:23.084]                       is.null <- base::is.null
[10:19:23.084]                       muffled <- FALSE
[10:19:23.084]                       if (inherits(cond, "message")) {
[10:19:23.084]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.084]                         if (muffled) 
[10:19:23.084]                           invokeRestart("muffleMessage")
[10:19:23.084]                       }
[10:19:23.084]                       else if (inherits(cond, "warning")) {
[10:19:23.084]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.084]                         if (muffled) 
[10:19:23.084]                           invokeRestart("muffleWarning")
[10:19:23.084]                       }
[10:19:23.084]                       else if (inherits(cond, "condition")) {
[10:19:23.084]                         if (!is.null(pattern)) {
[10:19:23.084]                           computeRestarts <- base::computeRestarts
[10:19:23.084]                           grepl <- base::grepl
[10:19:23.084]                           restarts <- computeRestarts(cond)
[10:19:23.084]                           for (restart in restarts) {
[10:19:23.084]                             name <- restart$name
[10:19:23.084]                             if (is.null(name)) 
[10:19:23.084]                               next
[10:19:23.084]                             if (!grepl(pattern, name)) 
[10:19:23.084]                               next
[10:19:23.084]                             invokeRestart(restart)
[10:19:23.084]                             muffled <- TRUE
[10:19:23.084]                             break
[10:19:23.084]                           }
[10:19:23.084]                         }
[10:19:23.084]                       }
[10:19:23.084]                       invisible(muffled)
[10:19:23.084]                     }
[10:19:23.084]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.084]                   }
[10:19:23.084]                 }
[10:19:23.084]             }
[10:19:23.084]         }))
[10:19:23.084]     }, error = function(ex) {
[10:19:23.084]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.084]                 ...future.rng), started = ...future.startTime, 
[10:19:23.084]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.084]             version = "1.8"), class = "FutureResult")
[10:19:23.084]     }, finally = {
[10:19:23.084]         if (!identical(...future.workdir, getwd())) 
[10:19:23.084]             setwd(...future.workdir)
[10:19:23.084]         {
[10:19:23.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.084]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.084]             }
[10:19:23.084]             base::options(...future.oldOptions)
[10:19:23.084]             if (.Platform$OS.type == "windows") {
[10:19:23.084]                 old_names <- names(...future.oldEnvVars)
[10:19:23.084]                 envs <- base::Sys.getenv()
[10:19:23.084]                 names <- names(envs)
[10:19:23.084]                 common <- intersect(names, old_names)
[10:19:23.084]                 added <- setdiff(names, old_names)
[10:19:23.084]                 removed <- setdiff(old_names, names)
[10:19:23.084]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.084]                   envs[common]]
[10:19:23.084]                 NAMES <- toupper(changed)
[10:19:23.084]                 args <- list()
[10:19:23.084]                 for (kk in seq_along(NAMES)) {
[10:19:23.084]                   name <- changed[[kk]]
[10:19:23.084]                   NAME <- NAMES[[kk]]
[10:19:23.084]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.084]                     next
[10:19:23.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.084]                 }
[10:19:23.084]                 NAMES <- toupper(added)
[10:19:23.084]                 for (kk in seq_along(NAMES)) {
[10:19:23.084]                   name <- added[[kk]]
[10:19:23.084]                   NAME <- NAMES[[kk]]
[10:19:23.084]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.084]                     next
[10:19:23.084]                   args[[name]] <- ""
[10:19:23.084]                 }
[10:19:23.084]                 NAMES <- toupper(removed)
[10:19:23.084]                 for (kk in seq_along(NAMES)) {
[10:19:23.084]                   name <- removed[[kk]]
[10:19:23.084]                   NAME <- NAMES[[kk]]
[10:19:23.084]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.084]                     next
[10:19:23.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.084]                 }
[10:19:23.084]                 if (length(args) > 0) 
[10:19:23.084]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.084]             }
[10:19:23.084]             else {
[10:19:23.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.084]             }
[10:19:23.084]             {
[10:19:23.084]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.084]                   0L) {
[10:19:23.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.084]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.084]                   base::options(opts)
[10:19:23.084]                 }
[10:19:23.084]                 {
[10:19:23.084]                   {
[10:19:23.084]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.084]                     NULL
[10:19:23.084]                   }
[10:19:23.084]                   options(future.plan = NULL)
[10:19:23.084]                   if (is.na(NA_character_)) 
[10:19:23.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.084]                     .init = FALSE)
[10:19:23.084]                 }
[10:19:23.084]             }
[10:19:23.084]         }
[10:19:23.084]     })
[10:19:23.084]     if (TRUE) {
[10:19:23.084]         base::sink(type = "output", split = FALSE)
[10:19:23.084]         if (TRUE) {
[10:19:23.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.084]         }
[10:19:23.084]         else {
[10:19:23.084]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.084]         }
[10:19:23.084]         base::close(...future.stdout)
[10:19:23.084]         ...future.stdout <- NULL
[10:19:23.084]     }
[10:19:23.084]     ...future.result$conditions <- ...future.conditions
[10:19:23.084]     ...future.result$finished <- base::Sys.time()
[10:19:23.084]     ...future.result
[10:19:23.084] }
[10:19:23.088] assign_globals() ...
[10:19:23.088] List of 5
[10:19:23.088]  $ ...future.FUN            :function (x, y)  
[10:19:23.088]  $ MoreArgs                 :List of 1
[10:19:23.088]   ..$ y: int [1:2] 3 4
[10:19:23.088]  $ ...future.elements_ii    :List of 1
[10:19:23.088]   ..$ x:List of 1
[10:19:23.088]   .. ..$ : int 2
[10:19:23.088]  $ ...future.seeds_ii       : NULL
[10:19:23.088]  $ ...future.globals.maxSize: NULL
[10:19:23.088]  - attr(*, "where")=List of 5
[10:19:23.088]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.088]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.088]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.088]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.088]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.088]  - attr(*, "resolved")= logi FALSE
[10:19:23.088]  - attr(*, "total_size")= num 656
[10:19:23.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.088]  - attr(*, "already-done")= logi TRUE
[10:19:23.094] - reassign environment for ‘...future.FUN’
[10:19:23.095] - copied ‘...future.FUN’ to environment
[10:19:23.095] - copied ‘MoreArgs’ to environment
[10:19:23.095] - copied ‘...future.elements_ii’ to environment
[10:19:23.097] - copied ‘...future.seeds_ii’ to environment
[10:19:23.098] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.098] assign_globals() ... done
[10:19:23.098] requestCore(): workers = 2
[10:19:23.101] MulticoreFuture started
[10:19:23.101] - Launch lazy future ... done
[10:19:23.102] run() for ‘MulticoreFuture’ ... done
[10:19:23.102] plan(): Setting new future strategy stack:
[10:19:23.102] Created future:
[10:19:23.102] List of future strategies:
[10:19:23.102] 1. sequential:
[10:19:23.102]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.102]    - tweaked: FALSE
[10:19:23.102]    - call: NULL
[10:19:23.104] plan(): nbrOfWorkers() = 1
[10:19:23.108] plan(): Setting new future strategy stack:
[10:19:23.108] List of future strategies:
[10:19:23.108] 1. multicore:
[10:19:23.108]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.108]    - tweaked: FALSE
[10:19:23.108]    - call: plan(strategy)
[10:19:23.112] plan(): nbrOfWorkers() = 2
[10:19:23.103] MulticoreFuture:
[10:19:23.103] Label: ‘future_.mapply-2’
[10:19:23.103] Expression:
[10:19:23.103] {
[10:19:23.103]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.103]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.103]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.103]         on.exit(options(oopts), add = TRUE)
[10:19:23.103]     }
[10:19:23.103]     {
[10:19:23.103]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.103]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.103]         do.call(mapply, args = args)
[10:19:23.103]     }
[10:19:23.103] }
[10:19:23.103] Lazy evaluation: FALSE
[10:19:23.103] Asynchronous evaluation: TRUE
[10:19:23.103] Local evaluation: TRUE
[10:19:23.103] Environment: R_GlobalEnv
[10:19:23.103] Capture standard output: TRUE
[10:19:23.103] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.103] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.103] Packages: <none>
[10:19:23.103] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:23.103] Resolved: TRUE
[10:19:23.103] Value: <not collected>
[10:19:23.103] Conditions captured: <none>
[10:19:23.103] Early signaling: FALSE
[10:19:23.103] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.103] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.114] Chunk #2 of 2 ... DONE
[10:19:23.114] Launching 2 futures (chunks) ... DONE
[10:19:23.114] Resolving 2 futures (chunks) ...
[10:19:23.114] resolve() on list ...
[10:19:23.114]  recursive: 0
[10:19:23.115]  length: 2
[10:19:23.115] 
[10:19:23.115] Future #1
[10:19:23.115] result() for MulticoreFuture ...
[10:19:23.116] result() for MulticoreFuture ...
[10:19:23.117] result() for MulticoreFuture ... done
[10:19:23.117] result() for MulticoreFuture ... done
[10:19:23.117] result() for MulticoreFuture ...
[10:19:23.117] result() for MulticoreFuture ... done
[10:19:23.117] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:23.118] - nx: 2
[10:19:23.118] - relay: TRUE
[10:19:23.118] - stdout: TRUE
[10:19:23.118] - signal: TRUE
[10:19:23.118] - resignal: FALSE
[10:19:23.119] - force: TRUE
[10:19:23.119] - relayed: [n=2] FALSE, FALSE
[10:19:23.119] - queued futures: [n=2] FALSE, FALSE
[10:19:23.119]  - until=1
[10:19:23.119]  - relaying element #1
[10:19:23.120] result() for MulticoreFuture ...
[10:19:23.120] result() for MulticoreFuture ... done
[10:19:23.120] result() for MulticoreFuture ...
[10:19:23.120] result() for MulticoreFuture ... done
[10:19:23.121] result() for MulticoreFuture ...
[10:19:23.121] result() for MulticoreFuture ... done
[10:19:23.121] result() for MulticoreFuture ...
[10:19:23.121] result() for MulticoreFuture ... done
[10:19:23.121] - relayed: [n=2] TRUE, FALSE
[10:19:23.121] - queued futures: [n=2] TRUE, FALSE
[10:19:23.122] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:23.122]  length: 1 (resolved future 1)
[10:19:23.122] Future #2
[10:19:23.123] result() for MulticoreFuture ...
[10:19:23.123] result() for MulticoreFuture ...
[10:19:23.124] result() for MulticoreFuture ... done
[10:19:23.124] result() for MulticoreFuture ... done
[10:19:23.124] result() for MulticoreFuture ...
[10:19:23.124] result() for MulticoreFuture ... done
[10:19:23.124] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:23.124] - nx: 2
[10:19:23.124] - relay: TRUE
[10:19:23.125] - stdout: TRUE
[10:19:23.125] - signal: TRUE
[10:19:23.125] - resignal: FALSE
[10:19:23.125] - force: TRUE
[10:19:23.125] - relayed: [n=2] TRUE, FALSE
[10:19:23.125] - queued futures: [n=2] TRUE, FALSE
[10:19:23.125]  - until=2
[10:19:23.125]  - relaying element #2
[10:19:23.125] result() for MulticoreFuture ...
[10:19:23.126] result() for MulticoreFuture ... done
[10:19:23.126] result() for MulticoreFuture ...
[10:19:23.126] result() for MulticoreFuture ... done
[10:19:23.126] result() for MulticoreFuture ...
[10:19:23.126] result() for MulticoreFuture ... done
[10:19:23.126] result() for MulticoreFuture ...
[10:19:23.126] result() for MulticoreFuture ... done
[10:19:23.126] - relayed: [n=2] TRUE, TRUE
[10:19:23.126] - queued futures: [n=2] TRUE, TRUE
[10:19:23.127] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:23.127]  length: 0 (resolved future 2)
[10:19:23.127] Relaying remaining futures
[10:19:23.127] signalConditionsASAP(NULL, pos=0) ...
[10:19:23.127] - nx: 2
[10:19:23.127] - relay: TRUE
[10:19:23.127] - stdout: TRUE
[10:19:23.127] - signal: TRUE
[10:19:23.127] - resignal: FALSE
[10:19:23.127] - force: TRUE
[10:19:23.128] - relayed: [n=2] TRUE, TRUE
[10:19:23.128] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:23.128] - relayed: [n=2] TRUE, TRUE
[10:19:23.128] - queued futures: [n=2] TRUE, TRUE
[10:19:23.128] signalConditionsASAP(NULL, pos=0) ... done
[10:19:23.128] resolve() on list ... DONE
[10:19:23.128] result() for MulticoreFuture ...
[10:19:23.128] result() for MulticoreFuture ... done
[10:19:23.128] result() for MulticoreFuture ...
[10:19:23.129] result() for MulticoreFuture ... done
[10:19:23.129] result() for MulticoreFuture ...
[10:19:23.129] result() for MulticoreFuture ... done
[10:19:23.129] result() for MulticoreFuture ...
[10:19:23.129] result() for MulticoreFuture ... done
[10:19:23.129]  - Number of value chunks collected: 2
[10:19:23.129] Resolving 2 futures (chunks) ... DONE
[10:19:23.129] Reducing values from 2 chunks ...
[10:19:23.129]  - Number of values collected after concatenation: 2
[10:19:23.129]  - Number of values expected: 2
[10:19:23.130] Reducing values from 2 chunks ... DONE
[10:19:23.130] future_mapply() ... DONE
- Recycle arguments to same length ...
[10:19:23.130] future_mapply() ...
[10:19:23.132] Number of chunks: 2
[10:19:23.132] getGlobalsAndPackagesXApply() ...
[10:19:23.132]  - future.globals: TRUE
[10:19:23.132] getGlobalsAndPackages() ...
[10:19:23.132] Searching for globals...
[10:19:23.133] - globals found: [1] ‘FUN’
[10:19:23.133] Searching for globals ... DONE
[10:19:23.133] Resolving globals: FALSE
[10:19:23.134] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:23.134] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:23.134] - globals: [1] ‘FUN’
[10:19:23.134] 
[10:19:23.134] getGlobalsAndPackages() ... DONE
[10:19:23.135]  - globals found/used: [n=1] ‘FUN’
[10:19:23.135]  - needed namespaces: [n=0] 
[10:19:23.135] Finding globals ... DONE
[10:19:23.135] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:23.135] List of 2
[10:19:23.135]  $ ...future.FUN:function (x, ...)  
[10:19:23.135]  $ MoreArgs     : NULL
[10:19:23.135]  - attr(*, "where")=List of 2
[10:19:23.135]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:23.135]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:23.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.135]  - attr(*, "resolved")= logi FALSE
[10:19:23.135]  - attr(*, "total_size")= num NA
[10:19:23.141] Packages to be attached in all futures: [n=0] 
[10:19:23.141] getGlobalsAndPackagesXApply() ... DONE
[10:19:23.141] Number of futures (= number of chunks): 2
[10:19:23.141] Launching 2 futures (chunks) ...
[10:19:23.141] Chunk #1 of 2 ...
[10:19:23.141]  - Finding globals in '...' for chunk #1 ...
[10:19:23.142] getGlobalsAndPackages() ...
[10:19:23.142] Searching for globals...
[10:19:23.142] 
[10:19:23.142] Searching for globals ... DONE
[10:19:23.142] - globals: [0] <none>
[10:19:23.143] getGlobalsAndPackages() ... DONE
[10:19:23.143]    + additional globals found: [n=0] 
[10:19:23.143]    + additional namespaces needed: [n=0] 
[10:19:23.143]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:23.143]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.143]  - seeds: <none>
[10:19:23.143]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.143] getGlobalsAndPackages() ...
[10:19:23.144] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.144] Resolving globals: FALSE
[10:19:23.144] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:23.145] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:23.145] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.145] 
[10:19:23.145] getGlobalsAndPackages() ... DONE
[10:19:23.146] run() for ‘Future’ ...
[10:19:23.146] - state: ‘created’
[10:19:23.146] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.148] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.148] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.148]   - Field: ‘label’
[10:19:23.148]   - Field: ‘local’
[10:19:23.149]   - Field: ‘owner’
[10:19:23.149]   - Field: ‘envir’
[10:19:23.149]   - Field: ‘workers’
[10:19:23.149]   - Field: ‘packages’
[10:19:23.149]   - Field: ‘gc’
[10:19:23.149]   - Field: ‘job’
[10:19:23.149]   - Field: ‘conditions’
[10:19:23.149]   - Field: ‘expr’
[10:19:23.149]   - Field: ‘uuid’
[10:19:23.149]   - Field: ‘seed’
[10:19:23.150]   - Field: ‘version’
[10:19:23.150]   - Field: ‘result’
[10:19:23.150]   - Field: ‘asynchronous’
[10:19:23.150]   - Field: ‘calls’
[10:19:23.150]   - Field: ‘globals’
[10:19:23.150]   - Field: ‘stdout’
[10:19:23.150]   - Field: ‘earlySignal’
[10:19:23.150]   - Field: ‘lazy’
[10:19:23.150]   - Field: ‘state’
[10:19:23.150] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.150] - Launch lazy future ...
[10:19:23.151] Packages needed by the future expression (n = 0): <none>
[10:19:23.151] Packages needed by future strategies (n = 0): <none>
[10:19:23.151] {
[10:19:23.151]     {
[10:19:23.151]         {
[10:19:23.151]             ...future.startTime <- base::Sys.time()
[10:19:23.151]             {
[10:19:23.151]                 {
[10:19:23.151]                   {
[10:19:23.151]                     {
[10:19:23.151]                       base::local({
[10:19:23.151]                         has_future <- base::requireNamespace("future", 
[10:19:23.151]                           quietly = TRUE)
[10:19:23.151]                         if (has_future) {
[10:19:23.151]                           ns <- base::getNamespace("future")
[10:19:23.151]                           version <- ns[[".package"]][["version"]]
[10:19:23.151]                           if (is.null(version)) 
[10:19:23.151]                             version <- utils::packageVersion("future")
[10:19:23.151]                         }
[10:19:23.151]                         else {
[10:19:23.151]                           version <- NULL
[10:19:23.151]                         }
[10:19:23.151]                         if (!has_future || version < "1.8.0") {
[10:19:23.151]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.151]                             "", base::R.version$version.string), 
[10:19:23.151]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:23.151]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:23.151]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.151]                               "release", "version")], collapse = " "), 
[10:19:23.151]                             hostname = base::Sys.info()[["nodename"]])
[10:19:23.151]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.151]                             info)
[10:19:23.151]                           info <- base::paste(info, collapse = "; ")
[10:19:23.151]                           if (!has_future) {
[10:19:23.151]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.151]                               info)
[10:19:23.151]                           }
[10:19:23.151]                           else {
[10:19:23.151]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.151]                               info, version)
[10:19:23.151]                           }
[10:19:23.151]                           base::stop(msg)
[10:19:23.151]                         }
[10:19:23.151]                       })
[10:19:23.151]                     }
[10:19:23.151]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.151]                     base::options(mc.cores = 1L)
[10:19:23.151]                   }
[10:19:23.151]                   ...future.strategy.old <- future::plan("list")
[10:19:23.151]                   options(future.plan = NULL)
[10:19:23.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.151]                 }
[10:19:23.151]                 ...future.workdir <- getwd()
[10:19:23.151]             }
[10:19:23.151]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.151]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.151]         }
[10:19:23.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.151]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.151]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.151]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.151]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.151]             base::names(...future.oldOptions))
[10:19:23.151]     }
[10:19:23.151]     if (FALSE) {
[10:19:23.151]     }
[10:19:23.151]     else {
[10:19:23.151]         if (TRUE) {
[10:19:23.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.151]                 open = "w")
[10:19:23.151]         }
[10:19:23.151]         else {
[10:19:23.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.151]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.151]         }
[10:19:23.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.151]             base::sink(type = "output", split = FALSE)
[10:19:23.151]             base::close(...future.stdout)
[10:19:23.151]         }, add = TRUE)
[10:19:23.151]     }
[10:19:23.151]     ...future.frame <- base::sys.nframe()
[10:19:23.151]     ...future.conditions <- base::list()
[10:19:23.151]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.151]     if (FALSE) {
[10:19:23.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.151]     }
[10:19:23.151]     ...future.result <- base::tryCatch({
[10:19:23.151]         base::withCallingHandlers({
[10:19:23.151]             ...future.value <- base::withVisible(base::local({
[10:19:23.151]                 withCallingHandlers({
[10:19:23.151]                   {
[10:19:23.151]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.151]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.151]                       ...future.globals.maxSize)) {
[10:19:23.151]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.151]                       on.exit(options(oopts), add = TRUE)
[10:19:23.151]                     }
[10:19:23.151]                     {
[10:19:23.151]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.151]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.151]                         USE.NAMES = FALSE)
[10:19:23.151]                       do.call(mapply, args = args)
[10:19:23.151]                     }
[10:19:23.151]                   }
[10:19:23.151]                 }, immediateCondition = function(cond) {
[10:19:23.151]                   save_rds <- function (object, pathname, ...) 
[10:19:23.151]                   {
[10:19:23.151]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.151]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.151]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.151]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.151]                         fi_tmp[["mtime"]])
[10:19:23.151]                     }
[10:19:23.151]                     tryCatch({
[10:19:23.151]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.151]                     }, error = function(ex) {
[10:19:23.151]                       msg <- conditionMessage(ex)
[10:19:23.151]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.151]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.151]                         fi_tmp[["mtime"]], msg)
[10:19:23.151]                       ex$message <- msg
[10:19:23.151]                       stop(ex)
[10:19:23.151]                     })
[10:19:23.151]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.151]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.151]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.151]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.151]                       fi <- file.info(pathname)
[10:19:23.151]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.151]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.151]                         fi[["size"]], fi[["mtime"]])
[10:19:23.151]                       stop(msg)
[10:19:23.151]                     }
[10:19:23.151]                     invisible(pathname)
[10:19:23.151]                   }
[10:19:23.151]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.151]                     rootPath = tempdir()) 
[10:19:23.151]                   {
[10:19:23.151]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.151]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.151]                       tmpdir = path, fileext = ".rds")
[10:19:23.151]                     save_rds(obj, file)
[10:19:23.151]                   }
[10:19:23.151]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.151]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.151]                   {
[10:19:23.151]                     inherits <- base::inherits
[10:19:23.151]                     invokeRestart <- base::invokeRestart
[10:19:23.151]                     is.null <- base::is.null
[10:19:23.151]                     muffled <- FALSE
[10:19:23.151]                     if (inherits(cond, "message")) {
[10:19:23.151]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.151]                       if (muffled) 
[10:19:23.151]                         invokeRestart("muffleMessage")
[10:19:23.151]                     }
[10:19:23.151]                     else if (inherits(cond, "warning")) {
[10:19:23.151]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.151]                       if (muffled) 
[10:19:23.151]                         invokeRestart("muffleWarning")
[10:19:23.151]                     }
[10:19:23.151]                     else if (inherits(cond, "condition")) {
[10:19:23.151]                       if (!is.null(pattern)) {
[10:19:23.151]                         computeRestarts <- base::computeRestarts
[10:19:23.151]                         grepl <- base::grepl
[10:19:23.151]                         restarts <- computeRestarts(cond)
[10:19:23.151]                         for (restart in restarts) {
[10:19:23.151]                           name <- restart$name
[10:19:23.151]                           if (is.null(name)) 
[10:19:23.151]                             next
[10:19:23.151]                           if (!grepl(pattern, name)) 
[10:19:23.151]                             next
[10:19:23.151]                           invokeRestart(restart)
[10:19:23.151]                           muffled <- TRUE
[10:19:23.151]                           break
[10:19:23.151]                         }
[10:19:23.151]                       }
[10:19:23.151]                     }
[10:19:23.151]                     invisible(muffled)
[10:19:23.151]                   }
[10:19:23.151]                   muffleCondition(cond)
[10:19:23.151]                 })
[10:19:23.151]             }))
[10:19:23.151]             future::FutureResult(value = ...future.value$value, 
[10:19:23.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.151]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.151]                     ...future.globalenv.names))
[10:19:23.151]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.151]         }, condition = base::local({
[10:19:23.151]             c <- base::c
[10:19:23.151]             inherits <- base::inherits
[10:19:23.151]             invokeRestart <- base::invokeRestart
[10:19:23.151]             length <- base::length
[10:19:23.151]             list <- base::list
[10:19:23.151]             seq.int <- base::seq.int
[10:19:23.151]             signalCondition <- base::signalCondition
[10:19:23.151]             sys.calls <- base::sys.calls
[10:19:23.151]             `[[` <- base::`[[`
[10:19:23.151]             `+` <- base::`+`
[10:19:23.151]             `<<-` <- base::`<<-`
[10:19:23.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.151]                   3L)]
[10:19:23.151]             }
[10:19:23.151]             function(cond) {
[10:19:23.151]                 is_error <- inherits(cond, "error")
[10:19:23.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.151]                   NULL)
[10:19:23.151]                 if (is_error) {
[10:19:23.151]                   sessionInformation <- function() {
[10:19:23.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.151]                       search = base::search(), system = base::Sys.info())
[10:19:23.151]                   }
[10:19:23.151]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.151]                     cond$call), session = sessionInformation(), 
[10:19:23.151]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.151]                   signalCondition(cond)
[10:19:23.151]                 }
[10:19:23.151]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.151]                 "immediateCondition"))) {
[10:19:23.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.151]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.151]                   if (TRUE && !signal) {
[10:19:23.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.151]                     {
[10:19:23.151]                       inherits <- base::inherits
[10:19:23.151]                       invokeRestart <- base::invokeRestart
[10:19:23.151]                       is.null <- base::is.null
[10:19:23.151]                       muffled <- FALSE
[10:19:23.151]                       if (inherits(cond, "message")) {
[10:19:23.151]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.151]                         if (muffled) 
[10:19:23.151]                           invokeRestart("muffleMessage")
[10:19:23.151]                       }
[10:19:23.151]                       else if (inherits(cond, "warning")) {
[10:19:23.151]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.151]                         if (muffled) 
[10:19:23.151]                           invokeRestart("muffleWarning")
[10:19:23.151]                       }
[10:19:23.151]                       else if (inherits(cond, "condition")) {
[10:19:23.151]                         if (!is.null(pattern)) {
[10:19:23.151]                           computeRestarts <- base::computeRestarts
[10:19:23.151]                           grepl <- base::grepl
[10:19:23.151]                           restarts <- computeRestarts(cond)
[10:19:23.151]                           for (restart in restarts) {
[10:19:23.151]                             name <- restart$name
[10:19:23.151]                             if (is.null(name)) 
[10:19:23.151]                               next
[10:19:23.151]                             if (!grepl(pattern, name)) 
[10:19:23.151]                               next
[10:19:23.151]                             invokeRestart(restart)
[10:19:23.151]                             muffled <- TRUE
[10:19:23.151]                             break
[10:19:23.151]                           }
[10:19:23.151]                         }
[10:19:23.151]                       }
[10:19:23.151]                       invisible(muffled)
[10:19:23.151]                     }
[10:19:23.151]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.151]                   }
[10:19:23.151]                 }
[10:19:23.151]                 else {
[10:19:23.151]                   if (TRUE) {
[10:19:23.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.151]                     {
[10:19:23.151]                       inherits <- base::inherits
[10:19:23.151]                       invokeRestart <- base::invokeRestart
[10:19:23.151]                       is.null <- base::is.null
[10:19:23.151]                       muffled <- FALSE
[10:19:23.151]                       if (inherits(cond, "message")) {
[10:19:23.151]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.151]                         if (muffled) 
[10:19:23.151]                           invokeRestart("muffleMessage")
[10:19:23.151]                       }
[10:19:23.151]                       else if (inherits(cond, "warning")) {
[10:19:23.151]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.151]                         if (muffled) 
[10:19:23.151]                           invokeRestart("muffleWarning")
[10:19:23.151]                       }
[10:19:23.151]                       else if (inherits(cond, "condition")) {
[10:19:23.151]                         if (!is.null(pattern)) {
[10:19:23.151]                           computeRestarts <- base::computeRestarts
[10:19:23.151]                           grepl <- base::grepl
[10:19:23.151]                           restarts <- computeRestarts(cond)
[10:19:23.151]                           for (restart in restarts) {
[10:19:23.151]                             name <- restart$name
[10:19:23.151]                             if (is.null(name)) 
[10:19:23.151]                               next
[10:19:23.151]                             if (!grepl(pattern, name)) 
[10:19:23.151]                               next
[10:19:23.151]                             invokeRestart(restart)
[10:19:23.151]                             muffled <- TRUE
[10:19:23.151]                             break
[10:19:23.151]                           }
[10:19:23.151]                         }
[10:19:23.151]                       }
[10:19:23.151]                       invisible(muffled)
[10:19:23.151]                     }
[10:19:23.151]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.151]                   }
[10:19:23.151]                 }
[10:19:23.151]             }
[10:19:23.151]         }))
[10:19:23.151]     }, error = function(ex) {
[10:19:23.151]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.151]                 ...future.rng), started = ...future.startTime, 
[10:19:23.151]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.151]             version = "1.8"), class = "FutureResult")
[10:19:23.151]     }, finally = {
[10:19:23.151]         if (!identical(...future.workdir, getwd())) 
[10:19:23.151]             setwd(...future.workdir)
[10:19:23.151]         {
[10:19:23.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.151]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.151]             }
[10:19:23.151]             base::options(...future.oldOptions)
[10:19:23.151]             if (.Platform$OS.type == "windows") {
[10:19:23.151]                 old_names <- names(...future.oldEnvVars)
[10:19:23.151]                 envs <- base::Sys.getenv()
[10:19:23.151]                 names <- names(envs)
[10:19:23.151]                 common <- intersect(names, old_names)
[10:19:23.151]                 added <- setdiff(names, old_names)
[10:19:23.151]                 removed <- setdiff(old_names, names)
[10:19:23.151]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.151]                   envs[common]]
[10:19:23.151]                 NAMES <- toupper(changed)
[10:19:23.151]                 args <- list()
[10:19:23.151]                 for (kk in seq_along(NAMES)) {
[10:19:23.151]                   name <- changed[[kk]]
[10:19:23.151]                   NAME <- NAMES[[kk]]
[10:19:23.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.151]                     next
[10:19:23.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.151]                 }
[10:19:23.151]                 NAMES <- toupper(added)
[10:19:23.151]                 for (kk in seq_along(NAMES)) {
[10:19:23.151]                   name <- added[[kk]]
[10:19:23.151]                   NAME <- NAMES[[kk]]
[10:19:23.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.151]                     next
[10:19:23.151]                   args[[name]] <- ""
[10:19:23.151]                 }
[10:19:23.151]                 NAMES <- toupper(removed)
[10:19:23.151]                 for (kk in seq_along(NAMES)) {
[10:19:23.151]                   name <- removed[[kk]]
[10:19:23.151]                   NAME <- NAMES[[kk]]
[10:19:23.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.151]                     next
[10:19:23.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.151]                 }
[10:19:23.151]                 if (length(args) > 0) 
[10:19:23.151]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.151]             }
[10:19:23.151]             else {
[10:19:23.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.151]             }
[10:19:23.151]             {
[10:19:23.151]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.151]                   0L) {
[10:19:23.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.151]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.151]                   base::options(opts)
[10:19:23.151]                 }
[10:19:23.151]                 {
[10:19:23.151]                   {
[10:19:23.151]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.151]                     NULL
[10:19:23.151]                   }
[10:19:23.151]                   options(future.plan = NULL)
[10:19:23.151]                   if (is.na(NA_character_)) 
[10:19:23.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.151]                     .init = FALSE)
[10:19:23.151]                 }
[10:19:23.151]             }
[10:19:23.151]         }
[10:19:23.151]     })
[10:19:23.151]     if (TRUE) {
[10:19:23.151]         base::sink(type = "output", split = FALSE)
[10:19:23.151]         if (TRUE) {
[10:19:23.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.151]         }
[10:19:23.151]         else {
[10:19:23.151]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.151]         }
[10:19:23.151]         base::close(...future.stdout)
[10:19:23.151]         ...future.stdout <- NULL
[10:19:23.151]     }
[10:19:23.151]     ...future.result$conditions <- ...future.conditions
[10:19:23.151]     ...future.result$finished <- base::Sys.time()
[10:19:23.151]     ...future.result
[10:19:23.151] }
[10:19:23.154] assign_globals() ...
[10:19:23.154] List of 5
[10:19:23.154]  $ ...future.FUN            :function (x, ...)  
[10:19:23.154]  $ MoreArgs                 : NULL
[10:19:23.154]  $ ...future.elements_ii    :List of 2
[10:19:23.154]   ..$ :List of 2
[10:19:23.154]   .. ..$ : int 1
[10:19:23.154]   .. ..$ : int 2
[10:19:23.154]   ..$ :List of 2
[10:19:23.154]   .. ..$ : int 2
[10:19:23.154]   .. ..$ : int 1
[10:19:23.154]  $ ...future.seeds_ii       : NULL
[10:19:23.154]  $ ...future.globals.maxSize: NULL
[10:19:23.154]  - attr(*, "where")=List of 5
[10:19:23.154]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.154]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.154]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.154]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.154]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.154]  - attr(*, "resolved")= logi FALSE
[10:19:23.154]  - attr(*, "total_size")= num 210
[10:19:23.154]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.154]  - attr(*, "already-done")= logi TRUE
[10:19:23.160] - copied ‘...future.FUN’ to environment
[10:19:23.160] - copied ‘MoreArgs’ to environment
[10:19:23.160] - copied ‘...future.elements_ii’ to environment
[10:19:23.160] - copied ‘...future.seeds_ii’ to environment
[10:19:23.160] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.160] assign_globals() ... done
[10:19:23.161] requestCore(): workers = 2
[10:19:23.163] MulticoreFuture started
[10:19:23.163] - Launch lazy future ... done
[10:19:23.164] run() for ‘MulticoreFuture’ ... done
[10:19:23.164] Created future:
[10:19:23.164] plan(): Setting new future strategy stack:
[10:19:23.164] List of future strategies:
[10:19:23.164] 1. sequential:
[10:19:23.164]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.164]    - tweaked: FALSE
[10:19:23.164]    - call: NULL
[10:19:23.165] plan(): nbrOfWorkers() = 1
[10:19:23.172] plan(): Setting new future strategy stack:
[10:19:23.172] List of future strategies:
[10:19:23.172] 1. multicore:
[10:19:23.172]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.172]    - tweaked: FALSE
[10:19:23.172]    - call: plan(strategy)
[10:19:23.177] plan(): nbrOfWorkers() = 2
[10:19:23.164] MulticoreFuture:
[10:19:23.164] Label: ‘future_mapply-1’
[10:19:23.164] Expression:
[10:19:23.164] {
[10:19:23.164]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.164]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.164]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.164]         on.exit(options(oopts), add = TRUE)
[10:19:23.164]     }
[10:19:23.164]     {
[10:19:23.164]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.164]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.164]         do.call(mapply, args = args)
[10:19:23.164]     }
[10:19:23.164] }
[10:19:23.164] Lazy evaluation: FALSE
[10:19:23.164] Asynchronous evaluation: TRUE
[10:19:23.164] Local evaluation: TRUE
[10:19:23.164] Environment: R_GlobalEnv
[10:19:23.164] Capture standard output: TRUE
[10:19:23.164] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.164] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.164] Packages: <none>
[10:19:23.164] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:23.164] Resolved: TRUE
[10:19:23.164] Value: <not collected>
[10:19:23.164] Conditions captured: <none>
[10:19:23.164] Early signaling: FALSE
[10:19:23.164] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.164] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.179] Chunk #1 of 2 ... DONE
[10:19:23.179] Chunk #2 of 2 ...
[10:19:23.179]  - Finding globals in '...' for chunk #2 ...
[10:19:23.180] getGlobalsAndPackages() ...
[10:19:23.180] Searching for globals...
[10:19:23.181] 
[10:19:23.181] Searching for globals ... DONE
[10:19:23.181] - globals: [0] <none>
[10:19:23.181] getGlobalsAndPackages() ... DONE
[10:19:23.181]    + additional globals found: [n=0] 
[10:19:23.182]    + additional namespaces needed: [n=0] 
[10:19:23.182]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:23.182]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.182]  - seeds: <none>
[10:19:23.182]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.183] getGlobalsAndPackages() ...
[10:19:23.183] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.183] Resolving globals: FALSE
[10:19:23.184] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:23.185] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:23.185] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.186] 
[10:19:23.186] getGlobalsAndPackages() ... DONE
[10:19:23.186] run() for ‘Future’ ...
[10:19:23.187] - state: ‘created’
[10:19:23.187] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.190] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.190] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.190]   - Field: ‘label’
[10:19:23.190]   - Field: ‘local’
[10:19:23.191]   - Field: ‘owner’
[10:19:23.191]   - Field: ‘envir’
[10:19:23.191]   - Field: ‘workers’
[10:19:23.191]   - Field: ‘packages’
[10:19:23.191]   - Field: ‘gc’
[10:19:23.192]   - Field: ‘job’
[10:19:23.192]   - Field: ‘conditions’
[10:19:23.192]   - Field: ‘expr’
[10:19:23.192]   - Field: ‘uuid’
[10:19:23.192]   - Field: ‘seed’
[10:19:23.192]   - Field: ‘version’
[10:19:23.193]   - Field: ‘result’
[10:19:23.193]   - Field: ‘asynchronous’
[10:19:23.193]   - Field: ‘calls’
[10:19:23.193]   - Field: ‘globals’
[10:19:23.193]   - Field: ‘stdout’
[10:19:23.193]   - Field: ‘earlySignal’
[10:19:23.193]   - Field: ‘lazy’
[10:19:23.194]   - Field: ‘state’
[10:19:23.194] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.194] - Launch lazy future ...
[10:19:23.194] Packages needed by the future expression (n = 0): <none>
[10:19:23.194] Packages needed by future strategies (n = 0): <none>
[10:19:23.195] {
[10:19:23.195]     {
[10:19:23.195]         {
[10:19:23.195]             ...future.startTime <- base::Sys.time()
[10:19:23.195]             {
[10:19:23.195]                 {
[10:19:23.195]                   {
[10:19:23.195]                     {
[10:19:23.195]                       base::local({
[10:19:23.195]                         has_future <- base::requireNamespace("future", 
[10:19:23.195]                           quietly = TRUE)
[10:19:23.195]                         if (has_future) {
[10:19:23.195]                           ns <- base::getNamespace("future")
[10:19:23.195]                           version <- ns[[".package"]][["version"]]
[10:19:23.195]                           if (is.null(version)) 
[10:19:23.195]                             version <- utils::packageVersion("future")
[10:19:23.195]                         }
[10:19:23.195]                         else {
[10:19:23.195]                           version <- NULL
[10:19:23.195]                         }
[10:19:23.195]                         if (!has_future || version < "1.8.0") {
[10:19:23.195]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.195]                             "", base::R.version$version.string), 
[10:19:23.195]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:23.195]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:23.195]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.195]                               "release", "version")], collapse = " "), 
[10:19:23.195]                             hostname = base::Sys.info()[["nodename"]])
[10:19:23.195]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.195]                             info)
[10:19:23.195]                           info <- base::paste(info, collapse = "; ")
[10:19:23.195]                           if (!has_future) {
[10:19:23.195]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.195]                               info)
[10:19:23.195]                           }
[10:19:23.195]                           else {
[10:19:23.195]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.195]                               info, version)
[10:19:23.195]                           }
[10:19:23.195]                           base::stop(msg)
[10:19:23.195]                         }
[10:19:23.195]                       })
[10:19:23.195]                     }
[10:19:23.195]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.195]                     base::options(mc.cores = 1L)
[10:19:23.195]                   }
[10:19:23.195]                   ...future.strategy.old <- future::plan("list")
[10:19:23.195]                   options(future.plan = NULL)
[10:19:23.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.195]                 }
[10:19:23.195]                 ...future.workdir <- getwd()
[10:19:23.195]             }
[10:19:23.195]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.195]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.195]         }
[10:19:23.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.195]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.195]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.195]             base::names(...future.oldOptions))
[10:19:23.195]     }
[10:19:23.195]     if (FALSE) {
[10:19:23.195]     }
[10:19:23.195]     else {
[10:19:23.195]         if (TRUE) {
[10:19:23.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.195]                 open = "w")
[10:19:23.195]         }
[10:19:23.195]         else {
[10:19:23.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.195]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.195]         }
[10:19:23.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.195]             base::sink(type = "output", split = FALSE)
[10:19:23.195]             base::close(...future.stdout)
[10:19:23.195]         }, add = TRUE)
[10:19:23.195]     }
[10:19:23.195]     ...future.frame <- base::sys.nframe()
[10:19:23.195]     ...future.conditions <- base::list()
[10:19:23.195]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.195]     if (FALSE) {
[10:19:23.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.195]     }
[10:19:23.195]     ...future.result <- base::tryCatch({
[10:19:23.195]         base::withCallingHandlers({
[10:19:23.195]             ...future.value <- base::withVisible(base::local({
[10:19:23.195]                 withCallingHandlers({
[10:19:23.195]                   {
[10:19:23.195]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.195]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.195]                       ...future.globals.maxSize)) {
[10:19:23.195]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.195]                       on.exit(options(oopts), add = TRUE)
[10:19:23.195]                     }
[10:19:23.195]                     {
[10:19:23.195]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.195]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.195]                         USE.NAMES = FALSE)
[10:19:23.195]                       do.call(mapply, args = args)
[10:19:23.195]                     }
[10:19:23.195]                   }
[10:19:23.195]                 }, immediateCondition = function(cond) {
[10:19:23.195]                   save_rds <- function (object, pathname, ...) 
[10:19:23.195]                   {
[10:19:23.195]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.195]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.195]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.195]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.195]                         fi_tmp[["mtime"]])
[10:19:23.195]                     }
[10:19:23.195]                     tryCatch({
[10:19:23.195]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.195]                     }, error = function(ex) {
[10:19:23.195]                       msg <- conditionMessage(ex)
[10:19:23.195]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.195]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.195]                         fi_tmp[["mtime"]], msg)
[10:19:23.195]                       ex$message <- msg
[10:19:23.195]                       stop(ex)
[10:19:23.195]                     })
[10:19:23.195]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.195]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.195]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.195]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.195]                       fi <- file.info(pathname)
[10:19:23.195]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.195]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.195]                         fi[["size"]], fi[["mtime"]])
[10:19:23.195]                       stop(msg)
[10:19:23.195]                     }
[10:19:23.195]                     invisible(pathname)
[10:19:23.195]                   }
[10:19:23.195]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.195]                     rootPath = tempdir()) 
[10:19:23.195]                   {
[10:19:23.195]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.195]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.195]                       tmpdir = path, fileext = ".rds")
[10:19:23.195]                     save_rds(obj, file)
[10:19:23.195]                   }
[10:19:23.195]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.195]                   {
[10:19:23.195]                     inherits <- base::inherits
[10:19:23.195]                     invokeRestart <- base::invokeRestart
[10:19:23.195]                     is.null <- base::is.null
[10:19:23.195]                     muffled <- FALSE
[10:19:23.195]                     if (inherits(cond, "message")) {
[10:19:23.195]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.195]                       if (muffled) 
[10:19:23.195]                         invokeRestart("muffleMessage")
[10:19:23.195]                     }
[10:19:23.195]                     else if (inherits(cond, "warning")) {
[10:19:23.195]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.195]                       if (muffled) 
[10:19:23.195]                         invokeRestart("muffleWarning")
[10:19:23.195]                     }
[10:19:23.195]                     else if (inherits(cond, "condition")) {
[10:19:23.195]                       if (!is.null(pattern)) {
[10:19:23.195]                         computeRestarts <- base::computeRestarts
[10:19:23.195]                         grepl <- base::grepl
[10:19:23.195]                         restarts <- computeRestarts(cond)
[10:19:23.195]                         for (restart in restarts) {
[10:19:23.195]                           name <- restart$name
[10:19:23.195]                           if (is.null(name)) 
[10:19:23.195]                             next
[10:19:23.195]                           if (!grepl(pattern, name)) 
[10:19:23.195]                             next
[10:19:23.195]                           invokeRestart(restart)
[10:19:23.195]                           muffled <- TRUE
[10:19:23.195]                           break
[10:19:23.195]                         }
[10:19:23.195]                       }
[10:19:23.195]                     }
[10:19:23.195]                     invisible(muffled)
[10:19:23.195]                   }
[10:19:23.195]                   muffleCondition(cond)
[10:19:23.195]                 })
[10:19:23.195]             }))
[10:19:23.195]             future::FutureResult(value = ...future.value$value, 
[10:19:23.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.195]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.195]                     ...future.globalenv.names))
[10:19:23.195]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.195]         }, condition = base::local({
[10:19:23.195]             c <- base::c
[10:19:23.195]             inherits <- base::inherits
[10:19:23.195]             invokeRestart <- base::invokeRestart
[10:19:23.195]             length <- base::length
[10:19:23.195]             list <- base::list
[10:19:23.195]             seq.int <- base::seq.int
[10:19:23.195]             signalCondition <- base::signalCondition
[10:19:23.195]             sys.calls <- base::sys.calls
[10:19:23.195]             `[[` <- base::`[[`
[10:19:23.195]             `+` <- base::`+`
[10:19:23.195]             `<<-` <- base::`<<-`
[10:19:23.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.195]                   3L)]
[10:19:23.195]             }
[10:19:23.195]             function(cond) {
[10:19:23.195]                 is_error <- inherits(cond, "error")
[10:19:23.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.195]                   NULL)
[10:19:23.195]                 if (is_error) {
[10:19:23.195]                   sessionInformation <- function() {
[10:19:23.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.195]                       search = base::search(), system = base::Sys.info())
[10:19:23.195]                   }
[10:19:23.195]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.195]                     cond$call), session = sessionInformation(), 
[10:19:23.195]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.195]                   signalCondition(cond)
[10:19:23.195]                 }
[10:19:23.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.195]                 "immediateCondition"))) {
[10:19:23.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.195]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.195]                   if (TRUE && !signal) {
[10:19:23.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.195]                     {
[10:19:23.195]                       inherits <- base::inherits
[10:19:23.195]                       invokeRestart <- base::invokeRestart
[10:19:23.195]                       is.null <- base::is.null
[10:19:23.195]                       muffled <- FALSE
[10:19:23.195]                       if (inherits(cond, "message")) {
[10:19:23.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.195]                         if (muffled) 
[10:19:23.195]                           invokeRestart("muffleMessage")
[10:19:23.195]                       }
[10:19:23.195]                       else if (inherits(cond, "warning")) {
[10:19:23.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.195]                         if (muffled) 
[10:19:23.195]                           invokeRestart("muffleWarning")
[10:19:23.195]                       }
[10:19:23.195]                       else if (inherits(cond, "condition")) {
[10:19:23.195]                         if (!is.null(pattern)) {
[10:19:23.195]                           computeRestarts <- base::computeRestarts
[10:19:23.195]                           grepl <- base::grepl
[10:19:23.195]                           restarts <- computeRestarts(cond)
[10:19:23.195]                           for (restart in restarts) {
[10:19:23.195]                             name <- restart$name
[10:19:23.195]                             if (is.null(name)) 
[10:19:23.195]                               next
[10:19:23.195]                             if (!grepl(pattern, name)) 
[10:19:23.195]                               next
[10:19:23.195]                             invokeRestart(restart)
[10:19:23.195]                             muffled <- TRUE
[10:19:23.195]                             break
[10:19:23.195]                           }
[10:19:23.195]                         }
[10:19:23.195]                       }
[10:19:23.195]                       invisible(muffled)
[10:19:23.195]                     }
[10:19:23.195]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.195]                   }
[10:19:23.195]                 }
[10:19:23.195]                 else {
[10:19:23.195]                   if (TRUE) {
[10:19:23.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.195]                     {
[10:19:23.195]                       inherits <- base::inherits
[10:19:23.195]                       invokeRestart <- base::invokeRestart
[10:19:23.195]                       is.null <- base::is.null
[10:19:23.195]                       muffled <- FALSE
[10:19:23.195]                       if (inherits(cond, "message")) {
[10:19:23.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.195]                         if (muffled) 
[10:19:23.195]                           invokeRestart("muffleMessage")
[10:19:23.195]                       }
[10:19:23.195]                       else if (inherits(cond, "warning")) {
[10:19:23.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.195]                         if (muffled) 
[10:19:23.195]                           invokeRestart("muffleWarning")
[10:19:23.195]                       }
[10:19:23.195]                       else if (inherits(cond, "condition")) {
[10:19:23.195]                         if (!is.null(pattern)) {
[10:19:23.195]                           computeRestarts <- base::computeRestarts
[10:19:23.195]                           grepl <- base::grepl
[10:19:23.195]                           restarts <- computeRestarts(cond)
[10:19:23.195]                           for (restart in restarts) {
[10:19:23.195]                             name <- restart$name
[10:19:23.195]                             if (is.null(name)) 
[10:19:23.195]                               next
[10:19:23.195]                             if (!grepl(pattern, name)) 
[10:19:23.195]                               next
[10:19:23.195]                             invokeRestart(restart)
[10:19:23.195]                             muffled <- TRUE
[10:19:23.195]                             break
[10:19:23.195]                           }
[10:19:23.195]                         }
[10:19:23.195]                       }
[10:19:23.195]                       invisible(muffled)
[10:19:23.195]                     }
[10:19:23.195]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.195]                   }
[10:19:23.195]                 }
[10:19:23.195]             }
[10:19:23.195]         }))
[10:19:23.195]     }, error = function(ex) {
[10:19:23.195]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.195]                 ...future.rng), started = ...future.startTime, 
[10:19:23.195]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.195]             version = "1.8"), class = "FutureResult")
[10:19:23.195]     }, finally = {
[10:19:23.195]         if (!identical(...future.workdir, getwd())) 
[10:19:23.195]             setwd(...future.workdir)
[10:19:23.195]         {
[10:19:23.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.195]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.195]             }
[10:19:23.195]             base::options(...future.oldOptions)
[10:19:23.195]             if (.Platform$OS.type == "windows") {
[10:19:23.195]                 old_names <- names(...future.oldEnvVars)
[10:19:23.195]                 envs <- base::Sys.getenv()
[10:19:23.195]                 names <- names(envs)
[10:19:23.195]                 common <- intersect(names, old_names)
[10:19:23.195]                 added <- setdiff(names, old_names)
[10:19:23.195]                 removed <- setdiff(old_names, names)
[10:19:23.195]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.195]                   envs[common]]
[10:19:23.195]                 NAMES <- toupper(changed)
[10:19:23.195]                 args <- list()
[10:19:23.195]                 for (kk in seq_along(NAMES)) {
[10:19:23.195]                   name <- changed[[kk]]
[10:19:23.195]                   NAME <- NAMES[[kk]]
[10:19:23.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.195]                     next
[10:19:23.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.195]                 }
[10:19:23.195]                 NAMES <- toupper(added)
[10:19:23.195]                 for (kk in seq_along(NAMES)) {
[10:19:23.195]                   name <- added[[kk]]
[10:19:23.195]                   NAME <- NAMES[[kk]]
[10:19:23.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.195]                     next
[10:19:23.195]                   args[[name]] <- ""
[10:19:23.195]                 }
[10:19:23.195]                 NAMES <- toupper(removed)
[10:19:23.195]                 for (kk in seq_along(NAMES)) {
[10:19:23.195]                   name <- removed[[kk]]
[10:19:23.195]                   NAME <- NAMES[[kk]]
[10:19:23.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.195]                     next
[10:19:23.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.195]                 }
[10:19:23.195]                 if (length(args) > 0) 
[10:19:23.195]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.195]             }
[10:19:23.195]             else {
[10:19:23.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.195]             }
[10:19:23.195]             {
[10:19:23.195]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.195]                   0L) {
[10:19:23.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.195]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.195]                   base::options(opts)
[10:19:23.195]                 }
[10:19:23.195]                 {
[10:19:23.195]                   {
[10:19:23.195]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.195]                     NULL
[10:19:23.195]                   }
[10:19:23.195]                   options(future.plan = NULL)
[10:19:23.195]                   if (is.na(NA_character_)) 
[10:19:23.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.195]                     .init = FALSE)
[10:19:23.195]                 }
[10:19:23.195]             }
[10:19:23.195]         }
[10:19:23.195]     })
[10:19:23.195]     if (TRUE) {
[10:19:23.195]         base::sink(type = "output", split = FALSE)
[10:19:23.195]         if (TRUE) {
[10:19:23.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.195]         }
[10:19:23.195]         else {
[10:19:23.195]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.195]         }
[10:19:23.195]         base::close(...future.stdout)
[10:19:23.195]         ...future.stdout <- NULL
[10:19:23.195]     }
[10:19:23.195]     ...future.result$conditions <- ...future.conditions
[10:19:23.195]     ...future.result$finished <- base::Sys.time()
[10:19:23.195]     ...future.result
[10:19:23.195] }
[10:19:23.198] assign_globals() ...
[10:19:23.198] List of 5
[10:19:23.198]  $ ...future.FUN            :function (x, ...)  
[10:19:23.198]  $ MoreArgs                 : NULL
[10:19:23.198]  $ ...future.elements_ii    :List of 2
[10:19:23.198]   ..$ :List of 2
[10:19:23.198]   .. ..$ : int 3
[10:19:23.198]   .. ..$ : int 4
[10:19:23.198]   ..$ :List of 2
[10:19:23.198]   .. ..$ : int 2
[10:19:23.198]   .. ..$ : int 1
[10:19:23.198]  $ ...future.seeds_ii       : NULL
[10:19:23.198]  $ ...future.globals.maxSize: NULL
[10:19:23.198]  - attr(*, "where")=List of 5
[10:19:23.198]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.198]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.198]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.198]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.198]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.198]  - attr(*, "resolved")= logi FALSE
[10:19:23.198]  - attr(*, "total_size")= num 210
[10:19:23.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.198]  - attr(*, "already-done")= logi TRUE
[10:19:23.205] - copied ‘...future.FUN’ to environment
[10:19:23.205] - copied ‘MoreArgs’ to environment
[10:19:23.205] - copied ‘...future.elements_ii’ to environment
[10:19:23.206] - copied ‘...future.seeds_ii’ to environment
[10:19:23.206] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.206] assign_globals() ... done
[10:19:23.206] requestCore(): workers = 2
[10:19:23.208] MulticoreFuture started
[10:19:23.209] - Launch lazy future ... done
[10:19:23.209] run() for ‘MulticoreFuture’ ... done
[10:19:23.209] Created future:
[10:19:23.209] plan(): Setting new future strategy stack:
[10:19:23.210] List of future strategies:
[10:19:23.210] 1. sequential:
[10:19:23.210]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.210]    - tweaked: FALSE
[10:19:23.210]    - call: NULL
[10:19:23.211] plan(): nbrOfWorkers() = 1
[10:19:23.213] plan(): Setting new future strategy stack:
[10:19:23.213] List of future strategies:
[10:19:23.213] 1. multicore:
[10:19:23.213]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.213]    - tweaked: FALSE
[10:19:23.213]    - call: plan(strategy)
[10:19:23.209] MulticoreFuture:
[10:19:23.209] Label: ‘future_mapply-2’
[10:19:23.209] Expression:
[10:19:23.209] {
[10:19:23.209]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.209]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.209]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.209]         on.exit(options(oopts), add = TRUE)
[10:19:23.209]     }
[10:19:23.209]     {
[10:19:23.209]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.209]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.209]         do.call(mapply, args = args)
[10:19:23.209]     }
[10:19:23.209] }
[10:19:23.209] Lazy evaluation: FALSE
[10:19:23.209] Asynchronous evaluation: TRUE
[10:19:23.209] Local evaluation: TRUE
[10:19:23.209] Environment: R_GlobalEnv
[10:19:23.209] Capture standard output: TRUE
[10:19:23.209] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.209] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.209] Packages: <none>
[10:19:23.209] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:23.209] Resolved: FALSE
[10:19:23.209] Value: <not collected>
[10:19:23.209] Conditions captured: <none>
[10:19:23.209] Early signaling: FALSE
[10:19:23.209] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.209] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.222] Chunk #2 of 2 ... DONE
[10:19:23.222] Launching 2 futures (chunks) ... DONE
[10:19:23.222] Resolving 2 futures (chunks) ...
[10:19:23.222] resolve() on list ...
[10:19:23.223]  recursive: 0
[10:19:23.223]  length: 2
[10:19:23.224] plan(): nbrOfWorkers() = 2
[10:19:23.223] 
[10:19:23.228] Future #1
[10:19:23.228] result() for MulticoreFuture ...
[10:19:23.229] result() for MulticoreFuture ...
[10:19:23.229] result() for MulticoreFuture ... done
[10:19:23.230] result() for MulticoreFuture ... done
[10:19:23.230] result() for MulticoreFuture ...
[10:19:23.230] result() for MulticoreFuture ... done
[10:19:23.230] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:23.230] - nx: 2
[10:19:23.230] - relay: TRUE
[10:19:23.231] - stdout: TRUE
[10:19:23.231] - signal: TRUE
[10:19:23.231] - resignal: FALSE
[10:19:23.231] - force: TRUE
[10:19:23.232] - relayed: [n=2] FALSE, FALSE
[10:19:23.232] - queued futures: [n=2] FALSE, FALSE
[10:19:23.232]  - until=1
[10:19:23.232]  - relaying element #1
[10:19:23.232] result() for MulticoreFuture ...
[10:19:23.233] result() for MulticoreFuture ... done
[10:19:23.233] result() for MulticoreFuture ...
[10:19:23.233] result() for MulticoreFuture ... done
[10:19:23.234] result() for MulticoreFuture ...
[10:19:23.234] result() for MulticoreFuture ... done
[10:19:23.234] result() for MulticoreFuture ...
[10:19:23.234] result() for MulticoreFuture ... done
[10:19:23.234] - relayed: [n=2] TRUE, FALSE
[10:19:23.235] - queued futures: [n=2] TRUE, FALSE
[10:19:23.235] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:23.235]  length: 1 (resolved future 1)
[10:19:23.235] Future #2
[10:19:23.236] result() for MulticoreFuture ...
[10:19:23.236] result() for MulticoreFuture ...
[10:19:23.237] result() for MulticoreFuture ... done
[10:19:23.237] result() for MulticoreFuture ... done
[10:19:23.237] result() for MulticoreFuture ...
[10:19:23.237] result() for MulticoreFuture ... done
[10:19:23.237] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:23.237] - nx: 2
[10:19:23.238] - relay: TRUE
[10:19:23.238] - stdout: TRUE
[10:19:23.238] - signal: TRUE
[10:19:23.238] - resignal: FALSE
[10:19:23.238] - force: TRUE
[10:19:23.238] - relayed: [n=2] TRUE, FALSE
[10:19:23.238] - queued futures: [n=2] TRUE, FALSE
[10:19:23.239]  - until=2
[10:19:23.239]  - relaying element #2
[10:19:23.239] result() for MulticoreFuture ...
[10:19:23.239] result() for MulticoreFuture ... done
[10:19:23.239] result() for MulticoreFuture ...
[10:19:23.239] result() for MulticoreFuture ... done
[10:19:23.239] result() for MulticoreFuture ...
[10:19:23.240] result() for MulticoreFuture ... done
[10:19:23.240] result() for MulticoreFuture ...
[10:19:23.240] result() for MulticoreFuture ... done
[10:19:23.240] - relayed: [n=2] TRUE, TRUE
[10:19:23.240] - queued futures: [n=2] TRUE, TRUE
[10:19:23.240] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:23.240]  length: 0 (resolved future 2)
[10:19:23.240] Relaying remaining futures
[10:19:23.241] signalConditionsASAP(NULL, pos=0) ...
[10:19:23.241] - nx: 2
[10:19:23.241] - relay: TRUE
[10:19:23.241] - stdout: TRUE
[10:19:23.241] - signal: TRUE
[10:19:23.241] - resignal: FALSE
[10:19:23.241] - force: TRUE
[10:19:23.241] - relayed: [n=2] TRUE, TRUE
[10:19:23.242] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:23.242] - relayed: [n=2] TRUE, TRUE
[10:19:23.242] - queued futures: [n=2] TRUE, TRUE
[10:19:23.242] signalConditionsASAP(NULL, pos=0) ... done
[10:19:23.242] resolve() on list ... DONE
[10:19:23.242] result() for MulticoreFuture ...
[10:19:23.242] result() for MulticoreFuture ... done
[10:19:23.242] result() for MulticoreFuture ...
[10:19:23.242] result() for MulticoreFuture ... done
[10:19:23.243] result() for MulticoreFuture ...
[10:19:23.243] result() for MulticoreFuture ... done
[10:19:23.243] result() for MulticoreFuture ...
[10:19:23.243] result() for MulticoreFuture ... done
[10:19:23.243]  - Number of value chunks collected: 2
[10:19:23.243] Resolving 2 futures (chunks) ... DONE
[10:19:23.243] Reducing values from 2 chunks ...
[10:19:23.243]  - Number of values collected after concatenation: 4
[10:19:23.243]  - Number of values expected: 4
[10:19:23.244] Reducing values from 2 chunks ... DONE
[10:19:23.244] future_mapply() ... DONE
- Parallel RNG ...
[10:19:23.244] future_mapply() ...
[10:19:23.244] Generating random seeds ...
[10:19:23.244] Generating random seed streams for 4 elements ...
[10:19:23.244] Generating random seed streams for 4 elements ... DONE
[10:19:23.244] Generating random seeds ... DONE
[10:19:23.244] Will set RNG state on exit: 10407, 1490418050, 1501057889, 303072665, 946656183, 1207653843, -1835562351
[10:19:23.247] Number of chunks: 2
[10:19:23.247] getGlobalsAndPackagesXApply() ...
[10:19:23.247]  - future.globals: TRUE
[10:19:23.247] getGlobalsAndPackages() ...
[10:19:23.247] Searching for globals...
[10:19:23.248] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:19:23.249] Searching for globals ... DONE
[10:19:23.249] Resolving globals: FALSE
[10:19:23.249] The total size of the 1 globals is 501 bytes (501 bytes)
[10:19:23.250] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[10:19:23.250] - globals: [1] ‘FUN’
[10:19:23.250] - packages: [1] ‘stats’
[10:19:23.250] getGlobalsAndPackages() ... DONE
[10:19:23.250]  - globals found/used: [n=1] ‘FUN’
[10:19:23.250]  - needed namespaces: [n=1] ‘stats’
[10:19:23.250] Finding globals ... DONE
[10:19:23.250] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:23.251] List of 2
[10:19:23.251]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:19:23.251]  $ MoreArgs     :List of 1
[10:19:23.251]   ..$ min: num 1
[10:19:23.251]  - attr(*, "where")=List of 2
[10:19:23.251]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:23.251]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:23.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.251]  - attr(*, "resolved")= logi FALSE
[10:19:23.251]  - attr(*, "total_size")= num NA
[10:19:23.254] Packages to be attached in all futures: [n=1] ‘stats’
[10:19:23.254] getGlobalsAndPackagesXApply() ... DONE
[10:19:23.254] Number of futures (= number of chunks): 2
[10:19:23.254] Launching 2 futures (chunks) ...
[10:19:23.254] Chunk #1 of 2 ...
[10:19:23.257]  - Finding globals in '...' for chunk #1 ...
[10:19:23.257] getGlobalsAndPackages() ...
[10:19:23.257] Searching for globals...
[10:19:23.257] 
[10:19:23.257] Searching for globals ... DONE
[10:19:23.257] - globals: [0] <none>
[10:19:23.258] getGlobalsAndPackages() ... DONE
[10:19:23.258]    + additional globals found: [n=0] 
[10:19:23.258]    + additional namespaces needed: [n=0] 
[10:19:23.258]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:23.258]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.258]  - seeds: [2] <seeds>
[10:19:23.258]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.258] getGlobalsAndPackages() ...
[10:19:23.258] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.259] Resolving globals: FALSE
[10:19:23.259] The total size of the 5 globals is 870 bytes (870 bytes)
[10:19:23.259] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[10:19:23.260] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.260] - packages: [1] ‘stats’
[10:19:23.260] getGlobalsAndPackages() ... DONE
[10:19:23.260] run() for ‘Future’ ...
[10:19:23.260] - state: ‘created’
[10:19:23.261] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.262] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.262] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.263]   - Field: ‘label’
[10:19:23.263]   - Field: ‘local’
[10:19:23.263]   - Field: ‘owner’
[10:19:23.263]   - Field: ‘envir’
[10:19:23.263]   - Field: ‘workers’
[10:19:23.263]   - Field: ‘packages’
[10:19:23.263]   - Field: ‘gc’
[10:19:23.263]   - Field: ‘job’
[10:19:23.263]   - Field: ‘conditions’
[10:19:23.264]   - Field: ‘expr’
[10:19:23.264]   - Field: ‘uuid’
[10:19:23.264]   - Field: ‘seed’
[10:19:23.264]   - Field: ‘version’
[10:19:23.264]   - Field: ‘result’
[10:19:23.264]   - Field: ‘asynchronous’
[10:19:23.264]   - Field: ‘calls’
[10:19:23.264]   - Field: ‘globals’
[10:19:23.264]   - Field: ‘stdout’
[10:19:23.264]   - Field: ‘earlySignal’
[10:19:23.264]   - Field: ‘lazy’
[10:19:23.265]   - Field: ‘state’
[10:19:23.265] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.265] - Launch lazy future ...
[10:19:23.265] Packages needed by the future expression (n = 1): ‘stats’
[10:19:23.265] Packages needed by future strategies (n = 0): <none>
[10:19:23.266] {
[10:19:23.266]     {
[10:19:23.266]         {
[10:19:23.266]             ...future.startTime <- base::Sys.time()
[10:19:23.266]             {
[10:19:23.266]                 {
[10:19:23.266]                   {
[10:19:23.266]                     {
[10:19:23.266]                       {
[10:19:23.266]                         base::local({
[10:19:23.266]                           has_future <- base::requireNamespace("future", 
[10:19:23.266]                             quietly = TRUE)
[10:19:23.266]                           if (has_future) {
[10:19:23.266]                             ns <- base::getNamespace("future")
[10:19:23.266]                             version <- ns[[".package"]][["version"]]
[10:19:23.266]                             if (is.null(version)) 
[10:19:23.266]                               version <- utils::packageVersion("future")
[10:19:23.266]                           }
[10:19:23.266]                           else {
[10:19:23.266]                             version <- NULL
[10:19:23.266]                           }
[10:19:23.266]                           if (!has_future || version < "1.8.0") {
[10:19:23.266]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.266]                               "", base::R.version$version.string), 
[10:19:23.266]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:23.266]                                 base::R.version$platform, 8 * 
[10:19:23.266]                                   base::.Machine$sizeof.pointer), 
[10:19:23.266]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.266]                                 "release", "version")], collapse = " "), 
[10:19:23.266]                               hostname = base::Sys.info()[["nodename"]])
[10:19:23.266]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.266]                               info)
[10:19:23.266]                             info <- base::paste(info, collapse = "; ")
[10:19:23.266]                             if (!has_future) {
[10:19:23.266]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.266]                                 info)
[10:19:23.266]                             }
[10:19:23.266]                             else {
[10:19:23.266]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.266]                                 info, version)
[10:19:23.266]                             }
[10:19:23.266]                             base::stop(msg)
[10:19:23.266]                           }
[10:19:23.266]                         })
[10:19:23.266]                       }
[10:19:23.266]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.266]                       base::options(mc.cores = 1L)
[10:19:23.266]                     }
[10:19:23.266]                     base::local({
[10:19:23.266]                       for (pkg in "stats") {
[10:19:23.266]                         base::loadNamespace(pkg)
[10:19:23.266]                         base::library(pkg, character.only = TRUE)
[10:19:23.266]                       }
[10:19:23.266]                     })
[10:19:23.266]                   }
[10:19:23.266]                   ...future.strategy.old <- future::plan("list")
[10:19:23.266]                   options(future.plan = NULL)
[10:19:23.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.266]                 }
[10:19:23.266]                 ...future.workdir <- getwd()
[10:19:23.266]             }
[10:19:23.266]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.266]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.266]         }
[10:19:23.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.266]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.266]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.266]             base::names(...future.oldOptions))
[10:19:23.266]     }
[10:19:23.266]     if (FALSE) {
[10:19:23.266]     }
[10:19:23.266]     else {
[10:19:23.266]         if (TRUE) {
[10:19:23.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.266]                 open = "w")
[10:19:23.266]         }
[10:19:23.266]         else {
[10:19:23.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.266]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.266]         }
[10:19:23.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.266]             base::sink(type = "output", split = FALSE)
[10:19:23.266]             base::close(...future.stdout)
[10:19:23.266]         }, add = TRUE)
[10:19:23.266]     }
[10:19:23.266]     ...future.frame <- base::sys.nframe()
[10:19:23.266]     ...future.conditions <- base::list()
[10:19:23.266]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.266]     if (FALSE) {
[10:19:23.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.266]     }
[10:19:23.266]     ...future.result <- base::tryCatch({
[10:19:23.266]         base::withCallingHandlers({
[10:19:23.266]             ...future.value <- base::withVisible(base::local({
[10:19:23.266]                 withCallingHandlers({
[10:19:23.266]                   {
[10:19:23.266]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.266]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.266]                       ...future.globals.maxSize)) {
[10:19:23.266]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.266]                       on.exit(options(oopts), add = TRUE)
[10:19:23.266]                     }
[10:19:23.266]                     {
[10:19:23.266]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:23.266]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:23.266]                           envir = globalenv(), inherits = FALSE)
[10:19:23.266]                         ...future.FUN(...)
[10:19:23.266]                       }
[10:19:23.266]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:23.266]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:23.266]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.266]                         USE.NAMES = FALSE)
[10:19:23.266]                       do.call(mapply, args = args)
[10:19:23.266]                     }
[10:19:23.266]                   }
[10:19:23.266]                 }, immediateCondition = function(cond) {
[10:19:23.266]                   save_rds <- function (object, pathname, ...) 
[10:19:23.266]                   {
[10:19:23.266]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.266]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.266]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.266]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.266]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.266]                         fi_tmp[["mtime"]])
[10:19:23.266]                     }
[10:19:23.266]                     tryCatch({
[10:19:23.266]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.266]                     }, error = function(ex) {
[10:19:23.266]                       msg <- conditionMessage(ex)
[10:19:23.266]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.266]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.266]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.266]                         fi_tmp[["mtime"]], msg)
[10:19:23.266]                       ex$message <- msg
[10:19:23.266]                       stop(ex)
[10:19:23.266]                     })
[10:19:23.266]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.266]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.266]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.266]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.266]                       fi <- file.info(pathname)
[10:19:23.266]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.266]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.266]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.266]                         fi[["size"]], fi[["mtime"]])
[10:19:23.266]                       stop(msg)
[10:19:23.266]                     }
[10:19:23.266]                     invisible(pathname)
[10:19:23.266]                   }
[10:19:23.266]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.266]                     rootPath = tempdir()) 
[10:19:23.266]                   {
[10:19:23.266]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.266]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.266]                       tmpdir = path, fileext = ".rds")
[10:19:23.266]                     save_rds(obj, file)
[10:19:23.266]                   }
[10:19:23.266]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.266]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.266]                   {
[10:19:23.266]                     inherits <- base::inherits
[10:19:23.266]                     invokeRestart <- base::invokeRestart
[10:19:23.266]                     is.null <- base::is.null
[10:19:23.266]                     muffled <- FALSE
[10:19:23.266]                     if (inherits(cond, "message")) {
[10:19:23.266]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.266]                       if (muffled) 
[10:19:23.266]                         invokeRestart("muffleMessage")
[10:19:23.266]                     }
[10:19:23.266]                     else if (inherits(cond, "warning")) {
[10:19:23.266]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.266]                       if (muffled) 
[10:19:23.266]                         invokeRestart("muffleWarning")
[10:19:23.266]                     }
[10:19:23.266]                     else if (inherits(cond, "condition")) {
[10:19:23.266]                       if (!is.null(pattern)) {
[10:19:23.266]                         computeRestarts <- base::computeRestarts
[10:19:23.266]                         grepl <- base::grepl
[10:19:23.266]                         restarts <- computeRestarts(cond)
[10:19:23.266]                         for (restart in restarts) {
[10:19:23.266]                           name <- restart$name
[10:19:23.266]                           if (is.null(name)) 
[10:19:23.266]                             next
[10:19:23.266]                           if (!grepl(pattern, name)) 
[10:19:23.266]                             next
[10:19:23.266]                           invokeRestart(restart)
[10:19:23.266]                           muffled <- TRUE
[10:19:23.266]                           break
[10:19:23.266]                         }
[10:19:23.266]                       }
[10:19:23.266]                     }
[10:19:23.266]                     invisible(muffled)
[10:19:23.266]                   }
[10:19:23.266]                   muffleCondition(cond)
[10:19:23.266]                 })
[10:19:23.266]             }))
[10:19:23.266]             future::FutureResult(value = ...future.value$value, 
[10:19:23.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.266]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.266]                     ...future.globalenv.names))
[10:19:23.266]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.266]         }, condition = base::local({
[10:19:23.266]             c <- base::c
[10:19:23.266]             inherits <- base::inherits
[10:19:23.266]             invokeRestart <- base::invokeRestart
[10:19:23.266]             length <- base::length
[10:19:23.266]             list <- base::list
[10:19:23.266]             seq.int <- base::seq.int
[10:19:23.266]             signalCondition <- base::signalCondition
[10:19:23.266]             sys.calls <- base::sys.calls
[10:19:23.266]             `[[` <- base::`[[`
[10:19:23.266]             `+` <- base::`+`
[10:19:23.266]             `<<-` <- base::`<<-`
[10:19:23.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.266]                   3L)]
[10:19:23.266]             }
[10:19:23.266]             function(cond) {
[10:19:23.266]                 is_error <- inherits(cond, "error")
[10:19:23.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.266]                   NULL)
[10:19:23.266]                 if (is_error) {
[10:19:23.266]                   sessionInformation <- function() {
[10:19:23.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.266]                       search = base::search(), system = base::Sys.info())
[10:19:23.266]                   }
[10:19:23.266]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.266]                     cond$call), session = sessionInformation(), 
[10:19:23.266]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.266]                   signalCondition(cond)
[10:19:23.266]                 }
[10:19:23.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.266]                 "immediateCondition"))) {
[10:19:23.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.266]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.266]                   if (TRUE && !signal) {
[10:19:23.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.266]                     {
[10:19:23.266]                       inherits <- base::inherits
[10:19:23.266]                       invokeRestart <- base::invokeRestart
[10:19:23.266]                       is.null <- base::is.null
[10:19:23.266]                       muffled <- FALSE
[10:19:23.266]                       if (inherits(cond, "message")) {
[10:19:23.266]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.266]                         if (muffled) 
[10:19:23.266]                           invokeRestart("muffleMessage")
[10:19:23.266]                       }
[10:19:23.266]                       else if (inherits(cond, "warning")) {
[10:19:23.266]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.266]                         if (muffled) 
[10:19:23.266]                           invokeRestart("muffleWarning")
[10:19:23.266]                       }
[10:19:23.266]                       else if (inherits(cond, "condition")) {
[10:19:23.266]                         if (!is.null(pattern)) {
[10:19:23.266]                           computeRestarts <- base::computeRestarts
[10:19:23.266]                           grepl <- base::grepl
[10:19:23.266]                           restarts <- computeRestarts(cond)
[10:19:23.266]                           for (restart in restarts) {
[10:19:23.266]                             name <- restart$name
[10:19:23.266]                             if (is.null(name)) 
[10:19:23.266]                               next
[10:19:23.266]                             if (!grepl(pattern, name)) 
[10:19:23.266]                               next
[10:19:23.266]                             invokeRestart(restart)
[10:19:23.266]                             muffled <- TRUE
[10:19:23.266]                             break
[10:19:23.266]                           }
[10:19:23.266]                         }
[10:19:23.266]                       }
[10:19:23.266]                       invisible(muffled)
[10:19:23.266]                     }
[10:19:23.266]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.266]                   }
[10:19:23.266]                 }
[10:19:23.266]                 else {
[10:19:23.266]                   if (TRUE) {
[10:19:23.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.266]                     {
[10:19:23.266]                       inherits <- base::inherits
[10:19:23.266]                       invokeRestart <- base::invokeRestart
[10:19:23.266]                       is.null <- base::is.null
[10:19:23.266]                       muffled <- FALSE
[10:19:23.266]                       if (inherits(cond, "message")) {
[10:19:23.266]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.266]                         if (muffled) 
[10:19:23.266]                           invokeRestart("muffleMessage")
[10:19:23.266]                       }
[10:19:23.266]                       else if (inherits(cond, "warning")) {
[10:19:23.266]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.266]                         if (muffled) 
[10:19:23.266]                           invokeRestart("muffleWarning")
[10:19:23.266]                       }
[10:19:23.266]                       else if (inherits(cond, "condition")) {
[10:19:23.266]                         if (!is.null(pattern)) {
[10:19:23.266]                           computeRestarts <- base::computeRestarts
[10:19:23.266]                           grepl <- base::grepl
[10:19:23.266]                           restarts <- computeRestarts(cond)
[10:19:23.266]                           for (restart in restarts) {
[10:19:23.266]                             name <- restart$name
[10:19:23.266]                             if (is.null(name)) 
[10:19:23.266]                               next
[10:19:23.266]                             if (!grepl(pattern, name)) 
[10:19:23.266]                               next
[10:19:23.266]                             invokeRestart(restart)
[10:19:23.266]                             muffled <- TRUE
[10:19:23.266]                             break
[10:19:23.266]                           }
[10:19:23.266]                         }
[10:19:23.266]                       }
[10:19:23.266]                       invisible(muffled)
[10:19:23.266]                     }
[10:19:23.266]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.266]                   }
[10:19:23.266]                 }
[10:19:23.266]             }
[10:19:23.266]         }))
[10:19:23.266]     }, error = function(ex) {
[10:19:23.266]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.266]                 ...future.rng), started = ...future.startTime, 
[10:19:23.266]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.266]             version = "1.8"), class = "FutureResult")
[10:19:23.266]     }, finally = {
[10:19:23.266]         if (!identical(...future.workdir, getwd())) 
[10:19:23.266]             setwd(...future.workdir)
[10:19:23.266]         {
[10:19:23.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.266]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.266]             }
[10:19:23.266]             base::options(...future.oldOptions)
[10:19:23.266]             if (.Platform$OS.type == "windows") {
[10:19:23.266]                 old_names <- names(...future.oldEnvVars)
[10:19:23.266]                 envs <- base::Sys.getenv()
[10:19:23.266]                 names <- names(envs)
[10:19:23.266]                 common <- intersect(names, old_names)
[10:19:23.266]                 added <- setdiff(names, old_names)
[10:19:23.266]                 removed <- setdiff(old_names, names)
[10:19:23.266]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.266]                   envs[common]]
[10:19:23.266]                 NAMES <- toupper(changed)
[10:19:23.266]                 args <- list()
[10:19:23.266]                 for (kk in seq_along(NAMES)) {
[10:19:23.266]                   name <- changed[[kk]]
[10:19:23.266]                   NAME <- NAMES[[kk]]
[10:19:23.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.266]                     next
[10:19:23.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.266]                 }
[10:19:23.266]                 NAMES <- toupper(added)
[10:19:23.266]                 for (kk in seq_along(NAMES)) {
[10:19:23.266]                   name <- added[[kk]]
[10:19:23.266]                   NAME <- NAMES[[kk]]
[10:19:23.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.266]                     next
[10:19:23.266]                   args[[name]] <- ""
[10:19:23.266]                 }
[10:19:23.266]                 NAMES <- toupper(removed)
[10:19:23.266]                 for (kk in seq_along(NAMES)) {
[10:19:23.266]                   name <- removed[[kk]]
[10:19:23.266]                   NAME <- NAMES[[kk]]
[10:19:23.266]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.266]                     next
[10:19:23.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.266]                 }
[10:19:23.266]                 if (length(args) > 0) 
[10:19:23.266]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.266]             }
[10:19:23.266]             else {
[10:19:23.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.266]             }
[10:19:23.266]             {
[10:19:23.266]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.266]                   0L) {
[10:19:23.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.266]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.266]                   base::options(opts)
[10:19:23.266]                 }
[10:19:23.266]                 {
[10:19:23.266]                   {
[10:19:23.266]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.266]                     NULL
[10:19:23.266]                   }
[10:19:23.266]                   options(future.plan = NULL)
[10:19:23.266]                   if (is.na(NA_character_)) 
[10:19:23.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.266]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.266]                     .init = FALSE)
[10:19:23.266]                 }
[10:19:23.266]             }
[10:19:23.266]         }
[10:19:23.266]     })
[10:19:23.266]     if (TRUE) {
[10:19:23.266]         base::sink(type = "output", split = FALSE)
[10:19:23.266]         if (TRUE) {
[10:19:23.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.266]         }
[10:19:23.266]         else {
[10:19:23.266]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.266]         }
[10:19:23.266]         base::close(...future.stdout)
[10:19:23.266]         ...future.stdout <- NULL
[10:19:23.266]     }
[10:19:23.266]     ...future.result$conditions <- ...future.conditions
[10:19:23.266]     ...future.result$finished <- base::Sys.time()
[10:19:23.266]     ...future.result
[10:19:23.266] }
[10:19:23.268] assign_globals() ...
[10:19:23.268] List of 5
[10:19:23.268]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:19:23.268]  $ MoreArgs                 :List of 1
[10:19:23.268]   ..$ min: num 1
[10:19:23.268]  $ ...future.elements_ii    :List of 2
[10:19:23.268]   ..$ n  :List of 2
[10:19:23.268]   .. ..$ : int 1
[10:19:23.268]   .. ..$ : int 2
[10:19:23.268]   ..$ max:List of 2
[10:19:23.268]   .. ..$ : int 2
[10:19:23.268]   .. ..$ : int 3
[10:19:23.268]  $ ...future.seeds_ii       :List of 2
[10:19:23.268]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:19:23.268]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:19:23.268]  $ ...future.globals.maxSize: NULL
[10:19:23.268]  - attr(*, "where")=List of 5
[10:19:23.268]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.268]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.268]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.268]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.268]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.268]  - attr(*, "resolved")= logi FALSE
[10:19:23.268]  - attr(*, "total_size")= num 870
[10:19:23.268]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.268]  - attr(*, "already-done")= logi TRUE
[10:19:23.275] - copied ‘...future.FUN’ to environment
[10:19:23.275] - copied ‘MoreArgs’ to environment
[10:19:23.275] - copied ‘...future.elements_ii’ to environment
[10:19:23.275] - copied ‘...future.seeds_ii’ to environment
[10:19:23.275] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.275] assign_globals() ... done
[10:19:23.276] requestCore(): workers = 2
[10:19:23.278] MulticoreFuture started
[10:19:23.278] - Launch lazy future ... done
[10:19:23.278] run() for ‘MulticoreFuture’ ... done
[10:19:23.279] Created future:
[10:19:23.280] plan(): Setting new future strategy stack:
[10:19:23.280] List of future strategies:
[10:19:23.280] 1. sequential:
[10:19:23.280]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.280]    - tweaked: FALSE
[10:19:23.280]    - call: NULL
[10:19:23.281] plan(): nbrOfWorkers() = 1
[10:19:23.284] plan(): Setting new future strategy stack:
[10:19:23.284] List of future strategies:
[10:19:23.284] 1. multicore:
[10:19:23.284]    - args: function (..., workers = availa[10:19:23.279] MulticoreFuture:
[10:19:23.279] Label: ‘future_mapply-1’
[10:19:23.279] Expression:
[10:19:23.279] {
[10:19:2bleCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.284]    - tweaked: FALSE
[10:19:23.284]    - call: plan(s3.279]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.279]     if (!identical(...future.globtrategy)
als.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.279]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.279]         on.exit(options(oopts), add = TRUE)
[10:19:23.279]     }
[10:19:23.279]     {
[10:19:23.279]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:23.279]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:23.279]                 inherits = FALSE)
[10:19:23.279]             ...future.FUN(...)
[10:19:23.279]         }
[10:19:23.279]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:23.279]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:23.279]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.279]         do.call(mapply, args = args)
[10:19:23.279]     }
[10:19:23.279] }
[10:19:23.279] Lazy evaluation: FALSE
[10:19:23.279] Asynchronous evaluation: TRUE
[10:19:23.279] Local evaluation: TRUE
[10:19:23.279] Environment: R_GlobalEnv
[10:19:23.279] Capture standard output: TRUE
[10:19:23.279] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.279] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.279] Packages: 1 packages (‘stats’)
[10:19:23.279] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:23.279] Resolved: FALSE
[10:19:23.279] Value: <not collected>
[10:19:23.279] Conditions captured: <none>
[10:19:23.279] Early signaling: FALSE
[10:19:23.279] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.279] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.291] Chunk #1 of 2 ... DONE
[10:19:23.292] Chunk #2 of 2 ...
[10:19:23.292]  - Finding globals in '...' for chunk #2 ...
[10:19:23.292] getGlobalsAndPackages() ...
[10:19:23.292] Searching for globals...
[10:19:23.295] 
[10:19:23.296] Searching for globals ... DONE
[10:19:23.296] - globals: [0] <none>
[10:19:23.296] getGlobalsAndPackages() ... DONE
[10:19:23.296]    + additional globals found: [n=0] 
[10:19:23.296]    + additional namespaces needed: [n=0] 
[10:19:23.297]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:23.297]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.297]  - seeds: [2] <seeds>
[10:19:23.297] plan(): nbrOfWorkers() = 2
[10:19:23.298]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.298] getGlobalsAndPackages() ...
[10:19:23.298] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.298] Resolving globals: FALSE
[10:19:23.299] The total size of the 5 globals is 870 bytes (870 bytes)
[10:19:23.301] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[10:19:23.301] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.301] - packages: [1] ‘stats’
[10:19:23.302] getGlobalsAndPackages() ... DONE
[10:19:23.302] run() for ‘Future’ ...
[10:19:23.302] - state: ‘created’
[10:19:23.303] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.306] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.306]   - Field: ‘label’
[10:19:23.306]   - Field: ‘local’
[10:19:23.307]   - Field: ‘owner’
[10:19:23.307]   - Field: ‘envir’
[10:19:23.307]   - Field: ‘workers’
[10:19:23.307]   - Field: ‘packages’
[10:19:23.307]   - Field: ‘gc’
[10:19:23.308]   - Field: ‘job’
[10:19:23.308]   - Field: ‘conditions’
[10:19:23.308]   - Field: ‘expr’
[10:19:23.308]   - Field: ‘uuid’
[10:19:23.308]   - Field: ‘seed’
[10:19:23.308]   - Field: ‘version’
[10:19:23.309]   - Field: ‘result’
[10:19:23.309]   - Field: ‘asynchronous’
[10:19:23.309]   - Field: ‘calls’
[10:19:23.309]   - Field: ‘globals’
[10:19:23.309]   - Field: ‘stdout’
[10:19:23.309]   - Field: ‘earlySignal’
[10:19:23.309]   - Field: ‘lazy’
[10:19:23.310]   - Field: ‘state’
[10:19:23.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.310] - Launch lazy future ...
[10:19:23.311] Packages needed by the future expression (n = 1): ‘stats’
[10:19:23.311] Packages needed by future strategies (n = 0): <none>
[10:19:23.312] {
[10:19:23.312]     {
[10:19:23.312]         {
[10:19:23.312]             ...future.startTime <- base::Sys.time()
[10:19:23.312]             {
[10:19:23.312]                 {
[10:19:23.312]                   {
[10:19:23.312]                     {
[10:19:23.312]                       {
[10:19:23.312]                         base::local({
[10:19:23.312]                           has_future <- base::requireNamespace("future", 
[10:19:23.312]                             quietly = TRUE)
[10:19:23.312]                           if (has_future) {
[10:19:23.312]                             ns <- base::getNamespace("future")
[10:19:23.312]                             version <- ns[[".package"]][["version"]]
[10:19:23.312]                             if (is.null(version)) 
[10:19:23.312]                               version <- utils::packageVersion("future")
[10:19:23.312]                           }
[10:19:23.312]                           else {
[10:19:23.312]                             version <- NULL
[10:19:23.312]                           }
[10:19:23.312]                           if (!has_future || version < "1.8.0") {
[10:19:23.312]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.312]                               "", base::R.version$version.string), 
[10:19:23.312]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:23.312]                                 base::R.version$platform, 8 * 
[10:19:23.312]                                   base::.Machine$sizeof.pointer), 
[10:19:23.312]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.312]                                 "release", "version")], collapse = " "), 
[10:19:23.312]                               hostname = base::Sys.info()[["nodename"]])
[10:19:23.312]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.312]                               info)
[10:19:23.312]                             info <- base::paste(info, collapse = "; ")
[10:19:23.312]                             if (!has_future) {
[10:19:23.312]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.312]                                 info)
[10:19:23.312]                             }
[10:19:23.312]                             else {
[10:19:23.312]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.312]                                 info, version)
[10:19:23.312]                             }
[10:19:23.312]                             base::stop(msg)
[10:19:23.312]                           }
[10:19:23.312]                         })
[10:19:23.312]                       }
[10:19:23.312]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.312]                       base::options(mc.cores = 1L)
[10:19:23.312]                     }
[10:19:23.312]                     base::local({
[10:19:23.312]                       for (pkg in "stats") {
[10:19:23.312]                         base::loadNamespace(pkg)
[10:19:23.312]                         base::library(pkg, character.only = TRUE)
[10:19:23.312]                       }
[10:19:23.312]                     })
[10:19:23.312]                   }
[10:19:23.312]                   ...future.strategy.old <- future::plan("list")
[10:19:23.312]                   options(future.plan = NULL)
[10:19:23.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.312]                 }
[10:19:23.312]                 ...future.workdir <- getwd()
[10:19:23.312]             }
[10:19:23.312]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.312]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.312]         }
[10:19:23.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.312]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.312]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.312]             base::names(...future.oldOptions))
[10:19:23.312]     }
[10:19:23.312]     if (FALSE) {
[10:19:23.312]     }
[10:19:23.312]     else {
[10:19:23.312]         if (TRUE) {
[10:19:23.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.312]                 open = "w")
[10:19:23.312]         }
[10:19:23.312]         else {
[10:19:23.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.312]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.312]         }
[10:19:23.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.312]             base::sink(type = "output", split = FALSE)
[10:19:23.312]             base::close(...future.stdout)
[10:19:23.312]         }, add = TRUE)
[10:19:23.312]     }
[10:19:23.312]     ...future.frame <- base::sys.nframe()
[10:19:23.312]     ...future.conditions <- base::list()
[10:19:23.312]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.312]     if (FALSE) {
[10:19:23.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.312]     }
[10:19:23.312]     ...future.result <- base::tryCatch({
[10:19:23.312]         base::withCallingHandlers({
[10:19:23.312]             ...future.value <- base::withVisible(base::local({
[10:19:23.312]                 withCallingHandlers({
[10:19:23.312]                   {
[10:19:23.312]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.312]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.312]                       ...future.globals.maxSize)) {
[10:19:23.312]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.312]                       on.exit(options(oopts), add = TRUE)
[10:19:23.312]                     }
[10:19:23.312]                     {
[10:19:23.312]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:23.312]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:23.312]                           envir = globalenv(), inherits = FALSE)
[10:19:23.312]                         ...future.FUN(...)
[10:19:23.312]                       }
[10:19:23.312]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:23.312]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:23.312]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.312]                         USE.NAMES = FALSE)
[10:19:23.312]                       do.call(mapply, args = args)
[10:19:23.312]                     }
[10:19:23.312]                   }
[10:19:23.312]                 }, immediateCondition = function(cond) {
[10:19:23.312]                   save_rds <- function (object, pathname, ...) 
[10:19:23.312]                   {
[10:19:23.312]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.312]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.312]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.312]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.312]                         fi_tmp[["mtime"]])
[10:19:23.312]                     }
[10:19:23.312]                     tryCatch({
[10:19:23.312]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.312]                     }, error = function(ex) {
[10:19:23.312]                       msg <- conditionMessage(ex)
[10:19:23.312]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.312]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.312]                         fi_tmp[["mtime"]], msg)
[10:19:23.312]                       ex$message <- msg
[10:19:23.312]                       stop(ex)
[10:19:23.312]                     })
[10:19:23.312]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.312]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.312]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.312]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.312]                       fi <- file.info(pathname)
[10:19:23.312]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.312]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.312]                         fi[["size"]], fi[["mtime"]])
[10:19:23.312]                       stop(msg)
[10:19:23.312]                     }
[10:19:23.312]                     invisible(pathname)
[10:19:23.312]                   }
[10:19:23.312]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.312]                     rootPath = tempdir()) 
[10:19:23.312]                   {
[10:19:23.312]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.312]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.312]                       tmpdir = path, fileext = ".rds")
[10:19:23.312]                     save_rds(obj, file)
[10:19:23.312]                   }
[10:19:23.312]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.312]                   {
[10:19:23.312]                     inherits <- base::inherits
[10:19:23.312]                     invokeRestart <- base::invokeRestart
[10:19:23.312]                     is.null <- base::is.null
[10:19:23.312]                     muffled <- FALSE
[10:19:23.312]                     if (inherits(cond, "message")) {
[10:19:23.312]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.312]                       if (muffled) 
[10:19:23.312]                         invokeRestart("muffleMessage")
[10:19:23.312]                     }
[10:19:23.312]                     else if (inherits(cond, "warning")) {
[10:19:23.312]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.312]                       if (muffled) 
[10:19:23.312]                         invokeRestart("muffleWarning")
[10:19:23.312]                     }
[10:19:23.312]                     else if (inherits(cond, "condition")) {
[10:19:23.312]                       if (!is.null(pattern)) {
[10:19:23.312]                         computeRestarts <- base::computeRestarts
[10:19:23.312]                         grepl <- base::grepl
[10:19:23.312]                         restarts <- computeRestarts(cond)
[10:19:23.312]                         for (restart in restarts) {
[10:19:23.312]                           name <- restart$name
[10:19:23.312]                           if (is.null(name)) 
[10:19:23.312]                             next
[10:19:23.312]                           if (!grepl(pattern, name)) 
[10:19:23.312]                             next
[10:19:23.312]                           invokeRestart(restart)
[10:19:23.312]                           muffled <- TRUE
[10:19:23.312]                           break
[10:19:23.312]                         }
[10:19:23.312]                       }
[10:19:23.312]                     }
[10:19:23.312]                     invisible(muffled)
[10:19:23.312]                   }
[10:19:23.312]                   muffleCondition(cond)
[10:19:23.312]                 })
[10:19:23.312]             }))
[10:19:23.312]             future::FutureResult(value = ...future.value$value, 
[10:19:23.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.312]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.312]                     ...future.globalenv.names))
[10:19:23.312]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.312]         }, condition = base::local({
[10:19:23.312]             c <- base::c
[10:19:23.312]             inherits <- base::inherits
[10:19:23.312]             invokeRestart <- base::invokeRestart
[10:19:23.312]             length <- base::length
[10:19:23.312]             list <- base::list
[10:19:23.312]             seq.int <- base::seq.int
[10:19:23.312]             signalCondition <- base::signalCondition
[10:19:23.312]             sys.calls <- base::sys.calls
[10:19:23.312]             `[[` <- base::`[[`
[10:19:23.312]             `+` <- base::`+`
[10:19:23.312]             `<<-` <- base::`<<-`
[10:19:23.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.312]                   3L)]
[10:19:23.312]             }
[10:19:23.312]             function(cond) {
[10:19:23.312]                 is_error <- inherits(cond, "error")
[10:19:23.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.312]                   NULL)
[10:19:23.312]                 if (is_error) {
[10:19:23.312]                   sessionInformation <- function() {
[10:19:23.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.312]                       search = base::search(), system = base::Sys.info())
[10:19:23.312]                   }
[10:19:23.312]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.312]                     cond$call), session = sessionInformation(), 
[10:19:23.312]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.312]                   signalCondition(cond)
[10:19:23.312]                 }
[10:19:23.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.312]                 "immediateCondition"))) {
[10:19:23.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.312]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.312]                   if (TRUE && !signal) {
[10:19:23.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.312]                     {
[10:19:23.312]                       inherits <- base::inherits
[10:19:23.312]                       invokeRestart <- base::invokeRestart
[10:19:23.312]                       is.null <- base::is.null
[10:19:23.312]                       muffled <- FALSE
[10:19:23.312]                       if (inherits(cond, "message")) {
[10:19:23.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.312]                         if (muffled) 
[10:19:23.312]                           invokeRestart("muffleMessage")
[10:19:23.312]                       }
[10:19:23.312]                       else if (inherits(cond, "warning")) {
[10:19:23.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.312]                         if (muffled) 
[10:19:23.312]                           invokeRestart("muffleWarning")
[10:19:23.312]                       }
[10:19:23.312]                       else if (inherits(cond, "condition")) {
[10:19:23.312]                         if (!is.null(pattern)) {
[10:19:23.312]                           computeRestarts <- base::computeRestarts
[10:19:23.312]                           grepl <- base::grepl
[10:19:23.312]                           restarts <- computeRestarts(cond)
[10:19:23.312]                           for (restart in restarts) {
[10:19:23.312]                             name <- restart$name
[10:19:23.312]                             if (is.null(name)) 
[10:19:23.312]                               next
[10:19:23.312]                             if (!grepl(pattern, name)) 
[10:19:23.312]                               next
[10:19:23.312]                             invokeRestart(restart)
[10:19:23.312]                             muffled <- TRUE
[10:19:23.312]                             break
[10:19:23.312]                           }
[10:19:23.312]                         }
[10:19:23.312]                       }
[10:19:23.312]                       invisible(muffled)
[10:19:23.312]                     }
[10:19:23.312]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.312]                   }
[10:19:23.312]                 }
[10:19:23.312]                 else {
[10:19:23.312]                   if (TRUE) {
[10:19:23.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.312]                     {
[10:19:23.312]                       inherits <- base::inherits
[10:19:23.312]                       invokeRestart <- base::invokeRestart
[10:19:23.312]                       is.null <- base::is.null
[10:19:23.312]                       muffled <- FALSE
[10:19:23.312]                       if (inherits(cond, "message")) {
[10:19:23.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.312]                         if (muffled) 
[10:19:23.312]                           invokeRestart("muffleMessage")
[10:19:23.312]                       }
[10:19:23.312]                       else if (inherits(cond, "warning")) {
[10:19:23.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.312]                         if (muffled) 
[10:19:23.312]                           invokeRestart("muffleWarning")
[10:19:23.312]                       }
[10:19:23.312]                       else if (inherits(cond, "condition")) {
[10:19:23.312]                         if (!is.null(pattern)) {
[10:19:23.312]                           computeRestarts <- base::computeRestarts
[10:19:23.312]                           grepl <- base::grepl
[10:19:23.312]                           restarts <- computeRestarts(cond)
[10:19:23.312]                           for (restart in restarts) {
[10:19:23.312]                             name <- restart$name
[10:19:23.312]                             if (is.null(name)) 
[10:19:23.312]                               next
[10:19:23.312]                             if (!grepl(pattern, name)) 
[10:19:23.312]                               next
[10:19:23.312]                             invokeRestart(restart)
[10:19:23.312]                             muffled <- TRUE
[10:19:23.312]                             break
[10:19:23.312]                           }
[10:19:23.312]                         }
[10:19:23.312]                       }
[10:19:23.312]                       invisible(muffled)
[10:19:23.312]                     }
[10:19:23.312]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.312]                   }
[10:19:23.312]                 }
[10:19:23.312]             }
[10:19:23.312]         }))
[10:19:23.312]     }, error = function(ex) {
[10:19:23.312]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.312]                 ...future.rng), started = ...future.startTime, 
[10:19:23.312]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.312]             version = "1.8"), class = "FutureResult")
[10:19:23.312]     }, finally = {
[10:19:23.312]         if (!identical(...future.workdir, getwd())) 
[10:19:23.312]             setwd(...future.workdir)
[10:19:23.312]         {
[10:19:23.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.312]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.312]             }
[10:19:23.312]             base::options(...future.oldOptions)
[10:19:23.312]             if (.Platform$OS.type == "windows") {
[10:19:23.312]                 old_names <- names(...future.oldEnvVars)
[10:19:23.312]                 envs <- base::Sys.getenv()
[10:19:23.312]                 names <- names(envs)
[10:19:23.312]                 common <- intersect(names, old_names)
[10:19:23.312]                 added <- setdiff(names, old_names)
[10:19:23.312]                 removed <- setdiff(old_names, names)
[10:19:23.312]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.312]                   envs[common]]
[10:19:23.312]                 NAMES <- toupper(changed)
[10:19:23.312]                 args <- list()
[10:19:23.312]                 for (kk in seq_along(NAMES)) {
[10:19:23.312]                   name <- changed[[kk]]
[10:19:23.312]                   NAME <- NAMES[[kk]]
[10:19:23.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.312]                     next
[10:19:23.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.312]                 }
[10:19:23.312]                 NAMES <- toupper(added)
[10:19:23.312]                 for (kk in seq_along(NAMES)) {
[10:19:23.312]                   name <- added[[kk]]
[10:19:23.312]                   NAME <- NAMES[[kk]]
[10:19:23.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.312]                     next
[10:19:23.312]                   args[[name]] <- ""
[10:19:23.312]                 }
[10:19:23.312]                 NAMES <- toupper(removed)
[10:19:23.312]                 for (kk in seq_along(NAMES)) {
[10:19:23.312]                   name <- removed[[kk]]
[10:19:23.312]                   NAME <- NAMES[[kk]]
[10:19:23.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.312]                     next
[10:19:23.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.312]                 }
[10:19:23.312]                 if (length(args) > 0) 
[10:19:23.312]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.312]             }
[10:19:23.312]             else {
[10:19:23.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.312]             }
[10:19:23.312]             {
[10:19:23.312]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.312]                   0L) {
[10:19:23.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.312]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.312]                   base::options(opts)
[10:19:23.312]                 }
[10:19:23.312]                 {
[10:19:23.312]                   {
[10:19:23.312]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.312]                     NULL
[10:19:23.312]                   }
[10:19:23.312]                   options(future.plan = NULL)
[10:19:23.312]                   if (is.na(NA_character_)) 
[10:19:23.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.312]                     .init = FALSE)
[10:19:23.312]                 }
[10:19:23.312]             }
[10:19:23.312]         }
[10:19:23.312]     })
[10:19:23.312]     if (TRUE) {
[10:19:23.312]         base::sink(type = "output", split = FALSE)
[10:19:23.312]         if (TRUE) {
[10:19:23.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.312]         }
[10:19:23.312]         else {
[10:19:23.312]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.312]         }
[10:19:23.312]         base::close(...future.stdout)
[10:19:23.312]         ...future.stdout <- NULL
[10:19:23.312]     }
[10:19:23.312]     ...future.result$conditions <- ...future.conditions
[10:19:23.312]     ...future.result$finished <- base::Sys.time()
[10:19:23.312]     ...future.result
[10:19:23.312] }
[10:19:23.315] assign_globals() ...
[10:19:23.315] List of 5
[10:19:23.315]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[10:19:23.315]  $ MoreArgs                 :List of 1
[10:19:23.315]   ..$ min: num 1
[10:19:23.315]  $ ...future.elements_ii    :List of 2
[10:19:23.315]   ..$ n  :List of 2
[10:19:23.315]   .. ..$ : int 3
[10:19:23.315]   .. ..$ : int 4
[10:19:23.315]   ..$ max:List of 2
[10:19:23.315]   .. ..$ : int 4
[10:19:23.315]   .. ..$ : int 5
[10:19:23.315]  $ ...future.seeds_ii       :List of 2
[10:19:23.315]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[10:19:23.315]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[10:19:23.315]  $ ...future.globals.maxSize: NULL
[10:19:23.315]  - attr(*, "where")=List of 5
[10:19:23.315]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.315]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.315]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.315]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.315]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.315]  - attr(*, "resolved")= logi FALSE
[10:19:23.315]  - attr(*, "total_size")= num 870
[10:19:23.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.315]  - attr(*, "already-done")= logi TRUE
[10:19:23.323] - copied ‘...future.FUN’ to environment
[10:19:23.323] - copied ‘MoreArgs’ to environment
[10:19:23.323] - copied ‘...future.elements_ii’ to environment
[10:19:23.323] - copied ‘...future.seeds_ii’ to environment
[10:19:23.323] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.323] assign_globals() ... done
[10:19:23.324] requestCore(): workers = 2
[10:19:23.326] MulticoreFuture started
[10:19:23.327] - Launch lazy future ... done
[10:19:23.327] run() for ‘MulticoreFuture’ ... done
[10:19:23.327] Created future:
[10:19:23.327] plan(): Setting new future strategy stack:
[10:19:23.328] List of future strategies:
[10:19:23.328] 1. sequential:
[10:19:23.328]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.328]    - tweaked: FALSE
[10:19:23.328]    - call: NULL
[10:19:23.329] plan(): nbrOfWorkers() = 1
[10:19:23.331] plan(): Setting new future strategy stack:
[10:19:23.331] List of future strategies:
[10:19:23.331] 1. multicore:
[10:19:23.331]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.331]    - tweaked: FALSE
[10:19:23.331]    - call: plan(strategy)
[10:19:23.327] MulticoreFuture:
[10:19:23.327] Label: ‘future_mapply-2’
[10:19:23.327] Expression:
[10:19:23.327] {
[10:19:23.327]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.327]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.327]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.327]         on.exit(options(oopts), add = TRUE)
[10:19:23.327]     }
[10:19:23.327]     {
[10:19:23.327]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:23.327]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:23.327]                 inherits = FALSE)
[10:19:23.327]             ...future.FUN(...)
[10:19:23.327]         }
[10:19:23.327]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:23.327]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:23.327]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.327]         do.call(mapply, args = args)
[10:19:23.327]     }
[10:19:23.327] }
[10:19:23.327] Lazy evaluation: FALSE
[10:19:23.327] Asynchronous evaluation: TRUE
[10:19:23.327] Local evaluation: TRUE
[10:19:23.327] Environment: R_GlobalEnv
[10:19:23.327] Capture standard output: TRUE
[10:19:23.327] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.327] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.327] Packages: 1 packages (‘stats’)
[10:19:23.327] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:23.327] Resolved: FALSE
[10:19:23.327] Value: <not collected>
[10:19:23.327] Conditions captured: <none>
[10:19:23.327] Early signaling: FALSE
[10:19:23.327] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.327] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.340] Chunk #2 of 2 ... DONE
[10:19:23.340] Launching 2 futures (chunks) ... DONE
[10:19:23.340] Resolving 2 futures (chunks) ...
[10:19:23.340] resolve() on list ...
[10:19:23.340]  recursive: 0
[10:19:23.340]  length: 2
[10:19:23.340] plan(): nbrOfWorkers() = 2
[10:19:23.341] 
[10:19:23.341] Future #1
[10:19:23.341] result() for MulticoreFuture ...
[10:19:23.345] result() for MulticoreFuture ...
[10:19:23.345] result() for MulticoreFuture ... done
[10:19:23.345] result() for MulticoreFuture ... done
[10:19:23.346] result() for MulticoreFuture ...
[10:19:23.346] result() for MulticoreFuture ... done
[10:19:23.346] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:23.346] - nx: 2
[10:19:23.347] - relay: TRUE
[10:19:23.347] - stdout: TRUE
[10:19:23.347] - signal: TRUE
[10:19:23.347] - resignal: FALSE
[10:19:23.348] - force: TRUE
[10:19:23.348] - relayed: [n=2] FALSE, FALSE
[10:19:23.348] - queued futures: [n=2] FALSE, FALSE
[10:19:23.348]  - until=1
[10:19:23.349]  - relaying element #1
[10:19:23.349] result() for MulticoreFuture ...
[10:19:23.349] result() for MulticoreFuture ... done
[10:19:23.349] result() for MulticoreFuture ...
[10:19:23.350] result() for MulticoreFuture ... done
[10:19:23.350] result() for MulticoreFuture ...
[10:19:23.350] result() for MulticoreFuture ... done
[10:19:23.351] result() for MulticoreFuture ...
[10:19:23.351] result() for MulticoreFuture ... done
[10:19:23.351] - relayed: [n=2] TRUE, FALSE
[10:19:23.351] - queued futures: [n=2] TRUE, FALSE
[10:19:23.352] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:23.352]  length: 1 (resolved future 1)
[10:19:23.352] Future #2
[10:19:23.352] result() for MulticoreFuture ...
[10:19:23.353] result() for MulticoreFuture ...
[10:19:23.354] result() for MulticoreFuture ... done
[10:19:23.354] result() for MulticoreFuture ... done
[10:19:23.354] result() for MulticoreFuture ...
[10:19:23.354] result() for MulticoreFuture ... done
[10:19:23.354] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:23.354] - nx: 2
[10:19:23.355] - relay: TRUE
[10:19:23.355] - stdout: TRUE
[10:19:23.355] - signal: TRUE
[10:19:23.355] - resignal: FALSE
[10:19:23.355] - force: TRUE
[10:19:23.355] - relayed: [n=2] TRUE, FALSE
[10:19:23.356] - queued futures: [n=2] TRUE, FALSE
[10:19:23.356]  - until=2
[10:19:23.356]  - relaying element #2
[10:19:23.356] result() for MulticoreFuture ...
[10:19:23.356] result() for MulticoreFuture ... done
[10:19:23.356] result() for MulticoreFuture ...
[10:19:23.356] result() for MulticoreFuture ... done
[10:19:23.357] result() for MulticoreFuture ...
[10:19:23.357] result() for MulticoreFuture ... done
[10:19:23.357] result() for MulticoreFuture ...
[10:19:23.357] result() for MulticoreFuture ... done
[10:19:23.357] - relayed: [n=2] TRUE, TRUE
[10:19:23.357] - queued futures: [n=2] TRUE, TRUE
[10:19:23.357] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:23.358]  length: 0 (resolved future 2)
[10:19:23.358] Relaying remaining futures
[10:19:23.358] signalConditionsASAP(NULL, pos=0) ...
[10:19:23.358] - nx: 2
[10:19:23.358] - relay: TRUE
[10:19:23.358] - stdout: TRUE
[10:19:23.358] - signal: TRUE
[10:19:23.358] - resignal: FALSE
[10:19:23.359] - force: TRUE
[10:19:23.359] - relayed: [n=2] TRUE, TRUE
[10:19:23.359] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:23.359] - relayed: [n=2] TRUE, TRUE
[10:19:23.359] - queued futures: [n=2] TRUE, TRUE
[10:19:23.359] signalConditionsASAP(NULL, pos=0) ... done
[10:19:23.359] resolve() on list ... DONE
[10:19:23.360] result() for MulticoreFuture ...
[10:19:23.360] result() for MulticoreFuture ... done
[10:19:23.360] result() for MulticoreFuture ...
[10:19:23.360] result() for MulticoreFuture ... done
[10:19:23.360] result() for MulticoreFuture ...
[10:19:23.360] result() for MulticoreFuture ... done
[10:19:23.360] result() for MulticoreFuture ...
[10:19:23.360] result() for MulticoreFuture ... done
[10:19:23.360]  - Number of value chunks collected: 2
[10:19:23.361] Resolving 2 futures (chunks) ... DONE
[10:19:23.361] Reducing values from 2 chunks ...
[10:19:23.361]  - Number of values collected after concatenation: 4
[10:19:23.361]  - Number of values expected: 4
[10:19:23.361] Reducing values from 2 chunks ... DONE
[10:19:23.361] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[10:19:23.362] future_mapply() ...
[10:19:23.364] Number of chunks: 2
[10:19:23.364] getGlobalsAndPackagesXApply() ...
[10:19:23.364]  - future.globals: TRUE
[10:19:23.364] getGlobalsAndPackages() ...
[10:19:23.364] Searching for globals...
[10:19:23.366] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:19:23.366] Searching for globals ... DONE
[10:19:23.366] Resolving globals: FALSE
[10:19:23.366] The total size of the 1 globals is 337 bytes (337 bytes)
[10:19:23.367] The total size of the 1 globals exported for future expression (‘FUN()’) is 337 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (337 bytes of class ‘function’)
[10:19:23.367] - globals: [1] ‘FUN’
[10:19:23.367] - packages: [1] ‘stats’
[10:19:23.367] getGlobalsAndPackages() ... DONE
[10:19:23.367]  - globals found/used: [n=1] ‘FUN’
[10:19:23.367]  - needed namespaces: [n=1] ‘stats’
[10:19:23.367] Finding globals ... DONE
[10:19:23.368] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:23.368] List of 2
[10:19:23.368]  $ ...future.FUN:function (x, w, ...)  
[10:19:23.368]  $ MoreArgs     : NULL
[10:19:23.368]  - attr(*, "where")=List of 2
[10:19:23.368]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:23.368]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:23.368]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.368]  - attr(*, "resolved")= logi FALSE
[10:19:23.368]  - attr(*, "total_size")= num NA
[10:19:23.371] Packages to be attached in all futures: [n=1] ‘stats’
[10:19:23.371] getGlobalsAndPackagesXApply() ... DONE
[10:19:23.371] Number of futures (= number of chunks): 2
[10:19:23.371] Launching 2 futures (chunks) ...
[10:19:23.371] Chunk #1 of 2 ...
[10:19:23.371]  - Finding globals in '...' for chunk #1 ...
[10:19:23.371] getGlobalsAndPackages() ...
[10:19:23.372] Searching for globals...
[10:19:23.372] 
[10:19:23.372] Searching for globals ... DONE
[10:19:23.372] - globals: [0] <none>
[10:19:23.375] getGlobalsAndPackages() ... DONE
[10:19:23.375]    + additional globals found: [n=0] 
[10:19:23.375]    + additional namespaces needed: [n=0] 
[10:19:23.375]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:23.375]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.375]  - seeds: <none>
[10:19:23.375]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.375] getGlobalsAndPackages() ...
[10:19:23.376] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.376] Resolving globals: FALSE
[10:19:23.376] The total size of the 5 globals is 817 bytes (817 bytes)
[10:19:23.377] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 817 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (399 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:23.377] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.377] - packages: [1] ‘stats’
[10:19:23.377] getGlobalsAndPackages() ... DONE
[10:19:23.377] run() for ‘Future’ ...
[10:19:23.378] - state: ‘created’
[10:19:23.378] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.380] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.380]   - Field: ‘label’
[10:19:23.380]   - Field: ‘local’
[10:19:23.380]   - Field: ‘owner’
[10:19:23.380]   - Field: ‘envir’
[10:19:23.380]   - Field: ‘workers’
[10:19:23.380]   - Field: ‘packages’
[10:19:23.381]   - Field: ‘gc’
[10:19:23.381]   - Field: ‘job’
[10:19:23.381]   - Field: ‘conditions’
[10:19:23.381]   - Field: ‘expr’
[10:19:23.381]   - Field: ‘uuid’
[10:19:23.381]   - Field: ‘seed’
[10:19:23.381]   - Field: ‘version’
[10:19:23.381]   - Field: ‘result’
[10:19:23.381]   - Field: ‘asynchronous’
[10:19:23.381]   - Field: ‘calls’
[10:19:23.382]   - Field: ‘globals’
[10:19:23.382]   - Field: ‘stdout’
[10:19:23.382]   - Field: ‘earlySignal’
[10:19:23.382]   - Field: ‘lazy’
[10:19:23.382]   - Field: ‘state’
[10:19:23.382] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.382] - Launch lazy future ...
[10:19:23.382] Packages needed by the future expression (n = 1): ‘stats’
[10:19:23.383] Packages needed by future strategies (n = 0): <none>
[10:19:23.383] {
[10:19:23.383]     {
[10:19:23.383]         {
[10:19:23.383]             ...future.startTime <- base::Sys.time()
[10:19:23.383]             {
[10:19:23.383]                 {
[10:19:23.383]                   {
[10:19:23.383]                     {
[10:19:23.383]                       {
[10:19:23.383]                         base::local({
[10:19:23.383]                           has_future <- base::requireNamespace("future", 
[10:19:23.383]                             quietly = TRUE)
[10:19:23.383]                           if (has_future) {
[10:19:23.383]                             ns <- base::getNamespace("future")
[10:19:23.383]                             version <- ns[[".package"]][["version"]]
[10:19:23.383]                             if (is.null(version)) 
[10:19:23.383]                               version <- utils::packageVersion("future")
[10:19:23.383]                           }
[10:19:23.383]                           else {
[10:19:23.383]                             version <- NULL
[10:19:23.383]                           }
[10:19:23.383]                           if (!has_future || version < "1.8.0") {
[10:19:23.383]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.383]                               "", base::R.version$version.string), 
[10:19:23.383]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:23.383]                                 base::R.version$platform, 8 * 
[10:19:23.383]                                   base::.Machine$sizeof.pointer), 
[10:19:23.383]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.383]                                 "release", "version")], collapse = " "), 
[10:19:23.383]                               hostname = base::Sys.info()[["nodename"]])
[10:19:23.383]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.383]                               info)
[10:19:23.383]                             info <- base::paste(info, collapse = "; ")
[10:19:23.383]                             if (!has_future) {
[10:19:23.383]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.383]                                 info)
[10:19:23.383]                             }
[10:19:23.383]                             else {
[10:19:23.383]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.383]                                 info, version)
[10:19:23.383]                             }
[10:19:23.383]                             base::stop(msg)
[10:19:23.383]                           }
[10:19:23.383]                         })
[10:19:23.383]                       }
[10:19:23.383]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.383]                       base::options(mc.cores = 1L)
[10:19:23.383]                     }
[10:19:23.383]                     base::local({
[10:19:23.383]                       for (pkg in "stats") {
[10:19:23.383]                         base::loadNamespace(pkg)
[10:19:23.383]                         base::library(pkg, character.only = TRUE)
[10:19:23.383]                       }
[10:19:23.383]                     })
[10:19:23.383]                   }
[10:19:23.383]                   ...future.strategy.old <- future::plan("list")
[10:19:23.383]                   options(future.plan = NULL)
[10:19:23.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.383]                 }
[10:19:23.383]                 ...future.workdir <- getwd()
[10:19:23.383]             }
[10:19:23.383]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.383]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.383]         }
[10:19:23.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.383]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.383]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.383]             base::names(...future.oldOptions))
[10:19:23.383]     }
[10:19:23.383]     if (FALSE) {
[10:19:23.383]     }
[10:19:23.383]     else {
[10:19:23.383]         if (TRUE) {
[10:19:23.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.383]                 open = "w")
[10:19:23.383]         }
[10:19:23.383]         else {
[10:19:23.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.383]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.383]         }
[10:19:23.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.383]             base::sink(type = "output", split = FALSE)
[10:19:23.383]             base::close(...future.stdout)
[10:19:23.383]         }, add = TRUE)
[10:19:23.383]     }
[10:19:23.383]     ...future.frame <- base::sys.nframe()
[10:19:23.383]     ...future.conditions <- base::list()
[10:19:23.383]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.383]     if (FALSE) {
[10:19:23.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.383]     }
[10:19:23.383]     ...future.result <- base::tryCatch({
[10:19:23.383]         base::withCallingHandlers({
[10:19:23.383]             ...future.value <- base::withVisible(base::local({
[10:19:23.383]                 withCallingHandlers({
[10:19:23.383]                   {
[10:19:23.383]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.383]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.383]                       ...future.globals.maxSize)) {
[10:19:23.383]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.383]                       on.exit(options(oopts), add = TRUE)
[10:19:23.383]                     }
[10:19:23.383]                     {
[10:19:23.383]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.383]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.383]                         USE.NAMES = FALSE)
[10:19:23.383]                       do.call(mapply, args = args)
[10:19:23.383]                     }
[10:19:23.383]                   }
[10:19:23.383]                 }, immediateCondition = function(cond) {
[10:19:23.383]                   save_rds <- function (object, pathname, ...) 
[10:19:23.383]                   {
[10:19:23.383]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.383]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.383]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.383]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.383]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.383]                         fi_tmp[["mtime"]])
[10:19:23.383]                     }
[10:19:23.383]                     tryCatch({
[10:19:23.383]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.383]                     }, error = function(ex) {
[10:19:23.383]                       msg <- conditionMessage(ex)
[10:19:23.383]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.383]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.383]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.383]                         fi_tmp[["mtime"]], msg)
[10:19:23.383]                       ex$message <- msg
[10:19:23.383]                       stop(ex)
[10:19:23.383]                     })
[10:19:23.383]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.383]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.383]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.383]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.383]                       fi <- file.info(pathname)
[10:19:23.383]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.383]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.383]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.383]                         fi[["size"]], fi[["mtime"]])
[10:19:23.383]                       stop(msg)
[10:19:23.383]                     }
[10:19:23.383]                     invisible(pathname)
[10:19:23.383]                   }
[10:19:23.383]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.383]                     rootPath = tempdir()) 
[10:19:23.383]                   {
[10:19:23.383]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.383]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.383]                       tmpdir = path, fileext = ".rds")
[10:19:23.383]                     save_rds(obj, file)
[10:19:23.383]                   }
[10:19:23.383]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.383]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.383]                   {
[10:19:23.383]                     inherits <- base::inherits
[10:19:23.383]                     invokeRestart <- base::invokeRestart
[10:19:23.383]                     is.null <- base::is.null
[10:19:23.383]                     muffled <- FALSE
[10:19:23.383]                     if (inherits(cond, "message")) {
[10:19:23.383]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.383]                       if (muffled) 
[10:19:23.383]                         invokeRestart("muffleMessage")
[10:19:23.383]                     }
[10:19:23.383]                     else if (inherits(cond, "warning")) {
[10:19:23.383]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.383]                       if (muffled) 
[10:19:23.383]                         invokeRestart("muffleWarning")
[10:19:23.383]                     }
[10:19:23.383]                     else if (inherits(cond, "condition")) {
[10:19:23.383]                       if (!is.null(pattern)) {
[10:19:23.383]                         computeRestarts <- base::computeRestarts
[10:19:23.383]                         grepl <- base::grepl
[10:19:23.383]                         restarts <- computeRestarts(cond)
[10:19:23.383]                         for (restart in restarts) {
[10:19:23.383]                           name <- restart$name
[10:19:23.383]                           if (is.null(name)) 
[10:19:23.383]                             next
[10:19:23.383]                           if (!grepl(pattern, name)) 
[10:19:23.383]                             next
[10:19:23.383]                           invokeRestart(restart)
[10:19:23.383]                           muffled <- TRUE
[10:19:23.383]                           break
[10:19:23.383]                         }
[10:19:23.383]                       }
[10:19:23.383]                     }
[10:19:23.383]                     invisible(muffled)
[10:19:23.383]                   }
[10:19:23.383]                   muffleCondition(cond)
[10:19:23.383]                 })
[10:19:23.383]             }))
[10:19:23.383]             future::FutureResult(value = ...future.value$value, 
[10:19:23.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.383]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.383]                     ...future.globalenv.names))
[10:19:23.383]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.383]         }, condition = base::local({
[10:19:23.383]             c <- base::c
[10:19:23.383]             inherits <- base::inherits
[10:19:23.383]             invokeRestart <- base::invokeRestart
[10:19:23.383]             length <- base::length
[10:19:23.383]             list <- base::list
[10:19:23.383]             seq.int <- base::seq.int
[10:19:23.383]             signalCondition <- base::signalCondition
[10:19:23.383]             sys.calls <- base::sys.calls
[10:19:23.383]             `[[` <- base::`[[`
[10:19:23.383]             `+` <- base::`+`
[10:19:23.383]             `<<-` <- base::`<<-`
[10:19:23.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.383]                   3L)]
[10:19:23.383]             }
[10:19:23.383]             function(cond) {
[10:19:23.383]                 is_error <- inherits(cond, "error")
[10:19:23.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.383]                   NULL)
[10:19:23.383]                 if (is_error) {
[10:19:23.383]                   sessionInformation <- function() {
[10:19:23.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.383]                       search = base::search(), system = base::Sys.info())
[10:19:23.383]                   }
[10:19:23.383]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.383]                     cond$call), session = sessionInformation(), 
[10:19:23.383]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.383]                   signalCondition(cond)
[10:19:23.383]                 }
[10:19:23.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.383]                 "immediateCondition"))) {
[10:19:23.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.383]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.383]                   if (TRUE && !signal) {
[10:19:23.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.383]                     {
[10:19:23.383]                       inherits <- base::inherits
[10:19:23.383]                       invokeRestart <- base::invokeRestart
[10:19:23.383]                       is.null <- base::is.null
[10:19:23.383]                       muffled <- FALSE
[10:19:23.383]                       if (inherits(cond, "message")) {
[10:19:23.383]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.383]                         if (muffled) 
[10:19:23.383]                           invokeRestart("muffleMessage")
[10:19:23.383]                       }
[10:19:23.383]                       else if (inherits(cond, "warning")) {
[10:19:23.383]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.383]                         if (muffled) 
[10:19:23.383]                           invokeRestart("muffleWarning")
[10:19:23.383]                       }
[10:19:23.383]                       else if (inherits(cond, "condition")) {
[10:19:23.383]                         if (!is.null(pattern)) {
[10:19:23.383]                           computeRestarts <- base::computeRestarts
[10:19:23.383]                           grepl <- base::grepl
[10:19:23.383]                           restarts <- computeRestarts(cond)
[10:19:23.383]                           for (restart in restarts) {
[10:19:23.383]                             name <- restart$name
[10:19:23.383]                             if (is.null(name)) 
[10:19:23.383]                               next
[10:19:23.383]                             if (!grepl(pattern, name)) 
[10:19:23.383]                               next
[10:19:23.383]                             invokeRestart(restart)
[10:19:23.383]                             muffled <- TRUE
[10:19:23.383]                             break
[10:19:23.383]                           }
[10:19:23.383]                         }
[10:19:23.383]                       }
[10:19:23.383]                       invisible(muffled)
[10:19:23.383]                     }
[10:19:23.383]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.383]                   }
[10:19:23.383]                 }
[10:19:23.383]                 else {
[10:19:23.383]                   if (TRUE) {
[10:19:23.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.383]                     {
[10:19:23.383]                       inherits <- base::inherits
[10:19:23.383]                       invokeRestart <- base::invokeRestart
[10:19:23.383]                       is.null <- base::is.null
[10:19:23.383]                       muffled <- FALSE
[10:19:23.383]                       if (inherits(cond, "message")) {
[10:19:23.383]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.383]                         if (muffled) 
[10:19:23.383]                           invokeRestart("muffleMessage")
[10:19:23.383]                       }
[10:19:23.383]                       else if (inherits(cond, "warning")) {
[10:19:23.383]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.383]                         if (muffled) 
[10:19:23.383]                           invokeRestart("muffleWarning")
[10:19:23.383]                       }
[10:19:23.383]                       else if (inherits(cond, "condition")) {
[10:19:23.383]                         if (!is.null(pattern)) {
[10:19:23.383]                           computeRestarts <- base::computeRestarts
[10:19:23.383]                           grepl <- base::grepl
[10:19:23.383]                           restarts <- computeRestarts(cond)
[10:19:23.383]                           for (restart in restarts) {
[10:19:23.383]                             name <- restart$name
[10:19:23.383]                             if (is.null(name)) 
[10:19:23.383]                               next
[10:19:23.383]                             if (!grepl(pattern, name)) 
[10:19:23.383]                               next
[10:19:23.383]                             invokeRestart(restart)
[10:19:23.383]                             muffled <- TRUE
[10:19:23.383]                             break
[10:19:23.383]                           }
[10:19:23.383]                         }
[10:19:23.383]                       }
[10:19:23.383]                       invisible(muffled)
[10:19:23.383]                     }
[10:19:23.383]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.383]                   }
[10:19:23.383]                 }
[10:19:23.383]             }
[10:19:23.383]         }))
[10:19:23.383]     }, error = function(ex) {
[10:19:23.383]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.383]                 ...future.rng), started = ...future.startTime, 
[10:19:23.383]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.383]             version = "1.8"), class = "FutureResult")
[10:19:23.383]     }, finally = {
[10:19:23.383]         if (!identical(...future.workdir, getwd())) 
[10:19:23.383]             setwd(...future.workdir)
[10:19:23.383]         {
[10:19:23.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.383]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.383]             }
[10:19:23.383]             base::options(...future.oldOptions)
[10:19:23.383]             if (.Platform$OS.type == "windows") {
[10:19:23.383]                 old_names <- names(...future.oldEnvVars)
[10:19:23.383]                 envs <- base::Sys.getenv()
[10:19:23.383]                 names <- names(envs)
[10:19:23.383]                 common <- intersect(names, old_names)
[10:19:23.383]                 added <- setdiff(names, old_names)
[10:19:23.383]                 removed <- setdiff(old_names, names)
[10:19:23.383]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.383]                   envs[common]]
[10:19:23.383]                 NAMES <- toupper(changed)
[10:19:23.383]                 args <- list()
[10:19:23.383]                 for (kk in seq_along(NAMES)) {
[10:19:23.383]                   name <- changed[[kk]]
[10:19:23.383]                   NAME <- NAMES[[kk]]
[10:19:23.383]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.383]                     next
[10:19:23.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.383]                 }
[10:19:23.383]                 NAMES <- toupper(added)
[10:19:23.383]                 for (kk in seq_along(NAMES)) {
[10:19:23.383]                   name <- added[[kk]]
[10:19:23.383]                   NAME <- NAMES[[kk]]
[10:19:23.383]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.383]                     next
[10:19:23.383]                   args[[name]] <- ""
[10:19:23.383]                 }
[10:19:23.383]                 NAMES <- toupper(removed)
[10:19:23.383]                 for (kk in seq_along(NAMES)) {
[10:19:23.383]                   name <- removed[[kk]]
[10:19:23.383]                   NAME <- NAMES[[kk]]
[10:19:23.383]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.383]                     next
[10:19:23.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.383]                 }
[10:19:23.383]                 if (length(args) > 0) 
[10:19:23.383]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.383]             }
[10:19:23.383]             else {
[10:19:23.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.383]             }
[10:19:23.383]             {
[10:19:23.383]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.383]                   0L) {
[10:19:23.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.383]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.383]                   base::options(opts)
[10:19:23.383]                 }
[10:19:23.383]                 {
[10:19:23.383]                   {
[10:19:23.383]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.383]                     NULL
[10:19:23.383]                   }
[10:19:23.383]                   options(future.plan = NULL)
[10:19:23.383]                   if (is.na(NA_character_)) 
[10:19:23.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.383]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.383]                     .init = FALSE)
[10:19:23.383]                 }
[10:19:23.383]             }
[10:19:23.383]         }
[10:19:23.383]     })
[10:19:23.383]     if (TRUE) {
[10:19:23.383]         base::sink(type = "output", split = FALSE)
[10:19:23.383]         if (TRUE) {
[10:19:23.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.383]         }
[10:19:23.383]         else {
[10:19:23.383]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.383]         }
[10:19:23.383]         base::close(...future.stdout)
[10:19:23.383]         ...future.stdout <- NULL
[10:19:23.383]     }
[10:19:23.383]     ...future.result$conditions <- ...future.conditions
[10:19:23.383]     ...future.result$finished <- base::Sys.time()
[10:19:23.383]     ...future.result
[10:19:23.383] }
[10:19:23.386] assign_globals() ...
[10:19:23.386] List of 5
[10:19:23.386]  $ ...future.FUN            :function (x, w, ...)  
[10:19:23.386]  $ MoreArgs                 : NULL
[10:19:23.386]  $ ...future.elements_ii    :List of 2
[10:19:23.386]   ..$ :List of 2
[10:19:23.386]   .. ..$ : num [1:10] 0.17 0.668 0.749 0.301 0.685 ...
[10:19:23.386]   .. ..$ : num [1:10] 0.697 0.908 0.54 0.798 0.107 ...
[10:19:23.386]   ..$ :List of 2
[10:19:23.386]   .. ..$ : num [1:10] 4 4 7 9 6 5 8 7 9 7
[10:19:23.386]   .. ..$ : num [1:10] 6 7 9 3 6 3 5 8 5 5
[10:19:23.386]  $ ...future.seeds_ii       : NULL
[10:19:23.386]  $ ...future.globals.maxSize: NULL
[10:19:23.386]  - attr(*, "where")=List of 5
[10:19:23.386]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.386]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.386]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.386]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.386]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.386]  - attr(*, "resolved")= logi FALSE
[10:19:23.386]  - attr(*, "total_size")= num 817
[10:19:23.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.386]  - attr(*, "already-done")= logi TRUE
[10:19:23.392] - copied ‘...future.FUN’ to environment
[10:19:23.392] - copied ‘MoreArgs’ to environment
[10:19:23.392] - copied ‘...future.elements_ii’ to environment
[10:19:23.392] - copied ‘...future.seeds_ii’ to environment
[10:19:23.392] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.392] assign_globals() ... done
[10:19:23.392] requestCore(): workers = 2
[10:19:23.395] MulticoreFuture started
[10:19:23.395] - Launch lazy future ... done
[10:19:23.395] run() for ‘MulticoreFuture’ ... done
[10:19:23.396] Created future:
[10:19:23.396] plan(): Setting new future strategy stack:
[10:19:23.396] List of future strategies:
[10:19:23.396] 1. sequential:
[10:19:23.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.396]    - tweaked: FALSE
[10:19:23.396]    - call: NULL
[10:19:23.397] plan(): nbrOfWorkers() = 1
[10:19:23.399] plan(): Setting new future strategy stack:
[10:19:23.400] List of future strategies:
[10:19:23.400] 1. multicore:
[10:19:23.400]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.400]    - tweaked: FALSE
[10:19:23.400]    - call: plan(strategy)
[10:19:23.403] plan(): nbrOfWorkers() = 2
[10:19:23.396] MulticoreFuture:
[10:19:23.396] Label: ‘future_Map-1’
[10:19:23.396] Expression:
[10:19:23.396] {
[10:19:23.396]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.396]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.396]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.396]         on.exit(options(oopts), add = TRUE)
[10:19:23.396]     }
[10:19:23.396]     {
[10:19:23.396]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.396]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.396]         do.call(mapply, args = args)
[10:19:23.396]     }
[10:19:23.396] }
[10:19:23.396] Lazy evaluation: FALSE
[10:19:23.396] Asynchronous evaluation: TRUE
[10:19:23.396] Local evaluation: TRUE
[10:19:23.396] Environment: R_GlobalEnv
[10:19:23.396] Capture standard output: TRUE
[10:19:23.396] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.396] Globals: 5 objects totaling 817 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 399 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.396] Packages: 1 packages (‘stats’)
[10:19:23.396] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:23.396] Resolved: TRUE
[10:19:23.396] Value: <not collected>
[10:19:23.396] Conditions captured: <none>
[10:19:23.396] Early signaling: FALSE
[10:19:23.396] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.396] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.404] Chunk #1 of 2 ... DONE
[10:19:23.404] Chunk #2 of 2 ...
[10:19:23.404]  - Finding globals in '...' for chunk #2 ...
[10:19:23.404] getGlobalsAndPackages() ...
[10:19:23.405] Searching for globals...
[10:19:23.405] 
[10:19:23.405] Searching for globals ... DONE
[10:19:23.405] - globals: [0] <none>
[10:19:23.406] getGlobalsAndPackages() ... DONE
[10:19:23.406]    + additional globals found: [n=0] 
[10:19:23.406]    + additional namespaces needed: [n=0] 
[10:19:23.406]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:23.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.406]  - seeds: <none>
[10:19:23.406]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.406] getGlobalsAndPackages() ...
[10:19:23.407] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.407] Resolving globals: FALSE
[10:19:23.412] The total size of the 5 globals is 993 bytes (993 bytes)
[10:19:23.413] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 993 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (575 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:23.414] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.414] - packages: [1] ‘stats’
[10:19:23.414] getGlobalsAndPackages() ... DONE
[10:19:23.415] run() for ‘Future’ ...
[10:19:23.415] - state: ‘created’
[10:19:23.416] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.420] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.420]   - Field: ‘label’
[10:19:23.420]   - Field: ‘local’
[10:19:23.421]   - Field: ‘owner’
[10:19:23.421]   - Field: ‘envir’
[10:19:23.421]   - Field: ‘workers’
[10:19:23.421]   - Field: ‘packages’
[10:19:23.421]   - Field: ‘gc’
[10:19:23.422]   - Field: ‘job’
[10:19:23.422]   - Field: ‘conditions’
[10:19:23.422]   - Field: ‘expr’
[10:19:23.422]   - Field: ‘uuid’
[10:19:23.422]   - Field: ‘seed’
[10:19:23.423]   - Field: ‘version’
[10:19:23.423]   - Field: ‘result’
[10:19:23.423]   - Field: ‘asynchronous’
[10:19:23.423]   - Field: ‘calls’
[10:19:23.423]   - Field: ‘globals’
[10:19:23.423]   - Field: ‘stdout’
[10:19:23.424]   - Field: ‘earlySignal’
[10:19:23.424]   - Field: ‘lazy’
[10:19:23.424]   - Field: ‘state’
[10:19:23.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.424] - Launch lazy future ...
[10:19:23.425] Packages needed by the future expression (n = 1): ‘stats’
[10:19:23.425] Packages needed by future strategies (n = 0): <none>
[10:19:23.426] {
[10:19:23.426]     {
[10:19:23.426]         {
[10:19:23.426]             ...future.startTime <- base::Sys.time()
[10:19:23.426]             {
[10:19:23.426]                 {
[10:19:23.426]                   {
[10:19:23.426]                     {
[10:19:23.426]                       {
[10:19:23.426]                         base::local({
[10:19:23.426]                           has_future <- base::requireNamespace("future", 
[10:19:23.426]                             quietly = TRUE)
[10:19:23.426]                           if (has_future) {
[10:19:23.426]                             ns <- base::getNamespace("future")
[10:19:23.426]                             version <- ns[[".package"]][["version"]]
[10:19:23.426]                             if (is.null(version)) 
[10:19:23.426]                               version <- utils::packageVersion("future")
[10:19:23.426]                           }
[10:19:23.426]                           else {
[10:19:23.426]                             version <- NULL
[10:19:23.426]                           }
[10:19:23.426]                           if (!has_future || version < "1.8.0") {
[10:19:23.426]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.426]                               "", base::R.version$version.string), 
[10:19:23.426]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:23.426]                                 base::R.version$platform, 8 * 
[10:19:23.426]                                   base::.Machine$sizeof.pointer), 
[10:19:23.426]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.426]                                 "release", "version")], collapse = " "), 
[10:19:23.426]                               hostname = base::Sys.info()[["nodename"]])
[10:19:23.426]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.426]                               info)
[10:19:23.426]                             info <- base::paste(info, collapse = "; ")
[10:19:23.426]                             if (!has_future) {
[10:19:23.426]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.426]                                 info)
[10:19:23.426]                             }
[10:19:23.426]                             else {
[10:19:23.426]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.426]                                 info, version)
[10:19:23.426]                             }
[10:19:23.426]                             base::stop(msg)
[10:19:23.426]                           }
[10:19:23.426]                         })
[10:19:23.426]                       }
[10:19:23.426]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.426]                       base::options(mc.cores = 1L)
[10:19:23.426]                     }
[10:19:23.426]                     base::local({
[10:19:23.426]                       for (pkg in "stats") {
[10:19:23.426]                         base::loadNamespace(pkg)
[10:19:23.426]                         base::library(pkg, character.only = TRUE)
[10:19:23.426]                       }
[10:19:23.426]                     })
[10:19:23.426]                   }
[10:19:23.426]                   ...future.strategy.old <- future::plan("list")
[10:19:23.426]                   options(future.plan = NULL)
[10:19:23.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.426]                 }
[10:19:23.426]                 ...future.workdir <- getwd()
[10:19:23.426]             }
[10:19:23.426]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.426]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.426]         }
[10:19:23.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.426]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.426]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.426]             base::names(...future.oldOptions))
[10:19:23.426]     }
[10:19:23.426]     if (FALSE) {
[10:19:23.426]     }
[10:19:23.426]     else {
[10:19:23.426]         if (TRUE) {
[10:19:23.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.426]                 open = "w")
[10:19:23.426]         }
[10:19:23.426]         else {
[10:19:23.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.426]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.426]         }
[10:19:23.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.426]             base::sink(type = "output", split = FALSE)
[10:19:23.426]             base::close(...future.stdout)
[10:19:23.426]         }, add = TRUE)
[10:19:23.426]     }
[10:19:23.426]     ...future.frame <- base::sys.nframe()
[10:19:23.426]     ...future.conditions <- base::list()
[10:19:23.426]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.426]     if (FALSE) {
[10:19:23.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.426]     }
[10:19:23.426]     ...future.result <- base::tryCatch({
[10:19:23.426]         base::withCallingHandlers({
[10:19:23.426]             ...future.value <- base::withVisible(base::local({
[10:19:23.426]                 withCallingHandlers({
[10:19:23.426]                   {
[10:19:23.426]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.426]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.426]                       ...future.globals.maxSize)) {
[10:19:23.426]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.426]                       on.exit(options(oopts), add = TRUE)
[10:19:23.426]                     }
[10:19:23.426]                     {
[10:19:23.426]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.426]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.426]                         USE.NAMES = FALSE)
[10:19:23.426]                       do.call(mapply, args = args)
[10:19:23.426]                     }
[10:19:23.426]                   }
[10:19:23.426]                 }, immediateCondition = function(cond) {
[10:19:23.426]                   save_rds <- function (object, pathname, ...) 
[10:19:23.426]                   {
[10:19:23.426]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.426]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.426]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.426]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.426]                         fi_tmp[["mtime"]])
[10:19:23.426]                     }
[10:19:23.426]                     tryCatch({
[10:19:23.426]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.426]                     }, error = function(ex) {
[10:19:23.426]                       msg <- conditionMessage(ex)
[10:19:23.426]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.426]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.426]                         fi_tmp[["mtime"]], msg)
[10:19:23.426]                       ex$message <- msg
[10:19:23.426]                       stop(ex)
[10:19:23.426]                     })
[10:19:23.426]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.426]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.426]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.426]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.426]                       fi <- file.info(pathname)
[10:19:23.426]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.426]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.426]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.426]                         fi[["size"]], fi[["mtime"]])
[10:19:23.426]                       stop(msg)
[10:19:23.426]                     }
[10:19:23.426]                     invisible(pathname)
[10:19:23.426]                   }
[10:19:23.426]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.426]                     rootPath = tempdir()) 
[10:19:23.426]                   {
[10:19:23.426]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.426]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.426]                       tmpdir = path, fileext = ".rds")
[10:19:23.426]                     save_rds(obj, file)
[10:19:23.426]                   }
[10:19:23.426]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.426]                   {
[10:19:23.426]                     inherits <- base::inherits
[10:19:23.426]                     invokeRestart <- base::invokeRestart
[10:19:23.426]                     is.null <- base::is.null
[10:19:23.426]                     muffled <- FALSE
[10:19:23.426]                     if (inherits(cond, "message")) {
[10:19:23.426]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.426]                       if (muffled) 
[10:19:23.426]                         invokeRestart("muffleMessage")
[10:19:23.426]                     }
[10:19:23.426]                     else if (inherits(cond, "warning")) {
[10:19:23.426]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.426]                       if (muffled) 
[10:19:23.426]                         invokeRestart("muffleWarning")
[10:19:23.426]                     }
[10:19:23.426]                     else if (inherits(cond, "condition")) {
[10:19:23.426]                       if (!is.null(pattern)) {
[10:19:23.426]                         computeRestarts <- base::computeRestarts
[10:19:23.426]                         grepl <- base::grepl
[10:19:23.426]                         restarts <- computeRestarts(cond)
[10:19:23.426]                         for (restart in restarts) {
[10:19:23.426]                           name <- restart$name
[10:19:23.426]                           if (is.null(name)) 
[10:19:23.426]                             next
[10:19:23.426]                           if (!grepl(pattern, name)) 
[10:19:23.426]                             next
[10:19:23.426]                           invokeRestart(restart)
[10:19:23.426]                           muffled <- TRUE
[10:19:23.426]                           break
[10:19:23.426]                         }
[10:19:23.426]                       }
[10:19:23.426]                     }
[10:19:23.426]                     invisible(muffled)
[10:19:23.426]                   }
[10:19:23.426]                   muffleCondition(cond)
[10:19:23.426]                 })
[10:19:23.426]             }))
[10:19:23.426]             future::FutureResult(value = ...future.value$value, 
[10:19:23.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.426]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.426]                     ...future.globalenv.names))
[10:19:23.426]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.426]         }, condition = base::local({
[10:19:23.426]             c <- base::c
[10:19:23.426]             inherits <- base::inherits
[10:19:23.426]             invokeRestart <- base::invokeRestart
[10:19:23.426]             length <- base::length
[10:19:23.426]             list <- base::list
[10:19:23.426]             seq.int <- base::seq.int
[10:19:23.426]             signalCondition <- base::signalCondition
[10:19:23.426]             sys.calls <- base::sys.calls
[10:19:23.426]             `[[` <- base::`[[`
[10:19:23.426]             `+` <- base::`+`
[10:19:23.426]             `<<-` <- base::`<<-`
[10:19:23.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.426]                   3L)]
[10:19:23.426]             }
[10:19:23.426]             function(cond) {
[10:19:23.426]                 is_error <- inherits(cond, "error")
[10:19:23.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.426]                   NULL)
[10:19:23.426]                 if (is_error) {
[10:19:23.426]                   sessionInformation <- function() {
[10:19:23.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.426]                       search = base::search(), system = base::Sys.info())
[10:19:23.426]                   }
[10:19:23.426]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.426]                     cond$call), session = sessionInformation(), 
[10:19:23.426]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.426]                   signalCondition(cond)
[10:19:23.426]                 }
[10:19:23.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.426]                 "immediateCondition"))) {
[10:19:23.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.426]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.426]                   if (TRUE && !signal) {
[10:19:23.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.426]                     {
[10:19:23.426]                       inherits <- base::inherits
[10:19:23.426]                       invokeRestart <- base::invokeRestart
[10:19:23.426]                       is.null <- base::is.null
[10:19:23.426]                       muffled <- FALSE
[10:19:23.426]                       if (inherits(cond, "message")) {
[10:19:23.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.426]                         if (muffled) 
[10:19:23.426]                           invokeRestart("muffleMessage")
[10:19:23.426]                       }
[10:19:23.426]                       else if (inherits(cond, "warning")) {
[10:19:23.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.426]                         if (muffled) 
[10:19:23.426]                           invokeRestart("muffleWarning")
[10:19:23.426]                       }
[10:19:23.426]                       else if (inherits(cond, "condition")) {
[10:19:23.426]                         if (!is.null(pattern)) {
[10:19:23.426]                           computeRestarts <- base::computeRestarts
[10:19:23.426]                           grepl <- base::grepl
[10:19:23.426]                           restarts <- computeRestarts(cond)
[10:19:23.426]                           for (restart in restarts) {
[10:19:23.426]                             name <- restart$name
[10:19:23.426]                             if (is.null(name)) 
[10:19:23.426]                               next
[10:19:23.426]                             if (!grepl(pattern, name)) 
[10:19:23.426]                               next
[10:19:23.426]                             invokeRestart(restart)
[10:19:23.426]                             muffled <- TRUE
[10:19:23.426]                             break
[10:19:23.426]                           }
[10:19:23.426]                         }
[10:19:23.426]                       }
[10:19:23.426]                       invisible(muffled)
[10:19:23.426]                     }
[10:19:23.426]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.426]                   }
[10:19:23.426]                 }
[10:19:23.426]                 else {
[10:19:23.426]                   if (TRUE) {
[10:19:23.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.426]                     {
[10:19:23.426]                       inherits <- base::inherits
[10:19:23.426]                       invokeRestart <- base::invokeRestart
[10:19:23.426]                       is.null <- base::is.null
[10:19:23.426]                       muffled <- FALSE
[10:19:23.426]                       if (inherits(cond, "message")) {
[10:19:23.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.426]                         if (muffled) 
[10:19:23.426]                           invokeRestart("muffleMessage")
[10:19:23.426]                       }
[10:19:23.426]                       else if (inherits(cond, "warning")) {
[10:19:23.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.426]                         if (muffled) 
[10:19:23.426]                           invokeRestart("muffleWarning")
[10:19:23.426]                       }
[10:19:23.426]                       else if (inherits(cond, "condition")) {
[10:19:23.426]                         if (!is.null(pattern)) {
[10:19:23.426]                           computeRestarts <- base::computeRestarts
[10:19:23.426]                           grepl <- base::grepl
[10:19:23.426]                           restarts <- computeRestarts(cond)
[10:19:23.426]                           for (restart in restarts) {
[10:19:23.426]                             name <- restart$name
[10:19:23.426]                             if (is.null(name)) 
[10:19:23.426]                               next
[10:19:23.426]                             if (!grepl(pattern, name)) 
[10:19:23.426]                               next
[10:19:23.426]                             invokeRestart(restart)
[10:19:23.426]                             muffled <- TRUE
[10:19:23.426]                             break
[10:19:23.426]                           }
[10:19:23.426]                         }
[10:19:23.426]                       }
[10:19:23.426]                       invisible(muffled)
[10:19:23.426]                     }
[10:19:23.426]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.426]                   }
[10:19:23.426]                 }
[10:19:23.426]             }
[10:19:23.426]         }))
[10:19:23.426]     }, error = function(ex) {
[10:19:23.426]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.426]                 ...future.rng), started = ...future.startTime, 
[10:19:23.426]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.426]             version = "1.8"), class = "FutureResult")
[10:19:23.426]     }, finally = {
[10:19:23.426]         if (!identical(...future.workdir, getwd())) 
[10:19:23.426]             setwd(...future.workdir)
[10:19:23.426]         {
[10:19:23.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.426]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.426]             }
[10:19:23.426]             base::options(...future.oldOptions)
[10:19:23.426]             if (.Platform$OS.type == "windows") {
[10:19:23.426]                 old_names <- names(...future.oldEnvVars)
[10:19:23.426]                 envs <- base::Sys.getenv()
[10:19:23.426]                 names <- names(envs)
[10:19:23.426]                 common <- intersect(names, old_names)
[10:19:23.426]                 added <- setdiff(names, old_names)
[10:19:23.426]                 removed <- setdiff(old_names, names)
[10:19:23.426]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.426]                   envs[common]]
[10:19:23.426]                 NAMES <- toupper(changed)
[10:19:23.426]                 args <- list()
[10:19:23.426]                 for (kk in seq_along(NAMES)) {
[10:19:23.426]                   name <- changed[[kk]]
[10:19:23.426]                   NAME <- NAMES[[kk]]
[10:19:23.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.426]                     next
[10:19:23.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.426]                 }
[10:19:23.426]                 NAMES <- toupper(added)
[10:19:23.426]                 for (kk in seq_along(NAMES)) {
[10:19:23.426]                   name <- added[[kk]]
[10:19:23.426]                   NAME <- NAMES[[kk]]
[10:19:23.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.426]                     next
[10:19:23.426]                   args[[name]] <- ""
[10:19:23.426]                 }
[10:19:23.426]                 NAMES <- toupper(removed)
[10:19:23.426]                 for (kk in seq_along(NAMES)) {
[10:19:23.426]                   name <- removed[[kk]]
[10:19:23.426]                   NAME <- NAMES[[kk]]
[10:19:23.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.426]                     next
[10:19:23.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.426]                 }
[10:19:23.426]                 if (length(args) > 0) 
[10:19:23.426]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.426]             }
[10:19:23.426]             else {
[10:19:23.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.426]             }
[10:19:23.426]             {
[10:19:23.426]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.426]                   0L) {
[10:19:23.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.426]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.426]                   base::options(opts)
[10:19:23.426]                 }
[10:19:23.426]                 {
[10:19:23.426]                   {
[10:19:23.426]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.426]                     NULL
[10:19:23.426]                   }
[10:19:23.426]                   options(future.plan = NULL)
[10:19:23.426]                   if (is.na(NA_character_)) 
[10:19:23.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.426]                     .init = FALSE)
[10:19:23.426]                 }
[10:19:23.426]             }
[10:19:23.426]         }
[10:19:23.426]     })
[10:19:23.426]     if (TRUE) {
[10:19:23.426]         base::sink(type = "output", split = FALSE)
[10:19:23.426]         if (TRUE) {
[10:19:23.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.426]         }
[10:19:23.426]         else {
[10:19:23.426]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.426]         }
[10:19:23.426]         base::close(...future.stdout)
[10:19:23.426]         ...future.stdout <- NULL
[10:19:23.426]     }
[10:19:23.426]     ...future.result$conditions <- ...future.conditions
[10:19:23.426]     ...future.result$finished <- base::Sys.time()
[10:19:23.426]     ...future.result
[10:19:23.426] }
[10:19:23.429] assign_globals() ...
[10:19:23.429] List of 5
[10:19:23.429]  $ ...future.FUN            :function (x, w, ...)  
[10:19:23.429]  $ MoreArgs                 : NULL
[10:19:23.429]  $ ...future.elements_ii    :List of 2
[10:19:23.429]   ..$ :List of 3
[10:19:23.429]   .. ..$ : num [1:10] 0.109 0.287 0.894 0.65 0.459 ...
[10:19:23.429]   .. ..$ : num [1:10] 0.714 0.415 0.795 0.289 0.801 ...
[10:19:23.429]   .. ..$ : num [1:10] 0.227 0.464 0.271 0.361 0.63 ...
[10:19:23.429]   ..$ :List of 3
[10:19:23.429]   .. ..$ : num [1:10] 6 8 6 4 10 6 5 6 5 5
[10:19:23.429]   .. ..$ : num [1:10] 11 7 4 5 3 6 1 6 7 2
[10:19:23.429]   .. ..$ : num [1:10] 7 8 6 6 13 9 5 6 7 7
[10:19:23.429]  $ ...future.seeds_ii       : NULL
[10:19:23.429]  $ ...future.globals.maxSize: NULL
[10:19:23.429]  - attr(*, "where")=List of 5
[10:19:23.429]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.429]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.429]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.429]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.429]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.429]  - attr(*, "resolved")= logi FALSE
[10:19:23.429]  - attr(*, "total_size")= num 993
[10:19:23.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.429]  - attr(*, "already-done")= logi TRUE
[10:19:23.438] - copied ‘...future.FUN’ to environment
[10:19:23.438] - copied ‘MoreArgs’ to environment
[10:19:23.438] - copied ‘...future.elements_ii’ to environment
[10:19:23.438] - copied ‘...future.seeds_ii’ to environment
[10:19:23.439] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.439] assign_globals() ... done
[10:19:23.439] requestCore(): workers = 2
[10:19:23.441] MulticoreFuture started
[10:19:23.442] - Launch lazy future ... done
[10:19:23.442] run() for ‘MulticoreFuture’ ... done
[10:19:23.442] Created future:
[10:19:23.443] plan(): Setting new future strategy stack:
[10:19:23.443] List of future strategies:
[10:19:23.443] 1. sequential:
[10:19:23.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.443]    - tweaked: FALSE
[10:19:23.443]    - call: NULL
[10:19:23.444] plan(): nbrOfWorkers() = 1
[10:19:23.446] plan(): Setting new future strategy stack:
[10:19:23.446] List of future strategies:
[10:19:23.446] 1. multicore:
[10:19:23.446]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.446]    - tweaked: FALSE
[10:19:23.446]    - call: plan(strategy)
[10:19:23.450] plan(): nbrOfWorkers() = 2
[10:19:23.442] MulticoreFuture:
[10:19:23.442] Label: ‘future_Map-2’
[10:19:23.442] Expression:
[10:19:23.442] {
[10:19:23.442]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.442]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.442]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.442]         on.exit(options(oopts), add = TRUE)
[10:19:23.442]     }
[10:19:23.442]     {
[10:19:23.442]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.442]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.442]         do.call(mapply, args = args)
[10:19:23.442]     }
[10:19:23.442] }
[10:19:23.442] Lazy evaluation: FALSE
[10:19:23.442] Asynchronous evaluation: TRUE
[10:19:23.442] Local evaluation: TRUE
[10:19:23.442] Environment: R_GlobalEnv
[10:19:23.442] Capture standard output: TRUE
[10:19:23.442] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.442] Globals: 5 objects totaling 993 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 575 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.442] Packages: 1 packages (‘stats’)
[10:19:23.442] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:23.442] Resolved: TRUE
[10:19:23.442] Value: <not collected>
[10:19:23.442] Conditions captured: <none>
[10:19:23.442] Early signaling: FALSE
[10:19:23.442] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.442] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.451] Chunk #2 of 2 ... DONE
[10:19:23.451] Launching 2 futures (chunks) ... DONE
[10:19:23.451] Resolving 2 futures (chunks) ...
[10:19:23.451] resolve() on list ...
[10:19:23.451]  recursive: 0
[10:19:23.451]  length: 2
[10:19:23.452] 
[10:19:23.452] Future #1
[10:19:23.452] result() for MulticoreFuture ...
[10:19:23.453] result() for MulticoreFuture ...
[10:19:23.453] result() for MulticoreFuture ... done
[10:19:23.453] result() for MulticoreFuture ... done
[10:19:23.453] result() for MulticoreFuture ...
[10:19:23.453] result() for MulticoreFuture ... done
[10:19:23.454] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:23.454] - nx: 2
[10:19:23.454] - relay: TRUE
[10:19:23.454] - stdout: TRUE
[10:19:23.454] - signal: TRUE
[10:19:23.454] - resignal: FALSE
[10:19:23.455] - force: TRUE
[10:19:23.455] - relayed: [n=2] FALSE, FALSE
[10:19:23.455] - queued futures: [n=2] FALSE, FALSE
[10:19:23.455]  - until=1
[10:19:23.459]  - relaying element #1
[10:19:23.460] result() for MulticoreFuture ...
[10:19:23.460] result() for MulticoreFuture ... done
[10:19:23.461] result() for MulticoreFuture ...
[10:19:23.461] result() for MulticoreFuture ... done
[10:19:23.461] result() for MulticoreFuture ...
[10:19:23.462] result() for MulticoreFuture ... done
[10:19:23.462] result() for MulticoreFuture ...
[10:19:23.462] result() for MulticoreFuture ... done
[10:19:23.462] - relayed: [n=2] TRUE, FALSE
[10:19:23.463] - queued futures: [n=2] TRUE, FALSE
[10:19:23.463] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:23.463]  length: 1 (resolved future 1)
[10:19:23.464] Future #2
[10:19:23.464] result() for MulticoreFuture ...
[10:19:23.465] result() for MulticoreFuture ...
[10:19:23.465] result() for MulticoreFuture ... done
[10:19:23.466] result() for MulticoreFuture ... done
[10:19:23.466] result() for MulticoreFuture ...
[10:19:23.466] result() for MulticoreFuture ... done
[10:19:23.466] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:23.467] - nx: 2
[10:19:23.467] - relay: TRUE
[10:19:23.467] - stdout: TRUE
[10:19:23.467] - signal: TRUE
[10:19:23.467] - resignal: FALSE
[10:19:23.467] - force: TRUE
[10:19:23.468] - relayed: [n=2] TRUE, FALSE
[10:19:23.468] - queued futures: [n=2] TRUE, FALSE
[10:19:23.468]  - until=2
[10:19:23.468]  - relaying element #2
[10:19:23.468] result() for MulticoreFuture ...
[10:19:23.468] result() for MulticoreFuture ... done
[10:19:23.468] result() for MulticoreFuture ...
[10:19:23.469] result() for MulticoreFuture ... done
[10:19:23.469] result() for MulticoreFuture ...
[10:19:23.469] result() for MulticoreFuture ... done
[10:19:23.469] result() for MulticoreFuture ...
[10:19:23.469] result() for MulticoreFuture ... done
[10:19:23.469] - relayed: [n=2] TRUE, TRUE
[10:19:23.469] - queued futures: [n=2] TRUE, TRUE
[10:19:23.470] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:23.470]  length: 0 (resolved future 2)
[10:19:23.470] Relaying remaining futures
[10:19:23.470] signalConditionsASAP(NULL, pos=0) ...
[10:19:23.470] - nx: 2
[10:19:23.470] - relay: TRUE
[10:19:23.470] - stdout: TRUE
[10:19:23.470] - signal: TRUE
[10:19:23.471] - resignal: FALSE
[10:19:23.471] - force: TRUE
[10:19:23.471] - relayed: [n=2] TRUE, TRUE
[10:19:23.471] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:23.471] - relayed: [n=2] TRUE, TRUE
[10:19:23.471] - queued futures: [n=2] TRUE, TRUE
[10:19:23.471] signalConditionsASAP(NULL, pos=0) ... done
[10:19:23.471] resolve() on list ... DONE
[10:19:23.472] result() for MulticoreFuture ...
[10:19:23.472] result() for MulticoreFuture ... done
[10:19:23.472] result() for MulticoreFuture ...
[10:19:23.472] result() for MulticoreFuture ... done
[10:19:23.472] result() for MulticoreFuture ...
[10:19:23.472] result() for MulticoreFuture ... done
[10:19:23.473] result() for MulticoreFuture ...
[10:19:23.473] result() for MulticoreFuture ... done
[10:19:23.473]  - Number of value chunks collected: 2
[10:19:23.473] Resolving 2 futures (chunks) ... DONE
[10:19:23.473] Reducing values from 2 chunks ...
[10:19:23.473]  - Number of values collected after concatenation: 5
[10:19:23.473]  - Number of values expected: 5
[10:19:23.473] Reducing values from 2 chunks ... DONE
[10:19:23.474] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[10:19:23.476] future_mapply() ...
[10:19:23.478] Number of chunks: 2
[10:19:23.478] getGlobalsAndPackagesXApply() ...
[10:19:23.478]  - future.globals: TRUE
[10:19:23.478] getGlobalsAndPackages() ...
[10:19:23.478] Searching for globals...
[10:19:23.479] - globals found: [1] ‘FUN’
[10:19:23.479] Searching for globals ... DONE
[10:19:23.479] Resolving globals: FALSE
[10:19:23.480] The total size of the 1 globals is 32 bytes (32 bytes)
[10:19:23.480] The total size of the 1 globals exported for future expression (‘FUN()’) is 32 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (32 bytes of class ‘function’)
[10:19:23.480] - globals: [1] ‘FUN’
[10:19:23.480] 
[10:19:23.480] getGlobalsAndPackages() ... DONE
[10:19:23.480]  - globals found/used: [n=1] ‘FUN’
[10:19:23.481]  - needed namespaces: [n=0] 
[10:19:23.481] Finding globals ... DONE
[10:19:23.481] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:23.481] List of 2
[10:19:23.481]  $ ...future.FUN:function (e1, e2)  
[10:19:23.481]  $ MoreArgs     : NULL
[10:19:23.481]  - attr(*, "where")=List of 2
[10:19:23.481]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:23.481]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:23.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.481]  - attr(*, "resolved")= logi FALSE
[10:19:23.481]  - attr(*, "total_size")= num NA
[10:19:23.484] Packages to be attached in all futures: [n=0] 
[10:19:23.484] getGlobalsAndPackagesXApply() ... DONE
[10:19:23.484] Number of futures (= number of chunks): 2
[10:19:23.484] Launching 2 futures (chunks) ...
[10:19:23.484] Chunk #1 of 2 ...
[10:19:23.484]  - Finding globals in '...' for chunk #1 ...
[10:19:23.484] getGlobalsAndPackages() ...
[10:19:23.485] Searching for globals...
[10:19:23.485] 
[10:19:23.485] Searching for globals ... DONE
[10:19:23.485] - globals: [0] <none>
[10:19:23.485] getGlobalsAndPackages() ... DONE
[10:19:23.485]    + additional globals found: [n=0] 
[10:19:23.485]    + additional namespaces needed: [n=0] 
[10:19:23.485]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:23.486]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.486]  - seeds: <none>
[10:19:23.486]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.486] getGlobalsAndPackages() ...
[10:19:23.489] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.489] Resolving globals: FALSE
[10:19:23.489] The total size of the 5 globals is 188 bytes (188 bytes)
[10:19:23.490] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 188 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (75 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:23.490] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.490] 
[10:19:23.490] getGlobalsAndPackages() ... DONE
[10:19:23.491] run() for ‘Future’ ...
[10:19:23.491] - state: ‘created’
[10:19:23.491] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.493] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.493] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.493]   - Field: ‘label’
[10:19:23.493]   - Field: ‘local’
[10:19:23.493]   - Field: ‘owner’
[10:19:23.493]   - Field: ‘envir’
[10:19:23.493]   - Field: ‘workers’
[10:19:23.494]   - Field: ‘packages’
[10:19:23.494]   - Field: ‘gc’
[10:19:23.494]   - Field: ‘job’
[10:19:23.494]   - Field: ‘conditions’
[10:19:23.494]   - Field: ‘expr’
[10:19:23.494]   - Field: ‘uuid’
[10:19:23.494]   - Field: ‘seed’
[10:19:23.494]   - Field: ‘version’
[10:19:23.494]   - Field: ‘result’
[10:19:23.494]   - Field: ‘asynchronous’
[10:19:23.495]   - Field: ‘calls’
[10:19:23.495]   - Field: ‘globals’
[10:19:23.495]   - Field: ‘stdout’
[10:19:23.495]   - Field: ‘earlySignal’
[10:19:23.495]   - Field: ‘lazy’
[10:19:23.495]   - Field: ‘state’
[10:19:23.495] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.495] - Launch lazy future ...
[10:19:23.496] Packages needed by the future expression (n = 0): <none>
[10:19:23.496] Packages needed by future strategies (n = 0): <none>
[10:19:23.496] {
[10:19:23.496]     {
[10:19:23.496]         {
[10:19:23.496]             ...future.startTime <- base::Sys.time()
[10:19:23.496]             {
[10:19:23.496]                 {
[10:19:23.496]                   {
[10:19:23.496]                     {
[10:19:23.496]                       base::local({
[10:19:23.496]                         has_future <- base::requireNamespace("future", 
[10:19:23.496]                           quietly = TRUE)
[10:19:23.496]                         if (has_future) {
[10:19:23.496]                           ns <- base::getNamespace("future")
[10:19:23.496]                           version <- ns[[".package"]][["version"]]
[10:19:23.496]                           if (is.null(version)) 
[10:19:23.496]                             version <- utils::packageVersion("future")
[10:19:23.496]                         }
[10:19:23.496]                         else {
[10:19:23.496]                           version <- NULL
[10:19:23.496]                         }
[10:19:23.496]                         if (!has_future || version < "1.8.0") {
[10:19:23.496]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.496]                             "", base::R.version$version.string), 
[10:19:23.496]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:23.496]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:23.496]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.496]                               "release", "version")], collapse = " "), 
[10:19:23.496]                             hostname = base::Sys.info()[["nodename"]])
[10:19:23.496]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.496]                             info)
[10:19:23.496]                           info <- base::paste(info, collapse = "; ")
[10:19:23.496]                           if (!has_future) {
[10:19:23.496]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.496]                               info)
[10:19:23.496]                           }
[10:19:23.496]                           else {
[10:19:23.496]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.496]                               info, version)
[10:19:23.496]                           }
[10:19:23.496]                           base::stop(msg)
[10:19:23.496]                         }
[10:19:23.496]                       })
[10:19:23.496]                     }
[10:19:23.496]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.496]                     base::options(mc.cores = 1L)
[10:19:23.496]                   }
[10:19:23.496]                   ...future.strategy.old <- future::plan("list")
[10:19:23.496]                   options(future.plan = NULL)
[10:19:23.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.496]                 }
[10:19:23.496]                 ...future.workdir <- getwd()
[10:19:23.496]             }
[10:19:23.496]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.496]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.496]         }
[10:19:23.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.496]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.496]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.496]             base::names(...future.oldOptions))
[10:19:23.496]     }
[10:19:23.496]     if (FALSE) {
[10:19:23.496]     }
[10:19:23.496]     else {
[10:19:23.496]         if (TRUE) {
[10:19:23.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.496]                 open = "w")
[10:19:23.496]         }
[10:19:23.496]         else {
[10:19:23.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.496]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.496]         }
[10:19:23.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.496]             base::sink(type = "output", split = FALSE)
[10:19:23.496]             base::close(...future.stdout)
[10:19:23.496]         }, add = TRUE)
[10:19:23.496]     }
[10:19:23.496]     ...future.frame <- base::sys.nframe()
[10:19:23.496]     ...future.conditions <- base::list()
[10:19:23.496]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.496]     if (FALSE) {
[10:19:23.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.496]     }
[10:19:23.496]     ...future.result <- base::tryCatch({
[10:19:23.496]         base::withCallingHandlers({
[10:19:23.496]             ...future.value <- base::withVisible(base::local({
[10:19:23.496]                 withCallingHandlers({
[10:19:23.496]                   {
[10:19:23.496]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.496]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.496]                       ...future.globals.maxSize)) {
[10:19:23.496]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.496]                       on.exit(options(oopts), add = TRUE)
[10:19:23.496]                     }
[10:19:23.496]                     {
[10:19:23.496]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.496]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.496]                         USE.NAMES = FALSE)
[10:19:23.496]                       do.call(mapply, args = args)
[10:19:23.496]                     }
[10:19:23.496]                   }
[10:19:23.496]                 }, immediateCondition = function(cond) {
[10:19:23.496]                   save_rds <- function (object, pathname, ...) 
[10:19:23.496]                   {
[10:19:23.496]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.496]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.496]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.496]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.496]                         fi_tmp[["mtime"]])
[10:19:23.496]                     }
[10:19:23.496]                     tryCatch({
[10:19:23.496]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.496]                     }, error = function(ex) {
[10:19:23.496]                       msg <- conditionMessage(ex)
[10:19:23.496]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.496]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.496]                         fi_tmp[["mtime"]], msg)
[10:19:23.496]                       ex$message <- msg
[10:19:23.496]                       stop(ex)
[10:19:23.496]                     })
[10:19:23.496]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.496]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.496]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.496]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.496]                       fi <- file.info(pathname)
[10:19:23.496]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.496]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.496]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.496]                         fi[["size"]], fi[["mtime"]])
[10:19:23.496]                       stop(msg)
[10:19:23.496]                     }
[10:19:23.496]                     invisible(pathname)
[10:19:23.496]                   }
[10:19:23.496]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.496]                     rootPath = tempdir()) 
[10:19:23.496]                   {
[10:19:23.496]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.496]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.496]                       tmpdir = path, fileext = ".rds")
[10:19:23.496]                     save_rds(obj, file)
[10:19:23.496]                   }
[10:19:23.496]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.496]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.496]                   {
[10:19:23.496]                     inherits <- base::inherits
[10:19:23.496]                     invokeRestart <- base::invokeRestart
[10:19:23.496]                     is.null <- base::is.null
[10:19:23.496]                     muffled <- FALSE
[10:19:23.496]                     if (inherits(cond, "message")) {
[10:19:23.496]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.496]                       if (muffled) 
[10:19:23.496]                         invokeRestart("muffleMessage")
[10:19:23.496]                     }
[10:19:23.496]                     else if (inherits(cond, "warning")) {
[10:19:23.496]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.496]                       if (muffled) 
[10:19:23.496]                         invokeRestart("muffleWarning")
[10:19:23.496]                     }
[10:19:23.496]                     else if (inherits(cond, "condition")) {
[10:19:23.496]                       if (!is.null(pattern)) {
[10:19:23.496]                         computeRestarts <- base::computeRestarts
[10:19:23.496]                         grepl <- base::grepl
[10:19:23.496]                         restarts <- computeRestarts(cond)
[10:19:23.496]                         for (restart in restarts) {
[10:19:23.496]                           name <- restart$name
[10:19:23.496]                           if (is.null(name)) 
[10:19:23.496]                             next
[10:19:23.496]                           if (!grepl(pattern, name)) 
[10:19:23.496]                             next
[10:19:23.496]                           invokeRestart(restart)
[10:19:23.496]                           muffled <- TRUE
[10:19:23.496]                           break
[10:19:23.496]                         }
[10:19:23.496]                       }
[10:19:23.496]                     }
[10:19:23.496]                     invisible(muffled)
[10:19:23.496]                   }
[10:19:23.496]                   muffleCondition(cond)
[10:19:23.496]                 })
[10:19:23.496]             }))
[10:19:23.496]             future::FutureResult(value = ...future.value$value, 
[10:19:23.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.496]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.496]                     ...future.globalenv.names))
[10:19:23.496]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.496]         }, condition = base::local({
[10:19:23.496]             c <- base::c
[10:19:23.496]             inherits <- base::inherits
[10:19:23.496]             invokeRestart <- base::invokeRestart
[10:19:23.496]             length <- base::length
[10:19:23.496]             list <- base::list
[10:19:23.496]             seq.int <- base::seq.int
[10:19:23.496]             signalCondition <- base::signalCondition
[10:19:23.496]             sys.calls <- base::sys.calls
[10:19:23.496]             `[[` <- base::`[[`
[10:19:23.496]             `+` <- base::`+`
[10:19:23.496]             `<<-` <- base::`<<-`
[10:19:23.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.496]                   3L)]
[10:19:23.496]             }
[10:19:23.496]             function(cond) {
[10:19:23.496]                 is_error <- inherits(cond, "error")
[10:19:23.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.496]                   NULL)
[10:19:23.496]                 if (is_error) {
[10:19:23.496]                   sessionInformation <- function() {
[10:19:23.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.496]                       search = base::search(), system = base::Sys.info())
[10:19:23.496]                   }
[10:19:23.496]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.496]                     cond$call), session = sessionInformation(), 
[10:19:23.496]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.496]                   signalCondition(cond)
[10:19:23.496]                 }
[10:19:23.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.496]                 "immediateCondition"))) {
[10:19:23.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.496]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.496]                   if (TRUE && !signal) {
[10:19:23.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.496]                     {
[10:19:23.496]                       inherits <- base::inherits
[10:19:23.496]                       invokeRestart <- base::invokeRestart
[10:19:23.496]                       is.null <- base::is.null
[10:19:23.496]                       muffled <- FALSE
[10:19:23.496]                       if (inherits(cond, "message")) {
[10:19:23.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.496]                         if (muffled) 
[10:19:23.496]                           invokeRestart("muffleMessage")
[10:19:23.496]                       }
[10:19:23.496]                       else if (inherits(cond, "warning")) {
[10:19:23.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.496]                         if (muffled) 
[10:19:23.496]                           invokeRestart("muffleWarning")
[10:19:23.496]                       }
[10:19:23.496]                       else if (inherits(cond, "condition")) {
[10:19:23.496]                         if (!is.null(pattern)) {
[10:19:23.496]                           computeRestarts <- base::computeRestarts
[10:19:23.496]                           grepl <- base::grepl
[10:19:23.496]                           restarts <- computeRestarts(cond)
[10:19:23.496]                           for (restart in restarts) {
[10:19:23.496]                             name <- restart$name
[10:19:23.496]                             if (is.null(name)) 
[10:19:23.496]                               next
[10:19:23.496]                             if (!grepl(pattern, name)) 
[10:19:23.496]                               next
[10:19:23.496]                             invokeRestart(restart)
[10:19:23.496]                             muffled <- TRUE
[10:19:23.496]                             break
[10:19:23.496]                           }
[10:19:23.496]                         }
[10:19:23.496]                       }
[10:19:23.496]                       invisible(muffled)
[10:19:23.496]                     }
[10:19:23.496]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.496]                   }
[10:19:23.496]                 }
[10:19:23.496]                 else {
[10:19:23.496]                   if (TRUE) {
[10:19:23.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.496]                     {
[10:19:23.496]                       inherits <- base::inherits
[10:19:23.496]                       invokeRestart <- base::invokeRestart
[10:19:23.496]                       is.null <- base::is.null
[10:19:23.496]                       muffled <- FALSE
[10:19:23.496]                       if (inherits(cond, "message")) {
[10:19:23.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.496]                         if (muffled) 
[10:19:23.496]                           invokeRestart("muffleMessage")
[10:19:23.496]                       }
[10:19:23.496]                       else if (inherits(cond, "warning")) {
[10:19:23.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.496]                         if (muffled) 
[10:19:23.496]                           invokeRestart("muffleWarning")
[10:19:23.496]                       }
[10:19:23.496]                       else if (inherits(cond, "condition")) {
[10:19:23.496]                         if (!is.null(pattern)) {
[10:19:23.496]                           computeRestarts <- base::computeRestarts
[10:19:23.496]                           grepl <- base::grepl
[10:19:23.496]                           restarts <- computeRestarts(cond)
[10:19:23.496]                           for (restart in restarts) {
[10:19:23.496]                             name <- restart$name
[10:19:23.496]                             if (is.null(name)) 
[10:19:23.496]                               next
[10:19:23.496]                             if (!grepl(pattern, name)) 
[10:19:23.496]                               next
[10:19:23.496]                             invokeRestart(restart)
[10:19:23.496]                             muffled <- TRUE
[10:19:23.496]                             break
[10:19:23.496]                           }
[10:19:23.496]                         }
[10:19:23.496]                       }
[10:19:23.496]                       invisible(muffled)
[10:19:23.496]                     }
[10:19:23.496]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.496]                   }
[10:19:23.496]                 }
[10:19:23.496]             }
[10:19:23.496]         }))
[10:19:23.496]     }, error = function(ex) {
[10:19:23.496]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.496]                 ...future.rng), started = ...future.startTime, 
[10:19:23.496]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.496]             version = "1.8"), class = "FutureResult")
[10:19:23.496]     }, finally = {
[10:19:23.496]         if (!identical(...future.workdir, getwd())) 
[10:19:23.496]             setwd(...future.workdir)
[10:19:23.496]         {
[10:19:23.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.496]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.496]             }
[10:19:23.496]             base::options(...future.oldOptions)
[10:19:23.496]             if (.Platform$OS.type == "windows") {
[10:19:23.496]                 old_names <- names(...future.oldEnvVars)
[10:19:23.496]                 envs <- base::Sys.getenv()
[10:19:23.496]                 names <- names(envs)
[10:19:23.496]                 common <- intersect(names, old_names)
[10:19:23.496]                 added <- setdiff(names, old_names)
[10:19:23.496]                 removed <- setdiff(old_names, names)
[10:19:23.496]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.496]                   envs[common]]
[10:19:23.496]                 NAMES <- toupper(changed)
[10:19:23.496]                 args <- list()
[10:19:23.496]                 for (kk in seq_along(NAMES)) {
[10:19:23.496]                   name <- changed[[kk]]
[10:19:23.496]                   NAME <- NAMES[[kk]]
[10:19:23.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.496]                     next
[10:19:23.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.496]                 }
[10:19:23.496]                 NAMES <- toupper(added)
[10:19:23.496]                 for (kk in seq_along(NAMES)) {
[10:19:23.496]                   name <- added[[kk]]
[10:19:23.496]                   NAME <- NAMES[[kk]]
[10:19:23.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.496]                     next
[10:19:23.496]                   args[[name]] <- ""
[10:19:23.496]                 }
[10:19:23.496]                 NAMES <- toupper(removed)
[10:19:23.496]                 for (kk in seq_along(NAMES)) {
[10:19:23.496]                   name <- removed[[kk]]
[10:19:23.496]                   NAME <- NAMES[[kk]]
[10:19:23.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.496]                     next
[10:19:23.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.496]                 }
[10:19:23.496]                 if (length(args) > 0) 
[10:19:23.496]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.496]             }
[10:19:23.496]             else {
[10:19:23.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.496]             }
[10:19:23.496]             {
[10:19:23.496]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.496]                   0L) {
[10:19:23.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.496]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.496]                   base::options(opts)
[10:19:23.496]                 }
[10:19:23.496]                 {
[10:19:23.496]                   {
[10:19:23.496]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.496]                     NULL
[10:19:23.496]                   }
[10:19:23.496]                   options(future.plan = NULL)
[10:19:23.496]                   if (is.na(NA_character_)) 
[10:19:23.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.496]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.496]                     .init = FALSE)
[10:19:23.496]                 }
[10:19:23.496]             }
[10:19:23.496]         }
[10:19:23.496]     })
[10:19:23.496]     if (TRUE) {
[10:19:23.496]         base::sink(type = "output", split = FALSE)
[10:19:23.496]         if (TRUE) {
[10:19:23.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.496]         }
[10:19:23.496]         else {
[10:19:23.496]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.496]         }
[10:19:23.496]         base::close(...future.stdout)
[10:19:23.496]         ...future.stdout <- NULL
[10:19:23.496]     }
[10:19:23.496]     ...future.result$conditions <- ...future.conditions
[10:19:23.496]     ...future.result$finished <- base::Sys.time()
[10:19:23.496]     ...future.result
[10:19:23.496] }
[10:19:23.499] assign_globals() ...
[10:19:23.499] List of 5
[10:19:23.499]  $ ...future.FUN            :function (e1, e2)  
[10:19:23.499]  $ MoreArgs                 : NULL
[10:19:23.499]  $ ...future.elements_ii    :List of 2
[10:19:23.499]   ..$ :List of 1
[10:19:23.499]   .. ..$ : num 1
[10:19:23.499]   ..$ :List of 1
[10:19:23.499]   .. ..$ : int 1
[10:19:23.499]  $ ...future.seeds_ii       : NULL
[10:19:23.499]  $ ...future.globals.maxSize: NULL
[10:19:23.499]  - attr(*, "where")=List of 5
[10:19:23.499]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.499]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.499]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.499]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.499]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.499]  - attr(*, "resolved")= logi FALSE
[10:19:23.499]  - attr(*, "total_size")= num 188
[10:19:23.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.499]  - attr(*, "already-done")= logi TRUE
[10:19:23.504] - copied ‘...future.FUN’ to environment
[10:19:23.504] - copied ‘MoreArgs’ to environment
[10:19:23.505] - copied ‘...future.elements_ii’ to environment
[10:19:23.505] - copied ‘...future.seeds_ii’ to environment
[10:19:23.505] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.505] assign_globals() ... done
[10:19:23.505] requestCore(): workers = 2
[10:19:23.507] MulticoreFuture started
[10:19:23.508] - Launch lazy future ... done
[10:19:23.508] run() for ‘MulticoreFuture’ ... done
[10:19:23.508] Created future:
[10:19:23.508] plan(): Setting new future strategy stack:
[10:19:23.509] List of future strategies:
[10:19:23.509] 1. sequential:
[10:19:23.509]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.509]    - tweaked: FALSE
[10:19:23.509]    - call: NULL
[10:19:23.510] plan(): nbrOfWorkers() = 1
[10:19:23.512] plan(): Setting new future strategy stack:
[10:19:23.512] List of future strategies:
[10:19:23.512] 1. multicore:
[10:19:23.512]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.512]    - tweaked: FALSE
[10:19:23.512]    - call: plan(strategy)
[10:19:23.515] plan(): nbrOfWorkers() = 2
[10:19:23.508] MulticoreFuture:
[10:19:23.508] Label: ‘future_Map-1’
[10:19:23.508] Expression:
[10:19:23.508] {
[10:19:23.508]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.508]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.508]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.508]         on.exit(options(oopts), add = TRUE)
[10:19:23.508]     }
[10:19:23.508]     {
[10:19:23.508]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.508]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.508]         do.call(mapply, args = args)
[10:19:23.508]     }
[10:19:23.508] }
[10:19:23.508] Lazy evaluation: FALSE
[10:19:23.508] Asynchronous evaluation: TRUE
[10:19:23.508] Local evaluation: TRUE
[10:19:23.508] Environment: R_GlobalEnv
[10:19:23.508] Capture standard output: TRUE
[10:19:23.508] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.508] Globals: 5 objects totaling 188 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 75 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.508] Packages: <none>
[10:19:23.508] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:23.508] Resolved: TRUE
[10:19:23.508] Value: <not collected>
[10:19:23.508] Conditions captured: <none>
[10:19:23.508] Early signaling: FALSE
[10:19:23.508] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.508] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.516] Chunk #1 of 2 ... DONE
[10:19:23.516] Chunk #2 of 2 ...
[10:19:23.516]  - Finding globals in '...' for chunk #2 ...
[10:19:23.517] getGlobalsAndPackages() ...
[10:19:23.517] Searching for globals...
[10:19:23.517] 
[10:19:23.518] Searching for globals ... DONE
[10:19:23.518] - globals: [0] <none>
[10:19:23.518] getGlobalsAndPackages() ... DONE
[10:19:23.518]    + additional globals found: [n=0] 
[10:19:23.518]    + additional namespaces needed: [n=0] 
[10:19:23.518]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:23.518]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.518]  - seeds: <none>
[10:19:23.519]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.519] getGlobalsAndPackages() ...
[10:19:23.519] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.519] Resolving globals: FALSE
[10:19:23.520] The total size of the 5 globals is 216 bytes (216 bytes)
[10:19:23.521] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 216 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (103 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:23.521] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.521] 
[10:19:23.521] getGlobalsAndPackages() ... DONE
[10:19:23.522] run() for ‘Future’ ...
[10:19:23.522] - state: ‘created’
[10:19:23.522] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.530] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.531]   - Field: ‘label’
[10:19:23.531]   - Field: ‘local’
[10:19:23.531]   - Field: ‘owner’
[10:19:23.531]   - Field: ‘envir’
[10:19:23.532]   - Field: ‘workers’
[10:19:23.532]   - Field: ‘packages’
[10:19:23.532]   - Field: ‘gc’
[10:19:23.532]   - Field: ‘job’
[10:19:23.533]   - Field: ‘conditions’
[10:19:23.533]   - Field: ‘expr’
[10:19:23.533]   - Field: ‘uuid’
[10:19:23.533]   - Field: ‘seed’
[10:19:23.534]   - Field: ‘version’
[10:19:23.534]   - Field: ‘result’
[10:19:23.534]   - Field: ‘asynchronous’
[10:19:23.534]   - Field: ‘calls’
[10:19:23.535]   - Field: ‘globals’
[10:19:23.535]   - Field: ‘stdout’
[10:19:23.535]   - Field: ‘earlySignal’
[10:19:23.535]   - Field: ‘lazy’
[10:19:23.535]   - Field: ‘state’
[10:19:23.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.536] - Launch lazy future ...
[10:19:23.536] Packages needed by the future expression (n = 0): <none>
[10:19:23.536] Packages needed by future strategies (n = 0): <none>
[10:19:23.537] {
[10:19:23.537]     {
[10:19:23.537]         {
[10:19:23.537]             ...future.startTime <- base::Sys.time()
[10:19:23.537]             {
[10:19:23.537]                 {
[10:19:23.537]                   {
[10:19:23.537]                     {
[10:19:23.537]                       base::local({
[10:19:23.537]                         has_future <- base::requireNamespace("future", 
[10:19:23.537]                           quietly = TRUE)
[10:19:23.537]                         if (has_future) {
[10:19:23.537]                           ns <- base::getNamespace("future")
[10:19:23.537]                           version <- ns[[".package"]][["version"]]
[10:19:23.537]                           if (is.null(version)) 
[10:19:23.537]                             version <- utils::packageVersion("future")
[10:19:23.537]                         }
[10:19:23.537]                         else {
[10:19:23.537]                           version <- NULL
[10:19:23.537]                         }
[10:19:23.537]                         if (!has_future || version < "1.8.0") {
[10:19:23.537]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.537]                             "", base::R.version$version.string), 
[10:19:23.537]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:23.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:23.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.537]                               "release", "version")], collapse = " "), 
[10:19:23.537]                             hostname = base::Sys.info()[["nodename"]])
[10:19:23.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.537]                             info)
[10:19:23.537]                           info <- base::paste(info, collapse = "; ")
[10:19:23.537]                           if (!has_future) {
[10:19:23.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.537]                               info)
[10:19:23.537]                           }
[10:19:23.537]                           else {
[10:19:23.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.537]                               info, version)
[10:19:23.537]                           }
[10:19:23.537]                           base::stop(msg)
[10:19:23.537]                         }
[10:19:23.537]                       })
[10:19:23.537]                     }
[10:19:23.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.537]                     base::options(mc.cores = 1L)
[10:19:23.537]                   }
[10:19:23.537]                   ...future.strategy.old <- future::plan("list")
[10:19:23.537]                   options(future.plan = NULL)
[10:19:23.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.537]                 }
[10:19:23.537]                 ...future.workdir <- getwd()
[10:19:23.537]             }
[10:19:23.537]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.537]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.537]         }
[10:19:23.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.537]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.537]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.537]             base::names(...future.oldOptions))
[10:19:23.537]     }
[10:19:23.537]     if (FALSE) {
[10:19:23.537]     }
[10:19:23.537]     else {
[10:19:23.537]         if (TRUE) {
[10:19:23.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.537]                 open = "w")
[10:19:23.537]         }
[10:19:23.537]         else {
[10:19:23.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.537]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.537]         }
[10:19:23.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.537]             base::sink(type = "output", split = FALSE)
[10:19:23.537]             base::close(...future.stdout)
[10:19:23.537]         }, add = TRUE)
[10:19:23.537]     }
[10:19:23.537]     ...future.frame <- base::sys.nframe()
[10:19:23.537]     ...future.conditions <- base::list()
[10:19:23.537]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.537]     if (FALSE) {
[10:19:23.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.537]     }
[10:19:23.537]     ...future.result <- base::tryCatch({
[10:19:23.537]         base::withCallingHandlers({
[10:19:23.537]             ...future.value <- base::withVisible(base::local({
[10:19:23.537]                 withCallingHandlers({
[10:19:23.537]                   {
[10:19:23.537]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.537]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.537]                       ...future.globals.maxSize)) {
[10:19:23.537]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.537]                       on.exit(options(oopts), add = TRUE)
[10:19:23.537]                     }
[10:19:23.537]                     {
[10:19:23.537]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.537]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.537]                         USE.NAMES = FALSE)
[10:19:23.537]                       do.call(mapply, args = args)
[10:19:23.537]                     }
[10:19:23.537]                   }
[10:19:23.537]                 }, immediateCondition = function(cond) {
[10:19:23.537]                   save_rds <- function (object, pathname, ...) 
[10:19:23.537]                   {
[10:19:23.537]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.537]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.537]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.537]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.537]                         fi_tmp[["mtime"]])
[10:19:23.537]                     }
[10:19:23.537]                     tryCatch({
[10:19:23.537]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.537]                     }, error = function(ex) {
[10:19:23.537]                       msg <- conditionMessage(ex)
[10:19:23.537]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.537]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.537]                         fi_tmp[["mtime"]], msg)
[10:19:23.537]                       ex$message <- msg
[10:19:23.537]                       stop(ex)
[10:19:23.537]                     })
[10:19:23.537]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.537]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.537]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.537]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.537]                       fi <- file.info(pathname)
[10:19:23.537]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.537]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.537]                         fi[["size"]], fi[["mtime"]])
[10:19:23.537]                       stop(msg)
[10:19:23.537]                     }
[10:19:23.537]                     invisible(pathname)
[10:19:23.537]                   }
[10:19:23.537]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.537]                     rootPath = tempdir()) 
[10:19:23.537]                   {
[10:19:23.537]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.537]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.537]                       tmpdir = path, fileext = ".rds")
[10:19:23.537]                     save_rds(obj, file)
[10:19:23.537]                   }
[10:19:23.537]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.537]                   {
[10:19:23.537]                     inherits <- base::inherits
[10:19:23.537]                     invokeRestart <- base::invokeRestart
[10:19:23.537]                     is.null <- base::is.null
[10:19:23.537]                     muffled <- FALSE
[10:19:23.537]                     if (inherits(cond, "message")) {
[10:19:23.537]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.537]                       if (muffled) 
[10:19:23.537]                         invokeRestart("muffleMessage")
[10:19:23.537]                     }
[10:19:23.537]                     else if (inherits(cond, "warning")) {
[10:19:23.537]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.537]                       if (muffled) 
[10:19:23.537]                         invokeRestart("muffleWarning")
[10:19:23.537]                     }
[10:19:23.537]                     else if (inherits(cond, "condition")) {
[10:19:23.537]                       if (!is.null(pattern)) {
[10:19:23.537]                         computeRestarts <- base::computeRestarts
[10:19:23.537]                         grepl <- base::grepl
[10:19:23.537]                         restarts <- computeRestarts(cond)
[10:19:23.537]                         for (restart in restarts) {
[10:19:23.537]                           name <- restart$name
[10:19:23.537]                           if (is.null(name)) 
[10:19:23.537]                             next
[10:19:23.537]                           if (!grepl(pattern, name)) 
[10:19:23.537]                             next
[10:19:23.537]                           invokeRestart(restart)
[10:19:23.537]                           muffled <- TRUE
[10:19:23.537]                           break
[10:19:23.537]                         }
[10:19:23.537]                       }
[10:19:23.537]                     }
[10:19:23.537]                     invisible(muffled)
[10:19:23.537]                   }
[10:19:23.537]                   muffleCondition(cond)
[10:19:23.537]                 })
[10:19:23.537]             }))
[10:19:23.537]             future::FutureResult(value = ...future.value$value, 
[10:19:23.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.537]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.537]                     ...future.globalenv.names))
[10:19:23.537]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.537]         }, condition = base::local({
[10:19:23.537]             c <- base::c
[10:19:23.537]             inherits <- base::inherits
[10:19:23.537]             invokeRestart <- base::invokeRestart
[10:19:23.537]             length <- base::length
[10:19:23.537]             list <- base::list
[10:19:23.537]             seq.int <- base::seq.int
[10:19:23.537]             signalCondition <- base::signalCondition
[10:19:23.537]             sys.calls <- base::sys.calls
[10:19:23.537]             `[[` <- base::`[[`
[10:19:23.537]             `+` <- base::`+`
[10:19:23.537]             `<<-` <- base::`<<-`
[10:19:23.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.537]                   3L)]
[10:19:23.537]             }
[10:19:23.537]             function(cond) {
[10:19:23.537]                 is_error <- inherits(cond, "error")
[10:19:23.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.537]                   NULL)
[10:19:23.537]                 if (is_error) {
[10:19:23.537]                   sessionInformation <- function() {
[10:19:23.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.537]                       search = base::search(), system = base::Sys.info())
[10:19:23.537]                   }
[10:19:23.537]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.537]                     cond$call), session = sessionInformation(), 
[10:19:23.537]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.537]                   signalCondition(cond)
[10:19:23.537]                 }
[10:19:23.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.537]                 "immediateCondition"))) {
[10:19:23.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.537]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.537]                   if (TRUE && !signal) {
[10:19:23.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.537]                     {
[10:19:23.537]                       inherits <- base::inherits
[10:19:23.537]                       invokeRestart <- base::invokeRestart
[10:19:23.537]                       is.null <- base::is.null
[10:19:23.537]                       muffled <- FALSE
[10:19:23.537]                       if (inherits(cond, "message")) {
[10:19:23.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.537]                         if (muffled) 
[10:19:23.537]                           invokeRestart("muffleMessage")
[10:19:23.537]                       }
[10:19:23.537]                       else if (inherits(cond, "warning")) {
[10:19:23.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.537]                         if (muffled) 
[10:19:23.537]                           invokeRestart("muffleWarning")
[10:19:23.537]                       }
[10:19:23.537]                       else if (inherits(cond, "condition")) {
[10:19:23.537]                         if (!is.null(pattern)) {
[10:19:23.537]                           computeRestarts <- base::computeRestarts
[10:19:23.537]                           grepl <- base::grepl
[10:19:23.537]                           restarts <- computeRestarts(cond)
[10:19:23.537]                           for (restart in restarts) {
[10:19:23.537]                             name <- restart$name
[10:19:23.537]                             if (is.null(name)) 
[10:19:23.537]                               next
[10:19:23.537]                             if (!grepl(pattern, name)) 
[10:19:23.537]                               next
[10:19:23.537]                             invokeRestart(restart)
[10:19:23.537]                             muffled <- TRUE
[10:19:23.537]                             break
[10:19:23.537]                           }
[10:19:23.537]                         }
[10:19:23.537]                       }
[10:19:23.537]                       invisible(muffled)
[10:19:23.537]                     }
[10:19:23.537]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.537]                   }
[10:19:23.537]                 }
[10:19:23.537]                 else {
[10:19:23.537]                   if (TRUE) {
[10:19:23.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.537]                     {
[10:19:23.537]                       inherits <- base::inherits
[10:19:23.537]                       invokeRestart <- base::invokeRestart
[10:19:23.537]                       is.null <- base::is.null
[10:19:23.537]                       muffled <- FALSE
[10:19:23.537]                       if (inherits(cond, "message")) {
[10:19:23.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.537]                         if (muffled) 
[10:19:23.537]                           invokeRestart("muffleMessage")
[10:19:23.537]                       }
[10:19:23.537]                       else if (inherits(cond, "warning")) {
[10:19:23.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.537]                         if (muffled) 
[10:19:23.537]                           invokeRestart("muffleWarning")
[10:19:23.537]                       }
[10:19:23.537]                       else if (inherits(cond, "condition")) {
[10:19:23.537]                         if (!is.null(pattern)) {
[10:19:23.537]                           computeRestarts <- base::computeRestarts
[10:19:23.537]                           grepl <- base::grepl
[10:19:23.537]                           restarts <- computeRestarts(cond)
[10:19:23.537]                           for (restart in restarts) {
[10:19:23.537]                             name <- restart$name
[10:19:23.537]                             if (is.null(name)) 
[10:19:23.537]                               next
[10:19:23.537]                             if (!grepl(pattern, name)) 
[10:19:23.537]                               next
[10:19:23.537]                             invokeRestart(restart)
[10:19:23.537]                             muffled <- TRUE
[10:19:23.537]                             break
[10:19:23.537]                           }
[10:19:23.537]                         }
[10:19:23.537]                       }
[10:19:23.537]                       invisible(muffled)
[10:19:23.537]                     }
[10:19:23.537]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.537]                   }
[10:19:23.537]                 }
[10:19:23.537]             }
[10:19:23.537]         }))
[10:19:23.537]     }, error = function(ex) {
[10:19:23.537]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.537]                 ...future.rng), started = ...future.startTime, 
[10:19:23.537]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.537]             version = "1.8"), class = "FutureResult")
[10:19:23.537]     }, finally = {
[10:19:23.537]         if (!identical(...future.workdir, getwd())) 
[10:19:23.537]             setwd(...future.workdir)
[10:19:23.537]         {
[10:19:23.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.537]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.537]             }
[10:19:23.537]             base::options(...future.oldOptions)
[10:19:23.537]             if (.Platform$OS.type == "windows") {
[10:19:23.537]                 old_names <- names(...future.oldEnvVars)
[10:19:23.537]                 envs <- base::Sys.getenv()
[10:19:23.537]                 names <- names(envs)
[10:19:23.537]                 common <- intersect(names, old_names)
[10:19:23.537]                 added <- setdiff(names, old_names)
[10:19:23.537]                 removed <- setdiff(old_names, names)
[10:19:23.537]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.537]                   envs[common]]
[10:19:23.537]                 NAMES <- toupper(changed)
[10:19:23.537]                 args <- list()
[10:19:23.537]                 for (kk in seq_along(NAMES)) {
[10:19:23.537]                   name <- changed[[kk]]
[10:19:23.537]                   NAME <- NAMES[[kk]]
[10:19:23.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.537]                     next
[10:19:23.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.537]                 }
[10:19:23.537]                 NAMES <- toupper(added)
[10:19:23.537]                 for (kk in seq_along(NAMES)) {
[10:19:23.537]                   name <- added[[kk]]
[10:19:23.537]                   NAME <- NAMES[[kk]]
[10:19:23.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.537]                     next
[10:19:23.537]                   args[[name]] <- ""
[10:19:23.537]                 }
[10:19:23.537]                 NAMES <- toupper(removed)
[10:19:23.537]                 for (kk in seq_along(NAMES)) {
[10:19:23.537]                   name <- removed[[kk]]
[10:19:23.537]                   NAME <- NAMES[[kk]]
[10:19:23.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.537]                     next
[10:19:23.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.537]                 }
[10:19:23.537]                 if (length(args) > 0) 
[10:19:23.537]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.537]             }
[10:19:23.537]             else {
[10:19:23.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.537]             }
[10:19:23.537]             {
[10:19:23.537]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.537]                   0L) {
[10:19:23.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.537]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.537]                   base::options(opts)
[10:19:23.537]                 }
[10:19:23.537]                 {
[10:19:23.537]                   {
[10:19:23.537]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.537]                     NULL
[10:19:23.537]                   }
[10:19:23.537]                   options(future.plan = NULL)
[10:19:23.537]                   if (is.na(NA_character_)) 
[10:19:23.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.537]                     .init = FALSE)
[10:19:23.537]                 }
[10:19:23.537]             }
[10:19:23.537]         }
[10:19:23.537]     })
[10:19:23.537]     if (TRUE) {
[10:19:23.537]         base::sink(type = "output", split = FALSE)
[10:19:23.537]         if (TRUE) {
[10:19:23.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.537]         }
[10:19:23.537]         else {
[10:19:23.537]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.537]         }
[10:19:23.537]         base::close(...future.stdout)
[10:19:23.537]         ...future.stdout <- NULL
[10:19:23.537]     }
[10:19:23.537]     ...future.result$conditions <- ...future.conditions
[10:19:23.537]     ...future.result$finished <- base::Sys.time()
[10:19:23.537]     ...future.result
[10:19:23.537] }
[10:19:23.540] assign_globals() ...
[10:19:23.540] List of 5
[10:19:23.540]  $ ...future.FUN            :function (e1, e2)  
[10:19:23.540]  $ MoreArgs                 : NULL
[10:19:23.540]  $ ...future.elements_ii    :List of 2
[10:19:23.540]   ..$ :List of 2
[10:19:23.540]   .. ..$ : num 1
[10:19:23.540]   .. ..$ : num 1
[10:19:23.540]   ..$ :List of 2
[10:19:23.540]   .. ..$ : int 2
[10:19:23.540]   .. ..$ : int 3
[10:19:23.540]  $ ...future.seeds_ii       : NULL
[10:19:23.540]  $ ...future.globals.maxSize: NULL
[10:19:23.540]  - attr(*, "where")=List of 5
[10:19:23.540]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.540]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.540]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.540]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.540]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.540]  - attr(*, "resolved")= logi FALSE
[10:19:23.540]  - attr(*, "total_size")= num 216
[10:19:23.540]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.540]  - attr(*, "already-done")= logi TRUE
[10:19:23.549] - copied ‘...future.FUN’ to environment
[10:19:23.549] - copied ‘MoreArgs’ to environment
[10:19:23.549] - copied ‘...future.elements_ii’ to environment
[10:19:23.549] - copied ‘...future.seeds_ii’ to environment
[10:19:23.549] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.550] assign_globals() ... done
[10:19:23.550] requestCore(): workers = 2
[10:19:23.552] MulticoreFuture started
[10:19:23.553] - Launch lazy future ... done
[10:19:23.553] run() for ‘MulticoreFuture’ ... done
[10:19:23.553] Created future:
[10:19:23.553] plan(): Setting new future strategy stack:
[10:19:23.554] List of future strategies:
[10:19:23.554] 1. sequential:
[10:19:23.554]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.554]    - tweaked: FALSE
[10:19:23.554]    - call: NULL
[10:19:23.554] plan(): nbrOfWorkers() = 1
[10:19:23.557] plan(): Setting new future strategy stack:
[10:19:23.557] List of future strategies:
[10:19:23.557] 1. multicore:
[10:19:23.557]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.557]    - tweaked: FALSE
[10:19:23.557]    - call: plan(strategy)
[10:19:23.560] plan(): nbrOfWorkers() = 2
[10:19:23.553] MulticoreFuture:
[10:19:23.553] Label: ‘future_Map-2’
[10:19:23.553] Expression:
[10:19:23.553] {
[10:19:23.553]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.553]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.553]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.553]         on.exit(options(oopts), add = TRUE)
[10:19:23.553]     }
[10:19:23.553]     {
[10:19:23.553]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.553]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.553]         do.call(mapply, args = args)
[10:19:23.553]     }
[10:19:23.553] }
[10:19:23.553] Lazy evaluation: FALSE
[10:19:23.553] Asynchronous evaluation: TRUE
[10:19:23.553] Local evaluation: TRUE
[10:19:23.553] Environment: R_GlobalEnv
[10:19:23.553] Capture standard output: TRUE
[10:19:23.553] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.553] Globals: 5 objects totaling 216 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.553] Packages: <none>
[10:19:23.553] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:23.553] Resolved: TRUE
[10:19:23.553] Value: <not collected>
[10:19:23.553] Conditions captured: <none>
[10:19:23.553] Early signaling: FALSE
[10:19:23.553] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.553] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.561] Chunk #2 of 2 ... DONE
[10:19:23.561] Launching 2 futures (chunks) ... DONE
[10:19:23.561] Resolving 2 futures (chunks) ...
[10:19:23.562] resolve() on list ...
[10:19:23.562]  recursive: 0
[10:19:23.562]  length: 2
[10:19:23.562] 
[10:19:23.562] Future #1
[10:19:23.563] result() for MulticoreFuture ...
[10:19:23.563] result() for MulticoreFuture ...
[10:19:23.564] result() for MulticoreFuture ... done
[10:19:23.564] result() for MulticoreFuture ... done
[10:19:23.564] result() for MulticoreFuture ...
[10:19:23.564] result() for MulticoreFuture ... done
[10:19:23.564] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:23.564] - nx: 2
[10:19:23.564] - relay: TRUE
[10:19:23.565] - stdout: TRUE
[10:19:23.565] - signal: TRUE
[10:19:23.565] - resignal: FALSE
[10:19:23.565] - force: TRUE
[10:19:23.565] - relayed: [n=2] FALSE, FALSE
[10:19:23.565] - queued futures: [n=2] FALSE, FALSE
[10:19:23.566]  - until=1
[10:19:23.566]  - relaying element #1
[10:19:23.566] result() for MulticoreFuture ...
[10:19:23.566] result() for MulticoreFuture ... done
[10:19:23.566] result() for MulticoreFuture ...
[10:19:23.566] result() for MulticoreFuture ... done
[10:19:23.566] result() for MulticoreFuture ...
[10:19:23.567] result() for MulticoreFuture ... done
[10:19:23.567] result() for MulticoreFuture ...
[10:19:23.567] result() for MulticoreFuture ... done
[10:19:23.567] - relayed: [n=2] TRUE, FALSE
[10:19:23.567] - queued futures: [n=2] TRUE, FALSE
[10:19:23.567] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:23.568]  length: 1 (resolved future 1)
[10:19:23.568] Future #2
[10:19:23.568] result() for MulticoreFuture ...
[10:19:23.569] result() for MulticoreFuture ...
[10:19:23.572] result() for MulticoreFuture ... done
[10:19:23.573] result() for MulticoreFuture ... done
[10:19:23.573] result() for MulticoreFuture ...
[10:19:23.573] result() for MulticoreFuture ... done
[10:19:23.573] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:23.573] - nx: 2
[10:19:23.574] - relay: TRUE
[10:19:23.574] - stdout: TRUE
[10:19:23.574] - signal: TRUE
[10:19:23.574] - resignal: FALSE
[10:19:23.574] - force: TRUE
[10:19:23.574] - relayed: [n=2] TRUE, FALSE
[10:19:23.575] - queued futures: [n=2] TRUE, FALSE
[10:19:23.575]  - until=2
[10:19:23.575]  - relaying element #2
[10:19:23.575] result() for MulticoreFuture ...
[10:19:23.575] result() for MulticoreFuture ... done
[10:19:23.575] result() for MulticoreFuture ...
[10:19:23.575] result() for MulticoreFuture ... done
[10:19:23.576] result() for MulticoreFuture ...
[10:19:23.576] result() for MulticoreFuture ... done
[10:19:23.576] result() for MulticoreFuture ...
[10:19:23.576] result() for MulticoreFuture ... done
[10:19:23.576] - relayed: [n=2] TRUE, TRUE
[10:19:23.577] - queued futures: [n=2] TRUE, TRUE
[10:19:23.577] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:23.577]  length: 0 (resolved future 2)
[10:19:23.577] Relaying remaining futures
[10:19:23.577] signalConditionsASAP(NULL, pos=0) ...
[10:19:23.577] - nx: 2
[10:19:23.578] - relay: TRUE
[10:19:23.578] - stdout: TRUE
[10:19:23.578] - signal: TRUE
[10:19:23.578] - resignal: FALSE
[10:19:23.578] - force: TRUE
[10:19:23.578] - relayed: [n=2] TRUE, TRUE
[10:19:23.578] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:23.579] - relayed: [n=2] TRUE, TRUE
[10:19:23.579] - queued futures: [n=2] TRUE, TRUE
[10:19:23.579] signalConditionsASAP(NULL, pos=0) ... done
[10:19:23.579] resolve() on list ... DONE
[10:19:23.579] result() for MulticoreFuture ...
[10:19:23.579] result() for MulticoreFuture ... done
[10:19:23.579] result() for MulticoreFuture ...
[10:19:23.579] result() for MulticoreFuture ... done
[10:19:23.580] result() for MulticoreFuture ...
[10:19:23.580] result() for MulticoreFuture ... done
[10:19:23.580] result() for MulticoreFuture ...
[10:19:23.580] result() for MulticoreFuture ... done
[10:19:23.580]  - Number of value chunks collected: 2
[10:19:23.580] Resolving 2 futures (chunks) ... DONE
[10:19:23.581] Reducing values from 2 chunks ...
[10:19:23.581]  - Number of values collected after concatenation: 3
[10:19:23.581]  - Number of values expected: 3
[10:19:23.581] Reducing values from 2 chunks ... DONE
[10:19:23.581] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[10:19:23.582] future_mapply() ...
[10:19:23.584] Number of chunks: 2
[10:19:23.584] getGlobalsAndPackagesXApply() ...
[10:19:23.584]  - future.globals: TRUE
[10:19:23.585] getGlobalsAndPackages() ...
[10:19:23.585] Searching for globals...
[10:19:23.586] - globals found: [1] ‘FUN’
[10:19:23.586] Searching for globals ... DONE
[10:19:23.586] Resolving globals: FALSE
[10:19:23.587] The total size of the 1 globals is 185 bytes (185 bytes)
[10:19:23.587] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:19:23.587] - globals: [1] ‘FUN’
[10:19:23.587] 
[10:19:23.587] getGlobalsAndPackages() ... DONE
[10:19:23.587]  - globals found/used: [n=1] ‘FUN’
[10:19:23.588]  - needed namespaces: [n=0] 
[10:19:23.588] Finding globals ... DONE
[10:19:23.588] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:23.588] List of 2
[10:19:23.588]  $ ...future.FUN:function (x)  
[10:19:23.588]  $ MoreArgs     : NULL
[10:19:23.588]  - attr(*, "where")=List of 2
[10:19:23.588]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:23.588]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:23.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.588]  - attr(*, "resolved")= logi FALSE
[10:19:23.588]  - attr(*, "total_size")= num NA
[10:19:23.591] Packages to be attached in all futures: [n=0] 
[10:19:23.591] getGlobalsAndPackagesXApply() ... DONE
[10:19:23.591] Number of futures (= number of chunks): 2
[10:19:23.591] Launching 2 futures (chunks) ...
[10:19:23.591] Chunk #1 of 2 ...
[10:19:23.592]  - Finding globals in '...' for chunk #1 ...
[10:19:23.592] getGlobalsAndPackages() ...
[10:19:23.592] Searching for globals...
[10:19:23.592] 
[10:19:23.592] Searching for globals ... DONE
[10:19:23.592] - globals: [0] <none>
[10:19:23.592] getGlobalsAndPackages() ... DONE
[10:19:23.592]    + additional globals found: [n=0] 
[10:19:23.592]    + additional namespaces needed: [n=0] 
[10:19:23.593]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:23.593]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.593]  - seeds: <none>
[10:19:23.593]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.593] getGlobalsAndPackages() ...
[10:19:23.593] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.593] Resolving globals: FALSE
[10:19:23.594] The total size of the 5 globals is 363 bytes (363 bytes)
[10:19:23.594] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:23.594] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.594] 
[10:19:23.594] getGlobalsAndPackages() ... DONE
[10:19:23.595] run() for ‘Future’ ...
[10:19:23.595] - state: ‘created’
[10:19:23.595] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.641] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.641] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.641]   - Field: ‘label’
[10:19:23.641]   - Field: ‘local’
[10:19:23.642]   - Field: ‘owner’
[10:19:23.642]   - Field: ‘envir’
[10:19:23.642]   - Field: ‘workers’
[10:19:23.642]   - Field: ‘packages’
[10:19:23.642]   - Field: ‘gc’
[10:19:23.642]   - Field: ‘job’
[10:19:23.642]   - Field: ‘conditions’
[10:19:23.642]   - Field: ‘expr’
[10:19:23.642]   - Field: ‘uuid’
[10:19:23.642]   - Field: ‘seed’
[10:19:23.642]   - Field: ‘version’
[10:19:23.642]   - Field: ‘result’
[10:19:23.643]   - Field: ‘asynchronous’
[10:19:23.643]   - Field: ‘calls’
[10:19:23.643]   - Field: ‘globals’
[10:19:23.643]   - Field: ‘stdout’
[10:19:23.643]   - Field: ‘earlySignal’
[10:19:23.643]   - Field: ‘lazy’
[10:19:23.643]   - Field: ‘state’
[10:19:23.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.643] - Launch lazy future ...
[10:19:23.644] Packages needed by the future expression (n = 0): <none>
[10:19:23.644] Packages needed by future strategies (n = 0): <none>
[10:19:23.644] {
[10:19:23.644]     {
[10:19:23.644]         {
[10:19:23.644]             ...future.startTime <- base::Sys.time()
[10:19:23.644]             {
[10:19:23.644]                 {
[10:19:23.644]                   {
[10:19:23.644]                     {
[10:19:23.644]                       base::local({
[10:19:23.644]                         has_future <- base::requireNamespace("future", 
[10:19:23.644]                           quietly = TRUE)
[10:19:23.644]                         if (has_future) {
[10:19:23.644]                           ns <- base::getNamespace("future")
[10:19:23.644]                           version <- ns[[".package"]][["version"]]
[10:19:23.644]                           if (is.null(version)) 
[10:19:23.644]                             version <- utils::packageVersion("future")
[10:19:23.644]                         }
[10:19:23.644]                         else {
[10:19:23.644]                           version <- NULL
[10:19:23.644]                         }
[10:19:23.644]                         if (!has_future || version < "1.8.0") {
[10:19:23.644]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.644]                             "", base::R.version$version.string), 
[10:19:23.644]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:23.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:23.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.644]                               "release", "version")], collapse = " "), 
[10:19:23.644]                             hostname = base::Sys.info()[["nodename"]])
[10:19:23.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.644]                             info)
[10:19:23.644]                           info <- base::paste(info, collapse = "; ")
[10:19:23.644]                           if (!has_future) {
[10:19:23.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.644]                               info)
[10:19:23.644]                           }
[10:19:23.644]                           else {
[10:19:23.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.644]                               info, version)
[10:19:23.644]                           }
[10:19:23.644]                           base::stop(msg)
[10:19:23.644]                         }
[10:19:23.644]                       })
[10:19:23.644]                     }
[10:19:23.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.644]                     base::options(mc.cores = 1L)
[10:19:23.644]                   }
[10:19:23.644]                   ...future.strategy.old <- future::plan("list")
[10:19:23.644]                   options(future.plan = NULL)
[10:19:23.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.644]                 }
[10:19:23.644]                 ...future.workdir <- getwd()
[10:19:23.644]             }
[10:19:23.644]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.644]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.644]         }
[10:19:23.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.644]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.644]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.644]             base::names(...future.oldOptions))
[10:19:23.644]     }
[10:19:23.644]     if (FALSE) {
[10:19:23.644]     }
[10:19:23.644]     else {
[10:19:23.644]         if (TRUE) {
[10:19:23.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.644]                 open = "w")
[10:19:23.644]         }
[10:19:23.644]         else {
[10:19:23.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.644]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.644]         }
[10:19:23.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.644]             base::sink(type = "output", split = FALSE)
[10:19:23.644]             base::close(...future.stdout)
[10:19:23.644]         }, add = TRUE)
[10:19:23.644]     }
[10:19:23.644]     ...future.frame <- base::sys.nframe()
[10:19:23.644]     ...future.conditions <- base::list()
[10:19:23.644]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.644]     if (FALSE) {
[10:19:23.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.644]     }
[10:19:23.644]     ...future.result <- base::tryCatch({
[10:19:23.644]         base::withCallingHandlers({
[10:19:23.644]             ...future.value <- base::withVisible(base::local({
[10:19:23.644]                 withCallingHandlers({
[10:19:23.644]                   {
[10:19:23.644]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.644]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.644]                       ...future.globals.maxSize)) {
[10:19:23.644]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.644]                       on.exit(options(oopts), add = TRUE)
[10:19:23.644]                     }
[10:19:23.644]                     {
[10:19:23.644]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.644]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.644]                         USE.NAMES = FALSE)
[10:19:23.644]                       do.call(mapply, args = args)
[10:19:23.644]                     }
[10:19:23.644]                   }
[10:19:23.644]                 }, immediateCondition = function(cond) {
[10:19:23.644]                   save_rds <- function (object, pathname, ...) 
[10:19:23.644]                   {
[10:19:23.644]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.644]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.644]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.644]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.644]                         fi_tmp[["mtime"]])
[10:19:23.644]                     }
[10:19:23.644]                     tryCatch({
[10:19:23.644]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.644]                     }, error = function(ex) {
[10:19:23.644]                       msg <- conditionMessage(ex)
[10:19:23.644]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.644]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.644]                         fi_tmp[["mtime"]], msg)
[10:19:23.644]                       ex$message <- msg
[10:19:23.644]                       stop(ex)
[10:19:23.644]                     })
[10:19:23.644]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.644]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.644]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.644]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.644]                       fi <- file.info(pathname)
[10:19:23.644]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.644]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.644]                         fi[["size"]], fi[["mtime"]])
[10:19:23.644]                       stop(msg)
[10:19:23.644]                     }
[10:19:23.644]                     invisible(pathname)
[10:19:23.644]                   }
[10:19:23.644]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.644]                     rootPath = tempdir()) 
[10:19:23.644]                   {
[10:19:23.644]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.644]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.644]                       tmpdir = path, fileext = ".rds")
[10:19:23.644]                     save_rds(obj, file)
[10:19:23.644]                   }
[10:19:23.644]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.644]                   {
[10:19:23.644]                     inherits <- base::inherits
[10:19:23.644]                     invokeRestart <- base::invokeRestart
[10:19:23.644]                     is.null <- base::is.null
[10:19:23.644]                     muffled <- FALSE
[10:19:23.644]                     if (inherits(cond, "message")) {
[10:19:23.644]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.644]                       if (muffled) 
[10:19:23.644]                         invokeRestart("muffleMessage")
[10:19:23.644]                     }
[10:19:23.644]                     else if (inherits(cond, "warning")) {
[10:19:23.644]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.644]                       if (muffled) 
[10:19:23.644]                         invokeRestart("muffleWarning")
[10:19:23.644]                     }
[10:19:23.644]                     else if (inherits(cond, "condition")) {
[10:19:23.644]                       if (!is.null(pattern)) {
[10:19:23.644]                         computeRestarts <- base::computeRestarts
[10:19:23.644]                         grepl <- base::grepl
[10:19:23.644]                         restarts <- computeRestarts(cond)
[10:19:23.644]                         for (restart in restarts) {
[10:19:23.644]                           name <- restart$name
[10:19:23.644]                           if (is.null(name)) 
[10:19:23.644]                             next
[10:19:23.644]                           if (!grepl(pattern, name)) 
[10:19:23.644]                             next
[10:19:23.644]                           invokeRestart(restart)
[10:19:23.644]                           muffled <- TRUE
[10:19:23.644]                           break
[10:19:23.644]                         }
[10:19:23.644]                       }
[10:19:23.644]                     }
[10:19:23.644]                     invisible(muffled)
[10:19:23.644]                   }
[10:19:23.644]                   muffleCondition(cond)
[10:19:23.644]                 })
[10:19:23.644]             }))
[10:19:23.644]             future::FutureResult(value = ...future.value$value, 
[10:19:23.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.644]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.644]                     ...future.globalenv.names))
[10:19:23.644]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.644]         }, condition = base::local({
[10:19:23.644]             c <- base::c
[10:19:23.644]             inherits <- base::inherits
[10:19:23.644]             invokeRestart <- base::invokeRestart
[10:19:23.644]             length <- base::length
[10:19:23.644]             list <- base::list
[10:19:23.644]             seq.int <- base::seq.int
[10:19:23.644]             signalCondition <- base::signalCondition
[10:19:23.644]             sys.calls <- base::sys.calls
[10:19:23.644]             `[[` <- base::`[[`
[10:19:23.644]             `+` <- base::`+`
[10:19:23.644]             `<<-` <- base::`<<-`
[10:19:23.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.644]                   3L)]
[10:19:23.644]             }
[10:19:23.644]             function(cond) {
[10:19:23.644]                 is_error <- inherits(cond, "error")
[10:19:23.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.644]                   NULL)
[10:19:23.644]                 if (is_error) {
[10:19:23.644]                   sessionInformation <- function() {
[10:19:23.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.644]                       search = base::search(), system = base::Sys.info())
[10:19:23.644]                   }
[10:19:23.644]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.644]                     cond$call), session = sessionInformation(), 
[10:19:23.644]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.644]                   signalCondition(cond)
[10:19:23.644]                 }
[10:19:23.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.644]                 "immediateCondition"))) {
[10:19:23.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.644]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.644]                   if (TRUE && !signal) {
[10:19:23.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.644]                     {
[10:19:23.644]                       inherits <- base::inherits
[10:19:23.644]                       invokeRestart <- base::invokeRestart
[10:19:23.644]                       is.null <- base::is.null
[10:19:23.644]                       muffled <- FALSE
[10:19:23.644]                       if (inherits(cond, "message")) {
[10:19:23.644]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.644]                         if (muffled) 
[10:19:23.644]                           invokeRestart("muffleMessage")
[10:19:23.644]                       }
[10:19:23.644]                       else if (inherits(cond, "warning")) {
[10:19:23.644]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.644]                         if (muffled) 
[10:19:23.644]                           invokeRestart("muffleWarning")
[10:19:23.644]                       }
[10:19:23.644]                       else if (inherits(cond, "condition")) {
[10:19:23.644]                         if (!is.null(pattern)) {
[10:19:23.644]                           computeRestarts <- base::computeRestarts
[10:19:23.644]                           grepl <- base::grepl
[10:19:23.644]                           restarts <- computeRestarts(cond)
[10:19:23.644]                           for (restart in restarts) {
[10:19:23.644]                             name <- restart$name
[10:19:23.644]                             if (is.null(name)) 
[10:19:23.644]                               next
[10:19:23.644]                             if (!grepl(pattern, name)) 
[10:19:23.644]                               next
[10:19:23.644]                             invokeRestart(restart)
[10:19:23.644]                             muffled <- TRUE
[10:19:23.644]                             break
[10:19:23.644]                           }
[10:19:23.644]                         }
[10:19:23.644]                       }
[10:19:23.644]                       invisible(muffled)
[10:19:23.644]                     }
[10:19:23.644]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.644]                   }
[10:19:23.644]                 }
[10:19:23.644]                 else {
[10:19:23.644]                   if (TRUE) {
[10:19:23.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.644]                     {
[10:19:23.644]                       inherits <- base::inherits
[10:19:23.644]                       invokeRestart <- base::invokeRestart
[10:19:23.644]                       is.null <- base::is.null
[10:19:23.644]                       muffled <- FALSE
[10:19:23.644]                       if (inherits(cond, "message")) {
[10:19:23.644]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.644]                         if (muffled) 
[10:19:23.644]                           invokeRestart("muffleMessage")
[10:19:23.644]                       }
[10:19:23.644]                       else if (inherits(cond, "warning")) {
[10:19:23.644]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.644]                         if (muffled) 
[10:19:23.644]                           invokeRestart("muffleWarning")
[10:19:23.644]                       }
[10:19:23.644]                       else if (inherits(cond, "condition")) {
[10:19:23.644]                         if (!is.null(pattern)) {
[10:19:23.644]                           computeRestarts <- base::computeRestarts
[10:19:23.644]                           grepl <- base::grepl
[10:19:23.644]                           restarts <- computeRestarts(cond)
[10:19:23.644]                           for (restart in restarts) {
[10:19:23.644]                             name <- restart$name
[10:19:23.644]                             if (is.null(name)) 
[10:19:23.644]                               next
[10:19:23.644]                             if (!grepl(pattern, name)) 
[10:19:23.644]                               next
[10:19:23.644]                             invokeRestart(restart)
[10:19:23.644]                             muffled <- TRUE
[10:19:23.644]                             break
[10:19:23.644]                           }
[10:19:23.644]                         }
[10:19:23.644]                       }
[10:19:23.644]                       invisible(muffled)
[10:19:23.644]                     }
[10:19:23.644]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.644]                   }
[10:19:23.644]                 }
[10:19:23.644]             }
[10:19:23.644]         }))
[10:19:23.644]     }, error = function(ex) {
[10:19:23.644]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.644]                 ...future.rng), started = ...future.startTime, 
[10:19:23.644]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.644]             version = "1.8"), class = "FutureResult")
[10:19:23.644]     }, finally = {
[10:19:23.644]         if (!identical(...future.workdir, getwd())) 
[10:19:23.644]             setwd(...future.workdir)
[10:19:23.644]         {
[10:19:23.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.644]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.644]             }
[10:19:23.644]             base::options(...future.oldOptions)
[10:19:23.644]             if (.Platform$OS.type == "windows") {
[10:19:23.644]                 old_names <- names(...future.oldEnvVars)
[10:19:23.644]                 envs <- base::Sys.getenv()
[10:19:23.644]                 names <- names(envs)
[10:19:23.644]                 common <- intersect(names, old_names)
[10:19:23.644]                 added <- setdiff(names, old_names)
[10:19:23.644]                 removed <- setdiff(old_names, names)
[10:19:23.644]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.644]                   envs[common]]
[10:19:23.644]                 NAMES <- toupper(changed)
[10:19:23.644]                 args <- list()
[10:19:23.644]                 for (kk in seq_along(NAMES)) {
[10:19:23.644]                   name <- changed[[kk]]
[10:19:23.644]                   NAME <- NAMES[[kk]]
[10:19:23.644]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.644]                     next
[10:19:23.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.644]                 }
[10:19:23.644]                 NAMES <- toupper(added)
[10:19:23.644]                 for (kk in seq_along(NAMES)) {
[10:19:23.644]                   name <- added[[kk]]
[10:19:23.644]                   NAME <- NAMES[[kk]]
[10:19:23.644]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.644]                     next
[10:19:23.644]                   args[[name]] <- ""
[10:19:23.644]                 }
[10:19:23.644]                 NAMES <- toupper(removed)
[10:19:23.644]                 for (kk in seq_along(NAMES)) {
[10:19:23.644]                   name <- removed[[kk]]
[10:19:23.644]                   NAME <- NAMES[[kk]]
[10:19:23.644]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.644]                     next
[10:19:23.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.644]                 }
[10:19:23.644]                 if (length(args) > 0) 
[10:19:23.644]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.644]             }
[10:19:23.644]             else {
[10:19:23.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.644]             }
[10:19:23.644]             {
[10:19:23.644]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.644]                   0L) {
[10:19:23.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.644]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.644]                   base::options(opts)
[10:19:23.644]                 }
[10:19:23.644]                 {
[10:19:23.644]                   {
[10:19:23.644]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.644]                     NULL
[10:19:23.644]                   }
[10:19:23.644]                   options(future.plan = NULL)
[10:19:23.644]                   if (is.na(NA_character_)) 
[10:19:23.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.644]                     .init = FALSE)
[10:19:23.644]                 }
[10:19:23.644]             }
[10:19:23.644]         }
[10:19:23.644]     })
[10:19:23.644]     if (TRUE) {
[10:19:23.644]         base::sink(type = "output", split = FALSE)
[10:19:23.644]         if (TRUE) {
[10:19:23.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.644]         }
[10:19:23.644]         else {
[10:19:23.644]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.644]         }
[10:19:23.644]         base::close(...future.stdout)
[10:19:23.644]         ...future.stdout <- NULL
[10:19:23.644]     }
[10:19:23.644]     ...future.result$conditions <- ...future.conditions
[10:19:23.644]     ...future.result$finished <- base::Sys.time()
[10:19:23.644]     ...future.result
[10:19:23.644] }
[10:19:23.646] assign_globals() ...
[10:19:23.646] List of 5
[10:19:23.646]  $ ...future.FUN            :function (x)  
[10:19:23.646]  $ MoreArgs                 : NULL
[10:19:23.646]  $ ...future.elements_ii    :List of 1
[10:19:23.646]   ..$ :List of 1
[10:19:23.646]   .. ..$ a: num 0
[10:19:23.646]  $ ...future.seeds_ii       : NULL
[10:19:23.646]  $ ...future.globals.maxSize: NULL
[10:19:23.646]  - attr(*, "where")=List of 5
[10:19:23.646]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.646]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.646]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.646]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.646]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.646]  - attr(*, "resolved")= logi FALSE
[10:19:23.646]  - attr(*, "total_size")= num 363
[10:19:23.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.646]  - attr(*, "already-done")= logi TRUE
[10:19:23.651] - copied ‘...future.FUN’ to environment
[10:19:23.651] - copied ‘MoreArgs’ to environment
[10:19:23.651] - copied ‘...future.elements_ii’ to environment
[10:19:23.651] - copied ‘...future.seeds_ii’ to environment
[10:19:23.651] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.651] assign_globals() ... done
[10:19:23.652] requestCore(): workers = 2
[10:19:23.654] MulticoreFuture started
[10:19:23.654] - Launch lazy future ... done
[10:19:23.654] run() for ‘MulticoreFuture’ ... done
[10:19:23.655] Created future:
[10:19:23.655] plan(): Setting new future strategy stack:
[10:19:23.655] List of future strategies:
[10:19:23.655] 1. sequential:
[10:19:23.655]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.655]    - tweaked: FALSE
[10:19:23.655]    - call: NULL
[10:19:23.656] plan(): nbrOfWorkers() = 1
[10:19:23.658] plan(): Setting new future strategy stack:
[10:19:23.658] List of future strategies:
[10:19:23.658] 1. multicore:
[10:19:23.658]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.658]    - tweaked: FALSE
[10:19:23.658]    - call: plan(strategy)
[10:19:23.662] plan(): nbrOfWorkers() = 2
[10:19:23.655] MulticoreFuture:
[10:19:23.655] Label: ‘future_mapply-1’
[10:19:23.655] Expression:
[10:19:23.655] {
[10:19:23.655]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.655]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.655]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.655]         on.exit(options(oopts), add = TRUE)
[10:19:23.655]     }
[10:19:23.655]     {
[10:19:23.655]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.655]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.655]         do.call(mapply, args = args)
[10:19:23.655]     }
[10:19:23.655] }
[10:19:23.655] Lazy evaluation: FALSE
[10:19:23.655] Asynchronous evaluation: TRUE
[10:19:23.655] Local evaluation: TRUE
[10:19:23.655] Environment: R_GlobalEnv
[10:19:23.655] Capture standard output: TRUE
[10:19:23.655] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.655] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.655] Packages: <none>
[10:19:23.655] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:23.655] Resolved: TRUE
[10:19:23.655] Value: <not collected>
[10:19:23.655] Conditions captured: <none>
[10:19:23.655] Early signaling: FALSE
[10:19:23.655] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.655] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.663] Chunk #1 of 2 ... DONE
[10:19:23.663] Chunk #2 of 2 ...
[10:19:23.663]  - Finding globals in '...' for chunk #2 ...
[10:19:23.663] getGlobalsAndPackages() ...
[10:19:23.663] Searching for globals...
[10:19:23.664] 
[10:19:23.664] Searching for globals ... DONE
[10:19:23.664] - globals: [0] <none>
[10:19:23.664] getGlobalsAndPackages() ... DONE
[10:19:23.664]    + additional globals found: [n=0] 
[10:19:23.665]    + additional namespaces needed: [n=0] 
[10:19:23.665]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:23.665]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:23.665]  - seeds: <none>
[10:19:23.665]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.665] getGlobalsAndPackages() ...
[10:19:23.665] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.665] Resolving globals: FALSE
[10:19:23.666] The total size of the 5 globals is 363 bytes (363 bytes)
[10:19:23.667] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:23.667] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:23.667] 
[10:19:23.667] getGlobalsAndPackages() ... DONE
[10:19:23.668] run() for ‘Future’ ...
[10:19:23.668] - state: ‘created’
[10:19:23.668] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:19:23.671] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:19:23.671]   - Field: ‘label’
[10:19:23.671]   - Field: ‘local’
[10:19:23.672]   - Field: ‘owner’
[10:19:23.672]   - Field: ‘envir’
[10:19:23.672]   - Field: ‘workers’
[10:19:23.672]   - Field: ‘packages’
[10:19:23.672]   - Field: ‘gc’
[10:19:23.672]   - Field: ‘job’
[10:19:23.672]   - Field: ‘conditions’
[10:19:23.672]   - Field: ‘expr’
[10:19:23.673]   - Field: ‘uuid’
[10:19:23.673]   - Field: ‘seed’
[10:19:23.673]   - Field: ‘version’
[10:19:23.673]   - Field: ‘result’
[10:19:23.673]   - Field: ‘asynchronous’
[10:19:23.673]   - Field: ‘calls’
[10:19:23.673]   - Field: ‘globals’
[10:19:23.673]   - Field: ‘stdout’
[10:19:23.674]   - Field: ‘earlySignal’
[10:19:23.674]   - Field: ‘lazy’
[10:19:23.674]   - Field: ‘state’
[10:19:23.674] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:19:23.674] - Launch lazy future ...
[10:19:23.675] Packages needed by the future expression (n = 0): <none>
[10:19:23.675] Packages needed by future strategies (n = 0): <none>
[10:19:23.675] {
[10:19:23.675]     {
[10:19:23.675]         {
[10:19:23.675]             ...future.startTime <- base::Sys.time()
[10:19:23.675]             {
[10:19:23.675]                 {
[10:19:23.675]                   {
[10:19:23.675]                     {
[10:19:23.675]                       base::local({
[10:19:23.675]                         has_future <- base::requireNamespace("future", 
[10:19:23.675]                           quietly = TRUE)
[10:19:23.675]                         if (has_future) {
[10:19:23.675]                           ns <- base::getNamespace("future")
[10:19:23.675]                           version <- ns[[".package"]][["version"]]
[10:19:23.675]                           if (is.null(version)) 
[10:19:23.675]                             version <- utils::packageVersion("future")
[10:19:23.675]                         }
[10:19:23.675]                         else {
[10:19:23.675]                           version <- NULL
[10:19:23.675]                         }
[10:19:23.675]                         if (!has_future || version < "1.8.0") {
[10:19:23.675]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:23.675]                             "", base::R.version$version.string), 
[10:19:23.675]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:23.675]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:23.675]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:23.675]                               "release", "version")], collapse = " "), 
[10:19:23.675]                             hostname = base::Sys.info()[["nodename"]])
[10:19:23.675]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:23.675]                             info)
[10:19:23.675]                           info <- base::paste(info, collapse = "; ")
[10:19:23.675]                           if (!has_future) {
[10:19:23.675]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:23.675]                               info)
[10:19:23.675]                           }
[10:19:23.675]                           else {
[10:19:23.675]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:23.675]                               info, version)
[10:19:23.675]                           }
[10:19:23.675]                           base::stop(msg)
[10:19:23.675]                         }
[10:19:23.675]                       })
[10:19:23.675]                     }
[10:19:23.675]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:23.675]                     base::options(mc.cores = 1L)
[10:19:23.675]                   }
[10:19:23.675]                   ...future.strategy.old <- future::plan("list")
[10:19:23.675]                   options(future.plan = NULL)
[10:19:23.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:23.675]                 }
[10:19:23.675]                 ...future.workdir <- getwd()
[10:19:23.675]             }
[10:19:23.675]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:23.675]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:23.675]         }
[10:19:23.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:23.675]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:23.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:23.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:23.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:23.675]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:23.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:23.675]             base::names(...future.oldOptions))
[10:19:23.675]     }
[10:19:23.675]     if (FALSE) {
[10:19:23.675]     }
[10:19:23.675]     else {
[10:19:23.675]         if (TRUE) {
[10:19:23.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:23.675]                 open = "w")
[10:19:23.675]         }
[10:19:23.675]         else {
[10:19:23.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:23.675]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:23.675]         }
[10:19:23.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:23.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:23.675]             base::sink(type = "output", split = FALSE)
[10:19:23.675]             base::close(...future.stdout)
[10:19:23.675]         }, add = TRUE)
[10:19:23.675]     }
[10:19:23.675]     ...future.frame <- base::sys.nframe()
[10:19:23.675]     ...future.conditions <- base::list()
[10:19:23.675]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:23.675]     if (FALSE) {
[10:19:23.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:23.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:23.675]     }
[10:19:23.675]     ...future.result <- base::tryCatch({
[10:19:23.675]         base::withCallingHandlers({
[10:19:23.675]             ...future.value <- base::withVisible(base::local({
[10:19:23.675]                 withCallingHandlers({
[10:19:23.675]                   {
[10:19:23.675]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.675]                     if (!identical(...future.globals.maxSize.org, 
[10:19:23.675]                       ...future.globals.maxSize)) {
[10:19:23.675]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.675]                       on.exit(options(oopts), add = TRUE)
[10:19:23.675]                     }
[10:19:23.675]                     {
[10:19:23.675]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.675]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:23.675]                         USE.NAMES = FALSE)
[10:19:23.675]                       do.call(mapply, args = args)
[10:19:23.675]                     }
[10:19:23.675]                   }
[10:19:23.675]                 }, immediateCondition = function(cond) {
[10:19:23.675]                   save_rds <- function (object, pathname, ...) 
[10:19:23.675]                   {
[10:19:23.675]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:19:23.675]                     if (file_test("-f", pathname_tmp)) {
[10:19:23.675]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.675]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:19:23.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.675]                         fi_tmp[["mtime"]])
[10:19:23.675]                     }
[10:19:23.675]                     tryCatch({
[10:19:23.675]                       saveRDS(object, file = pathname_tmp, ...)
[10:19:23.675]                     }, error = function(ex) {
[10:19:23.675]                       msg <- conditionMessage(ex)
[10:19:23.675]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.675]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:19:23.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.675]                         fi_tmp[["mtime"]], msg)
[10:19:23.675]                       ex$message <- msg
[10:19:23.675]                       stop(ex)
[10:19:23.675]                     })
[10:19:23.675]                     stopifnot(file_test("-f", pathname_tmp))
[10:19:23.675]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:19:23.675]                     if (!res || file_test("-f", pathname_tmp)) {
[10:19:23.675]                       fi_tmp <- file.info(pathname_tmp)
[10:19:23.675]                       fi <- file.info(pathname)
[10:19:23.675]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:19:23.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:19:23.675]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:19:23.675]                         fi[["size"]], fi[["mtime"]])
[10:19:23.675]                       stop(msg)
[10:19:23.675]                     }
[10:19:23.675]                     invisible(pathname)
[10:19:23.675]                   }
[10:19:23.675]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:19:23.675]                     rootPath = tempdir()) 
[10:19:23.675]                   {
[10:19:23.675]                     obj <- list(time = Sys.time(), condition = cond)
[10:19:23.675]                     file <- tempfile(pattern = class(cond)[1], 
[10:19:23.675]                       tmpdir = path, fileext = ".rds")
[10:19:23.675]                     save_rds(obj, file)
[10:19:23.675]                   }
[10:19:23.675]                   saveImmediateCondition(cond, path = "/tmp/RtmpwPCcH2/.future/immediateConditions")
[10:19:23.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.675]                   {
[10:19:23.675]                     inherits <- base::inherits
[10:19:23.675]                     invokeRestart <- base::invokeRestart
[10:19:23.675]                     is.null <- base::is.null
[10:19:23.675]                     muffled <- FALSE
[10:19:23.675]                     if (inherits(cond, "message")) {
[10:19:23.675]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:23.675]                       if (muffled) 
[10:19:23.675]                         invokeRestart("muffleMessage")
[10:19:23.675]                     }
[10:19:23.675]                     else if (inherits(cond, "warning")) {
[10:19:23.675]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:23.675]                       if (muffled) 
[10:19:23.675]                         invokeRestart("muffleWarning")
[10:19:23.675]                     }
[10:19:23.675]                     else if (inherits(cond, "condition")) {
[10:19:23.675]                       if (!is.null(pattern)) {
[10:19:23.675]                         computeRestarts <- base::computeRestarts
[10:19:23.675]                         grepl <- base::grepl
[10:19:23.675]                         restarts <- computeRestarts(cond)
[10:19:23.675]                         for (restart in restarts) {
[10:19:23.675]                           name <- restart$name
[10:19:23.675]                           if (is.null(name)) 
[10:19:23.675]                             next
[10:19:23.675]                           if (!grepl(pattern, name)) 
[10:19:23.675]                             next
[10:19:23.675]                           invokeRestart(restart)
[10:19:23.675]                           muffled <- TRUE
[10:19:23.675]                           break
[10:19:23.675]                         }
[10:19:23.675]                       }
[10:19:23.675]                     }
[10:19:23.675]                     invisible(muffled)
[10:19:23.675]                   }
[10:19:23.675]                   muffleCondition(cond)
[10:19:23.675]                 })
[10:19:23.675]             }))
[10:19:23.675]             future::FutureResult(value = ...future.value$value, 
[10:19:23.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.675]                   ...future.rng), globalenv = if (FALSE) 
[10:19:23.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:23.675]                     ...future.globalenv.names))
[10:19:23.675]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:23.675]         }, condition = base::local({
[10:19:23.675]             c <- base::c
[10:19:23.675]             inherits <- base::inherits
[10:19:23.675]             invokeRestart <- base::invokeRestart
[10:19:23.675]             length <- base::length
[10:19:23.675]             list <- base::list
[10:19:23.675]             seq.int <- base::seq.int
[10:19:23.675]             signalCondition <- base::signalCondition
[10:19:23.675]             sys.calls <- base::sys.calls
[10:19:23.675]             `[[` <- base::`[[`
[10:19:23.675]             `+` <- base::`+`
[10:19:23.675]             `<<-` <- base::`<<-`
[10:19:23.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:23.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:23.675]                   3L)]
[10:19:23.675]             }
[10:19:23.675]             function(cond) {
[10:19:23.675]                 is_error <- inherits(cond, "error")
[10:19:23.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:23.675]                   NULL)
[10:19:23.675]                 if (is_error) {
[10:19:23.675]                   sessionInformation <- function() {
[10:19:23.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:23.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:23.675]                       search = base::search(), system = base::Sys.info())
[10:19:23.675]                   }
[10:19:23.675]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:23.675]                     cond$call), session = sessionInformation(), 
[10:19:23.675]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:23.675]                   signalCondition(cond)
[10:19:23.675]                 }
[10:19:23.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:23.675]                 "immediateCondition"))) {
[10:19:23.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:23.675]                   ...future.conditions[[length(...future.conditions) + 
[10:19:23.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:23.675]                   if (TRUE && !signal) {
[10:19:23.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.675]                     {
[10:19:23.675]                       inherits <- base::inherits
[10:19:23.675]                       invokeRestart <- base::invokeRestart
[10:19:23.675]                       is.null <- base::is.null
[10:19:23.675]                       muffled <- FALSE
[10:19:23.675]                       if (inherits(cond, "message")) {
[10:19:23.675]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.675]                         if (muffled) 
[10:19:23.675]                           invokeRestart("muffleMessage")
[10:19:23.675]                       }
[10:19:23.675]                       else if (inherits(cond, "warning")) {
[10:19:23.675]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.675]                         if (muffled) 
[10:19:23.675]                           invokeRestart("muffleWarning")
[10:19:23.675]                       }
[10:19:23.675]                       else if (inherits(cond, "condition")) {
[10:19:23.675]                         if (!is.null(pattern)) {
[10:19:23.675]                           computeRestarts <- base::computeRestarts
[10:19:23.675]                           grepl <- base::grepl
[10:19:23.675]                           restarts <- computeRestarts(cond)
[10:19:23.675]                           for (restart in restarts) {
[10:19:23.675]                             name <- restart$name
[10:19:23.675]                             if (is.null(name)) 
[10:19:23.675]                               next
[10:19:23.675]                             if (!grepl(pattern, name)) 
[10:19:23.675]                               next
[10:19:23.675]                             invokeRestart(restart)
[10:19:23.675]                             muffled <- TRUE
[10:19:23.675]                             break
[10:19:23.675]                           }
[10:19:23.675]                         }
[10:19:23.675]                       }
[10:19:23.675]                       invisible(muffled)
[10:19:23.675]                     }
[10:19:23.675]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.675]                   }
[10:19:23.675]                 }
[10:19:23.675]                 else {
[10:19:23.675]                   if (TRUE) {
[10:19:23.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:23.675]                     {
[10:19:23.675]                       inherits <- base::inherits
[10:19:23.675]                       invokeRestart <- base::invokeRestart
[10:19:23.675]                       is.null <- base::is.null
[10:19:23.675]                       muffled <- FALSE
[10:19:23.675]                       if (inherits(cond, "message")) {
[10:19:23.675]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:23.675]                         if (muffled) 
[10:19:23.675]                           invokeRestart("muffleMessage")
[10:19:23.675]                       }
[10:19:23.675]                       else if (inherits(cond, "warning")) {
[10:19:23.675]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:23.675]                         if (muffled) 
[10:19:23.675]                           invokeRestart("muffleWarning")
[10:19:23.675]                       }
[10:19:23.675]                       else if (inherits(cond, "condition")) {
[10:19:23.675]                         if (!is.null(pattern)) {
[10:19:23.675]                           computeRestarts <- base::computeRestarts
[10:19:23.675]                           grepl <- base::grepl
[10:19:23.675]                           restarts <- computeRestarts(cond)
[10:19:23.675]                           for (restart in restarts) {
[10:19:23.675]                             name <- restart$name
[10:19:23.675]                             if (is.null(name)) 
[10:19:23.675]                               next
[10:19:23.675]                             if (!grepl(pattern, name)) 
[10:19:23.675]                               next
[10:19:23.675]                             invokeRestart(restart)
[10:19:23.675]                             muffled <- TRUE
[10:19:23.675]                             break
[10:19:23.675]                           }
[10:19:23.675]                         }
[10:19:23.675]                       }
[10:19:23.675]                       invisible(muffled)
[10:19:23.675]                     }
[10:19:23.675]                     muffleCondition(cond, pattern = "^muffle")
[10:19:23.675]                   }
[10:19:23.675]                 }
[10:19:23.675]             }
[10:19:23.675]         }))
[10:19:23.675]     }, error = function(ex) {
[10:19:23.675]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:23.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:23.675]                 ...future.rng), started = ...future.startTime, 
[10:19:23.675]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:23.675]             version = "1.8"), class = "FutureResult")
[10:19:23.675]     }, finally = {
[10:19:23.675]         if (!identical(...future.workdir, getwd())) 
[10:19:23.675]             setwd(...future.workdir)
[10:19:23.675]         {
[10:19:23.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:23.675]                 ...future.oldOptions$nwarnings <- NULL
[10:19:23.675]             }
[10:19:23.675]             base::options(...future.oldOptions)
[10:19:23.675]             if (.Platform$OS.type == "windows") {
[10:19:23.675]                 old_names <- names(...future.oldEnvVars)
[10:19:23.675]                 envs <- base::Sys.getenv()
[10:19:23.675]                 names <- names(envs)
[10:19:23.675]                 common <- intersect(names, old_names)
[10:19:23.675]                 added <- setdiff(names, old_names)
[10:19:23.675]                 removed <- setdiff(old_names, names)
[10:19:23.675]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:23.675]                   envs[common]]
[10:19:23.675]                 NAMES <- toupper(changed)
[10:19:23.675]                 args <- list()
[10:19:23.675]                 for (kk in seq_along(NAMES)) {
[10:19:23.675]                   name <- changed[[kk]]
[10:19:23.675]                   NAME <- NAMES[[kk]]
[10:19:23.675]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.675]                     next
[10:19:23.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.675]                 }
[10:19:23.675]                 NAMES <- toupper(added)
[10:19:23.675]                 for (kk in seq_along(NAMES)) {
[10:19:23.675]                   name <- added[[kk]]
[10:19:23.675]                   NAME <- NAMES[[kk]]
[10:19:23.675]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.675]                     next
[10:19:23.675]                   args[[name]] <- ""
[10:19:23.675]                 }
[10:19:23.675]                 NAMES <- toupper(removed)
[10:19:23.675]                 for (kk in seq_along(NAMES)) {
[10:19:23.675]                   name <- removed[[kk]]
[10:19:23.675]                   NAME <- NAMES[[kk]]
[10:19:23.675]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:23.675]                     next
[10:19:23.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:23.675]                 }
[10:19:23.675]                 if (length(args) > 0) 
[10:19:23.675]                   base::do.call(base::Sys.setenv, args = args)
[10:19:23.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:23.675]             }
[10:19:23.675]             else {
[10:19:23.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:23.675]             }
[10:19:23.675]             {
[10:19:23.675]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:23.675]                   0L) {
[10:19:23.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:23.675]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:23.675]                   base::options(opts)
[10:19:23.675]                 }
[10:19:23.675]                 {
[10:19:23.675]                   {
[10:19:23.675]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:23.675]                     NULL
[10:19:23.675]                   }
[10:19:23.675]                   options(future.plan = NULL)
[10:19:23.675]                   if (is.na(NA_character_)) 
[10:19:23.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:23.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:23.675]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:23.675]                     .init = FALSE)
[10:19:23.675]                 }
[10:19:23.675]             }
[10:19:23.675]         }
[10:19:23.675]     })
[10:19:23.675]     if (TRUE) {
[10:19:23.675]         base::sink(type = "output", split = FALSE)
[10:19:23.675]         if (TRUE) {
[10:19:23.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:23.675]         }
[10:19:23.675]         else {
[10:19:23.675]             ...future.result["stdout"] <- base::list(NULL)
[10:19:23.675]         }
[10:19:23.675]         base::close(...future.stdout)
[10:19:23.675]         ...future.stdout <- NULL
[10:19:23.675]     }
[10:19:23.675]     ...future.result$conditions <- ...future.conditions
[10:19:23.675]     ...future.result$finished <- base::Sys.time()
[10:19:23.675]     ...future.result
[10:19:23.675] }
[10:19:23.679] assign_globals() ...
[10:19:23.679] List of 5
[10:19:23.679]  $ ...future.FUN            :function (x)  
[10:19:23.679]  $ MoreArgs                 : NULL
[10:19:23.679]  $ ...future.elements_ii    :List of 1
[10:19:23.679]   ..$ :List of 1
[10:19:23.679]   .. ..$ b: num 0
[10:19:23.679]  $ ...future.seeds_ii       : NULL
[10:19:23.679]  $ ...future.globals.maxSize: NULL
[10:19:23.679]  - attr(*, "where")=List of 5
[10:19:23.679]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:19:23.679]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:19:23.679]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:19:23.679]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:19:23.679]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:19:23.679]  - attr(*, "resolved")= logi FALSE
[10:19:23.679]  - attr(*, "total_size")= num 363
[10:19:23.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:23.679]  - attr(*, "already-done")= logi TRUE
[10:19:23.687] - copied ‘...future.FUN’ to environment
[10:19:23.687] - copied ‘MoreArgs’ to environment
[10:19:23.687] - copied ‘...future.elements_ii’ to environment
[10:19:23.687] - copied ‘...future.seeds_ii’ to environment
[10:19:23.687] - copied ‘...future.globals.maxSize’ to environment
[10:19:23.688] assign_globals() ... done
[10:19:23.688] requestCore(): workers = 2
[10:19:23.690] MulticoreFuture started
[10:19:23.691] - Launch lazy future ... done
[10:19:23.691] run() for ‘MulticoreFuture’ ... done
[10:19:23.691] Created future:
[10:19:23.691] plan(): Setting new future strategy stack:
[10:19:23.691] List of future strategies:
[10:19:23.691] 1. sequential:
[10:19:23.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.691]    - tweaked: FALSE
[10:19:23.691]    - call: NULL
[10:19:23.693] plan(): nbrOfWorkers() = 1
[10:19:23.695] plan(): Setting new future strategy stack:
[10:19:23.695] List of future strategies:
[10:19:23.695] 1. multicore:
[10:19:23.695]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:19:23.695]    - tweaked: FALSE
[10:19:23.695]    - call: plan(strategy)
[10:19:23.698] plan(): nbrOfWorkers() = 2
[10:19:23.691] MulticoreFuture:
[10:19:23.691] Label: ‘future_mapply-2’
[10:19:23.691] Expression:
[10:19:23.691] {
[10:19:23.691]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:23.691]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:23.691]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:23.691]         on.exit(options(oopts), add = TRUE)
[10:19:23.691]     }
[10:19:23.691]     {
[10:19:23.691]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:23.691]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:23.691]         do.call(mapply, args = args)
[10:19:23.691]     }
[10:19:23.691] }
[10:19:23.691] Lazy evaluation: FALSE
[10:19:23.691] Asynchronous evaluation: TRUE
[10:19:23.691] Local evaluation: TRUE
[10:19:23.691] Environment: R_GlobalEnv
[10:19:23.691] Capture standard output: TRUE
[10:19:23.691] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:23.691] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:23.691] Packages: <none>
[10:19:23.691] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:23.691] Resolved: TRUE
[10:19:23.691] Value: <not collected>
[10:19:23.691] Conditions captured: <none>
[10:19:23.691] Early signaling: FALSE
[10:19:23.691] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:23.691] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:23.699] Chunk #2 of 2 ... DONE
[10:19:23.699] Launching 2 futures (chunks) ... DONE
[10:19:23.699] Resolving 2 futures (chunks) ...
[10:19:23.700] resolve() on list ...
[10:19:23.700]  recursive: 0
[10:19:23.700]  length: 2
[10:19:23.700] 
[10:19:23.700] Future #1
[10:19:23.701] result() for MulticoreFuture ...
[10:19:23.701] result() for MulticoreFuture ...
[10:19:23.702] result() for MulticoreFuture ... done
[10:19:23.702] result() for MulticoreFuture ... done
[10:19:23.702] result() for MulticoreFuture ...
[10:19:23.702] result() for MulticoreFuture ... done
[10:19:23.702] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:19:23.702] - nx: 2
[10:19:23.703] - relay: TRUE
[10:19:23.703] - stdout: TRUE
[10:19:23.703] - signal: TRUE
[10:19:23.703] - resignal: FALSE
[10:19:23.703] - force: TRUE
[10:19:23.703] - relayed: [n=2] FALSE, FALSE
[10:19:23.703] - queued futures: [n=2] FALSE, FALSE
[10:19:23.703]  - until=1
[10:19:23.704]  - relaying element #1
[10:19:23.704] result() for MulticoreFuture ...
[10:19:23.704] result() for MulticoreFuture ... done
[10:19:23.704] result() for MulticoreFuture ...
[10:19:23.704] result() for MulticoreFuture ... done
[10:19:23.704] result() for MulticoreFuture ...
[10:19:23.705] result() for MulticoreFuture ... done
[10:19:23.705] result() for MulticoreFuture ...
[10:19:23.705] result() for MulticoreFuture ... done
[10:19:23.705] - relayed: [n=2] TRUE, FALSE
[10:19:23.705] - queued futures: [n=2] TRUE, FALSE
[10:19:23.705] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:19:23.706]  length: 1 (resolved future 1)
[10:19:23.706] Future #2
[10:19:23.706] result() for MulticoreFuture ...
[10:19:23.707] result() for MulticoreFuture ...
[10:19:23.707] result() for MulticoreFuture ... done
[10:19:23.707] result() for MulticoreFuture ... done
[10:19:23.707] result() for MulticoreFuture ...
[10:19:23.707] result() for MulticoreFuture ... done
[10:19:23.707] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:19:23.707] - nx: 2
[10:19:23.708] - relay: TRUE
[10:19:23.708] - stdout: TRUE
[10:19:23.708] - signal: TRUE
[10:19:23.708] - resignal: FALSE
[10:19:23.708] - force: TRUE
[10:19:23.708] - relayed: [n=2] TRUE, FALSE
[10:19:23.708] - queued futures: [n=2] TRUE, FALSE
[10:19:23.708]  - until=2
[10:19:23.708]  - relaying element #2
[10:19:23.709] result() for MulticoreFuture ...
[10:19:23.709] result() for MulticoreFuture ... done
[10:19:23.709] result() for MulticoreFuture ...
[10:19:23.709] result() for MulticoreFuture ... done
[10:19:23.709] result() for MulticoreFuture ...
[10:19:23.709] result() for MulticoreFuture ... done
[10:19:23.709] result() for MulticoreFuture ...
[10:19:23.709] result() for MulticoreFuture ... done
[10:19:23.710] - relayed: [n=2] TRUE, TRUE
[10:19:23.710] - queued futures: [n=2] TRUE, TRUE
[10:19:23.710] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:19:23.710]  length: 0 (resolved future 2)
[10:19:23.710] Relaying remaining futures
[10:19:23.710] signalConditionsASAP(NULL, pos=0) ...
[10:19:23.710] - nx: 2
[10:19:23.710] - relay: TRUE
[10:19:23.710] - stdout: TRUE
[10:19:23.711] - signal: TRUE
[10:19:23.711] - resignal: FALSE
[10:19:23.711] - force: TRUE
[10:19:23.711] - relayed: [n=2] TRUE, TRUE
[10:19:23.711] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:23.711] - relayed: [n=2] TRUE, TRUE
[10:19:23.711] - queued futures: [n=2] TRUE, TRUE
[10:19:23.711] signalConditionsASAP(NULL, pos=0) ... done
[10:19:23.711] resolve() on list ... DONE
[10:19:23.711] result() for MulticoreFuture ...
[10:19:23.712] result() for MulticoreFuture ... done
[10:19:23.712] result() for MulticoreFuture ...
[10:19:23.712] result() for MulticoreFuture ... done
[10:19:23.712] result() for MulticoreFuture ...
[10:19:23.712] result() for MulticoreFuture ... done
[10:19:23.712] result() for MulticoreFuture ...
[10:19:23.712] result() for MulticoreFuture ... done
[10:19:23.712]  - Number of value chunks collected: 2
[10:19:23.712] Resolving 2 futures (chunks) ... DONE
[10:19:23.713] Reducing values from 2 chunks ...
[10:19:23.713]  - Number of values collected after concatenation: 2
[10:19:23.713]  - Number of values expected: 2
[10:19:23.713] Reducing values from 2 chunks ... DONE
[10:19:23.713] future_mapply() ... DONE
[10:19:23.713] plan(): Setting new future strategy stack:
[10:19:23.713] List of future strategies:
[10:19:23.713] 1. sequential:
[10:19:23.713]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:23.713]    - tweaked: FALSE
[10:19:23.713]    - call: plan(sequential)
[10:19:23.714] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:19:23.714] plan(): Setting new future strategy stack:
[10:19:23.715] List of future strategies:
[10:19:23.715] 1. multisession:
[10:19:23.715]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:19:23.715]    - tweaked: FALSE
[10:19:23.715]    - call: plan(strategy)
[10:19:23.715] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:19:23.715] multisession:
[10:19:23.715] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:19:23.715] - tweaked: FALSE
[10:19:23.715] - call: plan(strategy)
[10:19:23.720] getGlobalsAndPackages() ...
[10:19:23.720] Not searching for globals
[10:19:23.720] - globals: [0] <none>
[10:19:23.720] getGlobalsAndPackages() ... DONE
[10:19:24.209] Packages needed by the future expression (n = 0): <none>
[10:19:24.209] Packages needed by future strategies (n = 0): <none>
[10:19:24.210] {
[10:19:24.210]     {
[10:19:24.210]         {
[10:19:24.210]             ...future.startTime <- base::Sys.time()
[10:19:24.210]             {
[10:19:24.210]                 {
[10:19:24.210]                   {
[10:19:24.210]                     {
[10:19:24.210]                       base::local({
[10:19:24.210]                         has_future <- base::requireNamespace("future", 
[10:19:24.210]                           quietly = TRUE)
[10:19:24.210]                         if (has_future) {
[10:19:24.210]                           ns <- base::getNamespace("future")
[10:19:24.210]                           version <- ns[[".package"]][["version"]]
[10:19:24.210]                           if (is.null(version)) 
[10:19:24.210]                             version <- utils::packageVersion("future")
[10:19:24.210]                         }
[10:19:24.210]                         else {
[10:19:24.210]                           version <- NULL
[10:19:24.210]                         }
[10:19:24.210]                         if (!has_future || version < "1.8.0") {
[10:19:24.210]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.210]                             "", base::R.version$version.string), 
[10:19:24.210]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.210]                               "release", "version")], collapse = " "), 
[10:19:24.210]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.210]                             info)
[10:19:24.210]                           info <- base::paste(info, collapse = "; ")
[10:19:24.210]                           if (!has_future) {
[10:19:24.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.210]                               info)
[10:19:24.210]                           }
[10:19:24.210]                           else {
[10:19:24.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.210]                               info, version)
[10:19:24.210]                           }
[10:19:24.210]                           base::stop(msg)
[10:19:24.210]                         }
[10:19:24.210]                       })
[10:19:24.210]                     }
[10:19:24.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.210]                     base::options(mc.cores = 1L)
[10:19:24.210]                   }
[10:19:24.210]                   ...future.strategy.old <- future::plan("list")
[10:19:24.210]                   options(future.plan = NULL)
[10:19:24.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.210]                 }
[10:19:24.210]                 ...future.workdir <- getwd()
[10:19:24.210]             }
[10:19:24.210]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.210]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.210]         }
[10:19:24.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:24.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.210]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.210]             base::names(...future.oldOptions))
[10:19:24.210]     }
[10:19:24.210]     if (FALSE) {
[10:19:24.210]     }
[10:19:24.210]     else {
[10:19:24.210]         if (TRUE) {
[10:19:24.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.210]                 open = "w")
[10:19:24.210]         }
[10:19:24.210]         else {
[10:19:24.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.210]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.210]         }
[10:19:24.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.210]             base::sink(type = "output", split = FALSE)
[10:19:24.210]             base::close(...future.stdout)
[10:19:24.210]         }, add = TRUE)
[10:19:24.210]     }
[10:19:24.210]     ...future.frame <- base::sys.nframe()
[10:19:24.210]     ...future.conditions <- base::list()
[10:19:24.210]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.210]     if (FALSE) {
[10:19:24.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.210]     }
[10:19:24.210]     ...future.result <- base::tryCatch({
[10:19:24.210]         base::withCallingHandlers({
[10:19:24.210]             ...future.value <- base::withVisible(base::local({
[10:19:24.210]                 ...future.makeSendCondition <- base::local({
[10:19:24.210]                   sendCondition <- NULL
[10:19:24.210]                   function(frame = 1L) {
[10:19:24.210]                     if (is.function(sendCondition)) 
[10:19:24.210]                       return(sendCondition)
[10:19:24.210]                     ns <- getNamespace("parallel")
[10:19:24.210]                     if (exists("sendData", mode = "function", 
[10:19:24.210]                       envir = ns)) {
[10:19:24.210]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.210]                         envir = ns)
[10:19:24.210]                       envir <- sys.frame(frame)
[10:19:24.210]                       master <- NULL
[10:19:24.210]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.210]                         !identical(envir, emptyenv())) {
[10:19:24.210]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.210]                           inherits = FALSE)) {
[10:19:24.210]                           master <- get("master", mode = "list", 
[10:19:24.210]                             envir = envir, inherits = FALSE)
[10:19:24.210]                           if (inherits(master, c("SOCKnode", 
[10:19:24.210]                             "SOCK0node"))) {
[10:19:24.210]                             sendCondition <<- function(cond) {
[10:19:24.210]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.210]                                 success = TRUE)
[10:19:24.210]                               parallel_sendData(master, data)
[10:19:24.210]                             }
[10:19:24.210]                             return(sendCondition)
[10:19:24.210]                           }
[10:19:24.210]                         }
[10:19:24.210]                         frame <- frame + 1L
[10:19:24.210]                         envir <- sys.frame(frame)
[10:19:24.210]                       }
[10:19:24.210]                     }
[10:19:24.210]                     sendCondition <<- function(cond) NULL
[10:19:24.210]                   }
[10:19:24.210]                 })
[10:19:24.210]                 withCallingHandlers({
[10:19:24.210]                   NA
[10:19:24.210]                 }, immediateCondition = function(cond) {
[10:19:24.210]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.210]                   sendCondition(cond)
[10:19:24.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.210]                   {
[10:19:24.210]                     inherits <- base::inherits
[10:19:24.210]                     invokeRestart <- base::invokeRestart
[10:19:24.210]                     is.null <- base::is.null
[10:19:24.210]                     muffled <- FALSE
[10:19:24.210]                     if (inherits(cond, "message")) {
[10:19:24.210]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.210]                       if (muffled) 
[10:19:24.210]                         invokeRestart("muffleMessage")
[10:19:24.210]                     }
[10:19:24.210]                     else if (inherits(cond, "warning")) {
[10:19:24.210]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.210]                       if (muffled) 
[10:19:24.210]                         invokeRestart("muffleWarning")
[10:19:24.210]                     }
[10:19:24.210]                     else if (inherits(cond, "condition")) {
[10:19:24.210]                       if (!is.null(pattern)) {
[10:19:24.210]                         computeRestarts <- base::computeRestarts
[10:19:24.210]                         grepl <- base::grepl
[10:19:24.210]                         restarts <- computeRestarts(cond)
[10:19:24.210]                         for (restart in restarts) {
[10:19:24.210]                           name <- restart$name
[10:19:24.210]                           if (is.null(name)) 
[10:19:24.210]                             next
[10:19:24.210]                           if (!grepl(pattern, name)) 
[10:19:24.210]                             next
[10:19:24.210]                           invokeRestart(restart)
[10:19:24.210]                           muffled <- TRUE
[10:19:24.210]                           break
[10:19:24.210]                         }
[10:19:24.210]                       }
[10:19:24.210]                     }
[10:19:24.210]                     invisible(muffled)
[10:19:24.210]                   }
[10:19:24.210]                   muffleCondition(cond)
[10:19:24.210]                 })
[10:19:24.210]             }))
[10:19:24.210]             future::FutureResult(value = ...future.value$value, 
[10:19:24.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.210]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.210]                     ...future.globalenv.names))
[10:19:24.210]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.210]         }, condition = base::local({
[10:19:24.210]             c <- base::c
[10:19:24.210]             inherits <- base::inherits
[10:19:24.210]             invokeRestart <- base::invokeRestart
[10:19:24.210]             length <- base::length
[10:19:24.210]             list <- base::list
[10:19:24.210]             seq.int <- base::seq.int
[10:19:24.210]             signalCondition <- base::signalCondition
[10:19:24.210]             sys.calls <- base::sys.calls
[10:19:24.210]             `[[` <- base::`[[`
[10:19:24.210]             `+` <- base::`+`
[10:19:24.210]             `<<-` <- base::`<<-`
[10:19:24.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.210]                   3L)]
[10:19:24.210]             }
[10:19:24.210]             function(cond) {
[10:19:24.210]                 is_error <- inherits(cond, "error")
[10:19:24.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.210]                   NULL)
[10:19:24.210]                 if (is_error) {
[10:19:24.210]                   sessionInformation <- function() {
[10:19:24.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.210]                       search = base::search(), system = base::Sys.info())
[10:19:24.210]                   }
[10:19:24.210]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.210]                     cond$call), session = sessionInformation(), 
[10:19:24.210]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.210]                   signalCondition(cond)
[10:19:24.210]                 }
[10:19:24.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.210]                 "immediateCondition"))) {
[10:19:24.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.210]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.210]                   if (TRUE && !signal) {
[10:19:24.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.210]                     {
[10:19:24.210]                       inherits <- base::inherits
[10:19:24.210]                       invokeRestart <- base::invokeRestart
[10:19:24.210]                       is.null <- base::is.null
[10:19:24.210]                       muffled <- FALSE
[10:19:24.210]                       if (inherits(cond, "message")) {
[10:19:24.210]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.210]                         if (muffled) 
[10:19:24.210]                           invokeRestart("muffleMessage")
[10:19:24.210]                       }
[10:19:24.210]                       else if (inherits(cond, "warning")) {
[10:19:24.210]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.210]                         if (muffled) 
[10:19:24.210]                           invokeRestart("muffleWarning")
[10:19:24.210]                       }
[10:19:24.210]                       else if (inherits(cond, "condition")) {
[10:19:24.210]                         if (!is.null(pattern)) {
[10:19:24.210]                           computeRestarts <- base::computeRestarts
[10:19:24.210]                           grepl <- base::grepl
[10:19:24.210]                           restarts <- computeRestarts(cond)
[10:19:24.210]                           for (restart in restarts) {
[10:19:24.210]                             name <- restart$name
[10:19:24.210]                             if (is.null(name)) 
[10:19:24.210]                               next
[10:19:24.210]                             if (!grepl(pattern, name)) 
[10:19:24.210]                               next
[10:19:24.210]                             invokeRestart(restart)
[10:19:24.210]                             muffled <- TRUE
[10:19:24.210]                             break
[10:19:24.210]                           }
[10:19:24.210]                         }
[10:19:24.210]                       }
[10:19:24.210]                       invisible(muffled)
[10:19:24.210]                     }
[10:19:24.210]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.210]                   }
[10:19:24.210]                 }
[10:19:24.210]                 else {
[10:19:24.210]                   if (TRUE) {
[10:19:24.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.210]                     {
[10:19:24.210]                       inherits <- base::inherits
[10:19:24.210]                       invokeRestart <- base::invokeRestart
[10:19:24.210]                       is.null <- base::is.null
[10:19:24.210]                       muffled <- FALSE
[10:19:24.210]                       if (inherits(cond, "message")) {
[10:19:24.210]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.210]                         if (muffled) 
[10:19:24.210]                           invokeRestart("muffleMessage")
[10:19:24.210]                       }
[10:19:24.210]                       else if (inherits(cond, "warning")) {
[10:19:24.210]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.210]                         if (muffled) 
[10:19:24.210]                           invokeRestart("muffleWarning")
[10:19:24.210]                       }
[10:19:24.210]                       else if (inherits(cond, "condition")) {
[10:19:24.210]                         if (!is.null(pattern)) {
[10:19:24.210]                           computeRestarts <- base::computeRestarts
[10:19:24.210]                           grepl <- base::grepl
[10:19:24.210]                           restarts <- computeRestarts(cond)
[10:19:24.210]                           for (restart in restarts) {
[10:19:24.210]                             name <- restart$name
[10:19:24.210]                             if (is.null(name)) 
[10:19:24.210]                               next
[10:19:24.210]                             if (!grepl(pattern, name)) 
[10:19:24.210]                               next
[10:19:24.210]                             invokeRestart(restart)
[10:19:24.210]                             muffled <- TRUE
[10:19:24.210]                             break
[10:19:24.210]                           }
[10:19:24.210]                         }
[10:19:24.210]                       }
[10:19:24.210]                       invisible(muffled)
[10:19:24.210]                     }
[10:19:24.210]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.210]                   }
[10:19:24.210]                 }
[10:19:24.210]             }
[10:19:24.210]         }))
[10:19:24.210]     }, error = function(ex) {
[10:19:24.210]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.210]                 ...future.rng), started = ...future.startTime, 
[10:19:24.210]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.210]             version = "1.8"), class = "FutureResult")
[10:19:24.210]     }, finally = {
[10:19:24.210]         if (!identical(...future.workdir, getwd())) 
[10:19:24.210]             setwd(...future.workdir)
[10:19:24.210]         {
[10:19:24.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.210]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.210]             }
[10:19:24.210]             base::options(...future.oldOptions)
[10:19:24.210]             if (.Platform$OS.type == "windows") {
[10:19:24.210]                 old_names <- names(...future.oldEnvVars)
[10:19:24.210]                 envs <- base::Sys.getenv()
[10:19:24.210]                 names <- names(envs)
[10:19:24.210]                 common <- intersect(names, old_names)
[10:19:24.210]                 added <- setdiff(names, old_names)
[10:19:24.210]                 removed <- setdiff(old_names, names)
[10:19:24.210]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.210]                   envs[common]]
[10:19:24.210]                 NAMES <- toupper(changed)
[10:19:24.210]                 args <- list()
[10:19:24.210]                 for (kk in seq_along(NAMES)) {
[10:19:24.210]                   name <- changed[[kk]]
[10:19:24.210]                   NAME <- NAMES[[kk]]
[10:19:24.210]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.210]                     next
[10:19:24.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.210]                 }
[10:19:24.210]                 NAMES <- toupper(added)
[10:19:24.210]                 for (kk in seq_along(NAMES)) {
[10:19:24.210]                   name <- added[[kk]]
[10:19:24.210]                   NAME <- NAMES[[kk]]
[10:19:24.210]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.210]                     next
[10:19:24.210]                   args[[name]] <- ""
[10:19:24.210]                 }
[10:19:24.210]                 NAMES <- toupper(removed)
[10:19:24.210]                 for (kk in seq_along(NAMES)) {
[10:19:24.210]                   name <- removed[[kk]]
[10:19:24.210]                   NAME <- NAMES[[kk]]
[10:19:24.210]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.210]                     next
[10:19:24.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.210]                 }
[10:19:24.210]                 if (length(args) > 0) 
[10:19:24.210]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.210]             }
[10:19:24.210]             else {
[10:19:24.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.210]             }
[10:19:24.210]             {
[10:19:24.210]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.210]                   0L) {
[10:19:24.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.210]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.210]                   base::options(opts)
[10:19:24.210]                 }
[10:19:24.210]                 {
[10:19:24.210]                   {
[10:19:24.210]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.210]                     NULL
[10:19:24.210]                   }
[10:19:24.210]                   options(future.plan = NULL)
[10:19:24.210]                   if (is.na(NA_character_)) 
[10:19:24.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.210]                     .init = FALSE)
[10:19:24.210]                 }
[10:19:24.210]             }
[10:19:24.210]         }
[10:19:24.210]     })
[10:19:24.210]     if (TRUE) {
[10:19:24.210]         base::sink(type = "output", split = FALSE)
[10:19:24.210]         if (TRUE) {
[10:19:24.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.210]         }
[10:19:24.210]         else {
[10:19:24.210]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.210]         }
[10:19:24.210]         base::close(...future.stdout)
[10:19:24.210]         ...future.stdout <- NULL
[10:19:24.210]     }
[10:19:24.210]     ...future.result$conditions <- ...future.conditions
[10:19:24.210]     ...future.result$finished <- base::Sys.time()
[10:19:24.210]     ...future.result
[10:19:24.210] }
[10:19:24.263] MultisessionFuture started
[10:19:24.263] result() for ClusterFuture ...
[10:19:24.263] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.264] - Validating connection of MultisessionFuture
[10:19:24.294] - received message: FutureResult
[10:19:24.294] - Received FutureResult
[10:19:24.295] - Erased future from FutureRegistry
[10:19:24.295] result() for ClusterFuture ...
[10:19:24.295] - result already collected: FutureResult
[10:19:24.295] result() for ClusterFuture ... done
[10:19:24.295] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.295] result() for ClusterFuture ... done
[10:19:24.295] result() for ClusterFuture ...
[10:19:24.295] - result already collected: FutureResult
[10:19:24.295] result() for ClusterFuture ... done
[10:19:24.295] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:19:24.297] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[10:19:24.297] future_mapply() ...
[10:19:24.299] Number of chunks: 2
[10:19:24.299] getGlobalsAndPackagesXApply() ...
[10:19:24.299]  - future.globals: TRUE
[10:19:24.299] getGlobalsAndPackages() ...
[10:19:24.299] Searching for globals...
[10:19:24.300] - globals found: [1] ‘FUN’
[10:19:24.300] Searching for globals ... DONE
[10:19:24.300] Resolving globals: FALSE
[10:19:24.300] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:24.301] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:24.301] - globals: [1] ‘FUN’
[10:19:24.301] 
[10:19:24.301] getGlobalsAndPackages() ... DONE
[10:19:24.301]  - globals found/used: [n=1] ‘FUN’
[10:19:24.301]  - needed namespaces: [n=0] 
[10:19:24.301] Finding globals ... DONE
[10:19:24.301] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:24.301] List of 2
[10:19:24.301]  $ ...future.FUN:function (x, ...)  
[10:19:24.301]  $ MoreArgs     : NULL
[10:19:24.301]  - attr(*, "where")=List of 2
[10:19:24.301]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:24.301]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:24.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:24.301]  - attr(*, "resolved")= logi FALSE
[10:19:24.301]  - attr(*, "total_size")= num NA
[10:19:24.304] Packages to be attached in all futures: [n=0] 
[10:19:24.304] getGlobalsAndPackagesXApply() ... DONE
[10:19:24.304] Number of futures (= number of chunks): 2
[10:19:24.304] Launching 2 futures (chunks) ...
[10:19:24.304] Chunk #1 of 2 ...
[10:19:24.304]  - Finding globals in '...' for chunk #1 ...
[10:19:24.304] getGlobalsAndPackages() ...
[10:19:24.305] Searching for globals...
[10:19:24.305] 
[10:19:24.305] Searching for globals ... DONE
[10:19:24.305] - globals: [0] <none>
[10:19:24.305] getGlobalsAndPackages() ... DONE
[10:19:24.305]    + additional globals found: [n=0] 
[10:19:24.305]    + additional namespaces needed: [n=0] 
[10:19:24.305]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:24.305]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:24.305]  - seeds: <none>
[10:19:24.306]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.306] getGlobalsAndPackages() ...
[10:19:24.306] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.306] Resolving globals: FALSE
[10:19:24.306] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:24.307] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:24.307] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.307] 
[10:19:24.307] getGlobalsAndPackages() ... DONE
[10:19:24.307] run() for ‘Future’ ...
[10:19:24.307] - state: ‘created’
[10:19:24.307] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:24.322] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.322] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:24.322]   - Field: ‘node’
[10:19:24.322]   - Field: ‘label’
[10:19:24.322]   - Field: ‘local’
[10:19:24.323]   - Field: ‘owner’
[10:19:24.323]   - Field: ‘envir’
[10:19:24.323]   - Field: ‘workers’
[10:19:24.323]   - Field: ‘packages’
[10:19:24.323]   - Field: ‘gc’
[10:19:24.323]   - Field: ‘conditions’
[10:19:24.323]   - Field: ‘persistent’
[10:19:24.323]   - Field: ‘expr’
[10:19:24.323]   - Field: ‘uuid’
[10:19:24.323]   - Field: ‘seed’
[10:19:24.323]   - Field: ‘version’
[10:19:24.323]   - Field: ‘result’
[10:19:24.324]   - Field: ‘asynchronous’
[10:19:24.324]   - Field: ‘calls’
[10:19:24.324]   - Field: ‘globals’
[10:19:24.324]   - Field: ‘stdout’
[10:19:24.324]   - Field: ‘earlySignal’
[10:19:24.324]   - Field: ‘lazy’
[10:19:24.324]   - Field: ‘state’
[10:19:24.324] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:24.324] - Launch lazy future ...
[10:19:24.324] Packages needed by the future expression (n = 0): <none>
[10:19:24.325] Packages needed by future strategies (n = 0): <none>
[10:19:24.325] {
[10:19:24.325]     {
[10:19:24.325]         {
[10:19:24.325]             ...future.startTime <- base::Sys.time()
[10:19:24.325]             {
[10:19:24.325]                 {
[10:19:24.325]                   {
[10:19:24.325]                     {
[10:19:24.325]                       base::local({
[10:19:24.325]                         has_future <- base::requireNamespace("future", 
[10:19:24.325]                           quietly = TRUE)
[10:19:24.325]                         if (has_future) {
[10:19:24.325]                           ns <- base::getNamespace("future")
[10:19:24.325]                           version <- ns[[".package"]][["version"]]
[10:19:24.325]                           if (is.null(version)) 
[10:19:24.325]                             version <- utils::packageVersion("future")
[10:19:24.325]                         }
[10:19:24.325]                         else {
[10:19:24.325]                           version <- NULL
[10:19:24.325]                         }
[10:19:24.325]                         if (!has_future || version < "1.8.0") {
[10:19:24.325]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.325]                             "", base::R.version$version.string), 
[10:19:24.325]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.325]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.325]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.325]                               "release", "version")], collapse = " "), 
[10:19:24.325]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.325]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.325]                             info)
[10:19:24.325]                           info <- base::paste(info, collapse = "; ")
[10:19:24.325]                           if (!has_future) {
[10:19:24.325]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.325]                               info)
[10:19:24.325]                           }
[10:19:24.325]                           else {
[10:19:24.325]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.325]                               info, version)
[10:19:24.325]                           }
[10:19:24.325]                           base::stop(msg)
[10:19:24.325]                         }
[10:19:24.325]                       })
[10:19:24.325]                     }
[10:19:24.325]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.325]                     base::options(mc.cores = 1L)
[10:19:24.325]                   }
[10:19:24.325]                   ...future.strategy.old <- future::plan("list")
[10:19:24.325]                   options(future.plan = NULL)
[10:19:24.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.325]                 }
[10:19:24.325]                 ...future.workdir <- getwd()
[10:19:24.325]             }
[10:19:24.325]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.325]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.325]         }
[10:19:24.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.325]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:24.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.325]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.325]             base::names(...future.oldOptions))
[10:19:24.325]     }
[10:19:24.325]     if (FALSE) {
[10:19:24.325]     }
[10:19:24.325]     else {
[10:19:24.325]         if (TRUE) {
[10:19:24.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.325]                 open = "w")
[10:19:24.325]         }
[10:19:24.325]         else {
[10:19:24.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.325]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.325]         }
[10:19:24.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.325]             base::sink(type = "output", split = FALSE)
[10:19:24.325]             base::close(...future.stdout)
[10:19:24.325]         }, add = TRUE)
[10:19:24.325]     }
[10:19:24.325]     ...future.frame <- base::sys.nframe()
[10:19:24.325]     ...future.conditions <- base::list()
[10:19:24.325]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.325]     if (FALSE) {
[10:19:24.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.325]     }
[10:19:24.325]     ...future.result <- base::tryCatch({
[10:19:24.325]         base::withCallingHandlers({
[10:19:24.325]             ...future.value <- base::withVisible(base::local({
[10:19:24.325]                 ...future.makeSendCondition <- base::local({
[10:19:24.325]                   sendCondition <- NULL
[10:19:24.325]                   function(frame = 1L) {
[10:19:24.325]                     if (is.function(sendCondition)) 
[10:19:24.325]                       return(sendCondition)
[10:19:24.325]                     ns <- getNamespace("parallel")
[10:19:24.325]                     if (exists("sendData", mode = "function", 
[10:19:24.325]                       envir = ns)) {
[10:19:24.325]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.325]                         envir = ns)
[10:19:24.325]                       envir <- sys.frame(frame)
[10:19:24.325]                       master <- NULL
[10:19:24.325]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.325]                         !identical(envir, emptyenv())) {
[10:19:24.325]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.325]                           inherits = FALSE)) {
[10:19:24.325]                           master <- get("master", mode = "list", 
[10:19:24.325]                             envir = envir, inherits = FALSE)
[10:19:24.325]                           if (inherits(master, c("SOCKnode", 
[10:19:24.325]                             "SOCK0node"))) {
[10:19:24.325]                             sendCondition <<- function(cond) {
[10:19:24.325]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.325]                                 success = TRUE)
[10:19:24.325]                               parallel_sendData(master, data)
[10:19:24.325]                             }
[10:19:24.325]                             return(sendCondition)
[10:19:24.325]                           }
[10:19:24.325]                         }
[10:19:24.325]                         frame <- frame + 1L
[10:19:24.325]                         envir <- sys.frame(frame)
[10:19:24.325]                       }
[10:19:24.325]                     }
[10:19:24.325]                     sendCondition <<- function(cond) NULL
[10:19:24.325]                   }
[10:19:24.325]                 })
[10:19:24.325]                 withCallingHandlers({
[10:19:24.325]                   {
[10:19:24.325]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.325]                     if (!identical(...future.globals.maxSize.org, 
[10:19:24.325]                       ...future.globals.maxSize)) {
[10:19:24.325]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.325]                       on.exit(options(oopts), add = TRUE)
[10:19:24.325]                     }
[10:19:24.325]                     {
[10:19:24.325]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.325]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:24.325]                         USE.NAMES = FALSE)
[10:19:24.325]                       do.call(mapply, args = args)
[10:19:24.325]                     }
[10:19:24.325]                   }
[10:19:24.325]                 }, immediateCondition = function(cond) {
[10:19:24.325]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.325]                   sendCondition(cond)
[10:19:24.325]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.325]                   {
[10:19:24.325]                     inherits <- base::inherits
[10:19:24.325]                     invokeRestart <- base::invokeRestart
[10:19:24.325]                     is.null <- base::is.null
[10:19:24.325]                     muffled <- FALSE
[10:19:24.325]                     if (inherits(cond, "message")) {
[10:19:24.325]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.325]                       if (muffled) 
[10:19:24.325]                         invokeRestart("muffleMessage")
[10:19:24.325]                     }
[10:19:24.325]                     else if (inherits(cond, "warning")) {
[10:19:24.325]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.325]                       if (muffled) 
[10:19:24.325]                         invokeRestart("muffleWarning")
[10:19:24.325]                     }
[10:19:24.325]                     else if (inherits(cond, "condition")) {
[10:19:24.325]                       if (!is.null(pattern)) {
[10:19:24.325]                         computeRestarts <- base::computeRestarts
[10:19:24.325]                         grepl <- base::grepl
[10:19:24.325]                         restarts <- computeRestarts(cond)
[10:19:24.325]                         for (restart in restarts) {
[10:19:24.325]                           name <- restart$name
[10:19:24.325]                           if (is.null(name)) 
[10:19:24.325]                             next
[10:19:24.325]                           if (!grepl(pattern, name)) 
[10:19:24.325]                             next
[10:19:24.325]                           invokeRestart(restart)
[10:19:24.325]                           muffled <- TRUE
[10:19:24.325]                           break
[10:19:24.325]                         }
[10:19:24.325]                       }
[10:19:24.325]                     }
[10:19:24.325]                     invisible(muffled)
[10:19:24.325]                   }
[10:19:24.325]                   muffleCondition(cond)
[10:19:24.325]                 })
[10:19:24.325]             }))
[10:19:24.325]             future::FutureResult(value = ...future.value$value, 
[10:19:24.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.325]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.325]                     ...future.globalenv.names))
[10:19:24.325]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.325]         }, condition = base::local({
[10:19:24.325]             c <- base::c
[10:19:24.325]             inherits <- base::inherits
[10:19:24.325]             invokeRestart <- base::invokeRestart
[10:19:24.325]             length <- base::length
[10:19:24.325]             list <- base::list
[10:19:24.325]             seq.int <- base::seq.int
[10:19:24.325]             signalCondition <- base::signalCondition
[10:19:24.325]             sys.calls <- base::sys.calls
[10:19:24.325]             `[[` <- base::`[[`
[10:19:24.325]             `+` <- base::`+`
[10:19:24.325]             `<<-` <- base::`<<-`
[10:19:24.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.325]                   3L)]
[10:19:24.325]             }
[10:19:24.325]             function(cond) {
[10:19:24.325]                 is_error <- inherits(cond, "error")
[10:19:24.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.325]                   NULL)
[10:19:24.325]                 if (is_error) {
[10:19:24.325]                   sessionInformation <- function() {
[10:19:24.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.325]                       search = base::search(), system = base::Sys.info())
[10:19:24.325]                   }
[10:19:24.325]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.325]                     cond$call), session = sessionInformation(), 
[10:19:24.325]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.325]                   signalCondition(cond)
[10:19:24.325]                 }
[10:19:24.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.325]                 "immediateCondition"))) {
[10:19:24.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.325]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.325]                   if (TRUE && !signal) {
[10:19:24.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.325]                     {
[10:19:24.325]                       inherits <- base::inherits
[10:19:24.325]                       invokeRestart <- base::invokeRestart
[10:19:24.325]                       is.null <- base::is.null
[10:19:24.325]                       muffled <- FALSE
[10:19:24.325]                       if (inherits(cond, "message")) {
[10:19:24.325]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.325]                         if (muffled) 
[10:19:24.325]                           invokeRestart("muffleMessage")
[10:19:24.325]                       }
[10:19:24.325]                       else if (inherits(cond, "warning")) {
[10:19:24.325]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.325]                         if (muffled) 
[10:19:24.325]                           invokeRestart("muffleWarning")
[10:19:24.325]                       }
[10:19:24.325]                       else if (inherits(cond, "condition")) {
[10:19:24.325]                         if (!is.null(pattern)) {
[10:19:24.325]                           computeRestarts <- base::computeRestarts
[10:19:24.325]                           grepl <- base::grepl
[10:19:24.325]                           restarts <- computeRestarts(cond)
[10:19:24.325]                           for (restart in restarts) {
[10:19:24.325]                             name <- restart$name
[10:19:24.325]                             if (is.null(name)) 
[10:19:24.325]                               next
[10:19:24.325]                             if (!grepl(pattern, name)) 
[10:19:24.325]                               next
[10:19:24.325]                             invokeRestart(restart)
[10:19:24.325]                             muffled <- TRUE
[10:19:24.325]                             break
[10:19:24.325]                           }
[10:19:24.325]                         }
[10:19:24.325]                       }
[10:19:24.325]                       invisible(muffled)
[10:19:24.325]                     }
[10:19:24.325]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.325]                   }
[10:19:24.325]                 }
[10:19:24.325]                 else {
[10:19:24.325]                   if (TRUE) {
[10:19:24.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.325]                     {
[10:19:24.325]                       inherits <- base::inherits
[10:19:24.325]                       invokeRestart <- base::invokeRestart
[10:19:24.325]                       is.null <- base::is.null
[10:19:24.325]                       muffled <- FALSE
[10:19:24.325]                       if (inherits(cond, "message")) {
[10:19:24.325]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.325]                         if (muffled) 
[10:19:24.325]                           invokeRestart("muffleMessage")
[10:19:24.325]                       }
[10:19:24.325]                       else if (inherits(cond, "warning")) {
[10:19:24.325]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.325]                         if (muffled) 
[10:19:24.325]                           invokeRestart("muffleWarning")
[10:19:24.325]                       }
[10:19:24.325]                       else if (inherits(cond, "condition")) {
[10:19:24.325]                         if (!is.null(pattern)) {
[10:19:24.325]                           computeRestarts <- base::computeRestarts
[10:19:24.325]                           grepl <- base::grepl
[10:19:24.325]                           restarts <- computeRestarts(cond)
[10:19:24.325]                           for (restart in restarts) {
[10:19:24.325]                             name <- restart$name
[10:19:24.325]                             if (is.null(name)) 
[10:19:24.325]                               next
[10:19:24.325]                             if (!grepl(pattern, name)) 
[10:19:24.325]                               next
[10:19:24.325]                             invokeRestart(restart)
[10:19:24.325]                             muffled <- TRUE
[10:19:24.325]                             break
[10:19:24.325]                           }
[10:19:24.325]                         }
[10:19:24.325]                       }
[10:19:24.325]                       invisible(muffled)
[10:19:24.325]                     }
[10:19:24.325]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.325]                   }
[10:19:24.325]                 }
[10:19:24.325]             }
[10:19:24.325]         }))
[10:19:24.325]     }, error = function(ex) {
[10:19:24.325]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.325]                 ...future.rng), started = ...future.startTime, 
[10:19:24.325]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.325]             version = "1.8"), class = "FutureResult")
[10:19:24.325]     }, finally = {
[10:19:24.325]         if (!identical(...future.workdir, getwd())) 
[10:19:24.325]             setwd(...future.workdir)
[10:19:24.325]         {
[10:19:24.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.325]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.325]             }
[10:19:24.325]             base::options(...future.oldOptions)
[10:19:24.325]             if (.Platform$OS.type == "windows") {
[10:19:24.325]                 old_names <- names(...future.oldEnvVars)
[10:19:24.325]                 envs <- base::Sys.getenv()
[10:19:24.325]                 names <- names(envs)
[10:19:24.325]                 common <- intersect(names, old_names)
[10:19:24.325]                 added <- setdiff(names, old_names)
[10:19:24.325]                 removed <- setdiff(old_names, names)
[10:19:24.325]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.325]                   envs[common]]
[10:19:24.325]                 NAMES <- toupper(changed)
[10:19:24.325]                 args <- list()
[10:19:24.325]                 for (kk in seq_along(NAMES)) {
[10:19:24.325]                   name <- changed[[kk]]
[10:19:24.325]                   NAME <- NAMES[[kk]]
[10:19:24.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.325]                     next
[10:19:24.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.325]                 }
[10:19:24.325]                 NAMES <- toupper(added)
[10:19:24.325]                 for (kk in seq_along(NAMES)) {
[10:19:24.325]                   name <- added[[kk]]
[10:19:24.325]                   NAME <- NAMES[[kk]]
[10:19:24.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.325]                     next
[10:19:24.325]                   args[[name]] <- ""
[10:19:24.325]                 }
[10:19:24.325]                 NAMES <- toupper(removed)
[10:19:24.325]                 for (kk in seq_along(NAMES)) {
[10:19:24.325]                   name <- removed[[kk]]
[10:19:24.325]                   NAME <- NAMES[[kk]]
[10:19:24.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.325]                     next
[10:19:24.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.325]                 }
[10:19:24.325]                 if (length(args) > 0) 
[10:19:24.325]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.325]             }
[10:19:24.325]             else {
[10:19:24.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.325]             }
[10:19:24.325]             {
[10:19:24.325]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.325]                   0L) {
[10:19:24.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.325]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.325]                   base::options(opts)
[10:19:24.325]                 }
[10:19:24.325]                 {
[10:19:24.325]                   {
[10:19:24.325]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.325]                     NULL
[10:19:24.325]                   }
[10:19:24.325]                   options(future.plan = NULL)
[10:19:24.325]                   if (is.na(NA_character_)) 
[10:19:24.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.325]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.325]                     .init = FALSE)
[10:19:24.325]                 }
[10:19:24.325]             }
[10:19:24.325]         }
[10:19:24.325]     })
[10:19:24.325]     if (TRUE) {
[10:19:24.325]         base::sink(type = "output", split = FALSE)
[10:19:24.325]         if (TRUE) {
[10:19:24.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.325]         }
[10:19:24.325]         else {
[10:19:24.325]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.325]         }
[10:19:24.325]         base::close(...future.stdout)
[10:19:24.325]         ...future.stdout <- NULL
[10:19:24.325]     }
[10:19:24.325]     ...future.result$conditions <- ...future.conditions
[10:19:24.325]     ...future.result$finished <- base::Sys.time()
[10:19:24.325]     ...future.result
[10:19:24.325] }
[10:19:24.328] Exporting 5 global objects (673 bytes) to cluster node #1 ...
[10:19:24.328] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[10:19:24.328] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[10:19:24.328] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:24.329] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.329] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ...
[10:19:24.329] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ... DONE
[10:19:24.329] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:24.330] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.330] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:24.330] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.330] Exporting 5 global objects (673 bytes) to cluster node #1 ... DONE
[10:19:24.331] MultisessionFuture started
[10:19:24.331] - Launch lazy future ... done
[10:19:24.331] run() for ‘MultisessionFuture’ ... done
[10:19:24.331] Created future:
[10:19:24.331] MultisessionFuture:
[10:19:24.331] Label: ‘future_mapply-1’
[10:19:24.331] Expression:
[10:19:24.331] {
[10:19:24.331]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.331]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:24.331]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.331]         on.exit(options(oopts), add = TRUE)
[10:19:24.331]     }
[10:19:24.331]     {
[10:19:24.331]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.331]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:24.331]         do.call(mapply, args = args)
[10:19:24.331]     }
[10:19:24.331] }
[10:19:24.331] Lazy evaluation: FALSE
[10:19:24.331] Asynchronous evaluation: TRUE
[10:19:24.331] Local evaluation: TRUE
[10:19:24.331] Environment: R_GlobalEnv
[10:19:24.331] Capture standard output: TRUE
[10:19:24.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:24.331] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:24.331] Packages: <none>
[10:19:24.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:24.331] Resolved: FALSE
[10:19:24.331] Value: <not collected>
[10:19:24.331] Conditions captured: <none>
[10:19:24.331] Early signaling: FALSE
[10:19:24.331] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:24.331] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.343] Chunk #1 of 2 ... DONE
[10:19:24.343] Chunk #2 of 2 ...
[10:19:24.343]  - Finding globals in '...' for chunk #2 ...
[10:19:24.343] getGlobalsAndPackages() ...
[10:19:24.343] Searching for globals...
[10:19:24.344] 
[10:19:24.344] Searching for globals ... DONE
[10:19:24.344] - globals: [0] <none>
[10:19:24.344] getGlobalsAndPackages() ... DONE
[10:19:24.344]    + additional globals found: [n=0] 
[10:19:24.344]    + additional namespaces needed: [n=0] 
[10:19:24.344]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:24.344]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:24.344]  - seeds: <none>
[10:19:24.344]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.345] getGlobalsAndPackages() ...
[10:19:24.345] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.345] Resolving globals: FALSE
[10:19:24.345] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:24.346] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:24.346] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.346] 
[10:19:24.346] getGlobalsAndPackages() ... DONE
[10:19:24.346] run() for ‘Future’ ...
[10:19:24.346] - state: ‘created’
[10:19:24.346] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:24.360] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:24.360]   - Field: ‘node’
[10:19:24.360]   - Field: ‘label’
[10:19:24.360]   - Field: ‘local’
[10:19:24.361]   - Field: ‘owner’
[10:19:24.361]   - Field: ‘envir’
[10:19:24.361]   - Field: ‘workers’
[10:19:24.361]   - Field: ‘packages’
[10:19:24.361]   - Field: ‘gc’
[10:19:24.361]   - Field: ‘conditions’
[10:19:24.361]   - Field: ‘persistent’
[10:19:24.361]   - Field: ‘expr’
[10:19:24.361]   - Field: ‘uuid’
[10:19:24.361]   - Field: ‘seed’
[10:19:24.361]   - Field: ‘version’
[10:19:24.362]   - Field: ‘result’
[10:19:24.362]   - Field: ‘asynchronous’
[10:19:24.362]   - Field: ‘calls’
[10:19:24.362]   - Field: ‘globals’
[10:19:24.362]   - Field: ‘stdout’
[10:19:24.362]   - Field: ‘earlySignal’
[10:19:24.362]   - Field: ‘lazy’
[10:19:24.362]   - Field: ‘state’
[10:19:24.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:24.362] - Launch lazy future ...
[10:19:24.363] Packages needed by the future expression (n = 0): <none>
[10:19:24.363] Packages needed by future strategies (n = 0): <none>
[10:19:24.363] {
[10:19:24.363]     {
[10:19:24.363]         {
[10:19:24.363]             ...future.startTime <- base::Sys.time()
[10:19:24.363]             {
[10:19:24.363]                 {
[10:19:24.363]                   {
[10:19:24.363]                     {
[10:19:24.363]                       base::local({
[10:19:24.363]                         has_future <- base::requireNamespace("future", 
[10:19:24.363]                           quietly = TRUE)
[10:19:24.363]                         if (has_future) {
[10:19:24.363]                           ns <- base::getNamespace("future")
[10:19:24.363]                           version <- ns[[".package"]][["version"]]
[10:19:24.363]                           if (is.null(version)) 
[10:19:24.363]                             version <- utils::packageVersion("future")
[10:19:24.363]                         }
[10:19:24.363]                         else {
[10:19:24.363]                           version <- NULL
[10:19:24.363]                         }
[10:19:24.363]                         if (!has_future || version < "1.8.0") {
[10:19:24.363]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.363]                             "", base::R.version$version.string), 
[10:19:24.363]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.363]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.363]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.363]                               "release", "version")], collapse = " "), 
[10:19:24.363]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.363]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.363]                             info)
[10:19:24.363]                           info <- base::paste(info, collapse = "; ")
[10:19:24.363]                           if (!has_future) {
[10:19:24.363]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.363]                               info)
[10:19:24.363]                           }
[10:19:24.363]                           else {
[10:19:24.363]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.363]                               info, version)
[10:19:24.363]                           }
[10:19:24.363]                           base::stop(msg)
[10:19:24.363]                         }
[10:19:24.363]                       })
[10:19:24.363]                     }
[10:19:24.363]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.363]                     base::options(mc.cores = 1L)
[10:19:24.363]                   }
[10:19:24.363]                   ...future.strategy.old <- future::plan("list")
[10:19:24.363]                   options(future.plan = NULL)
[10:19:24.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.363]                 }
[10:19:24.363]                 ...future.workdir <- getwd()
[10:19:24.363]             }
[10:19:24.363]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.363]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.363]         }
[10:19:24.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.363]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:24.363]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.363]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.363]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.363]             base::names(...future.oldOptions))
[10:19:24.363]     }
[10:19:24.363]     if (FALSE) {
[10:19:24.363]     }
[10:19:24.363]     else {
[10:19:24.363]         if (TRUE) {
[10:19:24.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.363]                 open = "w")
[10:19:24.363]         }
[10:19:24.363]         else {
[10:19:24.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.363]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.363]         }
[10:19:24.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.363]             base::sink(type = "output", split = FALSE)
[10:19:24.363]             base::close(...future.stdout)
[10:19:24.363]         }, add = TRUE)
[10:19:24.363]     }
[10:19:24.363]     ...future.frame <- base::sys.nframe()
[10:19:24.363]     ...future.conditions <- base::list()
[10:19:24.363]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.363]     if (FALSE) {
[10:19:24.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.363]     }
[10:19:24.363]     ...future.result <- base::tryCatch({
[10:19:24.363]         base::withCallingHandlers({
[10:19:24.363]             ...future.value <- base::withVisible(base::local({
[10:19:24.363]                 ...future.makeSendCondition <- base::local({
[10:19:24.363]                   sendCondition <- NULL
[10:19:24.363]                   function(frame = 1L) {
[10:19:24.363]                     if (is.function(sendCondition)) 
[10:19:24.363]                       return(sendCondition)
[10:19:24.363]                     ns <- getNamespace("parallel")
[10:19:24.363]                     if (exists("sendData", mode = "function", 
[10:19:24.363]                       envir = ns)) {
[10:19:24.363]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.363]                         envir = ns)
[10:19:24.363]                       envir <- sys.frame(frame)
[10:19:24.363]                       master <- NULL
[10:19:24.363]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.363]                         !identical(envir, emptyenv())) {
[10:19:24.363]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.363]                           inherits = FALSE)) {
[10:19:24.363]                           master <- get("master", mode = "list", 
[10:19:24.363]                             envir = envir, inherits = FALSE)
[10:19:24.363]                           if (inherits(master, c("SOCKnode", 
[10:19:24.363]                             "SOCK0node"))) {
[10:19:24.363]                             sendCondition <<- function(cond) {
[10:19:24.363]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.363]                                 success = TRUE)
[10:19:24.363]                               parallel_sendData(master, data)
[10:19:24.363]                             }
[10:19:24.363]                             return(sendCondition)
[10:19:24.363]                           }
[10:19:24.363]                         }
[10:19:24.363]                         frame <- frame + 1L
[10:19:24.363]                         envir <- sys.frame(frame)
[10:19:24.363]                       }
[10:19:24.363]                     }
[10:19:24.363]                     sendCondition <<- function(cond) NULL
[10:19:24.363]                   }
[10:19:24.363]                 })
[10:19:24.363]                 withCallingHandlers({
[10:19:24.363]                   {
[10:19:24.363]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.363]                     if (!identical(...future.globals.maxSize.org, 
[10:19:24.363]                       ...future.globals.maxSize)) {
[10:19:24.363]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.363]                       on.exit(options(oopts), add = TRUE)
[10:19:24.363]                     }
[10:19:24.363]                     {
[10:19:24.363]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.363]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:24.363]                         USE.NAMES = FALSE)
[10:19:24.363]                       do.call(mapply, args = args)
[10:19:24.363]                     }
[10:19:24.363]                   }
[10:19:24.363]                 }, immediateCondition = function(cond) {
[10:19:24.363]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.363]                   sendCondition(cond)
[10:19:24.363]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.363]                   {
[10:19:24.363]                     inherits <- base::inherits
[10:19:24.363]                     invokeRestart <- base::invokeRestart
[10:19:24.363]                     is.null <- base::is.null
[10:19:24.363]                     muffled <- FALSE
[10:19:24.363]                     if (inherits(cond, "message")) {
[10:19:24.363]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.363]                       if (muffled) 
[10:19:24.363]                         invokeRestart("muffleMessage")
[10:19:24.363]                     }
[10:19:24.363]                     else if (inherits(cond, "warning")) {
[10:19:24.363]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.363]                       if (muffled) 
[10:19:24.363]                         invokeRestart("muffleWarning")
[10:19:24.363]                     }
[10:19:24.363]                     else if (inherits(cond, "condition")) {
[10:19:24.363]                       if (!is.null(pattern)) {
[10:19:24.363]                         computeRestarts <- base::computeRestarts
[10:19:24.363]                         grepl <- base::grepl
[10:19:24.363]                         restarts <- computeRestarts(cond)
[10:19:24.363]                         for (restart in restarts) {
[10:19:24.363]                           name <- restart$name
[10:19:24.363]                           if (is.null(name)) 
[10:19:24.363]                             next
[10:19:24.363]                           if (!grepl(pattern, name)) 
[10:19:24.363]                             next
[10:19:24.363]                           invokeRestart(restart)
[10:19:24.363]                           muffled <- TRUE
[10:19:24.363]                           break
[10:19:24.363]                         }
[10:19:24.363]                       }
[10:19:24.363]                     }
[10:19:24.363]                     invisible(muffled)
[10:19:24.363]                   }
[10:19:24.363]                   muffleCondition(cond)
[10:19:24.363]                 })
[10:19:24.363]             }))
[10:19:24.363]             future::FutureResult(value = ...future.value$value, 
[10:19:24.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.363]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.363]                     ...future.globalenv.names))
[10:19:24.363]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.363]         }, condition = base::local({
[10:19:24.363]             c <- base::c
[10:19:24.363]             inherits <- base::inherits
[10:19:24.363]             invokeRestart <- base::invokeRestart
[10:19:24.363]             length <- base::length
[10:19:24.363]             list <- base::list
[10:19:24.363]             seq.int <- base::seq.int
[10:19:24.363]             signalCondition <- base::signalCondition
[10:19:24.363]             sys.calls <- base::sys.calls
[10:19:24.363]             `[[` <- base::`[[`
[10:19:24.363]             `+` <- base::`+`
[10:19:24.363]             `<<-` <- base::`<<-`
[10:19:24.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.363]                   3L)]
[10:19:24.363]             }
[10:19:24.363]             function(cond) {
[10:19:24.363]                 is_error <- inherits(cond, "error")
[10:19:24.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.363]                   NULL)
[10:19:24.363]                 if (is_error) {
[10:19:24.363]                   sessionInformation <- function() {
[10:19:24.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.363]                       search = base::search(), system = base::Sys.info())
[10:19:24.363]                   }
[10:19:24.363]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.363]                     cond$call), session = sessionInformation(), 
[10:19:24.363]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.363]                   signalCondition(cond)
[10:19:24.363]                 }
[10:19:24.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.363]                 "immediateCondition"))) {
[10:19:24.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.363]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.363]                   if (TRUE && !signal) {
[10:19:24.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.363]                     {
[10:19:24.363]                       inherits <- base::inherits
[10:19:24.363]                       invokeRestart <- base::invokeRestart
[10:19:24.363]                       is.null <- base::is.null
[10:19:24.363]                       muffled <- FALSE
[10:19:24.363]                       if (inherits(cond, "message")) {
[10:19:24.363]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.363]                         if (muffled) 
[10:19:24.363]                           invokeRestart("muffleMessage")
[10:19:24.363]                       }
[10:19:24.363]                       else if (inherits(cond, "warning")) {
[10:19:24.363]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.363]                         if (muffled) 
[10:19:24.363]                           invokeRestart("muffleWarning")
[10:19:24.363]                       }
[10:19:24.363]                       else if (inherits(cond, "condition")) {
[10:19:24.363]                         if (!is.null(pattern)) {
[10:19:24.363]                           computeRestarts <- base::computeRestarts
[10:19:24.363]                           grepl <- base::grepl
[10:19:24.363]                           restarts <- computeRestarts(cond)
[10:19:24.363]                           for (restart in restarts) {
[10:19:24.363]                             name <- restart$name
[10:19:24.363]                             if (is.null(name)) 
[10:19:24.363]                               next
[10:19:24.363]                             if (!grepl(pattern, name)) 
[10:19:24.363]                               next
[10:19:24.363]                             invokeRestart(restart)
[10:19:24.363]                             muffled <- TRUE
[10:19:24.363]                             break
[10:19:24.363]                           }
[10:19:24.363]                         }
[10:19:24.363]                       }
[10:19:24.363]                       invisible(muffled)
[10:19:24.363]                     }
[10:19:24.363]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.363]                   }
[10:19:24.363]                 }
[10:19:24.363]                 else {
[10:19:24.363]                   if (TRUE) {
[10:19:24.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.363]                     {
[10:19:24.363]                       inherits <- base::inherits
[10:19:24.363]                       invokeRestart <- base::invokeRestart
[10:19:24.363]                       is.null <- base::is.null
[10:19:24.363]                       muffled <- FALSE
[10:19:24.363]                       if (inherits(cond, "message")) {
[10:19:24.363]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.363]                         if (muffled) 
[10:19:24.363]                           invokeRestart("muffleMessage")
[10:19:24.363]                       }
[10:19:24.363]                       else if (inherits(cond, "warning")) {
[10:19:24.363]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.363]                         if (muffled) 
[10:19:24.363]                           invokeRestart("muffleWarning")
[10:19:24.363]                       }
[10:19:24.363]                       else if (inherits(cond, "condition")) {
[10:19:24.363]                         if (!is.null(pattern)) {
[10:19:24.363]                           computeRestarts <- base::computeRestarts
[10:19:24.363]                           grepl <- base::grepl
[10:19:24.363]                           restarts <- computeRestarts(cond)
[10:19:24.363]                           for (restart in restarts) {
[10:19:24.363]                             name <- restart$name
[10:19:24.363]                             if (is.null(name)) 
[10:19:24.363]                               next
[10:19:24.363]                             if (!grepl(pattern, name)) 
[10:19:24.363]                               next
[10:19:24.363]                             invokeRestart(restart)
[10:19:24.363]                             muffled <- TRUE
[10:19:24.363]                             break
[10:19:24.363]                           }
[10:19:24.363]                         }
[10:19:24.363]                       }
[10:19:24.363]                       invisible(muffled)
[10:19:24.363]                     }
[10:19:24.363]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.363]                   }
[10:19:24.363]                 }
[10:19:24.363]             }
[10:19:24.363]         }))
[10:19:24.363]     }, error = function(ex) {
[10:19:24.363]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.363]                 ...future.rng), started = ...future.startTime, 
[10:19:24.363]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.363]             version = "1.8"), class = "FutureResult")
[10:19:24.363]     }, finally = {
[10:19:24.363]         if (!identical(...future.workdir, getwd())) 
[10:19:24.363]             setwd(...future.workdir)
[10:19:24.363]         {
[10:19:24.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.363]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.363]             }
[10:19:24.363]             base::options(...future.oldOptions)
[10:19:24.363]             if (.Platform$OS.type == "windows") {
[10:19:24.363]                 old_names <- names(...future.oldEnvVars)
[10:19:24.363]                 envs <- base::Sys.getenv()
[10:19:24.363]                 names <- names(envs)
[10:19:24.363]                 common <- intersect(names, old_names)
[10:19:24.363]                 added <- setdiff(names, old_names)
[10:19:24.363]                 removed <- setdiff(old_names, names)
[10:19:24.363]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.363]                   envs[common]]
[10:19:24.363]                 NAMES <- toupper(changed)
[10:19:24.363]                 args <- list()
[10:19:24.363]                 for (kk in seq_along(NAMES)) {
[10:19:24.363]                   name <- changed[[kk]]
[10:19:24.363]                   NAME <- NAMES[[kk]]
[10:19:24.363]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.363]                     next
[10:19:24.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.363]                 }
[10:19:24.363]                 NAMES <- toupper(added)
[10:19:24.363]                 for (kk in seq_along(NAMES)) {
[10:19:24.363]                   name <- added[[kk]]
[10:19:24.363]                   NAME <- NAMES[[kk]]
[10:19:24.363]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.363]                     next
[10:19:24.363]                   args[[name]] <- ""
[10:19:24.363]                 }
[10:19:24.363]                 NAMES <- toupper(removed)
[10:19:24.363]                 for (kk in seq_along(NAMES)) {
[10:19:24.363]                   name <- removed[[kk]]
[10:19:24.363]                   NAME <- NAMES[[kk]]
[10:19:24.363]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.363]                     next
[10:19:24.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.363]                 }
[10:19:24.363]                 if (length(args) > 0) 
[10:19:24.363]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.363]             }
[10:19:24.363]             else {
[10:19:24.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.363]             }
[10:19:24.363]             {
[10:19:24.363]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.363]                   0L) {
[10:19:24.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.363]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.363]                   base::options(opts)
[10:19:24.363]                 }
[10:19:24.363]                 {
[10:19:24.363]                   {
[10:19:24.363]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.363]                     NULL
[10:19:24.363]                   }
[10:19:24.363]                   options(future.plan = NULL)
[10:19:24.363]                   if (is.na(NA_character_)) 
[10:19:24.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.363]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.363]                     .init = FALSE)
[10:19:24.363]                 }
[10:19:24.363]             }
[10:19:24.363]         }
[10:19:24.363]     })
[10:19:24.363]     if (TRUE) {
[10:19:24.363]         base::sink(type = "output", split = FALSE)
[10:19:24.363]         if (TRUE) {
[10:19:24.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.363]         }
[10:19:24.363]         else {
[10:19:24.363]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.363]         }
[10:19:24.363]         base::close(...future.stdout)
[10:19:24.363]         ...future.stdout <- NULL
[10:19:24.363]     }
[10:19:24.363]     ...future.result$conditions <- ...future.conditions
[10:19:24.363]     ...future.result$finished <- base::Sys.time()
[10:19:24.363]     ...future.result
[10:19:24.363] }
[10:19:24.416] Exporting 5 global objects (673 bytes) to cluster node #2 ...
[10:19:24.416] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[10:19:24.416] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[10:19:24.417] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:24.417] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.417] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ...
[10:19:24.417] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ... DONE
[10:19:24.417] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:24.418] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.418] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:24.418] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.418] Exporting 5 global objects (673 bytes) to cluster node #2 ... DONE
[10:19:24.419] MultisessionFuture started
[10:19:24.419] - Launch lazy future ... done
[10:19:24.419] run() for ‘MultisessionFuture’ ... done
[10:19:24.419] Created future:
[10:19:24.419] MultisessionFuture:
[10:19:24.419] Label: ‘future_mapply-2’
[10:19:24.419] Expression:
[10:19:24.419] {
[10:19:24.419]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.419]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:24.419]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.419]         on.exit(options(oopts), add = TRUE)
[10:19:24.419]     }
[10:19:24.419]     {
[10:19:24.419]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.419]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:24.419]         do.call(mapply, args = args)
[10:19:24.419]     }
[10:19:24.419] }
[10:19:24.419] Lazy evaluation: FALSE
[10:19:24.419] Asynchronous evaluation: TRUE
[10:19:24.419] Local evaluation: TRUE
[10:19:24.419] Environment: R_GlobalEnv
[10:19:24.419] Capture standard output: TRUE
[10:19:24.419] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:24.419] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:24.419] Packages: <none>
[10:19:24.419] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:24.419] Resolved: FALSE
[10:19:24.419] Value: <not collected>
[10:19:24.419] Conditions captured: <none>
[10:19:24.419] Early signaling: FALSE
[10:19:24.419] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:24.419] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.431] Chunk #2 of 2 ... DONE
[10:19:24.431] Launching 2 futures (chunks) ... DONE
[10:19:24.431] Resolving 2 futures (chunks) ...
[10:19:24.431] resolve() on list ...
[10:19:24.431]  recursive: 0
[10:19:24.432]  length: 2
[10:19:24.432] 
[10:19:24.432] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.432] - Validating connection of MultisessionFuture
[10:19:24.432] - received message: FutureResult
[10:19:24.433] - Received FutureResult
[10:19:24.433] - Erased future from FutureRegistry
[10:19:24.433] result() for ClusterFuture ...
[10:19:24.433] - result already collected: FutureResult
[10:19:24.433] result() for ClusterFuture ... done
[10:19:24.433] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.433] Future #1
[10:19:24.433] result() for ClusterFuture ...
[10:19:24.433] - result already collected: FutureResult
[10:19:24.434] result() for ClusterFuture ... done
[10:19:24.434] result() for ClusterFuture ...
[10:19:24.434] - result already collected: FutureResult
[10:19:24.434] result() for ClusterFuture ... done
[10:19:24.434] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:24.434] - nx: 2
[10:19:24.434] - relay: TRUE
[10:19:24.434] - stdout: TRUE
[10:19:24.434] - signal: TRUE
[10:19:24.435] - resignal: FALSE
[10:19:24.435] - force: TRUE
[10:19:24.435] - relayed: [n=2] FALSE, FALSE
[10:19:24.435] - queued futures: [n=2] FALSE, FALSE
[10:19:24.435]  - until=1
[10:19:24.435]  - relaying element #1
[10:19:24.435] result() for ClusterFuture ...
[10:19:24.435] - result already collected: FutureResult
[10:19:24.435] result() for ClusterFuture ... done
[10:19:24.435] result() for ClusterFuture ...
[10:19:24.436] - result already collected: FutureResult
[10:19:24.436] result() for ClusterFuture ... done
[10:19:24.436] result() for ClusterFuture ...
[10:19:24.436] - result already collected: FutureResult
[10:19:24.436] result() for ClusterFuture ... done
[10:19:24.436] result() for ClusterFuture ...
[10:19:24.436] - result already collected: FutureResult
[10:19:24.436] result() for ClusterFuture ... done
[10:19:24.436] - relayed: [n=2] TRUE, FALSE
[10:19:24.437] - queued futures: [n=2] TRUE, FALSE
[10:19:24.437] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:24.437]  length: 1 (resolved future 1)
[10:19:24.499] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.500] - Validating connection of MultisessionFuture
[10:19:24.500] - received message: FutureResult
[10:19:24.500] - Received FutureResult
[10:19:24.500] - Erased future from FutureRegistry
[10:19:24.500] result() for ClusterFuture ...
[10:19:24.500] - result already collected: FutureResult
[10:19:24.500] result() for ClusterFuture ... done
[10:19:24.501] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.501] Future #2
[10:19:24.501] result() for ClusterFuture ...
[10:19:24.501] - result already collected: FutureResult
[10:19:24.501] result() for ClusterFuture ... done
[10:19:24.501] result() for ClusterFuture ...
[10:19:24.501] - result already collected: FutureResult
[10:19:24.501] result() for ClusterFuture ... done
[10:19:24.501] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:24.502] - nx: 2
[10:19:24.502] - relay: TRUE
[10:19:24.502] - stdout: TRUE
[10:19:24.502] - signal: TRUE
[10:19:24.502] - resignal: FALSE
[10:19:24.502] - force: TRUE
[10:19:24.502] - relayed: [n=2] TRUE, FALSE
[10:19:24.502] - queued futures: [n=2] TRUE, FALSE
[10:19:24.502]  - until=2
[10:19:24.502]  - relaying element #2
[10:19:24.503] result() for ClusterFuture ...
[10:19:24.503] - result already collected: FutureResult
[10:19:24.503] result() for ClusterFuture ... done
[10:19:24.503] result() for ClusterFuture ...
[10:19:24.503] - result already collected: FutureResult
[10:19:24.503] result() for ClusterFuture ... done
[10:19:24.503] result() for ClusterFuture ...
[10:19:24.503] - result already collected: FutureResult
[10:19:24.503] result() for ClusterFuture ... done
[10:19:24.504] result() for ClusterFuture ...
[10:19:24.504] - result already collected: FutureResult
[10:19:24.504] result() for ClusterFuture ... done
[10:19:24.504] - relayed: [n=2] TRUE, TRUE
[10:19:24.504] - queued futures: [n=2] TRUE, TRUE
[10:19:24.504] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:24.504]  length: 0 (resolved future 2)
[10:19:24.504] Relaying remaining futures
[10:19:24.504] signalConditionsASAP(NULL, pos=0) ...
[10:19:24.504] - nx: 2
[10:19:24.505] - relay: TRUE
[10:19:24.505] - stdout: TRUE
[10:19:24.505] - signal: TRUE
[10:19:24.505] - resignal: FALSE
[10:19:24.505] - force: TRUE
[10:19:24.505] - relayed: [n=2] TRUE, TRUE
[10:19:24.505] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:24.505] - relayed: [n=2] TRUE, TRUE
[10:19:24.505] - queued futures: [n=2] TRUE, TRUE
[10:19:24.506] signalConditionsASAP(NULL, pos=0) ... done
[10:19:24.506] resolve() on list ... DONE
[10:19:24.506] result() for ClusterFuture ...
[10:19:24.506] - result already collected: FutureResult
[10:19:24.506] result() for ClusterFuture ... done
[10:19:24.506] result() for ClusterFuture ...
[10:19:24.506] - result already collected: FutureResult
[10:19:24.506] result() for ClusterFuture ... done
[10:19:24.506] result() for ClusterFuture ...
[10:19:24.507] - result already collected: FutureResult
[10:19:24.507] result() for ClusterFuture ... done
[10:19:24.507] result() for ClusterFuture ...
[10:19:24.507] - result already collected: FutureResult
[10:19:24.507] result() for ClusterFuture ... done
[10:19:24.507]  - Number of value chunks collected: 2
[10:19:24.507] Resolving 2 futures (chunks) ... DONE
[10:19:24.507] Reducing values from 2 chunks ...
[10:19:24.507]  - Number of values collected after concatenation: 4
[10:19:24.507]  - Number of values expected: 4
[10:19:24.508] Reducing values from 2 chunks ... DONE
[10:19:24.508] future_mapply() ... DONE
[10:19:24.508] future_mapply() ...
[10:19:24.510] Number of chunks: 2
[10:19:24.510] getGlobalsAndPackagesXApply() ...
[10:19:24.510]  - future.globals: TRUE
[10:19:24.510] getGlobalsAndPackages() ...
[10:19:24.510] Searching for globals...
[10:19:24.511] - globals found: [1] ‘FUN’
[10:19:24.511] Searching for globals ... DONE
[10:19:24.511] Resolving globals: FALSE
[10:19:24.512] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:24.512] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:24.512] - globals: [1] ‘FUN’
[10:19:24.512] 
[10:19:24.512] getGlobalsAndPackages() ... DONE
[10:19:24.512]  - globals found/used: [n=1] ‘FUN’
[10:19:24.513]  - needed namespaces: [n=0] 
[10:19:24.513] Finding globals ... DONE
[10:19:24.513] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:24.513] List of 2
[10:19:24.513]  $ ...future.FUN:function (x, ...)  
[10:19:24.513]  $ MoreArgs     : NULL
[10:19:24.513]  - attr(*, "where")=List of 2
[10:19:24.513]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:24.513]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:24.513]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:24.513]  - attr(*, "resolved")= logi FALSE
[10:19:24.513]  - attr(*, "total_size")= num NA
[10:19:24.516] Packages to be attached in all futures: [n=0] 
[10:19:24.516] getGlobalsAndPackagesXApply() ... DONE
[10:19:24.516] Number of futures (= number of chunks): 2
[10:19:24.517] Launching 2 futures (chunks) ...
[10:19:24.517] Chunk #1 of 2 ...
[10:19:24.517]  - Finding globals in '...' for chunk #1 ...
[10:19:24.517] getGlobalsAndPackages() ...
[10:19:24.517] Searching for globals...
[10:19:24.517] 
[10:19:24.518] Searching for globals ... DONE
[10:19:24.518] - globals: [0] <none>
[10:19:24.518] getGlobalsAndPackages() ... DONE
[10:19:24.518]    + additional globals found: [n=0] 
[10:19:24.518]    + additional namespaces needed: [n=0] 
[10:19:24.518]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:24.518]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:24.518]  - seeds: <none>
[10:19:24.518]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.519] getGlobalsAndPackages() ...
[10:19:24.519] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.519] Resolving globals: FALSE
[10:19:24.519] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:24.520] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:24.520] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.520] 
[10:19:24.520] getGlobalsAndPackages() ... DONE
[10:19:24.520] run() for ‘Future’ ...
[10:19:24.521] - state: ‘created’
[10:19:24.521] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:24.535] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:24.535]   - Field: ‘node’
[10:19:24.536]   - Field: ‘label’
[10:19:24.536]   - Field: ‘local’
[10:19:24.536]   - Field: ‘owner’
[10:19:24.536]   - Field: ‘envir’
[10:19:24.536]   - Field: ‘workers’
[10:19:24.536]   - Field: ‘packages’
[10:19:24.536]   - Field: ‘gc’
[10:19:24.536]   - Field: ‘conditions’
[10:19:24.536]   - Field: ‘persistent’
[10:19:24.536]   - Field: ‘expr’
[10:19:24.537]   - Field: ‘uuid’
[10:19:24.537]   - Field: ‘seed’
[10:19:24.537]   - Field: ‘version’
[10:19:24.537]   - Field: ‘result’
[10:19:24.537]   - Field: ‘asynchronous’
[10:19:24.537]   - Field: ‘calls’
[10:19:24.537]   - Field: ‘globals’
[10:19:24.537]   - Field: ‘stdout’
[10:19:24.537]   - Field: ‘earlySignal’
[10:19:24.538]   - Field: ‘lazy’
[10:19:24.538]   - Field: ‘state’
[10:19:24.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:24.538] - Launch lazy future ...
[10:19:24.538] Packages needed by the future expression (n = 0): <none>
[10:19:24.538] Packages needed by future strategies (n = 0): <none>
[10:19:24.543] {
[10:19:24.543]     {
[10:19:24.543]         {
[10:19:24.543]             ...future.startTime <- base::Sys.time()
[10:19:24.543]             {
[10:19:24.543]                 {
[10:19:24.543]                   {
[10:19:24.543]                     {
[10:19:24.543]                       base::local({
[10:19:24.543]                         has_future <- base::requireNamespace("future", 
[10:19:24.543]                           quietly = TRUE)
[10:19:24.543]                         if (has_future) {
[10:19:24.543]                           ns <- base::getNamespace("future")
[10:19:24.543]                           version <- ns[[".package"]][["version"]]
[10:19:24.543]                           if (is.null(version)) 
[10:19:24.543]                             version <- utils::packageVersion("future")
[10:19:24.543]                         }
[10:19:24.543]                         else {
[10:19:24.543]                           version <- NULL
[10:19:24.543]                         }
[10:19:24.543]                         if (!has_future || version < "1.8.0") {
[10:19:24.543]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.543]                             "", base::R.version$version.string), 
[10:19:24.543]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.543]                               "release", "version")], collapse = " "), 
[10:19:24.543]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.543]                             info)
[10:19:24.543]                           info <- base::paste(info, collapse = "; ")
[10:19:24.543]                           if (!has_future) {
[10:19:24.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.543]                               info)
[10:19:24.543]                           }
[10:19:24.543]                           else {
[10:19:24.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.543]                               info, version)
[10:19:24.543]                           }
[10:19:24.543]                           base::stop(msg)
[10:19:24.543]                         }
[10:19:24.543]                       })
[10:19:24.543]                     }
[10:19:24.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.543]                     base::options(mc.cores = 1L)
[10:19:24.543]                   }
[10:19:24.543]                   ...future.strategy.old <- future::plan("list")
[10:19:24.543]                   options(future.plan = NULL)
[10:19:24.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.543]                 }
[10:19:24.543]                 ...future.workdir <- getwd()
[10:19:24.543]             }
[10:19:24.543]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.543]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.543]         }
[10:19:24.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.543]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:24.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.543]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.543]             base::names(...future.oldOptions))
[10:19:24.543]     }
[10:19:24.543]     if (FALSE) {
[10:19:24.543]     }
[10:19:24.543]     else {
[10:19:24.543]         if (TRUE) {
[10:19:24.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.543]                 open = "w")
[10:19:24.543]         }
[10:19:24.543]         else {
[10:19:24.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.543]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.543]         }
[10:19:24.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.543]             base::sink(type = "output", split = FALSE)
[10:19:24.543]             base::close(...future.stdout)
[10:19:24.543]         }, add = TRUE)
[10:19:24.543]     }
[10:19:24.543]     ...future.frame <- base::sys.nframe()
[10:19:24.543]     ...future.conditions <- base::list()
[10:19:24.543]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.543]     if (FALSE) {
[10:19:24.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.543]     }
[10:19:24.543]     ...future.result <- base::tryCatch({
[10:19:24.543]         base::withCallingHandlers({
[10:19:24.543]             ...future.value <- base::withVisible(base::local({
[10:19:24.543]                 ...future.makeSendCondition <- base::local({
[10:19:24.543]                   sendCondition <- NULL
[10:19:24.543]                   function(frame = 1L) {
[10:19:24.543]                     if (is.function(sendCondition)) 
[10:19:24.543]                       return(sendCondition)
[10:19:24.543]                     ns <- getNamespace("parallel")
[10:19:24.543]                     if (exists("sendData", mode = "function", 
[10:19:24.543]                       envir = ns)) {
[10:19:24.543]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.543]                         envir = ns)
[10:19:24.543]                       envir <- sys.frame(frame)
[10:19:24.543]                       master <- NULL
[10:19:24.543]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.543]                         !identical(envir, emptyenv())) {
[10:19:24.543]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.543]                           inherits = FALSE)) {
[10:19:24.543]                           master <- get("master", mode = "list", 
[10:19:24.543]                             envir = envir, inherits = FALSE)
[10:19:24.543]                           if (inherits(master, c("SOCKnode", 
[10:19:24.543]                             "SOCK0node"))) {
[10:19:24.543]                             sendCondition <<- function(cond) {
[10:19:24.543]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.543]                                 success = TRUE)
[10:19:24.543]                               parallel_sendData(master, data)
[10:19:24.543]                             }
[10:19:24.543]                             return(sendCondition)
[10:19:24.543]                           }
[10:19:24.543]                         }
[10:19:24.543]                         frame <- frame + 1L
[10:19:24.543]                         envir <- sys.frame(frame)
[10:19:24.543]                       }
[10:19:24.543]                     }
[10:19:24.543]                     sendCondition <<- function(cond) NULL
[10:19:24.543]                   }
[10:19:24.543]                 })
[10:19:24.543]                 withCallingHandlers({
[10:19:24.543]                   {
[10:19:24.543]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.543]                     if (!identical(...future.globals.maxSize.org, 
[10:19:24.543]                       ...future.globals.maxSize)) {
[10:19:24.543]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.543]                       on.exit(options(oopts), add = TRUE)
[10:19:24.543]                     }
[10:19:24.543]                     {
[10:19:24.543]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.543]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:24.543]                         USE.NAMES = FALSE)
[10:19:24.543]                       do.call(mapply, args = args)
[10:19:24.543]                     }
[10:19:24.543]                   }
[10:19:24.543]                 }, immediateCondition = function(cond) {
[10:19:24.543]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.543]                   sendCondition(cond)
[10:19:24.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.543]                   {
[10:19:24.543]                     inherits <- base::inherits
[10:19:24.543]                     invokeRestart <- base::invokeRestart
[10:19:24.543]                     is.null <- base::is.null
[10:19:24.543]                     muffled <- FALSE
[10:19:24.543]                     if (inherits(cond, "message")) {
[10:19:24.543]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.543]                       if (muffled) 
[10:19:24.543]                         invokeRestart("muffleMessage")
[10:19:24.543]                     }
[10:19:24.543]                     else if (inherits(cond, "warning")) {
[10:19:24.543]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.543]                       if (muffled) 
[10:19:24.543]                         invokeRestart("muffleWarning")
[10:19:24.543]                     }
[10:19:24.543]                     else if (inherits(cond, "condition")) {
[10:19:24.543]                       if (!is.null(pattern)) {
[10:19:24.543]                         computeRestarts <- base::computeRestarts
[10:19:24.543]                         grepl <- base::grepl
[10:19:24.543]                         restarts <- computeRestarts(cond)
[10:19:24.543]                         for (restart in restarts) {
[10:19:24.543]                           name <- restart$name
[10:19:24.543]                           if (is.null(name)) 
[10:19:24.543]                             next
[10:19:24.543]                           if (!grepl(pattern, name)) 
[10:19:24.543]                             next
[10:19:24.543]                           invokeRestart(restart)
[10:19:24.543]                           muffled <- TRUE
[10:19:24.543]                           break
[10:19:24.543]                         }
[10:19:24.543]                       }
[10:19:24.543]                     }
[10:19:24.543]                     invisible(muffled)
[10:19:24.543]                   }
[10:19:24.543]                   muffleCondition(cond)
[10:19:24.543]                 })
[10:19:24.543]             }))
[10:19:24.543]             future::FutureResult(value = ...future.value$value, 
[10:19:24.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.543]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.543]                     ...future.globalenv.names))
[10:19:24.543]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.543]         }, condition = base::local({
[10:19:24.543]             c <- base::c
[10:19:24.543]             inherits <- base::inherits
[10:19:24.543]             invokeRestart <- base::invokeRestart
[10:19:24.543]             length <- base::length
[10:19:24.543]             list <- base::list
[10:19:24.543]             seq.int <- base::seq.int
[10:19:24.543]             signalCondition <- base::signalCondition
[10:19:24.543]             sys.calls <- base::sys.calls
[10:19:24.543]             `[[` <- base::`[[`
[10:19:24.543]             `+` <- base::`+`
[10:19:24.543]             `<<-` <- base::`<<-`
[10:19:24.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.543]                   3L)]
[10:19:24.543]             }
[10:19:24.543]             function(cond) {
[10:19:24.543]                 is_error <- inherits(cond, "error")
[10:19:24.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.543]                   NULL)
[10:19:24.543]                 if (is_error) {
[10:19:24.543]                   sessionInformation <- function() {
[10:19:24.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.543]                       search = base::search(), system = base::Sys.info())
[10:19:24.543]                   }
[10:19:24.543]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.543]                     cond$call), session = sessionInformation(), 
[10:19:24.543]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.543]                   signalCondition(cond)
[10:19:24.543]                 }
[10:19:24.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.543]                 "immediateCondition"))) {
[10:19:24.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.543]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.543]                   if (TRUE && !signal) {
[10:19:24.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.543]                     {
[10:19:24.543]                       inherits <- base::inherits
[10:19:24.543]                       invokeRestart <- base::invokeRestart
[10:19:24.543]                       is.null <- base::is.null
[10:19:24.543]                       muffled <- FALSE
[10:19:24.543]                       if (inherits(cond, "message")) {
[10:19:24.543]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.543]                         if (muffled) 
[10:19:24.543]                           invokeRestart("muffleMessage")
[10:19:24.543]                       }
[10:19:24.543]                       else if (inherits(cond, "warning")) {
[10:19:24.543]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.543]                         if (muffled) 
[10:19:24.543]                           invokeRestart("muffleWarning")
[10:19:24.543]                       }
[10:19:24.543]                       else if (inherits(cond, "condition")) {
[10:19:24.543]                         if (!is.null(pattern)) {
[10:19:24.543]                           computeRestarts <- base::computeRestarts
[10:19:24.543]                           grepl <- base::grepl
[10:19:24.543]                           restarts <- computeRestarts(cond)
[10:19:24.543]                           for (restart in restarts) {
[10:19:24.543]                             name <- restart$name
[10:19:24.543]                             if (is.null(name)) 
[10:19:24.543]                               next
[10:19:24.543]                             if (!grepl(pattern, name)) 
[10:19:24.543]                               next
[10:19:24.543]                             invokeRestart(restart)
[10:19:24.543]                             muffled <- TRUE
[10:19:24.543]                             break
[10:19:24.543]                           }
[10:19:24.543]                         }
[10:19:24.543]                       }
[10:19:24.543]                       invisible(muffled)
[10:19:24.543]                     }
[10:19:24.543]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.543]                   }
[10:19:24.543]                 }
[10:19:24.543]                 else {
[10:19:24.543]                   if (TRUE) {
[10:19:24.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.543]                     {
[10:19:24.543]                       inherits <- base::inherits
[10:19:24.543]                       invokeRestart <- base::invokeRestart
[10:19:24.543]                       is.null <- base::is.null
[10:19:24.543]                       muffled <- FALSE
[10:19:24.543]                       if (inherits(cond, "message")) {
[10:19:24.543]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.543]                         if (muffled) 
[10:19:24.543]                           invokeRestart("muffleMessage")
[10:19:24.543]                       }
[10:19:24.543]                       else if (inherits(cond, "warning")) {
[10:19:24.543]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.543]                         if (muffled) 
[10:19:24.543]                           invokeRestart("muffleWarning")
[10:19:24.543]                       }
[10:19:24.543]                       else if (inherits(cond, "condition")) {
[10:19:24.543]                         if (!is.null(pattern)) {
[10:19:24.543]                           computeRestarts <- base::computeRestarts
[10:19:24.543]                           grepl <- base::grepl
[10:19:24.543]                           restarts <- computeRestarts(cond)
[10:19:24.543]                           for (restart in restarts) {
[10:19:24.543]                             name <- restart$name
[10:19:24.543]                             if (is.null(name)) 
[10:19:24.543]                               next
[10:19:24.543]                             if (!grepl(pattern, name)) 
[10:19:24.543]                               next
[10:19:24.543]                             invokeRestart(restart)
[10:19:24.543]                             muffled <- TRUE
[10:19:24.543]                             break
[10:19:24.543]                           }
[10:19:24.543]                         }
[10:19:24.543]                       }
[10:19:24.543]                       invisible(muffled)
[10:19:24.543]                     }
[10:19:24.543]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.543]                   }
[10:19:24.543]                 }
[10:19:24.543]             }
[10:19:24.543]         }))
[10:19:24.543]     }, error = function(ex) {
[10:19:24.543]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.543]                 ...future.rng), started = ...future.startTime, 
[10:19:24.543]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.543]             version = "1.8"), class = "FutureResult")
[10:19:24.543]     }, finally = {
[10:19:24.543]         if (!identical(...future.workdir, getwd())) 
[10:19:24.543]             setwd(...future.workdir)
[10:19:24.543]         {
[10:19:24.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.543]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.543]             }
[10:19:24.543]             base::options(...future.oldOptions)
[10:19:24.543]             if (.Platform$OS.type == "windows") {
[10:19:24.543]                 old_names <- names(...future.oldEnvVars)
[10:19:24.543]                 envs <- base::Sys.getenv()
[10:19:24.543]                 names <- names(envs)
[10:19:24.543]                 common <- intersect(names, old_names)
[10:19:24.543]                 added <- setdiff(names, old_names)
[10:19:24.543]                 removed <- setdiff(old_names, names)
[10:19:24.543]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.543]                   envs[common]]
[10:19:24.543]                 NAMES <- toupper(changed)
[10:19:24.543]                 args <- list()
[10:19:24.543]                 for (kk in seq_along(NAMES)) {
[10:19:24.543]                   name <- changed[[kk]]
[10:19:24.543]                   NAME <- NAMES[[kk]]
[10:19:24.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.543]                     next
[10:19:24.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.543]                 }
[10:19:24.543]                 NAMES <- toupper(added)
[10:19:24.543]                 for (kk in seq_along(NAMES)) {
[10:19:24.543]                   name <- added[[kk]]
[10:19:24.543]                   NAME <- NAMES[[kk]]
[10:19:24.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.543]                     next
[10:19:24.543]                   args[[name]] <- ""
[10:19:24.543]                 }
[10:19:24.543]                 NAMES <- toupper(removed)
[10:19:24.543]                 for (kk in seq_along(NAMES)) {
[10:19:24.543]                   name <- removed[[kk]]
[10:19:24.543]                   NAME <- NAMES[[kk]]
[10:19:24.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.543]                     next
[10:19:24.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.543]                 }
[10:19:24.543]                 if (length(args) > 0) 
[10:19:24.543]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.543]             }
[10:19:24.543]             else {
[10:19:24.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.543]             }
[10:19:24.543]             {
[10:19:24.543]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.543]                   0L) {
[10:19:24.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.543]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.543]                   base::options(opts)
[10:19:24.543]                 }
[10:19:24.543]                 {
[10:19:24.543]                   {
[10:19:24.543]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.543]                     NULL
[10:19:24.543]                   }
[10:19:24.543]                   options(future.plan = NULL)
[10:19:24.543]                   if (is.na(NA_character_)) 
[10:19:24.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.543]                     .init = FALSE)
[10:19:24.543]                 }
[10:19:24.543]             }
[10:19:24.543]         }
[10:19:24.543]     })
[10:19:24.543]     if (TRUE) {
[10:19:24.543]         base::sink(type = "output", split = FALSE)
[10:19:24.543]         if (TRUE) {
[10:19:24.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.543]         }
[10:19:24.543]         else {
[10:19:24.543]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.543]         }
[10:19:24.543]         base::close(...future.stdout)
[10:19:24.543]         ...future.stdout <- NULL
[10:19:24.543]     }
[10:19:24.543]     ...future.result$conditions <- ...future.conditions
[10:19:24.543]     ...future.result$finished <- base::Sys.time()
[10:19:24.543]     ...future.result
[10:19:24.543] }
[10:19:24.546] Exporting 5 global objects (673 bytes) to cluster node #1 ...
[10:19:24.546] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[10:19:24.546] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[10:19:24.546] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:24.547] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.547] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ...
[10:19:24.547] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ... DONE
[10:19:24.547] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:24.548] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.548] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:24.548] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.548] Exporting 5 global objects (673 bytes) to cluster node #1 ... DONE
[10:19:24.549] MultisessionFuture started
[10:19:24.549] - Launch lazy future ... done
[10:19:24.549] run() for ‘MultisessionFuture’ ... done
[10:19:24.549] Created future:
[10:19:24.549] MultisessionFuture:
[10:19:24.549] Label: ‘future_mapply-1’
[10:19:24.549] Expression:
[10:19:24.549] {
[10:19:24.549]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.549]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:24.549]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.549]         on.exit(options(oopts), add = TRUE)
[10:19:24.549]     }
[10:19:24.549]     {
[10:19:24.549]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.549]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:24.549]         do.call(mapply, args = args)
[10:19:24.549]     }
[10:19:24.549] }
[10:19:24.549] Lazy evaluation: FALSE
[10:19:24.549] Asynchronous evaluation: TRUE
[10:19:24.549] Local evaluation: TRUE
[10:19:24.549] Environment: R_GlobalEnv
[10:19:24.549] Capture standard output: TRUE
[10:19:24.549] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:24.549] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:24.549] Packages: <none>
[10:19:24.549] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:24.549] Resolved: FALSE
[10:19:24.549] Value: <not collected>
[10:19:24.549] Conditions captured: <none>
[10:19:24.549] Early signaling: FALSE
[10:19:24.549] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:24.549] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.560] Chunk #1 of 2 ... DONE
[10:19:24.561] Chunk #2 of 2 ...
[10:19:24.561]  - Finding globals in '...' for chunk #2 ...
[10:19:24.561] getGlobalsAndPackages() ...
[10:19:24.561] Searching for globals...
[10:19:24.561] 
[10:19:24.561] Searching for globals ... DONE
[10:19:24.561] - globals: [0] <none>
[10:19:24.561] getGlobalsAndPackages() ... DONE
[10:19:24.562]    + additional globals found: [n=0] 
[10:19:24.562]    + additional namespaces needed: [n=0] 
[10:19:24.562]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:24.562]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:24.562]  - seeds: <none>
[10:19:24.562]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.562] getGlobalsAndPackages() ...
[10:19:24.562] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.562] Resolving globals: FALSE
[10:19:24.563] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:24.563] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:24.563] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.563] 
[10:19:24.563] getGlobalsAndPackages() ... DONE
[10:19:24.564] run() for ‘Future’ ...
[10:19:24.564] - state: ‘created’
[10:19:24.564] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:24.578] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:24.578]   - Field: ‘node’
[10:19:24.578]   - Field: ‘label’
[10:19:24.578]   - Field: ‘local’
[10:19:24.578]   - Field: ‘owner’
[10:19:24.578]   - Field: ‘envir’
[10:19:24.578]   - Field: ‘workers’
[10:19:24.578]   - Field: ‘packages’
[10:19:24.578]   - Field: ‘gc’
[10:19:24.578]   - Field: ‘conditions’
[10:19:24.579]   - Field: ‘persistent’
[10:19:24.579]   - Field: ‘expr’
[10:19:24.579]   - Field: ‘uuid’
[10:19:24.579]   - Field: ‘seed’
[10:19:24.579]   - Field: ‘version’
[10:19:24.579]   - Field: ‘result’
[10:19:24.579]   - Field: ‘asynchronous’
[10:19:24.579]   - Field: ‘calls’
[10:19:24.579]   - Field: ‘globals’
[10:19:24.579]   - Field: ‘stdout’
[10:19:24.579]   - Field: ‘earlySignal’
[10:19:24.579]   - Field: ‘lazy’
[10:19:24.580]   - Field: ‘state’
[10:19:24.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:24.580] - Launch lazy future ...
[10:19:24.580] Packages needed by the future expression (n = 0): <none>
[10:19:24.580] Packages needed by future strategies (n = 0): <none>
[10:19:24.580] {
[10:19:24.580]     {
[10:19:24.580]         {
[10:19:24.580]             ...future.startTime <- base::Sys.time()
[10:19:24.580]             {
[10:19:24.580]                 {
[10:19:24.580]                   {
[10:19:24.580]                     {
[10:19:24.580]                       base::local({
[10:19:24.580]                         has_future <- base::requireNamespace("future", 
[10:19:24.580]                           quietly = TRUE)
[10:19:24.580]                         if (has_future) {
[10:19:24.580]                           ns <- base::getNamespace("future")
[10:19:24.580]                           version <- ns[[".package"]][["version"]]
[10:19:24.580]                           if (is.null(version)) 
[10:19:24.580]                             version <- utils::packageVersion("future")
[10:19:24.580]                         }
[10:19:24.580]                         else {
[10:19:24.580]                           version <- NULL
[10:19:24.580]                         }
[10:19:24.580]                         if (!has_future || version < "1.8.0") {
[10:19:24.580]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.580]                             "", base::R.version$version.string), 
[10:19:24.580]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.580]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.580]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.580]                               "release", "version")], collapse = " "), 
[10:19:24.580]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.580]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.580]                             info)
[10:19:24.580]                           info <- base::paste(info, collapse = "; ")
[10:19:24.580]                           if (!has_future) {
[10:19:24.580]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.580]                               info)
[10:19:24.580]                           }
[10:19:24.580]                           else {
[10:19:24.580]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.580]                               info, version)
[10:19:24.580]                           }
[10:19:24.580]                           base::stop(msg)
[10:19:24.580]                         }
[10:19:24.580]                       })
[10:19:24.580]                     }
[10:19:24.580]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.580]                     base::options(mc.cores = 1L)
[10:19:24.580]                   }
[10:19:24.580]                   ...future.strategy.old <- future::plan("list")
[10:19:24.580]                   options(future.plan = NULL)
[10:19:24.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.580]                 }
[10:19:24.580]                 ...future.workdir <- getwd()
[10:19:24.580]             }
[10:19:24.580]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.580]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.580]         }
[10:19:24.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.580]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:24.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.580]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.580]             base::names(...future.oldOptions))
[10:19:24.580]     }
[10:19:24.580]     if (FALSE) {
[10:19:24.580]     }
[10:19:24.580]     else {
[10:19:24.580]         if (TRUE) {
[10:19:24.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.580]                 open = "w")
[10:19:24.580]         }
[10:19:24.580]         else {
[10:19:24.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.580]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.580]         }
[10:19:24.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.580]             base::sink(type = "output", split = FALSE)
[10:19:24.580]             base::close(...future.stdout)
[10:19:24.580]         }, add = TRUE)
[10:19:24.580]     }
[10:19:24.580]     ...future.frame <- base::sys.nframe()
[10:19:24.580]     ...future.conditions <- base::list()
[10:19:24.580]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.580]     if (FALSE) {
[10:19:24.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.580]     }
[10:19:24.580]     ...future.result <- base::tryCatch({
[10:19:24.580]         base::withCallingHandlers({
[10:19:24.580]             ...future.value <- base::withVisible(base::local({
[10:19:24.580]                 ...future.makeSendCondition <- base::local({
[10:19:24.580]                   sendCondition <- NULL
[10:19:24.580]                   function(frame = 1L) {
[10:19:24.580]                     if (is.function(sendCondition)) 
[10:19:24.580]                       return(sendCondition)
[10:19:24.580]                     ns <- getNamespace("parallel")
[10:19:24.580]                     if (exists("sendData", mode = "function", 
[10:19:24.580]                       envir = ns)) {
[10:19:24.580]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.580]                         envir = ns)
[10:19:24.580]                       envir <- sys.frame(frame)
[10:19:24.580]                       master <- NULL
[10:19:24.580]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.580]                         !identical(envir, emptyenv())) {
[10:19:24.580]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.580]                           inherits = FALSE)) {
[10:19:24.580]                           master <- get("master", mode = "list", 
[10:19:24.580]                             envir = envir, inherits = FALSE)
[10:19:24.580]                           if (inherits(master, c("SOCKnode", 
[10:19:24.580]                             "SOCK0node"))) {
[10:19:24.580]                             sendCondition <<- function(cond) {
[10:19:24.580]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.580]                                 success = TRUE)
[10:19:24.580]                               parallel_sendData(master, data)
[10:19:24.580]                             }
[10:19:24.580]                             return(sendCondition)
[10:19:24.580]                           }
[10:19:24.580]                         }
[10:19:24.580]                         frame <- frame + 1L
[10:19:24.580]                         envir <- sys.frame(frame)
[10:19:24.580]                       }
[10:19:24.580]                     }
[10:19:24.580]                     sendCondition <<- function(cond) NULL
[10:19:24.580]                   }
[10:19:24.580]                 })
[10:19:24.580]                 withCallingHandlers({
[10:19:24.580]                   {
[10:19:24.580]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.580]                     if (!identical(...future.globals.maxSize.org, 
[10:19:24.580]                       ...future.globals.maxSize)) {
[10:19:24.580]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.580]                       on.exit(options(oopts), add = TRUE)
[10:19:24.580]                     }
[10:19:24.580]                     {
[10:19:24.580]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.580]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:24.580]                         USE.NAMES = FALSE)
[10:19:24.580]                       do.call(mapply, args = args)
[10:19:24.580]                     }
[10:19:24.580]                   }
[10:19:24.580]                 }, immediateCondition = function(cond) {
[10:19:24.580]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.580]                   sendCondition(cond)
[10:19:24.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.580]                   {
[10:19:24.580]                     inherits <- base::inherits
[10:19:24.580]                     invokeRestart <- base::invokeRestart
[10:19:24.580]                     is.null <- base::is.null
[10:19:24.580]                     muffled <- FALSE
[10:19:24.580]                     if (inherits(cond, "message")) {
[10:19:24.580]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.580]                       if (muffled) 
[10:19:24.580]                         invokeRestart("muffleMessage")
[10:19:24.580]                     }
[10:19:24.580]                     else if (inherits(cond, "warning")) {
[10:19:24.580]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.580]                       if (muffled) 
[10:19:24.580]                         invokeRestart("muffleWarning")
[10:19:24.580]                     }
[10:19:24.580]                     else if (inherits(cond, "condition")) {
[10:19:24.580]                       if (!is.null(pattern)) {
[10:19:24.580]                         computeRestarts <- base::computeRestarts
[10:19:24.580]                         grepl <- base::grepl
[10:19:24.580]                         restarts <- computeRestarts(cond)
[10:19:24.580]                         for (restart in restarts) {
[10:19:24.580]                           name <- restart$name
[10:19:24.580]                           if (is.null(name)) 
[10:19:24.580]                             next
[10:19:24.580]                           if (!grepl(pattern, name)) 
[10:19:24.580]                             next
[10:19:24.580]                           invokeRestart(restart)
[10:19:24.580]                           muffled <- TRUE
[10:19:24.580]                           break
[10:19:24.580]                         }
[10:19:24.580]                       }
[10:19:24.580]                     }
[10:19:24.580]                     invisible(muffled)
[10:19:24.580]                   }
[10:19:24.580]                   muffleCondition(cond)
[10:19:24.580]                 })
[10:19:24.580]             }))
[10:19:24.580]             future::FutureResult(value = ...future.value$value, 
[10:19:24.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.580]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.580]                     ...future.globalenv.names))
[10:19:24.580]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.580]         }, condition = base::local({
[10:19:24.580]             c <- base::c
[10:19:24.580]             inherits <- base::inherits
[10:19:24.580]             invokeRestart <- base::invokeRestart
[10:19:24.580]             length <- base::length
[10:19:24.580]             list <- base::list
[10:19:24.580]             seq.int <- base::seq.int
[10:19:24.580]             signalCondition <- base::signalCondition
[10:19:24.580]             sys.calls <- base::sys.calls
[10:19:24.580]             `[[` <- base::`[[`
[10:19:24.580]             `+` <- base::`+`
[10:19:24.580]             `<<-` <- base::`<<-`
[10:19:24.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.580]                   3L)]
[10:19:24.580]             }
[10:19:24.580]             function(cond) {
[10:19:24.580]                 is_error <- inherits(cond, "error")
[10:19:24.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.580]                   NULL)
[10:19:24.580]                 if (is_error) {
[10:19:24.580]                   sessionInformation <- function() {
[10:19:24.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.580]                       search = base::search(), system = base::Sys.info())
[10:19:24.580]                   }
[10:19:24.580]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.580]                     cond$call), session = sessionInformation(), 
[10:19:24.580]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.580]                   signalCondition(cond)
[10:19:24.580]                 }
[10:19:24.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.580]                 "immediateCondition"))) {
[10:19:24.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.580]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.580]                   if (TRUE && !signal) {
[10:19:24.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.580]                     {
[10:19:24.580]                       inherits <- base::inherits
[10:19:24.580]                       invokeRestart <- base::invokeRestart
[10:19:24.580]                       is.null <- base::is.null
[10:19:24.580]                       muffled <- FALSE
[10:19:24.580]                       if (inherits(cond, "message")) {
[10:19:24.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.580]                         if (muffled) 
[10:19:24.580]                           invokeRestart("muffleMessage")
[10:19:24.580]                       }
[10:19:24.580]                       else if (inherits(cond, "warning")) {
[10:19:24.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.580]                         if (muffled) 
[10:19:24.580]                           invokeRestart("muffleWarning")
[10:19:24.580]                       }
[10:19:24.580]                       else if (inherits(cond, "condition")) {
[10:19:24.580]                         if (!is.null(pattern)) {
[10:19:24.580]                           computeRestarts <- base::computeRestarts
[10:19:24.580]                           grepl <- base::grepl
[10:19:24.580]                           restarts <- computeRestarts(cond)
[10:19:24.580]                           for (restart in restarts) {
[10:19:24.580]                             name <- restart$name
[10:19:24.580]                             if (is.null(name)) 
[10:19:24.580]                               next
[10:19:24.580]                             if (!grepl(pattern, name)) 
[10:19:24.580]                               next
[10:19:24.580]                             invokeRestart(restart)
[10:19:24.580]                             muffled <- TRUE
[10:19:24.580]                             break
[10:19:24.580]                           }
[10:19:24.580]                         }
[10:19:24.580]                       }
[10:19:24.580]                       invisible(muffled)
[10:19:24.580]                     }
[10:19:24.580]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.580]                   }
[10:19:24.580]                 }
[10:19:24.580]                 else {
[10:19:24.580]                   if (TRUE) {
[10:19:24.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.580]                     {
[10:19:24.580]                       inherits <- base::inherits
[10:19:24.580]                       invokeRestart <- base::invokeRestart
[10:19:24.580]                       is.null <- base::is.null
[10:19:24.580]                       muffled <- FALSE
[10:19:24.580]                       if (inherits(cond, "message")) {
[10:19:24.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.580]                         if (muffled) 
[10:19:24.580]                           invokeRestart("muffleMessage")
[10:19:24.580]                       }
[10:19:24.580]                       else if (inherits(cond, "warning")) {
[10:19:24.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.580]                         if (muffled) 
[10:19:24.580]                           invokeRestart("muffleWarning")
[10:19:24.580]                       }
[10:19:24.580]                       else if (inherits(cond, "condition")) {
[10:19:24.580]                         if (!is.null(pattern)) {
[10:19:24.580]                           computeRestarts <- base::computeRestarts
[10:19:24.580]                           grepl <- base::grepl
[10:19:24.580]                           restarts <- computeRestarts(cond)
[10:19:24.580]                           for (restart in restarts) {
[10:19:24.580]                             name <- restart$name
[10:19:24.580]                             if (is.null(name)) 
[10:19:24.580]                               next
[10:19:24.580]                             if (!grepl(pattern, name)) 
[10:19:24.580]                               next
[10:19:24.580]                             invokeRestart(restart)
[10:19:24.580]                             muffled <- TRUE
[10:19:24.580]                             break
[10:19:24.580]                           }
[10:19:24.580]                         }
[10:19:24.580]                       }
[10:19:24.580]                       invisible(muffled)
[10:19:24.580]                     }
[10:19:24.580]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.580]                   }
[10:19:24.580]                 }
[10:19:24.580]             }
[10:19:24.580]         }))
[10:19:24.580]     }, error = function(ex) {
[10:19:24.580]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.580]                 ...future.rng), started = ...future.startTime, 
[10:19:24.580]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.580]             version = "1.8"), class = "FutureResult")
[10:19:24.580]     }, finally = {
[10:19:24.580]         if (!identical(...future.workdir, getwd())) 
[10:19:24.580]             setwd(...future.workdir)
[10:19:24.580]         {
[10:19:24.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.580]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.580]             }
[10:19:24.580]             base::options(...future.oldOptions)
[10:19:24.580]             if (.Platform$OS.type == "windows") {
[10:19:24.580]                 old_names <- names(...future.oldEnvVars)
[10:19:24.580]                 envs <- base::Sys.getenv()
[10:19:24.580]                 names <- names(envs)
[10:19:24.580]                 common <- intersect(names, old_names)
[10:19:24.580]                 added <- setdiff(names, old_names)
[10:19:24.580]                 removed <- setdiff(old_names, names)
[10:19:24.580]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.580]                   envs[common]]
[10:19:24.580]                 NAMES <- toupper(changed)
[10:19:24.580]                 args <- list()
[10:19:24.580]                 for (kk in seq_along(NAMES)) {
[10:19:24.580]                   name <- changed[[kk]]
[10:19:24.580]                   NAME <- NAMES[[kk]]
[10:19:24.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.580]                     next
[10:19:24.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.580]                 }
[10:19:24.580]                 NAMES <- toupper(added)
[10:19:24.580]                 for (kk in seq_along(NAMES)) {
[10:19:24.580]                   name <- added[[kk]]
[10:19:24.580]                   NAME <- NAMES[[kk]]
[10:19:24.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.580]                     next
[10:19:24.580]                   args[[name]] <- ""
[10:19:24.580]                 }
[10:19:24.580]                 NAMES <- toupper(removed)
[10:19:24.580]                 for (kk in seq_along(NAMES)) {
[10:19:24.580]                   name <- removed[[kk]]
[10:19:24.580]                   NAME <- NAMES[[kk]]
[10:19:24.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.580]                     next
[10:19:24.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.580]                 }
[10:19:24.580]                 if (length(args) > 0) 
[10:19:24.580]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.580]             }
[10:19:24.580]             else {
[10:19:24.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.580]             }
[10:19:24.580]             {
[10:19:24.580]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.580]                   0L) {
[10:19:24.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.580]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.580]                   base::options(opts)
[10:19:24.580]                 }
[10:19:24.580]                 {
[10:19:24.580]                   {
[10:19:24.580]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.580]                     NULL
[10:19:24.580]                   }
[10:19:24.580]                   options(future.plan = NULL)
[10:19:24.580]                   if (is.na(NA_character_)) 
[10:19:24.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.580]                     .init = FALSE)
[10:19:24.580]                 }
[10:19:24.580]             }
[10:19:24.580]         }
[10:19:24.580]     })
[10:19:24.580]     if (TRUE) {
[10:19:24.580]         base::sink(type = "output", split = FALSE)
[10:19:24.580]         if (TRUE) {
[10:19:24.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.580]         }
[10:19:24.580]         else {
[10:19:24.580]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.580]         }
[10:19:24.580]         base::close(...future.stdout)
[10:19:24.580]         ...future.stdout <- NULL
[10:19:24.580]     }
[10:19:24.580]     ...future.result$conditions <- ...future.conditions
[10:19:24.580]     ...future.result$finished <- base::Sys.time()
[10:19:24.580]     ...future.result
[10:19:24.580] }
[10:19:24.583] Exporting 5 global objects (673 bytes) to cluster node #2 ...
[10:19:24.583] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[10:19:24.583] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[10:19:24.584] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:24.584] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.584] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ...
[10:19:24.584] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ... DONE
[10:19:24.585] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:24.585] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.585] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:24.585] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.585] Exporting 5 global objects (673 bytes) to cluster node #2 ... DONE
[10:19:24.586] MultisessionFuture started
[10:19:24.586] - Launch lazy future ... done
[10:19:24.586] run() for ‘MultisessionFuture’ ... done
[10:19:24.586] Created future:
[10:19:24.586] MultisessionFuture:
[10:19:24.586] Label: ‘future_mapply-2’
[10:19:24.586] Expression:
[10:19:24.586] {
[10:19:24.586]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.586]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:24.586]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.586]         on.exit(options(oopts), add = TRUE)
[10:19:24.586]     }
[10:19:24.586]     {
[10:19:24.586]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.586]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:24.586]         do.call(mapply, args = args)
[10:19:24.586]     }
[10:19:24.586] }
[10:19:24.586] Lazy evaluation: FALSE
[10:19:24.586] Asynchronous evaluation: TRUE
[10:19:24.586] Local evaluation: TRUE
[10:19:24.586] Environment: R_GlobalEnv
[10:19:24.586] Capture standard output: TRUE
[10:19:24.586] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:24.586] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:24.586] Packages: <none>
[10:19:24.586] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:24.586] Resolved: FALSE
[10:19:24.586] Value: <not collected>
[10:19:24.586] Conditions captured: <none>
[10:19:24.586] Early signaling: FALSE
[10:19:24.586] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:24.586] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.598] Chunk #2 of 2 ... DONE
[10:19:24.598] Launching 2 futures (chunks) ... DONE
[10:19:24.598] Resolving 2 futures (chunks) ...
[10:19:24.598] resolve() on list ...
[10:19:24.598]  recursive: 0
[10:19:24.598]  length: 2
[10:19:24.598] 
[10:19:24.599] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.599] - Validating connection of MultisessionFuture
[10:19:24.599] - received message: FutureResult
[10:19:24.599] - Received FutureResult
[10:19:24.599] - Erased future from FutureRegistry
[10:19:24.599] result() for ClusterFuture ...
[10:19:24.599] - result already collected: FutureResult
[10:19:24.599] result() for ClusterFuture ... done
[10:19:24.599] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.599] Future #1
[10:19:24.600] result() for ClusterFuture ...
[10:19:24.600] - result already collected: FutureResult
[10:19:24.600] result() for ClusterFuture ... done
[10:19:24.600] result() for ClusterFuture ...
[10:19:24.600] - result already collected: FutureResult
[10:19:24.600] result() for ClusterFuture ... done
[10:19:24.600] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:24.600] - nx: 2
[10:19:24.600] - relay: TRUE
[10:19:24.600] - stdout: TRUE
[10:19:24.600] - signal: TRUE
[10:19:24.600] - resignal: FALSE
[10:19:24.600] - force: TRUE
[10:19:24.601] - relayed: [n=2] FALSE, FALSE
[10:19:24.601] - queued futures: [n=2] FALSE, FALSE
[10:19:24.601]  - until=1
[10:19:24.601]  - relaying element #1
[10:19:24.601] result() for ClusterFuture ...
[10:19:24.601] - result already collected: FutureResult
[10:19:24.601] result() for ClusterFuture ... done
[10:19:24.601] result() for ClusterFuture ...
[10:19:24.601] - result already collected: FutureResult
[10:19:24.601] result() for ClusterFuture ... done
[10:19:24.601] result() for ClusterFuture ...
[10:19:24.602] - result already collected: FutureResult
[10:19:24.602] result() for ClusterFuture ... done
[10:19:24.602] result() for ClusterFuture ...
[10:19:24.602] - result already collected: FutureResult
[10:19:24.602] result() for ClusterFuture ... done
[10:19:24.602] - relayed: [n=2] TRUE, FALSE
[10:19:24.602] - queued futures: [n=2] TRUE, FALSE
[10:19:24.602] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:24.602]  length: 1 (resolved future 1)
[10:19:24.631] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.631] - Validating connection of MultisessionFuture
[10:19:24.632] - received message: FutureResult
[10:19:24.632] - Received FutureResult
[10:19:24.632] - Erased future from FutureRegistry
[10:19:24.632] result() for ClusterFuture ...
[10:19:24.632] - result already collected: FutureResult
[10:19:24.632] result() for ClusterFuture ... done
[10:19:24.632] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.632] Future #2
[10:19:24.632] result() for ClusterFuture ...
[10:19:24.632] - result already collected: FutureResult
[10:19:24.633] result() for ClusterFuture ... done
[10:19:24.633] result() for ClusterFuture ...
[10:19:24.633] - result already collected: FutureResult
[10:19:24.633] result() for ClusterFuture ... done
[10:19:24.633] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:24.633] - nx: 2
[10:19:24.633] - relay: TRUE
[10:19:24.633] - stdout: TRUE
[10:19:24.633] - signal: TRUE
[10:19:24.633] - resignal: FALSE
[10:19:24.633] - force: TRUE
[10:19:24.633] - relayed: [n=2] TRUE, FALSE
[10:19:24.634] - queued futures: [n=2] TRUE, FALSE
[10:19:24.634]  - until=2
[10:19:24.634]  - relaying element #2
[10:19:24.634] result() for ClusterFuture ...
[10:19:24.634] - result already collected: FutureResult
[10:19:24.634] result() for ClusterFuture ... done
[10:19:24.634] result() for ClusterFuture ...
[10:19:24.634] - result already collected: FutureResult
[10:19:24.634] result() for ClusterFuture ... done
[10:19:24.634] result() for ClusterFuture ...
[10:19:24.634] - result already collected: FutureResult
[10:19:24.634] result() for ClusterFuture ... done
[10:19:24.635] result() for ClusterFuture ...
[10:19:24.635] - result already collected: FutureResult
[10:19:24.635] result() for ClusterFuture ... done
[10:19:24.635] - relayed: [n=2] TRUE, TRUE
[10:19:24.635] - queued futures: [n=2] TRUE, TRUE
[10:19:24.635] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:24.635]  length: 0 (resolved future 2)
[10:19:24.635] Relaying remaining futures
[10:19:24.635] signalConditionsASAP(NULL, pos=0) ...
[10:19:24.635] - nx: 2
[10:19:24.635] - relay: TRUE
[10:19:24.635] - stdout: TRUE
[10:19:24.636] - signal: TRUE
[10:19:24.636] - resignal: FALSE
[10:19:24.636] - force: TRUE
[10:19:24.636] - relayed: [n=2] TRUE, TRUE
[10:19:24.636] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:24.636] - relayed: [n=2] TRUE, TRUE
[10:19:24.636] - queued futures: [n=2] TRUE, TRUE
[10:19:24.636] signalConditionsASAP(NULL, pos=0) ... done
[10:19:24.636] resolve() on list ... DONE
[10:19:24.636] result() for ClusterFuture ...
[10:19:24.636] - result already collected: FutureResult
[10:19:24.636] result() for ClusterFuture ... done
[10:19:24.637] result() for ClusterFuture ...
[10:19:24.637] - result already collected: FutureResult
[10:19:24.637] result() for ClusterFuture ... done
[10:19:24.637] result() for ClusterFuture ...
[10:19:24.637] - result already collected: FutureResult
[10:19:24.637] result() for ClusterFuture ... done
[10:19:24.637] result() for ClusterFuture ...
[10:19:24.637] - result already collected: FutureResult
[10:19:24.637] result() for ClusterFuture ... done
[10:19:24.637]  - Number of value chunks collected: 2
[10:19:24.637] Resolving 2 futures (chunks) ... DONE
[10:19:24.637] Reducing values from 2 chunks ...
[10:19:24.638]  - Number of values collected after concatenation: 4
[10:19:24.638]  - Number of values expected: 4
[10:19:24.638] Reducing values from 2 chunks ... DONE
[10:19:24.638] future_mapply() ... DONE
[10:19:24.638] future_mapply() ...
[10:19:24.640] Number of chunks: 2
[10:19:24.640] getGlobalsAndPackagesXApply() ...
[10:19:24.640]  - future.globals: TRUE
[10:19:24.640] getGlobalsAndPackages() ...
[10:19:24.640] Searching for globals...
[10:19:24.641] - globals found: [1] ‘FUN’
[10:19:24.641] Searching for globals ... DONE
[10:19:24.641] Resolving globals: FALSE
[10:19:24.641] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:24.641] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:24.642] - globals: [1] ‘FUN’
[10:19:24.642] 
[10:19:24.642] getGlobalsAndPackages() ... DONE
[10:19:24.642]  - globals found/used: [n=1] ‘FUN’
[10:19:24.642]  - needed namespaces: [n=0] 
[10:19:24.642] Finding globals ... DONE
[10:19:24.642] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:24.642] List of 2
[10:19:24.642]  $ ...future.FUN:function (x, ...)  
[10:19:24.642]  $ MoreArgs     : NULL
[10:19:24.642]  - attr(*, "where")=List of 2
[10:19:24.642]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:24.642]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:24.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:24.642]  - attr(*, "resolved")= logi FALSE
[10:19:24.642]  - attr(*, "total_size")= num NA
[10:19:24.645] Packages to be attached in all futures: [n=0] 
[10:19:24.645] getGlobalsAndPackagesXApply() ... DONE
[10:19:24.645] Number of futures (= number of chunks): 2
[10:19:24.645] Launching 2 futures (chunks) ...
[10:19:24.645] Chunk #1 of 2 ...
[10:19:24.645]  - Finding globals in '...' for chunk #1 ...
[10:19:24.645] getGlobalsAndPackages() ...
[10:19:24.645] Searching for globals...
[10:19:24.646] 
[10:19:24.646] Searching for globals ... DONE
[10:19:24.646] - globals: [0] <none>
[10:19:24.646] getGlobalsAndPackages() ... DONE
[10:19:24.646]    + additional globals found: [n=0] 
[10:19:24.646]    + additional namespaces needed: [n=0] 
[10:19:24.646]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:24.646]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:24.647]  - seeds: <none>
[10:19:24.647]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.647] getGlobalsAndPackages() ...
[10:19:24.647] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.647] Resolving globals: FALSE
[10:19:24.647] The total size of the 5 globals is 265 bytes (265 bytes)
[10:19:24.648] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:24.648] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.648] 
[10:19:24.648] getGlobalsAndPackages() ... DONE
[10:19:24.648] run() for ‘Future’ ...
[10:19:24.648] - state: ‘created’
[10:19:24.649] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:24.662] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:24.662]   - Field: ‘node’
[10:19:24.663]   - Field: ‘label’
[10:19:24.663]   - Field: ‘local’
[10:19:24.663]   - Field: ‘owner’
[10:19:24.663]   - Field: ‘envir’
[10:19:24.663]   - Field: ‘workers’
[10:19:24.663]   - Field: ‘packages’
[10:19:24.663]   - Field: ‘gc’
[10:19:24.663]   - Field: ‘conditions’
[10:19:24.663]   - Field: ‘persistent’
[10:19:24.663]   - Field: ‘expr’
[10:19:24.663]   - Field: ‘uuid’
[10:19:24.664]   - Field: ‘seed’
[10:19:24.664]   - Field: ‘version’
[10:19:24.664]   - Field: ‘result’
[10:19:24.664]   - Field: ‘asynchronous’
[10:19:24.664]   - Field: ‘calls’
[10:19:24.664]   - Field: ‘globals’
[10:19:24.664]   - Field: ‘stdout’
[10:19:24.664]   - Field: ‘earlySignal’
[10:19:24.664]   - Field: ‘lazy’
[10:19:24.664]   - Field: ‘state’
[10:19:24.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:24.664] - Launch lazy future ...
[10:19:24.665] Packages needed by the future expression (n = 0): <none>
[10:19:24.665] Packages needed by future strategies (n = 0): <none>
[10:19:24.665] {
[10:19:24.665]     {
[10:19:24.665]         {
[10:19:24.665]             ...future.startTime <- base::Sys.time()
[10:19:24.665]             {
[10:19:24.665]                 {
[10:19:24.665]                   {
[10:19:24.665]                     {
[10:19:24.665]                       base::local({
[10:19:24.665]                         has_future <- base::requireNamespace("future", 
[10:19:24.665]                           quietly = TRUE)
[10:19:24.665]                         if (has_future) {
[10:19:24.665]                           ns <- base::getNamespace("future")
[10:19:24.665]                           version <- ns[[".package"]][["version"]]
[10:19:24.665]                           if (is.null(version)) 
[10:19:24.665]                             version <- utils::packageVersion("future")
[10:19:24.665]                         }
[10:19:24.665]                         else {
[10:19:24.665]                           version <- NULL
[10:19:24.665]                         }
[10:19:24.665]                         if (!has_future || version < "1.8.0") {
[10:19:24.665]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.665]                             "", base::R.version$version.string), 
[10:19:24.665]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.665]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.665]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.665]                               "release", "version")], collapse = " "), 
[10:19:24.665]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.665]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.665]                             info)
[10:19:24.665]                           info <- base::paste(info, collapse = "; ")
[10:19:24.665]                           if (!has_future) {
[10:19:24.665]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.665]                               info)
[10:19:24.665]                           }
[10:19:24.665]                           else {
[10:19:24.665]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.665]                               info, version)
[10:19:24.665]                           }
[10:19:24.665]                           base::stop(msg)
[10:19:24.665]                         }
[10:19:24.665]                       })
[10:19:24.665]                     }
[10:19:24.665]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.665]                     base::options(mc.cores = 1L)
[10:19:24.665]                   }
[10:19:24.665]                   ...future.strategy.old <- future::plan("list")
[10:19:24.665]                   options(future.plan = NULL)
[10:19:24.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.665]                 }
[10:19:24.665]                 ...future.workdir <- getwd()
[10:19:24.665]             }
[10:19:24.665]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.665]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.665]         }
[10:19:24.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.665]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:24.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.665]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.665]             base::names(...future.oldOptions))
[10:19:24.665]     }
[10:19:24.665]     if (FALSE) {
[10:19:24.665]     }
[10:19:24.665]     else {
[10:19:24.665]         if (TRUE) {
[10:19:24.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.665]                 open = "w")
[10:19:24.665]         }
[10:19:24.665]         else {
[10:19:24.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.665]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.665]         }
[10:19:24.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.665]             base::sink(type = "output", split = FALSE)
[10:19:24.665]             base::close(...future.stdout)
[10:19:24.665]         }, add = TRUE)
[10:19:24.665]     }
[10:19:24.665]     ...future.frame <- base::sys.nframe()
[10:19:24.665]     ...future.conditions <- base::list()
[10:19:24.665]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.665]     if (FALSE) {
[10:19:24.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.665]     }
[10:19:24.665]     ...future.result <- base::tryCatch({
[10:19:24.665]         base::withCallingHandlers({
[10:19:24.665]             ...future.value <- base::withVisible(base::local({
[10:19:24.665]                 ...future.makeSendCondition <- base::local({
[10:19:24.665]                   sendCondition <- NULL
[10:19:24.665]                   function(frame = 1L) {
[10:19:24.665]                     if (is.function(sendCondition)) 
[10:19:24.665]                       return(sendCondition)
[10:19:24.665]                     ns <- getNamespace("parallel")
[10:19:24.665]                     if (exists("sendData", mode = "function", 
[10:19:24.665]                       envir = ns)) {
[10:19:24.665]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.665]                         envir = ns)
[10:19:24.665]                       envir <- sys.frame(frame)
[10:19:24.665]                       master <- NULL
[10:19:24.665]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.665]                         !identical(envir, emptyenv())) {
[10:19:24.665]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.665]                           inherits = FALSE)) {
[10:19:24.665]                           master <- get("master", mode = "list", 
[10:19:24.665]                             envir = envir, inherits = FALSE)
[10:19:24.665]                           if (inherits(master, c("SOCKnode", 
[10:19:24.665]                             "SOCK0node"))) {
[10:19:24.665]                             sendCondition <<- function(cond) {
[10:19:24.665]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.665]                                 success = TRUE)
[10:19:24.665]                               parallel_sendData(master, data)
[10:19:24.665]                             }
[10:19:24.665]                             return(sendCondition)
[10:19:24.665]                           }
[10:19:24.665]                         }
[10:19:24.665]                         frame <- frame + 1L
[10:19:24.665]                         envir <- sys.frame(frame)
[10:19:24.665]                       }
[10:19:24.665]                     }
[10:19:24.665]                     sendCondition <<- function(cond) NULL
[10:19:24.665]                   }
[10:19:24.665]                 })
[10:19:24.665]                 withCallingHandlers({
[10:19:24.665]                   {
[10:19:24.665]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.665]                     if (!identical(...future.globals.maxSize.org, 
[10:19:24.665]                       ...future.globals.maxSize)) {
[10:19:24.665]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.665]                       on.exit(options(oopts), add = TRUE)
[10:19:24.665]                     }
[10:19:24.665]                     {
[10:19:24.665]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.665]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:24.665]                         USE.NAMES = FALSE)
[10:19:24.665]                       do.call(mapply, args = args)
[10:19:24.665]                     }
[10:19:24.665]                   }
[10:19:24.665]                 }, immediateCondition = function(cond) {
[10:19:24.665]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.665]                   sendCondition(cond)
[10:19:24.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.665]                   {
[10:19:24.665]                     inherits <- base::inherits
[10:19:24.665]                     invokeRestart <- base::invokeRestart
[10:19:24.665]                     is.null <- base::is.null
[10:19:24.665]                     muffled <- FALSE
[10:19:24.665]                     if (inherits(cond, "message")) {
[10:19:24.665]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.665]                       if (muffled) 
[10:19:24.665]                         invokeRestart("muffleMessage")
[10:19:24.665]                     }
[10:19:24.665]                     else if (inherits(cond, "warning")) {
[10:19:24.665]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.665]                       if (muffled) 
[10:19:24.665]                         invokeRestart("muffleWarning")
[10:19:24.665]                     }
[10:19:24.665]                     else if (inherits(cond, "condition")) {
[10:19:24.665]                       if (!is.null(pattern)) {
[10:19:24.665]                         computeRestarts <- base::computeRestarts
[10:19:24.665]                         grepl <- base::grepl
[10:19:24.665]                         restarts <- computeRestarts(cond)
[10:19:24.665]                         for (restart in restarts) {
[10:19:24.665]                           name <- restart$name
[10:19:24.665]                           if (is.null(name)) 
[10:19:24.665]                             next
[10:19:24.665]                           if (!grepl(pattern, name)) 
[10:19:24.665]                             next
[10:19:24.665]                           invokeRestart(restart)
[10:19:24.665]                           muffled <- TRUE
[10:19:24.665]                           break
[10:19:24.665]                         }
[10:19:24.665]                       }
[10:19:24.665]                     }
[10:19:24.665]                     invisible(muffled)
[10:19:24.665]                   }
[10:19:24.665]                   muffleCondition(cond)
[10:19:24.665]                 })
[10:19:24.665]             }))
[10:19:24.665]             future::FutureResult(value = ...future.value$value, 
[10:19:24.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.665]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.665]                     ...future.globalenv.names))
[10:19:24.665]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.665]         }, condition = base::local({
[10:19:24.665]             c <- base::c
[10:19:24.665]             inherits <- base::inherits
[10:19:24.665]             invokeRestart <- base::invokeRestart
[10:19:24.665]             length <- base::length
[10:19:24.665]             list <- base::list
[10:19:24.665]             seq.int <- base::seq.int
[10:19:24.665]             signalCondition <- base::signalCondition
[10:19:24.665]             sys.calls <- base::sys.calls
[10:19:24.665]             `[[` <- base::`[[`
[10:19:24.665]             `+` <- base::`+`
[10:19:24.665]             `<<-` <- base::`<<-`
[10:19:24.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.665]                   3L)]
[10:19:24.665]             }
[10:19:24.665]             function(cond) {
[10:19:24.665]                 is_error <- inherits(cond, "error")
[10:19:24.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.665]                   NULL)
[10:19:24.665]                 if (is_error) {
[10:19:24.665]                   sessionInformation <- function() {
[10:19:24.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.665]                       search = base::search(), system = base::Sys.info())
[10:19:24.665]                   }
[10:19:24.665]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.665]                     cond$call), session = sessionInformation(), 
[10:19:24.665]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.665]                   signalCondition(cond)
[10:19:24.665]                 }
[10:19:24.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.665]                 "immediateCondition"))) {
[10:19:24.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.665]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.665]                   if (TRUE && !signal) {
[10:19:24.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.665]                     {
[10:19:24.665]                       inherits <- base::inherits
[10:19:24.665]                       invokeRestart <- base::invokeRestart
[10:19:24.665]                       is.null <- base::is.null
[10:19:24.665]                       muffled <- FALSE
[10:19:24.665]                       if (inherits(cond, "message")) {
[10:19:24.665]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.665]                         if (muffled) 
[10:19:24.665]                           invokeRestart("muffleMessage")
[10:19:24.665]                       }
[10:19:24.665]                       else if (inherits(cond, "warning")) {
[10:19:24.665]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.665]                         if (muffled) 
[10:19:24.665]                           invokeRestart("muffleWarning")
[10:19:24.665]                       }
[10:19:24.665]                       else if (inherits(cond, "condition")) {
[10:19:24.665]                         if (!is.null(pattern)) {
[10:19:24.665]                           computeRestarts <- base::computeRestarts
[10:19:24.665]                           grepl <- base::grepl
[10:19:24.665]                           restarts <- computeRestarts(cond)
[10:19:24.665]                           for (restart in restarts) {
[10:19:24.665]                             name <- restart$name
[10:19:24.665]                             if (is.null(name)) 
[10:19:24.665]                               next
[10:19:24.665]                             if (!grepl(pattern, name)) 
[10:19:24.665]                               next
[10:19:24.665]                             invokeRestart(restart)
[10:19:24.665]                             muffled <- TRUE
[10:19:24.665]                             break
[10:19:24.665]                           }
[10:19:24.665]                         }
[10:19:24.665]                       }
[10:19:24.665]                       invisible(muffled)
[10:19:24.665]                     }
[10:19:24.665]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.665]                   }
[10:19:24.665]                 }
[10:19:24.665]                 else {
[10:19:24.665]                   if (TRUE) {
[10:19:24.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.665]                     {
[10:19:24.665]                       inherits <- base::inherits
[10:19:24.665]                       invokeRestart <- base::invokeRestart
[10:19:24.665]                       is.null <- base::is.null
[10:19:24.665]                       muffled <- FALSE
[10:19:24.665]                       if (inherits(cond, "message")) {
[10:19:24.665]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.665]                         if (muffled) 
[10:19:24.665]                           invokeRestart("muffleMessage")
[10:19:24.665]                       }
[10:19:24.665]                       else if (inherits(cond, "warning")) {
[10:19:24.665]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.665]                         if (muffled) 
[10:19:24.665]                           invokeRestart("muffleWarning")
[10:19:24.665]                       }
[10:19:24.665]                       else if (inherits(cond, "condition")) {
[10:19:24.665]                         if (!is.null(pattern)) {
[10:19:24.665]                           computeRestarts <- base::computeRestarts
[10:19:24.665]                           grepl <- base::grepl
[10:19:24.665]                           restarts <- computeRestarts(cond)
[10:19:24.665]                           for (restart in restarts) {
[10:19:24.665]                             name <- restart$name
[10:19:24.665]                             if (is.null(name)) 
[10:19:24.665]                               next
[10:19:24.665]                             if (!grepl(pattern, name)) 
[10:19:24.665]                               next
[10:19:24.665]                             invokeRestart(restart)
[10:19:24.665]                             muffled <- TRUE
[10:19:24.665]                             break
[10:19:24.665]                           }
[10:19:24.665]                         }
[10:19:24.665]                       }
[10:19:24.665]                       invisible(muffled)
[10:19:24.665]                     }
[10:19:24.665]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.665]                   }
[10:19:24.665]                 }
[10:19:24.665]             }
[10:19:24.665]         }))
[10:19:24.665]     }, error = function(ex) {
[10:19:24.665]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.665]                 ...future.rng), started = ...future.startTime, 
[10:19:24.665]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.665]             version = "1.8"), class = "FutureResult")
[10:19:24.665]     }, finally = {
[10:19:24.665]         if (!identical(...future.workdir, getwd())) 
[10:19:24.665]             setwd(...future.workdir)
[10:19:24.665]         {
[10:19:24.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.665]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.665]             }
[10:19:24.665]             base::options(...future.oldOptions)
[10:19:24.665]             if (.Platform$OS.type == "windows") {
[10:19:24.665]                 old_names <- names(...future.oldEnvVars)
[10:19:24.665]                 envs <- base::Sys.getenv()
[10:19:24.665]                 names <- names(envs)
[10:19:24.665]                 common <- intersect(names, old_names)
[10:19:24.665]                 added <- setdiff(names, old_names)
[10:19:24.665]                 removed <- setdiff(old_names, names)
[10:19:24.665]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.665]                   envs[common]]
[10:19:24.665]                 NAMES <- toupper(changed)
[10:19:24.665]                 args <- list()
[10:19:24.665]                 for (kk in seq_along(NAMES)) {
[10:19:24.665]                   name <- changed[[kk]]
[10:19:24.665]                   NAME <- NAMES[[kk]]
[10:19:24.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.665]                     next
[10:19:24.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.665]                 }
[10:19:24.665]                 NAMES <- toupper(added)
[10:19:24.665]                 for (kk in seq_along(NAMES)) {
[10:19:24.665]                   name <- added[[kk]]
[10:19:24.665]                   NAME <- NAMES[[kk]]
[10:19:24.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.665]                     next
[10:19:24.665]                   args[[name]] <- ""
[10:19:24.665]                 }
[10:19:24.665]                 NAMES <- toupper(removed)
[10:19:24.665]                 for (kk in seq_along(NAMES)) {
[10:19:24.665]                   name <- removed[[kk]]
[10:19:24.665]                   NAME <- NAMES[[kk]]
[10:19:24.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.665]                     next
[10:19:24.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.665]                 }
[10:19:24.665]                 if (length(args) > 0) 
[10:19:24.665]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.665]             }
[10:19:24.665]             else {
[10:19:24.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.665]             }
[10:19:24.665]             {
[10:19:24.665]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.665]                   0L) {
[10:19:24.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.665]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.665]                   base::options(opts)
[10:19:24.665]                 }
[10:19:24.665]                 {
[10:19:24.665]                   {
[10:19:24.665]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.665]                     NULL
[10:19:24.665]                   }
[10:19:24.665]                   options(future.plan = NULL)
[10:19:24.665]                   if (is.na(NA_character_)) 
[10:19:24.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.665]                     .init = FALSE)
[10:19:24.665]                 }
[10:19:24.665]             }
[10:19:24.665]         }
[10:19:24.665]     })
[10:19:24.665]     if (TRUE) {
[10:19:24.665]         base::sink(type = "output", split = FALSE)
[10:19:24.665]         if (TRUE) {
[10:19:24.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.665]         }
[10:19:24.665]         else {
[10:19:24.665]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.665]         }
[10:19:24.665]         base::close(...future.stdout)
[10:19:24.665]         ...future.stdout <- NULL
[10:19:24.665]     }
[10:19:24.665]     ...future.result$conditions <- ...future.conditions
[10:19:24.665]     ...future.result$finished <- base::Sys.time()
[10:19:24.665]     ...future.result
[10:19:24.665] }
[10:19:24.668] Exporting 5 global objects (715 bytes) to cluster node #1 ...
[10:19:24.668] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[10:19:24.669] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[10:19:24.669] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:24.669] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.669] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ...
[10:19:24.670] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ... DONE
[10:19:24.670] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:24.670] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.670] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:24.671] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.671] Exporting 5 global objects (715 bytes) to cluster node #1 ... DONE
[10:19:24.671] MultisessionFuture started
[10:19:24.671] - Launch lazy future ... done
[10:19:24.671] run() for ‘MultisessionFuture’ ... done
[10:19:24.671] Created future:
[10:19:24.672] MultisessionFuture:
[10:19:24.672] Label: ‘future_mapply-1’
[10:19:24.672] Expression:
[10:19:24.672] {
[10:19:24.672]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.672]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:24.672]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.672]         on.exit(options(oopts), add = TRUE)
[10:19:24.672]     }
[10:19:24.672]     {
[10:19:24.672]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.672]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:24.672]         do.call(mapply, args = args)
[10:19:24.672]     }
[10:19:24.672] }
[10:19:24.672] Lazy evaluation: FALSE
[10:19:24.672] Asynchronous evaluation: TRUE
[10:19:24.672] Local evaluation: TRUE
[10:19:24.672] Environment: R_GlobalEnv
[10:19:24.672] Capture standard output: TRUE
[10:19:24.672] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:24.672] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:24.672] Packages: <none>
[10:19:24.672] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:24.672] Resolved: FALSE
[10:19:24.672] Value: <not collected>
[10:19:24.672] Conditions captured: <none>
[10:19:24.672] Early signaling: FALSE
[10:19:24.672] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:24.672] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.683] Chunk #1 of 2 ... DONE
[10:19:24.683] Chunk #2 of 2 ...
[10:19:24.683]  - Finding globals in '...' for chunk #2 ...
[10:19:24.683] getGlobalsAndPackages() ...
[10:19:24.683] Searching for globals...
[10:19:24.684] 
[10:19:24.684] Searching for globals ... DONE
[10:19:24.684] - globals: [0] <none>
[10:19:24.684] getGlobalsAndPackages() ... DONE
[10:19:24.684]    + additional globals found: [n=0] 
[10:19:24.684]    + additional namespaces needed: [n=0] 
[10:19:24.684]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:24.684]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:24.684]  - seeds: <none>
[10:19:24.685]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.685] getGlobalsAndPackages() ...
[10:19:24.685] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.685] Resolving globals: FALSE
[10:19:24.685] The total size of the 5 globals is 265 bytes (265 bytes)
[10:19:24.686] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:24.686] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.686] 
[10:19:24.686] getGlobalsAndPackages() ... DONE
[10:19:24.686] run() for ‘Future’ ...
[10:19:24.686] - state: ‘created’
[10:19:24.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:24.700] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.700] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:24.700]   - Field: ‘node’
[10:19:24.700]   - Field: ‘label’
[10:19:24.700]   - Field: ‘local’
[10:19:24.700]   - Field: ‘owner’
[10:19:24.700]   - Field: ‘envir’
[10:19:24.701]   - Field: ‘workers’
[10:19:24.701]   - Field: ‘packages’
[10:19:24.701]   - Field: ‘gc’
[10:19:24.701]   - Field: ‘conditions’
[10:19:24.701]   - Field: ‘persistent’
[10:19:24.701]   - Field: ‘expr’
[10:19:24.701]   - Field: ‘uuid’
[10:19:24.701]   - Field: ‘seed’
[10:19:24.701]   - Field: ‘version’
[10:19:24.701]   - Field: ‘result’
[10:19:24.701]   - Field: ‘asynchronous’
[10:19:24.701]   - Field: ‘calls’
[10:19:24.702]   - Field: ‘globals’
[10:19:24.702]   - Field: ‘stdout’
[10:19:24.702]   - Field: ‘earlySignal’
[10:19:24.702]   - Field: ‘lazy’
[10:19:24.702]   - Field: ‘state’
[10:19:24.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:24.702] - Launch lazy future ...
[10:19:24.702] Packages needed by the future expression (n = 0): <none>
[10:19:24.702] Packages needed by future strategies (n = 0): <none>
[10:19:24.703] {
[10:19:24.703]     {
[10:19:24.703]         {
[10:19:24.703]             ...future.startTime <- base::Sys.time()
[10:19:24.703]             {
[10:19:24.703]                 {
[10:19:24.703]                   {
[10:19:24.703]                     {
[10:19:24.703]                       base::local({
[10:19:24.703]                         has_future <- base::requireNamespace("future", 
[10:19:24.703]                           quietly = TRUE)
[10:19:24.703]                         if (has_future) {
[10:19:24.703]                           ns <- base::getNamespace("future")
[10:19:24.703]                           version <- ns[[".package"]][["version"]]
[10:19:24.703]                           if (is.null(version)) 
[10:19:24.703]                             version <- utils::packageVersion("future")
[10:19:24.703]                         }
[10:19:24.703]                         else {
[10:19:24.703]                           version <- NULL
[10:19:24.703]                         }
[10:19:24.703]                         if (!has_future || version < "1.8.0") {
[10:19:24.703]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.703]                             "", base::R.version$version.string), 
[10:19:24.703]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.703]                               "release", "version")], collapse = " "), 
[10:19:24.703]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.703]                             info)
[10:19:24.703]                           info <- base::paste(info, collapse = "; ")
[10:19:24.703]                           if (!has_future) {
[10:19:24.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.703]                               info)
[10:19:24.703]                           }
[10:19:24.703]                           else {
[10:19:24.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.703]                               info, version)
[10:19:24.703]                           }
[10:19:24.703]                           base::stop(msg)
[10:19:24.703]                         }
[10:19:24.703]                       })
[10:19:24.703]                     }
[10:19:24.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.703]                     base::options(mc.cores = 1L)
[10:19:24.703]                   }
[10:19:24.703]                   ...future.strategy.old <- future::plan("list")
[10:19:24.703]                   options(future.plan = NULL)
[10:19:24.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.703]                 }
[10:19:24.703]                 ...future.workdir <- getwd()
[10:19:24.703]             }
[10:19:24.703]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.703]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.703]         }
[10:19:24.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.703]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:24.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.703]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.703]             base::names(...future.oldOptions))
[10:19:24.703]     }
[10:19:24.703]     if (FALSE) {
[10:19:24.703]     }
[10:19:24.703]     else {
[10:19:24.703]         if (TRUE) {
[10:19:24.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.703]                 open = "w")
[10:19:24.703]         }
[10:19:24.703]         else {
[10:19:24.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.703]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.703]         }
[10:19:24.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.703]             base::sink(type = "output", split = FALSE)
[10:19:24.703]             base::close(...future.stdout)
[10:19:24.703]         }, add = TRUE)
[10:19:24.703]     }
[10:19:24.703]     ...future.frame <- base::sys.nframe()
[10:19:24.703]     ...future.conditions <- base::list()
[10:19:24.703]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.703]     if (FALSE) {
[10:19:24.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.703]     }
[10:19:24.703]     ...future.result <- base::tryCatch({
[10:19:24.703]         base::withCallingHandlers({
[10:19:24.703]             ...future.value <- base::withVisible(base::local({
[10:19:24.703]                 ...future.makeSendCondition <- base::local({
[10:19:24.703]                   sendCondition <- NULL
[10:19:24.703]                   function(frame = 1L) {
[10:19:24.703]                     if (is.function(sendCondition)) 
[10:19:24.703]                       return(sendCondition)
[10:19:24.703]                     ns <- getNamespace("parallel")
[10:19:24.703]                     if (exists("sendData", mode = "function", 
[10:19:24.703]                       envir = ns)) {
[10:19:24.703]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.703]                         envir = ns)
[10:19:24.703]                       envir <- sys.frame(frame)
[10:19:24.703]                       master <- NULL
[10:19:24.703]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.703]                         !identical(envir, emptyenv())) {
[10:19:24.703]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.703]                           inherits = FALSE)) {
[10:19:24.703]                           master <- get("master", mode = "list", 
[10:19:24.703]                             envir = envir, inherits = FALSE)
[10:19:24.703]                           if (inherits(master, c("SOCKnode", 
[10:19:24.703]                             "SOCK0node"))) {
[10:19:24.703]                             sendCondition <<- function(cond) {
[10:19:24.703]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.703]                                 success = TRUE)
[10:19:24.703]                               parallel_sendData(master, data)
[10:19:24.703]                             }
[10:19:24.703]                             return(sendCondition)
[10:19:24.703]                           }
[10:19:24.703]                         }
[10:19:24.703]                         frame <- frame + 1L
[10:19:24.703]                         envir <- sys.frame(frame)
[10:19:24.703]                       }
[10:19:24.703]                     }
[10:19:24.703]                     sendCondition <<- function(cond) NULL
[10:19:24.703]                   }
[10:19:24.703]                 })
[10:19:24.703]                 withCallingHandlers({
[10:19:24.703]                   {
[10:19:24.703]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.703]                     if (!identical(...future.globals.maxSize.org, 
[10:19:24.703]                       ...future.globals.maxSize)) {
[10:19:24.703]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.703]                       on.exit(options(oopts), add = TRUE)
[10:19:24.703]                     }
[10:19:24.703]                     {
[10:19:24.703]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.703]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:24.703]                         USE.NAMES = FALSE)
[10:19:24.703]                       do.call(mapply, args = args)
[10:19:24.703]                     }
[10:19:24.703]                   }
[10:19:24.703]                 }, immediateCondition = function(cond) {
[10:19:24.703]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.703]                   sendCondition(cond)
[10:19:24.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.703]                   {
[10:19:24.703]                     inherits <- base::inherits
[10:19:24.703]                     invokeRestart <- base::invokeRestart
[10:19:24.703]                     is.null <- base::is.null
[10:19:24.703]                     muffled <- FALSE
[10:19:24.703]                     if (inherits(cond, "message")) {
[10:19:24.703]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.703]                       if (muffled) 
[10:19:24.703]                         invokeRestart("muffleMessage")
[10:19:24.703]                     }
[10:19:24.703]                     else if (inherits(cond, "warning")) {
[10:19:24.703]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.703]                       if (muffled) 
[10:19:24.703]                         invokeRestart("muffleWarning")
[10:19:24.703]                     }
[10:19:24.703]                     else if (inherits(cond, "condition")) {
[10:19:24.703]                       if (!is.null(pattern)) {
[10:19:24.703]                         computeRestarts <- base::computeRestarts
[10:19:24.703]                         grepl <- base::grepl
[10:19:24.703]                         restarts <- computeRestarts(cond)
[10:19:24.703]                         for (restart in restarts) {
[10:19:24.703]                           name <- restart$name
[10:19:24.703]                           if (is.null(name)) 
[10:19:24.703]                             next
[10:19:24.703]                           if (!grepl(pattern, name)) 
[10:19:24.703]                             next
[10:19:24.703]                           invokeRestart(restart)
[10:19:24.703]                           muffled <- TRUE
[10:19:24.703]                           break
[10:19:24.703]                         }
[10:19:24.703]                       }
[10:19:24.703]                     }
[10:19:24.703]                     invisible(muffled)
[10:19:24.703]                   }
[10:19:24.703]                   muffleCondition(cond)
[10:19:24.703]                 })
[10:19:24.703]             }))
[10:19:24.703]             future::FutureResult(value = ...future.value$value, 
[10:19:24.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.703]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.703]                     ...future.globalenv.names))
[10:19:24.703]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.703]         }, condition = base::local({
[10:19:24.703]             c <- base::c
[10:19:24.703]             inherits <- base::inherits
[10:19:24.703]             invokeRestart <- base::invokeRestart
[10:19:24.703]             length <- base::length
[10:19:24.703]             list <- base::list
[10:19:24.703]             seq.int <- base::seq.int
[10:19:24.703]             signalCondition <- base::signalCondition
[10:19:24.703]             sys.calls <- base::sys.calls
[10:19:24.703]             `[[` <- base::`[[`
[10:19:24.703]             `+` <- base::`+`
[10:19:24.703]             `<<-` <- base::`<<-`
[10:19:24.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.703]                   3L)]
[10:19:24.703]             }
[10:19:24.703]             function(cond) {
[10:19:24.703]                 is_error <- inherits(cond, "error")
[10:19:24.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.703]                   NULL)
[10:19:24.703]                 if (is_error) {
[10:19:24.703]                   sessionInformation <- function() {
[10:19:24.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.703]                       search = base::search(), system = base::Sys.info())
[10:19:24.703]                   }
[10:19:24.703]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.703]                     cond$call), session = sessionInformation(), 
[10:19:24.703]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.703]                   signalCondition(cond)
[10:19:24.703]                 }
[10:19:24.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.703]                 "immediateCondition"))) {
[10:19:24.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.703]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.703]                   if (TRUE && !signal) {
[10:19:24.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.703]                     {
[10:19:24.703]                       inherits <- base::inherits
[10:19:24.703]                       invokeRestart <- base::invokeRestart
[10:19:24.703]                       is.null <- base::is.null
[10:19:24.703]                       muffled <- FALSE
[10:19:24.703]                       if (inherits(cond, "message")) {
[10:19:24.703]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.703]                         if (muffled) 
[10:19:24.703]                           invokeRestart("muffleMessage")
[10:19:24.703]                       }
[10:19:24.703]                       else if (inherits(cond, "warning")) {
[10:19:24.703]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.703]                         if (muffled) 
[10:19:24.703]                           invokeRestart("muffleWarning")
[10:19:24.703]                       }
[10:19:24.703]                       else if (inherits(cond, "condition")) {
[10:19:24.703]                         if (!is.null(pattern)) {
[10:19:24.703]                           computeRestarts <- base::computeRestarts
[10:19:24.703]                           grepl <- base::grepl
[10:19:24.703]                           restarts <- computeRestarts(cond)
[10:19:24.703]                           for (restart in restarts) {
[10:19:24.703]                             name <- restart$name
[10:19:24.703]                             if (is.null(name)) 
[10:19:24.703]                               next
[10:19:24.703]                             if (!grepl(pattern, name)) 
[10:19:24.703]                               next
[10:19:24.703]                             invokeRestart(restart)
[10:19:24.703]                             muffled <- TRUE
[10:19:24.703]                             break
[10:19:24.703]                           }
[10:19:24.703]                         }
[10:19:24.703]                       }
[10:19:24.703]                       invisible(muffled)
[10:19:24.703]                     }
[10:19:24.703]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.703]                   }
[10:19:24.703]                 }
[10:19:24.703]                 else {
[10:19:24.703]                   if (TRUE) {
[10:19:24.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.703]                     {
[10:19:24.703]                       inherits <- base::inherits
[10:19:24.703]                       invokeRestart <- base::invokeRestart
[10:19:24.703]                       is.null <- base::is.null
[10:19:24.703]                       muffled <- FALSE
[10:19:24.703]                       if (inherits(cond, "message")) {
[10:19:24.703]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.703]                         if (muffled) 
[10:19:24.703]                           invokeRestart("muffleMessage")
[10:19:24.703]                       }
[10:19:24.703]                       else if (inherits(cond, "warning")) {
[10:19:24.703]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.703]                         if (muffled) 
[10:19:24.703]                           invokeRestart("muffleWarning")
[10:19:24.703]                       }
[10:19:24.703]                       else if (inherits(cond, "condition")) {
[10:19:24.703]                         if (!is.null(pattern)) {
[10:19:24.703]                           computeRestarts <- base::computeRestarts
[10:19:24.703]                           grepl <- base::grepl
[10:19:24.703]                           restarts <- computeRestarts(cond)
[10:19:24.703]                           for (restart in restarts) {
[10:19:24.703]                             name <- restart$name
[10:19:24.703]                             if (is.null(name)) 
[10:19:24.703]                               next
[10:19:24.703]                             if (!grepl(pattern, name)) 
[10:19:24.703]                               next
[10:19:24.703]                             invokeRestart(restart)
[10:19:24.703]                             muffled <- TRUE
[10:19:24.703]                             break
[10:19:24.703]                           }
[10:19:24.703]                         }
[10:19:24.703]                       }
[10:19:24.703]                       invisible(muffled)
[10:19:24.703]                     }
[10:19:24.703]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.703]                   }
[10:19:24.703]                 }
[10:19:24.703]             }
[10:19:24.703]         }))
[10:19:24.703]     }, error = function(ex) {
[10:19:24.703]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.703]                 ...future.rng), started = ...future.startTime, 
[10:19:24.703]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.703]             version = "1.8"), class = "FutureResult")
[10:19:24.703]     }, finally = {
[10:19:24.703]         if (!identical(...future.workdir, getwd())) 
[10:19:24.703]             setwd(...future.workdir)
[10:19:24.703]         {
[10:19:24.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.703]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.703]             }
[10:19:24.703]             base::options(...future.oldOptions)
[10:19:24.703]             if (.Platform$OS.type == "windows") {
[10:19:24.703]                 old_names <- names(...future.oldEnvVars)
[10:19:24.703]                 envs <- base::Sys.getenv()
[10:19:24.703]                 names <- names(envs)
[10:19:24.703]                 common <- intersect(names, old_names)
[10:19:24.703]                 added <- setdiff(names, old_names)
[10:19:24.703]                 removed <- setdiff(old_names, names)
[10:19:24.703]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.703]                   envs[common]]
[10:19:24.703]                 NAMES <- toupper(changed)
[10:19:24.703]                 args <- list()
[10:19:24.703]                 for (kk in seq_along(NAMES)) {
[10:19:24.703]                   name <- changed[[kk]]
[10:19:24.703]                   NAME <- NAMES[[kk]]
[10:19:24.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.703]                     next
[10:19:24.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.703]                 }
[10:19:24.703]                 NAMES <- toupper(added)
[10:19:24.703]                 for (kk in seq_along(NAMES)) {
[10:19:24.703]                   name <- added[[kk]]
[10:19:24.703]                   NAME <- NAMES[[kk]]
[10:19:24.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.703]                     next
[10:19:24.703]                   args[[name]] <- ""
[10:19:24.703]                 }
[10:19:24.703]                 NAMES <- toupper(removed)
[10:19:24.703]                 for (kk in seq_along(NAMES)) {
[10:19:24.703]                   name <- removed[[kk]]
[10:19:24.703]                   NAME <- NAMES[[kk]]
[10:19:24.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.703]                     next
[10:19:24.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.703]                 }
[10:19:24.703]                 if (length(args) > 0) 
[10:19:24.703]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.703]             }
[10:19:24.703]             else {
[10:19:24.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.703]             }
[10:19:24.703]             {
[10:19:24.703]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.703]                   0L) {
[10:19:24.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.703]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.703]                   base::options(opts)
[10:19:24.703]                 }
[10:19:24.703]                 {
[10:19:24.703]                   {
[10:19:24.703]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.703]                     NULL
[10:19:24.703]                   }
[10:19:24.703]                   options(future.plan = NULL)
[10:19:24.703]                   if (is.na(NA_character_)) 
[10:19:24.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.703]                     .init = FALSE)
[10:19:24.703]                 }
[10:19:24.703]             }
[10:19:24.703]         }
[10:19:24.703]     })
[10:19:24.703]     if (TRUE) {
[10:19:24.703]         base::sink(type = "output", split = FALSE)
[10:19:24.703]         if (TRUE) {
[10:19:24.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.703]         }
[10:19:24.703]         else {
[10:19:24.703]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.703]         }
[10:19:24.703]         base::close(...future.stdout)
[10:19:24.703]         ...future.stdout <- NULL
[10:19:24.703]     }
[10:19:24.703]     ...future.result$conditions <- ...future.conditions
[10:19:24.703]     ...future.result$finished <- base::Sys.time()
[10:19:24.703]     ...future.result
[10:19:24.703] }
[10:19:24.705] Exporting 5 global objects (715 bytes) to cluster node #2 ...
[10:19:24.706] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[10:19:24.706] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[10:19:24.706] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:24.706] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.706] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #2 ...
[10:19:24.707] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #2 ... DONE
[10:19:24.707] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:24.707] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.707] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:24.708] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.708] Exporting 5 global objects (715 bytes) to cluster node #2 ... DONE
[10:19:24.708] MultisessionFuture started
[10:19:24.708] - Launch lazy future ... done
[10:19:24.708] run() for ‘MultisessionFuture’ ... done
[10:19:24.708] Created future:
[10:19:24.708] MultisessionFuture:
[10:19:24.708] Label: ‘future_mapply-2’
[10:19:24.708] Expression:
[10:19:24.708] {
[10:19:24.708]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.708]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:24.708]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.708]         on.exit(options(oopts), add = TRUE)
[10:19:24.708]     }
[10:19:24.708]     {
[10:19:24.708]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.708]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:24.708]         do.call(mapply, args = args)
[10:19:24.708]     }
[10:19:24.708] }
[10:19:24.708] Lazy evaluation: FALSE
[10:19:24.708] Asynchronous evaluation: TRUE
[10:19:24.708] Local evaluation: TRUE
[10:19:24.708] Environment: R_GlobalEnv
[10:19:24.708] Capture standard output: TRUE
[10:19:24.708] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:24.708] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:24.708] Packages: <none>
[10:19:24.708] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:24.708] Resolved: FALSE
[10:19:24.708] Value: <not collected>
[10:19:24.708] Conditions captured: <none>
[10:19:24.708] Early signaling: FALSE
[10:19:24.708] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:24.708] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.720] Chunk #2 of 2 ... DONE
[10:19:24.720] Launching 2 futures (chunks) ... DONE
[10:19:24.720] Resolving 2 futures (chunks) ...
[10:19:24.720] resolve() on list ...
[10:19:24.720]  recursive: 0
[10:19:24.720]  length: 2
[10:19:24.720] 
[10:19:24.721] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.721] - Validating connection of MultisessionFuture
[10:19:24.721] - received message: FutureResult
[10:19:24.721] - Received FutureResult
[10:19:24.721] - Erased future from FutureRegistry
[10:19:24.721] result() for ClusterFuture ...
[10:19:24.722] - result already collected: FutureResult
[10:19:24.722] result() for ClusterFuture ... done
[10:19:24.722] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.722] Future #1
[10:19:24.722] result() for ClusterFuture ...
[10:19:24.722] - result already collected: FutureResult
[10:19:24.722] result() for ClusterFuture ... done
[10:19:24.722] result() for ClusterFuture ...
[10:19:24.722] - result already collected: FutureResult
[10:19:24.722] result() for ClusterFuture ... done
[10:19:24.722] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:24.722] - nx: 2
[10:19:24.723] - relay: TRUE
[10:19:24.723] - stdout: TRUE
[10:19:24.723] - signal: TRUE
[10:19:24.723] - resignal: FALSE
[10:19:24.723] - force: TRUE
[10:19:24.723] - relayed: [n=2] FALSE, FALSE
[10:19:24.723] - queued futures: [n=2] FALSE, FALSE
[10:19:24.723]  - until=1
[10:19:24.723]  - relaying element #1
[10:19:24.723] result() for ClusterFuture ...
[10:19:24.723] - result already collected: FutureResult
[10:19:24.723] result() for ClusterFuture ... done
[10:19:24.724] result() for ClusterFuture ...
[10:19:24.724] - result already collected: FutureResult
[10:19:24.724] result() for ClusterFuture ... done
[10:19:24.724] result() for ClusterFuture ...
[10:19:24.724] - result already collected: FutureResult
[10:19:24.724] result() for ClusterFuture ... done
[10:19:24.724] result() for ClusterFuture ...
[10:19:24.724] - result already collected: FutureResult
[10:19:24.724] result() for ClusterFuture ... done
[10:19:24.724] - relayed: [n=2] TRUE, FALSE
[10:19:24.724] - queued futures: [n=2] TRUE, FALSE
[10:19:24.724] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:24.725]  length: 1 (resolved future 1)
[10:19:24.750] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.750] - Validating connection of MultisessionFuture
[10:19:24.750] - received message: FutureResult
[10:19:24.750] - Received FutureResult
[10:19:24.751] - Erased future from FutureRegistry
[10:19:24.751] result() for ClusterFuture ...
[10:19:24.751] - result already collected: FutureResult
[10:19:24.751] result() for ClusterFuture ... done
[10:19:24.751] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.751] Future #2
[10:19:24.751] result() for ClusterFuture ...
[10:19:24.751] - result already collected: FutureResult
[10:19:24.751] result() for ClusterFuture ... done
[10:19:24.751] result() for ClusterFuture ...
[10:19:24.751] - result already collected: FutureResult
[10:19:24.751] result() for ClusterFuture ... done
[10:19:24.752] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:24.752] - nx: 2
[10:19:24.752] - relay: TRUE
[10:19:24.752] - stdout: TRUE
[10:19:24.752] - signal: TRUE
[10:19:24.752] - resignal: FALSE
[10:19:24.752] - force: TRUE
[10:19:24.752] - relayed: [n=2] TRUE, FALSE
[10:19:24.752] - queued futures: [n=2] TRUE, FALSE
[10:19:24.752]  - until=2
[10:19:24.752]  - relaying element #2
[10:19:24.752] result() for ClusterFuture ...
[10:19:24.753] - result already collected: FutureResult
[10:19:24.753] result() for ClusterFuture ... done
[10:19:24.753] result() for ClusterFuture ...
[10:19:24.753] - result already collected: FutureResult
[10:19:24.753] result() for ClusterFuture ... done
[10:19:24.753] result() for ClusterFuture ...
[10:19:24.753] - result already collected: FutureResult
[10:19:24.753] result() for ClusterFuture ... done
[10:19:24.753] result() for ClusterFuture ...
[10:19:24.753] - result already collected: FutureResult
[10:19:24.753] result() for ClusterFuture ... done
[10:19:24.754] - relayed: [n=2] TRUE, TRUE
[10:19:24.754] - queued futures: [n=2] TRUE, TRUE
[10:19:24.754] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:24.756]  length: 0 (resolved future 2)
[10:19:24.756] Relaying remaining futures
[10:19:24.756] signalConditionsASAP(NULL, pos=0) ...
[10:19:24.756] - nx: 2
[10:19:24.756] - relay: TRUE
[10:19:24.756] - stdout: TRUE
[10:19:24.756] - signal: TRUE
[10:19:24.756] - resignal: FALSE
[10:19:24.756] - force: TRUE
[10:19:24.756] - relayed: [n=2] TRUE, TRUE
[10:19:24.756] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:24.757] - relayed: [n=2] TRUE, TRUE
[10:19:24.757] - queued futures: [n=2] TRUE, TRUE
[10:19:24.757] signalConditionsASAP(NULL, pos=0) ... done
[10:19:24.757] resolve() on list ... DONE
[10:19:24.757] result() for ClusterFuture ...
[10:19:24.757] - result already collected: FutureResult
[10:19:24.757] result() for ClusterFuture ... done
[10:19:24.757] result() for ClusterFuture ...
[10:19:24.757] - result already collected: FutureResult
[10:19:24.757] result() for ClusterFuture ... done
[10:19:24.757] result() for ClusterFuture ...
[10:19:24.757] - result already collected: FutureResult
[10:19:24.758] result() for ClusterFuture ... done
[10:19:24.758] result() for ClusterFuture ...
[10:19:24.758] - result already collected: FutureResult
[10:19:24.758] result() for ClusterFuture ... done
[10:19:24.758]  - Number of value chunks collected: 2
[10:19:24.758] Resolving 2 futures (chunks) ... DONE
[10:19:24.758] Reducing values from 2 chunks ...
[10:19:24.758]  - Number of values collected after concatenation: 4
[10:19:24.758]  - Number of values expected: 4
[10:19:24.758] Reducing values from 2 chunks ... DONE
[10:19:24.758] future_mapply() ... DONE
[10:19:24.759] future_mapply() ...
[10:19:24.760] Number of chunks: 2
[10:19:24.760] getGlobalsAndPackagesXApply() ...
[10:19:24.760]  - future.globals: TRUE
[10:19:24.761] getGlobalsAndPackages() ...
[10:19:24.761] Searching for globals...
[10:19:24.761] - globals found: [1] ‘FUN’
[10:19:24.761] Searching for globals ... DONE
[10:19:24.761] Resolving globals: FALSE
[10:19:24.762] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:24.762] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:24.762] - globals: [1] ‘FUN’
[10:19:24.762] 
[10:19:24.762] getGlobalsAndPackages() ... DONE
[10:19:24.762]  - globals found/used: [n=1] ‘FUN’
[10:19:24.762]  - needed namespaces: [n=0] 
[10:19:24.762] Finding globals ... DONE
[10:19:24.763] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:24.763] List of 2
[10:19:24.763]  $ ...future.FUN:function (x, ...)  
[10:19:24.763]  $ MoreArgs     :List of 1
[10:19:24.763]   ..$ x: num 42
[10:19:24.763]  - attr(*, "where")=List of 2
[10:19:24.763]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:24.763]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:24.763]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:24.763]  - attr(*, "resolved")= logi FALSE
[10:19:24.763]  - attr(*, "total_size")= num NA
[10:19:24.765] Packages to be attached in all futures: [n=0] 
[10:19:24.766] getGlobalsAndPackagesXApply() ... DONE
[10:19:24.766] Number of futures (= number of chunks): 2
[10:19:24.766] Launching 2 futures (chunks) ...
[10:19:24.766] Chunk #1 of 2 ...
[10:19:24.766]  - Finding globals in '...' for chunk #1 ...
[10:19:24.766] getGlobalsAndPackages() ...
[10:19:24.766] Searching for globals...
[10:19:24.766] 
[10:19:24.767] Searching for globals ... DONE
[10:19:24.767] - globals: [0] <none>
[10:19:24.767] getGlobalsAndPackages() ... DONE
[10:19:24.767]    + additional globals found: [n=0] 
[10:19:24.767]    + additional namespaces needed: [n=0] 
[10:19:24.767]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:24.767]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:24.767]  - seeds: <none>
[10:19:24.767]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.767] getGlobalsAndPackages() ...
[10:19:24.767] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.768] Resolving globals: FALSE
[10:19:24.768] The total size of the 5 globals is 286 bytes (286 bytes)
[10:19:24.768] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[10:19:24.768] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.769] 
[10:19:24.769] getGlobalsAndPackages() ... DONE
[10:19:24.769] run() for ‘Future’ ...
[10:19:24.769] - state: ‘created’
[10:19:24.769] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:24.784] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:24.784]   - Field: ‘node’
[10:19:24.784]   - Field: ‘label’
[10:19:24.784]   - Field: ‘local’
[10:19:24.784]   - Field: ‘owner’
[10:19:24.784]   - Field: ‘envir’
[10:19:24.784]   - Field: ‘workers’
[10:19:24.784]   - Field: ‘packages’
[10:19:24.784]   - Field: ‘gc’
[10:19:24.785]   - Field: ‘conditions’
[10:19:24.785]   - Field: ‘persistent’
[10:19:24.785]   - Field: ‘expr’
[10:19:24.785]   - Field: ‘uuid’
[10:19:24.785]   - Field: ‘seed’
[10:19:24.785]   - Field: ‘version’
[10:19:24.785]   - Field: ‘result’
[10:19:24.785]   - Field: ‘asynchronous’
[10:19:24.785]   - Field: ‘calls’
[10:19:24.785]   - Field: ‘globals’
[10:19:24.785]   - Field: ‘stdout’
[10:19:24.785]   - Field: ‘earlySignal’
[10:19:24.786]   - Field: ‘lazy’
[10:19:24.786]   - Field: ‘state’
[10:19:24.786] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:24.786] - Launch lazy future ...
[10:19:24.786] Packages needed by the future expression (n = 0): <none>
[10:19:24.786] Packages needed by future strategies (n = 0): <none>
[10:19:24.787] {
[10:19:24.787]     {
[10:19:24.787]         {
[10:19:24.787]             ...future.startTime <- base::Sys.time()
[10:19:24.787]             {
[10:19:24.787]                 {
[10:19:24.787]                   {
[10:19:24.787]                     {
[10:19:24.787]                       base::local({
[10:19:24.787]                         has_future <- base::requireNamespace("future", 
[10:19:24.787]                           quietly = TRUE)
[10:19:24.787]                         if (has_future) {
[10:19:24.787]                           ns <- base::getNamespace("future")
[10:19:24.787]                           version <- ns[[".package"]][["version"]]
[10:19:24.787]                           if (is.null(version)) 
[10:19:24.787]                             version <- utils::packageVersion("future")
[10:19:24.787]                         }
[10:19:24.787]                         else {
[10:19:24.787]                           version <- NULL
[10:19:24.787]                         }
[10:19:24.787]                         if (!has_future || version < "1.8.0") {
[10:19:24.787]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.787]                             "", base::R.version$version.string), 
[10:19:24.787]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.787]                               "release", "version")], collapse = " "), 
[10:19:24.787]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.787]                             info)
[10:19:24.787]                           info <- base::paste(info, collapse = "; ")
[10:19:24.787]                           if (!has_future) {
[10:19:24.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.787]                               info)
[10:19:24.787]                           }
[10:19:24.787]                           else {
[10:19:24.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.787]                               info, version)
[10:19:24.787]                           }
[10:19:24.787]                           base::stop(msg)
[10:19:24.787]                         }
[10:19:24.787]                       })
[10:19:24.787]                     }
[10:19:24.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.787]                     base::options(mc.cores = 1L)
[10:19:24.787]                   }
[10:19:24.787]                   ...future.strategy.old <- future::plan("list")
[10:19:24.787]                   options(future.plan = NULL)
[10:19:24.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.787]                 }
[10:19:24.787]                 ...future.workdir <- getwd()
[10:19:24.787]             }
[10:19:24.787]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.787]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.787]         }
[10:19:24.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.787]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:24.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.787]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.787]             base::names(...future.oldOptions))
[10:19:24.787]     }
[10:19:24.787]     if (FALSE) {
[10:19:24.787]     }
[10:19:24.787]     else {
[10:19:24.787]         if (TRUE) {
[10:19:24.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.787]                 open = "w")
[10:19:24.787]         }
[10:19:24.787]         else {
[10:19:24.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.787]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.787]         }
[10:19:24.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.787]             base::sink(type = "output", split = FALSE)
[10:19:24.787]             base::close(...future.stdout)
[10:19:24.787]         }, add = TRUE)
[10:19:24.787]     }
[10:19:24.787]     ...future.frame <- base::sys.nframe()
[10:19:24.787]     ...future.conditions <- base::list()
[10:19:24.787]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.787]     if (FALSE) {
[10:19:24.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.787]     }
[10:19:24.787]     ...future.result <- base::tryCatch({
[10:19:24.787]         base::withCallingHandlers({
[10:19:24.787]             ...future.value <- base::withVisible(base::local({
[10:19:24.787]                 ...future.makeSendCondition <- base::local({
[10:19:24.787]                   sendCondition <- NULL
[10:19:24.787]                   function(frame = 1L) {
[10:19:24.787]                     if (is.function(sendCondition)) 
[10:19:24.787]                       return(sendCondition)
[10:19:24.787]                     ns <- getNamespace("parallel")
[10:19:24.787]                     if (exists("sendData", mode = "function", 
[10:19:24.787]                       envir = ns)) {
[10:19:24.787]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.787]                         envir = ns)
[10:19:24.787]                       envir <- sys.frame(frame)
[10:19:24.787]                       master <- NULL
[10:19:24.787]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.787]                         !identical(envir, emptyenv())) {
[10:19:24.787]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.787]                           inherits = FALSE)) {
[10:19:24.787]                           master <- get("master", mode = "list", 
[10:19:24.787]                             envir = envir, inherits = FALSE)
[10:19:24.787]                           if (inherits(master, c("SOCKnode", 
[10:19:24.787]                             "SOCK0node"))) {
[10:19:24.787]                             sendCondition <<- function(cond) {
[10:19:24.787]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.787]                                 success = TRUE)
[10:19:24.787]                               parallel_sendData(master, data)
[10:19:24.787]                             }
[10:19:24.787]                             return(sendCondition)
[10:19:24.787]                           }
[10:19:24.787]                         }
[10:19:24.787]                         frame <- frame + 1L
[10:19:24.787]                         envir <- sys.frame(frame)
[10:19:24.787]                       }
[10:19:24.787]                     }
[10:19:24.787]                     sendCondition <<- function(cond) NULL
[10:19:24.787]                   }
[10:19:24.787]                 })
[10:19:24.787]                 withCallingHandlers({
[10:19:24.787]                   {
[10:19:24.787]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.787]                     if (!identical(...future.globals.maxSize.org, 
[10:19:24.787]                       ...future.globals.maxSize)) {
[10:19:24.787]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.787]                       on.exit(options(oopts), add = TRUE)
[10:19:24.787]                     }
[10:19:24.787]                     {
[10:19:24.787]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.787]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:24.787]                         USE.NAMES = FALSE)
[10:19:24.787]                       do.call(mapply, args = args)
[10:19:24.787]                     }
[10:19:24.787]                   }
[10:19:24.787]                 }, immediateCondition = function(cond) {
[10:19:24.787]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.787]                   sendCondition(cond)
[10:19:24.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.787]                   {
[10:19:24.787]                     inherits <- base::inherits
[10:19:24.787]                     invokeRestart <- base::invokeRestart
[10:19:24.787]                     is.null <- base::is.null
[10:19:24.787]                     muffled <- FALSE
[10:19:24.787]                     if (inherits(cond, "message")) {
[10:19:24.787]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.787]                       if (muffled) 
[10:19:24.787]                         invokeRestart("muffleMessage")
[10:19:24.787]                     }
[10:19:24.787]                     else if (inherits(cond, "warning")) {
[10:19:24.787]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.787]                       if (muffled) 
[10:19:24.787]                         invokeRestart("muffleWarning")
[10:19:24.787]                     }
[10:19:24.787]                     else if (inherits(cond, "condition")) {
[10:19:24.787]                       if (!is.null(pattern)) {
[10:19:24.787]                         computeRestarts <- base::computeRestarts
[10:19:24.787]                         grepl <- base::grepl
[10:19:24.787]                         restarts <- computeRestarts(cond)
[10:19:24.787]                         for (restart in restarts) {
[10:19:24.787]                           name <- restart$name
[10:19:24.787]                           if (is.null(name)) 
[10:19:24.787]                             next
[10:19:24.787]                           if (!grepl(pattern, name)) 
[10:19:24.787]                             next
[10:19:24.787]                           invokeRestart(restart)
[10:19:24.787]                           muffled <- TRUE
[10:19:24.787]                           break
[10:19:24.787]                         }
[10:19:24.787]                       }
[10:19:24.787]                     }
[10:19:24.787]                     invisible(muffled)
[10:19:24.787]                   }
[10:19:24.787]                   muffleCondition(cond)
[10:19:24.787]                 })
[10:19:24.787]             }))
[10:19:24.787]             future::FutureResult(value = ...future.value$value, 
[10:19:24.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.787]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.787]                     ...future.globalenv.names))
[10:19:24.787]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.787]         }, condition = base::local({
[10:19:24.787]             c <- base::c
[10:19:24.787]             inherits <- base::inherits
[10:19:24.787]             invokeRestart <- base::invokeRestart
[10:19:24.787]             length <- base::length
[10:19:24.787]             list <- base::list
[10:19:24.787]             seq.int <- base::seq.int
[10:19:24.787]             signalCondition <- base::signalCondition
[10:19:24.787]             sys.calls <- base::sys.calls
[10:19:24.787]             `[[` <- base::`[[`
[10:19:24.787]             `+` <- base::`+`
[10:19:24.787]             `<<-` <- base::`<<-`
[10:19:24.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.787]                   3L)]
[10:19:24.787]             }
[10:19:24.787]             function(cond) {
[10:19:24.787]                 is_error <- inherits(cond, "error")
[10:19:24.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.787]                   NULL)
[10:19:24.787]                 if (is_error) {
[10:19:24.787]                   sessionInformation <- function() {
[10:19:24.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.787]                       search = base::search(), system = base::Sys.info())
[10:19:24.787]                   }
[10:19:24.787]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.787]                     cond$call), session = sessionInformation(), 
[10:19:24.787]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.787]                   signalCondition(cond)
[10:19:24.787]                 }
[10:19:24.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.787]                 "immediateCondition"))) {
[10:19:24.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.787]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.787]                   if (TRUE && !signal) {
[10:19:24.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.787]                     {
[10:19:24.787]                       inherits <- base::inherits
[10:19:24.787]                       invokeRestart <- base::invokeRestart
[10:19:24.787]                       is.null <- base::is.null
[10:19:24.787]                       muffled <- FALSE
[10:19:24.787]                       if (inherits(cond, "message")) {
[10:19:24.787]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.787]                         if (muffled) 
[10:19:24.787]                           invokeRestart("muffleMessage")
[10:19:24.787]                       }
[10:19:24.787]                       else if (inherits(cond, "warning")) {
[10:19:24.787]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.787]                         if (muffled) 
[10:19:24.787]                           invokeRestart("muffleWarning")
[10:19:24.787]                       }
[10:19:24.787]                       else if (inherits(cond, "condition")) {
[10:19:24.787]                         if (!is.null(pattern)) {
[10:19:24.787]                           computeRestarts <- base::computeRestarts
[10:19:24.787]                           grepl <- base::grepl
[10:19:24.787]                           restarts <- computeRestarts(cond)
[10:19:24.787]                           for (restart in restarts) {
[10:19:24.787]                             name <- restart$name
[10:19:24.787]                             if (is.null(name)) 
[10:19:24.787]                               next
[10:19:24.787]                             if (!grepl(pattern, name)) 
[10:19:24.787]                               next
[10:19:24.787]                             invokeRestart(restart)
[10:19:24.787]                             muffled <- TRUE
[10:19:24.787]                             break
[10:19:24.787]                           }
[10:19:24.787]                         }
[10:19:24.787]                       }
[10:19:24.787]                       invisible(muffled)
[10:19:24.787]                     }
[10:19:24.787]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.787]                   }
[10:19:24.787]                 }
[10:19:24.787]                 else {
[10:19:24.787]                   if (TRUE) {
[10:19:24.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.787]                     {
[10:19:24.787]                       inherits <- base::inherits
[10:19:24.787]                       invokeRestart <- base::invokeRestart
[10:19:24.787]                       is.null <- base::is.null
[10:19:24.787]                       muffled <- FALSE
[10:19:24.787]                       if (inherits(cond, "message")) {
[10:19:24.787]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.787]                         if (muffled) 
[10:19:24.787]                           invokeRestart("muffleMessage")
[10:19:24.787]                       }
[10:19:24.787]                       else if (inherits(cond, "warning")) {
[10:19:24.787]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.787]                         if (muffled) 
[10:19:24.787]                           invokeRestart("muffleWarning")
[10:19:24.787]                       }
[10:19:24.787]                       else if (inherits(cond, "condition")) {
[10:19:24.787]                         if (!is.null(pattern)) {
[10:19:24.787]                           computeRestarts <- base::computeRestarts
[10:19:24.787]                           grepl <- base::grepl
[10:19:24.787]                           restarts <- computeRestarts(cond)
[10:19:24.787]                           for (restart in restarts) {
[10:19:24.787]                             name <- restart$name
[10:19:24.787]                             if (is.null(name)) 
[10:19:24.787]                               next
[10:19:24.787]                             if (!grepl(pattern, name)) 
[10:19:24.787]                               next
[10:19:24.787]                             invokeRestart(restart)
[10:19:24.787]                             muffled <- TRUE
[10:19:24.787]                             break
[10:19:24.787]                           }
[10:19:24.787]                         }
[10:19:24.787]                       }
[10:19:24.787]                       invisible(muffled)
[10:19:24.787]                     }
[10:19:24.787]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.787]                   }
[10:19:24.787]                 }
[10:19:24.787]             }
[10:19:24.787]         }))
[10:19:24.787]     }, error = function(ex) {
[10:19:24.787]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.787]                 ...future.rng), started = ...future.startTime, 
[10:19:24.787]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.787]             version = "1.8"), class = "FutureResult")
[10:19:24.787]     }, finally = {
[10:19:24.787]         if (!identical(...future.workdir, getwd())) 
[10:19:24.787]             setwd(...future.workdir)
[10:19:24.787]         {
[10:19:24.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.787]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.787]             }
[10:19:24.787]             base::options(...future.oldOptions)
[10:19:24.787]             if (.Platform$OS.type == "windows") {
[10:19:24.787]                 old_names <- names(...future.oldEnvVars)
[10:19:24.787]                 envs <- base::Sys.getenv()
[10:19:24.787]                 names <- names(envs)
[10:19:24.787]                 common <- intersect(names, old_names)
[10:19:24.787]                 added <- setdiff(names, old_names)
[10:19:24.787]                 removed <- setdiff(old_names, names)
[10:19:24.787]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.787]                   envs[common]]
[10:19:24.787]                 NAMES <- toupper(changed)
[10:19:24.787]                 args <- list()
[10:19:24.787]                 for (kk in seq_along(NAMES)) {
[10:19:24.787]                   name <- changed[[kk]]
[10:19:24.787]                   NAME <- NAMES[[kk]]
[10:19:24.787]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.787]                     next
[10:19:24.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.787]                 }
[10:19:24.787]                 NAMES <- toupper(added)
[10:19:24.787]                 for (kk in seq_along(NAMES)) {
[10:19:24.787]                   name <- added[[kk]]
[10:19:24.787]                   NAME <- NAMES[[kk]]
[10:19:24.787]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.787]                     next
[10:19:24.787]                   args[[name]] <- ""
[10:19:24.787]                 }
[10:19:24.787]                 NAMES <- toupper(removed)
[10:19:24.787]                 for (kk in seq_along(NAMES)) {
[10:19:24.787]                   name <- removed[[kk]]
[10:19:24.787]                   NAME <- NAMES[[kk]]
[10:19:24.787]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.787]                     next
[10:19:24.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.787]                 }
[10:19:24.787]                 if (length(args) > 0) 
[10:19:24.787]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.787]             }
[10:19:24.787]             else {
[10:19:24.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.787]             }
[10:19:24.787]             {
[10:19:24.787]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.787]                   0L) {
[10:19:24.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.787]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.787]                   base::options(opts)
[10:19:24.787]                 }
[10:19:24.787]                 {
[10:19:24.787]                   {
[10:19:24.787]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.787]                     NULL
[10:19:24.787]                   }
[10:19:24.787]                   options(future.plan = NULL)
[10:19:24.787]                   if (is.na(NA_character_)) 
[10:19:24.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.787]                     .init = FALSE)
[10:19:24.787]                 }
[10:19:24.787]             }
[10:19:24.787]         }
[10:19:24.787]     })
[10:19:24.787]     if (TRUE) {
[10:19:24.787]         base::sink(type = "output", split = FALSE)
[10:19:24.787]         if (TRUE) {
[10:19:24.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.787]         }
[10:19:24.787]         else {
[10:19:24.787]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.787]         }
[10:19:24.787]         base::close(...future.stdout)
[10:19:24.787]         ...future.stdout <- NULL
[10:19:24.787]     }
[10:19:24.787]     ...future.result$conditions <- ...future.conditions
[10:19:24.787]     ...future.result$finished <- base::Sys.time()
[10:19:24.787]     ...future.result
[10:19:24.787] }
[10:19:24.789] Exporting 5 global objects (723 bytes) to cluster node #1 ...
[10:19:24.789] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[10:19:24.790] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[10:19:24.790] Exporting ‘MoreArgs’ (89 bytes) to cluster node #1 ...
[10:19:24.790] Exporting ‘MoreArgs’ (89 bytes) to cluster node #1 ... DONE
[10:19:24.791] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #1 ...
[10:19:24.791] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #1 ... DONE
[10:19:24.791] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:24.791] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.792] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:24.792] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.792] Exporting 5 global objects (723 bytes) to cluster node #1 ... DONE
[10:19:24.792] MultisessionFuture started
[10:19:24.793] - Launch lazy future ... done
[10:19:24.793] run() for ‘MultisessionFuture’ ... done
[10:19:24.793] Created future:
[10:19:24.793] MultisessionFuture:
[10:19:24.793] Label: ‘future_mapply-1’
[10:19:24.793] Expression:
[10:19:24.793] {
[10:19:24.793]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.793]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:24.793]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.793]         on.exit(options(oopts), add = TRUE)
[10:19:24.793]     }
[10:19:24.793]     {
[10:19:24.793]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.793]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:24.793]         do.call(mapply, args = args)
[10:19:24.793]     }
[10:19:24.793] }
[10:19:24.793] Lazy evaluation: FALSE
[10:19:24.793] Asynchronous evaluation: TRUE
[10:19:24.793] Local evaluation: TRUE
[10:19:24.793] Environment: R_GlobalEnv
[10:19:24.793] Capture standard output: TRUE
[10:19:24.793] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:24.793] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:24.793] Packages: <none>
[10:19:24.793] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:24.793] Resolved: FALSE
[10:19:24.793] Value: <not collected>
[10:19:24.793] Conditions captured: <none>
[10:19:24.793] Early signaling: FALSE
[10:19:24.793] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:24.793] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.804] Chunk #1 of 2 ... DONE
[10:19:24.804] Chunk #2 of 2 ...
[10:19:24.804]  - Finding globals in '...' for chunk #2 ...
[10:19:24.805] getGlobalsAndPackages() ...
[10:19:24.805] Searching for globals...
[10:19:24.805] 
[10:19:24.805] Searching for globals ... DONE
[10:19:24.805] - globals: [0] <none>
[10:19:24.805] getGlobalsAndPackages() ... DONE
[10:19:24.805]    + additional globals found: [n=0] 
[10:19:24.806]    + additional namespaces needed: [n=0] 
[10:19:24.806]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:24.806]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:24.806]  - seeds: <none>
[10:19:24.806]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.806] getGlobalsAndPackages() ...
[10:19:24.806] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.806] Resolving globals: FALSE
[10:19:24.807] The total size of the 5 globals is 286 bytes (286 bytes)
[10:19:24.807] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[10:19:24.807] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.807] 
[10:19:24.807] getGlobalsAndPackages() ... DONE
[10:19:24.808] run() for ‘Future’ ...
[10:19:24.808] - state: ‘created’
[10:19:24.808] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:24.822] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:24.822]   - Field: ‘node’
[10:19:24.822]   - Field: ‘label’
[10:19:24.822]   - Field: ‘local’
[10:19:24.822]   - Field: ‘owner’
[10:19:24.822]   - Field: ‘envir’
[10:19:24.822]   - Field: ‘workers’
[10:19:24.822]   - Field: ‘packages’
[10:19:24.822]   - Field: ‘gc’
[10:19:24.822]   - Field: ‘conditions’
[10:19:24.823]   - Field: ‘persistent’
[10:19:24.823]   - Field: ‘expr’
[10:19:24.823]   - Field: ‘uuid’
[10:19:24.823]   - Field: ‘seed’
[10:19:24.823]   - Field: ‘version’
[10:19:24.823]   - Field: ‘result’
[10:19:24.823]   - Field: ‘asynchronous’
[10:19:24.823]   - Field: ‘calls’
[10:19:24.823]   - Field: ‘globals’
[10:19:24.823]   - Field: ‘stdout’
[10:19:24.823]   - Field: ‘earlySignal’
[10:19:24.824]   - Field: ‘lazy’
[10:19:24.824]   - Field: ‘state’
[10:19:24.824] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:24.824] - Launch lazy future ...
[10:19:24.824] Packages needed by the future expression (n = 0): <none>
[10:19:24.824] Packages needed by future strategies (n = 0): <none>
[10:19:24.825] {
[10:19:24.825]     {
[10:19:24.825]         {
[10:19:24.825]             ...future.startTime <- base::Sys.time()
[10:19:24.825]             {
[10:19:24.825]                 {
[10:19:24.825]                   {
[10:19:24.825]                     {
[10:19:24.825]                       base::local({
[10:19:24.825]                         has_future <- base::requireNamespace("future", 
[10:19:24.825]                           quietly = TRUE)
[10:19:24.825]                         if (has_future) {
[10:19:24.825]                           ns <- base::getNamespace("future")
[10:19:24.825]                           version <- ns[[".package"]][["version"]]
[10:19:24.825]                           if (is.null(version)) 
[10:19:24.825]                             version <- utils::packageVersion("future")
[10:19:24.825]                         }
[10:19:24.825]                         else {
[10:19:24.825]                           version <- NULL
[10:19:24.825]                         }
[10:19:24.825]                         if (!has_future || version < "1.8.0") {
[10:19:24.825]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.825]                             "", base::R.version$version.string), 
[10:19:24.825]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.825]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.825]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.825]                               "release", "version")], collapse = " "), 
[10:19:24.825]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.825]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.825]                             info)
[10:19:24.825]                           info <- base::paste(info, collapse = "; ")
[10:19:24.825]                           if (!has_future) {
[10:19:24.825]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.825]                               info)
[10:19:24.825]                           }
[10:19:24.825]                           else {
[10:19:24.825]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.825]                               info, version)
[10:19:24.825]                           }
[10:19:24.825]                           base::stop(msg)
[10:19:24.825]                         }
[10:19:24.825]                       })
[10:19:24.825]                     }
[10:19:24.825]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.825]                     base::options(mc.cores = 1L)
[10:19:24.825]                   }
[10:19:24.825]                   ...future.strategy.old <- future::plan("list")
[10:19:24.825]                   options(future.plan = NULL)
[10:19:24.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.825]                 }
[10:19:24.825]                 ...future.workdir <- getwd()
[10:19:24.825]             }
[10:19:24.825]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.825]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.825]         }
[10:19:24.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.825]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:24.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.825]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.825]             base::names(...future.oldOptions))
[10:19:24.825]     }
[10:19:24.825]     if (FALSE) {
[10:19:24.825]     }
[10:19:24.825]     else {
[10:19:24.825]         if (TRUE) {
[10:19:24.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.825]                 open = "w")
[10:19:24.825]         }
[10:19:24.825]         else {
[10:19:24.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.825]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.825]         }
[10:19:24.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.825]             base::sink(type = "output", split = FALSE)
[10:19:24.825]             base::close(...future.stdout)
[10:19:24.825]         }, add = TRUE)
[10:19:24.825]     }
[10:19:24.825]     ...future.frame <- base::sys.nframe()
[10:19:24.825]     ...future.conditions <- base::list()
[10:19:24.825]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.825]     if (FALSE) {
[10:19:24.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.825]     }
[10:19:24.825]     ...future.result <- base::tryCatch({
[10:19:24.825]         base::withCallingHandlers({
[10:19:24.825]             ...future.value <- base::withVisible(base::local({
[10:19:24.825]                 ...future.makeSendCondition <- base::local({
[10:19:24.825]                   sendCondition <- NULL
[10:19:24.825]                   function(frame = 1L) {
[10:19:24.825]                     if (is.function(sendCondition)) 
[10:19:24.825]                       return(sendCondition)
[10:19:24.825]                     ns <- getNamespace("parallel")
[10:19:24.825]                     if (exists("sendData", mode = "function", 
[10:19:24.825]                       envir = ns)) {
[10:19:24.825]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.825]                         envir = ns)
[10:19:24.825]                       envir <- sys.frame(frame)
[10:19:24.825]                       master <- NULL
[10:19:24.825]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.825]                         !identical(envir, emptyenv())) {
[10:19:24.825]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.825]                           inherits = FALSE)) {
[10:19:24.825]                           master <- get("master", mode = "list", 
[10:19:24.825]                             envir = envir, inherits = FALSE)
[10:19:24.825]                           if (inherits(master, c("SOCKnode", 
[10:19:24.825]                             "SOCK0node"))) {
[10:19:24.825]                             sendCondition <<- function(cond) {
[10:19:24.825]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.825]                                 success = TRUE)
[10:19:24.825]                               parallel_sendData(master, data)
[10:19:24.825]                             }
[10:19:24.825]                             return(sendCondition)
[10:19:24.825]                           }
[10:19:24.825]                         }
[10:19:24.825]                         frame <- frame + 1L
[10:19:24.825]                         envir <- sys.frame(frame)
[10:19:24.825]                       }
[10:19:24.825]                     }
[10:19:24.825]                     sendCondition <<- function(cond) NULL
[10:19:24.825]                   }
[10:19:24.825]                 })
[10:19:24.825]                 withCallingHandlers({
[10:19:24.825]                   {
[10:19:24.825]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.825]                     if (!identical(...future.globals.maxSize.org, 
[10:19:24.825]                       ...future.globals.maxSize)) {
[10:19:24.825]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.825]                       on.exit(options(oopts), add = TRUE)
[10:19:24.825]                     }
[10:19:24.825]                     {
[10:19:24.825]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.825]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:24.825]                         USE.NAMES = FALSE)
[10:19:24.825]                       do.call(mapply, args = args)
[10:19:24.825]                     }
[10:19:24.825]                   }
[10:19:24.825]                 }, immediateCondition = function(cond) {
[10:19:24.825]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.825]                   sendCondition(cond)
[10:19:24.825]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.825]                   {
[10:19:24.825]                     inherits <- base::inherits
[10:19:24.825]                     invokeRestart <- base::invokeRestart
[10:19:24.825]                     is.null <- base::is.null
[10:19:24.825]                     muffled <- FALSE
[10:19:24.825]                     if (inherits(cond, "message")) {
[10:19:24.825]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.825]                       if (muffled) 
[10:19:24.825]                         invokeRestart("muffleMessage")
[10:19:24.825]                     }
[10:19:24.825]                     else if (inherits(cond, "warning")) {
[10:19:24.825]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.825]                       if (muffled) 
[10:19:24.825]                         invokeRestart("muffleWarning")
[10:19:24.825]                     }
[10:19:24.825]                     else if (inherits(cond, "condition")) {
[10:19:24.825]                       if (!is.null(pattern)) {
[10:19:24.825]                         computeRestarts <- base::computeRestarts
[10:19:24.825]                         grepl <- base::grepl
[10:19:24.825]                         restarts <- computeRestarts(cond)
[10:19:24.825]                         for (restart in restarts) {
[10:19:24.825]                           name <- restart$name
[10:19:24.825]                           if (is.null(name)) 
[10:19:24.825]                             next
[10:19:24.825]                           if (!grepl(pattern, name)) 
[10:19:24.825]                             next
[10:19:24.825]                           invokeRestart(restart)
[10:19:24.825]                           muffled <- TRUE
[10:19:24.825]                           break
[10:19:24.825]                         }
[10:19:24.825]                       }
[10:19:24.825]                     }
[10:19:24.825]                     invisible(muffled)
[10:19:24.825]                   }
[10:19:24.825]                   muffleCondition(cond)
[10:19:24.825]                 })
[10:19:24.825]             }))
[10:19:24.825]             future::FutureResult(value = ...future.value$value, 
[10:19:24.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.825]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.825]                     ...future.globalenv.names))
[10:19:24.825]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.825]         }, condition = base::local({
[10:19:24.825]             c <- base::c
[10:19:24.825]             inherits <- base::inherits
[10:19:24.825]             invokeRestart <- base::invokeRestart
[10:19:24.825]             length <- base::length
[10:19:24.825]             list <- base::list
[10:19:24.825]             seq.int <- base::seq.int
[10:19:24.825]             signalCondition <- base::signalCondition
[10:19:24.825]             sys.calls <- base::sys.calls
[10:19:24.825]             `[[` <- base::`[[`
[10:19:24.825]             `+` <- base::`+`
[10:19:24.825]             `<<-` <- base::`<<-`
[10:19:24.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.825]                   3L)]
[10:19:24.825]             }
[10:19:24.825]             function(cond) {
[10:19:24.825]                 is_error <- inherits(cond, "error")
[10:19:24.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.825]                   NULL)
[10:19:24.825]                 if (is_error) {
[10:19:24.825]                   sessionInformation <- function() {
[10:19:24.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.825]                       search = base::search(), system = base::Sys.info())
[10:19:24.825]                   }
[10:19:24.825]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.825]                     cond$call), session = sessionInformation(), 
[10:19:24.825]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.825]                   signalCondition(cond)
[10:19:24.825]                 }
[10:19:24.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.825]                 "immediateCondition"))) {
[10:19:24.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.825]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.825]                   if (TRUE && !signal) {
[10:19:24.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.825]                     {
[10:19:24.825]                       inherits <- base::inherits
[10:19:24.825]                       invokeRestart <- base::invokeRestart
[10:19:24.825]                       is.null <- base::is.null
[10:19:24.825]                       muffled <- FALSE
[10:19:24.825]                       if (inherits(cond, "message")) {
[10:19:24.825]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.825]                         if (muffled) 
[10:19:24.825]                           invokeRestart("muffleMessage")
[10:19:24.825]                       }
[10:19:24.825]                       else if (inherits(cond, "warning")) {
[10:19:24.825]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.825]                         if (muffled) 
[10:19:24.825]                           invokeRestart("muffleWarning")
[10:19:24.825]                       }
[10:19:24.825]                       else if (inherits(cond, "condition")) {
[10:19:24.825]                         if (!is.null(pattern)) {
[10:19:24.825]                           computeRestarts <- base::computeRestarts
[10:19:24.825]                           grepl <- base::grepl
[10:19:24.825]                           restarts <- computeRestarts(cond)
[10:19:24.825]                           for (restart in restarts) {
[10:19:24.825]                             name <- restart$name
[10:19:24.825]                             if (is.null(name)) 
[10:19:24.825]                               next
[10:19:24.825]                             if (!grepl(pattern, name)) 
[10:19:24.825]                               next
[10:19:24.825]                             invokeRestart(restart)
[10:19:24.825]                             muffled <- TRUE
[10:19:24.825]                             break
[10:19:24.825]                           }
[10:19:24.825]                         }
[10:19:24.825]                       }
[10:19:24.825]                       invisible(muffled)
[10:19:24.825]                     }
[10:19:24.825]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.825]                   }
[10:19:24.825]                 }
[10:19:24.825]                 else {
[10:19:24.825]                   if (TRUE) {
[10:19:24.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.825]                     {
[10:19:24.825]                       inherits <- base::inherits
[10:19:24.825]                       invokeRestart <- base::invokeRestart
[10:19:24.825]                       is.null <- base::is.null
[10:19:24.825]                       muffled <- FALSE
[10:19:24.825]                       if (inherits(cond, "message")) {
[10:19:24.825]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.825]                         if (muffled) 
[10:19:24.825]                           invokeRestart("muffleMessage")
[10:19:24.825]                       }
[10:19:24.825]                       else if (inherits(cond, "warning")) {
[10:19:24.825]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.825]                         if (muffled) 
[10:19:24.825]                           invokeRestart("muffleWarning")
[10:19:24.825]                       }
[10:19:24.825]                       else if (inherits(cond, "condition")) {
[10:19:24.825]                         if (!is.null(pattern)) {
[10:19:24.825]                           computeRestarts <- base::computeRestarts
[10:19:24.825]                           grepl <- base::grepl
[10:19:24.825]                           restarts <- computeRestarts(cond)
[10:19:24.825]                           for (restart in restarts) {
[10:19:24.825]                             name <- restart$name
[10:19:24.825]                             if (is.null(name)) 
[10:19:24.825]                               next
[10:19:24.825]                             if (!grepl(pattern, name)) 
[10:19:24.825]                               next
[10:19:24.825]                             invokeRestart(restart)
[10:19:24.825]                             muffled <- TRUE
[10:19:24.825]                             break
[10:19:24.825]                           }
[10:19:24.825]                         }
[10:19:24.825]                       }
[10:19:24.825]                       invisible(muffled)
[10:19:24.825]                     }
[10:19:24.825]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.825]                   }
[10:19:24.825]                 }
[10:19:24.825]             }
[10:19:24.825]         }))
[10:19:24.825]     }, error = function(ex) {
[10:19:24.825]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.825]                 ...future.rng), started = ...future.startTime, 
[10:19:24.825]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.825]             version = "1.8"), class = "FutureResult")
[10:19:24.825]     }, finally = {
[10:19:24.825]         if (!identical(...future.workdir, getwd())) 
[10:19:24.825]             setwd(...future.workdir)
[10:19:24.825]         {
[10:19:24.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.825]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.825]             }
[10:19:24.825]             base::options(...future.oldOptions)
[10:19:24.825]             if (.Platform$OS.type == "windows") {
[10:19:24.825]                 old_names <- names(...future.oldEnvVars)
[10:19:24.825]                 envs <- base::Sys.getenv()
[10:19:24.825]                 names <- names(envs)
[10:19:24.825]                 common <- intersect(names, old_names)
[10:19:24.825]                 added <- setdiff(names, old_names)
[10:19:24.825]                 removed <- setdiff(old_names, names)
[10:19:24.825]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.825]                   envs[common]]
[10:19:24.825]                 NAMES <- toupper(changed)
[10:19:24.825]                 args <- list()
[10:19:24.825]                 for (kk in seq_along(NAMES)) {
[10:19:24.825]                   name <- changed[[kk]]
[10:19:24.825]                   NAME <- NAMES[[kk]]
[10:19:24.825]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.825]                     next
[10:19:24.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.825]                 }
[10:19:24.825]                 NAMES <- toupper(added)
[10:19:24.825]                 for (kk in seq_along(NAMES)) {
[10:19:24.825]                   name <- added[[kk]]
[10:19:24.825]                   NAME <- NAMES[[kk]]
[10:19:24.825]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.825]                     next
[10:19:24.825]                   args[[name]] <- ""
[10:19:24.825]                 }
[10:19:24.825]                 NAMES <- toupper(removed)
[10:19:24.825]                 for (kk in seq_along(NAMES)) {
[10:19:24.825]                   name <- removed[[kk]]
[10:19:24.825]                   NAME <- NAMES[[kk]]
[10:19:24.825]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.825]                     next
[10:19:24.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.825]                 }
[10:19:24.825]                 if (length(args) > 0) 
[10:19:24.825]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.825]             }
[10:19:24.825]             else {
[10:19:24.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.825]             }
[10:19:24.825]             {
[10:19:24.825]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.825]                   0L) {
[10:19:24.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.825]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.825]                   base::options(opts)
[10:19:24.825]                 }
[10:19:24.825]                 {
[10:19:24.825]                   {
[10:19:24.825]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.825]                     NULL
[10:19:24.825]                   }
[10:19:24.825]                   options(future.plan = NULL)
[10:19:24.825]                   if (is.na(NA_character_)) 
[10:19:24.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.825]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.825]                     .init = FALSE)
[10:19:24.825]                 }
[10:19:24.825]             }
[10:19:24.825]         }
[10:19:24.825]     })
[10:19:24.825]     if (TRUE) {
[10:19:24.825]         base::sink(type = "output", split = FALSE)
[10:19:24.825]         if (TRUE) {
[10:19:24.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.825]         }
[10:19:24.825]         else {
[10:19:24.825]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.825]         }
[10:19:24.825]         base::close(...future.stdout)
[10:19:24.825]         ...future.stdout <- NULL
[10:19:24.825]     }
[10:19:24.825]     ...future.result$conditions <- ...future.conditions
[10:19:24.825]     ...future.result$finished <- base::Sys.time()
[10:19:24.825]     ...future.result
[10:19:24.825] }
[10:19:24.827] Exporting 5 global objects (723 bytes) to cluster node #2 ...
[10:19:24.828] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[10:19:24.828] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[10:19:24.828] Exporting ‘MoreArgs’ (89 bytes) to cluster node #2 ...
[10:19:24.828] Exporting ‘MoreArgs’ (89 bytes) to cluster node #2 ... DONE
[10:19:24.829] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #2 ...
[10:19:24.829] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #2 ... DONE
[10:19:24.829] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:24.829] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.830] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:24.830] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.830] Exporting 5 global objects (723 bytes) to cluster node #2 ... DONE
[10:19:24.830] MultisessionFuture started
[10:19:24.831] - Launch lazy future ... done
[10:19:24.831] run() for ‘MultisessionFuture’ ... done
[10:19:24.831] Created future:
[10:19:24.831] MultisessionFuture:
[10:19:24.831] Label: ‘future_mapply-2’
[10:19:24.831] Expression:
[10:19:24.831] {
[10:19:24.831]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.831]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:24.831]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.831]         on.exit(options(oopts), add = TRUE)
[10:19:24.831]     }
[10:19:24.831]     {
[10:19:24.831]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.831]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:24.831]         do.call(mapply, args = args)
[10:19:24.831]     }
[10:19:24.831] }
[10:19:24.831] Lazy evaluation: FALSE
[10:19:24.831] Asynchronous evaluation: TRUE
[10:19:24.831] Local evaluation: TRUE
[10:19:24.831] Environment: R_GlobalEnv
[10:19:24.831] Capture standard output: TRUE
[10:19:24.831] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:24.831] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:24.831] Packages: <none>
[10:19:24.831] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:24.831] Resolved: FALSE
[10:19:24.831] Value: <not collected>
[10:19:24.831] Conditions captured: <none>
[10:19:24.831] Early signaling: FALSE
[10:19:24.831] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:24.831] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.842] Chunk #2 of 2 ... DONE
[10:19:24.842] Launching 2 futures (chunks) ... DONE
[10:19:24.842] Resolving 2 futures (chunks) ...
[10:19:24.843] resolve() on list ...
[10:19:24.843]  recursive: 0
[10:19:24.843]  length: 2
[10:19:24.843] 
[10:19:24.843] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.843] - Validating connection of MultisessionFuture
[10:19:24.843] - received message: FutureResult
[10:19:24.844] - Received FutureResult
[10:19:24.844] - Erased future from FutureRegistry
[10:19:24.844] result() for ClusterFuture ...
[10:19:24.844] - result already collected: FutureResult
[10:19:24.844] result() for ClusterFuture ... done
[10:19:24.844] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.844] Future #1
[10:19:24.844] result() for ClusterFuture ...
[10:19:24.844] - result already collected: FutureResult
[10:19:24.844] result() for ClusterFuture ... done
[10:19:24.844] result() for ClusterFuture ...
[10:19:24.845] - result already collected: FutureResult
[10:19:24.845] result() for ClusterFuture ... done
[10:19:24.845] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:24.845] - nx: 2
[10:19:24.845] - relay: TRUE
[10:19:24.845] - stdout: TRUE
[10:19:24.845] - signal: TRUE
[10:19:24.845] - resignal: FALSE
[10:19:24.845] - force: TRUE
[10:19:24.845] - relayed: [n=2] FALSE, FALSE
[10:19:24.845] - queued futures: [n=2] FALSE, FALSE
[10:19:24.845]  - until=1
[10:19:24.846]  - relaying element #1
[10:19:24.846] result() for ClusterFuture ...
[10:19:24.846] - result already collected: FutureResult
[10:19:24.846] result() for ClusterFuture ... done
[10:19:24.846] result() for ClusterFuture ...
[10:19:24.846] - result already collected: FutureResult
[10:19:24.846] result() for ClusterFuture ... done
[10:19:24.846] result() for ClusterFuture ...
[10:19:24.846] - result already collected: FutureResult
[10:19:24.846] result() for ClusterFuture ... done
[10:19:24.846] result() for ClusterFuture ...
[10:19:24.846] - result already collected: FutureResult
[10:19:24.847] result() for ClusterFuture ... done
[10:19:24.847] - relayed: [n=2] TRUE, FALSE
[10:19:24.847] - queued futures: [n=2] TRUE, FALSE
[10:19:24.847] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:24.847]  length: 1 (resolved future 1)
[10:19:24.873] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.873] - Validating connection of MultisessionFuture
[10:19:24.873] - received message: FutureResult
[10:19:24.874] - Received FutureResult
[10:19:24.874] - Erased future from FutureRegistry
[10:19:24.874] result() for ClusterFuture ...
[10:19:24.874] - result already collected: FutureResult
[10:19:24.874] result() for ClusterFuture ... done
[10:19:24.874] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.874] Future #2
[10:19:24.874] result() for ClusterFuture ...
[10:19:24.874] - result already collected: FutureResult
[10:19:24.874] result() for ClusterFuture ... done
[10:19:24.874] result() for ClusterFuture ...
[10:19:24.874] - result already collected: FutureResult
[10:19:24.875] result() for ClusterFuture ... done
[10:19:24.875] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:24.875] - nx: 2
[10:19:24.875] - relay: TRUE
[10:19:24.875] - stdout: TRUE
[10:19:24.875] - signal: TRUE
[10:19:24.875] - resignal: FALSE
[10:19:24.875] - force: TRUE
[10:19:24.875] - relayed: [n=2] TRUE, FALSE
[10:19:24.875] - queued futures: [n=2] TRUE, FALSE
[10:19:24.875]  - until=2
[10:19:24.875]  - relaying element #2
[10:19:24.876] result() for ClusterFuture ...
[10:19:24.876] - result already collected: FutureResult
[10:19:24.876] result() for ClusterFuture ... done
[10:19:24.876] result() for ClusterFuture ...
[10:19:24.876] - result already collected: FutureResult
[10:19:24.876] result() for ClusterFuture ... done
[10:19:24.876] result() for ClusterFuture ...
[10:19:24.876] - result already collected: FutureResult
[10:19:24.876] result() for ClusterFuture ... done
[10:19:24.876] result() for ClusterFuture ...
[10:19:24.876] - result already collected: FutureResult
[10:19:24.876] result() for ClusterFuture ... done
[10:19:24.877] - relayed: [n=2] TRUE, TRUE
[10:19:24.877] - queued futures: [n=2] TRUE, TRUE
[10:19:24.877] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:24.877]  length: 0 (resolved future 2)
[10:19:24.877] Relaying remaining futures
[10:19:24.877] signalConditionsASAP(NULL, pos=0) ...
[10:19:24.877] - nx: 2
[10:19:24.877] - relay: TRUE
[10:19:24.877] - stdout: TRUE
[10:19:24.877] - signal: TRUE
[10:19:24.877] - resignal: FALSE
[10:19:24.877] - force: TRUE
[10:19:24.877] - relayed: [n=2] TRUE, TRUE
[10:19:24.878] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:24.878] - relayed: [n=2] TRUE, TRUE
[10:19:24.878] - queued futures: [n=2] TRUE, TRUE
[10:19:24.878] signalConditionsASAP(NULL, pos=0) ... done
[10:19:24.878] resolve() on list ... DONE
[10:19:24.878] result() for ClusterFuture ...
[10:19:24.878] - result already collected: FutureResult
[10:19:24.878] result() for ClusterFuture ... done
[10:19:24.878] result() for ClusterFuture ...
[10:19:24.878] - result already collected: FutureResult
[10:19:24.878] result() for ClusterFuture ... done
[10:19:24.879] result() for ClusterFuture ...
[10:19:24.879] - result already collected: FutureResult
[10:19:24.879] result() for ClusterFuture ... done
[10:19:24.879] result() for ClusterFuture ...
[10:19:24.879] - result already collected: FutureResult
[10:19:24.879] result() for ClusterFuture ... done
[10:19:24.879]  - Number of value chunks collected: 2
[10:19:24.879] Resolving 2 futures (chunks) ... DONE
[10:19:24.879] Reducing values from 2 chunks ...
[10:19:24.879]  - Number of values collected after concatenation: 4
[10:19:24.879]  - Number of values expected: 4
[10:19:24.879] Reducing values from 2 chunks ... DONE
[10:19:24.880] future_mapply() ... DONE
[10:19:24.880] future_mapply() ...
[10:19:24.881] Number of chunks: 2
[10:19:24.881] getGlobalsAndPackagesXApply() ...
[10:19:24.882]  - future.globals: TRUE
[10:19:24.882] getGlobalsAndPackages() ...
[10:19:24.882] Searching for globals...
[10:19:24.883] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:19:24.883] Searching for globals ... DONE
[10:19:24.883] Resolving globals: FALSE
[10:19:24.884] The total size of the 1 globals is 414 bytes (414 bytes)
[10:19:24.884] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:19:24.884] - globals: [1] ‘FUN’
[10:19:24.884] 
[10:19:24.884] getGlobalsAndPackages() ... DONE
[10:19:24.884]  - globals found/used: [n=1] ‘FUN’
[10:19:24.884]  - needed namespaces: [n=0] 
[10:19:24.884] Finding globals ... DONE
[10:19:24.885] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:24.885] List of 2
[10:19:24.885]  $ ...future.FUN:function (x, y)  
[10:19:24.885]  $ MoreArgs     : NULL
[10:19:24.885]  - attr(*, "where")=List of 2
[10:19:24.885]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:24.885]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:24.885]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:24.885]  - attr(*, "resolved")= logi FALSE
[10:19:24.885]  - attr(*, "total_size")= num NA
[10:19:24.887] Packages to be attached in all futures: [n=0] 
[10:19:24.887] getGlobalsAndPackagesXApply() ... DONE
[10:19:24.887] Number of futures (= number of chunks): 2
[10:19:24.888] Launching 2 futures (chunks) ...
[10:19:24.888] Chunk #1 of 2 ...
[10:19:24.888]  - Finding globals in '...' for chunk #1 ...
[10:19:24.888] getGlobalsAndPackages() ...
[10:19:24.888] Searching for globals...
[10:19:24.888] 
[10:19:24.888] Searching for globals ... DONE
[10:19:24.888] - globals: [0] <none>
[10:19:24.889] getGlobalsAndPackages() ... DONE
[10:19:24.889]    + additional globals found: [n=0] 
[10:19:24.889]    + additional namespaces needed: [n=0] 
[10:19:24.889]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:24.889]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:24.889]  - seeds: <none>
[10:19:24.889]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.889] getGlobalsAndPackages() ...
[10:19:24.889] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.889] Resolving globals: FALSE
[10:19:24.890] The total size of the 5 globals is 645 bytes (645 bytes)
[10:19:24.890] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 645 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:24.890] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.890] 
[10:19:24.890] getGlobalsAndPackages() ... DONE
[10:19:24.891] run() for ‘Future’ ...
[10:19:24.891] - state: ‘created’
[10:19:24.891] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:24.905] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:24.905]   - Field: ‘node’
[10:19:24.905]   - Field: ‘label’
[10:19:24.905]   - Field: ‘local’
[10:19:24.905]   - Field: ‘owner’
[10:19:24.905]   - Field: ‘envir’
[10:19:24.906]   - Field: ‘workers’
[10:19:24.906]   - Field: ‘packages’
[10:19:24.906]   - Field: ‘gc’
[10:19:24.906]   - Field: ‘conditions’
[10:19:24.906]   - Field: ‘persistent’
[10:19:24.906]   - Field: ‘expr’
[10:19:24.906]   - Field: ‘uuid’
[10:19:24.906]   - Field: ‘seed’
[10:19:24.906]   - Field: ‘version’
[10:19:24.906]   - Field: ‘result’
[10:19:24.906]   - Field: ‘asynchronous’
[10:19:24.907]   - Field: ‘calls’
[10:19:24.907]   - Field: ‘globals’
[10:19:24.907]   - Field: ‘stdout’
[10:19:24.907]   - Field: ‘earlySignal’
[10:19:24.907]   - Field: ‘lazy’
[10:19:24.907]   - Field: ‘state’
[10:19:24.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:24.907] - Launch lazy future ...
[10:19:24.907] Packages needed by the future expression (n = 0): <none>
[10:19:24.907] Packages needed by future strategies (n = 0): <none>
[10:19:24.908] {
[10:19:24.908]     {
[10:19:24.908]         {
[10:19:24.908]             ...future.startTime <- base::Sys.time()
[10:19:24.908]             {
[10:19:24.908]                 {
[10:19:24.908]                   {
[10:19:24.908]                     {
[10:19:24.908]                       base::local({
[10:19:24.908]                         has_future <- base::requireNamespace("future", 
[10:19:24.908]                           quietly = TRUE)
[10:19:24.908]                         if (has_future) {
[10:19:24.908]                           ns <- base::getNamespace("future")
[10:19:24.908]                           version <- ns[[".package"]][["version"]]
[10:19:24.908]                           if (is.null(version)) 
[10:19:24.908]                             version <- utils::packageVersion("future")
[10:19:24.908]                         }
[10:19:24.908]                         else {
[10:19:24.908]                           version <- NULL
[10:19:24.908]                         }
[10:19:24.908]                         if (!has_future || version < "1.8.0") {
[10:19:24.908]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.908]                             "", base::R.version$version.string), 
[10:19:24.908]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.908]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.908]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.908]                               "release", "version")], collapse = " "), 
[10:19:24.908]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.908]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.908]                             info)
[10:19:24.908]                           info <- base::paste(info, collapse = "; ")
[10:19:24.908]                           if (!has_future) {
[10:19:24.908]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.908]                               info)
[10:19:24.908]                           }
[10:19:24.908]                           else {
[10:19:24.908]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.908]                               info, version)
[10:19:24.908]                           }
[10:19:24.908]                           base::stop(msg)
[10:19:24.908]                         }
[10:19:24.908]                       })
[10:19:24.908]                     }
[10:19:24.908]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.908]                     base::options(mc.cores = 1L)
[10:19:24.908]                   }
[10:19:24.908]                   ...future.strategy.old <- future::plan("list")
[10:19:24.908]                   options(future.plan = NULL)
[10:19:24.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.908]                 }
[10:19:24.908]                 ...future.workdir <- getwd()
[10:19:24.908]             }
[10:19:24.908]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.908]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.908]         }
[10:19:24.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.908]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:24.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.908]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.908]             base::names(...future.oldOptions))
[10:19:24.908]     }
[10:19:24.908]     if (FALSE) {
[10:19:24.908]     }
[10:19:24.908]     else {
[10:19:24.908]         if (TRUE) {
[10:19:24.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.908]                 open = "w")
[10:19:24.908]         }
[10:19:24.908]         else {
[10:19:24.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.908]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.908]         }
[10:19:24.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.908]             base::sink(type = "output", split = FALSE)
[10:19:24.908]             base::close(...future.stdout)
[10:19:24.908]         }, add = TRUE)
[10:19:24.908]     }
[10:19:24.908]     ...future.frame <- base::sys.nframe()
[10:19:24.908]     ...future.conditions <- base::list()
[10:19:24.908]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.908]     if (FALSE) {
[10:19:24.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.908]     }
[10:19:24.908]     ...future.result <- base::tryCatch({
[10:19:24.908]         base::withCallingHandlers({
[10:19:24.908]             ...future.value <- base::withVisible(base::local({
[10:19:24.908]                 ...future.makeSendCondition <- base::local({
[10:19:24.908]                   sendCondition <- NULL
[10:19:24.908]                   function(frame = 1L) {
[10:19:24.908]                     if (is.function(sendCondition)) 
[10:19:24.908]                       return(sendCondition)
[10:19:24.908]                     ns <- getNamespace("parallel")
[10:19:24.908]                     if (exists("sendData", mode = "function", 
[10:19:24.908]                       envir = ns)) {
[10:19:24.908]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.908]                         envir = ns)
[10:19:24.908]                       envir <- sys.frame(frame)
[10:19:24.908]                       master <- NULL
[10:19:24.908]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.908]                         !identical(envir, emptyenv())) {
[10:19:24.908]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.908]                           inherits = FALSE)) {
[10:19:24.908]                           master <- get("master", mode = "list", 
[10:19:24.908]                             envir = envir, inherits = FALSE)
[10:19:24.908]                           if (inherits(master, c("SOCKnode", 
[10:19:24.908]                             "SOCK0node"))) {
[10:19:24.908]                             sendCondition <<- function(cond) {
[10:19:24.908]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.908]                                 success = TRUE)
[10:19:24.908]                               parallel_sendData(master, data)
[10:19:24.908]                             }
[10:19:24.908]                             return(sendCondition)
[10:19:24.908]                           }
[10:19:24.908]                         }
[10:19:24.908]                         frame <- frame + 1L
[10:19:24.908]                         envir <- sys.frame(frame)
[10:19:24.908]                       }
[10:19:24.908]                     }
[10:19:24.908]                     sendCondition <<- function(cond) NULL
[10:19:24.908]                   }
[10:19:24.908]                 })
[10:19:24.908]                 withCallingHandlers({
[10:19:24.908]                   {
[10:19:24.908]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.908]                     if (!identical(...future.globals.maxSize.org, 
[10:19:24.908]                       ...future.globals.maxSize)) {
[10:19:24.908]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.908]                       on.exit(options(oopts), add = TRUE)
[10:19:24.908]                     }
[10:19:24.908]                     {
[10:19:24.908]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.908]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:24.908]                         USE.NAMES = FALSE)
[10:19:24.908]                       do.call(mapply, args = args)
[10:19:24.908]                     }
[10:19:24.908]                   }
[10:19:24.908]                 }, immediateCondition = function(cond) {
[10:19:24.908]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.908]                   sendCondition(cond)
[10:19:24.908]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.908]                   {
[10:19:24.908]                     inherits <- base::inherits
[10:19:24.908]                     invokeRestart <- base::invokeRestart
[10:19:24.908]                     is.null <- base::is.null
[10:19:24.908]                     muffled <- FALSE
[10:19:24.908]                     if (inherits(cond, "message")) {
[10:19:24.908]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.908]                       if (muffled) 
[10:19:24.908]                         invokeRestart("muffleMessage")
[10:19:24.908]                     }
[10:19:24.908]                     else if (inherits(cond, "warning")) {
[10:19:24.908]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.908]                       if (muffled) 
[10:19:24.908]                         invokeRestart("muffleWarning")
[10:19:24.908]                     }
[10:19:24.908]                     else if (inherits(cond, "condition")) {
[10:19:24.908]                       if (!is.null(pattern)) {
[10:19:24.908]                         computeRestarts <- base::computeRestarts
[10:19:24.908]                         grepl <- base::grepl
[10:19:24.908]                         restarts <- computeRestarts(cond)
[10:19:24.908]                         for (restart in restarts) {
[10:19:24.908]                           name <- restart$name
[10:19:24.908]                           if (is.null(name)) 
[10:19:24.908]                             next
[10:19:24.908]                           if (!grepl(pattern, name)) 
[10:19:24.908]                             next
[10:19:24.908]                           invokeRestart(restart)
[10:19:24.908]                           muffled <- TRUE
[10:19:24.908]                           break
[10:19:24.908]                         }
[10:19:24.908]                       }
[10:19:24.908]                     }
[10:19:24.908]                     invisible(muffled)
[10:19:24.908]                   }
[10:19:24.908]                   muffleCondition(cond)
[10:19:24.908]                 })
[10:19:24.908]             }))
[10:19:24.908]             future::FutureResult(value = ...future.value$value, 
[10:19:24.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.908]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.908]                     ...future.globalenv.names))
[10:19:24.908]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.908]         }, condition = base::local({
[10:19:24.908]             c <- base::c
[10:19:24.908]             inherits <- base::inherits
[10:19:24.908]             invokeRestart <- base::invokeRestart
[10:19:24.908]             length <- base::length
[10:19:24.908]             list <- base::list
[10:19:24.908]             seq.int <- base::seq.int
[10:19:24.908]             signalCondition <- base::signalCondition
[10:19:24.908]             sys.calls <- base::sys.calls
[10:19:24.908]             `[[` <- base::`[[`
[10:19:24.908]             `+` <- base::`+`
[10:19:24.908]             `<<-` <- base::`<<-`
[10:19:24.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.908]                   3L)]
[10:19:24.908]             }
[10:19:24.908]             function(cond) {
[10:19:24.908]                 is_error <- inherits(cond, "error")
[10:19:24.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.908]                   NULL)
[10:19:24.908]                 if (is_error) {
[10:19:24.908]                   sessionInformation <- function() {
[10:19:24.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.908]                       search = base::search(), system = base::Sys.info())
[10:19:24.908]                   }
[10:19:24.908]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.908]                     cond$call), session = sessionInformation(), 
[10:19:24.908]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.908]                   signalCondition(cond)
[10:19:24.908]                 }
[10:19:24.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.908]                 "immediateCondition"))) {
[10:19:24.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.908]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.908]                   if (TRUE && !signal) {
[10:19:24.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.908]                     {
[10:19:24.908]                       inherits <- base::inherits
[10:19:24.908]                       invokeRestart <- base::invokeRestart
[10:19:24.908]                       is.null <- base::is.null
[10:19:24.908]                       muffled <- FALSE
[10:19:24.908]                       if (inherits(cond, "message")) {
[10:19:24.908]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.908]                         if (muffled) 
[10:19:24.908]                           invokeRestart("muffleMessage")
[10:19:24.908]                       }
[10:19:24.908]                       else if (inherits(cond, "warning")) {
[10:19:24.908]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.908]                         if (muffled) 
[10:19:24.908]                           invokeRestart("muffleWarning")
[10:19:24.908]                       }
[10:19:24.908]                       else if (inherits(cond, "condition")) {
[10:19:24.908]                         if (!is.null(pattern)) {
[10:19:24.908]                           computeRestarts <- base::computeRestarts
[10:19:24.908]                           grepl <- base::grepl
[10:19:24.908]                           restarts <- computeRestarts(cond)
[10:19:24.908]                           for (restart in restarts) {
[10:19:24.908]                             name <- restart$name
[10:19:24.908]                             if (is.null(name)) 
[10:19:24.908]                               next
[10:19:24.908]                             if (!grepl(pattern, name)) 
[10:19:24.908]                               next
[10:19:24.908]                             invokeRestart(restart)
[10:19:24.908]                             muffled <- TRUE
[10:19:24.908]                             break
[10:19:24.908]                           }
[10:19:24.908]                         }
[10:19:24.908]                       }
[10:19:24.908]                       invisible(muffled)
[10:19:24.908]                     }
[10:19:24.908]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.908]                   }
[10:19:24.908]                 }
[10:19:24.908]                 else {
[10:19:24.908]                   if (TRUE) {
[10:19:24.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.908]                     {
[10:19:24.908]                       inherits <- base::inherits
[10:19:24.908]                       invokeRestart <- base::invokeRestart
[10:19:24.908]                       is.null <- base::is.null
[10:19:24.908]                       muffled <- FALSE
[10:19:24.908]                       if (inherits(cond, "message")) {
[10:19:24.908]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.908]                         if (muffled) 
[10:19:24.908]                           invokeRestart("muffleMessage")
[10:19:24.908]                       }
[10:19:24.908]                       else if (inherits(cond, "warning")) {
[10:19:24.908]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.908]                         if (muffled) 
[10:19:24.908]                           invokeRestart("muffleWarning")
[10:19:24.908]                       }
[10:19:24.908]                       else if (inherits(cond, "condition")) {
[10:19:24.908]                         if (!is.null(pattern)) {
[10:19:24.908]                           computeRestarts <- base::computeRestarts
[10:19:24.908]                           grepl <- base::grepl
[10:19:24.908]                           restarts <- computeRestarts(cond)
[10:19:24.908]                           for (restart in restarts) {
[10:19:24.908]                             name <- restart$name
[10:19:24.908]                             if (is.null(name)) 
[10:19:24.908]                               next
[10:19:24.908]                             if (!grepl(pattern, name)) 
[10:19:24.908]                               next
[10:19:24.908]                             invokeRestart(restart)
[10:19:24.908]                             muffled <- TRUE
[10:19:24.908]                             break
[10:19:24.908]                           }
[10:19:24.908]                         }
[10:19:24.908]                       }
[10:19:24.908]                       invisible(muffled)
[10:19:24.908]                     }
[10:19:24.908]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.908]                   }
[10:19:24.908]                 }
[10:19:24.908]             }
[10:19:24.908]         }))
[10:19:24.908]     }, error = function(ex) {
[10:19:24.908]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.908]                 ...future.rng), started = ...future.startTime, 
[10:19:24.908]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.908]             version = "1.8"), class = "FutureResult")
[10:19:24.908]     }, finally = {
[10:19:24.908]         if (!identical(...future.workdir, getwd())) 
[10:19:24.908]             setwd(...future.workdir)
[10:19:24.908]         {
[10:19:24.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.908]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.908]             }
[10:19:24.908]             base::options(...future.oldOptions)
[10:19:24.908]             if (.Platform$OS.type == "windows") {
[10:19:24.908]                 old_names <- names(...future.oldEnvVars)
[10:19:24.908]                 envs <- base::Sys.getenv()
[10:19:24.908]                 names <- names(envs)
[10:19:24.908]                 common <- intersect(names, old_names)
[10:19:24.908]                 added <- setdiff(names, old_names)
[10:19:24.908]                 removed <- setdiff(old_names, names)
[10:19:24.908]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.908]                   envs[common]]
[10:19:24.908]                 NAMES <- toupper(changed)
[10:19:24.908]                 args <- list()
[10:19:24.908]                 for (kk in seq_along(NAMES)) {
[10:19:24.908]                   name <- changed[[kk]]
[10:19:24.908]                   NAME <- NAMES[[kk]]
[10:19:24.908]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.908]                     next
[10:19:24.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.908]                 }
[10:19:24.908]                 NAMES <- toupper(added)
[10:19:24.908]                 for (kk in seq_along(NAMES)) {
[10:19:24.908]                   name <- added[[kk]]
[10:19:24.908]                   NAME <- NAMES[[kk]]
[10:19:24.908]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.908]                     next
[10:19:24.908]                   args[[name]] <- ""
[10:19:24.908]                 }
[10:19:24.908]                 NAMES <- toupper(removed)
[10:19:24.908]                 for (kk in seq_along(NAMES)) {
[10:19:24.908]                   name <- removed[[kk]]
[10:19:24.908]                   NAME <- NAMES[[kk]]
[10:19:24.908]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.908]                     next
[10:19:24.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.908]                 }
[10:19:24.908]                 if (length(args) > 0) 
[10:19:24.908]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.908]             }
[10:19:24.908]             else {
[10:19:24.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.908]             }
[10:19:24.908]             {
[10:19:24.908]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.908]                   0L) {
[10:19:24.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.908]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.908]                   base::options(opts)
[10:19:24.908]                 }
[10:19:24.908]                 {
[10:19:24.908]                   {
[10:19:24.908]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.908]                     NULL
[10:19:24.908]                   }
[10:19:24.908]                   options(future.plan = NULL)
[10:19:24.908]                   if (is.na(NA_character_)) 
[10:19:24.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.908]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.908]                     .init = FALSE)
[10:19:24.908]                 }
[10:19:24.908]             }
[10:19:24.908]         }
[10:19:24.908]     })
[10:19:24.908]     if (TRUE) {
[10:19:24.908]         base::sink(type = "output", split = FALSE)
[10:19:24.908]         if (TRUE) {
[10:19:24.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.908]         }
[10:19:24.908]         else {
[10:19:24.908]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.908]         }
[10:19:24.908]         base::close(...future.stdout)
[10:19:24.908]         ...future.stdout <- NULL
[10:19:24.908]     }
[10:19:24.908]     ...future.result$conditions <- ...future.conditions
[10:19:24.908]     ...future.result$finished <- base::Sys.time()
[10:19:24.908]     ...future.result
[10:19:24.908] }
[10:19:24.911] Exporting 5 global objects (1.06 KiB) to cluster node #1 ...
[10:19:24.911] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ...
[10:19:24.911] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ... DONE
[10:19:24.911] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:24.912] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.912] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ...
[10:19:24.912] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ... DONE
[10:19:24.912] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:24.913] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.913] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:24.913] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:24.913] Exporting 5 global objects (1.06 KiB) to cluster node #1 ... DONE
[10:19:24.914] MultisessionFuture started
[10:19:24.914] - Launch lazy future ... done
[10:19:24.914] run() for ‘MultisessionFuture’ ... done
[10:19:24.914] Created future:
[10:19:24.914] MultisessionFuture:
[10:19:24.914] Label: ‘future_mapply-1’
[10:19:24.914] Expression:
[10:19:24.914] {
[10:19:24.914]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.914]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:24.914]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.914]         on.exit(options(oopts), add = TRUE)
[10:19:24.914]     }
[10:19:24.914]     {
[10:19:24.914]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.914]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:24.914]         do.call(mapply, args = args)
[10:19:24.914]     }
[10:19:24.914] }
[10:19:24.914] Lazy evaluation: FALSE
[10:19:24.914] Asynchronous evaluation: TRUE
[10:19:24.914] Local evaluation: TRUE
[10:19:24.914] Environment: R_GlobalEnv
[10:19:24.914] Capture standard output: TRUE
[10:19:24.914] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:24.914] Globals: 5 objects totaling 645 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:24.914] Packages: <none>
[10:19:24.914] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:24.914] Resolved: FALSE
[10:19:24.914] Value: <not collected>
[10:19:24.914] Conditions captured: <none>
[10:19:24.914] Early signaling: FALSE
[10:19:24.914] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:24.914] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.926] Chunk #1 of 2 ... DONE
[10:19:24.926] Chunk #2 of 2 ...
[10:19:24.926]  - Finding globals in '...' for chunk #2 ...
[10:19:24.926] getGlobalsAndPackages() ...
[10:19:24.926] Searching for globals...
[10:19:24.926] 
[10:19:24.927] Searching for globals ... DONE
[10:19:24.927] - globals: [0] <none>
[10:19:24.927] getGlobalsAndPackages() ... DONE
[10:19:24.927]    + additional globals found: [n=0] 
[10:19:24.927]    + additional namespaces needed: [n=0] 
[10:19:24.927]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:24.927]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:24.927]  - seeds: <none>
[10:19:24.927]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.927] getGlobalsAndPackages() ...
[10:19:24.927] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.929] Resolving globals: FALSE
[10:19:24.930] The total size of the 5 globals is 695 bytes (695 bytes)
[10:19:24.930] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 695 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:24.930] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:24.931] 
[10:19:24.931] getGlobalsAndPackages() ... DONE
[10:19:24.931] run() for ‘Future’ ...
[10:19:24.931] - state: ‘created’
[10:19:24.931] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:24.945] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.945] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:24.945]   - Field: ‘node’
[10:19:24.946]   - Field: ‘label’
[10:19:24.946]   - Field: ‘local’
[10:19:24.946]   - Field: ‘owner’
[10:19:24.946]   - Field: ‘envir’
[10:19:24.946]   - Field: ‘workers’
[10:19:24.946]   - Field: ‘packages’
[10:19:24.946]   - Field: ‘gc’
[10:19:24.946]   - Field: ‘conditions’
[10:19:24.946]   - Field: ‘persistent’
[10:19:24.946]   - Field: ‘expr’
[10:19:24.946]   - Field: ‘uuid’
[10:19:24.946]   - Field: ‘seed’
[10:19:24.947]   - Field: ‘version’
[10:19:24.947]   - Field: ‘result’
[10:19:24.947]   - Field: ‘asynchronous’
[10:19:24.947]   - Field: ‘calls’
[10:19:24.947]   - Field: ‘globals’
[10:19:24.947]   - Field: ‘stdout’
[10:19:24.947]   - Field: ‘earlySignal’
[10:19:24.947]   - Field: ‘lazy’
[10:19:24.947]   - Field: ‘state’
[10:19:24.947] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:24.947] - Launch lazy future ...
[10:19:24.948] Packages needed by the future expression (n = 0): <none>
[10:19:24.948] Packages needed by future strategies (n = 0): <none>
[10:19:24.948] {
[10:19:24.948]     {
[10:19:24.948]         {
[10:19:24.948]             ...future.startTime <- base::Sys.time()
[10:19:24.948]             {
[10:19:24.948]                 {
[10:19:24.948]                   {
[10:19:24.948]                     {
[10:19:24.948]                       base::local({
[10:19:24.948]                         has_future <- base::requireNamespace("future", 
[10:19:24.948]                           quietly = TRUE)
[10:19:24.948]                         if (has_future) {
[10:19:24.948]                           ns <- base::getNamespace("future")
[10:19:24.948]                           version <- ns[[".package"]][["version"]]
[10:19:24.948]                           if (is.null(version)) 
[10:19:24.948]                             version <- utils::packageVersion("future")
[10:19:24.948]                         }
[10:19:24.948]                         else {
[10:19:24.948]                           version <- NULL
[10:19:24.948]                         }
[10:19:24.948]                         if (!has_future || version < "1.8.0") {
[10:19:24.948]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:24.948]                             "", base::R.version$version.string), 
[10:19:24.948]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:24.948]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:24.948]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:24.948]                               "release", "version")], collapse = " "), 
[10:19:24.948]                             hostname = base::Sys.info()[["nodename"]])
[10:19:24.948]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:24.948]                             info)
[10:19:24.948]                           info <- base::paste(info, collapse = "; ")
[10:19:24.948]                           if (!has_future) {
[10:19:24.948]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:24.948]                               info)
[10:19:24.948]                           }
[10:19:24.948]                           else {
[10:19:24.948]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:24.948]                               info, version)
[10:19:24.948]                           }
[10:19:24.948]                           base::stop(msg)
[10:19:24.948]                         }
[10:19:24.948]                       })
[10:19:24.948]                     }
[10:19:24.948]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:24.948]                     base::options(mc.cores = 1L)
[10:19:24.948]                   }
[10:19:24.948]                   ...future.strategy.old <- future::plan("list")
[10:19:24.948]                   options(future.plan = NULL)
[10:19:24.948]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.948]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:24.948]                 }
[10:19:24.948]                 ...future.workdir <- getwd()
[10:19:24.948]             }
[10:19:24.948]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:24.948]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:24.948]         }
[10:19:24.948]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:24.948]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:24.948]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:24.948]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:24.948]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:24.948]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:24.948]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:24.948]             base::names(...future.oldOptions))
[10:19:24.948]     }
[10:19:24.948]     if (FALSE) {
[10:19:24.948]     }
[10:19:24.948]     else {
[10:19:24.948]         if (TRUE) {
[10:19:24.948]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:24.948]                 open = "w")
[10:19:24.948]         }
[10:19:24.948]         else {
[10:19:24.948]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:24.948]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:24.948]         }
[10:19:24.948]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:24.948]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:24.948]             base::sink(type = "output", split = FALSE)
[10:19:24.948]             base::close(...future.stdout)
[10:19:24.948]         }, add = TRUE)
[10:19:24.948]     }
[10:19:24.948]     ...future.frame <- base::sys.nframe()
[10:19:24.948]     ...future.conditions <- base::list()
[10:19:24.948]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:24.948]     if (FALSE) {
[10:19:24.948]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:24.948]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:24.948]     }
[10:19:24.948]     ...future.result <- base::tryCatch({
[10:19:24.948]         base::withCallingHandlers({
[10:19:24.948]             ...future.value <- base::withVisible(base::local({
[10:19:24.948]                 ...future.makeSendCondition <- base::local({
[10:19:24.948]                   sendCondition <- NULL
[10:19:24.948]                   function(frame = 1L) {
[10:19:24.948]                     if (is.function(sendCondition)) 
[10:19:24.948]                       return(sendCondition)
[10:19:24.948]                     ns <- getNamespace("parallel")
[10:19:24.948]                     if (exists("sendData", mode = "function", 
[10:19:24.948]                       envir = ns)) {
[10:19:24.948]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:24.948]                         envir = ns)
[10:19:24.948]                       envir <- sys.frame(frame)
[10:19:24.948]                       master <- NULL
[10:19:24.948]                       while (!identical(envir, .GlobalEnv) && 
[10:19:24.948]                         !identical(envir, emptyenv())) {
[10:19:24.948]                         if (exists("master", mode = "list", envir = envir, 
[10:19:24.948]                           inherits = FALSE)) {
[10:19:24.948]                           master <- get("master", mode = "list", 
[10:19:24.948]                             envir = envir, inherits = FALSE)
[10:19:24.948]                           if (inherits(master, c("SOCKnode", 
[10:19:24.948]                             "SOCK0node"))) {
[10:19:24.948]                             sendCondition <<- function(cond) {
[10:19:24.948]                               data <- list(type = "VALUE", value = cond, 
[10:19:24.948]                                 success = TRUE)
[10:19:24.948]                               parallel_sendData(master, data)
[10:19:24.948]                             }
[10:19:24.948]                             return(sendCondition)
[10:19:24.948]                           }
[10:19:24.948]                         }
[10:19:24.948]                         frame <- frame + 1L
[10:19:24.948]                         envir <- sys.frame(frame)
[10:19:24.948]                       }
[10:19:24.948]                     }
[10:19:24.948]                     sendCondition <<- function(cond) NULL
[10:19:24.948]                   }
[10:19:24.948]                 })
[10:19:24.948]                 withCallingHandlers({
[10:19:24.948]                   {
[10:19:24.948]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.948]                     if (!identical(...future.globals.maxSize.org, 
[10:19:24.948]                       ...future.globals.maxSize)) {
[10:19:24.948]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.948]                       on.exit(options(oopts), add = TRUE)
[10:19:24.948]                     }
[10:19:24.948]                     {
[10:19:24.948]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.948]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:24.948]                         USE.NAMES = FALSE)
[10:19:24.948]                       do.call(mapply, args = args)
[10:19:24.948]                     }
[10:19:24.948]                   }
[10:19:24.948]                 }, immediateCondition = function(cond) {
[10:19:24.948]                   sendCondition <- ...future.makeSendCondition()
[10:19:24.948]                   sendCondition(cond)
[10:19:24.948]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.948]                   {
[10:19:24.948]                     inherits <- base::inherits
[10:19:24.948]                     invokeRestart <- base::invokeRestart
[10:19:24.948]                     is.null <- base::is.null
[10:19:24.948]                     muffled <- FALSE
[10:19:24.948]                     if (inherits(cond, "message")) {
[10:19:24.948]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:24.948]                       if (muffled) 
[10:19:24.948]                         invokeRestart("muffleMessage")
[10:19:24.948]                     }
[10:19:24.948]                     else if (inherits(cond, "warning")) {
[10:19:24.948]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:24.948]                       if (muffled) 
[10:19:24.948]                         invokeRestart("muffleWarning")
[10:19:24.948]                     }
[10:19:24.948]                     else if (inherits(cond, "condition")) {
[10:19:24.948]                       if (!is.null(pattern)) {
[10:19:24.948]                         computeRestarts <- base::computeRestarts
[10:19:24.948]                         grepl <- base::grepl
[10:19:24.948]                         restarts <- computeRestarts(cond)
[10:19:24.948]                         for (restart in restarts) {
[10:19:24.948]                           name <- restart$name
[10:19:24.948]                           if (is.null(name)) 
[10:19:24.948]                             next
[10:19:24.948]                           if (!grepl(pattern, name)) 
[10:19:24.948]                             next
[10:19:24.948]                           invokeRestart(restart)
[10:19:24.948]                           muffled <- TRUE
[10:19:24.948]                           break
[10:19:24.948]                         }
[10:19:24.948]                       }
[10:19:24.948]                     }
[10:19:24.948]                     invisible(muffled)
[10:19:24.948]                   }
[10:19:24.948]                   muffleCondition(cond)
[10:19:24.948]                 })
[10:19:24.948]             }))
[10:19:24.948]             future::FutureResult(value = ...future.value$value, 
[10:19:24.948]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.948]                   ...future.rng), globalenv = if (FALSE) 
[10:19:24.948]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:24.948]                     ...future.globalenv.names))
[10:19:24.948]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:24.948]         }, condition = base::local({
[10:19:24.948]             c <- base::c
[10:19:24.948]             inherits <- base::inherits
[10:19:24.948]             invokeRestart <- base::invokeRestart
[10:19:24.948]             length <- base::length
[10:19:24.948]             list <- base::list
[10:19:24.948]             seq.int <- base::seq.int
[10:19:24.948]             signalCondition <- base::signalCondition
[10:19:24.948]             sys.calls <- base::sys.calls
[10:19:24.948]             `[[` <- base::`[[`
[10:19:24.948]             `+` <- base::`+`
[10:19:24.948]             `<<-` <- base::`<<-`
[10:19:24.948]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:24.948]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:24.948]                   3L)]
[10:19:24.948]             }
[10:19:24.948]             function(cond) {
[10:19:24.948]                 is_error <- inherits(cond, "error")
[10:19:24.948]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:24.948]                   NULL)
[10:19:24.948]                 if (is_error) {
[10:19:24.948]                   sessionInformation <- function() {
[10:19:24.948]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:24.948]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:24.948]                       search = base::search(), system = base::Sys.info())
[10:19:24.948]                   }
[10:19:24.948]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.948]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:24.948]                     cond$call), session = sessionInformation(), 
[10:19:24.948]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:24.948]                   signalCondition(cond)
[10:19:24.948]                 }
[10:19:24.948]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:24.948]                 "immediateCondition"))) {
[10:19:24.948]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:24.948]                   ...future.conditions[[length(...future.conditions) + 
[10:19:24.948]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:24.948]                   if (TRUE && !signal) {
[10:19:24.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.948]                     {
[10:19:24.948]                       inherits <- base::inherits
[10:19:24.948]                       invokeRestart <- base::invokeRestart
[10:19:24.948]                       is.null <- base::is.null
[10:19:24.948]                       muffled <- FALSE
[10:19:24.948]                       if (inherits(cond, "message")) {
[10:19:24.948]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.948]                         if (muffled) 
[10:19:24.948]                           invokeRestart("muffleMessage")
[10:19:24.948]                       }
[10:19:24.948]                       else if (inherits(cond, "warning")) {
[10:19:24.948]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.948]                         if (muffled) 
[10:19:24.948]                           invokeRestart("muffleWarning")
[10:19:24.948]                       }
[10:19:24.948]                       else if (inherits(cond, "condition")) {
[10:19:24.948]                         if (!is.null(pattern)) {
[10:19:24.948]                           computeRestarts <- base::computeRestarts
[10:19:24.948]                           grepl <- base::grepl
[10:19:24.948]                           restarts <- computeRestarts(cond)
[10:19:24.948]                           for (restart in restarts) {
[10:19:24.948]                             name <- restart$name
[10:19:24.948]                             if (is.null(name)) 
[10:19:24.948]                               next
[10:19:24.948]                             if (!grepl(pattern, name)) 
[10:19:24.948]                               next
[10:19:24.948]                             invokeRestart(restart)
[10:19:24.948]                             muffled <- TRUE
[10:19:24.948]                             break
[10:19:24.948]                           }
[10:19:24.948]                         }
[10:19:24.948]                       }
[10:19:24.948]                       invisible(muffled)
[10:19:24.948]                     }
[10:19:24.948]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.948]                   }
[10:19:24.948]                 }
[10:19:24.948]                 else {
[10:19:24.948]                   if (TRUE) {
[10:19:24.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:24.948]                     {
[10:19:24.948]                       inherits <- base::inherits
[10:19:24.948]                       invokeRestart <- base::invokeRestart
[10:19:24.948]                       is.null <- base::is.null
[10:19:24.948]                       muffled <- FALSE
[10:19:24.948]                       if (inherits(cond, "message")) {
[10:19:24.948]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:24.948]                         if (muffled) 
[10:19:24.948]                           invokeRestart("muffleMessage")
[10:19:24.948]                       }
[10:19:24.948]                       else if (inherits(cond, "warning")) {
[10:19:24.948]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:24.948]                         if (muffled) 
[10:19:24.948]                           invokeRestart("muffleWarning")
[10:19:24.948]                       }
[10:19:24.948]                       else if (inherits(cond, "condition")) {
[10:19:24.948]                         if (!is.null(pattern)) {
[10:19:24.948]                           computeRestarts <- base::computeRestarts
[10:19:24.948]                           grepl <- base::grepl
[10:19:24.948]                           restarts <- computeRestarts(cond)
[10:19:24.948]                           for (restart in restarts) {
[10:19:24.948]                             name <- restart$name
[10:19:24.948]                             if (is.null(name)) 
[10:19:24.948]                               next
[10:19:24.948]                             if (!grepl(pattern, name)) 
[10:19:24.948]                               next
[10:19:24.948]                             invokeRestart(restart)
[10:19:24.948]                             muffled <- TRUE
[10:19:24.948]                             break
[10:19:24.948]                           }
[10:19:24.948]                         }
[10:19:24.948]                       }
[10:19:24.948]                       invisible(muffled)
[10:19:24.948]                     }
[10:19:24.948]                     muffleCondition(cond, pattern = "^muffle")
[10:19:24.948]                   }
[10:19:24.948]                 }
[10:19:24.948]             }
[10:19:24.948]         }))
[10:19:24.948]     }, error = function(ex) {
[10:19:24.948]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:24.948]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:24.948]                 ...future.rng), started = ...future.startTime, 
[10:19:24.948]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:24.948]             version = "1.8"), class = "FutureResult")
[10:19:24.948]     }, finally = {
[10:19:24.948]         if (!identical(...future.workdir, getwd())) 
[10:19:24.948]             setwd(...future.workdir)
[10:19:24.948]         {
[10:19:24.948]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:24.948]                 ...future.oldOptions$nwarnings <- NULL
[10:19:24.948]             }
[10:19:24.948]             base::options(...future.oldOptions)
[10:19:24.948]             if (.Platform$OS.type == "windows") {
[10:19:24.948]                 old_names <- names(...future.oldEnvVars)
[10:19:24.948]                 envs <- base::Sys.getenv()
[10:19:24.948]                 names <- names(envs)
[10:19:24.948]                 common <- intersect(names, old_names)
[10:19:24.948]                 added <- setdiff(names, old_names)
[10:19:24.948]                 removed <- setdiff(old_names, names)
[10:19:24.948]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:24.948]                   envs[common]]
[10:19:24.948]                 NAMES <- toupper(changed)
[10:19:24.948]                 args <- list()
[10:19:24.948]                 for (kk in seq_along(NAMES)) {
[10:19:24.948]                   name <- changed[[kk]]
[10:19:24.948]                   NAME <- NAMES[[kk]]
[10:19:24.948]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.948]                     next
[10:19:24.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.948]                 }
[10:19:24.948]                 NAMES <- toupper(added)
[10:19:24.948]                 for (kk in seq_along(NAMES)) {
[10:19:24.948]                   name <- added[[kk]]
[10:19:24.948]                   NAME <- NAMES[[kk]]
[10:19:24.948]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.948]                     next
[10:19:24.948]                   args[[name]] <- ""
[10:19:24.948]                 }
[10:19:24.948]                 NAMES <- toupper(removed)
[10:19:24.948]                 for (kk in seq_along(NAMES)) {
[10:19:24.948]                   name <- removed[[kk]]
[10:19:24.948]                   NAME <- NAMES[[kk]]
[10:19:24.948]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:24.948]                     next
[10:19:24.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:24.948]                 }
[10:19:24.948]                 if (length(args) > 0) 
[10:19:24.948]                   base::do.call(base::Sys.setenv, args = args)
[10:19:24.948]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:24.948]             }
[10:19:24.948]             else {
[10:19:24.948]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:24.948]             }
[10:19:24.948]             {
[10:19:24.948]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:24.948]                   0L) {
[10:19:24.948]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:24.948]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:24.948]                   base::options(opts)
[10:19:24.948]                 }
[10:19:24.948]                 {
[10:19:24.948]                   {
[10:19:24.948]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:24.948]                     NULL
[10:19:24.948]                   }
[10:19:24.948]                   options(future.plan = NULL)
[10:19:24.948]                   if (is.na(NA_character_)) 
[10:19:24.948]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:24.948]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:24.948]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:24.948]                     .init = FALSE)
[10:19:24.948]                 }
[10:19:24.948]             }
[10:19:24.948]         }
[10:19:24.948]     })
[10:19:24.948]     if (TRUE) {
[10:19:24.948]         base::sink(type = "output", split = FALSE)
[10:19:24.948]         if (TRUE) {
[10:19:24.948]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:24.948]         }
[10:19:24.948]         else {
[10:19:24.948]             ...future.result["stdout"] <- base::list(NULL)
[10:19:24.948]         }
[10:19:24.948]         base::close(...future.stdout)
[10:19:24.948]         ...future.stdout <- NULL
[10:19:24.948]     }
[10:19:24.948]     ...future.result$conditions <- ...future.conditions
[10:19:24.948]     ...future.result$finished <- base::Sys.time()
[10:19:24.948]     ...future.result
[10:19:24.948] }
[10:19:24.951] Exporting 5 global objects (1.11 KiB) to cluster node #2 ...
[10:19:24.951] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ...
[10:19:24.951] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ... DONE
[10:19:24.952] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:24.952] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.952] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ...
[10:19:24.952] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ... DONE
[10:19:24.953] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:24.953] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.953] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:24.953] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:24.953] Exporting 5 global objects (1.11 KiB) to cluster node #2 ... DONE
[10:19:24.954] MultisessionFuture started
[10:19:24.954] - Launch lazy future ... done
[10:19:24.954] run() for ‘MultisessionFuture’ ... done
[10:19:24.954] Created future:
[10:19:24.954] MultisessionFuture:
[10:19:24.954] Label: ‘future_mapply-2’
[10:19:24.954] Expression:
[10:19:24.954] {
[10:19:24.954]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:24.954]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:24.954]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:24.954]         on.exit(options(oopts), add = TRUE)
[10:19:24.954]     }
[10:19:24.954]     {
[10:19:24.954]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:24.954]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:24.954]         do.call(mapply, args = args)
[10:19:24.954]     }
[10:19:24.954] }
[10:19:24.954] Lazy evaluation: FALSE
[10:19:24.954] Asynchronous evaluation: TRUE
[10:19:24.954] Local evaluation: TRUE
[10:19:24.954] Environment: R_GlobalEnv
[10:19:24.954] Capture standard output: TRUE
[10:19:24.954] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:24.954] Globals: 5 objects totaling 695 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:24.954] Packages: <none>
[10:19:24.954] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:24.954] Resolved: FALSE
[10:19:24.954] Value: <not collected>
[10:19:24.954] Conditions captured: <none>
[10:19:24.954] Early signaling: FALSE
[10:19:24.954] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:24.954] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:24.966] Chunk #2 of 2 ... DONE
[10:19:24.966] Launching 2 futures (chunks) ... DONE
[10:19:24.966] Resolving 2 futures (chunks) ...
[10:19:24.967] resolve() on list ...
[10:19:24.967]  recursive: 0
[10:19:24.967]  length: 2
[10:19:24.967] 
[10:19:24.967] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.967] - Validating connection of MultisessionFuture
[10:19:24.968] - received message: FutureResult
[10:19:24.968] - Received FutureResult
[10:19:24.968] - Erased future from FutureRegistry
[10:19:24.968] result() for ClusterFuture ...
[10:19:24.968] - result already collected: FutureResult
[10:19:24.968] result() for ClusterFuture ... done
[10:19:24.968] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.968] Future #1
[10:19:24.968] result() for ClusterFuture ...
[10:19:24.968] - result already collected: FutureResult
[10:19:24.968] result() for ClusterFuture ... done
[10:19:24.969] result() for ClusterFuture ...
[10:19:24.969] - result already collected: FutureResult
[10:19:24.969] result() for ClusterFuture ... done
[10:19:24.969] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:24.969] - nx: 2
[10:19:24.969] - relay: TRUE
[10:19:24.969] - stdout: TRUE
[10:19:24.969] - signal: TRUE
[10:19:24.969] - resignal: FALSE
[10:19:24.969] - force: TRUE
[10:19:24.969] - relayed: [n=2] FALSE, FALSE
[10:19:24.969] - queued futures: [n=2] FALSE, FALSE
[10:19:24.969]  - until=1
[10:19:24.970]  - relaying element #1
[10:19:24.970] result() for ClusterFuture ...
[10:19:24.970] - result already collected: FutureResult
[10:19:24.970] result() for ClusterFuture ... done
[10:19:24.970] result() for ClusterFuture ...
[10:19:24.970] - result already collected: FutureResult
[10:19:24.970] result() for ClusterFuture ... done
[10:19:24.970] result() for ClusterFuture ...
[10:19:24.970] - result already collected: FutureResult
[10:19:24.970] result() for ClusterFuture ... done
[10:19:24.970] result() for ClusterFuture ...
[10:19:24.970] - result already collected: FutureResult
[10:19:24.970] result() for ClusterFuture ... done
[10:19:24.971] - relayed: [n=2] TRUE, FALSE
[10:19:24.971] - queued futures: [n=2] TRUE, FALSE
[10:19:24.971] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:24.971]  length: 1 (resolved future 1)
[10:19:24.996] receiveMessageFromWorker() for ClusterFuture ...
[10:19:24.996] - Validating connection of MultisessionFuture
[10:19:24.996] - received message: FutureResult
[10:19:24.997] - Received FutureResult
[10:19:24.997] - Erased future from FutureRegistry
[10:19:24.997] result() for ClusterFuture ...
[10:19:24.997] - result already collected: FutureResult
[10:19:24.997] result() for ClusterFuture ... done
[10:19:24.997] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:24.997] Future #2
[10:19:24.997] result() for ClusterFuture ...
[10:19:24.997] - result already collected: FutureResult
[10:19:24.997] result() for ClusterFuture ... done
[10:19:24.997] result() for ClusterFuture ...
[10:19:24.998] - result already collected: FutureResult
[10:19:24.998] result() for ClusterFuture ... done
[10:19:24.998] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:24.998] - nx: 2
[10:19:24.998] - relay: TRUE
[10:19:24.998] - stdout: TRUE
[10:19:24.998] - signal: TRUE
[10:19:24.998] - resignal: FALSE
[10:19:24.998] - force: TRUE
[10:19:24.998] - relayed: [n=2] TRUE, FALSE
[10:19:24.998] - queued futures: [n=2] TRUE, FALSE
[10:19:24.998]  - until=2
[10:19:24.998]  - relaying element #2
[10:19:24.999] result() for ClusterFuture ...
[10:19:24.999] - result already collected: FutureResult
[10:19:24.999] result() for ClusterFuture ... done
[10:19:24.999] result() for ClusterFuture ...
[10:19:24.999] - result already collected: FutureResult
[10:19:24.999] result() for ClusterFuture ... done
[10:19:24.999] result() for ClusterFuture ...
[10:19:24.999] - result already collected: FutureResult
[10:19:24.999] result() for ClusterFuture ... done
[10:19:24.999] result() for ClusterFuture ...
[10:19:24.999] - result already collected: FutureResult
[10:19:24.999] result() for ClusterFuture ... done
[10:19:25.000] - relayed: [n=2] TRUE, TRUE
[10:19:25.000] - queued futures: [n=2] TRUE, TRUE
[10:19:25.000] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:25.000]  length: 0 (resolved future 2)
[10:19:25.000] Relaying remaining futures
[10:19:25.000] signalConditionsASAP(NULL, pos=0) ...
[10:19:25.000] - nx: 2
[10:19:25.000] - relay: TRUE
[10:19:25.000] - stdout: TRUE
[10:19:25.000] - signal: TRUE
[10:19:25.000] - resignal: FALSE
[10:19:25.000] - force: TRUE
[10:19:25.000] - relayed: [n=2] TRUE, TRUE
[10:19:25.001] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:25.001] - relayed: [n=2] TRUE, TRUE
[10:19:25.001] - queued futures: [n=2] TRUE, TRUE
[10:19:25.001] signalConditionsASAP(NULL, pos=0) ... done
[10:19:25.001] resolve() on list ... DONE
[10:19:25.001] result() for ClusterFuture ...
[10:19:25.001] - result already collected: FutureResult
[10:19:25.001] result() for ClusterFuture ... done
[10:19:25.001] result() for ClusterFuture ...
[10:19:25.001] - result already collected: FutureResult
[10:19:25.001] result() for ClusterFuture ... done
[10:19:25.002] result() for ClusterFuture ...
[10:19:25.002] - result already collected: FutureResult
[10:19:25.002] result() for ClusterFuture ... done
[10:19:25.002] result() for ClusterFuture ...
[10:19:25.002] - result already collected: FutureResult
[10:19:25.002] result() for ClusterFuture ... done
[10:19:25.002]  - Number of value chunks collected: 2
[10:19:25.002] Resolving 2 futures (chunks) ... DONE
[10:19:25.002] Reducing values from 2 chunks ...
[10:19:25.002]  - Number of values collected after concatenation: 3
[10:19:25.002]  - Number of values expected: 3
[10:19:25.002] Reducing values from 2 chunks ... DONE
[10:19:25.003] future_mapply() ... DONE
- future_.mapply()
[10:19:25.003] future_mapply() ...
[10:19:25.005] Number of chunks: 2
[10:19:25.005] getGlobalsAndPackagesXApply() ...
[10:19:25.005]  - future.globals: TRUE
[10:19:25.005] getGlobalsAndPackages() ...
[10:19:25.005] Searching for globals...
[10:19:25.006] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[10:19:25.006] Searching for globals ... DONE
[10:19:25.006] Resolving globals: FALSE
[10:19:25.007] The total size of the 1 globals is 414 bytes (414 bytes)
[10:19:25.007] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[10:19:25.007] - globals: [1] ‘FUN’
[10:19:25.007] 
[10:19:25.007] getGlobalsAndPackages() ... DONE
[10:19:25.008]  - globals found/used: [n=1] ‘FUN’
[10:19:25.008]  - needed namespaces: [n=0] 
[10:19:25.008] Finding globals ... DONE
[10:19:25.008] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:25.008] List of 2
[10:19:25.008]  $ ...future.FUN:function (x, y)  
[10:19:25.008]  $ MoreArgs     : list()
[10:19:25.008]  - attr(*, "where")=List of 2
[10:19:25.008]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:25.008]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:25.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:25.008]  - attr(*, "resolved")= logi FALSE
[10:19:25.008]  - attr(*, "total_size")= num NA
[10:19:25.010] Packages to be attached in all futures: [n=0] 
[10:19:25.011] getGlobalsAndPackagesXApply() ... DONE
[10:19:25.011] Number of futures (= number of chunks): 2
[10:19:25.011] Launching 2 futures (chunks) ...
[10:19:25.011] Chunk #1 of 2 ...
[10:19:25.011]  - Finding globals in '...' for chunk #1 ...
[10:19:25.011] getGlobalsAndPackages() ...
[10:19:25.011] Searching for globals...
[10:19:25.011] 
[10:19:25.012] Searching for globals ... DONE
[10:19:25.012] - globals: [0] <none>
[10:19:25.012] getGlobalsAndPackages() ... DONE
[10:19:25.012]    + additional globals found: [n=0] 
[10:19:25.012]    + additional namespaces needed: [n=0] 
[10:19:25.012]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:25.012]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:25.012]  - seeds: <none>
[10:19:25.012]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.012] getGlobalsAndPackages() ...
[10:19:25.012] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.013] Resolving globals: FALSE
[10:19:25.013] The total size of the 5 globals is 649 bytes (649 bytes)
[10:19:25.013] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 649 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:25.013] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.014] 
[10:19:25.014] getGlobalsAndPackages() ... DONE
[10:19:25.014] run() for ‘Future’ ...
[10:19:25.014] - state: ‘created’
[10:19:25.014] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.028] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.028]   - Field: ‘node’
[10:19:25.028]   - Field: ‘label’
[10:19:25.028]   - Field: ‘local’
[10:19:25.028]   - Field: ‘owner’
[10:19:25.029]   - Field: ‘envir’
[10:19:25.029]   - Field: ‘workers’
[10:19:25.029]   - Field: ‘packages’
[10:19:25.029]   - Field: ‘gc’
[10:19:25.029]   - Field: ‘conditions’
[10:19:25.029]   - Field: ‘persistent’
[10:19:25.029]   - Field: ‘expr’
[10:19:25.029]   - Field: ‘uuid’
[10:19:25.029]   - Field: ‘seed’
[10:19:25.029]   - Field: ‘version’
[10:19:25.029]   - Field: ‘result’
[10:19:25.030]   - Field: ‘asynchronous’
[10:19:25.030]   - Field: ‘calls’
[10:19:25.030]   - Field: ‘globals’
[10:19:25.030]   - Field: ‘stdout’
[10:19:25.030]   - Field: ‘earlySignal’
[10:19:25.030]   - Field: ‘lazy’
[10:19:25.030]   - Field: ‘state’
[10:19:25.030] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.030] - Launch lazy future ...
[10:19:25.030] Packages needed by the future expression (n = 0): <none>
[10:19:25.031] Packages needed by future strategies (n = 0): <none>
[10:19:25.031] {
[10:19:25.031]     {
[10:19:25.031]         {
[10:19:25.031]             ...future.startTime <- base::Sys.time()
[10:19:25.031]             {
[10:19:25.031]                 {
[10:19:25.031]                   {
[10:19:25.031]                     {
[10:19:25.031]                       base::local({
[10:19:25.031]                         has_future <- base::requireNamespace("future", 
[10:19:25.031]                           quietly = TRUE)
[10:19:25.031]                         if (has_future) {
[10:19:25.031]                           ns <- base::getNamespace("future")
[10:19:25.031]                           version <- ns[[".package"]][["version"]]
[10:19:25.031]                           if (is.null(version)) 
[10:19:25.031]                             version <- utils::packageVersion("future")
[10:19:25.031]                         }
[10:19:25.031]                         else {
[10:19:25.031]                           version <- NULL
[10:19:25.031]                         }
[10:19:25.031]                         if (!has_future || version < "1.8.0") {
[10:19:25.031]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.031]                             "", base::R.version$version.string), 
[10:19:25.031]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.031]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.031]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.031]                               "release", "version")], collapse = " "), 
[10:19:25.031]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.031]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.031]                             info)
[10:19:25.031]                           info <- base::paste(info, collapse = "; ")
[10:19:25.031]                           if (!has_future) {
[10:19:25.031]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.031]                               info)
[10:19:25.031]                           }
[10:19:25.031]                           else {
[10:19:25.031]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.031]                               info, version)
[10:19:25.031]                           }
[10:19:25.031]                           base::stop(msg)
[10:19:25.031]                         }
[10:19:25.031]                       })
[10:19:25.031]                     }
[10:19:25.031]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.031]                     base::options(mc.cores = 1L)
[10:19:25.031]                   }
[10:19:25.031]                   ...future.strategy.old <- future::plan("list")
[10:19:25.031]                   options(future.plan = NULL)
[10:19:25.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.031]                 }
[10:19:25.031]                 ...future.workdir <- getwd()
[10:19:25.031]             }
[10:19:25.031]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.031]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.031]         }
[10:19:25.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.031]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:25.031]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.031]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.031]             base::names(...future.oldOptions))
[10:19:25.031]     }
[10:19:25.031]     if (FALSE) {
[10:19:25.031]     }
[10:19:25.031]     else {
[10:19:25.031]         if (TRUE) {
[10:19:25.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.031]                 open = "w")
[10:19:25.031]         }
[10:19:25.031]         else {
[10:19:25.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.031]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.031]         }
[10:19:25.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.031]             base::sink(type = "output", split = FALSE)
[10:19:25.031]             base::close(...future.stdout)
[10:19:25.031]         }, add = TRUE)
[10:19:25.031]     }
[10:19:25.031]     ...future.frame <- base::sys.nframe()
[10:19:25.031]     ...future.conditions <- base::list()
[10:19:25.031]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.031]     if (FALSE) {
[10:19:25.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.031]     }
[10:19:25.031]     ...future.result <- base::tryCatch({
[10:19:25.031]         base::withCallingHandlers({
[10:19:25.031]             ...future.value <- base::withVisible(base::local({
[10:19:25.031]                 ...future.makeSendCondition <- base::local({
[10:19:25.031]                   sendCondition <- NULL
[10:19:25.031]                   function(frame = 1L) {
[10:19:25.031]                     if (is.function(sendCondition)) 
[10:19:25.031]                       return(sendCondition)
[10:19:25.031]                     ns <- getNamespace("parallel")
[10:19:25.031]                     if (exists("sendData", mode = "function", 
[10:19:25.031]                       envir = ns)) {
[10:19:25.031]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.031]                         envir = ns)
[10:19:25.031]                       envir <- sys.frame(frame)
[10:19:25.031]                       master <- NULL
[10:19:25.031]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.031]                         !identical(envir, emptyenv())) {
[10:19:25.031]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.031]                           inherits = FALSE)) {
[10:19:25.031]                           master <- get("master", mode = "list", 
[10:19:25.031]                             envir = envir, inherits = FALSE)
[10:19:25.031]                           if (inherits(master, c("SOCKnode", 
[10:19:25.031]                             "SOCK0node"))) {
[10:19:25.031]                             sendCondition <<- function(cond) {
[10:19:25.031]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.031]                                 success = TRUE)
[10:19:25.031]                               parallel_sendData(master, data)
[10:19:25.031]                             }
[10:19:25.031]                             return(sendCondition)
[10:19:25.031]                           }
[10:19:25.031]                         }
[10:19:25.031]                         frame <- frame + 1L
[10:19:25.031]                         envir <- sys.frame(frame)
[10:19:25.031]                       }
[10:19:25.031]                     }
[10:19:25.031]                     sendCondition <<- function(cond) NULL
[10:19:25.031]                   }
[10:19:25.031]                 })
[10:19:25.031]                 withCallingHandlers({
[10:19:25.031]                   {
[10:19:25.031]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.031]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.031]                       ...future.globals.maxSize)) {
[10:19:25.031]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.031]                       on.exit(options(oopts), add = TRUE)
[10:19:25.031]                     }
[10:19:25.031]                     {
[10:19:25.031]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.031]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.031]                         USE.NAMES = FALSE)
[10:19:25.031]                       do.call(mapply, args = args)
[10:19:25.031]                     }
[10:19:25.031]                   }
[10:19:25.031]                 }, immediateCondition = function(cond) {
[10:19:25.031]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.031]                   sendCondition(cond)
[10:19:25.031]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.031]                   {
[10:19:25.031]                     inherits <- base::inherits
[10:19:25.031]                     invokeRestart <- base::invokeRestart
[10:19:25.031]                     is.null <- base::is.null
[10:19:25.031]                     muffled <- FALSE
[10:19:25.031]                     if (inherits(cond, "message")) {
[10:19:25.031]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.031]                       if (muffled) 
[10:19:25.031]                         invokeRestart("muffleMessage")
[10:19:25.031]                     }
[10:19:25.031]                     else if (inherits(cond, "warning")) {
[10:19:25.031]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.031]                       if (muffled) 
[10:19:25.031]                         invokeRestart("muffleWarning")
[10:19:25.031]                     }
[10:19:25.031]                     else if (inherits(cond, "condition")) {
[10:19:25.031]                       if (!is.null(pattern)) {
[10:19:25.031]                         computeRestarts <- base::computeRestarts
[10:19:25.031]                         grepl <- base::grepl
[10:19:25.031]                         restarts <- computeRestarts(cond)
[10:19:25.031]                         for (restart in restarts) {
[10:19:25.031]                           name <- restart$name
[10:19:25.031]                           if (is.null(name)) 
[10:19:25.031]                             next
[10:19:25.031]                           if (!grepl(pattern, name)) 
[10:19:25.031]                             next
[10:19:25.031]                           invokeRestart(restart)
[10:19:25.031]                           muffled <- TRUE
[10:19:25.031]                           break
[10:19:25.031]                         }
[10:19:25.031]                       }
[10:19:25.031]                     }
[10:19:25.031]                     invisible(muffled)
[10:19:25.031]                   }
[10:19:25.031]                   muffleCondition(cond)
[10:19:25.031]                 })
[10:19:25.031]             }))
[10:19:25.031]             future::FutureResult(value = ...future.value$value, 
[10:19:25.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.031]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.031]                     ...future.globalenv.names))
[10:19:25.031]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.031]         }, condition = base::local({
[10:19:25.031]             c <- base::c
[10:19:25.031]             inherits <- base::inherits
[10:19:25.031]             invokeRestart <- base::invokeRestart
[10:19:25.031]             length <- base::length
[10:19:25.031]             list <- base::list
[10:19:25.031]             seq.int <- base::seq.int
[10:19:25.031]             signalCondition <- base::signalCondition
[10:19:25.031]             sys.calls <- base::sys.calls
[10:19:25.031]             `[[` <- base::`[[`
[10:19:25.031]             `+` <- base::`+`
[10:19:25.031]             `<<-` <- base::`<<-`
[10:19:25.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.031]                   3L)]
[10:19:25.031]             }
[10:19:25.031]             function(cond) {
[10:19:25.031]                 is_error <- inherits(cond, "error")
[10:19:25.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.031]                   NULL)
[10:19:25.031]                 if (is_error) {
[10:19:25.031]                   sessionInformation <- function() {
[10:19:25.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.031]                       search = base::search(), system = base::Sys.info())
[10:19:25.031]                   }
[10:19:25.031]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.031]                     cond$call), session = sessionInformation(), 
[10:19:25.031]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.031]                   signalCondition(cond)
[10:19:25.031]                 }
[10:19:25.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.031]                 "immediateCondition"))) {
[10:19:25.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.031]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.031]                   if (TRUE && !signal) {
[10:19:25.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.031]                     {
[10:19:25.031]                       inherits <- base::inherits
[10:19:25.031]                       invokeRestart <- base::invokeRestart
[10:19:25.031]                       is.null <- base::is.null
[10:19:25.031]                       muffled <- FALSE
[10:19:25.031]                       if (inherits(cond, "message")) {
[10:19:25.031]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.031]                         if (muffled) 
[10:19:25.031]                           invokeRestart("muffleMessage")
[10:19:25.031]                       }
[10:19:25.031]                       else if (inherits(cond, "warning")) {
[10:19:25.031]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.031]                         if (muffled) 
[10:19:25.031]                           invokeRestart("muffleWarning")
[10:19:25.031]                       }
[10:19:25.031]                       else if (inherits(cond, "condition")) {
[10:19:25.031]                         if (!is.null(pattern)) {
[10:19:25.031]                           computeRestarts <- base::computeRestarts
[10:19:25.031]                           grepl <- base::grepl
[10:19:25.031]                           restarts <- computeRestarts(cond)
[10:19:25.031]                           for (restart in restarts) {
[10:19:25.031]                             name <- restart$name
[10:19:25.031]                             if (is.null(name)) 
[10:19:25.031]                               next
[10:19:25.031]                             if (!grepl(pattern, name)) 
[10:19:25.031]                               next
[10:19:25.031]                             invokeRestart(restart)
[10:19:25.031]                             muffled <- TRUE
[10:19:25.031]                             break
[10:19:25.031]                           }
[10:19:25.031]                         }
[10:19:25.031]                       }
[10:19:25.031]                       invisible(muffled)
[10:19:25.031]                     }
[10:19:25.031]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.031]                   }
[10:19:25.031]                 }
[10:19:25.031]                 else {
[10:19:25.031]                   if (TRUE) {
[10:19:25.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.031]                     {
[10:19:25.031]                       inherits <- base::inherits
[10:19:25.031]                       invokeRestart <- base::invokeRestart
[10:19:25.031]                       is.null <- base::is.null
[10:19:25.031]                       muffled <- FALSE
[10:19:25.031]                       if (inherits(cond, "message")) {
[10:19:25.031]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.031]                         if (muffled) 
[10:19:25.031]                           invokeRestart("muffleMessage")
[10:19:25.031]                       }
[10:19:25.031]                       else if (inherits(cond, "warning")) {
[10:19:25.031]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.031]                         if (muffled) 
[10:19:25.031]                           invokeRestart("muffleWarning")
[10:19:25.031]                       }
[10:19:25.031]                       else if (inherits(cond, "condition")) {
[10:19:25.031]                         if (!is.null(pattern)) {
[10:19:25.031]                           computeRestarts <- base::computeRestarts
[10:19:25.031]                           grepl <- base::grepl
[10:19:25.031]                           restarts <- computeRestarts(cond)
[10:19:25.031]                           for (restart in restarts) {
[10:19:25.031]                             name <- restart$name
[10:19:25.031]                             if (is.null(name)) 
[10:19:25.031]                               next
[10:19:25.031]                             if (!grepl(pattern, name)) 
[10:19:25.031]                               next
[10:19:25.031]                             invokeRestart(restart)
[10:19:25.031]                             muffled <- TRUE
[10:19:25.031]                             break
[10:19:25.031]                           }
[10:19:25.031]                         }
[10:19:25.031]                       }
[10:19:25.031]                       invisible(muffled)
[10:19:25.031]                     }
[10:19:25.031]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.031]                   }
[10:19:25.031]                 }
[10:19:25.031]             }
[10:19:25.031]         }))
[10:19:25.031]     }, error = function(ex) {
[10:19:25.031]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.031]                 ...future.rng), started = ...future.startTime, 
[10:19:25.031]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.031]             version = "1.8"), class = "FutureResult")
[10:19:25.031]     }, finally = {
[10:19:25.031]         if (!identical(...future.workdir, getwd())) 
[10:19:25.031]             setwd(...future.workdir)
[10:19:25.031]         {
[10:19:25.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.031]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.031]             }
[10:19:25.031]             base::options(...future.oldOptions)
[10:19:25.031]             if (.Platform$OS.type == "windows") {
[10:19:25.031]                 old_names <- names(...future.oldEnvVars)
[10:19:25.031]                 envs <- base::Sys.getenv()
[10:19:25.031]                 names <- names(envs)
[10:19:25.031]                 common <- intersect(names, old_names)
[10:19:25.031]                 added <- setdiff(names, old_names)
[10:19:25.031]                 removed <- setdiff(old_names, names)
[10:19:25.031]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.031]                   envs[common]]
[10:19:25.031]                 NAMES <- toupper(changed)
[10:19:25.031]                 args <- list()
[10:19:25.031]                 for (kk in seq_along(NAMES)) {
[10:19:25.031]                   name <- changed[[kk]]
[10:19:25.031]                   NAME <- NAMES[[kk]]
[10:19:25.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.031]                     next
[10:19:25.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.031]                 }
[10:19:25.031]                 NAMES <- toupper(added)
[10:19:25.031]                 for (kk in seq_along(NAMES)) {
[10:19:25.031]                   name <- added[[kk]]
[10:19:25.031]                   NAME <- NAMES[[kk]]
[10:19:25.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.031]                     next
[10:19:25.031]                   args[[name]] <- ""
[10:19:25.031]                 }
[10:19:25.031]                 NAMES <- toupper(removed)
[10:19:25.031]                 for (kk in seq_along(NAMES)) {
[10:19:25.031]                   name <- removed[[kk]]
[10:19:25.031]                   NAME <- NAMES[[kk]]
[10:19:25.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.031]                     next
[10:19:25.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.031]                 }
[10:19:25.031]                 if (length(args) > 0) 
[10:19:25.031]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.031]             }
[10:19:25.031]             else {
[10:19:25.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.031]             }
[10:19:25.031]             {
[10:19:25.031]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.031]                   0L) {
[10:19:25.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.031]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.031]                   base::options(opts)
[10:19:25.031]                 }
[10:19:25.031]                 {
[10:19:25.031]                   {
[10:19:25.031]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.031]                     NULL
[10:19:25.031]                   }
[10:19:25.031]                   options(future.plan = NULL)
[10:19:25.031]                   if (is.na(NA_character_)) 
[10:19:25.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.031]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.031]                     .init = FALSE)
[10:19:25.031]                 }
[10:19:25.031]             }
[10:19:25.031]         }
[10:19:25.031]     })
[10:19:25.031]     if (TRUE) {
[10:19:25.031]         base::sink(type = "output", split = FALSE)
[10:19:25.031]         if (TRUE) {
[10:19:25.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.031]         }
[10:19:25.031]         else {
[10:19:25.031]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.031]         }
[10:19:25.031]         base::close(...future.stdout)
[10:19:25.031]         ...future.stdout <- NULL
[10:19:25.031]     }
[10:19:25.031]     ...future.result$conditions <- ...future.conditions
[10:19:25.031]     ...future.result$finished <- base::Sys.time()
[10:19:25.031]     ...future.result
[10:19:25.031] }
[10:19:25.034] Exporting 5 global objects (1.06 KiB) to cluster node #1 ...
[10:19:25.034] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ...
[10:19:25.034] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ... DONE
[10:19:25.035] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[10:19:25.035] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[10:19:25.035] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ...
[10:19:25.036] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ... DONE
[10:19:25.036] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:25.036] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.037] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:25.037] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.037] Exporting 5 global objects (1.06 KiB) to cluster node #1 ... DONE
[10:19:25.038] MultisessionFuture started
[10:19:25.038] - Launch lazy future ... done
[10:19:25.038] run() for ‘MultisessionFuture’ ... done
[10:19:25.038] Created future:
[10:19:25.038] MultisessionFuture:
[10:19:25.038] Label: ‘future_.mapply-1’
[10:19:25.038] Expression:
[10:19:25.038] {
[10:19:25.038]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.038]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.038]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.038]         on.exit(options(oopts), add = TRUE)
[10:19:25.038]     }
[10:19:25.038]     {
[10:19:25.038]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.038]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.038]         do.call(mapply, args = args)
[10:19:25.038]     }
[10:19:25.038] }
[10:19:25.038] Lazy evaluation: FALSE
[10:19:25.038] Asynchronous evaluation: TRUE
[10:19:25.038] Local evaluation: TRUE
[10:19:25.038] Environment: R_GlobalEnv
[10:19:25.038] Capture standard output: TRUE
[10:19:25.038] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.038] Globals: 5 objects totaling 649 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.038] Packages: <none>
[10:19:25.038] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.038] Resolved: FALSE
[10:19:25.038] Value: <not collected>
[10:19:25.038] Conditions captured: <none>
[10:19:25.038] Early signaling: FALSE
[10:19:25.038] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.038] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.050] Chunk #1 of 2 ... DONE
[10:19:25.050] Chunk #2 of 2 ...
[10:19:25.050]  - Finding globals in '...' for chunk #2 ...
[10:19:25.050] getGlobalsAndPackages() ...
[10:19:25.050] Searching for globals...
[10:19:25.051] 
[10:19:25.051] Searching for globals ... DONE
[10:19:25.051] - globals: [0] <none>
[10:19:25.051] getGlobalsAndPackages() ... DONE
[10:19:25.051]    + additional globals found: [n=0] 
[10:19:25.051]    + additional namespaces needed: [n=0] 
[10:19:25.051]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:25.051]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:25.051]  - seeds: <none>
[10:19:25.051]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.051] getGlobalsAndPackages() ...
[10:19:25.052] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.052] Resolving globals: FALSE
[10:19:25.052] The total size of the 5 globals is 699 bytes (699 bytes)
[10:19:25.053] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 699 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:25.053] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.053] 
[10:19:25.053] getGlobalsAndPackages() ... DONE
[10:19:25.053] run() for ‘Future’ ...
[10:19:25.053] - state: ‘created’
[10:19:25.053] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.067] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.067]   - Field: ‘node’
[10:19:25.067]   - Field: ‘label’
[10:19:25.068]   - Field: ‘local’
[10:19:25.068]   - Field: ‘owner’
[10:19:25.068]   - Field: ‘envir’
[10:19:25.068]   - Field: ‘workers’
[10:19:25.068]   - Field: ‘packages’
[10:19:25.068]   - Field: ‘gc’
[10:19:25.068]   - Field: ‘conditions’
[10:19:25.068]   - Field: ‘persistent’
[10:19:25.068]   - Field: ‘expr’
[10:19:25.068]   - Field: ‘uuid’
[10:19:25.068]   - Field: ‘seed’
[10:19:25.069]   - Field: ‘version’
[10:19:25.069]   - Field: ‘result’
[10:19:25.069]   - Field: ‘asynchronous’
[10:19:25.069]   - Field: ‘calls’
[10:19:25.069]   - Field: ‘globals’
[10:19:25.069]   - Field: ‘stdout’
[10:19:25.069]   - Field: ‘earlySignal’
[10:19:25.069]   - Field: ‘lazy’
[10:19:25.069]   - Field: ‘state’
[10:19:25.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.069] - Launch lazy future ...
[10:19:25.070] Packages needed by the future expression (n = 0): <none>
[10:19:25.070] Packages needed by future strategies (n = 0): <none>
[10:19:25.070] {
[10:19:25.070]     {
[10:19:25.070]         {
[10:19:25.070]             ...future.startTime <- base::Sys.time()
[10:19:25.070]             {
[10:19:25.070]                 {
[10:19:25.070]                   {
[10:19:25.070]                     {
[10:19:25.070]                       base::local({
[10:19:25.070]                         has_future <- base::requireNamespace("future", 
[10:19:25.070]                           quietly = TRUE)
[10:19:25.070]                         if (has_future) {
[10:19:25.070]                           ns <- base::getNamespace("future")
[10:19:25.070]                           version <- ns[[".package"]][["version"]]
[10:19:25.070]                           if (is.null(version)) 
[10:19:25.070]                             version <- utils::packageVersion("future")
[10:19:25.070]                         }
[10:19:25.070]                         else {
[10:19:25.070]                           version <- NULL
[10:19:25.070]                         }
[10:19:25.070]                         if (!has_future || version < "1.8.0") {
[10:19:25.070]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.070]                             "", base::R.version$version.string), 
[10:19:25.070]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.070]                               "release", "version")], collapse = " "), 
[10:19:25.070]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.070]                             info)
[10:19:25.070]                           info <- base::paste(info, collapse = "; ")
[10:19:25.070]                           if (!has_future) {
[10:19:25.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.070]                               info)
[10:19:25.070]                           }
[10:19:25.070]                           else {
[10:19:25.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.070]                               info, version)
[10:19:25.070]                           }
[10:19:25.070]                           base::stop(msg)
[10:19:25.070]                         }
[10:19:25.070]                       })
[10:19:25.070]                     }
[10:19:25.070]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.070]                     base::options(mc.cores = 1L)
[10:19:25.070]                   }
[10:19:25.070]                   ...future.strategy.old <- future::plan("list")
[10:19:25.070]                   options(future.plan = NULL)
[10:19:25.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.070]                 }
[10:19:25.070]                 ...future.workdir <- getwd()
[10:19:25.070]             }
[10:19:25.070]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.070]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.070]         }
[10:19:25.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.070]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:25.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.070]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.070]             base::names(...future.oldOptions))
[10:19:25.070]     }
[10:19:25.070]     if (FALSE) {
[10:19:25.070]     }
[10:19:25.070]     else {
[10:19:25.070]         if (TRUE) {
[10:19:25.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.070]                 open = "w")
[10:19:25.070]         }
[10:19:25.070]         else {
[10:19:25.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.070]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.070]         }
[10:19:25.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.070]             base::sink(type = "output", split = FALSE)
[10:19:25.070]             base::close(...future.stdout)
[10:19:25.070]         }, add = TRUE)
[10:19:25.070]     }
[10:19:25.070]     ...future.frame <- base::sys.nframe()
[10:19:25.070]     ...future.conditions <- base::list()
[10:19:25.070]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.070]     if (FALSE) {
[10:19:25.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.070]     }
[10:19:25.070]     ...future.result <- base::tryCatch({
[10:19:25.070]         base::withCallingHandlers({
[10:19:25.070]             ...future.value <- base::withVisible(base::local({
[10:19:25.070]                 ...future.makeSendCondition <- base::local({
[10:19:25.070]                   sendCondition <- NULL
[10:19:25.070]                   function(frame = 1L) {
[10:19:25.070]                     if (is.function(sendCondition)) 
[10:19:25.070]                       return(sendCondition)
[10:19:25.070]                     ns <- getNamespace("parallel")
[10:19:25.070]                     if (exists("sendData", mode = "function", 
[10:19:25.070]                       envir = ns)) {
[10:19:25.070]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.070]                         envir = ns)
[10:19:25.070]                       envir <- sys.frame(frame)
[10:19:25.070]                       master <- NULL
[10:19:25.070]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.070]                         !identical(envir, emptyenv())) {
[10:19:25.070]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.070]                           inherits = FALSE)) {
[10:19:25.070]                           master <- get("master", mode = "list", 
[10:19:25.070]                             envir = envir, inherits = FALSE)
[10:19:25.070]                           if (inherits(master, c("SOCKnode", 
[10:19:25.070]                             "SOCK0node"))) {
[10:19:25.070]                             sendCondition <<- function(cond) {
[10:19:25.070]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.070]                                 success = TRUE)
[10:19:25.070]                               parallel_sendData(master, data)
[10:19:25.070]                             }
[10:19:25.070]                             return(sendCondition)
[10:19:25.070]                           }
[10:19:25.070]                         }
[10:19:25.070]                         frame <- frame + 1L
[10:19:25.070]                         envir <- sys.frame(frame)
[10:19:25.070]                       }
[10:19:25.070]                     }
[10:19:25.070]                     sendCondition <<- function(cond) NULL
[10:19:25.070]                   }
[10:19:25.070]                 })
[10:19:25.070]                 withCallingHandlers({
[10:19:25.070]                   {
[10:19:25.070]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.070]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.070]                       ...future.globals.maxSize)) {
[10:19:25.070]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.070]                       on.exit(options(oopts), add = TRUE)
[10:19:25.070]                     }
[10:19:25.070]                     {
[10:19:25.070]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.070]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.070]                         USE.NAMES = FALSE)
[10:19:25.070]                       do.call(mapply, args = args)
[10:19:25.070]                     }
[10:19:25.070]                   }
[10:19:25.070]                 }, immediateCondition = function(cond) {
[10:19:25.070]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.070]                   sendCondition(cond)
[10:19:25.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.070]                   {
[10:19:25.070]                     inherits <- base::inherits
[10:19:25.070]                     invokeRestart <- base::invokeRestart
[10:19:25.070]                     is.null <- base::is.null
[10:19:25.070]                     muffled <- FALSE
[10:19:25.070]                     if (inherits(cond, "message")) {
[10:19:25.070]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.070]                       if (muffled) 
[10:19:25.070]                         invokeRestart("muffleMessage")
[10:19:25.070]                     }
[10:19:25.070]                     else if (inherits(cond, "warning")) {
[10:19:25.070]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.070]                       if (muffled) 
[10:19:25.070]                         invokeRestart("muffleWarning")
[10:19:25.070]                     }
[10:19:25.070]                     else if (inherits(cond, "condition")) {
[10:19:25.070]                       if (!is.null(pattern)) {
[10:19:25.070]                         computeRestarts <- base::computeRestarts
[10:19:25.070]                         grepl <- base::grepl
[10:19:25.070]                         restarts <- computeRestarts(cond)
[10:19:25.070]                         for (restart in restarts) {
[10:19:25.070]                           name <- restart$name
[10:19:25.070]                           if (is.null(name)) 
[10:19:25.070]                             next
[10:19:25.070]                           if (!grepl(pattern, name)) 
[10:19:25.070]                             next
[10:19:25.070]                           invokeRestart(restart)
[10:19:25.070]                           muffled <- TRUE
[10:19:25.070]                           break
[10:19:25.070]                         }
[10:19:25.070]                       }
[10:19:25.070]                     }
[10:19:25.070]                     invisible(muffled)
[10:19:25.070]                   }
[10:19:25.070]                   muffleCondition(cond)
[10:19:25.070]                 })
[10:19:25.070]             }))
[10:19:25.070]             future::FutureResult(value = ...future.value$value, 
[10:19:25.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.070]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.070]                     ...future.globalenv.names))
[10:19:25.070]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.070]         }, condition = base::local({
[10:19:25.070]             c <- base::c
[10:19:25.070]             inherits <- base::inherits
[10:19:25.070]             invokeRestart <- base::invokeRestart
[10:19:25.070]             length <- base::length
[10:19:25.070]             list <- base::list
[10:19:25.070]             seq.int <- base::seq.int
[10:19:25.070]             signalCondition <- base::signalCondition
[10:19:25.070]             sys.calls <- base::sys.calls
[10:19:25.070]             `[[` <- base::`[[`
[10:19:25.070]             `+` <- base::`+`
[10:19:25.070]             `<<-` <- base::`<<-`
[10:19:25.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.070]                   3L)]
[10:19:25.070]             }
[10:19:25.070]             function(cond) {
[10:19:25.070]                 is_error <- inherits(cond, "error")
[10:19:25.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.070]                   NULL)
[10:19:25.070]                 if (is_error) {
[10:19:25.070]                   sessionInformation <- function() {
[10:19:25.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.070]                       search = base::search(), system = base::Sys.info())
[10:19:25.070]                   }
[10:19:25.070]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.070]                     cond$call), session = sessionInformation(), 
[10:19:25.070]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.070]                   signalCondition(cond)
[10:19:25.070]                 }
[10:19:25.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.070]                 "immediateCondition"))) {
[10:19:25.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.070]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.070]                   if (TRUE && !signal) {
[10:19:25.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.070]                     {
[10:19:25.070]                       inherits <- base::inherits
[10:19:25.070]                       invokeRestart <- base::invokeRestart
[10:19:25.070]                       is.null <- base::is.null
[10:19:25.070]                       muffled <- FALSE
[10:19:25.070]                       if (inherits(cond, "message")) {
[10:19:25.070]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.070]                         if (muffled) 
[10:19:25.070]                           invokeRestart("muffleMessage")
[10:19:25.070]                       }
[10:19:25.070]                       else if (inherits(cond, "warning")) {
[10:19:25.070]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.070]                         if (muffled) 
[10:19:25.070]                           invokeRestart("muffleWarning")
[10:19:25.070]                       }
[10:19:25.070]                       else if (inherits(cond, "condition")) {
[10:19:25.070]                         if (!is.null(pattern)) {
[10:19:25.070]                           computeRestarts <- base::computeRestarts
[10:19:25.070]                           grepl <- base::grepl
[10:19:25.070]                           restarts <- computeRestarts(cond)
[10:19:25.070]                           for (restart in restarts) {
[10:19:25.070]                             name <- restart$name
[10:19:25.070]                             if (is.null(name)) 
[10:19:25.070]                               next
[10:19:25.070]                             if (!grepl(pattern, name)) 
[10:19:25.070]                               next
[10:19:25.070]                             invokeRestart(restart)
[10:19:25.070]                             muffled <- TRUE
[10:19:25.070]                             break
[10:19:25.070]                           }
[10:19:25.070]                         }
[10:19:25.070]                       }
[10:19:25.070]                       invisible(muffled)
[10:19:25.070]                     }
[10:19:25.070]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.070]                   }
[10:19:25.070]                 }
[10:19:25.070]                 else {
[10:19:25.070]                   if (TRUE) {
[10:19:25.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.070]                     {
[10:19:25.070]                       inherits <- base::inherits
[10:19:25.070]                       invokeRestart <- base::invokeRestart
[10:19:25.070]                       is.null <- base::is.null
[10:19:25.070]                       muffled <- FALSE
[10:19:25.070]                       if (inherits(cond, "message")) {
[10:19:25.070]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.070]                         if (muffled) 
[10:19:25.070]                           invokeRestart("muffleMessage")
[10:19:25.070]                       }
[10:19:25.070]                       else if (inherits(cond, "warning")) {
[10:19:25.070]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.070]                         if (muffled) 
[10:19:25.070]                           invokeRestart("muffleWarning")
[10:19:25.070]                       }
[10:19:25.070]                       else if (inherits(cond, "condition")) {
[10:19:25.070]                         if (!is.null(pattern)) {
[10:19:25.070]                           computeRestarts <- base::computeRestarts
[10:19:25.070]                           grepl <- base::grepl
[10:19:25.070]                           restarts <- computeRestarts(cond)
[10:19:25.070]                           for (restart in restarts) {
[10:19:25.070]                             name <- restart$name
[10:19:25.070]                             if (is.null(name)) 
[10:19:25.070]                               next
[10:19:25.070]                             if (!grepl(pattern, name)) 
[10:19:25.070]                               next
[10:19:25.070]                             invokeRestart(restart)
[10:19:25.070]                             muffled <- TRUE
[10:19:25.070]                             break
[10:19:25.070]                           }
[10:19:25.070]                         }
[10:19:25.070]                       }
[10:19:25.070]                       invisible(muffled)
[10:19:25.070]                     }
[10:19:25.070]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.070]                   }
[10:19:25.070]                 }
[10:19:25.070]             }
[10:19:25.070]         }))
[10:19:25.070]     }, error = function(ex) {
[10:19:25.070]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.070]                 ...future.rng), started = ...future.startTime, 
[10:19:25.070]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.070]             version = "1.8"), class = "FutureResult")
[10:19:25.070]     }, finally = {
[10:19:25.070]         if (!identical(...future.workdir, getwd())) 
[10:19:25.070]             setwd(...future.workdir)
[10:19:25.070]         {
[10:19:25.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.070]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.070]             }
[10:19:25.070]             base::options(...future.oldOptions)
[10:19:25.070]             if (.Platform$OS.type == "windows") {
[10:19:25.070]                 old_names <- names(...future.oldEnvVars)
[10:19:25.070]                 envs <- base::Sys.getenv()
[10:19:25.070]                 names <- names(envs)
[10:19:25.070]                 common <- intersect(names, old_names)
[10:19:25.070]                 added <- setdiff(names, old_names)
[10:19:25.070]                 removed <- setdiff(old_names, names)
[10:19:25.070]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.070]                   envs[common]]
[10:19:25.070]                 NAMES <- toupper(changed)
[10:19:25.070]                 args <- list()
[10:19:25.070]                 for (kk in seq_along(NAMES)) {
[10:19:25.070]                   name <- changed[[kk]]
[10:19:25.070]                   NAME <- NAMES[[kk]]
[10:19:25.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.070]                     next
[10:19:25.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.070]                 }
[10:19:25.070]                 NAMES <- toupper(added)
[10:19:25.070]                 for (kk in seq_along(NAMES)) {
[10:19:25.070]                   name <- added[[kk]]
[10:19:25.070]                   NAME <- NAMES[[kk]]
[10:19:25.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.070]                     next
[10:19:25.070]                   args[[name]] <- ""
[10:19:25.070]                 }
[10:19:25.070]                 NAMES <- toupper(removed)
[10:19:25.070]                 for (kk in seq_along(NAMES)) {
[10:19:25.070]                   name <- removed[[kk]]
[10:19:25.070]                   NAME <- NAMES[[kk]]
[10:19:25.070]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.070]                     next
[10:19:25.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.070]                 }
[10:19:25.070]                 if (length(args) > 0) 
[10:19:25.070]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.070]             }
[10:19:25.070]             else {
[10:19:25.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.070]             }
[10:19:25.070]             {
[10:19:25.070]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.070]                   0L) {
[10:19:25.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.070]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.070]                   base::options(opts)
[10:19:25.070]                 }
[10:19:25.070]                 {
[10:19:25.070]                   {
[10:19:25.070]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.070]                     NULL
[10:19:25.070]                   }
[10:19:25.070]                   options(future.plan = NULL)
[10:19:25.070]                   if (is.na(NA_character_)) 
[10:19:25.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.070]                     .init = FALSE)
[10:19:25.070]                 }
[10:19:25.070]             }
[10:19:25.070]         }
[10:19:25.070]     })
[10:19:25.070]     if (TRUE) {
[10:19:25.070]         base::sink(type = "output", split = FALSE)
[10:19:25.070]         if (TRUE) {
[10:19:25.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.070]         }
[10:19:25.070]         else {
[10:19:25.070]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.070]         }
[10:19:25.070]         base::close(...future.stdout)
[10:19:25.070]         ...future.stdout <- NULL
[10:19:25.070]     }
[10:19:25.070]     ...future.result$conditions <- ...future.conditions
[10:19:25.070]     ...future.result$finished <- base::Sys.time()
[10:19:25.070]     ...future.result
[10:19:25.070] }
[10:19:25.073] Exporting 5 global objects (1.11 KiB) to cluster node #2 ...
[10:19:25.073] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ...
[10:19:25.074] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ... DONE
[10:19:25.074] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[10:19:25.074] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[10:19:25.074] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ...
[10:19:25.075] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ... DONE
[10:19:25.075] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:25.075] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.075] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:25.075] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.076] Exporting 5 global objects (1.11 KiB) to cluster node #2 ... DONE
[10:19:25.076] MultisessionFuture started
[10:19:25.076] - Launch lazy future ... done
[10:19:25.076] run() for ‘MultisessionFuture’ ... done
[10:19:25.076] Created future:
[10:19:25.076] MultisessionFuture:
[10:19:25.076] Label: ‘future_.mapply-2’
[10:19:25.076] Expression:
[10:19:25.076] {
[10:19:25.076]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.076]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.076]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.076]         on.exit(options(oopts), add = TRUE)
[10:19:25.076]     }
[10:19:25.076]     {
[10:19:25.076]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.076]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.076]         do.call(mapply, args = args)
[10:19:25.076]     }
[10:19:25.076] }
[10:19:25.076] Lazy evaluation: FALSE
[10:19:25.076] Asynchronous evaluation: TRUE
[10:19:25.076] Local evaluation: TRUE
[10:19:25.076] Environment: R_GlobalEnv
[10:19:25.076] Capture standard output: TRUE
[10:19:25.076] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.076] Globals: 5 objects totaling 699 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.076] Packages: <none>
[10:19:25.076] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.076] Resolved: FALSE
[10:19:25.076] Value: <not collected>
[10:19:25.076] Conditions captured: <none>
[10:19:25.076] Early signaling: FALSE
[10:19:25.076] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.076] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.088] Chunk #2 of 2 ... DONE
[10:19:25.088] Launching 2 futures (chunks) ... DONE
[10:19:25.088] Resolving 2 futures (chunks) ...
[10:19:25.088] resolve() on list ...
[10:19:25.088]  recursive: 0
[10:19:25.088]  length: 2
[10:19:25.088] 
[10:19:25.089] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.089] - Validating connection of MultisessionFuture
[10:19:25.089] - received message: FutureResult
[10:19:25.089] - Received FutureResult
[10:19:25.090] - Erased future from FutureRegistry
[10:19:25.090] result() for ClusterFuture ...
[10:19:25.090] - result already collected: FutureResult
[10:19:25.090] result() for ClusterFuture ... done
[10:19:25.090] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.090] Future #1
[10:19:25.090] result() for ClusterFuture ...
[10:19:25.090] - result already collected: FutureResult
[10:19:25.090] result() for ClusterFuture ... done
[10:19:25.090] result() for ClusterFuture ...
[10:19:25.090] - result already collected: FutureResult
[10:19:25.090] result() for ClusterFuture ... done
[10:19:25.091] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:25.091] - nx: 2
[10:19:25.091] - relay: TRUE
[10:19:25.091] - stdout: TRUE
[10:19:25.091] - signal: TRUE
[10:19:25.091] - resignal: FALSE
[10:19:25.091] - force: TRUE
[10:19:25.091] - relayed: [n=2] FALSE, FALSE
[10:19:25.091] - queued futures: [n=2] FALSE, FALSE
[10:19:25.091]  - until=1
[10:19:25.091]  - relaying element #1
[10:19:25.091] result() for ClusterFuture ...
[10:19:25.092] - result already collected: FutureResult
[10:19:25.092] result() for ClusterFuture ... done
[10:19:25.092] result() for ClusterFuture ...
[10:19:25.092] - result already collected: FutureResult
[10:19:25.092] result() for ClusterFuture ... done
[10:19:25.092] result() for ClusterFuture ...
[10:19:25.092] - result already collected: FutureResult
[10:19:25.092] result() for ClusterFuture ... done
[10:19:25.092] result() for ClusterFuture ...
[10:19:25.092] - result already collected: FutureResult
[10:19:25.092] result() for ClusterFuture ... done
[10:19:25.092] - relayed: [n=2] TRUE, FALSE
[10:19:25.093] - queued futures: [n=2] TRUE, FALSE
[10:19:25.093] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:25.093]  length: 1 (resolved future 1)
[10:19:25.118] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.118] - Validating connection of MultisessionFuture
[10:19:25.118] - received message: FutureResult
[10:19:25.119] - Received FutureResult
[10:19:25.119] - Erased future from FutureRegistry
[10:19:25.119] result() for ClusterFuture ...
[10:19:25.119] - result already collected: FutureResult
[10:19:25.119] result() for ClusterFuture ... done
[10:19:25.119] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.119] Future #2
[10:19:25.119] result() for ClusterFuture ...
[10:19:25.119] - result already collected: FutureResult
[10:19:25.119] result() for ClusterFuture ... done
[10:19:25.119] result() for ClusterFuture ...
[10:19:25.120] - result already collected: FutureResult
[10:19:25.120] result() for ClusterFuture ... done
[10:19:25.120] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:25.120] - nx: 2
[10:19:25.120] - relay: TRUE
[10:19:25.120] - stdout: TRUE
[10:19:25.120] - signal: TRUE
[10:19:25.120] - resignal: FALSE
[10:19:25.120] - force: TRUE
[10:19:25.120] - relayed: [n=2] TRUE, FALSE
[10:19:25.120] - queued futures: [n=2] TRUE, FALSE
[10:19:25.120]  - until=2
[10:19:25.121]  - relaying element #2
[10:19:25.121] result() for ClusterFuture ...
[10:19:25.121] - result already collected: FutureResult
[10:19:25.121] result() for ClusterFuture ... done
[10:19:25.121] result() for ClusterFuture ...
[10:19:25.121] - result already collected: FutureResult
[10:19:25.121] result() for ClusterFuture ... done
[10:19:25.121] result() for ClusterFuture ...
[10:19:25.121] - result already collected: FutureResult
[10:19:25.121] result() for ClusterFuture ... done
[10:19:25.121] result() for ClusterFuture ...
[10:19:25.121] - result already collected: FutureResult
[10:19:25.122] result() for ClusterFuture ... done
[10:19:25.122] - relayed: [n=2] TRUE, TRUE
[10:19:25.122] - queued futures: [n=2] TRUE, TRUE
[10:19:25.122] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:25.122]  length: 0 (resolved future 2)
[10:19:25.122] Relaying remaining futures
[10:19:25.122] signalConditionsASAP(NULL, pos=0) ...
[10:19:25.122] - nx: 2
[10:19:25.122] - relay: TRUE
[10:19:25.122] - stdout: TRUE
[10:19:25.122] - signal: TRUE
[10:19:25.122] - resignal: FALSE
[10:19:25.122] - force: TRUE
[10:19:25.123] - relayed: [n=2] TRUE, TRUE
[10:19:25.123] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:25.123] - relayed: [n=2] TRUE, TRUE
[10:19:25.123] - queued futures: [n=2] TRUE, TRUE
[10:19:25.123] signalConditionsASAP(NULL, pos=0) ... done
[10:19:25.123] resolve() on list ... DONE
[10:19:25.123] result() for ClusterFuture ...
[10:19:25.123] - result already collected: FutureResult
[10:19:25.123] result() for ClusterFuture ... done
[10:19:25.123] result() for ClusterFuture ...
[10:19:25.123] - result already collected: FutureResult
[10:19:25.124] result() for ClusterFuture ... done
[10:19:25.124] result() for ClusterFuture ...
[10:19:25.124] - result already collected: FutureResult
[10:19:25.124] result() for ClusterFuture ... done
[10:19:25.124] result() for ClusterFuture ...
[10:19:25.124] - result already collected: FutureResult
[10:19:25.124] result() for ClusterFuture ... done
[10:19:25.124]  - Number of value chunks collected: 2
[10:19:25.124] Resolving 2 futures (chunks) ... DONE
[10:19:25.124] Reducing values from 2 chunks ...
[10:19:25.124]  - Number of values collected after concatenation: 3
[10:19:25.124]  - Number of values expected: 3
[10:19:25.125] Reducing values from 2 chunks ... DONE
[10:19:25.125] future_mapply() ... DONE
[10:19:25.125] future_mapply() ...
[10:19:25.129] Number of chunks: 5
[10:19:25.129] getGlobalsAndPackagesXApply() ...
[10:19:25.129]  - future.globals: TRUE
[10:19:25.129] getGlobalsAndPackages() ...
[10:19:25.129] Searching for globals...
[10:19:25.130] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:25.130] Searching for globals ... DONE
[10:19:25.131] Resolving globals: FALSE
[10:19:25.131] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:25.131] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:25.131] - globals: [1] ‘FUN’
[10:19:25.131] 
[10:19:25.132] getGlobalsAndPackages() ... DONE
[10:19:25.132]  - globals found/used: [n=1] ‘FUN’
[10:19:25.132]  - needed namespaces: [n=0] 
[10:19:25.132] Finding globals ... DONE
[10:19:25.132] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:25.132] List of 2
[10:19:25.132]  $ ...future.FUN:function (C, k)  
[10:19:25.132]  $ MoreArgs     : NULL
[10:19:25.132]  - attr(*, "where")=List of 2
[10:19:25.132]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:25.132]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:25.132]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:25.132]  - attr(*, "resolved")= logi FALSE
[10:19:25.132]  - attr(*, "total_size")= num NA
[10:19:25.134] Packages to be attached in all futures: [n=0] 
[10:19:25.135] getGlobalsAndPackagesXApply() ... DONE
[10:19:25.135] Number of futures (= number of chunks): 5
[10:19:25.135] Launching 5 futures (chunks) ...
[10:19:25.135] Chunk #1 of 5 ...
[10:19:25.135]  - Finding globals in '...' for chunk #1 ...
[10:19:25.135] getGlobalsAndPackages() ...
[10:19:25.135] Searching for globals...
[10:19:25.136] 
[10:19:25.136] Searching for globals ... DONE
[10:19:25.136] - globals: [0] <none>
[10:19:25.136] getGlobalsAndPackages() ... DONE
[10:19:25.136]    + additional globals found: [n=0] 
[10:19:25.136]    + additional namespaces needed: [n=0] 
[10:19:25.136]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:25.136]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:25.136]  - seeds: <none>
[10:19:25.136]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.136] getGlobalsAndPackages() ...
[10:19:25.136] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.137] Resolving globals: FALSE
[10:19:25.137] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:25.137] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:25.137] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.138] 
[10:19:25.138] getGlobalsAndPackages() ... DONE
[10:19:25.138] run() for ‘Future’ ...
[10:19:25.138] - state: ‘created’
[10:19:25.138] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.152] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.153]   - Field: ‘node’
[10:19:25.153]   - Field: ‘label’
[10:19:25.153]   - Field: ‘local’
[10:19:25.153]   - Field: ‘owner’
[10:19:25.153]   - Field: ‘envir’
[10:19:25.153]   - Field: ‘workers’
[10:19:25.153]   - Field: ‘packages’
[10:19:25.153]   - Field: ‘gc’
[10:19:25.153]   - Field: ‘conditions’
[10:19:25.153]   - Field: ‘persistent’
[10:19:25.153]   - Field: ‘expr’
[10:19:25.154]   - Field: ‘uuid’
[10:19:25.154]   - Field: ‘seed’
[10:19:25.154]   - Field: ‘version’
[10:19:25.154]   - Field: ‘result’
[10:19:25.154]   - Field: ‘asynchronous’
[10:19:25.154]   - Field: ‘calls’
[10:19:25.154]   - Field: ‘globals’
[10:19:25.154]   - Field: ‘stdout’
[10:19:25.154]   - Field: ‘earlySignal’
[10:19:25.154]   - Field: ‘lazy’
[10:19:25.154]   - Field: ‘state’
[10:19:25.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.155] - Launch lazy future ...
[10:19:25.155] Packages needed by the future expression (n = 0): <none>
[10:19:25.155] Packages needed by future strategies (n = 0): <none>
[10:19:25.155] {
[10:19:25.155]     {
[10:19:25.155]         {
[10:19:25.155]             ...future.startTime <- base::Sys.time()
[10:19:25.155]             {
[10:19:25.155]                 {
[10:19:25.155]                   {
[10:19:25.155]                     {
[10:19:25.155]                       base::local({
[10:19:25.155]                         has_future <- base::requireNamespace("future", 
[10:19:25.155]                           quietly = TRUE)
[10:19:25.155]                         if (has_future) {
[10:19:25.155]                           ns <- base::getNamespace("future")
[10:19:25.155]                           version <- ns[[".package"]][["version"]]
[10:19:25.155]                           if (is.null(version)) 
[10:19:25.155]                             version <- utils::packageVersion("future")
[10:19:25.155]                         }
[10:19:25.155]                         else {
[10:19:25.155]                           version <- NULL
[10:19:25.155]                         }
[10:19:25.155]                         if (!has_future || version < "1.8.0") {
[10:19:25.155]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.155]                             "", base::R.version$version.string), 
[10:19:25.155]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.155]                               "release", "version")], collapse = " "), 
[10:19:25.155]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.155]                             info)
[10:19:25.155]                           info <- base::paste(info, collapse = "; ")
[10:19:25.155]                           if (!has_future) {
[10:19:25.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.155]                               info)
[10:19:25.155]                           }
[10:19:25.155]                           else {
[10:19:25.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.155]                               info, version)
[10:19:25.155]                           }
[10:19:25.155]                           base::stop(msg)
[10:19:25.155]                         }
[10:19:25.155]                       })
[10:19:25.155]                     }
[10:19:25.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.155]                     base::options(mc.cores = 1L)
[10:19:25.155]                   }
[10:19:25.155]                   ...future.strategy.old <- future::plan("list")
[10:19:25.155]                   options(future.plan = NULL)
[10:19:25.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.155]                 }
[10:19:25.155]                 ...future.workdir <- getwd()
[10:19:25.155]             }
[10:19:25.155]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.155]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.155]         }
[10:19:25.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.155]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:25.155]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.155]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.155]             base::names(...future.oldOptions))
[10:19:25.155]     }
[10:19:25.155]     if (FALSE) {
[10:19:25.155]     }
[10:19:25.155]     else {
[10:19:25.155]         if (TRUE) {
[10:19:25.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.155]                 open = "w")
[10:19:25.155]         }
[10:19:25.155]         else {
[10:19:25.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.155]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.155]         }
[10:19:25.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.155]             base::sink(type = "output", split = FALSE)
[10:19:25.155]             base::close(...future.stdout)
[10:19:25.155]         }, add = TRUE)
[10:19:25.155]     }
[10:19:25.155]     ...future.frame <- base::sys.nframe()
[10:19:25.155]     ...future.conditions <- base::list()
[10:19:25.155]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.155]     if (FALSE) {
[10:19:25.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.155]     }
[10:19:25.155]     ...future.result <- base::tryCatch({
[10:19:25.155]         base::withCallingHandlers({
[10:19:25.155]             ...future.value <- base::withVisible(base::local({
[10:19:25.155]                 ...future.makeSendCondition <- base::local({
[10:19:25.155]                   sendCondition <- NULL
[10:19:25.155]                   function(frame = 1L) {
[10:19:25.155]                     if (is.function(sendCondition)) 
[10:19:25.155]                       return(sendCondition)
[10:19:25.155]                     ns <- getNamespace("parallel")
[10:19:25.155]                     if (exists("sendData", mode = "function", 
[10:19:25.155]                       envir = ns)) {
[10:19:25.155]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.155]                         envir = ns)
[10:19:25.155]                       envir <- sys.frame(frame)
[10:19:25.155]                       master <- NULL
[10:19:25.155]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.155]                         !identical(envir, emptyenv())) {
[10:19:25.155]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.155]                           inherits = FALSE)) {
[10:19:25.155]                           master <- get("master", mode = "list", 
[10:19:25.155]                             envir = envir, inherits = FALSE)
[10:19:25.155]                           if (inherits(master, c("SOCKnode", 
[10:19:25.155]                             "SOCK0node"))) {
[10:19:25.155]                             sendCondition <<- function(cond) {
[10:19:25.155]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.155]                                 success = TRUE)
[10:19:25.155]                               parallel_sendData(master, data)
[10:19:25.155]                             }
[10:19:25.155]                             return(sendCondition)
[10:19:25.155]                           }
[10:19:25.155]                         }
[10:19:25.155]                         frame <- frame + 1L
[10:19:25.155]                         envir <- sys.frame(frame)
[10:19:25.155]                       }
[10:19:25.155]                     }
[10:19:25.155]                     sendCondition <<- function(cond) NULL
[10:19:25.155]                   }
[10:19:25.155]                 })
[10:19:25.155]                 withCallingHandlers({
[10:19:25.155]                   {
[10:19:25.155]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.155]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.155]                       ...future.globals.maxSize)) {
[10:19:25.155]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.155]                       on.exit(options(oopts), add = TRUE)
[10:19:25.155]                     }
[10:19:25.155]                     {
[10:19:25.155]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.155]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.155]                         USE.NAMES = FALSE)
[10:19:25.155]                       do.call(mapply, args = args)
[10:19:25.155]                     }
[10:19:25.155]                   }
[10:19:25.155]                 }, immediateCondition = function(cond) {
[10:19:25.155]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.155]                   sendCondition(cond)
[10:19:25.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.155]                   {
[10:19:25.155]                     inherits <- base::inherits
[10:19:25.155]                     invokeRestart <- base::invokeRestart
[10:19:25.155]                     is.null <- base::is.null
[10:19:25.155]                     muffled <- FALSE
[10:19:25.155]                     if (inherits(cond, "message")) {
[10:19:25.155]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.155]                       if (muffled) 
[10:19:25.155]                         invokeRestart("muffleMessage")
[10:19:25.155]                     }
[10:19:25.155]                     else if (inherits(cond, "warning")) {
[10:19:25.155]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.155]                       if (muffled) 
[10:19:25.155]                         invokeRestart("muffleWarning")
[10:19:25.155]                     }
[10:19:25.155]                     else if (inherits(cond, "condition")) {
[10:19:25.155]                       if (!is.null(pattern)) {
[10:19:25.155]                         computeRestarts <- base::computeRestarts
[10:19:25.155]                         grepl <- base::grepl
[10:19:25.155]                         restarts <- computeRestarts(cond)
[10:19:25.155]                         for (restart in restarts) {
[10:19:25.155]                           name <- restart$name
[10:19:25.155]                           if (is.null(name)) 
[10:19:25.155]                             next
[10:19:25.155]                           if (!grepl(pattern, name)) 
[10:19:25.155]                             next
[10:19:25.155]                           invokeRestart(restart)
[10:19:25.155]                           muffled <- TRUE
[10:19:25.155]                           break
[10:19:25.155]                         }
[10:19:25.155]                       }
[10:19:25.155]                     }
[10:19:25.155]                     invisible(muffled)
[10:19:25.155]                   }
[10:19:25.155]                   muffleCondition(cond)
[10:19:25.155]                 })
[10:19:25.155]             }))
[10:19:25.155]             future::FutureResult(value = ...future.value$value, 
[10:19:25.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.155]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.155]                     ...future.globalenv.names))
[10:19:25.155]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.155]         }, condition = base::local({
[10:19:25.155]             c <- base::c
[10:19:25.155]             inherits <- base::inherits
[10:19:25.155]             invokeRestart <- base::invokeRestart
[10:19:25.155]             length <- base::length
[10:19:25.155]             list <- base::list
[10:19:25.155]             seq.int <- base::seq.int
[10:19:25.155]             signalCondition <- base::signalCondition
[10:19:25.155]             sys.calls <- base::sys.calls
[10:19:25.155]             `[[` <- base::`[[`
[10:19:25.155]             `+` <- base::`+`
[10:19:25.155]             `<<-` <- base::`<<-`
[10:19:25.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.155]                   3L)]
[10:19:25.155]             }
[10:19:25.155]             function(cond) {
[10:19:25.155]                 is_error <- inherits(cond, "error")
[10:19:25.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.155]                   NULL)
[10:19:25.155]                 if (is_error) {
[10:19:25.155]                   sessionInformation <- function() {
[10:19:25.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.155]                       search = base::search(), system = base::Sys.info())
[10:19:25.155]                   }
[10:19:25.155]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.155]                     cond$call), session = sessionInformation(), 
[10:19:25.155]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.155]                   signalCondition(cond)
[10:19:25.155]                 }
[10:19:25.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.155]                 "immediateCondition"))) {
[10:19:25.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.155]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.155]                   if (TRUE && !signal) {
[10:19:25.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.155]                     {
[10:19:25.155]                       inherits <- base::inherits
[10:19:25.155]                       invokeRestart <- base::invokeRestart
[10:19:25.155]                       is.null <- base::is.null
[10:19:25.155]                       muffled <- FALSE
[10:19:25.155]                       if (inherits(cond, "message")) {
[10:19:25.155]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.155]                         if (muffled) 
[10:19:25.155]                           invokeRestart("muffleMessage")
[10:19:25.155]                       }
[10:19:25.155]                       else if (inherits(cond, "warning")) {
[10:19:25.155]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.155]                         if (muffled) 
[10:19:25.155]                           invokeRestart("muffleWarning")
[10:19:25.155]                       }
[10:19:25.155]                       else if (inherits(cond, "condition")) {
[10:19:25.155]                         if (!is.null(pattern)) {
[10:19:25.155]                           computeRestarts <- base::computeRestarts
[10:19:25.155]                           grepl <- base::grepl
[10:19:25.155]                           restarts <- computeRestarts(cond)
[10:19:25.155]                           for (restart in restarts) {
[10:19:25.155]                             name <- restart$name
[10:19:25.155]                             if (is.null(name)) 
[10:19:25.155]                               next
[10:19:25.155]                             if (!grepl(pattern, name)) 
[10:19:25.155]                               next
[10:19:25.155]                             invokeRestart(restart)
[10:19:25.155]                             muffled <- TRUE
[10:19:25.155]                             break
[10:19:25.155]                           }
[10:19:25.155]                         }
[10:19:25.155]                       }
[10:19:25.155]                       invisible(muffled)
[10:19:25.155]                     }
[10:19:25.155]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.155]                   }
[10:19:25.155]                 }
[10:19:25.155]                 else {
[10:19:25.155]                   if (TRUE) {
[10:19:25.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.155]                     {
[10:19:25.155]                       inherits <- base::inherits
[10:19:25.155]                       invokeRestart <- base::invokeRestart
[10:19:25.155]                       is.null <- base::is.null
[10:19:25.155]                       muffled <- FALSE
[10:19:25.155]                       if (inherits(cond, "message")) {
[10:19:25.155]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.155]                         if (muffled) 
[10:19:25.155]                           invokeRestart("muffleMessage")
[10:19:25.155]                       }
[10:19:25.155]                       else if (inherits(cond, "warning")) {
[10:19:25.155]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.155]                         if (muffled) 
[10:19:25.155]                           invokeRestart("muffleWarning")
[10:19:25.155]                       }
[10:19:25.155]                       else if (inherits(cond, "condition")) {
[10:19:25.155]                         if (!is.null(pattern)) {
[10:19:25.155]                           computeRestarts <- base::computeRestarts
[10:19:25.155]                           grepl <- base::grepl
[10:19:25.155]                           restarts <- computeRestarts(cond)
[10:19:25.155]                           for (restart in restarts) {
[10:19:25.155]                             name <- restart$name
[10:19:25.155]                             if (is.null(name)) 
[10:19:25.155]                               next
[10:19:25.155]                             if (!grepl(pattern, name)) 
[10:19:25.155]                               next
[10:19:25.155]                             invokeRestart(restart)
[10:19:25.155]                             muffled <- TRUE
[10:19:25.155]                             break
[10:19:25.155]                           }
[10:19:25.155]                         }
[10:19:25.155]                       }
[10:19:25.155]                       invisible(muffled)
[10:19:25.155]                     }
[10:19:25.155]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.155]                   }
[10:19:25.155]                 }
[10:19:25.155]             }
[10:19:25.155]         }))
[10:19:25.155]     }, error = function(ex) {
[10:19:25.155]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.155]                 ...future.rng), started = ...future.startTime, 
[10:19:25.155]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.155]             version = "1.8"), class = "FutureResult")
[10:19:25.155]     }, finally = {
[10:19:25.155]         if (!identical(...future.workdir, getwd())) 
[10:19:25.155]             setwd(...future.workdir)
[10:19:25.155]         {
[10:19:25.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.155]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.155]             }
[10:19:25.155]             base::options(...future.oldOptions)
[10:19:25.155]             if (.Platform$OS.type == "windows") {
[10:19:25.155]                 old_names <- names(...future.oldEnvVars)
[10:19:25.155]                 envs <- base::Sys.getenv()
[10:19:25.155]                 names <- names(envs)
[10:19:25.155]                 common <- intersect(names, old_names)
[10:19:25.155]                 added <- setdiff(names, old_names)
[10:19:25.155]                 removed <- setdiff(old_names, names)
[10:19:25.155]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.155]                   envs[common]]
[10:19:25.155]                 NAMES <- toupper(changed)
[10:19:25.155]                 args <- list()
[10:19:25.155]                 for (kk in seq_along(NAMES)) {
[10:19:25.155]                   name <- changed[[kk]]
[10:19:25.155]                   NAME <- NAMES[[kk]]
[10:19:25.155]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.155]                     next
[10:19:25.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.155]                 }
[10:19:25.155]                 NAMES <- toupper(added)
[10:19:25.155]                 for (kk in seq_along(NAMES)) {
[10:19:25.155]                   name <- added[[kk]]
[10:19:25.155]                   NAME <- NAMES[[kk]]
[10:19:25.155]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.155]                     next
[10:19:25.155]                   args[[name]] <- ""
[10:19:25.155]                 }
[10:19:25.155]                 NAMES <- toupper(removed)
[10:19:25.155]                 for (kk in seq_along(NAMES)) {
[10:19:25.155]                   name <- removed[[kk]]
[10:19:25.155]                   NAME <- NAMES[[kk]]
[10:19:25.155]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.155]                     next
[10:19:25.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.155]                 }
[10:19:25.155]                 if (length(args) > 0) 
[10:19:25.155]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.155]             }
[10:19:25.155]             else {
[10:19:25.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.155]             }
[10:19:25.155]             {
[10:19:25.155]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.155]                   0L) {
[10:19:25.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.155]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.155]                   base::options(opts)
[10:19:25.155]                 }
[10:19:25.155]                 {
[10:19:25.155]                   {
[10:19:25.155]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.155]                     NULL
[10:19:25.155]                   }
[10:19:25.155]                   options(future.plan = NULL)
[10:19:25.155]                   if (is.na(NA_character_)) 
[10:19:25.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.155]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.155]                     .init = FALSE)
[10:19:25.155]                 }
[10:19:25.155]             }
[10:19:25.155]         }
[10:19:25.155]     })
[10:19:25.155]     if (TRUE) {
[10:19:25.155]         base::sink(type = "output", split = FALSE)
[10:19:25.155]         if (TRUE) {
[10:19:25.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.155]         }
[10:19:25.155]         else {
[10:19:25.155]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.155]         }
[10:19:25.155]         base::close(...future.stdout)
[10:19:25.155]         ...future.stdout <- NULL
[10:19:25.155]     }
[10:19:25.155]     ...future.result$conditions <- ...future.conditions
[10:19:25.155]     ...future.result$finished <- base::Sys.time()
[10:19:25.155]     ...future.result
[10:19:25.155] }
[10:19:25.158] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[10:19:25.158] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:19:25.159] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:19:25.159] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:25.159] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.159] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ...
[10:19:25.160] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ... DONE
[10:19:25.160] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:25.160] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.160] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:25.161] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.161] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[10:19:25.161] MultisessionFuture started
[10:19:25.161] - Launch lazy future ... done
[10:19:25.161] run() for ‘MultisessionFuture’ ... done
[10:19:25.162] Created future:
[10:19:25.162] MultisessionFuture:
[10:19:25.162] Label: ‘future_mapply-1’
[10:19:25.162] Expression:
[10:19:25.162] {
[10:19:25.162]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.162]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.162]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.162]         on.exit(options(oopts), add = TRUE)
[10:19:25.162]     }
[10:19:25.162]     {
[10:19:25.162]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.162]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.162]         do.call(mapply, args = args)
[10:19:25.162]     }
[10:19:25.162] }
[10:19:25.162] Lazy evaluation: FALSE
[10:19:25.162] Asynchronous evaluation: TRUE
[10:19:25.162] Local evaluation: TRUE
[10:19:25.162] Environment: R_GlobalEnv
[10:19:25.162] Capture standard output: TRUE
[10:19:25.162] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.162] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.162] Packages: <none>
[10:19:25.162] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.162] Resolved: FALSE
[10:19:25.162] Value: <not collected>
[10:19:25.162] Conditions captured: <none>
[10:19:25.162] Early signaling: FALSE
[10:19:25.162] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.162] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.173] Chunk #1 of 5 ... DONE
[10:19:25.173] Chunk #2 of 5 ...
[10:19:25.173]  - Finding globals in '...' for chunk #2 ...
[10:19:25.173] getGlobalsAndPackages() ...
[10:19:25.173] Searching for globals...
[10:19:25.174] 
[10:19:25.174] Searching for globals ... DONE
[10:19:25.174] - globals: [0] <none>
[10:19:25.174] getGlobalsAndPackages() ... DONE
[10:19:25.174]    + additional globals found: [n=0] 
[10:19:25.174]    + additional namespaces needed: [n=0] 
[10:19:25.174]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:25.174]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:25.174]  - seeds: <none>
[10:19:25.175]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.175] getGlobalsAndPackages() ...
[10:19:25.175] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.175] Resolving globals: FALSE
[10:19:25.175] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:25.176] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:25.176] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.176] 
[10:19:25.176] getGlobalsAndPackages() ... DONE
[10:19:25.176] run() for ‘Future’ ...
[10:19:25.176] - state: ‘created’
[10:19:25.177] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.192] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.192] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.193]   - Field: ‘node’
[10:19:25.193]   - Field: ‘label’
[10:19:25.193]   - Field: ‘local’
[10:19:25.193]   - Field: ‘owner’
[10:19:25.193]   - Field: ‘envir’
[10:19:25.193]   - Field: ‘workers’
[10:19:25.193]   - Field: ‘packages’
[10:19:25.193]   - Field: ‘gc’
[10:19:25.193]   - Field: ‘conditions’
[10:19:25.193]   - Field: ‘persistent’
[10:19:25.193]   - Field: ‘expr’
[10:19:25.193]   - Field: ‘uuid’
[10:19:25.194]   - Field: ‘seed’
[10:19:25.194]   - Field: ‘version’
[10:19:25.194]   - Field: ‘result’
[10:19:25.194]   - Field: ‘asynchronous’
[10:19:25.194]   - Field: ‘calls’
[10:19:25.194]   - Field: ‘globals’
[10:19:25.194]   - Field: ‘stdout’
[10:19:25.194]   - Field: ‘earlySignal’
[10:19:25.194]   - Field: ‘lazy’
[10:19:25.194]   - Field: ‘state’
[10:19:25.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.194] - Launch lazy future ...
[10:19:25.195] Packages needed by the future expression (n = 0): <none>
[10:19:25.195] Packages needed by future strategies (n = 0): <none>
[10:19:25.195] {
[10:19:25.195]     {
[10:19:25.195]         {
[10:19:25.195]             ...future.startTime <- base::Sys.time()
[10:19:25.195]             {
[10:19:25.195]                 {
[10:19:25.195]                   {
[10:19:25.195]                     {
[10:19:25.195]                       base::local({
[10:19:25.195]                         has_future <- base::requireNamespace("future", 
[10:19:25.195]                           quietly = TRUE)
[10:19:25.195]                         if (has_future) {
[10:19:25.195]                           ns <- base::getNamespace("future")
[10:19:25.195]                           version <- ns[[".package"]][["version"]]
[10:19:25.195]                           if (is.null(version)) 
[10:19:25.195]                             version <- utils::packageVersion("future")
[10:19:25.195]                         }
[10:19:25.195]                         else {
[10:19:25.195]                           version <- NULL
[10:19:25.195]                         }
[10:19:25.195]                         if (!has_future || version < "1.8.0") {
[10:19:25.195]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.195]                             "", base::R.version$version.string), 
[10:19:25.195]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.195]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.195]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.195]                               "release", "version")], collapse = " "), 
[10:19:25.195]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.195]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.195]                             info)
[10:19:25.195]                           info <- base::paste(info, collapse = "; ")
[10:19:25.195]                           if (!has_future) {
[10:19:25.195]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.195]                               info)
[10:19:25.195]                           }
[10:19:25.195]                           else {
[10:19:25.195]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.195]                               info, version)
[10:19:25.195]                           }
[10:19:25.195]                           base::stop(msg)
[10:19:25.195]                         }
[10:19:25.195]                       })
[10:19:25.195]                     }
[10:19:25.195]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.195]                     base::options(mc.cores = 1L)
[10:19:25.195]                   }
[10:19:25.195]                   ...future.strategy.old <- future::plan("list")
[10:19:25.195]                   options(future.plan = NULL)
[10:19:25.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.195]                 }
[10:19:25.195]                 ...future.workdir <- getwd()
[10:19:25.195]             }
[10:19:25.195]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.195]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.195]         }
[10:19:25.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.195]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:25.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.195]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.195]             base::names(...future.oldOptions))
[10:19:25.195]     }
[10:19:25.195]     if (FALSE) {
[10:19:25.195]     }
[10:19:25.195]     else {
[10:19:25.195]         if (TRUE) {
[10:19:25.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.195]                 open = "w")
[10:19:25.195]         }
[10:19:25.195]         else {
[10:19:25.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.195]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.195]         }
[10:19:25.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.195]             base::sink(type = "output", split = FALSE)
[10:19:25.195]             base::close(...future.stdout)
[10:19:25.195]         }, add = TRUE)
[10:19:25.195]     }
[10:19:25.195]     ...future.frame <- base::sys.nframe()
[10:19:25.195]     ...future.conditions <- base::list()
[10:19:25.195]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.195]     if (FALSE) {
[10:19:25.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.195]     }
[10:19:25.195]     ...future.result <- base::tryCatch({
[10:19:25.195]         base::withCallingHandlers({
[10:19:25.195]             ...future.value <- base::withVisible(base::local({
[10:19:25.195]                 ...future.makeSendCondition <- base::local({
[10:19:25.195]                   sendCondition <- NULL
[10:19:25.195]                   function(frame = 1L) {
[10:19:25.195]                     if (is.function(sendCondition)) 
[10:19:25.195]                       return(sendCondition)
[10:19:25.195]                     ns <- getNamespace("parallel")
[10:19:25.195]                     if (exists("sendData", mode = "function", 
[10:19:25.195]                       envir = ns)) {
[10:19:25.195]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.195]                         envir = ns)
[10:19:25.195]                       envir <- sys.frame(frame)
[10:19:25.195]                       master <- NULL
[10:19:25.195]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.195]                         !identical(envir, emptyenv())) {
[10:19:25.195]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.195]                           inherits = FALSE)) {
[10:19:25.195]                           master <- get("master", mode = "list", 
[10:19:25.195]                             envir = envir, inherits = FALSE)
[10:19:25.195]                           if (inherits(master, c("SOCKnode", 
[10:19:25.195]                             "SOCK0node"))) {
[10:19:25.195]                             sendCondition <<- function(cond) {
[10:19:25.195]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.195]                                 success = TRUE)
[10:19:25.195]                               parallel_sendData(master, data)
[10:19:25.195]                             }
[10:19:25.195]                             return(sendCondition)
[10:19:25.195]                           }
[10:19:25.195]                         }
[10:19:25.195]                         frame <- frame + 1L
[10:19:25.195]                         envir <- sys.frame(frame)
[10:19:25.195]                       }
[10:19:25.195]                     }
[10:19:25.195]                     sendCondition <<- function(cond) NULL
[10:19:25.195]                   }
[10:19:25.195]                 })
[10:19:25.195]                 withCallingHandlers({
[10:19:25.195]                   {
[10:19:25.195]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.195]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.195]                       ...future.globals.maxSize)) {
[10:19:25.195]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.195]                       on.exit(options(oopts), add = TRUE)
[10:19:25.195]                     }
[10:19:25.195]                     {
[10:19:25.195]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.195]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.195]                         USE.NAMES = FALSE)
[10:19:25.195]                       do.call(mapply, args = args)
[10:19:25.195]                     }
[10:19:25.195]                   }
[10:19:25.195]                 }, immediateCondition = function(cond) {
[10:19:25.195]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.195]                   sendCondition(cond)
[10:19:25.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.195]                   {
[10:19:25.195]                     inherits <- base::inherits
[10:19:25.195]                     invokeRestart <- base::invokeRestart
[10:19:25.195]                     is.null <- base::is.null
[10:19:25.195]                     muffled <- FALSE
[10:19:25.195]                     if (inherits(cond, "message")) {
[10:19:25.195]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.195]                       if (muffled) 
[10:19:25.195]                         invokeRestart("muffleMessage")
[10:19:25.195]                     }
[10:19:25.195]                     else if (inherits(cond, "warning")) {
[10:19:25.195]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.195]                       if (muffled) 
[10:19:25.195]                         invokeRestart("muffleWarning")
[10:19:25.195]                     }
[10:19:25.195]                     else if (inherits(cond, "condition")) {
[10:19:25.195]                       if (!is.null(pattern)) {
[10:19:25.195]                         computeRestarts <- base::computeRestarts
[10:19:25.195]                         grepl <- base::grepl
[10:19:25.195]                         restarts <- computeRestarts(cond)
[10:19:25.195]                         for (restart in restarts) {
[10:19:25.195]                           name <- restart$name
[10:19:25.195]                           if (is.null(name)) 
[10:19:25.195]                             next
[10:19:25.195]                           if (!grepl(pattern, name)) 
[10:19:25.195]                             next
[10:19:25.195]                           invokeRestart(restart)
[10:19:25.195]                           muffled <- TRUE
[10:19:25.195]                           break
[10:19:25.195]                         }
[10:19:25.195]                       }
[10:19:25.195]                     }
[10:19:25.195]                     invisible(muffled)
[10:19:25.195]                   }
[10:19:25.195]                   muffleCondition(cond)
[10:19:25.195]                 })
[10:19:25.195]             }))
[10:19:25.195]             future::FutureResult(value = ...future.value$value, 
[10:19:25.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.195]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.195]                     ...future.globalenv.names))
[10:19:25.195]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.195]         }, condition = base::local({
[10:19:25.195]             c <- base::c
[10:19:25.195]             inherits <- base::inherits
[10:19:25.195]             invokeRestart <- base::invokeRestart
[10:19:25.195]             length <- base::length
[10:19:25.195]             list <- base::list
[10:19:25.195]             seq.int <- base::seq.int
[10:19:25.195]             signalCondition <- base::signalCondition
[10:19:25.195]             sys.calls <- base::sys.calls
[10:19:25.195]             `[[` <- base::`[[`
[10:19:25.195]             `+` <- base::`+`
[10:19:25.195]             `<<-` <- base::`<<-`
[10:19:25.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.195]                   3L)]
[10:19:25.195]             }
[10:19:25.195]             function(cond) {
[10:19:25.195]                 is_error <- inherits(cond, "error")
[10:19:25.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.195]                   NULL)
[10:19:25.195]                 if (is_error) {
[10:19:25.195]                   sessionInformation <- function() {
[10:19:25.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.195]                       search = base::search(), system = base::Sys.info())
[10:19:25.195]                   }
[10:19:25.195]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.195]                     cond$call), session = sessionInformation(), 
[10:19:25.195]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.195]                   signalCondition(cond)
[10:19:25.195]                 }
[10:19:25.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.195]                 "immediateCondition"))) {
[10:19:25.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.195]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.195]                   if (TRUE && !signal) {
[10:19:25.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.195]                     {
[10:19:25.195]                       inherits <- base::inherits
[10:19:25.195]                       invokeRestart <- base::invokeRestart
[10:19:25.195]                       is.null <- base::is.null
[10:19:25.195]                       muffled <- FALSE
[10:19:25.195]                       if (inherits(cond, "message")) {
[10:19:25.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.195]                         if (muffled) 
[10:19:25.195]                           invokeRestart("muffleMessage")
[10:19:25.195]                       }
[10:19:25.195]                       else if (inherits(cond, "warning")) {
[10:19:25.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.195]                         if (muffled) 
[10:19:25.195]                           invokeRestart("muffleWarning")
[10:19:25.195]                       }
[10:19:25.195]                       else if (inherits(cond, "condition")) {
[10:19:25.195]                         if (!is.null(pattern)) {
[10:19:25.195]                           computeRestarts <- base::computeRestarts
[10:19:25.195]                           grepl <- base::grepl
[10:19:25.195]                           restarts <- computeRestarts(cond)
[10:19:25.195]                           for (restart in restarts) {
[10:19:25.195]                             name <- restart$name
[10:19:25.195]                             if (is.null(name)) 
[10:19:25.195]                               next
[10:19:25.195]                             if (!grepl(pattern, name)) 
[10:19:25.195]                               next
[10:19:25.195]                             invokeRestart(restart)
[10:19:25.195]                             muffled <- TRUE
[10:19:25.195]                             break
[10:19:25.195]                           }
[10:19:25.195]                         }
[10:19:25.195]                       }
[10:19:25.195]                       invisible(muffled)
[10:19:25.195]                     }
[10:19:25.195]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.195]                   }
[10:19:25.195]                 }
[10:19:25.195]                 else {
[10:19:25.195]                   if (TRUE) {
[10:19:25.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.195]                     {
[10:19:25.195]                       inherits <- base::inherits
[10:19:25.195]                       invokeRestart <- base::invokeRestart
[10:19:25.195]                       is.null <- base::is.null
[10:19:25.195]                       muffled <- FALSE
[10:19:25.195]                       if (inherits(cond, "message")) {
[10:19:25.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.195]                         if (muffled) 
[10:19:25.195]                           invokeRestart("muffleMessage")
[10:19:25.195]                       }
[10:19:25.195]                       else if (inherits(cond, "warning")) {
[10:19:25.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.195]                         if (muffled) 
[10:19:25.195]                           invokeRestart("muffleWarning")
[10:19:25.195]                       }
[10:19:25.195]                       else if (inherits(cond, "condition")) {
[10:19:25.195]                         if (!is.null(pattern)) {
[10:19:25.195]                           computeRestarts <- base::computeRestarts
[10:19:25.195]                           grepl <- base::grepl
[10:19:25.195]                           restarts <- computeRestarts(cond)
[10:19:25.195]                           for (restart in restarts) {
[10:19:25.195]                             name <- restart$name
[10:19:25.195]                             if (is.null(name)) 
[10:19:25.195]                               next
[10:19:25.195]                             if (!grepl(pattern, name)) 
[10:19:25.195]                               next
[10:19:25.195]                             invokeRestart(restart)
[10:19:25.195]                             muffled <- TRUE
[10:19:25.195]                             break
[10:19:25.195]                           }
[10:19:25.195]                         }
[10:19:25.195]                       }
[10:19:25.195]                       invisible(muffled)
[10:19:25.195]                     }
[10:19:25.195]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.195]                   }
[10:19:25.195]                 }
[10:19:25.195]             }
[10:19:25.195]         }))
[10:19:25.195]     }, error = function(ex) {
[10:19:25.195]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.195]                 ...future.rng), started = ...future.startTime, 
[10:19:25.195]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.195]             version = "1.8"), class = "FutureResult")
[10:19:25.195]     }, finally = {
[10:19:25.195]         if (!identical(...future.workdir, getwd())) 
[10:19:25.195]             setwd(...future.workdir)
[10:19:25.195]         {
[10:19:25.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.195]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.195]             }
[10:19:25.195]             base::options(...future.oldOptions)
[10:19:25.195]             if (.Platform$OS.type == "windows") {
[10:19:25.195]                 old_names <- names(...future.oldEnvVars)
[10:19:25.195]                 envs <- base::Sys.getenv()
[10:19:25.195]                 names <- names(envs)
[10:19:25.195]                 common <- intersect(names, old_names)
[10:19:25.195]                 added <- setdiff(names, old_names)
[10:19:25.195]                 removed <- setdiff(old_names, names)
[10:19:25.195]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.195]                   envs[common]]
[10:19:25.195]                 NAMES <- toupper(changed)
[10:19:25.195]                 args <- list()
[10:19:25.195]                 for (kk in seq_along(NAMES)) {
[10:19:25.195]                   name <- changed[[kk]]
[10:19:25.195]                   NAME <- NAMES[[kk]]
[10:19:25.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.195]                     next
[10:19:25.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.195]                 }
[10:19:25.195]                 NAMES <- toupper(added)
[10:19:25.195]                 for (kk in seq_along(NAMES)) {
[10:19:25.195]                   name <- added[[kk]]
[10:19:25.195]                   NAME <- NAMES[[kk]]
[10:19:25.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.195]                     next
[10:19:25.195]                   args[[name]] <- ""
[10:19:25.195]                 }
[10:19:25.195]                 NAMES <- toupper(removed)
[10:19:25.195]                 for (kk in seq_along(NAMES)) {
[10:19:25.195]                   name <- removed[[kk]]
[10:19:25.195]                   NAME <- NAMES[[kk]]
[10:19:25.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.195]                     next
[10:19:25.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.195]                 }
[10:19:25.195]                 if (length(args) > 0) 
[10:19:25.195]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.195]             }
[10:19:25.195]             else {
[10:19:25.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.195]             }
[10:19:25.195]             {
[10:19:25.195]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.195]                   0L) {
[10:19:25.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.195]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.195]                   base::options(opts)
[10:19:25.195]                 }
[10:19:25.195]                 {
[10:19:25.195]                   {
[10:19:25.195]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.195]                     NULL
[10:19:25.195]                   }
[10:19:25.195]                   options(future.plan = NULL)
[10:19:25.195]                   if (is.na(NA_character_)) 
[10:19:25.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.195]                     .init = FALSE)
[10:19:25.195]                 }
[10:19:25.195]             }
[10:19:25.195]         }
[10:19:25.195]     })
[10:19:25.195]     if (TRUE) {
[10:19:25.195]         base::sink(type = "output", split = FALSE)
[10:19:25.195]         if (TRUE) {
[10:19:25.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.195]         }
[10:19:25.195]         else {
[10:19:25.195]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.195]         }
[10:19:25.195]         base::close(...future.stdout)
[10:19:25.195]         ...future.stdout <- NULL
[10:19:25.195]     }
[10:19:25.195]     ...future.result$conditions <- ...future.conditions
[10:19:25.195]     ...future.result$finished <- base::Sys.time()
[10:19:25.195]     ...future.result
[10:19:25.195] }
[10:19:25.198] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[10:19:25.198] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:19:25.199] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:19:25.199] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:25.199] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.199] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ...
[10:19:25.200] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ... DONE
[10:19:25.200] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:25.200] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.200] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:25.201] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.201] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[10:19:25.201] MultisessionFuture started
[10:19:25.201] - Launch lazy future ... done
[10:19:25.201] run() for ‘MultisessionFuture’ ... done
[10:19:25.202] Created future:
[10:19:25.202] MultisessionFuture:
[10:19:25.202] Label: ‘future_mapply-2’
[10:19:25.202] Expression:
[10:19:25.202] {
[10:19:25.202]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.202]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.202]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.202]         on.exit(options(oopts), add = TRUE)
[10:19:25.202]     }
[10:19:25.202]     {
[10:19:25.202]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.202]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.202]         do.call(mapply, args = args)
[10:19:25.202]     }
[10:19:25.202] }
[10:19:25.202] Lazy evaluation: FALSE
[10:19:25.202] Asynchronous evaluation: TRUE
[10:19:25.202] Local evaluation: TRUE
[10:19:25.202] Environment: R_GlobalEnv
[10:19:25.202] Capture standard output: TRUE
[10:19:25.202] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.202] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.202] Packages: <none>
[10:19:25.202] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.202] Resolved: FALSE
[10:19:25.202] Value: <not collected>
[10:19:25.202] Conditions captured: <none>
[10:19:25.202] Early signaling: FALSE
[10:19:25.202] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.202] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.213] Chunk #2 of 5 ... DONE
[10:19:25.213] Chunk #3 of 5 ...
[10:19:25.213]  - Finding globals in '...' for chunk #3 ...
[10:19:25.213] getGlobalsAndPackages() ...
[10:19:25.214] Searching for globals...
[10:19:25.214] 
[10:19:25.214] Searching for globals ... DONE
[10:19:25.214] - globals: [0] <none>
[10:19:25.214] getGlobalsAndPackages() ... DONE
[10:19:25.214]    + additional globals found: [n=0] 
[10:19:25.214]    + additional namespaces needed: [n=0] 
[10:19:25.215]  - Finding globals in '...' for chunk #3 ... DONE
[10:19:25.215]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:25.215]  - seeds: <none>
[10:19:25.215]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.215] getGlobalsAndPackages() ...
[10:19:25.215] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.215] Resolving globals: FALSE
[10:19:25.215] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:25.216] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:25.216] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.216] 
[10:19:25.216] getGlobalsAndPackages() ... DONE
[10:19:25.217] run() for ‘Future’ ...
[10:19:25.217] - state: ‘created’
[10:19:25.217] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.231] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.231]   - Field: ‘node’
[10:19:25.231]   - Field: ‘label’
[10:19:25.231]   - Field: ‘local’
[10:19:25.232]   - Field: ‘owner’
[10:19:25.232]   - Field: ‘envir’
[10:19:25.232]   - Field: ‘workers’
[10:19:25.232]   - Field: ‘packages’
[10:19:25.232]   - Field: ‘gc’
[10:19:25.232]   - Field: ‘conditions’
[10:19:25.232]   - Field: ‘persistent’
[10:19:25.232]   - Field: ‘expr’
[10:19:25.232]   - Field: ‘uuid’
[10:19:25.233]   - Field: ‘seed’
[10:19:25.233]   - Field: ‘version’
[10:19:25.233]   - Field: ‘result’
[10:19:25.233]   - Field: ‘asynchronous’
[10:19:25.233]   - Field: ‘calls’
[10:19:25.233]   - Field: ‘globals’
[10:19:25.233]   - Field: ‘stdout’
[10:19:25.233]   - Field: ‘earlySignal’
[10:19:25.233]   - Field: ‘lazy’
[10:19:25.233]   - Field: ‘state’
[10:19:25.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.234] - Launch lazy future ...
[10:19:25.234] Packages needed by the future expression (n = 0): <none>
[10:19:25.234] Packages needed by future strategies (n = 0): <none>
[10:19:25.235] {
[10:19:25.235]     {
[10:19:25.235]         {
[10:19:25.235]             ...future.startTime <- base::Sys.time()
[10:19:25.235]             {
[10:19:25.235]                 {
[10:19:25.235]                   {
[10:19:25.235]                     {
[10:19:25.235]                       base::local({
[10:19:25.235]                         has_future <- base::requireNamespace("future", 
[10:19:25.235]                           quietly = TRUE)
[10:19:25.235]                         if (has_future) {
[10:19:25.235]                           ns <- base::getNamespace("future")
[10:19:25.235]                           version <- ns[[".package"]][["version"]]
[10:19:25.235]                           if (is.null(version)) 
[10:19:25.235]                             version <- utils::packageVersion("future")
[10:19:25.235]                         }
[10:19:25.235]                         else {
[10:19:25.235]                           version <- NULL
[10:19:25.235]                         }
[10:19:25.235]                         if (!has_future || version < "1.8.0") {
[10:19:25.235]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.235]                             "", base::R.version$version.string), 
[10:19:25.235]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.235]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.235]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.235]                               "release", "version")], collapse = " "), 
[10:19:25.235]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.235]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.235]                             info)
[10:19:25.235]                           info <- base::paste(info, collapse = "; ")
[10:19:25.235]                           if (!has_future) {
[10:19:25.235]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.235]                               info)
[10:19:25.235]                           }
[10:19:25.235]                           else {
[10:19:25.235]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.235]                               info, version)
[10:19:25.235]                           }
[10:19:25.235]                           base::stop(msg)
[10:19:25.235]                         }
[10:19:25.235]                       })
[10:19:25.235]                     }
[10:19:25.235]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.235]                     base::options(mc.cores = 1L)
[10:19:25.235]                   }
[10:19:25.235]                   ...future.strategy.old <- future::plan("list")
[10:19:25.235]                   options(future.plan = NULL)
[10:19:25.235]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.235]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.235]                 }
[10:19:25.235]                 ...future.workdir <- getwd()
[10:19:25.235]             }
[10:19:25.235]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.235]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.235]         }
[10:19:25.235]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.235]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:25.235]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.235]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.235]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.235]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.235]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.235]             base::names(...future.oldOptions))
[10:19:25.235]     }
[10:19:25.235]     if (FALSE) {
[10:19:25.235]     }
[10:19:25.235]     else {
[10:19:25.235]         if (TRUE) {
[10:19:25.235]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.235]                 open = "w")
[10:19:25.235]         }
[10:19:25.235]         else {
[10:19:25.235]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.235]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.235]         }
[10:19:25.235]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.235]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.235]             base::sink(type = "output", split = FALSE)
[10:19:25.235]             base::close(...future.stdout)
[10:19:25.235]         }, add = TRUE)
[10:19:25.235]     }
[10:19:25.235]     ...future.frame <- base::sys.nframe()
[10:19:25.235]     ...future.conditions <- base::list()
[10:19:25.235]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.235]     if (FALSE) {
[10:19:25.235]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.235]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.235]     }
[10:19:25.235]     ...future.result <- base::tryCatch({
[10:19:25.235]         base::withCallingHandlers({
[10:19:25.235]             ...future.value <- base::withVisible(base::local({
[10:19:25.235]                 ...future.makeSendCondition <- base::local({
[10:19:25.235]                   sendCondition <- NULL
[10:19:25.235]                   function(frame = 1L) {
[10:19:25.235]                     if (is.function(sendCondition)) 
[10:19:25.235]                       return(sendCondition)
[10:19:25.235]                     ns <- getNamespace("parallel")
[10:19:25.235]                     if (exists("sendData", mode = "function", 
[10:19:25.235]                       envir = ns)) {
[10:19:25.235]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.235]                         envir = ns)
[10:19:25.235]                       envir <- sys.frame(frame)
[10:19:25.235]                       master <- NULL
[10:19:25.235]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.235]                         !identical(envir, emptyenv())) {
[10:19:25.235]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.235]                           inherits = FALSE)) {
[10:19:25.235]                           master <- get("master", mode = "list", 
[10:19:25.235]                             envir = envir, inherits = FALSE)
[10:19:25.235]                           if (inherits(master, c("SOCKnode", 
[10:19:25.235]                             "SOCK0node"))) {
[10:19:25.235]                             sendCondition <<- function(cond) {
[10:19:25.235]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.235]                                 success = TRUE)
[10:19:25.235]                               parallel_sendData(master, data)
[10:19:25.235]                             }
[10:19:25.235]                             return(sendCondition)
[10:19:25.235]                           }
[10:19:25.235]                         }
[10:19:25.235]                         frame <- frame + 1L
[10:19:25.235]                         envir <- sys.frame(frame)
[10:19:25.235]                       }
[10:19:25.235]                     }
[10:19:25.235]                     sendCondition <<- function(cond) NULL
[10:19:25.235]                   }
[10:19:25.235]                 })
[10:19:25.235]                 withCallingHandlers({
[10:19:25.235]                   {
[10:19:25.235]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.235]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.235]                       ...future.globals.maxSize)) {
[10:19:25.235]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.235]                       on.exit(options(oopts), add = TRUE)
[10:19:25.235]                     }
[10:19:25.235]                     {
[10:19:25.235]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.235]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.235]                         USE.NAMES = FALSE)
[10:19:25.235]                       do.call(mapply, args = args)
[10:19:25.235]                     }
[10:19:25.235]                   }
[10:19:25.235]                 }, immediateCondition = function(cond) {
[10:19:25.235]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.235]                   sendCondition(cond)
[10:19:25.235]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.235]                   {
[10:19:25.235]                     inherits <- base::inherits
[10:19:25.235]                     invokeRestart <- base::invokeRestart
[10:19:25.235]                     is.null <- base::is.null
[10:19:25.235]                     muffled <- FALSE
[10:19:25.235]                     if (inherits(cond, "message")) {
[10:19:25.235]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.235]                       if (muffled) 
[10:19:25.235]                         invokeRestart("muffleMessage")
[10:19:25.235]                     }
[10:19:25.235]                     else if (inherits(cond, "warning")) {
[10:19:25.235]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.235]                       if (muffled) 
[10:19:25.235]                         invokeRestart("muffleWarning")
[10:19:25.235]                     }
[10:19:25.235]                     else if (inherits(cond, "condition")) {
[10:19:25.235]                       if (!is.null(pattern)) {
[10:19:25.235]                         computeRestarts <- base::computeRestarts
[10:19:25.235]                         grepl <- base::grepl
[10:19:25.235]                         restarts <- computeRestarts(cond)
[10:19:25.235]                         for (restart in restarts) {
[10:19:25.235]                           name <- restart$name
[10:19:25.235]                           if (is.null(name)) 
[10:19:25.235]                             next
[10:19:25.235]                           if (!grepl(pattern, name)) 
[10:19:25.235]                             next
[10:19:25.235]                           invokeRestart(restart)
[10:19:25.235]                           muffled <- TRUE
[10:19:25.235]                           break
[10:19:25.235]                         }
[10:19:25.235]                       }
[10:19:25.235]                     }
[10:19:25.235]                     invisible(muffled)
[10:19:25.235]                   }
[10:19:25.235]                   muffleCondition(cond)
[10:19:25.235]                 })
[10:19:25.235]             }))
[10:19:25.235]             future::FutureResult(value = ...future.value$value, 
[10:19:25.235]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.235]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.235]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.235]                     ...future.globalenv.names))
[10:19:25.235]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.235]         }, condition = base::local({
[10:19:25.235]             c <- base::c
[10:19:25.235]             inherits <- base::inherits
[10:19:25.235]             invokeRestart <- base::invokeRestart
[10:19:25.235]             length <- base::length
[10:19:25.235]             list <- base::list
[10:19:25.235]             seq.int <- base::seq.int
[10:19:25.235]             signalCondition <- base::signalCondition
[10:19:25.235]             sys.calls <- base::sys.calls
[10:19:25.235]             `[[` <- base::`[[`
[10:19:25.235]             `+` <- base::`+`
[10:19:25.235]             `<<-` <- base::`<<-`
[10:19:25.235]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.235]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.235]                   3L)]
[10:19:25.235]             }
[10:19:25.235]             function(cond) {
[10:19:25.235]                 is_error <- inherits(cond, "error")
[10:19:25.235]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.235]                   NULL)
[10:19:25.235]                 if (is_error) {
[10:19:25.235]                   sessionInformation <- function() {
[10:19:25.235]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.235]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.235]                       search = base::search(), system = base::Sys.info())
[10:19:25.235]                   }
[10:19:25.235]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.235]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.235]                     cond$call), session = sessionInformation(), 
[10:19:25.235]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.235]                   signalCondition(cond)
[10:19:25.235]                 }
[10:19:25.235]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.235]                 "immediateCondition"))) {
[10:19:25.235]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.235]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.235]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.235]                   if (TRUE && !signal) {
[10:19:25.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.235]                     {
[10:19:25.235]                       inherits <- base::inherits
[10:19:25.235]                       invokeRestart <- base::invokeRestart
[10:19:25.235]                       is.null <- base::is.null
[10:19:25.235]                       muffled <- FALSE
[10:19:25.235]                       if (inherits(cond, "message")) {
[10:19:25.235]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.235]                         if (muffled) 
[10:19:25.235]                           invokeRestart("muffleMessage")
[10:19:25.235]                       }
[10:19:25.235]                       else if (inherits(cond, "warning")) {
[10:19:25.235]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.235]                         if (muffled) 
[10:19:25.235]                           invokeRestart("muffleWarning")
[10:19:25.235]                       }
[10:19:25.235]                       else if (inherits(cond, "condition")) {
[10:19:25.235]                         if (!is.null(pattern)) {
[10:19:25.235]                           computeRestarts <- base::computeRestarts
[10:19:25.235]                           grepl <- base::grepl
[10:19:25.235]                           restarts <- computeRestarts(cond)
[10:19:25.235]                           for (restart in restarts) {
[10:19:25.235]                             name <- restart$name
[10:19:25.235]                             if (is.null(name)) 
[10:19:25.235]                               next
[10:19:25.235]                             if (!grepl(pattern, name)) 
[10:19:25.235]                               next
[10:19:25.235]                             invokeRestart(restart)
[10:19:25.235]                             muffled <- TRUE
[10:19:25.235]                             break
[10:19:25.235]                           }
[10:19:25.235]                         }
[10:19:25.235]                       }
[10:19:25.235]                       invisible(muffled)
[10:19:25.235]                     }
[10:19:25.235]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.235]                   }
[10:19:25.235]                 }
[10:19:25.235]                 else {
[10:19:25.235]                   if (TRUE) {
[10:19:25.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.235]                     {
[10:19:25.235]                       inherits <- base::inherits
[10:19:25.235]                       invokeRestart <- base::invokeRestart
[10:19:25.235]                       is.null <- base::is.null
[10:19:25.235]                       muffled <- FALSE
[10:19:25.235]                       if (inherits(cond, "message")) {
[10:19:25.235]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.235]                         if (muffled) 
[10:19:25.235]                           invokeRestart("muffleMessage")
[10:19:25.235]                       }
[10:19:25.235]                       else if (inherits(cond, "warning")) {
[10:19:25.235]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.235]                         if (muffled) 
[10:19:25.235]                           invokeRestart("muffleWarning")
[10:19:25.235]                       }
[10:19:25.235]                       else if (inherits(cond, "condition")) {
[10:19:25.235]                         if (!is.null(pattern)) {
[10:19:25.235]                           computeRestarts <- base::computeRestarts
[10:19:25.235]                           grepl <- base::grepl
[10:19:25.235]                           restarts <- computeRestarts(cond)
[10:19:25.235]                           for (restart in restarts) {
[10:19:25.235]                             name <- restart$name
[10:19:25.235]                             if (is.null(name)) 
[10:19:25.235]                               next
[10:19:25.235]                             if (!grepl(pattern, name)) 
[10:19:25.235]                               next
[10:19:25.235]                             invokeRestart(restart)
[10:19:25.235]                             muffled <- TRUE
[10:19:25.235]                             break
[10:19:25.235]                           }
[10:19:25.235]                         }
[10:19:25.235]                       }
[10:19:25.235]                       invisible(muffled)
[10:19:25.235]                     }
[10:19:25.235]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.235]                   }
[10:19:25.235]                 }
[10:19:25.235]             }
[10:19:25.235]         }))
[10:19:25.235]     }, error = function(ex) {
[10:19:25.235]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.235]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.235]                 ...future.rng), started = ...future.startTime, 
[10:19:25.235]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.235]             version = "1.8"), class = "FutureResult")
[10:19:25.235]     }, finally = {
[10:19:25.235]         if (!identical(...future.workdir, getwd())) 
[10:19:25.235]             setwd(...future.workdir)
[10:19:25.235]         {
[10:19:25.235]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.235]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.235]             }
[10:19:25.235]             base::options(...future.oldOptions)
[10:19:25.235]             if (.Platform$OS.type == "windows") {
[10:19:25.235]                 old_names <- names(...future.oldEnvVars)
[10:19:25.235]                 envs <- base::Sys.getenv()
[10:19:25.235]                 names <- names(envs)
[10:19:25.235]                 common <- intersect(names, old_names)
[10:19:25.235]                 added <- setdiff(names, old_names)
[10:19:25.235]                 removed <- setdiff(old_names, names)
[10:19:25.235]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.235]                   envs[common]]
[10:19:25.235]                 NAMES <- toupper(changed)
[10:19:25.235]                 args <- list()
[10:19:25.235]                 for (kk in seq_along(NAMES)) {
[10:19:25.235]                   name <- changed[[kk]]
[10:19:25.235]                   NAME <- NAMES[[kk]]
[10:19:25.235]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.235]                     next
[10:19:25.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.235]                 }
[10:19:25.235]                 NAMES <- toupper(added)
[10:19:25.235]                 for (kk in seq_along(NAMES)) {
[10:19:25.235]                   name <- added[[kk]]
[10:19:25.235]                   NAME <- NAMES[[kk]]
[10:19:25.235]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.235]                     next
[10:19:25.235]                   args[[name]] <- ""
[10:19:25.235]                 }
[10:19:25.235]                 NAMES <- toupper(removed)
[10:19:25.235]                 for (kk in seq_along(NAMES)) {
[10:19:25.235]                   name <- removed[[kk]]
[10:19:25.235]                   NAME <- NAMES[[kk]]
[10:19:25.235]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.235]                     next
[10:19:25.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.235]                 }
[10:19:25.235]                 if (length(args) > 0) 
[10:19:25.235]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.235]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.235]             }
[10:19:25.235]             else {
[10:19:25.235]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.235]             }
[10:19:25.235]             {
[10:19:25.235]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.235]                   0L) {
[10:19:25.235]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.235]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.235]                   base::options(opts)
[10:19:25.235]                 }
[10:19:25.235]                 {
[10:19:25.235]                   {
[10:19:25.235]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.235]                     NULL
[10:19:25.235]                   }
[10:19:25.235]                   options(future.plan = NULL)
[10:19:25.235]                   if (is.na(NA_character_)) 
[10:19:25.235]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.235]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.235]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.235]                     .init = FALSE)
[10:19:25.235]                 }
[10:19:25.235]             }
[10:19:25.235]         }
[10:19:25.235]     })
[10:19:25.235]     if (TRUE) {
[10:19:25.235]         base::sink(type = "output", split = FALSE)
[10:19:25.235]         if (TRUE) {
[10:19:25.235]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.235]         }
[10:19:25.235]         else {
[10:19:25.235]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.235]         }
[10:19:25.235]         base::close(...future.stdout)
[10:19:25.235]         ...future.stdout <- NULL
[10:19:25.235]     }
[10:19:25.235]     ...future.result$conditions <- ...future.conditions
[10:19:25.235]     ...future.result$finished <- base::Sys.time()
[10:19:25.235]     ...future.result
[10:19:25.235] }
[10:19:25.237] Poll #1 (0): usedNodes() = 2, workers = 2
[10:19:25.248] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.248] - Validating connection of MultisessionFuture
[10:19:25.248] - received message: FutureResult
[10:19:25.248] - Received FutureResult
[10:19:25.248] - Erased future from FutureRegistry
[10:19:25.248] result() for ClusterFuture ...
[10:19:25.249] - result already collected: FutureResult
[10:19:25.249] result() for ClusterFuture ... done
[10:19:25.249] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.249] result() for ClusterFuture ...
[10:19:25.249] - result already collected: FutureResult
[10:19:25.249] result() for ClusterFuture ... done
[10:19:25.249] result() for ClusterFuture ...
[10:19:25.249] - result already collected: FutureResult
[10:19:25.249] result() for ClusterFuture ... done
[10:19:25.250] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[10:19:25.250] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:19:25.250] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:19:25.251] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:25.251] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.251] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ...
[10:19:25.251] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ... DONE
[10:19:25.251] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:25.252] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.252] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:25.252] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.252] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[10:19:25.253] MultisessionFuture started
[10:19:25.253] - Launch lazy future ... done
[10:19:25.253] run() for ‘MultisessionFuture’ ... done
[10:19:25.253] Created future:
[10:19:25.253] MultisessionFuture:
[10:19:25.253] Label: ‘future_mapply-3’
[10:19:25.253] Expression:
[10:19:25.253] {
[10:19:25.253]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.253]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.253]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.253]         on.exit(options(oopts), add = TRUE)
[10:19:25.253]     }
[10:19:25.253]     {
[10:19:25.253]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.253]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.253]         do.call(mapply, args = args)
[10:19:25.253]     }
[10:19:25.253] }
[10:19:25.253] Lazy evaluation: FALSE
[10:19:25.253] Asynchronous evaluation: TRUE
[10:19:25.253] Local evaluation: TRUE
[10:19:25.253] Environment: R_GlobalEnv
[10:19:25.253] Capture standard output: TRUE
[10:19:25.253] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.253] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.253] Packages: <none>
[10:19:25.253] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.253] Resolved: FALSE
[10:19:25.253] Value: <not collected>
[10:19:25.253] Conditions captured: <none>
[10:19:25.253] Early signaling: FALSE
[10:19:25.253] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.253] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.264] Chunk #3 of 5 ... DONE
[10:19:25.264] Chunk #4 of 5 ...
[10:19:25.265]  - Finding globals in '...' for chunk #4 ...
[10:19:25.265] getGlobalsAndPackages() ...
[10:19:25.265] Searching for globals...
[10:19:25.265] 
[10:19:25.265] Searching for globals ... DONE
[10:19:25.265] - globals: [0] <none>
[10:19:25.265] getGlobalsAndPackages() ... DONE
[10:19:25.266]    + additional globals found: [n=0] 
[10:19:25.266]    + additional namespaces needed: [n=0] 
[10:19:25.266]  - Finding globals in '...' for chunk #4 ... DONE
[10:19:25.266]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:25.266]  - seeds: <none>
[10:19:25.266]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.266] getGlobalsAndPackages() ...
[10:19:25.266] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.266] Resolving globals: FALSE
[10:19:25.267] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:25.267] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:25.267] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.267] 
[10:19:25.267] getGlobalsAndPackages() ... DONE
[10:19:25.268] run() for ‘Future’ ...
[10:19:25.268] - state: ‘created’
[10:19:25.268] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.282] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.282]   - Field: ‘node’
[10:19:25.282]   - Field: ‘label’
[10:19:25.282]   - Field: ‘local’
[10:19:25.282]   - Field: ‘owner’
[10:19:25.283]   - Field: ‘envir’
[10:19:25.283]   - Field: ‘workers’
[10:19:25.283]   - Field: ‘packages’
[10:19:25.283]   - Field: ‘gc’
[10:19:25.283]   - Field: ‘conditions’
[10:19:25.283]   - Field: ‘persistent’
[10:19:25.283]   - Field: ‘expr’
[10:19:25.283]   - Field: ‘uuid’
[10:19:25.283]   - Field: ‘seed’
[10:19:25.283]   - Field: ‘version’
[10:19:25.283]   - Field: ‘result’
[10:19:25.284]   - Field: ‘asynchronous’
[10:19:25.284]   - Field: ‘calls’
[10:19:25.284]   - Field: ‘globals’
[10:19:25.284]   - Field: ‘stdout’
[10:19:25.284]   - Field: ‘earlySignal’
[10:19:25.284]   - Field: ‘lazy’
[10:19:25.284]   - Field: ‘state’
[10:19:25.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.284] - Launch lazy future ...
[10:19:25.284] Packages needed by the future expression (n = 0): <none>
[10:19:25.285] Packages needed by future strategies (n = 0): <none>
[10:19:25.285] {
[10:19:25.285]     {
[10:19:25.285]         {
[10:19:25.285]             ...future.startTime <- base::Sys.time()
[10:19:25.285]             {
[10:19:25.285]                 {
[10:19:25.285]                   {
[10:19:25.285]                     {
[10:19:25.285]                       base::local({
[10:19:25.285]                         has_future <- base::requireNamespace("future", 
[10:19:25.285]                           quietly = TRUE)
[10:19:25.285]                         if (has_future) {
[10:19:25.285]                           ns <- base::getNamespace("future")
[10:19:25.285]                           version <- ns[[".package"]][["version"]]
[10:19:25.285]                           if (is.null(version)) 
[10:19:25.285]                             version <- utils::packageVersion("future")
[10:19:25.285]                         }
[10:19:25.285]                         else {
[10:19:25.285]                           version <- NULL
[10:19:25.285]                         }
[10:19:25.285]                         if (!has_future || version < "1.8.0") {
[10:19:25.285]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.285]                             "", base::R.version$version.string), 
[10:19:25.285]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.285]                               "release", "version")], collapse = " "), 
[10:19:25.285]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.285]                             info)
[10:19:25.285]                           info <- base::paste(info, collapse = "; ")
[10:19:25.285]                           if (!has_future) {
[10:19:25.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.285]                               info)
[10:19:25.285]                           }
[10:19:25.285]                           else {
[10:19:25.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.285]                               info, version)
[10:19:25.285]                           }
[10:19:25.285]                           base::stop(msg)
[10:19:25.285]                         }
[10:19:25.285]                       })
[10:19:25.285]                     }
[10:19:25.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.285]                     base::options(mc.cores = 1L)
[10:19:25.285]                   }
[10:19:25.285]                   ...future.strategy.old <- future::plan("list")
[10:19:25.285]                   options(future.plan = NULL)
[10:19:25.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.285]                 }
[10:19:25.285]                 ...future.workdir <- getwd()
[10:19:25.285]             }
[10:19:25.285]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.285]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.285]         }
[10:19:25.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.285]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:25.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.285]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.285]             base::names(...future.oldOptions))
[10:19:25.285]     }
[10:19:25.285]     if (FALSE) {
[10:19:25.285]     }
[10:19:25.285]     else {
[10:19:25.285]         if (TRUE) {
[10:19:25.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.285]                 open = "w")
[10:19:25.285]         }
[10:19:25.285]         else {
[10:19:25.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.285]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.285]         }
[10:19:25.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.285]             base::sink(type = "output", split = FALSE)
[10:19:25.285]             base::close(...future.stdout)
[10:19:25.285]         }, add = TRUE)
[10:19:25.285]     }
[10:19:25.285]     ...future.frame <- base::sys.nframe()
[10:19:25.285]     ...future.conditions <- base::list()
[10:19:25.285]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.285]     if (FALSE) {
[10:19:25.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.285]     }
[10:19:25.285]     ...future.result <- base::tryCatch({
[10:19:25.285]         base::withCallingHandlers({
[10:19:25.285]             ...future.value <- base::withVisible(base::local({
[10:19:25.285]                 ...future.makeSendCondition <- base::local({
[10:19:25.285]                   sendCondition <- NULL
[10:19:25.285]                   function(frame = 1L) {
[10:19:25.285]                     if (is.function(sendCondition)) 
[10:19:25.285]                       return(sendCondition)
[10:19:25.285]                     ns <- getNamespace("parallel")
[10:19:25.285]                     if (exists("sendData", mode = "function", 
[10:19:25.285]                       envir = ns)) {
[10:19:25.285]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.285]                         envir = ns)
[10:19:25.285]                       envir <- sys.frame(frame)
[10:19:25.285]                       master <- NULL
[10:19:25.285]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.285]                         !identical(envir, emptyenv())) {
[10:19:25.285]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.285]                           inherits = FALSE)) {
[10:19:25.285]                           master <- get("master", mode = "list", 
[10:19:25.285]                             envir = envir, inherits = FALSE)
[10:19:25.285]                           if (inherits(master, c("SOCKnode", 
[10:19:25.285]                             "SOCK0node"))) {
[10:19:25.285]                             sendCondition <<- function(cond) {
[10:19:25.285]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.285]                                 success = TRUE)
[10:19:25.285]                               parallel_sendData(master, data)
[10:19:25.285]                             }
[10:19:25.285]                             return(sendCondition)
[10:19:25.285]                           }
[10:19:25.285]                         }
[10:19:25.285]                         frame <- frame + 1L
[10:19:25.285]                         envir <- sys.frame(frame)
[10:19:25.285]                       }
[10:19:25.285]                     }
[10:19:25.285]                     sendCondition <<- function(cond) NULL
[10:19:25.285]                   }
[10:19:25.285]                 })
[10:19:25.285]                 withCallingHandlers({
[10:19:25.285]                   {
[10:19:25.285]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.285]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.285]                       ...future.globals.maxSize)) {
[10:19:25.285]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.285]                       on.exit(options(oopts), add = TRUE)
[10:19:25.285]                     }
[10:19:25.285]                     {
[10:19:25.285]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.285]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.285]                         USE.NAMES = FALSE)
[10:19:25.285]                       do.call(mapply, args = args)
[10:19:25.285]                     }
[10:19:25.285]                   }
[10:19:25.285]                 }, immediateCondition = function(cond) {
[10:19:25.285]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.285]                   sendCondition(cond)
[10:19:25.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.285]                   {
[10:19:25.285]                     inherits <- base::inherits
[10:19:25.285]                     invokeRestart <- base::invokeRestart
[10:19:25.285]                     is.null <- base::is.null
[10:19:25.285]                     muffled <- FALSE
[10:19:25.285]                     if (inherits(cond, "message")) {
[10:19:25.285]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.285]                       if (muffled) 
[10:19:25.285]                         invokeRestart("muffleMessage")
[10:19:25.285]                     }
[10:19:25.285]                     else if (inherits(cond, "warning")) {
[10:19:25.285]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.285]                       if (muffled) 
[10:19:25.285]                         invokeRestart("muffleWarning")
[10:19:25.285]                     }
[10:19:25.285]                     else if (inherits(cond, "condition")) {
[10:19:25.285]                       if (!is.null(pattern)) {
[10:19:25.285]                         computeRestarts <- base::computeRestarts
[10:19:25.285]                         grepl <- base::grepl
[10:19:25.285]                         restarts <- computeRestarts(cond)
[10:19:25.285]                         for (restart in restarts) {
[10:19:25.285]                           name <- restart$name
[10:19:25.285]                           if (is.null(name)) 
[10:19:25.285]                             next
[10:19:25.285]                           if (!grepl(pattern, name)) 
[10:19:25.285]                             next
[10:19:25.285]                           invokeRestart(restart)
[10:19:25.285]                           muffled <- TRUE
[10:19:25.285]                           break
[10:19:25.285]                         }
[10:19:25.285]                       }
[10:19:25.285]                     }
[10:19:25.285]                     invisible(muffled)
[10:19:25.285]                   }
[10:19:25.285]                   muffleCondition(cond)
[10:19:25.285]                 })
[10:19:25.285]             }))
[10:19:25.285]             future::FutureResult(value = ...future.value$value, 
[10:19:25.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.285]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.285]                     ...future.globalenv.names))
[10:19:25.285]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.285]         }, condition = base::local({
[10:19:25.285]             c <- base::c
[10:19:25.285]             inherits <- base::inherits
[10:19:25.285]             invokeRestart <- base::invokeRestart
[10:19:25.285]             length <- base::length
[10:19:25.285]             list <- base::list
[10:19:25.285]             seq.int <- base::seq.int
[10:19:25.285]             signalCondition <- base::signalCondition
[10:19:25.285]             sys.calls <- base::sys.calls
[10:19:25.285]             `[[` <- base::`[[`
[10:19:25.285]             `+` <- base::`+`
[10:19:25.285]             `<<-` <- base::`<<-`
[10:19:25.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.285]                   3L)]
[10:19:25.285]             }
[10:19:25.285]             function(cond) {
[10:19:25.285]                 is_error <- inherits(cond, "error")
[10:19:25.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.285]                   NULL)
[10:19:25.285]                 if (is_error) {
[10:19:25.285]                   sessionInformation <- function() {
[10:19:25.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.285]                       search = base::search(), system = base::Sys.info())
[10:19:25.285]                   }
[10:19:25.285]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.285]                     cond$call), session = sessionInformation(), 
[10:19:25.285]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.285]                   signalCondition(cond)
[10:19:25.285]                 }
[10:19:25.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.285]                 "immediateCondition"))) {
[10:19:25.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.285]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.285]                   if (TRUE && !signal) {
[10:19:25.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.285]                     {
[10:19:25.285]                       inherits <- base::inherits
[10:19:25.285]                       invokeRestart <- base::invokeRestart
[10:19:25.285]                       is.null <- base::is.null
[10:19:25.285]                       muffled <- FALSE
[10:19:25.285]                       if (inherits(cond, "message")) {
[10:19:25.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.285]                         if (muffled) 
[10:19:25.285]                           invokeRestart("muffleMessage")
[10:19:25.285]                       }
[10:19:25.285]                       else if (inherits(cond, "warning")) {
[10:19:25.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.285]                         if (muffled) 
[10:19:25.285]                           invokeRestart("muffleWarning")
[10:19:25.285]                       }
[10:19:25.285]                       else if (inherits(cond, "condition")) {
[10:19:25.285]                         if (!is.null(pattern)) {
[10:19:25.285]                           computeRestarts <- base::computeRestarts
[10:19:25.285]                           grepl <- base::grepl
[10:19:25.285]                           restarts <- computeRestarts(cond)
[10:19:25.285]                           for (restart in restarts) {
[10:19:25.285]                             name <- restart$name
[10:19:25.285]                             if (is.null(name)) 
[10:19:25.285]                               next
[10:19:25.285]                             if (!grepl(pattern, name)) 
[10:19:25.285]                               next
[10:19:25.285]                             invokeRestart(restart)
[10:19:25.285]                             muffled <- TRUE
[10:19:25.285]                             break
[10:19:25.285]                           }
[10:19:25.285]                         }
[10:19:25.285]                       }
[10:19:25.285]                       invisible(muffled)
[10:19:25.285]                     }
[10:19:25.285]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.285]                   }
[10:19:25.285]                 }
[10:19:25.285]                 else {
[10:19:25.285]                   if (TRUE) {
[10:19:25.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.285]                     {
[10:19:25.285]                       inherits <- base::inherits
[10:19:25.285]                       invokeRestart <- base::invokeRestart
[10:19:25.285]                       is.null <- base::is.null
[10:19:25.285]                       muffled <- FALSE
[10:19:25.285]                       if (inherits(cond, "message")) {
[10:19:25.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.285]                         if (muffled) 
[10:19:25.285]                           invokeRestart("muffleMessage")
[10:19:25.285]                       }
[10:19:25.285]                       else if (inherits(cond, "warning")) {
[10:19:25.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.285]                         if (muffled) 
[10:19:25.285]                           invokeRestart("muffleWarning")
[10:19:25.285]                       }
[10:19:25.285]                       else if (inherits(cond, "condition")) {
[10:19:25.285]                         if (!is.null(pattern)) {
[10:19:25.285]                           computeRestarts <- base::computeRestarts
[10:19:25.285]                           grepl <- base::grepl
[10:19:25.285]                           restarts <- computeRestarts(cond)
[10:19:25.285]                           for (restart in restarts) {
[10:19:25.285]                             name <- restart$name
[10:19:25.285]                             if (is.null(name)) 
[10:19:25.285]                               next
[10:19:25.285]                             if (!grepl(pattern, name)) 
[10:19:25.285]                               next
[10:19:25.285]                             invokeRestart(restart)
[10:19:25.285]                             muffled <- TRUE
[10:19:25.285]                             break
[10:19:25.285]                           }
[10:19:25.285]                         }
[10:19:25.285]                       }
[10:19:25.285]                       invisible(muffled)
[10:19:25.285]                     }
[10:19:25.285]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.285]                   }
[10:19:25.285]                 }
[10:19:25.285]             }
[10:19:25.285]         }))
[10:19:25.285]     }, error = function(ex) {
[10:19:25.285]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.285]                 ...future.rng), started = ...future.startTime, 
[10:19:25.285]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.285]             version = "1.8"), class = "FutureResult")
[10:19:25.285]     }, finally = {
[10:19:25.285]         if (!identical(...future.workdir, getwd())) 
[10:19:25.285]             setwd(...future.workdir)
[10:19:25.285]         {
[10:19:25.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.285]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.285]             }
[10:19:25.285]             base::options(...future.oldOptions)
[10:19:25.285]             if (.Platform$OS.type == "windows") {
[10:19:25.285]                 old_names <- names(...future.oldEnvVars)
[10:19:25.285]                 envs <- base::Sys.getenv()
[10:19:25.285]                 names <- names(envs)
[10:19:25.285]                 common <- intersect(names, old_names)
[10:19:25.285]                 added <- setdiff(names, old_names)
[10:19:25.285]                 removed <- setdiff(old_names, names)
[10:19:25.285]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.285]                   envs[common]]
[10:19:25.285]                 NAMES <- toupper(changed)
[10:19:25.285]                 args <- list()
[10:19:25.285]                 for (kk in seq_along(NAMES)) {
[10:19:25.285]                   name <- changed[[kk]]
[10:19:25.285]                   NAME <- NAMES[[kk]]
[10:19:25.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.285]                     next
[10:19:25.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.285]                 }
[10:19:25.285]                 NAMES <- toupper(added)
[10:19:25.285]                 for (kk in seq_along(NAMES)) {
[10:19:25.285]                   name <- added[[kk]]
[10:19:25.285]                   NAME <- NAMES[[kk]]
[10:19:25.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.285]                     next
[10:19:25.285]                   args[[name]] <- ""
[10:19:25.285]                 }
[10:19:25.285]                 NAMES <- toupper(removed)
[10:19:25.285]                 for (kk in seq_along(NAMES)) {
[10:19:25.285]                   name <- removed[[kk]]
[10:19:25.285]                   NAME <- NAMES[[kk]]
[10:19:25.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.285]                     next
[10:19:25.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.285]                 }
[10:19:25.285]                 if (length(args) > 0) 
[10:19:25.285]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.285]             }
[10:19:25.285]             else {
[10:19:25.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.285]             }
[10:19:25.285]             {
[10:19:25.285]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.285]                   0L) {
[10:19:25.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.285]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.285]                   base::options(opts)
[10:19:25.285]                 }
[10:19:25.285]                 {
[10:19:25.285]                   {
[10:19:25.285]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.285]                     NULL
[10:19:25.285]                   }
[10:19:25.285]                   options(future.plan = NULL)
[10:19:25.285]                   if (is.na(NA_character_)) 
[10:19:25.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.285]                     .init = FALSE)
[10:19:25.285]                 }
[10:19:25.285]             }
[10:19:25.285]         }
[10:19:25.285]     })
[10:19:25.285]     if (TRUE) {
[10:19:25.285]         base::sink(type = "output", split = FALSE)
[10:19:25.285]         if (TRUE) {
[10:19:25.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.285]         }
[10:19:25.285]         else {
[10:19:25.285]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.285]         }
[10:19:25.285]         base::close(...future.stdout)
[10:19:25.285]         ...future.stdout <- NULL
[10:19:25.285]     }
[10:19:25.285]     ...future.result$conditions <- ...future.conditions
[10:19:25.285]     ...future.result$finished <- base::Sys.time()
[10:19:25.285]     ...future.result
[10:19:25.285] }
[10:19:25.287] Poll #1 (0): usedNodes() = 2, workers = 2
[10:19:25.298] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.298] - Validating connection of MultisessionFuture
[10:19:25.299] - received message: FutureResult
[10:19:25.299] - Received FutureResult
[10:19:25.299] - Erased future from FutureRegistry
[10:19:25.299] result() for ClusterFuture ...
[10:19:25.299] - result already collected: FutureResult
[10:19:25.299] result() for ClusterFuture ... done
[10:19:25.299] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.299] result() for ClusterFuture ...
[10:19:25.299] - result already collected: FutureResult
[10:19:25.299] result() for ClusterFuture ... done
[10:19:25.299] result() for ClusterFuture ...
[10:19:25.300] - result already collected: FutureResult
[10:19:25.300] result() for ClusterFuture ... done
[10:19:25.300] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[10:19:25.301] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:19:25.301] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:19:25.301] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:25.302] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.302] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ...
[10:19:25.302] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ... DONE
[10:19:25.302] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:25.303] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.303] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:25.303] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.303] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[10:19:25.304] MultisessionFuture started
[10:19:25.304] - Launch lazy future ... done
[10:19:25.304] run() for ‘MultisessionFuture’ ... done
[10:19:25.304] Created future:
[10:19:25.304] MultisessionFuture:
[10:19:25.304] Label: ‘future_mapply-4’
[10:19:25.304] Expression:
[10:19:25.304] {
[10:19:25.304]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.304]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.304]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.304]         on.exit(options(oopts), add = TRUE)
[10:19:25.304]     }
[10:19:25.304]     {
[10:19:25.304]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.304]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.304]         do.call(mapply, args = args)
[10:19:25.304]     }
[10:19:25.304] }
[10:19:25.304] Lazy evaluation: FALSE
[10:19:25.304] Asynchronous evaluation: TRUE
[10:19:25.304] Local evaluation: TRUE
[10:19:25.304] Environment: R_GlobalEnv
[10:19:25.304] Capture standard output: TRUE
[10:19:25.304] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.304] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.304] Packages: <none>
[10:19:25.304] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.304] Resolved: FALSE
[10:19:25.304] Value: <not collected>
[10:19:25.304] Conditions captured: <none>
[10:19:25.304] Early signaling: FALSE
[10:19:25.304] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.304] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.316] Chunk #4 of 5 ... DONE
[10:19:25.316] Chunk #5 of 5 ...
[10:19:25.316]  - Finding globals in '...' for chunk #5 ...
[10:19:25.316] getGlobalsAndPackages() ...
[10:19:25.316] Searching for globals...
[10:19:25.317] 
[10:19:25.317] Searching for globals ... DONE
[10:19:25.317] - globals: [0] <none>
[10:19:25.317] getGlobalsAndPackages() ... DONE
[10:19:25.317]    + additional globals found: [n=0] 
[10:19:25.317]    + additional namespaces needed: [n=0] 
[10:19:25.317]  - Finding globals in '...' for chunk #5 ... DONE
[10:19:25.317]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[10:19:25.317]  - seeds: <none>
[10:19:25.317]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.317] getGlobalsAndPackages() ...
[10:19:25.318] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.318] Resolving globals: FALSE
[10:19:25.318] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:25.319] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:25.319] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.319] 
[10:19:25.319] getGlobalsAndPackages() ... DONE
[10:19:25.319] run() for ‘Future’ ...
[10:19:25.319] - state: ‘created’
[10:19:25.320] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.334] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.334]   - Field: ‘node’
[10:19:25.334]   - Field: ‘label’
[10:19:25.334]   - Field: ‘local’
[10:19:25.334]   - Field: ‘owner’
[10:19:25.334]   - Field: ‘envir’
[10:19:25.334]   - Field: ‘workers’
[10:19:25.334]   - Field: ‘packages’
[10:19:25.335]   - Field: ‘gc’
[10:19:25.335]   - Field: ‘conditions’
[10:19:25.335]   - Field: ‘persistent’
[10:19:25.335]   - Field: ‘expr’
[10:19:25.335]   - Field: ‘uuid’
[10:19:25.335]   - Field: ‘seed’
[10:19:25.335]   - Field: ‘version’
[10:19:25.335]   - Field: ‘result’
[10:19:25.335]   - Field: ‘asynchronous’
[10:19:25.335]   - Field: ‘calls’
[10:19:25.335]   - Field: ‘globals’
[10:19:25.336]   - Field: ‘stdout’
[10:19:25.336]   - Field: ‘earlySignal’
[10:19:25.336]   - Field: ‘lazy’
[10:19:25.336]   - Field: ‘state’
[10:19:25.336] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.336] - Launch lazy future ...
[10:19:25.338] Packages needed by the future expression (n = 0): <none>
[10:19:25.339] Packages needed by future strategies (n = 0): <none>
[10:19:25.339] {
[10:19:25.339]     {
[10:19:25.339]         {
[10:19:25.339]             ...future.startTime <- base::Sys.time()
[10:19:25.339]             {
[10:19:25.339]                 {
[10:19:25.339]                   {
[10:19:25.339]                     {
[10:19:25.339]                       base::local({
[10:19:25.339]                         has_future <- base::requireNamespace("future", 
[10:19:25.339]                           quietly = TRUE)
[10:19:25.339]                         if (has_future) {
[10:19:25.339]                           ns <- base::getNamespace("future")
[10:19:25.339]                           version <- ns[[".package"]][["version"]]
[10:19:25.339]                           if (is.null(version)) 
[10:19:25.339]                             version <- utils::packageVersion("future")
[10:19:25.339]                         }
[10:19:25.339]                         else {
[10:19:25.339]                           version <- NULL
[10:19:25.339]                         }
[10:19:25.339]                         if (!has_future || version < "1.8.0") {
[10:19:25.339]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.339]                             "", base::R.version$version.string), 
[10:19:25.339]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.339]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.339]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.339]                               "release", "version")], collapse = " "), 
[10:19:25.339]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.339]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.339]                             info)
[10:19:25.339]                           info <- base::paste(info, collapse = "; ")
[10:19:25.339]                           if (!has_future) {
[10:19:25.339]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.339]                               info)
[10:19:25.339]                           }
[10:19:25.339]                           else {
[10:19:25.339]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.339]                               info, version)
[10:19:25.339]                           }
[10:19:25.339]                           base::stop(msg)
[10:19:25.339]                         }
[10:19:25.339]                       })
[10:19:25.339]                     }
[10:19:25.339]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.339]                     base::options(mc.cores = 1L)
[10:19:25.339]                   }
[10:19:25.339]                   ...future.strategy.old <- future::plan("list")
[10:19:25.339]                   options(future.plan = NULL)
[10:19:25.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.339]                 }
[10:19:25.339]                 ...future.workdir <- getwd()
[10:19:25.339]             }
[10:19:25.339]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.339]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.339]         }
[10:19:25.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.339]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[10:19:25.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.339]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.339]             base::names(...future.oldOptions))
[10:19:25.339]     }
[10:19:25.339]     if (FALSE) {
[10:19:25.339]     }
[10:19:25.339]     else {
[10:19:25.339]         if (TRUE) {
[10:19:25.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.339]                 open = "w")
[10:19:25.339]         }
[10:19:25.339]         else {
[10:19:25.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.339]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.339]         }
[10:19:25.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.339]             base::sink(type = "output", split = FALSE)
[10:19:25.339]             base::close(...future.stdout)
[10:19:25.339]         }, add = TRUE)
[10:19:25.339]     }
[10:19:25.339]     ...future.frame <- base::sys.nframe()
[10:19:25.339]     ...future.conditions <- base::list()
[10:19:25.339]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.339]     if (FALSE) {
[10:19:25.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.339]     }
[10:19:25.339]     ...future.result <- base::tryCatch({
[10:19:25.339]         base::withCallingHandlers({
[10:19:25.339]             ...future.value <- base::withVisible(base::local({
[10:19:25.339]                 ...future.makeSendCondition <- base::local({
[10:19:25.339]                   sendCondition <- NULL
[10:19:25.339]                   function(frame = 1L) {
[10:19:25.339]                     if (is.function(sendCondition)) 
[10:19:25.339]                       return(sendCondition)
[10:19:25.339]                     ns <- getNamespace("parallel")
[10:19:25.339]                     if (exists("sendData", mode = "function", 
[10:19:25.339]                       envir = ns)) {
[10:19:25.339]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.339]                         envir = ns)
[10:19:25.339]                       envir <- sys.frame(frame)
[10:19:25.339]                       master <- NULL
[10:19:25.339]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.339]                         !identical(envir, emptyenv())) {
[10:19:25.339]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.339]                           inherits = FALSE)) {
[10:19:25.339]                           master <- get("master", mode = "list", 
[10:19:25.339]                             envir = envir, inherits = FALSE)
[10:19:25.339]                           if (inherits(master, c("SOCKnode", 
[10:19:25.339]                             "SOCK0node"))) {
[10:19:25.339]                             sendCondition <<- function(cond) {
[10:19:25.339]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.339]                                 success = TRUE)
[10:19:25.339]                               parallel_sendData(master, data)
[10:19:25.339]                             }
[10:19:25.339]                             return(sendCondition)
[10:19:25.339]                           }
[10:19:25.339]                         }
[10:19:25.339]                         frame <- frame + 1L
[10:19:25.339]                         envir <- sys.frame(frame)
[10:19:25.339]                       }
[10:19:25.339]                     }
[10:19:25.339]                     sendCondition <<- function(cond) NULL
[10:19:25.339]                   }
[10:19:25.339]                 })
[10:19:25.339]                 withCallingHandlers({
[10:19:25.339]                   {
[10:19:25.339]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.339]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.339]                       ...future.globals.maxSize)) {
[10:19:25.339]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.339]                       on.exit(options(oopts), add = TRUE)
[10:19:25.339]                     }
[10:19:25.339]                     {
[10:19:25.339]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.339]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.339]                         USE.NAMES = FALSE)
[10:19:25.339]                       do.call(mapply, args = args)
[10:19:25.339]                     }
[10:19:25.339]                   }
[10:19:25.339]                 }, immediateCondition = function(cond) {
[10:19:25.339]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.339]                   sendCondition(cond)
[10:19:25.339]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.339]                   {
[10:19:25.339]                     inherits <- base::inherits
[10:19:25.339]                     invokeRestart <- base::invokeRestart
[10:19:25.339]                     is.null <- base::is.null
[10:19:25.339]                     muffled <- FALSE
[10:19:25.339]                     if (inherits(cond, "message")) {
[10:19:25.339]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.339]                       if (muffled) 
[10:19:25.339]                         invokeRestart("muffleMessage")
[10:19:25.339]                     }
[10:19:25.339]                     else if (inherits(cond, "warning")) {
[10:19:25.339]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.339]                       if (muffled) 
[10:19:25.339]                         invokeRestart("muffleWarning")
[10:19:25.339]                     }
[10:19:25.339]                     else if (inherits(cond, "condition")) {
[10:19:25.339]                       if (!is.null(pattern)) {
[10:19:25.339]                         computeRestarts <- base::computeRestarts
[10:19:25.339]                         grepl <- base::grepl
[10:19:25.339]                         restarts <- computeRestarts(cond)
[10:19:25.339]                         for (restart in restarts) {
[10:19:25.339]                           name <- restart$name
[10:19:25.339]                           if (is.null(name)) 
[10:19:25.339]                             next
[10:19:25.339]                           if (!grepl(pattern, name)) 
[10:19:25.339]                             next
[10:19:25.339]                           invokeRestart(restart)
[10:19:25.339]                           muffled <- TRUE
[10:19:25.339]                           break
[10:19:25.339]                         }
[10:19:25.339]                       }
[10:19:25.339]                     }
[10:19:25.339]                     invisible(muffled)
[10:19:25.339]                   }
[10:19:25.339]                   muffleCondition(cond)
[10:19:25.339]                 })
[10:19:25.339]             }))
[10:19:25.339]             future::FutureResult(value = ...future.value$value, 
[10:19:25.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.339]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.339]                     ...future.globalenv.names))
[10:19:25.339]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.339]         }, condition = base::local({
[10:19:25.339]             c <- base::c
[10:19:25.339]             inherits <- base::inherits
[10:19:25.339]             invokeRestart <- base::invokeRestart
[10:19:25.339]             length <- base::length
[10:19:25.339]             list <- base::list
[10:19:25.339]             seq.int <- base::seq.int
[10:19:25.339]             signalCondition <- base::signalCondition
[10:19:25.339]             sys.calls <- base::sys.calls
[10:19:25.339]             `[[` <- base::`[[`
[10:19:25.339]             `+` <- base::`+`
[10:19:25.339]             `<<-` <- base::`<<-`
[10:19:25.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.339]                   3L)]
[10:19:25.339]             }
[10:19:25.339]             function(cond) {
[10:19:25.339]                 is_error <- inherits(cond, "error")
[10:19:25.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.339]                   NULL)
[10:19:25.339]                 if (is_error) {
[10:19:25.339]                   sessionInformation <- function() {
[10:19:25.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.339]                       search = base::search(), system = base::Sys.info())
[10:19:25.339]                   }
[10:19:25.339]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.339]                     cond$call), session = sessionInformation(), 
[10:19:25.339]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.339]                   signalCondition(cond)
[10:19:25.339]                 }
[10:19:25.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.339]                 "immediateCondition"))) {
[10:19:25.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.339]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.339]                   if (TRUE && !signal) {
[10:19:25.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.339]                     {
[10:19:25.339]                       inherits <- base::inherits
[10:19:25.339]                       invokeRestart <- base::invokeRestart
[10:19:25.339]                       is.null <- base::is.null
[10:19:25.339]                       muffled <- FALSE
[10:19:25.339]                       if (inherits(cond, "message")) {
[10:19:25.339]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.339]                         if (muffled) 
[10:19:25.339]                           invokeRestart("muffleMessage")
[10:19:25.339]                       }
[10:19:25.339]                       else if (inherits(cond, "warning")) {
[10:19:25.339]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.339]                         if (muffled) 
[10:19:25.339]                           invokeRestart("muffleWarning")
[10:19:25.339]                       }
[10:19:25.339]                       else if (inherits(cond, "condition")) {
[10:19:25.339]                         if (!is.null(pattern)) {
[10:19:25.339]                           computeRestarts <- base::computeRestarts
[10:19:25.339]                           grepl <- base::grepl
[10:19:25.339]                           restarts <- computeRestarts(cond)
[10:19:25.339]                           for (restart in restarts) {
[10:19:25.339]                             name <- restart$name
[10:19:25.339]                             if (is.null(name)) 
[10:19:25.339]                               next
[10:19:25.339]                             if (!grepl(pattern, name)) 
[10:19:25.339]                               next
[10:19:25.339]                             invokeRestart(restart)
[10:19:25.339]                             muffled <- TRUE
[10:19:25.339]                             break
[10:19:25.339]                           }
[10:19:25.339]                         }
[10:19:25.339]                       }
[10:19:25.339]                       invisible(muffled)
[10:19:25.339]                     }
[10:19:25.339]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.339]                   }
[10:19:25.339]                 }
[10:19:25.339]                 else {
[10:19:25.339]                   if (TRUE) {
[10:19:25.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.339]                     {
[10:19:25.339]                       inherits <- base::inherits
[10:19:25.339]                       invokeRestart <- base::invokeRestart
[10:19:25.339]                       is.null <- base::is.null
[10:19:25.339]                       muffled <- FALSE
[10:19:25.339]                       if (inherits(cond, "message")) {
[10:19:25.339]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.339]                         if (muffled) 
[10:19:25.339]                           invokeRestart("muffleMessage")
[10:19:25.339]                       }
[10:19:25.339]                       else if (inherits(cond, "warning")) {
[10:19:25.339]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.339]                         if (muffled) 
[10:19:25.339]                           invokeRestart("muffleWarning")
[10:19:25.339]                       }
[10:19:25.339]                       else if (inherits(cond, "condition")) {
[10:19:25.339]                         if (!is.null(pattern)) {
[10:19:25.339]                           computeRestarts <- base::computeRestarts
[10:19:25.339]                           grepl <- base::grepl
[10:19:25.339]                           restarts <- computeRestarts(cond)
[10:19:25.339]                           for (restart in restarts) {
[10:19:25.339]                             name <- restart$name
[10:19:25.339]                             if (is.null(name)) 
[10:19:25.339]                               next
[10:19:25.339]                             if (!grepl(pattern, name)) 
[10:19:25.339]                               next
[10:19:25.339]                             invokeRestart(restart)
[10:19:25.339]                             muffled <- TRUE
[10:19:25.339]                             break
[10:19:25.339]                           }
[10:19:25.339]                         }
[10:19:25.339]                       }
[10:19:25.339]                       invisible(muffled)
[10:19:25.339]                     }
[10:19:25.339]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.339]                   }
[10:19:25.339]                 }
[10:19:25.339]             }
[10:19:25.339]         }))
[10:19:25.339]     }, error = function(ex) {
[10:19:25.339]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.339]                 ...future.rng), started = ...future.startTime, 
[10:19:25.339]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.339]             version = "1.8"), class = "FutureResult")
[10:19:25.339]     }, finally = {
[10:19:25.339]         if (!identical(...future.workdir, getwd())) 
[10:19:25.339]             setwd(...future.workdir)
[10:19:25.339]         {
[10:19:25.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.339]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.339]             }
[10:19:25.339]             base::options(...future.oldOptions)
[10:19:25.339]             if (.Platform$OS.type == "windows") {
[10:19:25.339]                 old_names <- names(...future.oldEnvVars)
[10:19:25.339]                 envs <- base::Sys.getenv()
[10:19:25.339]                 names <- names(envs)
[10:19:25.339]                 common <- intersect(names, old_names)
[10:19:25.339]                 added <- setdiff(names, old_names)
[10:19:25.339]                 removed <- setdiff(old_names, names)
[10:19:25.339]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.339]                   envs[common]]
[10:19:25.339]                 NAMES <- toupper(changed)
[10:19:25.339]                 args <- list()
[10:19:25.339]                 for (kk in seq_along(NAMES)) {
[10:19:25.339]                   name <- changed[[kk]]
[10:19:25.339]                   NAME <- NAMES[[kk]]
[10:19:25.339]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.339]                     next
[10:19:25.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.339]                 }
[10:19:25.339]                 NAMES <- toupper(added)
[10:19:25.339]                 for (kk in seq_along(NAMES)) {
[10:19:25.339]                   name <- added[[kk]]
[10:19:25.339]                   NAME <- NAMES[[kk]]
[10:19:25.339]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.339]                     next
[10:19:25.339]                   args[[name]] <- ""
[10:19:25.339]                 }
[10:19:25.339]                 NAMES <- toupper(removed)
[10:19:25.339]                 for (kk in seq_along(NAMES)) {
[10:19:25.339]                   name <- removed[[kk]]
[10:19:25.339]                   NAME <- NAMES[[kk]]
[10:19:25.339]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.339]                     next
[10:19:25.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.339]                 }
[10:19:25.339]                 if (length(args) > 0) 
[10:19:25.339]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.339]             }
[10:19:25.339]             else {
[10:19:25.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.339]             }
[10:19:25.339]             {
[10:19:25.339]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.339]                   0L) {
[10:19:25.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.339]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.339]                   base::options(opts)
[10:19:25.339]                 }
[10:19:25.339]                 {
[10:19:25.339]                   {
[10:19:25.339]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.339]                     NULL
[10:19:25.339]                   }
[10:19:25.339]                   options(future.plan = NULL)
[10:19:25.339]                   if (is.na(NA_character_)) 
[10:19:25.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.339]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.339]                     .init = FALSE)
[10:19:25.339]                 }
[10:19:25.339]             }
[10:19:25.339]         }
[10:19:25.339]     })
[10:19:25.339]     if (TRUE) {
[10:19:25.339]         base::sink(type = "output", split = FALSE)
[10:19:25.339]         if (TRUE) {
[10:19:25.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.339]         }
[10:19:25.339]         else {
[10:19:25.339]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.339]         }
[10:19:25.339]         base::close(...future.stdout)
[10:19:25.339]         ...future.stdout <- NULL
[10:19:25.339]     }
[10:19:25.339]     ...future.result$conditions <- ...future.conditions
[10:19:25.339]     ...future.result$finished <- base::Sys.time()
[10:19:25.339]     ...future.result
[10:19:25.339] }
[10:19:25.341] Poll #1 (0): usedNodes() = 2, workers = 2
[10:19:25.352] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.352] - Validating connection of MultisessionFuture
[10:19:25.352] - received message: FutureResult
[10:19:25.353] - Received FutureResult
[10:19:25.353] - Erased future from FutureRegistry
[10:19:25.353] result() for ClusterFuture ...
[10:19:25.353] - result already collected: FutureResult
[10:19:25.353] result() for ClusterFuture ... done
[10:19:25.353] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.353] result() for ClusterFuture ...
[10:19:25.353] - result already collected: FutureResult
[10:19:25.353] result() for ClusterFuture ... done
[10:19:25.353] result() for ClusterFuture ...
[10:19:25.353] - result already collected: FutureResult
[10:19:25.353] result() for ClusterFuture ... done
[10:19:25.354] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[10:19:25.354] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:19:25.355] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:19:25.355] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:25.355] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.355] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ...
[10:19:25.356] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ... DONE
[10:19:25.356] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:25.356] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.356] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:25.357] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.357] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[10:19:25.357] MultisessionFuture started
[10:19:25.357] - Launch lazy future ... done
[10:19:25.357] run() for ‘MultisessionFuture’ ... done
[10:19:25.358] Created future:
[10:19:25.358] MultisessionFuture:
[10:19:25.358] Label: ‘future_mapply-5’
[10:19:25.358] Expression:
[10:19:25.358] {
[10:19:25.358]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.358]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.358]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.358]         on.exit(options(oopts), add = TRUE)
[10:19:25.358]     }
[10:19:25.358]     {
[10:19:25.358]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.358]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.358]         do.call(mapply, args = args)
[10:19:25.358]     }
[10:19:25.358] }
[10:19:25.358] Lazy evaluation: FALSE
[10:19:25.358] Asynchronous evaluation: TRUE
[10:19:25.358] Local evaluation: TRUE
[10:19:25.358] Environment: R_GlobalEnv
[10:19:25.358] Capture standard output: TRUE
[10:19:25.358] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.358] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.358] Packages: <none>
[10:19:25.358] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.358] Resolved: FALSE
[10:19:25.358] Value: <not collected>
[10:19:25.358] Conditions captured: <none>
[10:19:25.358] Early signaling: FALSE
[10:19:25.358] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.358] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.369] Chunk #5 of 5 ... DONE
[10:19:25.369] Launching 5 futures (chunks) ... DONE
[10:19:25.369] Resolving 5 futures (chunks) ...
[10:19:25.369] resolve() on list ...
[10:19:25.369]  recursive: 0
[10:19:25.370]  length: 5
[10:19:25.370] 
[10:19:25.370] Future #1
[10:19:25.370] result() for ClusterFuture ...
[10:19:25.370] - result already collected: FutureResult
[10:19:25.370] result() for ClusterFuture ... done
[10:19:25.370] result() for ClusterFuture ...
[10:19:25.370] - result already collected: FutureResult
[10:19:25.370] result() for ClusterFuture ... done
[10:19:25.370] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:25.370] - nx: 5
[10:19:25.370] - relay: TRUE
[10:19:25.371] - stdout: TRUE
[10:19:25.371] - signal: TRUE
[10:19:25.371] - resignal: FALSE
[10:19:25.371] - force: TRUE
[10:19:25.371] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:19:25.371] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[10:19:25.371]  - until=1
[10:19:25.371]  - relaying element #1
[10:19:25.371] result() for ClusterFuture ...
[10:19:25.371] - result already collected: FutureResult
[10:19:25.371] result() for ClusterFuture ... done
[10:19:25.371] result() for ClusterFuture ...
[10:19:25.372] - result already collected: FutureResult
[10:19:25.372] result() for ClusterFuture ... done
[10:19:25.372] result() for ClusterFuture ...
[10:19:25.372] - result already collected: FutureResult
[10:19:25.372] result() for ClusterFuture ... done
[10:19:25.372] result() for ClusterFuture ...
[10:19:25.372] - result already collected: FutureResult
[10:19:25.372] result() for ClusterFuture ... done
[10:19:25.372] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:25.372] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:25.372] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:25.372]  length: 4 (resolved future 1)
[10:19:25.373] Future #2
[10:19:25.373] result() for ClusterFuture ...
[10:19:25.373] - result already collected: FutureResult
[10:19:25.373] result() for ClusterFuture ... done
[10:19:25.373] result() for ClusterFuture ...
[10:19:25.373] - result already collected: FutureResult
[10:19:25.373] result() for ClusterFuture ... done
[10:19:25.373] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:25.373] - nx: 5
[10:19:25.373] - relay: TRUE
[10:19:25.373] - stdout: TRUE
[10:19:25.373] - signal: TRUE
[10:19:25.374] - resignal: FALSE
[10:19:25.374] - force: TRUE
[10:19:25.374] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:25.374] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[10:19:25.374]  - until=2
[10:19:25.374]  - relaying element #2
[10:19:25.374] result() for ClusterFuture ...
[10:19:25.374] - result already collected: FutureResult
[10:19:25.374] result() for ClusterFuture ... done
[10:19:25.374] result() for ClusterFuture ...
[10:19:25.374] - result already collected: FutureResult
[10:19:25.374] result() for ClusterFuture ... done
[10:19:25.374] result() for ClusterFuture ...
[10:19:25.375] - result already collected: FutureResult
[10:19:25.375] result() for ClusterFuture ... done
[10:19:25.375] result() for ClusterFuture ...
[10:19:25.375] - result already collected: FutureResult
[10:19:25.375] result() for ClusterFuture ... done
[10:19:25.375] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:25.375] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:25.375] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:25.375]  length: 3 (resolved future 2)
[10:19:25.375] Future #3
[10:19:25.375] result() for ClusterFuture ...
[10:19:25.375] - result already collected: FutureResult
[10:19:25.376] result() for ClusterFuture ... done
[10:19:25.376] result() for ClusterFuture ...
[10:19:25.376] - result already collected: FutureResult
[10:19:25.376] result() for ClusterFuture ... done
[10:19:25.376] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:19:25.376] - nx: 5
[10:19:25.376] - relay: TRUE
[10:19:25.376] - stdout: TRUE
[10:19:25.376] - signal: TRUE
[10:19:25.376] - resignal: FALSE
[10:19:25.376] - force: TRUE
[10:19:25.376] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:25.376] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[10:19:25.377]  - until=3
[10:19:25.377]  - relaying element #3
[10:19:25.377] result() for ClusterFuture ...
[10:19:25.377] - result already collected: FutureResult
[10:19:25.377] result() for ClusterFuture ... done
[10:19:25.377] result() for ClusterFuture ...
[10:19:25.377] - result already collected: FutureResult
[10:19:25.377] result() for ClusterFuture ... done
[10:19:25.377] result() for ClusterFuture ...
[10:19:25.377] - result already collected: FutureResult
[10:19:25.377] result() for ClusterFuture ... done
[10:19:25.377] result() for ClusterFuture ...
[10:19:25.378] - result already collected: FutureResult
[10:19:25.378] result() for ClusterFuture ... done
[10:19:25.378] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:25.378] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:25.378] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:19:25.378]  length: 2 (resolved future 3)
[10:19:25.378] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.379] - Validating connection of MultisessionFuture
[10:19:25.379] - received message: FutureResult
[10:19:25.379] - Received FutureResult
[10:19:25.379] - Erased future from FutureRegistry
[10:19:25.379] result() for ClusterFuture ...
[10:19:25.379] - result already collected: FutureResult
[10:19:25.379] result() for ClusterFuture ... done
[10:19:25.379] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.379] Future #4
[10:19:25.379] result() for ClusterFuture ...
[10:19:25.379] - result already collected: FutureResult
[10:19:25.380] result() for ClusterFuture ... done
[10:19:25.380] result() for ClusterFuture ...
[10:19:25.380] - result already collected: FutureResult
[10:19:25.380] result() for ClusterFuture ... done
[10:19:25.380] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:19:25.380] - nx: 5
[10:19:25.380] - relay: TRUE
[10:19:25.380] - stdout: TRUE
[10:19:25.380] - signal: TRUE
[10:19:25.380] - resignal: FALSE
[10:19:25.380] - force: TRUE
[10:19:25.380] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:25.380] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[10:19:25.381]  - until=4
[10:19:25.381]  - relaying element #4
[10:19:25.381] result() for ClusterFuture ...
[10:19:25.381] - result already collected: FutureResult
[10:19:25.381] result() for ClusterFuture ... done
[10:19:25.381] result() for ClusterFuture ...
[10:19:25.381] - result already collected: FutureResult
[10:19:25.381] result() for ClusterFuture ... done
[10:19:25.381] result() for ClusterFuture ...
[10:19:25.381] - result already collected: FutureResult
[10:19:25.381] result() for ClusterFuture ... done
[10:19:25.382] result() for ClusterFuture ...
[10:19:25.382] - result already collected: FutureResult
[10:19:25.382] result() for ClusterFuture ... done
[10:19:25.382] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:25.382] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:25.382] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:19:25.382]  length: 1 (resolved future 4)
[10:19:25.403] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.403] - Validating connection of MultisessionFuture
[10:19:25.403] - received message: FutureResult
[10:19:25.404] - Received FutureResult
[10:19:25.404] - Erased future from FutureRegistry
[10:19:25.404] result() for ClusterFuture ...
[10:19:25.404] - result already collected: FutureResult
[10:19:25.404] result() for ClusterFuture ... done
[10:19:25.404] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.404] Future #5
[10:19:25.404] result() for ClusterFuture ...
[10:19:25.404] - result already collected: FutureResult
[10:19:25.404] result() for ClusterFuture ... done
[10:19:25.404] result() for ClusterFuture ...
[10:19:25.405] - result already collected: FutureResult
[10:19:25.405] result() for ClusterFuture ... done
[10:19:25.405] signalConditionsASAP(MultisessionFuture, pos=5) ...
[10:19:25.405] - nx: 5
[10:19:25.405] - relay: TRUE
[10:19:25.405] - stdout: TRUE
[10:19:25.405] - signal: TRUE
[10:19:25.405] - resignal: FALSE
[10:19:25.405] - force: TRUE
[10:19:25.405] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:25.405] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[10:19:25.405]  - until=5
[10:19:25.406]  - relaying element #5
[10:19:25.406] result() for ClusterFuture ...
[10:19:25.406] - result already collected: FutureResult
[10:19:25.406] result() for ClusterFuture ... done
[10:19:25.406] result() for ClusterFuture ...
[10:19:25.406] - result already collected: FutureResult
[10:19:25.406] result() for ClusterFuture ... done
[10:19:25.406] result() for ClusterFuture ...
[10:19:25.406] - result already collected: FutureResult
[10:19:25.406] result() for ClusterFuture ... done
[10:19:25.406] result() for ClusterFuture ...
[10:19:25.407] - result already collected: FutureResult
[10:19:25.407] result() for ClusterFuture ... done
[10:19:25.407] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:25.407] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:25.407] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[10:19:25.407]  length: 0 (resolved future 5)
[10:19:25.407] Relaying remaining futures
[10:19:25.407] signalConditionsASAP(NULL, pos=0) ...
[10:19:25.407] - nx: 5
[10:19:25.407] - relay: TRUE
[10:19:25.407] - stdout: TRUE
[10:19:25.407] - signal: TRUE
[10:19:25.407] - resignal: FALSE
[10:19:25.408] - force: TRUE
[10:19:25.408] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:25.408] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[10:19:25.408] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:25.408] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[10:19:25.408] signalConditionsASAP(NULL, pos=0) ... done
[10:19:25.408] resolve() on list ... DONE
[10:19:25.408] result() for ClusterFuture ...
[10:19:25.408] - result already collected: FutureResult
[10:19:25.408] result() for ClusterFuture ... done
[10:19:25.408] result() for ClusterFuture ...
[10:19:25.408] - result already collected: FutureResult
[10:19:25.409] result() for ClusterFuture ... done
[10:19:25.409] result() for ClusterFuture ...
[10:19:25.409] - result already collected: FutureResult
[10:19:25.409] result() for ClusterFuture ... done
[10:19:25.409] result() for ClusterFuture ...
[10:19:25.409] - result already collected: FutureResult
[10:19:25.409] result() for ClusterFuture ... done
[10:19:25.409] result() for ClusterFuture ...
[10:19:25.409] - result already collected: FutureResult
[10:19:25.409] result() for ClusterFuture ... done
[10:19:25.409] result() for ClusterFuture ...
[10:19:25.410] - result already collected: FutureResult
[10:19:25.410] result() for ClusterFuture ... done
[10:19:25.410] result() for ClusterFuture ...
[10:19:25.410] - result already collected: FutureResult
[10:19:25.410] result() for ClusterFuture ... done
[10:19:25.410] result() for ClusterFuture ...
[10:19:25.410] - result already collected: FutureResult
[10:19:25.410] result() for ClusterFuture ... done
[10:19:25.410] result() for ClusterFuture ...
[10:19:25.410] - result already collected: FutureResult
[10:19:25.410] result() for ClusterFuture ... done
[10:19:25.410] result() for ClusterFuture ...
[10:19:25.411] - result already collected: FutureResult
[10:19:25.411] result() for ClusterFuture ... done
[10:19:25.411]  - Number of value chunks collected: 5
[10:19:25.411] Resolving 5 futures (chunks) ... DONE
[10:19:25.411] Reducing values from 5 chunks ...
[10:19:25.411]  - Number of values collected after concatenation: 5
[10:19:25.411]  - Number of values expected: 5
[10:19:25.411] Reducing values from 5 chunks ... DONE
[10:19:25.411] future_mapply() ... DONE
[10:19:25.411] future_mapply() ...
[10:19:25.413] Number of chunks: 2
[10:19:25.413] getGlobalsAndPackagesXApply() ...
[10:19:25.413]  - future.globals: TRUE
[10:19:25.413] getGlobalsAndPackages() ...
[10:19:25.414] Searching for globals...
[10:19:25.415] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:25.415] Searching for globals ... DONE
[10:19:25.415] Resolving globals: FALSE
[10:19:25.415] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:25.416] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:25.416] - globals: [1] ‘FUN’
[10:19:25.416] 
[10:19:25.416] getGlobalsAndPackages() ... DONE
[10:19:25.416]  - globals found/used: [n=1] ‘FUN’
[10:19:25.416]  - needed namespaces: [n=0] 
[10:19:25.416] Finding globals ... DONE
[10:19:25.417] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:25.417] List of 2
[10:19:25.417]  $ ...future.FUN:function (C, k)  
[10:19:25.417]  $ MoreArgs     : list()
[10:19:25.417]  - attr(*, "where")=List of 2
[10:19:25.417]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:25.417]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:25.417]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:25.417]  - attr(*, "resolved")= logi FALSE
[10:19:25.417]  - attr(*, "total_size")= num NA
[10:19:25.419] Packages to be attached in all futures: [n=0] 
[10:19:25.419] getGlobalsAndPackagesXApply() ... DONE
[10:19:25.419] Number of futures (= number of chunks): 2
[10:19:25.420] Launching 2 futures (chunks) ...
[10:19:25.420] Chunk #1 of 2 ...
[10:19:25.420]  - Finding globals in '...' for chunk #1 ...
[10:19:25.420] getGlobalsAndPackages() ...
[10:19:25.420] Searching for globals...
[10:19:25.420] 
[10:19:25.420] Searching for globals ... DONE
[10:19:25.420] - globals: [0] <none>
[10:19:25.420] getGlobalsAndPackages() ... DONE
[10:19:25.421]    + additional globals found: [n=0] 
[10:19:25.421]    + additional namespaces needed: [n=0] 
[10:19:25.421]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:25.421]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:25.421]  - seeds: <none>
[10:19:25.421]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.421] getGlobalsAndPackages() ...
[10:19:25.421] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.421] Resolving globals: FALSE
[10:19:25.422] The total size of the 5 globals is 880 bytes (880 bytes)
[10:19:25.422] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:25.422] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.422] 
[10:19:25.423] getGlobalsAndPackages() ... DONE
[10:19:25.423] run() for ‘Future’ ...
[10:19:25.423] - state: ‘created’
[10:19:25.423] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.437] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.437]   - Field: ‘node’
[10:19:25.437]   - Field: ‘label’
[10:19:25.437]   - Field: ‘local’
[10:19:25.437]   - Field: ‘owner’
[10:19:25.437]   - Field: ‘envir’
[10:19:25.437]   - Field: ‘workers’
[10:19:25.438]   - Field: ‘packages’
[10:19:25.438]   - Field: ‘gc’
[10:19:25.438]   - Field: ‘conditions’
[10:19:25.438]   - Field: ‘persistent’
[10:19:25.438]   - Field: ‘expr’
[10:19:25.438]   - Field: ‘uuid’
[10:19:25.438]   - Field: ‘seed’
[10:19:25.438]   - Field: ‘version’
[10:19:25.438]   - Field: ‘result’
[10:19:25.438]   - Field: ‘asynchronous’
[10:19:25.438]   - Field: ‘calls’
[10:19:25.439]   - Field: ‘globals’
[10:19:25.439]   - Field: ‘stdout’
[10:19:25.439]   - Field: ‘earlySignal’
[10:19:25.439]   - Field: ‘lazy’
[10:19:25.439]   - Field: ‘state’
[10:19:25.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.439] - Launch lazy future ...
[10:19:25.439] Packages needed by the future expression (n = 0): <none>
[10:19:25.439] Packages needed by future strategies (n = 0): <none>
[10:19:25.440] {
[10:19:25.440]     {
[10:19:25.440]         {
[10:19:25.440]             ...future.startTime <- base::Sys.time()
[10:19:25.440]             {
[10:19:25.440]                 {
[10:19:25.440]                   {
[10:19:25.440]                     {
[10:19:25.440]                       base::local({
[10:19:25.440]                         has_future <- base::requireNamespace("future", 
[10:19:25.440]                           quietly = TRUE)
[10:19:25.440]                         if (has_future) {
[10:19:25.440]                           ns <- base::getNamespace("future")
[10:19:25.440]                           version <- ns[[".package"]][["version"]]
[10:19:25.440]                           if (is.null(version)) 
[10:19:25.440]                             version <- utils::packageVersion("future")
[10:19:25.440]                         }
[10:19:25.440]                         else {
[10:19:25.440]                           version <- NULL
[10:19:25.440]                         }
[10:19:25.440]                         if (!has_future || version < "1.8.0") {
[10:19:25.440]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.440]                             "", base::R.version$version.string), 
[10:19:25.440]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.440]                               "release", "version")], collapse = " "), 
[10:19:25.440]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.440]                             info)
[10:19:25.440]                           info <- base::paste(info, collapse = "; ")
[10:19:25.440]                           if (!has_future) {
[10:19:25.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.440]                               info)
[10:19:25.440]                           }
[10:19:25.440]                           else {
[10:19:25.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.440]                               info, version)
[10:19:25.440]                           }
[10:19:25.440]                           base::stop(msg)
[10:19:25.440]                         }
[10:19:25.440]                       })
[10:19:25.440]                     }
[10:19:25.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.440]                     base::options(mc.cores = 1L)
[10:19:25.440]                   }
[10:19:25.440]                   ...future.strategy.old <- future::plan("list")
[10:19:25.440]                   options(future.plan = NULL)
[10:19:25.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.440]                 }
[10:19:25.440]                 ...future.workdir <- getwd()
[10:19:25.440]             }
[10:19:25.440]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.440]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.440]         }
[10:19:25.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.440]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:25.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.440]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.440]             base::names(...future.oldOptions))
[10:19:25.440]     }
[10:19:25.440]     if (FALSE) {
[10:19:25.440]     }
[10:19:25.440]     else {
[10:19:25.440]         if (TRUE) {
[10:19:25.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.440]                 open = "w")
[10:19:25.440]         }
[10:19:25.440]         else {
[10:19:25.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.440]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.440]         }
[10:19:25.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.440]             base::sink(type = "output", split = FALSE)
[10:19:25.440]             base::close(...future.stdout)
[10:19:25.440]         }, add = TRUE)
[10:19:25.440]     }
[10:19:25.440]     ...future.frame <- base::sys.nframe()
[10:19:25.440]     ...future.conditions <- base::list()
[10:19:25.440]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.440]     if (FALSE) {
[10:19:25.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.440]     }
[10:19:25.440]     ...future.result <- base::tryCatch({
[10:19:25.440]         base::withCallingHandlers({
[10:19:25.440]             ...future.value <- base::withVisible(base::local({
[10:19:25.440]                 ...future.makeSendCondition <- base::local({
[10:19:25.440]                   sendCondition <- NULL
[10:19:25.440]                   function(frame = 1L) {
[10:19:25.440]                     if (is.function(sendCondition)) 
[10:19:25.440]                       return(sendCondition)
[10:19:25.440]                     ns <- getNamespace("parallel")
[10:19:25.440]                     if (exists("sendData", mode = "function", 
[10:19:25.440]                       envir = ns)) {
[10:19:25.440]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.440]                         envir = ns)
[10:19:25.440]                       envir <- sys.frame(frame)
[10:19:25.440]                       master <- NULL
[10:19:25.440]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.440]                         !identical(envir, emptyenv())) {
[10:19:25.440]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.440]                           inherits = FALSE)) {
[10:19:25.440]                           master <- get("master", mode = "list", 
[10:19:25.440]                             envir = envir, inherits = FALSE)
[10:19:25.440]                           if (inherits(master, c("SOCKnode", 
[10:19:25.440]                             "SOCK0node"))) {
[10:19:25.440]                             sendCondition <<- function(cond) {
[10:19:25.440]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.440]                                 success = TRUE)
[10:19:25.440]                               parallel_sendData(master, data)
[10:19:25.440]                             }
[10:19:25.440]                             return(sendCondition)
[10:19:25.440]                           }
[10:19:25.440]                         }
[10:19:25.440]                         frame <- frame + 1L
[10:19:25.440]                         envir <- sys.frame(frame)
[10:19:25.440]                       }
[10:19:25.440]                     }
[10:19:25.440]                     sendCondition <<- function(cond) NULL
[10:19:25.440]                   }
[10:19:25.440]                 })
[10:19:25.440]                 withCallingHandlers({
[10:19:25.440]                   {
[10:19:25.440]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.440]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.440]                       ...future.globals.maxSize)) {
[10:19:25.440]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.440]                       on.exit(options(oopts), add = TRUE)
[10:19:25.440]                     }
[10:19:25.440]                     {
[10:19:25.440]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.440]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.440]                         USE.NAMES = FALSE)
[10:19:25.440]                       do.call(mapply, args = args)
[10:19:25.440]                     }
[10:19:25.440]                   }
[10:19:25.440]                 }, immediateCondition = function(cond) {
[10:19:25.440]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.440]                   sendCondition(cond)
[10:19:25.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.440]                   {
[10:19:25.440]                     inherits <- base::inherits
[10:19:25.440]                     invokeRestart <- base::invokeRestart
[10:19:25.440]                     is.null <- base::is.null
[10:19:25.440]                     muffled <- FALSE
[10:19:25.440]                     if (inherits(cond, "message")) {
[10:19:25.440]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.440]                       if (muffled) 
[10:19:25.440]                         invokeRestart("muffleMessage")
[10:19:25.440]                     }
[10:19:25.440]                     else if (inherits(cond, "warning")) {
[10:19:25.440]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.440]                       if (muffled) 
[10:19:25.440]                         invokeRestart("muffleWarning")
[10:19:25.440]                     }
[10:19:25.440]                     else if (inherits(cond, "condition")) {
[10:19:25.440]                       if (!is.null(pattern)) {
[10:19:25.440]                         computeRestarts <- base::computeRestarts
[10:19:25.440]                         grepl <- base::grepl
[10:19:25.440]                         restarts <- computeRestarts(cond)
[10:19:25.440]                         for (restart in restarts) {
[10:19:25.440]                           name <- restart$name
[10:19:25.440]                           if (is.null(name)) 
[10:19:25.440]                             next
[10:19:25.440]                           if (!grepl(pattern, name)) 
[10:19:25.440]                             next
[10:19:25.440]                           invokeRestart(restart)
[10:19:25.440]                           muffled <- TRUE
[10:19:25.440]                           break
[10:19:25.440]                         }
[10:19:25.440]                       }
[10:19:25.440]                     }
[10:19:25.440]                     invisible(muffled)
[10:19:25.440]                   }
[10:19:25.440]                   muffleCondition(cond)
[10:19:25.440]                 })
[10:19:25.440]             }))
[10:19:25.440]             future::FutureResult(value = ...future.value$value, 
[10:19:25.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.440]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.440]                     ...future.globalenv.names))
[10:19:25.440]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.440]         }, condition = base::local({
[10:19:25.440]             c <- base::c
[10:19:25.440]             inherits <- base::inherits
[10:19:25.440]             invokeRestart <- base::invokeRestart
[10:19:25.440]             length <- base::length
[10:19:25.440]             list <- base::list
[10:19:25.440]             seq.int <- base::seq.int
[10:19:25.440]             signalCondition <- base::signalCondition
[10:19:25.440]             sys.calls <- base::sys.calls
[10:19:25.440]             `[[` <- base::`[[`
[10:19:25.440]             `+` <- base::`+`
[10:19:25.440]             `<<-` <- base::`<<-`
[10:19:25.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.440]                   3L)]
[10:19:25.440]             }
[10:19:25.440]             function(cond) {
[10:19:25.440]                 is_error <- inherits(cond, "error")
[10:19:25.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.440]                   NULL)
[10:19:25.440]                 if (is_error) {
[10:19:25.440]                   sessionInformation <- function() {
[10:19:25.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.440]                       search = base::search(), system = base::Sys.info())
[10:19:25.440]                   }
[10:19:25.440]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.440]                     cond$call), session = sessionInformation(), 
[10:19:25.440]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.440]                   signalCondition(cond)
[10:19:25.440]                 }
[10:19:25.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.440]                 "immediateCondition"))) {
[10:19:25.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.440]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.440]                   if (TRUE && !signal) {
[10:19:25.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.440]                     {
[10:19:25.440]                       inherits <- base::inherits
[10:19:25.440]                       invokeRestart <- base::invokeRestart
[10:19:25.440]                       is.null <- base::is.null
[10:19:25.440]                       muffled <- FALSE
[10:19:25.440]                       if (inherits(cond, "message")) {
[10:19:25.440]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.440]                         if (muffled) 
[10:19:25.440]                           invokeRestart("muffleMessage")
[10:19:25.440]                       }
[10:19:25.440]                       else if (inherits(cond, "warning")) {
[10:19:25.440]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.440]                         if (muffled) 
[10:19:25.440]                           invokeRestart("muffleWarning")
[10:19:25.440]                       }
[10:19:25.440]                       else if (inherits(cond, "condition")) {
[10:19:25.440]                         if (!is.null(pattern)) {
[10:19:25.440]                           computeRestarts <- base::computeRestarts
[10:19:25.440]                           grepl <- base::grepl
[10:19:25.440]                           restarts <- computeRestarts(cond)
[10:19:25.440]                           for (restart in restarts) {
[10:19:25.440]                             name <- restart$name
[10:19:25.440]                             if (is.null(name)) 
[10:19:25.440]                               next
[10:19:25.440]                             if (!grepl(pattern, name)) 
[10:19:25.440]                               next
[10:19:25.440]                             invokeRestart(restart)
[10:19:25.440]                             muffled <- TRUE
[10:19:25.440]                             break
[10:19:25.440]                           }
[10:19:25.440]                         }
[10:19:25.440]                       }
[10:19:25.440]                       invisible(muffled)
[10:19:25.440]                     }
[10:19:25.440]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.440]                   }
[10:19:25.440]                 }
[10:19:25.440]                 else {
[10:19:25.440]                   if (TRUE) {
[10:19:25.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.440]                     {
[10:19:25.440]                       inherits <- base::inherits
[10:19:25.440]                       invokeRestart <- base::invokeRestart
[10:19:25.440]                       is.null <- base::is.null
[10:19:25.440]                       muffled <- FALSE
[10:19:25.440]                       if (inherits(cond, "message")) {
[10:19:25.440]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.440]                         if (muffled) 
[10:19:25.440]                           invokeRestart("muffleMessage")
[10:19:25.440]                       }
[10:19:25.440]                       else if (inherits(cond, "warning")) {
[10:19:25.440]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.440]                         if (muffled) 
[10:19:25.440]                           invokeRestart("muffleWarning")
[10:19:25.440]                       }
[10:19:25.440]                       else if (inherits(cond, "condition")) {
[10:19:25.440]                         if (!is.null(pattern)) {
[10:19:25.440]                           computeRestarts <- base::computeRestarts
[10:19:25.440]                           grepl <- base::grepl
[10:19:25.440]                           restarts <- computeRestarts(cond)
[10:19:25.440]                           for (restart in restarts) {
[10:19:25.440]                             name <- restart$name
[10:19:25.440]                             if (is.null(name)) 
[10:19:25.440]                               next
[10:19:25.440]                             if (!grepl(pattern, name)) 
[10:19:25.440]                               next
[10:19:25.440]                             invokeRestart(restart)
[10:19:25.440]                             muffled <- TRUE
[10:19:25.440]                             break
[10:19:25.440]                           }
[10:19:25.440]                         }
[10:19:25.440]                       }
[10:19:25.440]                       invisible(muffled)
[10:19:25.440]                     }
[10:19:25.440]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.440]                   }
[10:19:25.440]                 }
[10:19:25.440]             }
[10:19:25.440]         }))
[10:19:25.440]     }, error = function(ex) {
[10:19:25.440]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.440]                 ...future.rng), started = ...future.startTime, 
[10:19:25.440]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.440]             version = "1.8"), class = "FutureResult")
[10:19:25.440]     }, finally = {
[10:19:25.440]         if (!identical(...future.workdir, getwd())) 
[10:19:25.440]             setwd(...future.workdir)
[10:19:25.440]         {
[10:19:25.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.440]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.440]             }
[10:19:25.440]             base::options(...future.oldOptions)
[10:19:25.440]             if (.Platform$OS.type == "windows") {
[10:19:25.440]                 old_names <- names(...future.oldEnvVars)
[10:19:25.440]                 envs <- base::Sys.getenv()
[10:19:25.440]                 names <- names(envs)
[10:19:25.440]                 common <- intersect(names, old_names)
[10:19:25.440]                 added <- setdiff(names, old_names)
[10:19:25.440]                 removed <- setdiff(old_names, names)
[10:19:25.440]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.440]                   envs[common]]
[10:19:25.440]                 NAMES <- toupper(changed)
[10:19:25.440]                 args <- list()
[10:19:25.440]                 for (kk in seq_along(NAMES)) {
[10:19:25.440]                   name <- changed[[kk]]
[10:19:25.440]                   NAME <- NAMES[[kk]]
[10:19:25.440]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.440]                     next
[10:19:25.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.440]                 }
[10:19:25.440]                 NAMES <- toupper(added)
[10:19:25.440]                 for (kk in seq_along(NAMES)) {
[10:19:25.440]                   name <- added[[kk]]
[10:19:25.440]                   NAME <- NAMES[[kk]]
[10:19:25.440]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.440]                     next
[10:19:25.440]                   args[[name]] <- ""
[10:19:25.440]                 }
[10:19:25.440]                 NAMES <- toupper(removed)
[10:19:25.440]                 for (kk in seq_along(NAMES)) {
[10:19:25.440]                   name <- removed[[kk]]
[10:19:25.440]                   NAME <- NAMES[[kk]]
[10:19:25.440]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.440]                     next
[10:19:25.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.440]                 }
[10:19:25.440]                 if (length(args) > 0) 
[10:19:25.440]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.440]             }
[10:19:25.440]             else {
[10:19:25.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.440]             }
[10:19:25.440]             {
[10:19:25.440]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.440]                   0L) {
[10:19:25.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.440]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.440]                   base::options(opts)
[10:19:25.440]                 }
[10:19:25.440]                 {
[10:19:25.440]                   {
[10:19:25.440]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.440]                     NULL
[10:19:25.440]                   }
[10:19:25.440]                   options(future.plan = NULL)
[10:19:25.440]                   if (is.na(NA_character_)) 
[10:19:25.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.440]                     .init = FALSE)
[10:19:25.440]                 }
[10:19:25.440]             }
[10:19:25.440]         }
[10:19:25.440]     })
[10:19:25.440]     if (TRUE) {
[10:19:25.440]         base::sink(type = "output", split = FALSE)
[10:19:25.440]         if (TRUE) {
[10:19:25.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.440]         }
[10:19:25.440]         else {
[10:19:25.440]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.440]         }
[10:19:25.440]         base::close(...future.stdout)
[10:19:25.440]         ...future.stdout <- NULL
[10:19:25.440]     }
[10:19:25.440]     ...future.result$conditions <- ...future.conditions
[10:19:25.440]     ...future.result$finished <- base::Sys.time()
[10:19:25.440]     ...future.result
[10:19:25.440] }
[10:19:25.443] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[10:19:25.443] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:19:25.443] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:19:25.443] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[10:19:25.444] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[10:19:25.444] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:19:25.444] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:19:25.444] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:25.445] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.445] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:25.445] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.445] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[10:19:25.446] MultisessionFuture started
[10:19:25.446] - Launch lazy future ... done
[10:19:25.446] run() for ‘MultisessionFuture’ ... done
[10:19:25.446] Created future:
[10:19:25.446] MultisessionFuture:
[10:19:25.446] Label: ‘future_.mapply-1’
[10:19:25.446] Expression:
[10:19:25.446] {
[10:19:25.446]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.446]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.446]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.446]         on.exit(options(oopts), add = TRUE)
[10:19:25.446]     }
[10:19:25.446]     {
[10:19:25.446]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.446]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.446]         do.call(mapply, args = args)
[10:19:25.446]     }
[10:19:25.446] }
[10:19:25.446] Lazy evaluation: FALSE
[10:19:25.446] Asynchronous evaluation: TRUE
[10:19:25.446] Local evaluation: TRUE
[10:19:25.446] Environment: R_GlobalEnv
[10:19:25.446] Capture standard output: TRUE
[10:19:25.446] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.446] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.446] Packages: <none>
[10:19:25.446] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.446] Resolved: FALSE
[10:19:25.446] Value: <not collected>
[10:19:25.446] Conditions captured: <none>
[10:19:25.446] Early signaling: FALSE
[10:19:25.446] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.446] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.457] Chunk #1 of 2 ... DONE
[10:19:25.458] Chunk #2 of 2 ...
[10:19:25.458]  - Finding globals in '...' for chunk #2 ...
[10:19:25.458] getGlobalsAndPackages() ...
[10:19:25.458] Searching for globals...
[10:19:25.458] 
[10:19:25.459] Searching for globals ... DONE
[10:19:25.459] - globals: [0] <none>
[10:19:25.459] getGlobalsAndPackages() ... DONE
[10:19:25.459]    + additional globals found: [n=0] 
[10:19:25.459]    + additional namespaces needed: [n=0] 
[10:19:25.459]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:25.459]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:25.459]  - seeds: <none>
[10:19:25.459]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.459] getGlobalsAndPackages() ...
[10:19:25.459] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.460] Resolving globals: FALSE
[10:19:25.460] The total size of the 5 globals is 909 bytes (909 bytes)
[10:19:25.460] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:25.461] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.461] 
[10:19:25.461] getGlobalsAndPackages() ... DONE
[10:19:25.461] run() for ‘Future’ ...
[10:19:25.461] - state: ‘created’
[10:19:25.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.476]   - Field: ‘node’
[10:19:25.476]   - Field: ‘label’
[10:19:25.476]   - Field: ‘local’
[10:19:25.476]   - Field: ‘owner’
[10:19:25.476]   - Field: ‘envir’
[10:19:25.476]   - Field: ‘workers’
[10:19:25.476]   - Field: ‘packages’
[10:19:25.476]   - Field: ‘gc’
[10:19:25.476]   - Field: ‘conditions’
[10:19:25.476]   - Field: ‘persistent’
[10:19:25.476]   - Field: ‘expr’
[10:19:25.477]   - Field: ‘uuid’
[10:19:25.477]   - Field: ‘seed’
[10:19:25.477]   - Field: ‘version’
[10:19:25.477]   - Field: ‘result’
[10:19:25.477]   - Field: ‘asynchronous’
[10:19:25.477]   - Field: ‘calls’
[10:19:25.477]   - Field: ‘globals’
[10:19:25.477]   - Field: ‘stdout’
[10:19:25.477]   - Field: ‘earlySignal’
[10:19:25.477]   - Field: ‘lazy’
[10:19:25.477]   - Field: ‘state’
[10:19:25.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.478] - Launch lazy future ...
[10:19:25.478] Packages needed by the future expression (n = 0): <none>
[10:19:25.478] Packages needed by future strategies (n = 0): <none>
[10:19:25.478] {
[10:19:25.478]     {
[10:19:25.478]         {
[10:19:25.478]             ...future.startTime <- base::Sys.time()
[10:19:25.478]             {
[10:19:25.478]                 {
[10:19:25.478]                   {
[10:19:25.478]                     {
[10:19:25.478]                       base::local({
[10:19:25.478]                         has_future <- base::requireNamespace("future", 
[10:19:25.478]                           quietly = TRUE)
[10:19:25.478]                         if (has_future) {
[10:19:25.478]                           ns <- base::getNamespace("future")
[10:19:25.478]                           version <- ns[[".package"]][["version"]]
[10:19:25.478]                           if (is.null(version)) 
[10:19:25.478]                             version <- utils::packageVersion("future")
[10:19:25.478]                         }
[10:19:25.478]                         else {
[10:19:25.478]                           version <- NULL
[10:19:25.478]                         }
[10:19:25.478]                         if (!has_future || version < "1.8.0") {
[10:19:25.478]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.478]                             "", base::R.version$version.string), 
[10:19:25.478]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.478]                               "release", "version")], collapse = " "), 
[10:19:25.478]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.478]                             info)
[10:19:25.478]                           info <- base::paste(info, collapse = "; ")
[10:19:25.478]                           if (!has_future) {
[10:19:25.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.478]                               info)
[10:19:25.478]                           }
[10:19:25.478]                           else {
[10:19:25.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.478]                               info, version)
[10:19:25.478]                           }
[10:19:25.478]                           base::stop(msg)
[10:19:25.478]                         }
[10:19:25.478]                       })
[10:19:25.478]                     }
[10:19:25.478]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.478]                     base::options(mc.cores = 1L)
[10:19:25.478]                   }
[10:19:25.478]                   ...future.strategy.old <- future::plan("list")
[10:19:25.478]                   options(future.plan = NULL)
[10:19:25.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.478]                 }
[10:19:25.478]                 ...future.workdir <- getwd()
[10:19:25.478]             }
[10:19:25.478]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.478]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.478]         }
[10:19:25.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.478]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:25.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.478]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.478]             base::names(...future.oldOptions))
[10:19:25.478]     }
[10:19:25.478]     if (FALSE) {
[10:19:25.478]     }
[10:19:25.478]     else {
[10:19:25.478]         if (TRUE) {
[10:19:25.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.478]                 open = "w")
[10:19:25.478]         }
[10:19:25.478]         else {
[10:19:25.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.478]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.478]         }
[10:19:25.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.478]             base::sink(type = "output", split = FALSE)
[10:19:25.478]             base::close(...future.stdout)
[10:19:25.478]         }, add = TRUE)
[10:19:25.478]     }
[10:19:25.478]     ...future.frame <- base::sys.nframe()
[10:19:25.478]     ...future.conditions <- base::list()
[10:19:25.478]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.478]     if (FALSE) {
[10:19:25.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.478]     }
[10:19:25.478]     ...future.result <- base::tryCatch({
[10:19:25.478]         base::withCallingHandlers({
[10:19:25.478]             ...future.value <- base::withVisible(base::local({
[10:19:25.478]                 ...future.makeSendCondition <- base::local({
[10:19:25.478]                   sendCondition <- NULL
[10:19:25.478]                   function(frame = 1L) {
[10:19:25.478]                     if (is.function(sendCondition)) 
[10:19:25.478]                       return(sendCondition)
[10:19:25.478]                     ns <- getNamespace("parallel")
[10:19:25.478]                     if (exists("sendData", mode = "function", 
[10:19:25.478]                       envir = ns)) {
[10:19:25.478]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.478]                         envir = ns)
[10:19:25.478]                       envir <- sys.frame(frame)
[10:19:25.478]                       master <- NULL
[10:19:25.478]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.478]                         !identical(envir, emptyenv())) {
[10:19:25.478]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.478]                           inherits = FALSE)) {
[10:19:25.478]                           master <- get("master", mode = "list", 
[10:19:25.478]                             envir = envir, inherits = FALSE)
[10:19:25.478]                           if (inherits(master, c("SOCKnode", 
[10:19:25.478]                             "SOCK0node"))) {
[10:19:25.478]                             sendCondition <<- function(cond) {
[10:19:25.478]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.478]                                 success = TRUE)
[10:19:25.478]                               parallel_sendData(master, data)
[10:19:25.478]                             }
[10:19:25.478]                             return(sendCondition)
[10:19:25.478]                           }
[10:19:25.478]                         }
[10:19:25.478]                         frame <- frame + 1L
[10:19:25.478]                         envir <- sys.frame(frame)
[10:19:25.478]                       }
[10:19:25.478]                     }
[10:19:25.478]                     sendCondition <<- function(cond) NULL
[10:19:25.478]                   }
[10:19:25.478]                 })
[10:19:25.478]                 withCallingHandlers({
[10:19:25.478]                   {
[10:19:25.478]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.478]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.478]                       ...future.globals.maxSize)) {
[10:19:25.478]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.478]                       on.exit(options(oopts), add = TRUE)
[10:19:25.478]                     }
[10:19:25.478]                     {
[10:19:25.478]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.478]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.478]                         USE.NAMES = FALSE)
[10:19:25.478]                       do.call(mapply, args = args)
[10:19:25.478]                     }
[10:19:25.478]                   }
[10:19:25.478]                 }, immediateCondition = function(cond) {
[10:19:25.478]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.478]                   sendCondition(cond)
[10:19:25.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.478]                   {
[10:19:25.478]                     inherits <- base::inherits
[10:19:25.478]                     invokeRestart <- base::invokeRestart
[10:19:25.478]                     is.null <- base::is.null
[10:19:25.478]                     muffled <- FALSE
[10:19:25.478]                     if (inherits(cond, "message")) {
[10:19:25.478]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.478]                       if (muffled) 
[10:19:25.478]                         invokeRestart("muffleMessage")
[10:19:25.478]                     }
[10:19:25.478]                     else if (inherits(cond, "warning")) {
[10:19:25.478]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.478]                       if (muffled) 
[10:19:25.478]                         invokeRestart("muffleWarning")
[10:19:25.478]                     }
[10:19:25.478]                     else if (inherits(cond, "condition")) {
[10:19:25.478]                       if (!is.null(pattern)) {
[10:19:25.478]                         computeRestarts <- base::computeRestarts
[10:19:25.478]                         grepl <- base::grepl
[10:19:25.478]                         restarts <- computeRestarts(cond)
[10:19:25.478]                         for (restart in restarts) {
[10:19:25.478]                           name <- restart$name
[10:19:25.478]                           if (is.null(name)) 
[10:19:25.478]                             next
[10:19:25.478]                           if (!grepl(pattern, name)) 
[10:19:25.478]                             next
[10:19:25.478]                           invokeRestart(restart)
[10:19:25.478]                           muffled <- TRUE
[10:19:25.478]                           break
[10:19:25.478]                         }
[10:19:25.478]                       }
[10:19:25.478]                     }
[10:19:25.478]                     invisible(muffled)
[10:19:25.478]                   }
[10:19:25.478]                   muffleCondition(cond)
[10:19:25.478]                 })
[10:19:25.478]             }))
[10:19:25.478]             future::FutureResult(value = ...future.value$value, 
[10:19:25.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.478]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.478]                     ...future.globalenv.names))
[10:19:25.478]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.478]         }, condition = base::local({
[10:19:25.478]             c <- base::c
[10:19:25.478]             inherits <- base::inherits
[10:19:25.478]             invokeRestart <- base::invokeRestart
[10:19:25.478]             length <- base::length
[10:19:25.478]             list <- base::list
[10:19:25.478]             seq.int <- base::seq.int
[10:19:25.478]             signalCondition <- base::signalCondition
[10:19:25.478]             sys.calls <- base::sys.calls
[10:19:25.478]             `[[` <- base::`[[`
[10:19:25.478]             `+` <- base::`+`
[10:19:25.478]             `<<-` <- base::`<<-`
[10:19:25.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.478]                   3L)]
[10:19:25.478]             }
[10:19:25.478]             function(cond) {
[10:19:25.478]                 is_error <- inherits(cond, "error")
[10:19:25.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.478]                   NULL)
[10:19:25.478]                 if (is_error) {
[10:19:25.478]                   sessionInformation <- function() {
[10:19:25.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.478]                       search = base::search(), system = base::Sys.info())
[10:19:25.478]                   }
[10:19:25.478]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.478]                     cond$call), session = sessionInformation(), 
[10:19:25.478]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.478]                   signalCondition(cond)
[10:19:25.478]                 }
[10:19:25.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.478]                 "immediateCondition"))) {
[10:19:25.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.478]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.478]                   if (TRUE && !signal) {
[10:19:25.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.478]                     {
[10:19:25.478]                       inherits <- base::inherits
[10:19:25.478]                       invokeRestart <- base::invokeRestart
[10:19:25.478]                       is.null <- base::is.null
[10:19:25.478]                       muffled <- FALSE
[10:19:25.478]                       if (inherits(cond, "message")) {
[10:19:25.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.478]                         if (muffled) 
[10:19:25.478]                           invokeRestart("muffleMessage")
[10:19:25.478]                       }
[10:19:25.478]                       else if (inherits(cond, "warning")) {
[10:19:25.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.478]                         if (muffled) 
[10:19:25.478]                           invokeRestart("muffleWarning")
[10:19:25.478]                       }
[10:19:25.478]                       else if (inherits(cond, "condition")) {
[10:19:25.478]                         if (!is.null(pattern)) {
[10:19:25.478]                           computeRestarts <- base::computeRestarts
[10:19:25.478]                           grepl <- base::grepl
[10:19:25.478]                           restarts <- computeRestarts(cond)
[10:19:25.478]                           for (restart in restarts) {
[10:19:25.478]                             name <- restart$name
[10:19:25.478]                             if (is.null(name)) 
[10:19:25.478]                               next
[10:19:25.478]                             if (!grepl(pattern, name)) 
[10:19:25.478]                               next
[10:19:25.478]                             invokeRestart(restart)
[10:19:25.478]                             muffled <- TRUE
[10:19:25.478]                             break
[10:19:25.478]                           }
[10:19:25.478]                         }
[10:19:25.478]                       }
[10:19:25.478]                       invisible(muffled)
[10:19:25.478]                     }
[10:19:25.478]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.478]                   }
[10:19:25.478]                 }
[10:19:25.478]                 else {
[10:19:25.478]                   if (TRUE) {
[10:19:25.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.478]                     {
[10:19:25.478]                       inherits <- base::inherits
[10:19:25.478]                       invokeRestart <- base::invokeRestart
[10:19:25.478]                       is.null <- base::is.null
[10:19:25.478]                       muffled <- FALSE
[10:19:25.478]                       if (inherits(cond, "message")) {
[10:19:25.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.478]                         if (muffled) 
[10:19:25.478]                           invokeRestart("muffleMessage")
[10:19:25.478]                       }
[10:19:25.478]                       else if (inherits(cond, "warning")) {
[10:19:25.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.478]                         if (muffled) 
[10:19:25.478]                           invokeRestart("muffleWarning")
[10:19:25.478]                       }
[10:19:25.478]                       else if (inherits(cond, "condition")) {
[10:19:25.478]                         if (!is.null(pattern)) {
[10:19:25.478]                           computeRestarts <- base::computeRestarts
[10:19:25.478]                           grepl <- base::grepl
[10:19:25.478]                           restarts <- computeRestarts(cond)
[10:19:25.478]                           for (restart in restarts) {
[10:19:25.478]                             name <- restart$name
[10:19:25.478]                             if (is.null(name)) 
[10:19:25.478]                               next
[10:19:25.478]                             if (!grepl(pattern, name)) 
[10:19:25.478]                               next
[10:19:25.478]                             invokeRestart(restart)
[10:19:25.478]                             muffled <- TRUE
[10:19:25.478]                             break
[10:19:25.478]                           }
[10:19:25.478]                         }
[10:19:25.478]                       }
[10:19:25.478]                       invisible(muffled)
[10:19:25.478]                     }
[10:19:25.478]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.478]                   }
[10:19:25.478]                 }
[10:19:25.478]             }
[10:19:25.478]         }))
[10:19:25.478]     }, error = function(ex) {
[10:19:25.478]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.478]                 ...future.rng), started = ...future.startTime, 
[10:19:25.478]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.478]             version = "1.8"), class = "FutureResult")
[10:19:25.478]     }, finally = {
[10:19:25.478]         if (!identical(...future.workdir, getwd())) 
[10:19:25.478]             setwd(...future.workdir)
[10:19:25.478]         {
[10:19:25.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.478]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.478]             }
[10:19:25.478]             base::options(...future.oldOptions)
[10:19:25.478]             if (.Platform$OS.type == "windows") {
[10:19:25.478]                 old_names <- names(...future.oldEnvVars)
[10:19:25.478]                 envs <- base::Sys.getenv()
[10:19:25.478]                 names <- names(envs)
[10:19:25.478]                 common <- intersect(names, old_names)
[10:19:25.478]                 added <- setdiff(names, old_names)
[10:19:25.478]                 removed <- setdiff(old_names, names)
[10:19:25.478]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.478]                   envs[common]]
[10:19:25.478]                 NAMES <- toupper(changed)
[10:19:25.478]                 args <- list()
[10:19:25.478]                 for (kk in seq_along(NAMES)) {
[10:19:25.478]                   name <- changed[[kk]]
[10:19:25.478]                   NAME <- NAMES[[kk]]
[10:19:25.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.478]                     next
[10:19:25.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.478]                 }
[10:19:25.478]                 NAMES <- toupper(added)
[10:19:25.478]                 for (kk in seq_along(NAMES)) {
[10:19:25.478]                   name <- added[[kk]]
[10:19:25.478]                   NAME <- NAMES[[kk]]
[10:19:25.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.478]                     next
[10:19:25.478]                   args[[name]] <- ""
[10:19:25.478]                 }
[10:19:25.478]                 NAMES <- toupper(removed)
[10:19:25.478]                 for (kk in seq_along(NAMES)) {
[10:19:25.478]                   name <- removed[[kk]]
[10:19:25.478]                   NAME <- NAMES[[kk]]
[10:19:25.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.478]                     next
[10:19:25.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.478]                 }
[10:19:25.478]                 if (length(args) > 0) 
[10:19:25.478]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.478]             }
[10:19:25.478]             else {
[10:19:25.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.478]             }
[10:19:25.478]             {
[10:19:25.478]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.478]                   0L) {
[10:19:25.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.478]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.478]                   base::options(opts)
[10:19:25.478]                 }
[10:19:25.478]                 {
[10:19:25.478]                   {
[10:19:25.478]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.478]                     NULL
[10:19:25.478]                   }
[10:19:25.478]                   options(future.plan = NULL)
[10:19:25.478]                   if (is.na(NA_character_)) 
[10:19:25.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.478]                     .init = FALSE)
[10:19:25.478]                 }
[10:19:25.478]             }
[10:19:25.478]         }
[10:19:25.478]     })
[10:19:25.478]     if (TRUE) {
[10:19:25.478]         base::sink(type = "output", split = FALSE)
[10:19:25.478]         if (TRUE) {
[10:19:25.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.478]         }
[10:19:25.478]         else {
[10:19:25.478]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.478]         }
[10:19:25.478]         base::close(...future.stdout)
[10:19:25.478]         ...future.stdout <- NULL
[10:19:25.478]     }
[10:19:25.478]     ...future.result$conditions <- ...future.conditions
[10:19:25.478]     ...future.result$finished <- base::Sys.time()
[10:19:25.478]     ...future.result
[10:19:25.478] }
[10:19:25.481] Exporting 5 global objects (1.33 KiB) to cluster node #2 ...
[10:19:25.481] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:19:25.482] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:19:25.482] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[10:19:25.482] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[10:19:25.482] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[10:19:25.483] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[10:19:25.483] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:25.483] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.483] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:25.484] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.484] Exporting 5 global objects (1.33 KiB) to cluster node #2 ... DONE
[10:19:25.484] MultisessionFuture started
[10:19:25.484] - Launch lazy future ... done
[10:19:25.485] run() for ‘MultisessionFuture’ ... done
[10:19:25.485] Created future:
[10:19:25.485] MultisessionFuture:
[10:19:25.485] Label: ‘future_.mapply-2’
[10:19:25.485] Expression:
[10:19:25.485] {
[10:19:25.485]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.485]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.485]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.485]         on.exit(options(oopts), add = TRUE)
[10:19:25.485]     }
[10:19:25.485]     {
[10:19:25.485]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.485]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.485]         do.call(mapply, args = args)
[10:19:25.485]     }
[10:19:25.485] }
[10:19:25.485] Lazy evaluation: FALSE
[10:19:25.485] Asynchronous evaluation: TRUE
[10:19:25.485] Local evaluation: TRUE
[10:19:25.485] Environment: R_GlobalEnv
[10:19:25.485] Capture standard output: TRUE
[10:19:25.485] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.485] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.485] Packages: <none>
[10:19:25.485] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.485] Resolved: FALSE
[10:19:25.485] Value: <not collected>
[10:19:25.485] Conditions captured: <none>
[10:19:25.485] Early signaling: FALSE
[10:19:25.485] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.485] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.496] Chunk #2 of 2 ... DONE
[10:19:25.496] Launching 2 futures (chunks) ... DONE
[10:19:25.496] Resolving 2 futures (chunks) ...
[10:19:25.496] resolve() on list ...
[10:19:25.497]  recursive: 0
[10:19:25.497]  length: 2
[10:19:25.497] 
[10:19:25.497] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.497] - Validating connection of MultisessionFuture
[10:19:25.497] - received message: FutureResult
[10:19:25.498] - Received FutureResult
[10:19:25.498] - Erased future from FutureRegistry
[10:19:25.498] result() for ClusterFuture ...
[10:19:25.498] - result already collected: FutureResult
[10:19:25.498] result() for ClusterFuture ... done
[10:19:25.498] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.498] Future #1
[10:19:25.498] result() for ClusterFuture ...
[10:19:25.498] - result already collected: FutureResult
[10:19:25.498] result() for ClusterFuture ... done
[10:19:25.498] result() for ClusterFuture ...
[10:19:25.498] - result already collected: FutureResult
[10:19:25.499] result() for ClusterFuture ... done
[10:19:25.499] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:25.499] - nx: 2
[10:19:25.499] - relay: TRUE
[10:19:25.499] - stdout: TRUE
[10:19:25.499] - signal: TRUE
[10:19:25.499] - resignal: FALSE
[10:19:25.499] - force: TRUE
[10:19:25.499] - relayed: [n=2] FALSE, FALSE
[10:19:25.499] - queued futures: [n=2] FALSE, FALSE
[10:19:25.499]  - until=1
[10:19:25.499]  - relaying element #1
[10:19:25.500] result() for ClusterFuture ...
[10:19:25.500] - result already collected: FutureResult
[10:19:25.500] result() for ClusterFuture ... done
[10:19:25.500] result() for ClusterFuture ...
[10:19:25.500] - result already collected: FutureResult
[10:19:25.500] result() for ClusterFuture ... done
[10:19:25.500] result() for ClusterFuture ...
[10:19:25.500] - result already collected: FutureResult
[10:19:25.500] result() for ClusterFuture ... done
[10:19:25.500] result() for ClusterFuture ...
[10:19:25.500] - result already collected: FutureResult
[10:19:25.500] result() for ClusterFuture ... done
[10:19:25.501] - relayed: [n=2] TRUE, FALSE
[10:19:25.501] - queued futures: [n=2] TRUE, FALSE
[10:19:25.501] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:25.501]  length: 1 (resolved future 1)
[10:19:25.526] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.526] - Validating connection of MultisessionFuture
[10:19:25.526] - received message: FutureResult
[10:19:25.529] - Received FutureResult
[10:19:25.529] - Erased future from FutureRegistry
[10:19:25.529] result() for ClusterFuture ...
[10:19:25.529] - result already collected: FutureResult
[10:19:25.529] result() for ClusterFuture ... done
[10:19:25.529] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.529] Future #2
[10:19:25.529] result() for ClusterFuture ...
[10:19:25.530] - result already collected: FutureResult
[10:19:25.530] result() for ClusterFuture ... done
[10:19:25.530] result() for ClusterFuture ...
[10:19:25.530] - result already collected: FutureResult
[10:19:25.530] result() for ClusterFuture ... done
[10:19:25.530] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:25.530] - nx: 2
[10:19:25.530] - relay: TRUE
[10:19:25.530] - stdout: TRUE
[10:19:25.530] - signal: TRUE
[10:19:25.530] - resignal: FALSE
[10:19:25.530] - force: TRUE
[10:19:25.530] - relayed: [n=2] TRUE, FALSE
[10:19:25.531] - queued futures: [n=2] TRUE, FALSE
[10:19:25.531]  - until=2
[10:19:25.531]  - relaying element #2
[10:19:25.531] result() for ClusterFuture ...
[10:19:25.531] - result already collected: FutureResult
[10:19:25.531] result() for ClusterFuture ... done
[10:19:25.531] result() for ClusterFuture ...
[10:19:25.531] - result already collected: FutureResult
[10:19:25.531] result() for ClusterFuture ... done
[10:19:25.531] result() for ClusterFuture ...
[10:19:25.531] - result already collected: FutureResult
[10:19:25.531] result() for ClusterFuture ... done
[10:19:25.532] result() for ClusterFuture ...
[10:19:25.532] - result already collected: FutureResult
[10:19:25.532] result() for ClusterFuture ... done
[10:19:25.532] - relayed: [n=2] TRUE, TRUE
[10:19:25.532] - queued futures: [n=2] TRUE, TRUE
[10:19:25.532] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:25.532]  length: 0 (resolved future 2)
[10:19:25.532] Relaying remaining futures
[10:19:25.532] signalConditionsASAP(NULL, pos=0) ...
[10:19:25.532] - nx: 2
[10:19:25.532] - relay: TRUE
[10:19:25.532] - stdout: TRUE
[10:19:25.532] - signal: TRUE
[10:19:25.533] - resignal: FALSE
[10:19:25.533] - force: TRUE
[10:19:25.533] - relayed: [n=2] TRUE, TRUE
[10:19:25.533] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:25.533] - relayed: [n=2] TRUE, TRUE
[10:19:25.533] - queued futures: [n=2] TRUE, TRUE
[10:19:25.533] signalConditionsASAP(NULL, pos=0) ... done
[10:19:25.533] resolve() on list ... DONE
[10:19:25.533] result() for ClusterFuture ...
[10:19:25.533] - result already collected: FutureResult
[10:19:25.533] result() for ClusterFuture ... done
[10:19:25.533] result() for ClusterFuture ...
[10:19:25.534] - result already collected: FutureResult
[10:19:25.534] result() for ClusterFuture ... done
[10:19:25.534] result() for ClusterFuture ...
[10:19:25.534] - result already collected: FutureResult
[10:19:25.534] result() for ClusterFuture ... done
[10:19:25.534] result() for ClusterFuture ...
[10:19:25.534] - result already collected: FutureResult
[10:19:25.534] result() for ClusterFuture ... done
[10:19:25.534]  - Number of value chunks collected: 2
[10:19:25.534] Resolving 2 futures (chunks) ... DONE
[10:19:25.534] Reducing values from 2 chunks ...
[10:19:25.534]  - Number of values collected after concatenation: 5
[10:19:25.535]  - Number of values expected: 5
[10:19:25.535] Reducing values from 2 chunks ... DONE
[10:19:25.535] future_mapply() ... DONE
[10:19:25.535] future_mapply() ...
[10:19:25.537] Number of chunks: 3
[10:19:25.537] Index remapping (attribute 'ordering'): [n = 5] 4, 2, 3, 5, 1
[10:19:25.537] getGlobalsAndPackagesXApply() ...
[10:19:25.537]  - future.globals: TRUE
[10:19:25.537] getGlobalsAndPackages() ...
[10:19:25.537] Searching for globals...
[10:19:25.538] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:25.538] Searching for globals ... DONE
[10:19:25.539] Resolving globals: FALSE
[10:19:25.539] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:25.539] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:25.539] - globals: [1] ‘FUN’
[10:19:25.539] 
[10:19:25.540] getGlobalsAndPackages() ... DONE
[10:19:25.540]  - globals found/used: [n=1] ‘FUN’
[10:19:25.540]  - needed namespaces: [n=0] 
[10:19:25.540] Finding globals ... DONE
[10:19:25.540] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:25.540] List of 2
[10:19:25.540]  $ ...future.FUN:function (C, k)  
[10:19:25.540]  $ MoreArgs     : NULL
[10:19:25.540]  - attr(*, "where")=List of 2
[10:19:25.540]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:25.540]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:25.540]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:25.540]  - attr(*, "resolved")= logi FALSE
[10:19:25.540]  - attr(*, "total_size")= num NA
[10:19:25.542] Packages to be attached in all futures: [n=0] 
[10:19:25.543] getGlobalsAndPackagesXApply() ... DONE
[10:19:25.543] Number of futures (= number of chunks): 3
[10:19:25.543] Launching 3 futures (chunks) ...
[10:19:25.543] Chunk #1 of 3 ...
[10:19:25.543]  - Finding globals in '...' for chunk #1 ...
[10:19:25.543] getGlobalsAndPackages() ...
[10:19:25.543] Searching for globals...
[10:19:25.544] 
[10:19:25.544] Searching for globals ... DONE
[10:19:25.544] - globals: [0] <none>
[10:19:25.544] getGlobalsAndPackages() ... DONE
[10:19:25.544]    + additional globals found: [n=0] 
[10:19:25.544]    + additional namespaces needed: [n=0] 
[10:19:25.544]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:25.544]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:19:25.544]  - seeds: <none>
[10:19:25.544]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.544] getGlobalsAndPackages() ...
[10:19:25.544] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.545] Resolving globals: FALSE
[10:19:25.545] The total size of the 5 globals is 876 bytes (876 bytes)
[10:19:25.545] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:25.545] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.546] 
[10:19:25.546] getGlobalsAndPackages() ... DONE
[10:19:25.546] run() for ‘Future’ ...
[10:19:25.546] - state: ‘created’
[10:19:25.546] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.560] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.560] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.560]   - Field: ‘node’
[10:19:25.560]   - Field: ‘label’
[10:19:25.561]   - Field: ‘local’
[10:19:25.561]   - Field: ‘owner’
[10:19:25.561]   - Field: ‘envir’
[10:19:25.561]   - Field: ‘workers’
[10:19:25.561]   - Field: ‘packages’
[10:19:25.561]   - Field: ‘gc’
[10:19:25.561]   - Field: ‘conditions’
[10:19:25.561]   - Field: ‘persistent’
[10:19:25.561]   - Field: ‘expr’
[10:19:25.561]   - Field: ‘uuid’
[10:19:25.561]   - Field: ‘seed’
[10:19:25.561]   - Field: ‘version’
[10:19:25.562]   - Field: ‘result’
[10:19:25.562]   - Field: ‘asynchronous’
[10:19:25.562]   - Field: ‘calls’
[10:19:25.562]   - Field: ‘globals’
[10:19:25.562]   - Field: ‘stdout’
[10:19:25.562]   - Field: ‘earlySignal’
[10:19:25.562]   - Field: ‘lazy’
[10:19:25.562]   - Field: ‘state’
[10:19:25.562] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.562] - Launch lazy future ...
[10:19:25.563] Packages needed by the future expression (n = 0): <none>
[10:19:25.563] Packages needed by future strategies (n = 0): <none>
[10:19:25.563] {
[10:19:25.563]     {
[10:19:25.563]         {
[10:19:25.563]             ...future.startTime <- base::Sys.time()
[10:19:25.563]             {
[10:19:25.563]                 {
[10:19:25.563]                   {
[10:19:25.563]                     {
[10:19:25.563]                       base::local({
[10:19:25.563]                         has_future <- base::requireNamespace("future", 
[10:19:25.563]                           quietly = TRUE)
[10:19:25.563]                         if (has_future) {
[10:19:25.563]                           ns <- base::getNamespace("future")
[10:19:25.563]                           version <- ns[[".package"]][["version"]]
[10:19:25.563]                           if (is.null(version)) 
[10:19:25.563]                             version <- utils::packageVersion("future")
[10:19:25.563]                         }
[10:19:25.563]                         else {
[10:19:25.563]                           version <- NULL
[10:19:25.563]                         }
[10:19:25.563]                         if (!has_future || version < "1.8.0") {
[10:19:25.563]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.563]                             "", base::R.version$version.string), 
[10:19:25.563]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.563]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.563]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.563]                               "release", "version")], collapse = " "), 
[10:19:25.563]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.563]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.563]                             info)
[10:19:25.563]                           info <- base::paste(info, collapse = "; ")
[10:19:25.563]                           if (!has_future) {
[10:19:25.563]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.563]                               info)
[10:19:25.563]                           }
[10:19:25.563]                           else {
[10:19:25.563]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.563]                               info, version)
[10:19:25.563]                           }
[10:19:25.563]                           base::stop(msg)
[10:19:25.563]                         }
[10:19:25.563]                       })
[10:19:25.563]                     }
[10:19:25.563]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.563]                     base::options(mc.cores = 1L)
[10:19:25.563]                   }
[10:19:25.563]                   ...future.strategy.old <- future::plan("list")
[10:19:25.563]                   options(future.plan = NULL)
[10:19:25.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.563]                 }
[10:19:25.563]                 ...future.workdir <- getwd()
[10:19:25.563]             }
[10:19:25.563]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.563]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.563]         }
[10:19:25.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.563]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:19:25.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.563]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.563]             base::names(...future.oldOptions))
[10:19:25.563]     }
[10:19:25.563]     if (FALSE) {
[10:19:25.563]     }
[10:19:25.563]     else {
[10:19:25.563]         if (TRUE) {
[10:19:25.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.563]                 open = "w")
[10:19:25.563]         }
[10:19:25.563]         else {
[10:19:25.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.563]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.563]         }
[10:19:25.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.563]             base::sink(type = "output", split = FALSE)
[10:19:25.563]             base::close(...future.stdout)
[10:19:25.563]         }, add = TRUE)
[10:19:25.563]     }
[10:19:25.563]     ...future.frame <- base::sys.nframe()
[10:19:25.563]     ...future.conditions <- base::list()
[10:19:25.563]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.563]     if (FALSE) {
[10:19:25.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.563]     }
[10:19:25.563]     ...future.result <- base::tryCatch({
[10:19:25.563]         base::withCallingHandlers({
[10:19:25.563]             ...future.value <- base::withVisible(base::local({
[10:19:25.563]                 ...future.makeSendCondition <- base::local({
[10:19:25.563]                   sendCondition <- NULL
[10:19:25.563]                   function(frame = 1L) {
[10:19:25.563]                     if (is.function(sendCondition)) 
[10:19:25.563]                       return(sendCondition)
[10:19:25.563]                     ns <- getNamespace("parallel")
[10:19:25.563]                     if (exists("sendData", mode = "function", 
[10:19:25.563]                       envir = ns)) {
[10:19:25.563]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.563]                         envir = ns)
[10:19:25.563]                       envir <- sys.frame(frame)
[10:19:25.563]                       master <- NULL
[10:19:25.563]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.563]                         !identical(envir, emptyenv())) {
[10:19:25.563]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.563]                           inherits = FALSE)) {
[10:19:25.563]                           master <- get("master", mode = "list", 
[10:19:25.563]                             envir = envir, inherits = FALSE)
[10:19:25.563]                           if (inherits(master, c("SOCKnode", 
[10:19:25.563]                             "SOCK0node"))) {
[10:19:25.563]                             sendCondition <<- function(cond) {
[10:19:25.563]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.563]                                 success = TRUE)
[10:19:25.563]                               parallel_sendData(master, data)
[10:19:25.563]                             }
[10:19:25.563]                             return(sendCondition)
[10:19:25.563]                           }
[10:19:25.563]                         }
[10:19:25.563]                         frame <- frame + 1L
[10:19:25.563]                         envir <- sys.frame(frame)
[10:19:25.563]                       }
[10:19:25.563]                     }
[10:19:25.563]                     sendCondition <<- function(cond) NULL
[10:19:25.563]                   }
[10:19:25.563]                 })
[10:19:25.563]                 withCallingHandlers({
[10:19:25.563]                   {
[10:19:25.563]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.563]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.563]                       ...future.globals.maxSize)) {
[10:19:25.563]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.563]                       on.exit(options(oopts), add = TRUE)
[10:19:25.563]                     }
[10:19:25.563]                     {
[10:19:25.563]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.563]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.563]                         USE.NAMES = FALSE)
[10:19:25.563]                       do.call(mapply, args = args)
[10:19:25.563]                     }
[10:19:25.563]                   }
[10:19:25.563]                 }, immediateCondition = function(cond) {
[10:19:25.563]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.563]                   sendCondition(cond)
[10:19:25.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.563]                   {
[10:19:25.563]                     inherits <- base::inherits
[10:19:25.563]                     invokeRestart <- base::invokeRestart
[10:19:25.563]                     is.null <- base::is.null
[10:19:25.563]                     muffled <- FALSE
[10:19:25.563]                     if (inherits(cond, "message")) {
[10:19:25.563]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.563]                       if (muffled) 
[10:19:25.563]                         invokeRestart("muffleMessage")
[10:19:25.563]                     }
[10:19:25.563]                     else if (inherits(cond, "warning")) {
[10:19:25.563]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.563]                       if (muffled) 
[10:19:25.563]                         invokeRestart("muffleWarning")
[10:19:25.563]                     }
[10:19:25.563]                     else if (inherits(cond, "condition")) {
[10:19:25.563]                       if (!is.null(pattern)) {
[10:19:25.563]                         computeRestarts <- base::computeRestarts
[10:19:25.563]                         grepl <- base::grepl
[10:19:25.563]                         restarts <- computeRestarts(cond)
[10:19:25.563]                         for (restart in restarts) {
[10:19:25.563]                           name <- restart$name
[10:19:25.563]                           if (is.null(name)) 
[10:19:25.563]                             next
[10:19:25.563]                           if (!grepl(pattern, name)) 
[10:19:25.563]                             next
[10:19:25.563]                           invokeRestart(restart)
[10:19:25.563]                           muffled <- TRUE
[10:19:25.563]                           break
[10:19:25.563]                         }
[10:19:25.563]                       }
[10:19:25.563]                     }
[10:19:25.563]                     invisible(muffled)
[10:19:25.563]                   }
[10:19:25.563]                   muffleCondition(cond)
[10:19:25.563]                 })
[10:19:25.563]             }))
[10:19:25.563]             future::FutureResult(value = ...future.value$value, 
[10:19:25.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.563]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.563]                     ...future.globalenv.names))
[10:19:25.563]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.563]         }, condition = base::local({
[10:19:25.563]             c <- base::c
[10:19:25.563]             inherits <- base::inherits
[10:19:25.563]             invokeRestart <- base::invokeRestart
[10:19:25.563]             length <- base::length
[10:19:25.563]             list <- base::list
[10:19:25.563]             seq.int <- base::seq.int
[10:19:25.563]             signalCondition <- base::signalCondition
[10:19:25.563]             sys.calls <- base::sys.calls
[10:19:25.563]             `[[` <- base::`[[`
[10:19:25.563]             `+` <- base::`+`
[10:19:25.563]             `<<-` <- base::`<<-`
[10:19:25.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.563]                   3L)]
[10:19:25.563]             }
[10:19:25.563]             function(cond) {
[10:19:25.563]                 is_error <- inherits(cond, "error")
[10:19:25.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.563]                   NULL)
[10:19:25.563]                 if (is_error) {
[10:19:25.563]                   sessionInformation <- function() {
[10:19:25.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.563]                       search = base::search(), system = base::Sys.info())
[10:19:25.563]                   }
[10:19:25.563]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.563]                     cond$call), session = sessionInformation(), 
[10:19:25.563]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.563]                   signalCondition(cond)
[10:19:25.563]                 }
[10:19:25.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.563]                 "immediateCondition"))) {
[10:19:25.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.563]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.563]                   if (TRUE && !signal) {
[10:19:25.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.563]                     {
[10:19:25.563]                       inherits <- base::inherits
[10:19:25.563]                       invokeRestart <- base::invokeRestart
[10:19:25.563]                       is.null <- base::is.null
[10:19:25.563]                       muffled <- FALSE
[10:19:25.563]                       if (inherits(cond, "message")) {
[10:19:25.563]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.563]                         if (muffled) 
[10:19:25.563]                           invokeRestart("muffleMessage")
[10:19:25.563]                       }
[10:19:25.563]                       else if (inherits(cond, "warning")) {
[10:19:25.563]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.563]                         if (muffled) 
[10:19:25.563]                           invokeRestart("muffleWarning")
[10:19:25.563]                       }
[10:19:25.563]                       else if (inherits(cond, "condition")) {
[10:19:25.563]                         if (!is.null(pattern)) {
[10:19:25.563]                           computeRestarts <- base::computeRestarts
[10:19:25.563]                           grepl <- base::grepl
[10:19:25.563]                           restarts <- computeRestarts(cond)
[10:19:25.563]                           for (restart in restarts) {
[10:19:25.563]                             name <- restart$name
[10:19:25.563]                             if (is.null(name)) 
[10:19:25.563]                               next
[10:19:25.563]                             if (!grepl(pattern, name)) 
[10:19:25.563]                               next
[10:19:25.563]                             invokeRestart(restart)
[10:19:25.563]                             muffled <- TRUE
[10:19:25.563]                             break
[10:19:25.563]                           }
[10:19:25.563]                         }
[10:19:25.563]                       }
[10:19:25.563]                       invisible(muffled)
[10:19:25.563]                     }
[10:19:25.563]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.563]                   }
[10:19:25.563]                 }
[10:19:25.563]                 else {
[10:19:25.563]                   if (TRUE) {
[10:19:25.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.563]                     {
[10:19:25.563]                       inherits <- base::inherits
[10:19:25.563]                       invokeRestart <- base::invokeRestart
[10:19:25.563]                       is.null <- base::is.null
[10:19:25.563]                       muffled <- FALSE
[10:19:25.563]                       if (inherits(cond, "message")) {
[10:19:25.563]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.563]                         if (muffled) 
[10:19:25.563]                           invokeRestart("muffleMessage")
[10:19:25.563]                       }
[10:19:25.563]                       else if (inherits(cond, "warning")) {
[10:19:25.563]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.563]                         if (muffled) 
[10:19:25.563]                           invokeRestart("muffleWarning")
[10:19:25.563]                       }
[10:19:25.563]                       else if (inherits(cond, "condition")) {
[10:19:25.563]                         if (!is.null(pattern)) {
[10:19:25.563]                           computeRestarts <- base::computeRestarts
[10:19:25.563]                           grepl <- base::grepl
[10:19:25.563]                           restarts <- computeRestarts(cond)
[10:19:25.563]                           for (restart in restarts) {
[10:19:25.563]                             name <- restart$name
[10:19:25.563]                             if (is.null(name)) 
[10:19:25.563]                               next
[10:19:25.563]                             if (!grepl(pattern, name)) 
[10:19:25.563]                               next
[10:19:25.563]                             invokeRestart(restart)
[10:19:25.563]                             muffled <- TRUE
[10:19:25.563]                             break
[10:19:25.563]                           }
[10:19:25.563]                         }
[10:19:25.563]                       }
[10:19:25.563]                       invisible(muffled)
[10:19:25.563]                     }
[10:19:25.563]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.563]                   }
[10:19:25.563]                 }
[10:19:25.563]             }
[10:19:25.563]         }))
[10:19:25.563]     }, error = function(ex) {
[10:19:25.563]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.563]                 ...future.rng), started = ...future.startTime, 
[10:19:25.563]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.563]             version = "1.8"), class = "FutureResult")
[10:19:25.563]     }, finally = {
[10:19:25.563]         if (!identical(...future.workdir, getwd())) 
[10:19:25.563]             setwd(...future.workdir)
[10:19:25.563]         {
[10:19:25.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.563]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.563]             }
[10:19:25.563]             base::options(...future.oldOptions)
[10:19:25.563]             if (.Platform$OS.type == "windows") {
[10:19:25.563]                 old_names <- names(...future.oldEnvVars)
[10:19:25.563]                 envs <- base::Sys.getenv()
[10:19:25.563]                 names <- names(envs)
[10:19:25.563]                 common <- intersect(names, old_names)
[10:19:25.563]                 added <- setdiff(names, old_names)
[10:19:25.563]                 removed <- setdiff(old_names, names)
[10:19:25.563]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.563]                   envs[common]]
[10:19:25.563]                 NAMES <- toupper(changed)
[10:19:25.563]                 args <- list()
[10:19:25.563]                 for (kk in seq_along(NAMES)) {
[10:19:25.563]                   name <- changed[[kk]]
[10:19:25.563]                   NAME <- NAMES[[kk]]
[10:19:25.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.563]                     next
[10:19:25.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.563]                 }
[10:19:25.563]                 NAMES <- toupper(added)
[10:19:25.563]                 for (kk in seq_along(NAMES)) {
[10:19:25.563]                   name <- added[[kk]]
[10:19:25.563]                   NAME <- NAMES[[kk]]
[10:19:25.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.563]                     next
[10:19:25.563]                   args[[name]] <- ""
[10:19:25.563]                 }
[10:19:25.563]                 NAMES <- toupper(removed)
[10:19:25.563]                 for (kk in seq_along(NAMES)) {
[10:19:25.563]                   name <- removed[[kk]]
[10:19:25.563]                   NAME <- NAMES[[kk]]
[10:19:25.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.563]                     next
[10:19:25.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.563]                 }
[10:19:25.563]                 if (length(args) > 0) 
[10:19:25.563]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.563]             }
[10:19:25.563]             else {
[10:19:25.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.563]             }
[10:19:25.563]             {
[10:19:25.563]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.563]                   0L) {
[10:19:25.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.563]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.563]                   base::options(opts)
[10:19:25.563]                 }
[10:19:25.563]                 {
[10:19:25.563]                   {
[10:19:25.563]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.563]                     NULL
[10:19:25.563]                   }
[10:19:25.563]                   options(future.plan = NULL)
[10:19:25.563]                   if (is.na(NA_character_)) 
[10:19:25.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.563]                     .init = FALSE)
[10:19:25.563]                 }
[10:19:25.563]             }
[10:19:25.563]         }
[10:19:25.563]     })
[10:19:25.563]     if (TRUE) {
[10:19:25.563]         base::sink(type = "output", split = FALSE)
[10:19:25.563]         if (TRUE) {
[10:19:25.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.563]         }
[10:19:25.563]         else {
[10:19:25.563]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.563]         }
[10:19:25.563]         base::close(...future.stdout)
[10:19:25.563]         ...future.stdout <- NULL
[10:19:25.563]     }
[10:19:25.563]     ...future.result$conditions <- ...future.conditions
[10:19:25.563]     ...future.result$finished <- base::Sys.time()
[10:19:25.563]     ...future.result
[10:19:25.563] }
[10:19:25.566] Exporting 5 global objects (1.29 KiB) to cluster node #1 ...
[10:19:25.566] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:19:25.567] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:19:25.567] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:25.567] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.567] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:19:25.568] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:19:25.568] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:25.568] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.568] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:25.569] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.569] Exporting 5 global objects (1.29 KiB) to cluster node #1 ... DONE
[10:19:25.569] MultisessionFuture started
[10:19:25.569] - Launch lazy future ... done
[10:19:25.569] run() for ‘MultisessionFuture’ ... done
[10:19:25.569] Created future:
[10:19:25.569] MultisessionFuture:
[10:19:25.569] Label: ‘future_mapply-1’
[10:19:25.569] Expression:
[10:19:25.569] {
[10:19:25.569]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.569]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.569]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.569]         on.exit(options(oopts), add = TRUE)
[10:19:25.569]     }
[10:19:25.569]     {
[10:19:25.569]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.569]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.569]         do.call(mapply, args = args)
[10:19:25.569]     }
[10:19:25.569] }
[10:19:25.569] Lazy evaluation: FALSE
[10:19:25.569] Asynchronous evaluation: TRUE
[10:19:25.569] Local evaluation: TRUE
[10:19:25.569] Environment: R_GlobalEnv
[10:19:25.569] Capture standard output: TRUE
[10:19:25.569] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.569] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.569] Packages: <none>
[10:19:25.569] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.569] Resolved: FALSE
[10:19:25.569] Value: <not collected>
[10:19:25.569] Conditions captured: <none>
[10:19:25.569] Early signaling: FALSE
[10:19:25.569] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.569] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.581] Chunk #1 of 3 ... DONE
[10:19:25.581] Chunk #2 of 3 ...
[10:19:25.581]  - Finding globals in '...' for chunk #2 ...
[10:19:25.581] getGlobalsAndPackages() ...
[10:19:25.581] Searching for globals...
[10:19:25.582] 
[10:19:25.582] Searching for globals ... DONE
[10:19:25.582] - globals: [0] <none>
[10:19:25.582] getGlobalsAndPackages() ... DONE
[10:19:25.582]    + additional globals found: [n=0] 
[10:19:25.582]    + additional namespaces needed: [n=0] 
[10:19:25.582]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:25.582]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:19:25.582]  - seeds: <none>
[10:19:25.582]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.583] getGlobalsAndPackages() ...
[10:19:25.583] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.583] Resolving globals: FALSE
[10:19:25.583] The total size of the 5 globals is 847 bytes (847 bytes)
[10:19:25.584] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:25.584] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.584] 
[10:19:25.584] getGlobalsAndPackages() ... DONE
[10:19:25.584] run() for ‘Future’ ...
[10:19:25.584] - state: ‘created’
[10:19:25.584] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.598] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.598] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.598]   - Field: ‘node’
[10:19:25.598]   - Field: ‘label’
[10:19:25.598]   - Field: ‘local’
[10:19:25.598]   - Field: ‘owner’
[10:19:25.599]   - Field: ‘envir’
[10:19:25.599]   - Field: ‘workers’
[10:19:25.599]   - Field: ‘packages’
[10:19:25.599]   - Field: ‘gc’
[10:19:25.599]   - Field: ‘conditions’
[10:19:25.599]   - Field: ‘persistent’
[10:19:25.599]   - Field: ‘expr’
[10:19:25.599]   - Field: ‘uuid’
[10:19:25.599]   - Field: ‘seed’
[10:19:25.599]   - Field: ‘version’
[10:19:25.599]   - Field: ‘result’
[10:19:25.599]   - Field: ‘asynchronous’
[10:19:25.600]   - Field: ‘calls’
[10:19:25.600]   - Field: ‘globals’
[10:19:25.600]   - Field: ‘stdout’
[10:19:25.600]   - Field: ‘earlySignal’
[10:19:25.600]   - Field: ‘lazy’
[10:19:25.600]   - Field: ‘state’
[10:19:25.600] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.600] - Launch lazy future ...
[10:19:25.600] Packages needed by the future expression (n = 0): <none>
[10:19:25.601] Packages needed by future strategies (n = 0): <none>
[10:19:25.601] {
[10:19:25.601]     {
[10:19:25.601]         {
[10:19:25.601]             ...future.startTime <- base::Sys.time()
[10:19:25.601]             {
[10:19:25.601]                 {
[10:19:25.601]                   {
[10:19:25.601]                     {
[10:19:25.601]                       base::local({
[10:19:25.601]                         has_future <- base::requireNamespace("future", 
[10:19:25.601]                           quietly = TRUE)
[10:19:25.601]                         if (has_future) {
[10:19:25.601]                           ns <- base::getNamespace("future")
[10:19:25.601]                           version <- ns[[".package"]][["version"]]
[10:19:25.601]                           if (is.null(version)) 
[10:19:25.601]                             version <- utils::packageVersion("future")
[10:19:25.601]                         }
[10:19:25.601]                         else {
[10:19:25.601]                           version <- NULL
[10:19:25.601]                         }
[10:19:25.601]                         if (!has_future || version < "1.8.0") {
[10:19:25.601]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.601]                             "", base::R.version$version.string), 
[10:19:25.601]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.601]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.601]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.601]                               "release", "version")], collapse = " "), 
[10:19:25.601]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.601]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.601]                             info)
[10:19:25.601]                           info <- base::paste(info, collapse = "; ")
[10:19:25.601]                           if (!has_future) {
[10:19:25.601]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.601]                               info)
[10:19:25.601]                           }
[10:19:25.601]                           else {
[10:19:25.601]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.601]                               info, version)
[10:19:25.601]                           }
[10:19:25.601]                           base::stop(msg)
[10:19:25.601]                         }
[10:19:25.601]                       })
[10:19:25.601]                     }
[10:19:25.601]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.601]                     base::options(mc.cores = 1L)
[10:19:25.601]                   }
[10:19:25.601]                   ...future.strategy.old <- future::plan("list")
[10:19:25.601]                   options(future.plan = NULL)
[10:19:25.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.601]                 }
[10:19:25.601]                 ...future.workdir <- getwd()
[10:19:25.601]             }
[10:19:25.601]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.601]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.601]         }
[10:19:25.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.601]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:19:25.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.601]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.601]             base::names(...future.oldOptions))
[10:19:25.601]     }
[10:19:25.601]     if (FALSE) {
[10:19:25.601]     }
[10:19:25.601]     else {
[10:19:25.601]         if (TRUE) {
[10:19:25.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.601]                 open = "w")
[10:19:25.601]         }
[10:19:25.601]         else {
[10:19:25.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.601]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.601]         }
[10:19:25.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.601]             base::sink(type = "output", split = FALSE)
[10:19:25.601]             base::close(...future.stdout)
[10:19:25.601]         }, add = TRUE)
[10:19:25.601]     }
[10:19:25.601]     ...future.frame <- base::sys.nframe()
[10:19:25.601]     ...future.conditions <- base::list()
[10:19:25.601]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.601]     if (FALSE) {
[10:19:25.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.601]     }
[10:19:25.601]     ...future.result <- base::tryCatch({
[10:19:25.601]         base::withCallingHandlers({
[10:19:25.601]             ...future.value <- base::withVisible(base::local({
[10:19:25.601]                 ...future.makeSendCondition <- base::local({
[10:19:25.601]                   sendCondition <- NULL
[10:19:25.601]                   function(frame = 1L) {
[10:19:25.601]                     if (is.function(sendCondition)) 
[10:19:25.601]                       return(sendCondition)
[10:19:25.601]                     ns <- getNamespace("parallel")
[10:19:25.601]                     if (exists("sendData", mode = "function", 
[10:19:25.601]                       envir = ns)) {
[10:19:25.601]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.601]                         envir = ns)
[10:19:25.601]                       envir <- sys.frame(frame)
[10:19:25.601]                       master <- NULL
[10:19:25.601]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.601]                         !identical(envir, emptyenv())) {
[10:19:25.601]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.601]                           inherits = FALSE)) {
[10:19:25.601]                           master <- get("master", mode = "list", 
[10:19:25.601]                             envir = envir, inherits = FALSE)
[10:19:25.601]                           if (inherits(master, c("SOCKnode", 
[10:19:25.601]                             "SOCK0node"))) {
[10:19:25.601]                             sendCondition <<- function(cond) {
[10:19:25.601]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.601]                                 success = TRUE)
[10:19:25.601]                               parallel_sendData(master, data)
[10:19:25.601]                             }
[10:19:25.601]                             return(sendCondition)
[10:19:25.601]                           }
[10:19:25.601]                         }
[10:19:25.601]                         frame <- frame + 1L
[10:19:25.601]                         envir <- sys.frame(frame)
[10:19:25.601]                       }
[10:19:25.601]                     }
[10:19:25.601]                     sendCondition <<- function(cond) NULL
[10:19:25.601]                   }
[10:19:25.601]                 })
[10:19:25.601]                 withCallingHandlers({
[10:19:25.601]                   {
[10:19:25.601]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.601]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.601]                       ...future.globals.maxSize)) {
[10:19:25.601]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.601]                       on.exit(options(oopts), add = TRUE)
[10:19:25.601]                     }
[10:19:25.601]                     {
[10:19:25.601]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.601]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.601]                         USE.NAMES = FALSE)
[10:19:25.601]                       do.call(mapply, args = args)
[10:19:25.601]                     }
[10:19:25.601]                   }
[10:19:25.601]                 }, immediateCondition = function(cond) {
[10:19:25.601]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.601]                   sendCondition(cond)
[10:19:25.601]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.601]                   {
[10:19:25.601]                     inherits <- base::inherits
[10:19:25.601]                     invokeRestart <- base::invokeRestart
[10:19:25.601]                     is.null <- base::is.null
[10:19:25.601]                     muffled <- FALSE
[10:19:25.601]                     if (inherits(cond, "message")) {
[10:19:25.601]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.601]                       if (muffled) 
[10:19:25.601]                         invokeRestart("muffleMessage")
[10:19:25.601]                     }
[10:19:25.601]                     else if (inherits(cond, "warning")) {
[10:19:25.601]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.601]                       if (muffled) 
[10:19:25.601]                         invokeRestart("muffleWarning")
[10:19:25.601]                     }
[10:19:25.601]                     else if (inherits(cond, "condition")) {
[10:19:25.601]                       if (!is.null(pattern)) {
[10:19:25.601]                         computeRestarts <- base::computeRestarts
[10:19:25.601]                         grepl <- base::grepl
[10:19:25.601]                         restarts <- computeRestarts(cond)
[10:19:25.601]                         for (restart in restarts) {
[10:19:25.601]                           name <- restart$name
[10:19:25.601]                           if (is.null(name)) 
[10:19:25.601]                             next
[10:19:25.601]                           if (!grepl(pattern, name)) 
[10:19:25.601]                             next
[10:19:25.601]                           invokeRestart(restart)
[10:19:25.601]                           muffled <- TRUE
[10:19:25.601]                           break
[10:19:25.601]                         }
[10:19:25.601]                       }
[10:19:25.601]                     }
[10:19:25.601]                     invisible(muffled)
[10:19:25.601]                   }
[10:19:25.601]                   muffleCondition(cond)
[10:19:25.601]                 })
[10:19:25.601]             }))
[10:19:25.601]             future::FutureResult(value = ...future.value$value, 
[10:19:25.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.601]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.601]                     ...future.globalenv.names))
[10:19:25.601]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.601]         }, condition = base::local({
[10:19:25.601]             c <- base::c
[10:19:25.601]             inherits <- base::inherits
[10:19:25.601]             invokeRestart <- base::invokeRestart
[10:19:25.601]             length <- base::length
[10:19:25.601]             list <- base::list
[10:19:25.601]             seq.int <- base::seq.int
[10:19:25.601]             signalCondition <- base::signalCondition
[10:19:25.601]             sys.calls <- base::sys.calls
[10:19:25.601]             `[[` <- base::`[[`
[10:19:25.601]             `+` <- base::`+`
[10:19:25.601]             `<<-` <- base::`<<-`
[10:19:25.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.601]                   3L)]
[10:19:25.601]             }
[10:19:25.601]             function(cond) {
[10:19:25.601]                 is_error <- inherits(cond, "error")
[10:19:25.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.601]                   NULL)
[10:19:25.601]                 if (is_error) {
[10:19:25.601]                   sessionInformation <- function() {
[10:19:25.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.601]                       search = base::search(), system = base::Sys.info())
[10:19:25.601]                   }
[10:19:25.601]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.601]                     cond$call), session = sessionInformation(), 
[10:19:25.601]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.601]                   signalCondition(cond)
[10:19:25.601]                 }
[10:19:25.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.601]                 "immediateCondition"))) {
[10:19:25.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.601]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.601]                   if (TRUE && !signal) {
[10:19:25.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.601]                     {
[10:19:25.601]                       inherits <- base::inherits
[10:19:25.601]                       invokeRestart <- base::invokeRestart
[10:19:25.601]                       is.null <- base::is.null
[10:19:25.601]                       muffled <- FALSE
[10:19:25.601]                       if (inherits(cond, "message")) {
[10:19:25.601]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.601]                         if (muffled) 
[10:19:25.601]                           invokeRestart("muffleMessage")
[10:19:25.601]                       }
[10:19:25.601]                       else if (inherits(cond, "warning")) {
[10:19:25.601]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.601]                         if (muffled) 
[10:19:25.601]                           invokeRestart("muffleWarning")
[10:19:25.601]                       }
[10:19:25.601]                       else if (inherits(cond, "condition")) {
[10:19:25.601]                         if (!is.null(pattern)) {
[10:19:25.601]                           computeRestarts <- base::computeRestarts
[10:19:25.601]                           grepl <- base::grepl
[10:19:25.601]                           restarts <- computeRestarts(cond)
[10:19:25.601]                           for (restart in restarts) {
[10:19:25.601]                             name <- restart$name
[10:19:25.601]                             if (is.null(name)) 
[10:19:25.601]                               next
[10:19:25.601]                             if (!grepl(pattern, name)) 
[10:19:25.601]                               next
[10:19:25.601]                             invokeRestart(restart)
[10:19:25.601]                             muffled <- TRUE
[10:19:25.601]                             break
[10:19:25.601]                           }
[10:19:25.601]                         }
[10:19:25.601]                       }
[10:19:25.601]                       invisible(muffled)
[10:19:25.601]                     }
[10:19:25.601]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.601]                   }
[10:19:25.601]                 }
[10:19:25.601]                 else {
[10:19:25.601]                   if (TRUE) {
[10:19:25.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.601]                     {
[10:19:25.601]                       inherits <- base::inherits
[10:19:25.601]                       invokeRestart <- base::invokeRestart
[10:19:25.601]                       is.null <- base::is.null
[10:19:25.601]                       muffled <- FALSE
[10:19:25.601]                       if (inherits(cond, "message")) {
[10:19:25.601]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.601]                         if (muffled) 
[10:19:25.601]                           invokeRestart("muffleMessage")
[10:19:25.601]                       }
[10:19:25.601]                       else if (inherits(cond, "warning")) {
[10:19:25.601]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.601]                         if (muffled) 
[10:19:25.601]                           invokeRestart("muffleWarning")
[10:19:25.601]                       }
[10:19:25.601]                       else if (inherits(cond, "condition")) {
[10:19:25.601]                         if (!is.null(pattern)) {
[10:19:25.601]                           computeRestarts <- base::computeRestarts
[10:19:25.601]                           grepl <- base::grepl
[10:19:25.601]                           restarts <- computeRestarts(cond)
[10:19:25.601]                           for (restart in restarts) {
[10:19:25.601]                             name <- restart$name
[10:19:25.601]                             if (is.null(name)) 
[10:19:25.601]                               next
[10:19:25.601]                             if (!grepl(pattern, name)) 
[10:19:25.601]                               next
[10:19:25.601]                             invokeRestart(restart)
[10:19:25.601]                             muffled <- TRUE
[10:19:25.601]                             break
[10:19:25.601]                           }
[10:19:25.601]                         }
[10:19:25.601]                       }
[10:19:25.601]                       invisible(muffled)
[10:19:25.601]                     }
[10:19:25.601]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.601]                   }
[10:19:25.601]                 }
[10:19:25.601]             }
[10:19:25.601]         }))
[10:19:25.601]     }, error = function(ex) {
[10:19:25.601]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.601]                 ...future.rng), started = ...future.startTime, 
[10:19:25.601]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.601]             version = "1.8"), class = "FutureResult")
[10:19:25.601]     }, finally = {
[10:19:25.601]         if (!identical(...future.workdir, getwd())) 
[10:19:25.601]             setwd(...future.workdir)
[10:19:25.601]         {
[10:19:25.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.601]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.601]             }
[10:19:25.601]             base::options(...future.oldOptions)
[10:19:25.601]             if (.Platform$OS.type == "windows") {
[10:19:25.601]                 old_names <- names(...future.oldEnvVars)
[10:19:25.601]                 envs <- base::Sys.getenv()
[10:19:25.601]                 names <- names(envs)
[10:19:25.601]                 common <- intersect(names, old_names)
[10:19:25.601]                 added <- setdiff(names, old_names)
[10:19:25.601]                 removed <- setdiff(old_names, names)
[10:19:25.601]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.601]                   envs[common]]
[10:19:25.601]                 NAMES <- toupper(changed)
[10:19:25.601]                 args <- list()
[10:19:25.601]                 for (kk in seq_along(NAMES)) {
[10:19:25.601]                   name <- changed[[kk]]
[10:19:25.601]                   NAME <- NAMES[[kk]]
[10:19:25.601]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.601]                     next
[10:19:25.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.601]                 }
[10:19:25.601]                 NAMES <- toupper(added)
[10:19:25.601]                 for (kk in seq_along(NAMES)) {
[10:19:25.601]                   name <- added[[kk]]
[10:19:25.601]                   NAME <- NAMES[[kk]]
[10:19:25.601]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.601]                     next
[10:19:25.601]                   args[[name]] <- ""
[10:19:25.601]                 }
[10:19:25.601]                 NAMES <- toupper(removed)
[10:19:25.601]                 for (kk in seq_along(NAMES)) {
[10:19:25.601]                   name <- removed[[kk]]
[10:19:25.601]                   NAME <- NAMES[[kk]]
[10:19:25.601]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.601]                     next
[10:19:25.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.601]                 }
[10:19:25.601]                 if (length(args) > 0) 
[10:19:25.601]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.601]             }
[10:19:25.601]             else {
[10:19:25.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.601]             }
[10:19:25.601]             {
[10:19:25.601]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.601]                   0L) {
[10:19:25.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.601]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.601]                   base::options(opts)
[10:19:25.601]                 }
[10:19:25.601]                 {
[10:19:25.601]                   {
[10:19:25.601]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.601]                     NULL
[10:19:25.601]                   }
[10:19:25.601]                   options(future.plan = NULL)
[10:19:25.601]                   if (is.na(NA_character_)) 
[10:19:25.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.601]                     .init = FALSE)
[10:19:25.601]                 }
[10:19:25.601]             }
[10:19:25.601]         }
[10:19:25.601]     })
[10:19:25.601]     if (TRUE) {
[10:19:25.601]         base::sink(type = "output", split = FALSE)
[10:19:25.601]         if (TRUE) {
[10:19:25.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.601]         }
[10:19:25.601]         else {
[10:19:25.601]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.601]         }
[10:19:25.601]         base::close(...future.stdout)
[10:19:25.601]         ...future.stdout <- NULL
[10:19:25.601]     }
[10:19:25.601]     ...future.result$conditions <- ...future.conditions
[10:19:25.601]     ...future.result$finished <- base::Sys.time()
[10:19:25.601]     ...future.result
[10:19:25.601] }
[10:19:25.604] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[10:19:25.604] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:19:25.604] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:19:25.604] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:25.605] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.605] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ...
[10:19:25.605] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ... DONE
[10:19:25.605] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:25.606] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.606] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:25.606] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.606] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[10:19:25.607] MultisessionFuture started
[10:19:25.607] - Launch lazy future ... done
[10:19:25.607] run() for ‘MultisessionFuture’ ... done
[10:19:25.607] Created future:
[10:19:25.607] MultisessionFuture:
[10:19:25.607] Label: ‘future_mapply-2’
[10:19:25.607] Expression:
[10:19:25.607] {
[10:19:25.607]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.607]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.607]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.607]         on.exit(options(oopts), add = TRUE)
[10:19:25.607]     }
[10:19:25.607]     {
[10:19:25.607]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.607]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.607]         do.call(mapply, args = args)
[10:19:25.607]     }
[10:19:25.607] }
[10:19:25.607] Lazy evaluation: FALSE
[10:19:25.607] Asynchronous evaluation: TRUE
[10:19:25.607] Local evaluation: TRUE
[10:19:25.607] Environment: R_GlobalEnv
[10:19:25.607] Capture standard output: TRUE
[10:19:25.607] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.607] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.607] Packages: <none>
[10:19:25.607] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.607] Resolved: FALSE
[10:19:25.607] Value: <not collected>
[10:19:25.607] Conditions captured: <none>
[10:19:25.607] Early signaling: FALSE
[10:19:25.607] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.607] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.618] Chunk #2 of 3 ... DONE
[10:19:25.618] Chunk #3 of 3 ...
[10:19:25.619]  - Finding globals in '...' for chunk #3 ...
[10:19:25.619] getGlobalsAndPackages() ...
[10:19:25.619] Searching for globals...
[10:19:25.619] 
[10:19:25.619] Searching for globals ... DONE
[10:19:25.619] - globals: [0] <none>
[10:19:25.619] getGlobalsAndPackages() ... DONE
[10:19:25.619]    + additional globals found: [n=0] 
[10:19:25.619]    + additional namespaces needed: [n=0] 
[10:19:25.620]  - Finding globals in '...' for chunk #3 ... DONE
[10:19:25.620]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[10:19:25.620]  - seeds: <none>
[10:19:25.620]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.620] getGlobalsAndPackages() ...
[10:19:25.620] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.620] Resolving globals: FALSE
[10:19:25.620] The total size of the 5 globals is 876 bytes (876 bytes)
[10:19:25.621] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:25.621] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.621] 
[10:19:25.621] getGlobalsAndPackages() ... DONE
[10:19:25.621] run() for ‘Future’ ...
[10:19:25.622] - state: ‘created’
[10:19:25.622] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.635] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.635] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.635]   - Field: ‘node’
[10:19:25.636]   - Field: ‘label’
[10:19:25.636]   - Field: ‘local’
[10:19:25.636]   - Field: ‘owner’
[10:19:25.636]   - Field: ‘envir’
[10:19:25.636]   - Field: ‘workers’
[10:19:25.636]   - Field: ‘packages’
[10:19:25.636]   - Field: ‘gc’
[10:19:25.636]   - Field: ‘conditions’
[10:19:25.636]   - Field: ‘persistent’
[10:19:25.636]   - Field: ‘expr’
[10:19:25.636]   - Field: ‘uuid’
[10:19:25.636]   - Field: ‘seed’
[10:19:25.637]   - Field: ‘version’
[10:19:25.637]   - Field: ‘result’
[10:19:25.637]   - Field: ‘asynchronous’
[10:19:25.637]   - Field: ‘calls’
[10:19:25.637]   - Field: ‘globals’
[10:19:25.637]   - Field: ‘stdout’
[10:19:25.637]   - Field: ‘earlySignal’
[10:19:25.637]   - Field: ‘lazy’
[10:19:25.637]   - Field: ‘state’
[10:19:25.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.637] - Launch lazy future ...
[10:19:25.638] Packages needed by the future expression (n = 0): <none>
[10:19:25.638] Packages needed by future strategies (n = 0): <none>
[10:19:25.638] {
[10:19:25.638]     {
[10:19:25.638]         {
[10:19:25.638]             ...future.startTime <- base::Sys.time()
[10:19:25.638]             {
[10:19:25.638]                 {
[10:19:25.638]                   {
[10:19:25.638]                     {
[10:19:25.638]                       base::local({
[10:19:25.638]                         has_future <- base::requireNamespace("future", 
[10:19:25.638]                           quietly = TRUE)
[10:19:25.638]                         if (has_future) {
[10:19:25.638]                           ns <- base::getNamespace("future")
[10:19:25.638]                           version <- ns[[".package"]][["version"]]
[10:19:25.638]                           if (is.null(version)) 
[10:19:25.638]                             version <- utils::packageVersion("future")
[10:19:25.638]                         }
[10:19:25.638]                         else {
[10:19:25.638]                           version <- NULL
[10:19:25.638]                         }
[10:19:25.638]                         if (!has_future || version < "1.8.0") {
[10:19:25.638]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.638]                             "", base::R.version$version.string), 
[10:19:25.638]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.638]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.638]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.638]                               "release", "version")], collapse = " "), 
[10:19:25.638]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.638]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.638]                             info)
[10:19:25.638]                           info <- base::paste(info, collapse = "; ")
[10:19:25.638]                           if (!has_future) {
[10:19:25.638]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.638]                               info)
[10:19:25.638]                           }
[10:19:25.638]                           else {
[10:19:25.638]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.638]                               info, version)
[10:19:25.638]                           }
[10:19:25.638]                           base::stop(msg)
[10:19:25.638]                         }
[10:19:25.638]                       })
[10:19:25.638]                     }
[10:19:25.638]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.638]                     base::options(mc.cores = 1L)
[10:19:25.638]                   }
[10:19:25.638]                   ...future.strategy.old <- future::plan("list")
[10:19:25.638]                   options(future.plan = NULL)
[10:19:25.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.638]                 }
[10:19:25.638]                 ...future.workdir <- getwd()
[10:19:25.638]             }
[10:19:25.638]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.638]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.638]         }
[10:19:25.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.638]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[10:19:25.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.638]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.638]             base::names(...future.oldOptions))
[10:19:25.638]     }
[10:19:25.638]     if (FALSE) {
[10:19:25.638]     }
[10:19:25.638]     else {
[10:19:25.638]         if (TRUE) {
[10:19:25.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.638]                 open = "w")
[10:19:25.638]         }
[10:19:25.638]         else {
[10:19:25.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.638]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.638]         }
[10:19:25.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.638]             base::sink(type = "output", split = FALSE)
[10:19:25.638]             base::close(...future.stdout)
[10:19:25.638]         }, add = TRUE)
[10:19:25.638]     }
[10:19:25.638]     ...future.frame <- base::sys.nframe()
[10:19:25.638]     ...future.conditions <- base::list()
[10:19:25.638]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.638]     if (FALSE) {
[10:19:25.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.638]     }
[10:19:25.638]     ...future.result <- base::tryCatch({
[10:19:25.638]         base::withCallingHandlers({
[10:19:25.638]             ...future.value <- base::withVisible(base::local({
[10:19:25.638]                 ...future.makeSendCondition <- base::local({
[10:19:25.638]                   sendCondition <- NULL
[10:19:25.638]                   function(frame = 1L) {
[10:19:25.638]                     if (is.function(sendCondition)) 
[10:19:25.638]                       return(sendCondition)
[10:19:25.638]                     ns <- getNamespace("parallel")
[10:19:25.638]                     if (exists("sendData", mode = "function", 
[10:19:25.638]                       envir = ns)) {
[10:19:25.638]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.638]                         envir = ns)
[10:19:25.638]                       envir <- sys.frame(frame)
[10:19:25.638]                       master <- NULL
[10:19:25.638]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.638]                         !identical(envir, emptyenv())) {
[10:19:25.638]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.638]                           inherits = FALSE)) {
[10:19:25.638]                           master <- get("master", mode = "list", 
[10:19:25.638]                             envir = envir, inherits = FALSE)
[10:19:25.638]                           if (inherits(master, c("SOCKnode", 
[10:19:25.638]                             "SOCK0node"))) {
[10:19:25.638]                             sendCondition <<- function(cond) {
[10:19:25.638]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.638]                                 success = TRUE)
[10:19:25.638]                               parallel_sendData(master, data)
[10:19:25.638]                             }
[10:19:25.638]                             return(sendCondition)
[10:19:25.638]                           }
[10:19:25.638]                         }
[10:19:25.638]                         frame <- frame + 1L
[10:19:25.638]                         envir <- sys.frame(frame)
[10:19:25.638]                       }
[10:19:25.638]                     }
[10:19:25.638]                     sendCondition <<- function(cond) NULL
[10:19:25.638]                   }
[10:19:25.638]                 })
[10:19:25.638]                 withCallingHandlers({
[10:19:25.638]                   {
[10:19:25.638]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.638]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.638]                       ...future.globals.maxSize)) {
[10:19:25.638]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.638]                       on.exit(options(oopts), add = TRUE)
[10:19:25.638]                     }
[10:19:25.638]                     {
[10:19:25.638]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.638]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.638]                         USE.NAMES = FALSE)
[10:19:25.638]                       do.call(mapply, args = args)
[10:19:25.638]                     }
[10:19:25.638]                   }
[10:19:25.638]                 }, immediateCondition = function(cond) {
[10:19:25.638]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.638]                   sendCondition(cond)
[10:19:25.638]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.638]                   {
[10:19:25.638]                     inherits <- base::inherits
[10:19:25.638]                     invokeRestart <- base::invokeRestart
[10:19:25.638]                     is.null <- base::is.null
[10:19:25.638]                     muffled <- FALSE
[10:19:25.638]                     if (inherits(cond, "message")) {
[10:19:25.638]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.638]                       if (muffled) 
[10:19:25.638]                         invokeRestart("muffleMessage")
[10:19:25.638]                     }
[10:19:25.638]                     else if (inherits(cond, "warning")) {
[10:19:25.638]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.638]                       if (muffled) 
[10:19:25.638]                         invokeRestart("muffleWarning")
[10:19:25.638]                     }
[10:19:25.638]                     else if (inherits(cond, "condition")) {
[10:19:25.638]                       if (!is.null(pattern)) {
[10:19:25.638]                         computeRestarts <- base::computeRestarts
[10:19:25.638]                         grepl <- base::grepl
[10:19:25.638]                         restarts <- computeRestarts(cond)
[10:19:25.638]                         for (restart in restarts) {
[10:19:25.638]                           name <- restart$name
[10:19:25.638]                           if (is.null(name)) 
[10:19:25.638]                             next
[10:19:25.638]                           if (!grepl(pattern, name)) 
[10:19:25.638]                             next
[10:19:25.638]                           invokeRestart(restart)
[10:19:25.638]                           muffled <- TRUE
[10:19:25.638]                           break
[10:19:25.638]                         }
[10:19:25.638]                       }
[10:19:25.638]                     }
[10:19:25.638]                     invisible(muffled)
[10:19:25.638]                   }
[10:19:25.638]                   muffleCondition(cond)
[10:19:25.638]                 })
[10:19:25.638]             }))
[10:19:25.638]             future::FutureResult(value = ...future.value$value, 
[10:19:25.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.638]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.638]                     ...future.globalenv.names))
[10:19:25.638]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.638]         }, condition = base::local({
[10:19:25.638]             c <- base::c
[10:19:25.638]             inherits <- base::inherits
[10:19:25.638]             invokeRestart <- base::invokeRestart
[10:19:25.638]             length <- base::length
[10:19:25.638]             list <- base::list
[10:19:25.638]             seq.int <- base::seq.int
[10:19:25.638]             signalCondition <- base::signalCondition
[10:19:25.638]             sys.calls <- base::sys.calls
[10:19:25.638]             `[[` <- base::`[[`
[10:19:25.638]             `+` <- base::`+`
[10:19:25.638]             `<<-` <- base::`<<-`
[10:19:25.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.638]                   3L)]
[10:19:25.638]             }
[10:19:25.638]             function(cond) {
[10:19:25.638]                 is_error <- inherits(cond, "error")
[10:19:25.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.638]                   NULL)
[10:19:25.638]                 if (is_error) {
[10:19:25.638]                   sessionInformation <- function() {
[10:19:25.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.638]                       search = base::search(), system = base::Sys.info())
[10:19:25.638]                   }
[10:19:25.638]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.638]                     cond$call), session = sessionInformation(), 
[10:19:25.638]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.638]                   signalCondition(cond)
[10:19:25.638]                 }
[10:19:25.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.638]                 "immediateCondition"))) {
[10:19:25.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.638]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.638]                   if (TRUE && !signal) {
[10:19:25.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.638]                     {
[10:19:25.638]                       inherits <- base::inherits
[10:19:25.638]                       invokeRestart <- base::invokeRestart
[10:19:25.638]                       is.null <- base::is.null
[10:19:25.638]                       muffled <- FALSE
[10:19:25.638]                       if (inherits(cond, "message")) {
[10:19:25.638]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.638]                         if (muffled) 
[10:19:25.638]                           invokeRestart("muffleMessage")
[10:19:25.638]                       }
[10:19:25.638]                       else if (inherits(cond, "warning")) {
[10:19:25.638]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.638]                         if (muffled) 
[10:19:25.638]                           invokeRestart("muffleWarning")
[10:19:25.638]                       }
[10:19:25.638]                       else if (inherits(cond, "condition")) {
[10:19:25.638]                         if (!is.null(pattern)) {
[10:19:25.638]                           computeRestarts <- base::computeRestarts
[10:19:25.638]                           grepl <- base::grepl
[10:19:25.638]                           restarts <- computeRestarts(cond)
[10:19:25.638]                           for (restart in restarts) {
[10:19:25.638]                             name <- restart$name
[10:19:25.638]                             if (is.null(name)) 
[10:19:25.638]                               next
[10:19:25.638]                             if (!grepl(pattern, name)) 
[10:19:25.638]                               next
[10:19:25.638]                             invokeRestart(restart)
[10:19:25.638]                             muffled <- TRUE
[10:19:25.638]                             break
[10:19:25.638]                           }
[10:19:25.638]                         }
[10:19:25.638]                       }
[10:19:25.638]                       invisible(muffled)
[10:19:25.638]                     }
[10:19:25.638]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.638]                   }
[10:19:25.638]                 }
[10:19:25.638]                 else {
[10:19:25.638]                   if (TRUE) {
[10:19:25.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.638]                     {
[10:19:25.638]                       inherits <- base::inherits
[10:19:25.638]                       invokeRestart <- base::invokeRestart
[10:19:25.638]                       is.null <- base::is.null
[10:19:25.638]                       muffled <- FALSE
[10:19:25.638]                       if (inherits(cond, "message")) {
[10:19:25.638]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.638]                         if (muffled) 
[10:19:25.638]                           invokeRestart("muffleMessage")
[10:19:25.638]                       }
[10:19:25.638]                       else if (inherits(cond, "warning")) {
[10:19:25.638]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.638]                         if (muffled) 
[10:19:25.638]                           invokeRestart("muffleWarning")
[10:19:25.638]                       }
[10:19:25.638]                       else if (inherits(cond, "condition")) {
[10:19:25.638]                         if (!is.null(pattern)) {
[10:19:25.638]                           computeRestarts <- base::computeRestarts
[10:19:25.638]                           grepl <- base::grepl
[10:19:25.638]                           restarts <- computeRestarts(cond)
[10:19:25.638]                           for (restart in restarts) {
[10:19:25.638]                             name <- restart$name
[10:19:25.638]                             if (is.null(name)) 
[10:19:25.638]                               next
[10:19:25.638]                             if (!grepl(pattern, name)) 
[10:19:25.638]                               next
[10:19:25.638]                             invokeRestart(restart)
[10:19:25.638]                             muffled <- TRUE
[10:19:25.638]                             break
[10:19:25.638]                           }
[10:19:25.638]                         }
[10:19:25.638]                       }
[10:19:25.638]                       invisible(muffled)
[10:19:25.638]                     }
[10:19:25.638]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.638]                   }
[10:19:25.638]                 }
[10:19:25.638]             }
[10:19:25.638]         }))
[10:19:25.638]     }, error = function(ex) {
[10:19:25.638]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.638]                 ...future.rng), started = ...future.startTime, 
[10:19:25.638]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.638]             version = "1.8"), class = "FutureResult")
[10:19:25.638]     }, finally = {
[10:19:25.638]         if (!identical(...future.workdir, getwd())) 
[10:19:25.638]             setwd(...future.workdir)
[10:19:25.638]         {
[10:19:25.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.638]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.638]             }
[10:19:25.638]             base::options(...future.oldOptions)
[10:19:25.638]             if (.Platform$OS.type == "windows") {
[10:19:25.638]                 old_names <- names(...future.oldEnvVars)
[10:19:25.638]                 envs <- base::Sys.getenv()
[10:19:25.638]                 names <- names(envs)
[10:19:25.638]                 common <- intersect(names, old_names)
[10:19:25.638]                 added <- setdiff(names, old_names)
[10:19:25.638]                 removed <- setdiff(old_names, names)
[10:19:25.638]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.638]                   envs[common]]
[10:19:25.638]                 NAMES <- toupper(changed)
[10:19:25.638]                 args <- list()
[10:19:25.638]                 for (kk in seq_along(NAMES)) {
[10:19:25.638]                   name <- changed[[kk]]
[10:19:25.638]                   NAME <- NAMES[[kk]]
[10:19:25.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.638]                     next
[10:19:25.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.638]                 }
[10:19:25.638]                 NAMES <- toupper(added)
[10:19:25.638]                 for (kk in seq_along(NAMES)) {
[10:19:25.638]                   name <- added[[kk]]
[10:19:25.638]                   NAME <- NAMES[[kk]]
[10:19:25.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.638]                     next
[10:19:25.638]                   args[[name]] <- ""
[10:19:25.638]                 }
[10:19:25.638]                 NAMES <- toupper(removed)
[10:19:25.638]                 for (kk in seq_along(NAMES)) {
[10:19:25.638]                   name <- removed[[kk]]
[10:19:25.638]                   NAME <- NAMES[[kk]]
[10:19:25.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.638]                     next
[10:19:25.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.638]                 }
[10:19:25.638]                 if (length(args) > 0) 
[10:19:25.638]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.638]             }
[10:19:25.638]             else {
[10:19:25.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.638]             }
[10:19:25.638]             {
[10:19:25.638]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.638]                   0L) {
[10:19:25.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.638]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.638]                   base::options(opts)
[10:19:25.638]                 }
[10:19:25.638]                 {
[10:19:25.638]                   {
[10:19:25.638]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.638]                     NULL
[10:19:25.638]                   }
[10:19:25.638]                   options(future.plan = NULL)
[10:19:25.638]                   if (is.na(NA_character_)) 
[10:19:25.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.638]                     .init = FALSE)
[10:19:25.638]                 }
[10:19:25.638]             }
[10:19:25.638]         }
[10:19:25.638]     })
[10:19:25.638]     if (TRUE) {
[10:19:25.638]         base::sink(type = "output", split = FALSE)
[10:19:25.638]         if (TRUE) {
[10:19:25.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.638]         }
[10:19:25.638]         else {
[10:19:25.638]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.638]         }
[10:19:25.638]         base::close(...future.stdout)
[10:19:25.638]         ...future.stdout <- NULL
[10:19:25.638]     }
[10:19:25.638]     ...future.result$conditions <- ...future.conditions
[10:19:25.638]     ...future.result$finished <- base::Sys.time()
[10:19:25.638]     ...future.result
[10:19:25.638] }
[10:19:25.640] Poll #1 (0): usedNodes() = 2, workers = 2
[10:19:25.651] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.651] - Validating connection of MultisessionFuture
[10:19:25.651] - received message: FutureResult
[10:19:25.651] - Received FutureResult
[10:19:25.652] - Erased future from FutureRegistry
[10:19:25.652] result() for ClusterFuture ...
[10:19:25.652] - result already collected: FutureResult
[10:19:25.652] result() for ClusterFuture ... done
[10:19:25.652] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.652] result() for ClusterFuture ...
[10:19:25.652] - result already collected: FutureResult
[10:19:25.652] result() for ClusterFuture ... done
[10:19:25.652] result() for ClusterFuture ...
[10:19:25.652] - result already collected: FutureResult
[10:19:25.652] result() for ClusterFuture ... done
[10:19:25.653] Exporting 5 global objects (1.29 KiB) to cluster node #1 ...
[10:19:25.653] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:19:25.654] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:19:25.654] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:25.654] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.654] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:19:25.654] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:19:25.655] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:25.655] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.655] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:25.655] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.656] Exporting 5 global objects (1.29 KiB) to cluster node #1 ... DONE
[10:19:25.656] MultisessionFuture started
[10:19:25.656] - Launch lazy future ... done
[10:19:25.656] run() for ‘MultisessionFuture’ ... done
[10:19:25.656] Created future:
[10:19:25.656] MultisessionFuture:
[10:19:25.656] Label: ‘future_mapply-3’
[10:19:25.656] Expression:
[10:19:25.656] {
[10:19:25.656]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.656]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.656]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.656]         on.exit(options(oopts), add = TRUE)
[10:19:25.656]     }
[10:19:25.656]     {
[10:19:25.656]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.656]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.656]         do.call(mapply, args = args)
[10:19:25.656]     }
[10:19:25.656] }
[10:19:25.656] Lazy evaluation: FALSE
[10:19:25.656] Asynchronous evaluation: TRUE
[10:19:25.656] Local evaluation: TRUE
[10:19:25.656] Environment: R_GlobalEnv
[10:19:25.656] Capture standard output: TRUE
[10:19:25.656] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.656] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.656] Packages: <none>
[10:19:25.656] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.656] Resolved: FALSE
[10:19:25.656] Value: <not collected>
[10:19:25.656] Conditions captured: <none>
[10:19:25.656] Early signaling: FALSE
[10:19:25.656] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.656] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.668] Chunk #3 of 3 ... DONE
[10:19:25.668] Launching 3 futures (chunks) ... DONE
[10:19:25.668] Resolving 3 futures (chunks) ...
[10:19:25.668] resolve() on list ...
[10:19:25.668]  recursive: 0
[10:19:25.668]  length: 3
[10:19:25.668] 
[10:19:25.668] Future #1
[10:19:25.668] result() for ClusterFuture ...
[10:19:25.668] - result already collected: FutureResult
[10:19:25.669] result() for ClusterFuture ... done
[10:19:25.669] result() for ClusterFuture ...
[10:19:25.669] - result already collected: FutureResult
[10:19:25.669] result() for ClusterFuture ... done
[10:19:25.669] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:25.669] - nx: 3
[10:19:25.669] - relay: TRUE
[10:19:25.669] - stdout: TRUE
[10:19:25.669] - signal: TRUE
[10:19:25.669] - resignal: FALSE
[10:19:25.669] - force: TRUE
[10:19:25.669] - relayed: [n=3] FALSE, FALSE, FALSE
[10:19:25.669] - queued futures: [n=3] FALSE, FALSE, FALSE
[10:19:25.670]  - until=1
[10:19:25.670]  - relaying element #1
[10:19:25.670] result() for ClusterFuture ...
[10:19:25.670] - result already collected: FutureResult
[10:19:25.670] result() for ClusterFuture ... done
[10:19:25.670] result() for ClusterFuture ...
[10:19:25.670] - result already collected: FutureResult
[10:19:25.670] result() for ClusterFuture ... done
[10:19:25.670] result() for ClusterFuture ...
[10:19:25.670] - result already collected: FutureResult
[10:19:25.670] result() for ClusterFuture ... done
[10:19:25.671] result() for ClusterFuture ...
[10:19:25.671] - result already collected: FutureResult
[10:19:25.671] result() for ClusterFuture ... done
[10:19:25.671] - relayed: [n=3] TRUE, FALSE, FALSE
[10:19:25.671] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:19:25.671] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:25.671]  length: 2 (resolved future 1)
[10:19:25.671] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.672] - Validating connection of MultisessionFuture
[10:19:25.672] - received message: FutureResult
[10:19:25.672] - Received FutureResult
[10:19:25.672] - Erased future from FutureRegistry
[10:19:25.672] result() for ClusterFuture ...
[10:19:25.672] - result already collected: FutureResult
[10:19:25.672] result() for ClusterFuture ... done
[10:19:25.672] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.672] Future #2
[10:19:25.672] result() for ClusterFuture ...
[10:19:25.672] - result already collected: FutureResult
[10:19:25.673] result() for ClusterFuture ... done
[10:19:25.673] result() for ClusterFuture ...
[10:19:25.673] - result already collected: FutureResult
[10:19:25.673] result() for ClusterFuture ... done
[10:19:25.673] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:25.673] - nx: 3
[10:19:25.673] - relay: TRUE
[10:19:25.673] - stdout: TRUE
[10:19:25.673] - signal: TRUE
[10:19:25.673] - resignal: FALSE
[10:19:25.673] - force: TRUE
[10:19:25.673] - relayed: [n=3] TRUE, FALSE, FALSE
[10:19:25.673] - queued futures: [n=3] TRUE, FALSE, FALSE
[10:19:25.674]  - until=2
[10:19:25.674]  - relaying element #2
[10:19:25.674] result() for ClusterFuture ...
[10:19:25.674] - result already collected: FutureResult
[10:19:25.674] result() for ClusterFuture ... done
[10:19:25.674] result() for ClusterFuture ...
[10:19:25.674] - result already collected: FutureResult
[10:19:25.674] result() for ClusterFuture ... done
[10:19:25.674] result() for ClusterFuture ...
[10:19:25.674] - result already collected: FutureResult
[10:19:25.674] result() for ClusterFuture ... done
[10:19:25.674] result() for ClusterFuture ...
[10:19:25.675] - result already collected: FutureResult
[10:19:25.675] result() for ClusterFuture ... done
[10:19:25.675] - relayed: [n=3] TRUE, TRUE, FALSE
[10:19:25.675] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:19:25.675] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:25.675]  length: 1 (resolved future 2)
[10:19:25.698] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.698] - Validating connection of MultisessionFuture
[10:19:25.698] - received message: FutureResult
[10:19:25.698] - Received FutureResult
[10:19:25.698] - Erased future from FutureRegistry
[10:19:25.698] result() for ClusterFuture ...
[10:19:25.699] - result already collected: FutureResult
[10:19:25.699] result() for ClusterFuture ... done
[10:19:25.699] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.699] Future #3
[10:19:25.699] result() for ClusterFuture ...
[10:19:25.699] - result already collected: FutureResult
[10:19:25.699] result() for ClusterFuture ... done
[10:19:25.699] result() for ClusterFuture ...
[10:19:25.699] - result already collected: FutureResult
[10:19:25.699] result() for ClusterFuture ... done
[10:19:25.699] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:19:25.699] - nx: 3
[10:19:25.700] - relay: TRUE
[10:19:25.700] - stdout: TRUE
[10:19:25.700] - signal: TRUE
[10:19:25.700] - resignal: FALSE
[10:19:25.700] - force: TRUE
[10:19:25.700] - relayed: [n=3] TRUE, TRUE, FALSE
[10:19:25.700] - queued futures: [n=3] TRUE, TRUE, FALSE
[10:19:25.700]  - until=3
[10:19:25.700]  - relaying element #3
[10:19:25.700] result() for ClusterFuture ...
[10:19:25.700] - result already collected: FutureResult
[10:19:25.700] result() for ClusterFuture ... done
[10:19:25.700] result() for ClusterFuture ...
[10:19:25.701] - result already collected: FutureResult
[10:19:25.701] result() for ClusterFuture ... done
[10:19:25.701] result() for ClusterFuture ...
[10:19:25.701] - result already collected: FutureResult
[10:19:25.701] result() for ClusterFuture ... done
[10:19:25.701] result() for ClusterFuture ...
[10:19:25.701] - result already collected: FutureResult
[10:19:25.701] result() for ClusterFuture ... done
[10:19:25.701] - relayed: [n=3] TRUE, TRUE, TRUE
[10:19:25.701] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:19:25.701] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:19:25.702]  length: 0 (resolved future 3)
[10:19:25.702] Relaying remaining futures
[10:19:25.702] signalConditionsASAP(NULL, pos=0) ...
[10:19:25.702] - nx: 3
[10:19:25.702] - relay: TRUE
[10:19:25.702] - stdout: TRUE
[10:19:25.702] - signal: TRUE
[10:19:25.702] - resignal: FALSE
[10:19:25.702] - force: TRUE
[10:19:25.702] - relayed: [n=3] TRUE, TRUE, TRUE
[10:19:25.702] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[10:19:25.702] - relayed: [n=3] TRUE, TRUE, TRUE
[10:19:25.702] - queued futures: [n=3] TRUE, TRUE, TRUE
[10:19:25.703] signalConditionsASAP(NULL, pos=0) ... done
[10:19:25.703] resolve() on list ... DONE
[10:19:25.703] result() for ClusterFuture ...
[10:19:25.705] - result already collected: FutureResult
[10:19:25.705] result() for ClusterFuture ... done
[10:19:25.705] result() for ClusterFuture ...
[10:19:25.705] - result already collected: FutureResult
[10:19:25.705] result() for ClusterFuture ... done
[10:19:25.705] result() for ClusterFuture ...
[10:19:25.706] - result already collected: FutureResult
[10:19:25.706] result() for ClusterFuture ... done
[10:19:25.706] result() for ClusterFuture ...
[10:19:25.706] - result already collected: FutureResult
[10:19:25.706] result() for ClusterFuture ... done
[10:19:25.706] result() for ClusterFuture ...
[10:19:25.706] - result already collected: FutureResult
[10:19:25.706] result() for ClusterFuture ... done
[10:19:25.706] result() for ClusterFuture ...
[10:19:25.706] - result already collected: FutureResult
[10:19:25.706] result() for ClusterFuture ... done
[10:19:25.706]  - Number of value chunks collected: 3
[10:19:25.707] Resolving 3 futures (chunks) ... DONE
[10:19:25.707] Reducing values from 3 chunks ...
[10:19:25.707]  - Number of values collected after concatenation: 5
[10:19:25.707]  - Number of values expected: 5
[10:19:25.707] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 2, 3, 1, 4
[10:19:25.707] Reducing values from 3 chunks ... DONE
[10:19:25.707] future_mapply() ... DONE
[10:19:25.707] future_mapply() ...
[10:19:25.709] Number of chunks: 2
[10:19:25.709] getGlobalsAndPackagesXApply() ...
[10:19:25.709]  - future.globals: TRUE
[10:19:25.709] getGlobalsAndPackages() ...
[10:19:25.709] Searching for globals...
[10:19:25.710] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:25.711] Searching for globals ... DONE
[10:19:25.711] Resolving globals: FALSE
[10:19:25.711] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:25.711] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:25.712] - globals: [1] ‘FUN’
[10:19:25.712] 
[10:19:25.712] getGlobalsAndPackages() ... DONE
[10:19:25.712]  - globals found/used: [n=1] ‘FUN’
[10:19:25.712]  - needed namespaces: [n=0] 
[10:19:25.712] Finding globals ... DONE
[10:19:25.712] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:25.712] List of 2
[10:19:25.712]  $ ...future.FUN:function (C, k)  
[10:19:25.712]  $ MoreArgs     : list()
[10:19:25.712]  - attr(*, "where")=List of 2
[10:19:25.712]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:25.712]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:25.712]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:25.712]  - attr(*, "resolved")= logi FALSE
[10:19:25.712]  - attr(*, "total_size")= num NA
[10:19:25.715] Packages to be attached in all futures: [n=0] 
[10:19:25.715] getGlobalsAndPackagesXApply() ... DONE
[10:19:25.715] Number of futures (= number of chunks): 2
[10:19:25.715] Launching 2 futures (chunks) ...
[10:19:25.715] Chunk #1 of 2 ...
[10:19:25.715]  - Finding globals in '...' for chunk #1 ...
[10:19:25.715] getGlobalsAndPackages() ...
[10:19:25.715] Searching for globals...
[10:19:25.716] 
[10:19:25.716] Searching for globals ... DONE
[10:19:25.716] - globals: [0] <none>
[10:19:25.716] getGlobalsAndPackages() ... DONE
[10:19:25.716]    + additional globals found: [n=0] 
[10:19:25.716]    + additional namespaces needed: [n=0] 
[10:19:25.716]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:25.716]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:25.716]  - seeds: <none>
[10:19:25.716]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.717] getGlobalsAndPackages() ...
[10:19:25.717] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.717] Resolving globals: FALSE
[10:19:25.717] The total size of the 5 globals is 880 bytes (880 bytes)
[10:19:25.717] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:25.718] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.718] 
[10:19:25.718] getGlobalsAndPackages() ... DONE
[10:19:25.718] run() for ‘Future’ ...
[10:19:25.718] - state: ‘created’
[10:19:25.718] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.734] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.734] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.734]   - Field: ‘node’
[10:19:25.734]   - Field: ‘label’
[10:19:25.734]   - Field: ‘local’
[10:19:25.735]   - Field: ‘owner’
[10:19:25.735]   - Field: ‘envir’
[10:19:25.735]   - Field: ‘workers’
[10:19:25.735]   - Field: ‘packages’
[10:19:25.735]   - Field: ‘gc’
[10:19:25.735]   - Field: ‘conditions’
[10:19:25.736]   - Field: ‘persistent’
[10:19:25.736]   - Field: ‘expr’
[10:19:25.736]   - Field: ‘uuid’
[10:19:25.736]   - Field: ‘seed’
[10:19:25.736]   - Field: ‘version’
[10:19:25.737]   - Field: ‘result’
[10:19:25.737]   - Field: ‘asynchronous’
[10:19:25.737]   - Field: ‘calls’
[10:19:25.737]   - Field: ‘globals’
[10:19:25.737]   - Field: ‘stdout’
[10:19:25.737]   - Field: ‘earlySignal’
[10:19:25.738]   - Field: ‘lazy’
[10:19:25.738]   - Field: ‘state’
[10:19:25.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.738] - Launch lazy future ...
[10:19:25.738] Packages needed by the future expression (n = 0): <none>
[10:19:25.739] Packages needed by future strategies (n = 0): <none>
[10:19:25.739] {
[10:19:25.739]     {
[10:19:25.739]         {
[10:19:25.739]             ...future.startTime <- base::Sys.time()
[10:19:25.739]             {
[10:19:25.739]                 {
[10:19:25.739]                   {
[10:19:25.739]                     {
[10:19:25.739]                       base::local({
[10:19:25.739]                         has_future <- base::requireNamespace("future", 
[10:19:25.739]                           quietly = TRUE)
[10:19:25.739]                         if (has_future) {
[10:19:25.739]                           ns <- base::getNamespace("future")
[10:19:25.739]                           version <- ns[[".package"]][["version"]]
[10:19:25.739]                           if (is.null(version)) 
[10:19:25.739]                             version <- utils::packageVersion("future")
[10:19:25.739]                         }
[10:19:25.739]                         else {
[10:19:25.739]                           version <- NULL
[10:19:25.739]                         }
[10:19:25.739]                         if (!has_future || version < "1.8.0") {
[10:19:25.739]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.739]                             "", base::R.version$version.string), 
[10:19:25.739]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.739]                               "release", "version")], collapse = " "), 
[10:19:25.739]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.739]                             info)
[10:19:25.739]                           info <- base::paste(info, collapse = "; ")
[10:19:25.739]                           if (!has_future) {
[10:19:25.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.739]                               info)
[10:19:25.739]                           }
[10:19:25.739]                           else {
[10:19:25.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.739]                               info, version)
[10:19:25.739]                           }
[10:19:25.739]                           base::stop(msg)
[10:19:25.739]                         }
[10:19:25.739]                       })
[10:19:25.739]                     }
[10:19:25.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.739]                     base::options(mc.cores = 1L)
[10:19:25.739]                   }
[10:19:25.739]                   ...future.strategy.old <- future::plan("list")
[10:19:25.739]                   options(future.plan = NULL)
[10:19:25.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.739]                 }
[10:19:25.739]                 ...future.workdir <- getwd()
[10:19:25.739]             }
[10:19:25.739]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.739]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.739]         }
[10:19:25.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.739]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:25.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.739]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.739]             base::names(...future.oldOptions))
[10:19:25.739]     }
[10:19:25.739]     if (FALSE) {
[10:19:25.739]     }
[10:19:25.739]     else {
[10:19:25.739]         if (TRUE) {
[10:19:25.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.739]                 open = "w")
[10:19:25.739]         }
[10:19:25.739]         else {
[10:19:25.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.739]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.739]         }
[10:19:25.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.739]             base::sink(type = "output", split = FALSE)
[10:19:25.739]             base::close(...future.stdout)
[10:19:25.739]         }, add = TRUE)
[10:19:25.739]     }
[10:19:25.739]     ...future.frame <- base::sys.nframe()
[10:19:25.739]     ...future.conditions <- base::list()
[10:19:25.739]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.739]     if (FALSE) {
[10:19:25.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.739]     }
[10:19:25.739]     ...future.result <- base::tryCatch({
[10:19:25.739]         base::withCallingHandlers({
[10:19:25.739]             ...future.value <- base::withVisible(base::local({
[10:19:25.739]                 ...future.makeSendCondition <- base::local({
[10:19:25.739]                   sendCondition <- NULL
[10:19:25.739]                   function(frame = 1L) {
[10:19:25.739]                     if (is.function(sendCondition)) 
[10:19:25.739]                       return(sendCondition)
[10:19:25.739]                     ns <- getNamespace("parallel")
[10:19:25.739]                     if (exists("sendData", mode = "function", 
[10:19:25.739]                       envir = ns)) {
[10:19:25.739]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.739]                         envir = ns)
[10:19:25.739]                       envir <- sys.frame(frame)
[10:19:25.739]                       master <- NULL
[10:19:25.739]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.739]                         !identical(envir, emptyenv())) {
[10:19:25.739]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.739]                           inherits = FALSE)) {
[10:19:25.739]                           master <- get("master", mode = "list", 
[10:19:25.739]                             envir = envir, inherits = FALSE)
[10:19:25.739]                           if (inherits(master, c("SOCKnode", 
[10:19:25.739]                             "SOCK0node"))) {
[10:19:25.739]                             sendCondition <<- function(cond) {
[10:19:25.739]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.739]                                 success = TRUE)
[10:19:25.739]                               parallel_sendData(master, data)
[10:19:25.739]                             }
[10:19:25.739]                             return(sendCondition)
[10:19:25.739]                           }
[10:19:25.739]                         }
[10:19:25.739]                         frame <- frame + 1L
[10:19:25.739]                         envir <- sys.frame(frame)
[10:19:25.739]                       }
[10:19:25.739]                     }
[10:19:25.739]                     sendCondition <<- function(cond) NULL
[10:19:25.739]                   }
[10:19:25.739]                 })
[10:19:25.739]                 withCallingHandlers({
[10:19:25.739]                   {
[10:19:25.739]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.739]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.739]                       ...future.globals.maxSize)) {
[10:19:25.739]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.739]                       on.exit(options(oopts), add = TRUE)
[10:19:25.739]                     }
[10:19:25.739]                     {
[10:19:25.739]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.739]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.739]                         USE.NAMES = FALSE)
[10:19:25.739]                       do.call(mapply, args = args)
[10:19:25.739]                     }
[10:19:25.739]                   }
[10:19:25.739]                 }, immediateCondition = function(cond) {
[10:19:25.739]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.739]                   sendCondition(cond)
[10:19:25.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.739]                   {
[10:19:25.739]                     inherits <- base::inherits
[10:19:25.739]                     invokeRestart <- base::invokeRestart
[10:19:25.739]                     is.null <- base::is.null
[10:19:25.739]                     muffled <- FALSE
[10:19:25.739]                     if (inherits(cond, "message")) {
[10:19:25.739]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.739]                       if (muffled) 
[10:19:25.739]                         invokeRestart("muffleMessage")
[10:19:25.739]                     }
[10:19:25.739]                     else if (inherits(cond, "warning")) {
[10:19:25.739]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.739]                       if (muffled) 
[10:19:25.739]                         invokeRestart("muffleWarning")
[10:19:25.739]                     }
[10:19:25.739]                     else if (inherits(cond, "condition")) {
[10:19:25.739]                       if (!is.null(pattern)) {
[10:19:25.739]                         computeRestarts <- base::computeRestarts
[10:19:25.739]                         grepl <- base::grepl
[10:19:25.739]                         restarts <- computeRestarts(cond)
[10:19:25.739]                         for (restart in restarts) {
[10:19:25.739]                           name <- restart$name
[10:19:25.739]                           if (is.null(name)) 
[10:19:25.739]                             next
[10:19:25.739]                           if (!grepl(pattern, name)) 
[10:19:25.739]                             next
[10:19:25.739]                           invokeRestart(restart)
[10:19:25.739]                           muffled <- TRUE
[10:19:25.739]                           break
[10:19:25.739]                         }
[10:19:25.739]                       }
[10:19:25.739]                     }
[10:19:25.739]                     invisible(muffled)
[10:19:25.739]                   }
[10:19:25.739]                   muffleCondition(cond)
[10:19:25.739]                 })
[10:19:25.739]             }))
[10:19:25.739]             future::FutureResult(value = ...future.value$value, 
[10:19:25.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.739]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.739]                     ...future.globalenv.names))
[10:19:25.739]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.739]         }, condition = base::local({
[10:19:25.739]             c <- base::c
[10:19:25.739]             inherits <- base::inherits
[10:19:25.739]             invokeRestart <- base::invokeRestart
[10:19:25.739]             length <- base::length
[10:19:25.739]             list <- base::list
[10:19:25.739]             seq.int <- base::seq.int
[10:19:25.739]             signalCondition <- base::signalCondition
[10:19:25.739]             sys.calls <- base::sys.calls
[10:19:25.739]             `[[` <- base::`[[`
[10:19:25.739]             `+` <- base::`+`
[10:19:25.739]             `<<-` <- base::`<<-`
[10:19:25.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.739]                   3L)]
[10:19:25.739]             }
[10:19:25.739]             function(cond) {
[10:19:25.739]                 is_error <- inherits(cond, "error")
[10:19:25.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.739]                   NULL)
[10:19:25.739]                 if (is_error) {
[10:19:25.739]                   sessionInformation <- function() {
[10:19:25.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.739]                       search = base::search(), system = base::Sys.info())
[10:19:25.739]                   }
[10:19:25.739]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.739]                     cond$call), session = sessionInformation(), 
[10:19:25.739]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.739]                   signalCondition(cond)
[10:19:25.739]                 }
[10:19:25.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.739]                 "immediateCondition"))) {
[10:19:25.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.739]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.739]                   if (TRUE && !signal) {
[10:19:25.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.739]                     {
[10:19:25.739]                       inherits <- base::inherits
[10:19:25.739]                       invokeRestart <- base::invokeRestart
[10:19:25.739]                       is.null <- base::is.null
[10:19:25.739]                       muffled <- FALSE
[10:19:25.739]                       if (inherits(cond, "message")) {
[10:19:25.739]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.739]                         if (muffled) 
[10:19:25.739]                           invokeRestart("muffleMessage")
[10:19:25.739]                       }
[10:19:25.739]                       else if (inherits(cond, "warning")) {
[10:19:25.739]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.739]                         if (muffled) 
[10:19:25.739]                           invokeRestart("muffleWarning")
[10:19:25.739]                       }
[10:19:25.739]                       else if (inherits(cond, "condition")) {
[10:19:25.739]                         if (!is.null(pattern)) {
[10:19:25.739]                           computeRestarts <- base::computeRestarts
[10:19:25.739]                           grepl <- base::grepl
[10:19:25.739]                           restarts <- computeRestarts(cond)
[10:19:25.739]                           for (restart in restarts) {
[10:19:25.739]                             name <- restart$name
[10:19:25.739]                             if (is.null(name)) 
[10:19:25.739]                               next
[10:19:25.739]                             if (!grepl(pattern, name)) 
[10:19:25.739]                               next
[10:19:25.739]                             invokeRestart(restart)
[10:19:25.739]                             muffled <- TRUE
[10:19:25.739]                             break
[10:19:25.739]                           }
[10:19:25.739]                         }
[10:19:25.739]                       }
[10:19:25.739]                       invisible(muffled)
[10:19:25.739]                     }
[10:19:25.739]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.739]                   }
[10:19:25.739]                 }
[10:19:25.739]                 else {
[10:19:25.739]                   if (TRUE) {
[10:19:25.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.739]                     {
[10:19:25.739]                       inherits <- base::inherits
[10:19:25.739]                       invokeRestart <- base::invokeRestart
[10:19:25.739]                       is.null <- base::is.null
[10:19:25.739]                       muffled <- FALSE
[10:19:25.739]                       if (inherits(cond, "message")) {
[10:19:25.739]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.739]                         if (muffled) 
[10:19:25.739]                           invokeRestart("muffleMessage")
[10:19:25.739]                       }
[10:19:25.739]                       else if (inherits(cond, "warning")) {
[10:19:25.739]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.739]                         if (muffled) 
[10:19:25.739]                           invokeRestart("muffleWarning")
[10:19:25.739]                       }
[10:19:25.739]                       else if (inherits(cond, "condition")) {
[10:19:25.739]                         if (!is.null(pattern)) {
[10:19:25.739]                           computeRestarts <- base::computeRestarts
[10:19:25.739]                           grepl <- base::grepl
[10:19:25.739]                           restarts <- computeRestarts(cond)
[10:19:25.739]                           for (restart in restarts) {
[10:19:25.739]                             name <- restart$name
[10:19:25.739]                             if (is.null(name)) 
[10:19:25.739]                               next
[10:19:25.739]                             if (!grepl(pattern, name)) 
[10:19:25.739]                               next
[10:19:25.739]                             invokeRestart(restart)
[10:19:25.739]                             muffled <- TRUE
[10:19:25.739]                             break
[10:19:25.739]                           }
[10:19:25.739]                         }
[10:19:25.739]                       }
[10:19:25.739]                       invisible(muffled)
[10:19:25.739]                     }
[10:19:25.739]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.739]                   }
[10:19:25.739]                 }
[10:19:25.739]             }
[10:19:25.739]         }))
[10:19:25.739]     }, error = function(ex) {
[10:19:25.739]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.739]                 ...future.rng), started = ...future.startTime, 
[10:19:25.739]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.739]             version = "1.8"), class = "FutureResult")
[10:19:25.739]     }, finally = {
[10:19:25.739]         if (!identical(...future.workdir, getwd())) 
[10:19:25.739]             setwd(...future.workdir)
[10:19:25.739]         {
[10:19:25.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.739]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.739]             }
[10:19:25.739]             base::options(...future.oldOptions)
[10:19:25.739]             if (.Platform$OS.type == "windows") {
[10:19:25.739]                 old_names <- names(...future.oldEnvVars)
[10:19:25.739]                 envs <- base::Sys.getenv()
[10:19:25.739]                 names <- names(envs)
[10:19:25.739]                 common <- intersect(names, old_names)
[10:19:25.739]                 added <- setdiff(names, old_names)
[10:19:25.739]                 removed <- setdiff(old_names, names)
[10:19:25.739]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.739]                   envs[common]]
[10:19:25.739]                 NAMES <- toupper(changed)
[10:19:25.739]                 args <- list()
[10:19:25.739]                 for (kk in seq_along(NAMES)) {
[10:19:25.739]                   name <- changed[[kk]]
[10:19:25.739]                   NAME <- NAMES[[kk]]
[10:19:25.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.739]                     next
[10:19:25.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.739]                 }
[10:19:25.739]                 NAMES <- toupper(added)
[10:19:25.739]                 for (kk in seq_along(NAMES)) {
[10:19:25.739]                   name <- added[[kk]]
[10:19:25.739]                   NAME <- NAMES[[kk]]
[10:19:25.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.739]                     next
[10:19:25.739]                   args[[name]] <- ""
[10:19:25.739]                 }
[10:19:25.739]                 NAMES <- toupper(removed)
[10:19:25.739]                 for (kk in seq_along(NAMES)) {
[10:19:25.739]                   name <- removed[[kk]]
[10:19:25.739]                   NAME <- NAMES[[kk]]
[10:19:25.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.739]                     next
[10:19:25.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.739]                 }
[10:19:25.739]                 if (length(args) > 0) 
[10:19:25.739]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.739]             }
[10:19:25.739]             else {
[10:19:25.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.739]             }
[10:19:25.739]             {
[10:19:25.739]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.739]                   0L) {
[10:19:25.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.739]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.739]                   base::options(opts)
[10:19:25.739]                 }
[10:19:25.739]                 {
[10:19:25.739]                   {
[10:19:25.739]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.739]                     NULL
[10:19:25.739]                   }
[10:19:25.739]                   options(future.plan = NULL)
[10:19:25.739]                   if (is.na(NA_character_)) 
[10:19:25.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.739]                     .init = FALSE)
[10:19:25.739]                 }
[10:19:25.739]             }
[10:19:25.739]         }
[10:19:25.739]     })
[10:19:25.739]     if (TRUE) {
[10:19:25.739]         base::sink(type = "output", split = FALSE)
[10:19:25.739]         if (TRUE) {
[10:19:25.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.739]         }
[10:19:25.739]         else {
[10:19:25.739]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.739]         }
[10:19:25.739]         base::close(...future.stdout)
[10:19:25.739]         ...future.stdout <- NULL
[10:19:25.739]     }
[10:19:25.739]     ...future.result$conditions <- ...future.conditions
[10:19:25.739]     ...future.result$finished <- base::Sys.time()
[10:19:25.739]     ...future.result
[10:19:25.739] }
[10:19:25.744] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[10:19:25.744] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:19:25.745] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:19:25.745] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[10:19:25.746] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[10:19:25.746] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:19:25.746] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:19:25.747] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:25.747] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.747] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:25.748] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.748] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[10:19:25.748] MultisessionFuture started
[10:19:25.748] - Launch lazy future ... done
[10:19:25.749] run() for ‘MultisessionFuture’ ... done
[10:19:25.749] Created future:
[10:19:25.749] MultisessionFuture:
[10:19:25.749] Label: ‘future_.mapply-1’
[10:19:25.749] Expression:
[10:19:25.749] {
[10:19:25.749]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.749]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.749]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.749]         on.exit(options(oopts), add = TRUE)
[10:19:25.749]     }
[10:19:25.749]     {
[10:19:25.749]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.749]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.749]         do.call(mapply, args = args)
[10:19:25.749]     }
[10:19:25.749] }
[10:19:25.749] Lazy evaluation: FALSE
[10:19:25.749] Asynchronous evaluation: TRUE
[10:19:25.749] Local evaluation: TRUE
[10:19:25.749] Environment: R_GlobalEnv
[10:19:25.749] Capture standard output: TRUE
[10:19:25.749] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.749] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.749] Packages: <none>
[10:19:25.749] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.749] Resolved: FALSE
[10:19:25.749] Value: <not collected>
[10:19:25.749] Conditions captured: <none>
[10:19:25.749] Early signaling: FALSE
[10:19:25.749] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.749] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.761] Chunk #1 of 2 ... DONE
[10:19:25.761] Chunk #2 of 2 ...
[10:19:25.761]  - Finding globals in '...' for chunk #2 ...
[10:19:25.761] getGlobalsAndPackages() ...
[10:19:25.761] Searching for globals...
[10:19:25.761] 
[10:19:25.761] Searching for globals ... DONE
[10:19:25.762] - globals: [0] <none>
[10:19:25.762] getGlobalsAndPackages() ... DONE
[10:19:25.762]    + additional globals found: [n=0] 
[10:19:25.762]    + additional namespaces needed: [n=0] 
[10:19:25.762]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:25.762]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:25.762]  - seeds: <none>
[10:19:25.762]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.762] getGlobalsAndPackages() ...
[10:19:25.762] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.763] Resolving globals: FALSE
[10:19:25.763] The total size of the 5 globals is 909 bytes (909 bytes)
[10:19:25.763] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:25.764] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.764] 
[10:19:25.764] getGlobalsAndPackages() ... DONE
[10:19:25.764] run() for ‘Future’ ...
[10:19:25.764] - state: ‘created’
[10:19:25.764] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.780] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.780] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.780]   - Field: ‘node’
[10:19:25.781]   - Field: ‘label’
[10:19:25.781]   - Field: ‘local’
[10:19:25.781]   - Field: ‘owner’
[10:19:25.781]   - Field: ‘envir’
[10:19:25.781]   - Field: ‘workers’
[10:19:25.781]   - Field: ‘packages’
[10:19:25.782]   - Field: ‘gc’
[10:19:25.782]   - Field: ‘conditions’
[10:19:25.782]   - Field: ‘persistent’
[10:19:25.782]   - Field: ‘expr’
[10:19:25.782]   - Field: ‘uuid’
[10:19:25.782]   - Field: ‘seed’
[10:19:25.782]   - Field: ‘version’
[10:19:25.783]   - Field: ‘result’
[10:19:25.783]   - Field: ‘asynchronous’
[10:19:25.783]   - Field: ‘calls’
[10:19:25.783]   - Field: ‘globals’
[10:19:25.783]   - Field: ‘stdout’
[10:19:25.783]   - Field: ‘earlySignal’
[10:19:25.783]   - Field: ‘lazy’
[10:19:25.783]   - Field: ‘state’
[10:19:25.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.784] - Launch lazy future ...
[10:19:25.784] Packages needed by the future expression (n = 0): <none>
[10:19:25.784] Packages needed by future strategies (n = 0): <none>
[10:19:25.785] {
[10:19:25.785]     {
[10:19:25.785]         {
[10:19:25.785]             ...future.startTime <- base::Sys.time()
[10:19:25.785]             {
[10:19:25.785]                 {
[10:19:25.785]                   {
[10:19:25.785]                     {
[10:19:25.785]                       base::local({
[10:19:25.785]                         has_future <- base::requireNamespace("future", 
[10:19:25.785]                           quietly = TRUE)
[10:19:25.785]                         if (has_future) {
[10:19:25.785]                           ns <- base::getNamespace("future")
[10:19:25.785]                           version <- ns[[".package"]][["version"]]
[10:19:25.785]                           if (is.null(version)) 
[10:19:25.785]                             version <- utils::packageVersion("future")
[10:19:25.785]                         }
[10:19:25.785]                         else {
[10:19:25.785]                           version <- NULL
[10:19:25.785]                         }
[10:19:25.785]                         if (!has_future || version < "1.8.0") {
[10:19:25.785]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.785]                             "", base::R.version$version.string), 
[10:19:25.785]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.785]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.785]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.785]                               "release", "version")], collapse = " "), 
[10:19:25.785]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.785]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.785]                             info)
[10:19:25.785]                           info <- base::paste(info, collapse = "; ")
[10:19:25.785]                           if (!has_future) {
[10:19:25.785]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.785]                               info)
[10:19:25.785]                           }
[10:19:25.785]                           else {
[10:19:25.785]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.785]                               info, version)
[10:19:25.785]                           }
[10:19:25.785]                           base::stop(msg)
[10:19:25.785]                         }
[10:19:25.785]                       })
[10:19:25.785]                     }
[10:19:25.785]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.785]                     base::options(mc.cores = 1L)
[10:19:25.785]                   }
[10:19:25.785]                   ...future.strategy.old <- future::plan("list")
[10:19:25.785]                   options(future.plan = NULL)
[10:19:25.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.785]                 }
[10:19:25.785]                 ...future.workdir <- getwd()
[10:19:25.785]             }
[10:19:25.785]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.785]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.785]         }
[10:19:25.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.785]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:25.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.785]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.785]             base::names(...future.oldOptions))
[10:19:25.785]     }
[10:19:25.785]     if (FALSE) {
[10:19:25.785]     }
[10:19:25.785]     else {
[10:19:25.785]         if (TRUE) {
[10:19:25.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.785]                 open = "w")
[10:19:25.785]         }
[10:19:25.785]         else {
[10:19:25.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.785]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.785]         }
[10:19:25.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.785]             base::sink(type = "output", split = FALSE)
[10:19:25.785]             base::close(...future.stdout)
[10:19:25.785]         }, add = TRUE)
[10:19:25.785]     }
[10:19:25.785]     ...future.frame <- base::sys.nframe()
[10:19:25.785]     ...future.conditions <- base::list()
[10:19:25.785]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.785]     if (FALSE) {
[10:19:25.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.785]     }
[10:19:25.785]     ...future.result <- base::tryCatch({
[10:19:25.785]         base::withCallingHandlers({
[10:19:25.785]             ...future.value <- base::withVisible(base::local({
[10:19:25.785]                 ...future.makeSendCondition <- base::local({
[10:19:25.785]                   sendCondition <- NULL
[10:19:25.785]                   function(frame = 1L) {
[10:19:25.785]                     if (is.function(sendCondition)) 
[10:19:25.785]                       return(sendCondition)
[10:19:25.785]                     ns <- getNamespace("parallel")
[10:19:25.785]                     if (exists("sendData", mode = "function", 
[10:19:25.785]                       envir = ns)) {
[10:19:25.785]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.785]                         envir = ns)
[10:19:25.785]                       envir <- sys.frame(frame)
[10:19:25.785]                       master <- NULL
[10:19:25.785]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.785]                         !identical(envir, emptyenv())) {
[10:19:25.785]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.785]                           inherits = FALSE)) {
[10:19:25.785]                           master <- get("master", mode = "list", 
[10:19:25.785]                             envir = envir, inherits = FALSE)
[10:19:25.785]                           if (inherits(master, c("SOCKnode", 
[10:19:25.785]                             "SOCK0node"))) {
[10:19:25.785]                             sendCondition <<- function(cond) {
[10:19:25.785]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.785]                                 success = TRUE)
[10:19:25.785]                               parallel_sendData(master, data)
[10:19:25.785]                             }
[10:19:25.785]                             return(sendCondition)
[10:19:25.785]                           }
[10:19:25.785]                         }
[10:19:25.785]                         frame <- frame + 1L
[10:19:25.785]                         envir <- sys.frame(frame)
[10:19:25.785]                       }
[10:19:25.785]                     }
[10:19:25.785]                     sendCondition <<- function(cond) NULL
[10:19:25.785]                   }
[10:19:25.785]                 })
[10:19:25.785]                 withCallingHandlers({
[10:19:25.785]                   {
[10:19:25.785]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.785]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.785]                       ...future.globals.maxSize)) {
[10:19:25.785]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.785]                       on.exit(options(oopts), add = TRUE)
[10:19:25.785]                     }
[10:19:25.785]                     {
[10:19:25.785]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.785]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.785]                         USE.NAMES = FALSE)
[10:19:25.785]                       do.call(mapply, args = args)
[10:19:25.785]                     }
[10:19:25.785]                   }
[10:19:25.785]                 }, immediateCondition = function(cond) {
[10:19:25.785]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.785]                   sendCondition(cond)
[10:19:25.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.785]                   {
[10:19:25.785]                     inherits <- base::inherits
[10:19:25.785]                     invokeRestart <- base::invokeRestart
[10:19:25.785]                     is.null <- base::is.null
[10:19:25.785]                     muffled <- FALSE
[10:19:25.785]                     if (inherits(cond, "message")) {
[10:19:25.785]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.785]                       if (muffled) 
[10:19:25.785]                         invokeRestart("muffleMessage")
[10:19:25.785]                     }
[10:19:25.785]                     else if (inherits(cond, "warning")) {
[10:19:25.785]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.785]                       if (muffled) 
[10:19:25.785]                         invokeRestart("muffleWarning")
[10:19:25.785]                     }
[10:19:25.785]                     else if (inherits(cond, "condition")) {
[10:19:25.785]                       if (!is.null(pattern)) {
[10:19:25.785]                         computeRestarts <- base::computeRestarts
[10:19:25.785]                         grepl <- base::grepl
[10:19:25.785]                         restarts <- computeRestarts(cond)
[10:19:25.785]                         for (restart in restarts) {
[10:19:25.785]                           name <- restart$name
[10:19:25.785]                           if (is.null(name)) 
[10:19:25.785]                             next
[10:19:25.785]                           if (!grepl(pattern, name)) 
[10:19:25.785]                             next
[10:19:25.785]                           invokeRestart(restart)
[10:19:25.785]                           muffled <- TRUE
[10:19:25.785]                           break
[10:19:25.785]                         }
[10:19:25.785]                       }
[10:19:25.785]                     }
[10:19:25.785]                     invisible(muffled)
[10:19:25.785]                   }
[10:19:25.785]                   muffleCondition(cond)
[10:19:25.785]                 })
[10:19:25.785]             }))
[10:19:25.785]             future::FutureResult(value = ...future.value$value, 
[10:19:25.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.785]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.785]                     ...future.globalenv.names))
[10:19:25.785]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.785]         }, condition = base::local({
[10:19:25.785]             c <- base::c
[10:19:25.785]             inherits <- base::inherits
[10:19:25.785]             invokeRestart <- base::invokeRestart
[10:19:25.785]             length <- base::length
[10:19:25.785]             list <- base::list
[10:19:25.785]             seq.int <- base::seq.int
[10:19:25.785]             signalCondition <- base::signalCondition
[10:19:25.785]             sys.calls <- base::sys.calls
[10:19:25.785]             `[[` <- base::`[[`
[10:19:25.785]             `+` <- base::`+`
[10:19:25.785]             `<<-` <- base::`<<-`
[10:19:25.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.785]                   3L)]
[10:19:25.785]             }
[10:19:25.785]             function(cond) {
[10:19:25.785]                 is_error <- inherits(cond, "error")
[10:19:25.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.785]                   NULL)
[10:19:25.785]                 if (is_error) {
[10:19:25.785]                   sessionInformation <- function() {
[10:19:25.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.785]                       search = base::search(), system = base::Sys.info())
[10:19:25.785]                   }
[10:19:25.785]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.785]                     cond$call), session = sessionInformation(), 
[10:19:25.785]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.785]                   signalCondition(cond)
[10:19:25.785]                 }
[10:19:25.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.785]                 "immediateCondition"))) {
[10:19:25.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.785]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.785]                   if (TRUE && !signal) {
[10:19:25.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.785]                     {
[10:19:25.785]                       inherits <- base::inherits
[10:19:25.785]                       invokeRestart <- base::invokeRestart
[10:19:25.785]                       is.null <- base::is.null
[10:19:25.785]                       muffled <- FALSE
[10:19:25.785]                       if (inherits(cond, "message")) {
[10:19:25.785]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.785]                         if (muffled) 
[10:19:25.785]                           invokeRestart("muffleMessage")
[10:19:25.785]                       }
[10:19:25.785]                       else if (inherits(cond, "warning")) {
[10:19:25.785]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.785]                         if (muffled) 
[10:19:25.785]                           invokeRestart("muffleWarning")
[10:19:25.785]                       }
[10:19:25.785]                       else if (inherits(cond, "condition")) {
[10:19:25.785]                         if (!is.null(pattern)) {
[10:19:25.785]                           computeRestarts <- base::computeRestarts
[10:19:25.785]                           grepl <- base::grepl
[10:19:25.785]                           restarts <- computeRestarts(cond)
[10:19:25.785]                           for (restart in restarts) {
[10:19:25.785]                             name <- restart$name
[10:19:25.785]                             if (is.null(name)) 
[10:19:25.785]                               next
[10:19:25.785]                             if (!grepl(pattern, name)) 
[10:19:25.785]                               next
[10:19:25.785]                             invokeRestart(restart)
[10:19:25.785]                             muffled <- TRUE
[10:19:25.785]                             break
[10:19:25.785]                           }
[10:19:25.785]                         }
[10:19:25.785]                       }
[10:19:25.785]                       invisible(muffled)
[10:19:25.785]                     }
[10:19:25.785]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.785]                   }
[10:19:25.785]                 }
[10:19:25.785]                 else {
[10:19:25.785]                   if (TRUE) {
[10:19:25.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.785]                     {
[10:19:25.785]                       inherits <- base::inherits
[10:19:25.785]                       invokeRestart <- base::invokeRestart
[10:19:25.785]                       is.null <- base::is.null
[10:19:25.785]                       muffled <- FALSE
[10:19:25.785]                       if (inherits(cond, "message")) {
[10:19:25.785]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.785]                         if (muffled) 
[10:19:25.785]                           invokeRestart("muffleMessage")
[10:19:25.785]                       }
[10:19:25.785]                       else if (inherits(cond, "warning")) {
[10:19:25.785]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.785]                         if (muffled) 
[10:19:25.785]                           invokeRestart("muffleWarning")
[10:19:25.785]                       }
[10:19:25.785]                       else if (inherits(cond, "condition")) {
[10:19:25.785]                         if (!is.null(pattern)) {
[10:19:25.785]                           computeRestarts <- base::computeRestarts
[10:19:25.785]                           grepl <- base::grepl
[10:19:25.785]                           restarts <- computeRestarts(cond)
[10:19:25.785]                           for (restart in restarts) {
[10:19:25.785]                             name <- restart$name
[10:19:25.785]                             if (is.null(name)) 
[10:19:25.785]                               next
[10:19:25.785]                             if (!grepl(pattern, name)) 
[10:19:25.785]                               next
[10:19:25.785]                             invokeRestart(restart)
[10:19:25.785]                             muffled <- TRUE
[10:19:25.785]                             break
[10:19:25.785]                           }
[10:19:25.785]                         }
[10:19:25.785]                       }
[10:19:25.785]                       invisible(muffled)
[10:19:25.785]                     }
[10:19:25.785]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.785]                   }
[10:19:25.785]                 }
[10:19:25.785]             }
[10:19:25.785]         }))
[10:19:25.785]     }, error = function(ex) {
[10:19:25.785]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.785]                 ...future.rng), started = ...future.startTime, 
[10:19:25.785]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.785]             version = "1.8"), class = "FutureResult")
[10:19:25.785]     }, finally = {
[10:19:25.785]         if (!identical(...future.workdir, getwd())) 
[10:19:25.785]             setwd(...future.workdir)
[10:19:25.785]         {
[10:19:25.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.785]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.785]             }
[10:19:25.785]             base::options(...future.oldOptions)
[10:19:25.785]             if (.Platform$OS.type == "windows") {
[10:19:25.785]                 old_names <- names(...future.oldEnvVars)
[10:19:25.785]                 envs <- base::Sys.getenv()
[10:19:25.785]                 names <- names(envs)
[10:19:25.785]                 common <- intersect(names, old_names)
[10:19:25.785]                 added <- setdiff(names, old_names)
[10:19:25.785]                 removed <- setdiff(old_names, names)
[10:19:25.785]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.785]                   envs[common]]
[10:19:25.785]                 NAMES <- toupper(changed)
[10:19:25.785]                 args <- list()
[10:19:25.785]                 for (kk in seq_along(NAMES)) {
[10:19:25.785]                   name <- changed[[kk]]
[10:19:25.785]                   NAME <- NAMES[[kk]]
[10:19:25.785]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.785]                     next
[10:19:25.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.785]                 }
[10:19:25.785]                 NAMES <- toupper(added)
[10:19:25.785]                 for (kk in seq_along(NAMES)) {
[10:19:25.785]                   name <- added[[kk]]
[10:19:25.785]                   NAME <- NAMES[[kk]]
[10:19:25.785]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.785]                     next
[10:19:25.785]                   args[[name]] <- ""
[10:19:25.785]                 }
[10:19:25.785]                 NAMES <- toupper(removed)
[10:19:25.785]                 for (kk in seq_along(NAMES)) {
[10:19:25.785]                   name <- removed[[kk]]
[10:19:25.785]                   NAME <- NAMES[[kk]]
[10:19:25.785]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.785]                     next
[10:19:25.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.785]                 }
[10:19:25.785]                 if (length(args) > 0) 
[10:19:25.785]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.785]             }
[10:19:25.785]             else {
[10:19:25.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.785]             }
[10:19:25.785]             {
[10:19:25.785]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.785]                   0L) {
[10:19:25.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.785]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.785]                   base::options(opts)
[10:19:25.785]                 }
[10:19:25.785]                 {
[10:19:25.785]                   {
[10:19:25.785]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.785]                     NULL
[10:19:25.785]                   }
[10:19:25.785]                   options(future.plan = NULL)
[10:19:25.785]                   if (is.na(NA_character_)) 
[10:19:25.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.785]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.785]                     .init = FALSE)
[10:19:25.785]                 }
[10:19:25.785]             }
[10:19:25.785]         }
[10:19:25.785]     })
[10:19:25.785]     if (TRUE) {
[10:19:25.785]         base::sink(type = "output", split = FALSE)
[10:19:25.785]         if (TRUE) {
[10:19:25.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.785]         }
[10:19:25.785]         else {
[10:19:25.785]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.785]         }
[10:19:25.785]         base::close(...future.stdout)
[10:19:25.785]         ...future.stdout <- NULL
[10:19:25.785]     }
[10:19:25.785]     ...future.result$conditions <- ...future.conditions
[10:19:25.785]     ...future.result$finished <- base::Sys.time()
[10:19:25.785]     ...future.result
[10:19:25.785] }
[10:19:25.788] Exporting 5 global objects (1.33 KiB) to cluster node #2 ...
[10:19:25.788] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:19:25.789] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:19:25.789] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[10:19:25.789] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[10:19:25.789] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[10:19:25.790] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[10:19:25.790] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:25.790] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.791] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:25.791] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.791] Exporting 5 global objects (1.33 KiB) to cluster node #2 ... DONE
[10:19:25.791] MultisessionFuture started
[10:19:25.792] - Launch lazy future ... done
[10:19:25.792] run() for ‘MultisessionFuture’ ... done
[10:19:25.792] Created future:
[10:19:25.792] MultisessionFuture:
[10:19:25.792] Label: ‘future_.mapply-2’
[10:19:25.792] Expression:
[10:19:25.792] {
[10:19:25.792]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.792]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.792]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.792]         on.exit(options(oopts), add = TRUE)
[10:19:25.792]     }
[10:19:25.792]     {
[10:19:25.792]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.792]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.792]         do.call(mapply, args = args)
[10:19:25.792]     }
[10:19:25.792] }
[10:19:25.792] Lazy evaluation: FALSE
[10:19:25.792] Asynchronous evaluation: TRUE
[10:19:25.792] Local evaluation: TRUE
[10:19:25.792] Environment: R_GlobalEnv
[10:19:25.792] Capture standard output: TRUE
[10:19:25.792] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.792] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.792] Packages: <none>
[10:19:25.792] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.792] Resolved: FALSE
[10:19:25.792] Value: <not collected>
[10:19:25.792] Conditions captured: <none>
[10:19:25.792] Early signaling: FALSE
[10:19:25.792] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.792] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.803] Chunk #2 of 2 ... DONE
[10:19:25.803] Launching 2 futures (chunks) ... DONE
[10:19:25.803] Resolving 2 futures (chunks) ...
[10:19:25.804] resolve() on list ...
[10:19:25.804]  recursive: 0
[10:19:25.804]  length: 2
[10:19:25.804] 
[10:19:25.804] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.805] - Validating connection of MultisessionFuture
[10:19:25.805] - received message: FutureResult
[10:19:25.805] - Received FutureResult
[10:19:25.805] - Erased future from FutureRegistry
[10:19:25.805] result() for ClusterFuture ...
[10:19:25.805] - result already collected: FutureResult
[10:19:25.805] result() for ClusterFuture ... done
[10:19:25.805] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.805] Future #1
[10:19:25.806] result() for ClusterFuture ...
[10:19:25.806] - result already collected: FutureResult
[10:19:25.806] result() for ClusterFuture ... done
[10:19:25.806] result() for ClusterFuture ...
[10:19:25.806] - result already collected: FutureResult
[10:19:25.806] result() for ClusterFuture ... done
[10:19:25.806] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:25.806] - nx: 2
[10:19:25.806] - relay: TRUE
[10:19:25.806] - stdout: TRUE
[10:19:25.806] - signal: TRUE
[10:19:25.806] - resignal: FALSE
[10:19:25.807] - force: TRUE
[10:19:25.807] - relayed: [n=2] FALSE, FALSE
[10:19:25.807] - queued futures: [n=2] FALSE, FALSE
[10:19:25.807]  - until=1
[10:19:25.807]  - relaying element #1
[10:19:25.807] result() for ClusterFuture ...
[10:19:25.807] - result already collected: FutureResult
[10:19:25.807] result() for ClusterFuture ... done
[10:19:25.807] result() for ClusterFuture ...
[10:19:25.807] - result already collected: FutureResult
[10:19:25.807] result() for ClusterFuture ... done
[10:19:25.808] result() for ClusterFuture ...
[10:19:25.808] - result already collected: FutureResult
[10:19:25.808] result() for ClusterFuture ... done
[10:19:25.808] result() for ClusterFuture ...
[10:19:25.808] - result already collected: FutureResult
[10:19:25.808] result() for ClusterFuture ... done
[10:19:25.808] - relayed: [n=2] TRUE, FALSE
[10:19:25.808] - queued futures: [n=2] TRUE, FALSE
[10:19:25.808] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:25.808]  length: 1 (resolved future 1)
[10:19:25.834] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.834] - Validating connection of MultisessionFuture
[10:19:25.834] - received message: FutureResult
[10:19:25.834] - Received FutureResult
[10:19:25.835] - Erased future from FutureRegistry
[10:19:25.835] result() for ClusterFuture ...
[10:19:25.835] - result already collected: FutureResult
[10:19:25.835] result() for ClusterFuture ... done
[10:19:25.835] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.835] Future #2
[10:19:25.835] result() for ClusterFuture ...
[10:19:25.835] - result already collected: FutureResult
[10:19:25.835] result() for ClusterFuture ... done
[10:19:25.835] result() for ClusterFuture ...
[10:19:25.835] - result already collected: FutureResult
[10:19:25.836] result() for ClusterFuture ... done
[10:19:25.836] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:25.836] - nx: 2
[10:19:25.836] - relay: TRUE
[10:19:25.836] - stdout: TRUE
[10:19:25.836] - signal: TRUE
[10:19:25.836] - resignal: FALSE
[10:19:25.836] - force: TRUE
[10:19:25.836] - relayed: [n=2] TRUE, FALSE
[10:19:25.836] - queued futures: [n=2] TRUE, FALSE
[10:19:25.836]  - until=2
[10:19:25.836]  - relaying element #2
[10:19:25.837] result() for ClusterFuture ...
[10:19:25.837] - result already collected: FutureResult
[10:19:25.837] result() for ClusterFuture ... done
[10:19:25.837] result() for ClusterFuture ...
[10:19:25.837] - result already collected: FutureResult
[10:19:25.837] result() for ClusterFuture ... done
[10:19:25.837] result() for ClusterFuture ...
[10:19:25.837] - result already collected: FutureResult
[10:19:25.837] result() for ClusterFuture ... done
[10:19:25.837] result() for ClusterFuture ...
[10:19:25.837] - result already collected: FutureResult
[10:19:25.837] result() for ClusterFuture ... done
[10:19:25.838] - relayed: [n=2] TRUE, TRUE
[10:19:25.838] - queued futures: [n=2] TRUE, TRUE
[10:19:25.838] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:25.838]  length: 0 (resolved future 2)
[10:19:25.838] Relaying remaining futures
[10:19:25.838] signalConditionsASAP(NULL, pos=0) ...
[10:19:25.838] - nx: 2
[10:19:25.838] - relay: TRUE
[10:19:25.838] - stdout: TRUE
[10:19:25.838] - signal: TRUE
[10:19:25.838] - resignal: FALSE
[10:19:25.838] - force: TRUE
[10:19:25.839] - relayed: [n=2] TRUE, TRUE
[10:19:25.839] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:25.839] - relayed: [n=2] TRUE, TRUE
[10:19:25.839] - queued futures: [n=2] TRUE, TRUE
[10:19:25.839] signalConditionsASAP(NULL, pos=0) ... done
[10:19:25.839] resolve() on list ... DONE
[10:19:25.839] result() for ClusterFuture ...
[10:19:25.839] - result already collected: FutureResult
[10:19:25.839] result() for ClusterFuture ... done
[10:19:25.839] result() for ClusterFuture ...
[10:19:25.839] - result already collected: FutureResult
[10:19:25.839] result() for ClusterFuture ... done
[10:19:25.840] result() for ClusterFuture ...
[10:19:25.840] - result already collected: FutureResult
[10:19:25.840] result() for ClusterFuture ... done
[10:19:25.840] result() for ClusterFuture ...
[10:19:25.840] - result already collected: FutureResult
[10:19:25.840] result() for ClusterFuture ... done
[10:19:25.840]  - Number of value chunks collected: 2
[10:19:25.840] Resolving 2 futures (chunks) ... DONE
[10:19:25.840] Reducing values from 2 chunks ...
[10:19:25.840]  - Number of values collected after concatenation: 5
[10:19:25.840]  - Number of values expected: 5
[10:19:25.841] Reducing values from 2 chunks ... DONE
[10:19:25.841] future_mapply() ... DONE
[10:19:25.841] future_mapply() ...
[10:19:25.843] Number of chunks: 2
[10:19:25.843] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:19:25.843] getGlobalsAndPackagesXApply() ...
[10:19:25.843]  - future.globals: TRUE
[10:19:25.843] getGlobalsAndPackages() ...
[10:19:25.843] Searching for globals...
[10:19:25.844] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:25.844] Searching for globals ... DONE
[10:19:25.845] Resolving globals: FALSE
[10:19:25.845] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:25.845] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:25.845] - globals: [1] ‘FUN’
[10:19:25.845] 
[10:19:25.845] getGlobalsAndPackages() ... DONE
[10:19:25.846]  - globals found/used: [n=1] ‘FUN’
[10:19:25.846]  - needed namespaces: [n=0] 
[10:19:25.846] Finding globals ... DONE
[10:19:25.846] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:25.846] List of 2
[10:19:25.846]  $ ...future.FUN:function (C, k)  
[10:19:25.846]  $ MoreArgs     : NULL
[10:19:25.846]  - attr(*, "where")=List of 2
[10:19:25.846]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:25.846]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:25.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:25.846]  - attr(*, "resolved")= logi FALSE
[10:19:25.846]  - attr(*, "total_size")= num NA
[10:19:25.848] Packages to be attached in all futures: [n=0] 
[10:19:25.849] getGlobalsAndPackagesXApply() ... DONE
[10:19:25.849] Number of futures (= number of chunks): 2
[10:19:25.849] Launching 2 futures (chunks) ...
[10:19:25.849] Chunk #1 of 2 ...
[10:19:25.849]  - Finding globals in '...' for chunk #1 ...
[10:19:25.849] getGlobalsAndPackages() ...
[10:19:25.849] Searching for globals...
[10:19:25.850] 
[10:19:25.850] Searching for globals ... DONE
[10:19:25.850] - globals: [0] <none>
[10:19:25.850] getGlobalsAndPackages() ... DONE
[10:19:25.850]    + additional globals found: [n=0] 
[10:19:25.850]    + additional namespaces needed: [n=0] 
[10:19:25.850]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:25.850]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:25.850]  - seeds: <none>
[10:19:25.850]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.850] getGlobalsAndPackages() ...
[10:19:25.850] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.851] Resolving globals: FALSE
[10:19:25.851] The total size of the 5 globals is 876 bytes (876 bytes)
[10:19:25.851] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:25.852] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.852] 
[10:19:25.852] getGlobalsAndPackages() ... DONE
[10:19:25.852] run() for ‘Future’ ...
[10:19:25.852] - state: ‘created’
[10:19:25.852] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.866]   - Field: ‘node’
[10:19:25.866]   - Field: ‘label’
[10:19:25.866]   - Field: ‘local’
[10:19:25.866]   - Field: ‘owner’
[10:19:25.866]   - Field: ‘envir’
[10:19:25.867]   - Field: ‘workers’
[10:19:25.867]   - Field: ‘packages’
[10:19:25.867]   - Field: ‘gc’
[10:19:25.867]   - Field: ‘conditions’
[10:19:25.867]   - Field: ‘persistent’
[10:19:25.867]   - Field: ‘expr’
[10:19:25.867]   - Field: ‘uuid’
[10:19:25.867]   - Field: ‘seed’
[10:19:25.867]   - Field: ‘version’
[10:19:25.867]   - Field: ‘result’
[10:19:25.867]   - Field: ‘asynchronous’
[10:19:25.868]   - Field: ‘calls’
[10:19:25.868]   - Field: ‘globals’
[10:19:25.868]   - Field: ‘stdout’
[10:19:25.868]   - Field: ‘earlySignal’
[10:19:25.868]   - Field: ‘lazy’
[10:19:25.868]   - Field: ‘state’
[10:19:25.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.868] - Launch lazy future ...
[10:19:25.868] Packages needed by the future expression (n = 0): <none>
[10:19:25.868] Packages needed by future strategies (n = 0): <none>
[10:19:25.869] {
[10:19:25.869]     {
[10:19:25.869]         {
[10:19:25.869]             ...future.startTime <- base::Sys.time()
[10:19:25.869]             {
[10:19:25.869]                 {
[10:19:25.869]                   {
[10:19:25.869]                     {
[10:19:25.869]                       base::local({
[10:19:25.869]                         has_future <- base::requireNamespace("future", 
[10:19:25.869]                           quietly = TRUE)
[10:19:25.869]                         if (has_future) {
[10:19:25.869]                           ns <- base::getNamespace("future")
[10:19:25.869]                           version <- ns[[".package"]][["version"]]
[10:19:25.869]                           if (is.null(version)) 
[10:19:25.869]                             version <- utils::packageVersion("future")
[10:19:25.869]                         }
[10:19:25.869]                         else {
[10:19:25.869]                           version <- NULL
[10:19:25.869]                         }
[10:19:25.869]                         if (!has_future || version < "1.8.0") {
[10:19:25.869]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.869]                             "", base::R.version$version.string), 
[10:19:25.869]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.869]                               "release", "version")], collapse = " "), 
[10:19:25.869]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.869]                             info)
[10:19:25.869]                           info <- base::paste(info, collapse = "; ")
[10:19:25.869]                           if (!has_future) {
[10:19:25.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.869]                               info)
[10:19:25.869]                           }
[10:19:25.869]                           else {
[10:19:25.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.869]                               info, version)
[10:19:25.869]                           }
[10:19:25.869]                           base::stop(msg)
[10:19:25.869]                         }
[10:19:25.869]                       })
[10:19:25.869]                     }
[10:19:25.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.869]                     base::options(mc.cores = 1L)
[10:19:25.869]                   }
[10:19:25.869]                   ...future.strategy.old <- future::plan("list")
[10:19:25.869]                   options(future.plan = NULL)
[10:19:25.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.869]                 }
[10:19:25.869]                 ...future.workdir <- getwd()
[10:19:25.869]             }
[10:19:25.869]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.869]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.869]         }
[10:19:25.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.869]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:25.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.869]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.869]             base::names(...future.oldOptions))
[10:19:25.869]     }
[10:19:25.869]     if (FALSE) {
[10:19:25.869]     }
[10:19:25.869]     else {
[10:19:25.869]         if (TRUE) {
[10:19:25.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.869]                 open = "w")
[10:19:25.869]         }
[10:19:25.869]         else {
[10:19:25.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.869]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.869]         }
[10:19:25.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.869]             base::sink(type = "output", split = FALSE)
[10:19:25.869]             base::close(...future.stdout)
[10:19:25.869]         }, add = TRUE)
[10:19:25.869]     }
[10:19:25.869]     ...future.frame <- base::sys.nframe()
[10:19:25.869]     ...future.conditions <- base::list()
[10:19:25.869]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.869]     if (FALSE) {
[10:19:25.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.869]     }
[10:19:25.869]     ...future.result <- base::tryCatch({
[10:19:25.869]         base::withCallingHandlers({
[10:19:25.869]             ...future.value <- base::withVisible(base::local({
[10:19:25.869]                 ...future.makeSendCondition <- base::local({
[10:19:25.869]                   sendCondition <- NULL
[10:19:25.869]                   function(frame = 1L) {
[10:19:25.869]                     if (is.function(sendCondition)) 
[10:19:25.869]                       return(sendCondition)
[10:19:25.869]                     ns <- getNamespace("parallel")
[10:19:25.869]                     if (exists("sendData", mode = "function", 
[10:19:25.869]                       envir = ns)) {
[10:19:25.869]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.869]                         envir = ns)
[10:19:25.869]                       envir <- sys.frame(frame)
[10:19:25.869]                       master <- NULL
[10:19:25.869]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.869]                         !identical(envir, emptyenv())) {
[10:19:25.869]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.869]                           inherits = FALSE)) {
[10:19:25.869]                           master <- get("master", mode = "list", 
[10:19:25.869]                             envir = envir, inherits = FALSE)
[10:19:25.869]                           if (inherits(master, c("SOCKnode", 
[10:19:25.869]                             "SOCK0node"))) {
[10:19:25.869]                             sendCondition <<- function(cond) {
[10:19:25.869]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.869]                                 success = TRUE)
[10:19:25.869]                               parallel_sendData(master, data)
[10:19:25.869]                             }
[10:19:25.869]                             return(sendCondition)
[10:19:25.869]                           }
[10:19:25.869]                         }
[10:19:25.869]                         frame <- frame + 1L
[10:19:25.869]                         envir <- sys.frame(frame)
[10:19:25.869]                       }
[10:19:25.869]                     }
[10:19:25.869]                     sendCondition <<- function(cond) NULL
[10:19:25.869]                   }
[10:19:25.869]                 })
[10:19:25.869]                 withCallingHandlers({
[10:19:25.869]                   {
[10:19:25.869]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.869]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.869]                       ...future.globals.maxSize)) {
[10:19:25.869]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.869]                       on.exit(options(oopts), add = TRUE)
[10:19:25.869]                     }
[10:19:25.869]                     {
[10:19:25.869]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.869]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.869]                         USE.NAMES = FALSE)
[10:19:25.869]                       do.call(mapply, args = args)
[10:19:25.869]                     }
[10:19:25.869]                   }
[10:19:25.869]                 }, immediateCondition = function(cond) {
[10:19:25.869]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.869]                   sendCondition(cond)
[10:19:25.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.869]                   {
[10:19:25.869]                     inherits <- base::inherits
[10:19:25.869]                     invokeRestart <- base::invokeRestart
[10:19:25.869]                     is.null <- base::is.null
[10:19:25.869]                     muffled <- FALSE
[10:19:25.869]                     if (inherits(cond, "message")) {
[10:19:25.869]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.869]                       if (muffled) 
[10:19:25.869]                         invokeRestart("muffleMessage")
[10:19:25.869]                     }
[10:19:25.869]                     else if (inherits(cond, "warning")) {
[10:19:25.869]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.869]                       if (muffled) 
[10:19:25.869]                         invokeRestart("muffleWarning")
[10:19:25.869]                     }
[10:19:25.869]                     else if (inherits(cond, "condition")) {
[10:19:25.869]                       if (!is.null(pattern)) {
[10:19:25.869]                         computeRestarts <- base::computeRestarts
[10:19:25.869]                         grepl <- base::grepl
[10:19:25.869]                         restarts <- computeRestarts(cond)
[10:19:25.869]                         for (restart in restarts) {
[10:19:25.869]                           name <- restart$name
[10:19:25.869]                           if (is.null(name)) 
[10:19:25.869]                             next
[10:19:25.869]                           if (!grepl(pattern, name)) 
[10:19:25.869]                             next
[10:19:25.869]                           invokeRestart(restart)
[10:19:25.869]                           muffled <- TRUE
[10:19:25.869]                           break
[10:19:25.869]                         }
[10:19:25.869]                       }
[10:19:25.869]                     }
[10:19:25.869]                     invisible(muffled)
[10:19:25.869]                   }
[10:19:25.869]                   muffleCondition(cond)
[10:19:25.869]                 })
[10:19:25.869]             }))
[10:19:25.869]             future::FutureResult(value = ...future.value$value, 
[10:19:25.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.869]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.869]                     ...future.globalenv.names))
[10:19:25.869]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.869]         }, condition = base::local({
[10:19:25.869]             c <- base::c
[10:19:25.869]             inherits <- base::inherits
[10:19:25.869]             invokeRestart <- base::invokeRestart
[10:19:25.869]             length <- base::length
[10:19:25.869]             list <- base::list
[10:19:25.869]             seq.int <- base::seq.int
[10:19:25.869]             signalCondition <- base::signalCondition
[10:19:25.869]             sys.calls <- base::sys.calls
[10:19:25.869]             `[[` <- base::`[[`
[10:19:25.869]             `+` <- base::`+`
[10:19:25.869]             `<<-` <- base::`<<-`
[10:19:25.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.869]                   3L)]
[10:19:25.869]             }
[10:19:25.869]             function(cond) {
[10:19:25.869]                 is_error <- inherits(cond, "error")
[10:19:25.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.869]                   NULL)
[10:19:25.869]                 if (is_error) {
[10:19:25.869]                   sessionInformation <- function() {
[10:19:25.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.869]                       search = base::search(), system = base::Sys.info())
[10:19:25.869]                   }
[10:19:25.869]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.869]                     cond$call), session = sessionInformation(), 
[10:19:25.869]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.869]                   signalCondition(cond)
[10:19:25.869]                 }
[10:19:25.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.869]                 "immediateCondition"))) {
[10:19:25.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.869]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.869]                   if (TRUE && !signal) {
[10:19:25.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.869]                     {
[10:19:25.869]                       inherits <- base::inherits
[10:19:25.869]                       invokeRestart <- base::invokeRestart
[10:19:25.869]                       is.null <- base::is.null
[10:19:25.869]                       muffled <- FALSE
[10:19:25.869]                       if (inherits(cond, "message")) {
[10:19:25.869]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.869]                         if (muffled) 
[10:19:25.869]                           invokeRestart("muffleMessage")
[10:19:25.869]                       }
[10:19:25.869]                       else if (inherits(cond, "warning")) {
[10:19:25.869]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.869]                         if (muffled) 
[10:19:25.869]                           invokeRestart("muffleWarning")
[10:19:25.869]                       }
[10:19:25.869]                       else if (inherits(cond, "condition")) {
[10:19:25.869]                         if (!is.null(pattern)) {
[10:19:25.869]                           computeRestarts <- base::computeRestarts
[10:19:25.869]                           grepl <- base::grepl
[10:19:25.869]                           restarts <- computeRestarts(cond)
[10:19:25.869]                           for (restart in restarts) {
[10:19:25.869]                             name <- restart$name
[10:19:25.869]                             if (is.null(name)) 
[10:19:25.869]                               next
[10:19:25.869]                             if (!grepl(pattern, name)) 
[10:19:25.869]                               next
[10:19:25.869]                             invokeRestart(restart)
[10:19:25.869]                             muffled <- TRUE
[10:19:25.869]                             break
[10:19:25.869]                           }
[10:19:25.869]                         }
[10:19:25.869]                       }
[10:19:25.869]                       invisible(muffled)
[10:19:25.869]                     }
[10:19:25.869]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.869]                   }
[10:19:25.869]                 }
[10:19:25.869]                 else {
[10:19:25.869]                   if (TRUE) {
[10:19:25.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.869]                     {
[10:19:25.869]                       inherits <- base::inherits
[10:19:25.869]                       invokeRestart <- base::invokeRestart
[10:19:25.869]                       is.null <- base::is.null
[10:19:25.869]                       muffled <- FALSE
[10:19:25.869]                       if (inherits(cond, "message")) {
[10:19:25.869]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.869]                         if (muffled) 
[10:19:25.869]                           invokeRestart("muffleMessage")
[10:19:25.869]                       }
[10:19:25.869]                       else if (inherits(cond, "warning")) {
[10:19:25.869]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.869]                         if (muffled) 
[10:19:25.869]                           invokeRestart("muffleWarning")
[10:19:25.869]                       }
[10:19:25.869]                       else if (inherits(cond, "condition")) {
[10:19:25.869]                         if (!is.null(pattern)) {
[10:19:25.869]                           computeRestarts <- base::computeRestarts
[10:19:25.869]                           grepl <- base::grepl
[10:19:25.869]                           restarts <- computeRestarts(cond)
[10:19:25.869]                           for (restart in restarts) {
[10:19:25.869]                             name <- restart$name
[10:19:25.869]                             if (is.null(name)) 
[10:19:25.869]                               next
[10:19:25.869]                             if (!grepl(pattern, name)) 
[10:19:25.869]                               next
[10:19:25.869]                             invokeRestart(restart)
[10:19:25.869]                             muffled <- TRUE
[10:19:25.869]                             break
[10:19:25.869]                           }
[10:19:25.869]                         }
[10:19:25.869]                       }
[10:19:25.869]                       invisible(muffled)
[10:19:25.869]                     }
[10:19:25.869]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.869]                   }
[10:19:25.869]                 }
[10:19:25.869]             }
[10:19:25.869]         }))
[10:19:25.869]     }, error = function(ex) {
[10:19:25.869]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.869]                 ...future.rng), started = ...future.startTime, 
[10:19:25.869]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.869]             version = "1.8"), class = "FutureResult")
[10:19:25.869]     }, finally = {
[10:19:25.869]         if (!identical(...future.workdir, getwd())) 
[10:19:25.869]             setwd(...future.workdir)
[10:19:25.869]         {
[10:19:25.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.869]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.869]             }
[10:19:25.869]             base::options(...future.oldOptions)
[10:19:25.869]             if (.Platform$OS.type == "windows") {
[10:19:25.869]                 old_names <- names(...future.oldEnvVars)
[10:19:25.869]                 envs <- base::Sys.getenv()
[10:19:25.869]                 names <- names(envs)
[10:19:25.869]                 common <- intersect(names, old_names)
[10:19:25.869]                 added <- setdiff(names, old_names)
[10:19:25.869]                 removed <- setdiff(old_names, names)
[10:19:25.869]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.869]                   envs[common]]
[10:19:25.869]                 NAMES <- toupper(changed)
[10:19:25.869]                 args <- list()
[10:19:25.869]                 for (kk in seq_along(NAMES)) {
[10:19:25.869]                   name <- changed[[kk]]
[10:19:25.869]                   NAME <- NAMES[[kk]]
[10:19:25.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.869]                     next
[10:19:25.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.869]                 }
[10:19:25.869]                 NAMES <- toupper(added)
[10:19:25.869]                 for (kk in seq_along(NAMES)) {
[10:19:25.869]                   name <- added[[kk]]
[10:19:25.869]                   NAME <- NAMES[[kk]]
[10:19:25.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.869]                     next
[10:19:25.869]                   args[[name]] <- ""
[10:19:25.869]                 }
[10:19:25.869]                 NAMES <- toupper(removed)
[10:19:25.869]                 for (kk in seq_along(NAMES)) {
[10:19:25.869]                   name <- removed[[kk]]
[10:19:25.869]                   NAME <- NAMES[[kk]]
[10:19:25.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.869]                     next
[10:19:25.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.869]                 }
[10:19:25.869]                 if (length(args) > 0) 
[10:19:25.869]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.869]             }
[10:19:25.869]             else {
[10:19:25.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.869]             }
[10:19:25.869]             {
[10:19:25.869]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.869]                   0L) {
[10:19:25.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.869]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.869]                   base::options(opts)
[10:19:25.869]                 }
[10:19:25.869]                 {
[10:19:25.869]                   {
[10:19:25.869]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.869]                     NULL
[10:19:25.869]                   }
[10:19:25.869]                   options(future.plan = NULL)
[10:19:25.869]                   if (is.na(NA_character_)) 
[10:19:25.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.869]                     .init = FALSE)
[10:19:25.869]                 }
[10:19:25.869]             }
[10:19:25.869]         }
[10:19:25.869]     })
[10:19:25.869]     if (TRUE) {
[10:19:25.869]         base::sink(type = "output", split = FALSE)
[10:19:25.869]         if (TRUE) {
[10:19:25.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.869]         }
[10:19:25.869]         else {
[10:19:25.869]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.869]         }
[10:19:25.869]         base::close(...future.stdout)
[10:19:25.869]         ...future.stdout <- NULL
[10:19:25.869]     }
[10:19:25.869]     ...future.result$conditions <- ...future.conditions
[10:19:25.869]     ...future.result$finished <- base::Sys.time()
[10:19:25.869]     ...future.result
[10:19:25.869] }
[10:19:25.872] Exporting 5 global objects (1.29 KiB) to cluster node #1 ...
[10:19:25.872] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:19:25.872] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:19:25.872] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:25.873] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.873] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:19:25.873] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:19:25.873] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:25.874] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.874] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:25.874] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.874] Exporting 5 global objects (1.29 KiB) to cluster node #1 ... DONE
[10:19:25.875] MultisessionFuture started
[10:19:25.875] - Launch lazy future ... done
[10:19:25.875] run() for ‘MultisessionFuture’ ... done
[10:19:25.875] Created future:
[10:19:25.875] MultisessionFuture:
[10:19:25.875] Label: ‘future_mapply-1’
[10:19:25.875] Expression:
[10:19:25.875] {
[10:19:25.875]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.875]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.875]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.875]         on.exit(options(oopts), add = TRUE)
[10:19:25.875]     }
[10:19:25.875]     {
[10:19:25.875]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.875]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.875]         do.call(mapply, args = args)
[10:19:25.875]     }
[10:19:25.875] }
[10:19:25.875] Lazy evaluation: FALSE
[10:19:25.875] Asynchronous evaluation: TRUE
[10:19:25.875] Local evaluation: TRUE
[10:19:25.875] Environment: R_GlobalEnv
[10:19:25.875] Capture standard output: TRUE
[10:19:25.875] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.875] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.875] Packages: <none>
[10:19:25.875] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.875] Resolved: FALSE
[10:19:25.875] Value: <not collected>
[10:19:25.875] Conditions captured: <none>
[10:19:25.875] Early signaling: FALSE
[10:19:25.875] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.875] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.886] Chunk #1 of 2 ... DONE
[10:19:25.887] Chunk #2 of 2 ...
[10:19:25.889]  - Finding globals in '...' for chunk #2 ...
[10:19:25.889] getGlobalsAndPackages() ...
[10:19:25.889] Searching for globals...
[10:19:25.889] 
[10:19:25.889] Searching for globals ... DONE
[10:19:25.890] - globals: [0] <none>
[10:19:25.890] getGlobalsAndPackages() ... DONE
[10:19:25.890]    + additional globals found: [n=0] 
[10:19:25.890]    + additional namespaces needed: [n=0] 
[10:19:25.890]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:25.890]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:25.890]  - seeds: <none>
[10:19:25.890]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.890] getGlobalsAndPackages() ...
[10:19:25.890] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.890] Resolving globals: FALSE
[10:19:25.891] The total size of the 5 globals is 905 bytes (905 bytes)
[10:19:25.891] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 905 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:25.891] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.891] 
[10:19:25.892] getGlobalsAndPackages() ... DONE
[10:19:25.892] run() for ‘Future’ ...
[10:19:25.892] - state: ‘created’
[10:19:25.892] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.905] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.906]   - Field: ‘node’
[10:19:25.906]   - Field: ‘label’
[10:19:25.906]   - Field: ‘local’
[10:19:25.906]   - Field: ‘owner’
[10:19:25.906]   - Field: ‘envir’
[10:19:25.906]   - Field: ‘workers’
[10:19:25.906]   - Field: ‘packages’
[10:19:25.906]   - Field: ‘gc’
[10:19:25.906]   - Field: ‘conditions’
[10:19:25.906]   - Field: ‘persistent’
[10:19:25.907]   - Field: ‘expr’
[10:19:25.907]   - Field: ‘uuid’
[10:19:25.907]   - Field: ‘seed’
[10:19:25.907]   - Field: ‘version’
[10:19:25.907]   - Field: ‘result’
[10:19:25.907]   - Field: ‘asynchronous’
[10:19:25.907]   - Field: ‘calls’
[10:19:25.907]   - Field: ‘globals’
[10:19:25.907]   - Field: ‘stdout’
[10:19:25.907]   - Field: ‘earlySignal’
[10:19:25.907]   - Field: ‘lazy’
[10:19:25.907]   - Field: ‘state’
[10:19:25.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.908] - Launch lazy future ...
[10:19:25.908] Packages needed by the future expression (n = 0): <none>
[10:19:25.908] Packages needed by future strategies (n = 0): <none>
[10:19:25.908] {
[10:19:25.908]     {
[10:19:25.908]         {
[10:19:25.908]             ...future.startTime <- base::Sys.time()
[10:19:25.908]             {
[10:19:25.908]                 {
[10:19:25.908]                   {
[10:19:25.908]                     {
[10:19:25.908]                       base::local({
[10:19:25.908]                         has_future <- base::requireNamespace("future", 
[10:19:25.908]                           quietly = TRUE)
[10:19:25.908]                         if (has_future) {
[10:19:25.908]                           ns <- base::getNamespace("future")
[10:19:25.908]                           version <- ns[[".package"]][["version"]]
[10:19:25.908]                           if (is.null(version)) 
[10:19:25.908]                             version <- utils::packageVersion("future")
[10:19:25.908]                         }
[10:19:25.908]                         else {
[10:19:25.908]                           version <- NULL
[10:19:25.908]                         }
[10:19:25.908]                         if (!has_future || version < "1.8.0") {
[10:19:25.908]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.908]                             "", base::R.version$version.string), 
[10:19:25.908]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.908]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.908]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.908]                               "release", "version")], collapse = " "), 
[10:19:25.908]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.908]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.908]                             info)
[10:19:25.908]                           info <- base::paste(info, collapse = "; ")
[10:19:25.908]                           if (!has_future) {
[10:19:25.908]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.908]                               info)
[10:19:25.908]                           }
[10:19:25.908]                           else {
[10:19:25.908]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.908]                               info, version)
[10:19:25.908]                           }
[10:19:25.908]                           base::stop(msg)
[10:19:25.908]                         }
[10:19:25.908]                       })
[10:19:25.908]                     }
[10:19:25.908]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.908]                     base::options(mc.cores = 1L)
[10:19:25.908]                   }
[10:19:25.908]                   ...future.strategy.old <- future::plan("list")
[10:19:25.908]                   options(future.plan = NULL)
[10:19:25.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.908]                 }
[10:19:25.908]                 ...future.workdir <- getwd()
[10:19:25.908]             }
[10:19:25.908]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.908]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.908]         }
[10:19:25.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.908]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:25.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.908]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.908]             base::names(...future.oldOptions))
[10:19:25.908]     }
[10:19:25.908]     if (FALSE) {
[10:19:25.908]     }
[10:19:25.908]     else {
[10:19:25.908]         if (TRUE) {
[10:19:25.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.908]                 open = "w")
[10:19:25.908]         }
[10:19:25.908]         else {
[10:19:25.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.908]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.908]         }
[10:19:25.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.908]             base::sink(type = "output", split = FALSE)
[10:19:25.908]             base::close(...future.stdout)
[10:19:25.908]         }, add = TRUE)
[10:19:25.908]     }
[10:19:25.908]     ...future.frame <- base::sys.nframe()
[10:19:25.908]     ...future.conditions <- base::list()
[10:19:25.908]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.908]     if (FALSE) {
[10:19:25.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.908]     }
[10:19:25.908]     ...future.result <- base::tryCatch({
[10:19:25.908]         base::withCallingHandlers({
[10:19:25.908]             ...future.value <- base::withVisible(base::local({
[10:19:25.908]                 ...future.makeSendCondition <- base::local({
[10:19:25.908]                   sendCondition <- NULL
[10:19:25.908]                   function(frame = 1L) {
[10:19:25.908]                     if (is.function(sendCondition)) 
[10:19:25.908]                       return(sendCondition)
[10:19:25.908]                     ns <- getNamespace("parallel")
[10:19:25.908]                     if (exists("sendData", mode = "function", 
[10:19:25.908]                       envir = ns)) {
[10:19:25.908]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.908]                         envir = ns)
[10:19:25.908]                       envir <- sys.frame(frame)
[10:19:25.908]                       master <- NULL
[10:19:25.908]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.908]                         !identical(envir, emptyenv())) {
[10:19:25.908]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.908]                           inherits = FALSE)) {
[10:19:25.908]                           master <- get("master", mode = "list", 
[10:19:25.908]                             envir = envir, inherits = FALSE)
[10:19:25.908]                           if (inherits(master, c("SOCKnode", 
[10:19:25.908]                             "SOCK0node"))) {
[10:19:25.908]                             sendCondition <<- function(cond) {
[10:19:25.908]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.908]                                 success = TRUE)
[10:19:25.908]                               parallel_sendData(master, data)
[10:19:25.908]                             }
[10:19:25.908]                             return(sendCondition)
[10:19:25.908]                           }
[10:19:25.908]                         }
[10:19:25.908]                         frame <- frame + 1L
[10:19:25.908]                         envir <- sys.frame(frame)
[10:19:25.908]                       }
[10:19:25.908]                     }
[10:19:25.908]                     sendCondition <<- function(cond) NULL
[10:19:25.908]                   }
[10:19:25.908]                 })
[10:19:25.908]                 withCallingHandlers({
[10:19:25.908]                   {
[10:19:25.908]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.908]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.908]                       ...future.globals.maxSize)) {
[10:19:25.908]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.908]                       on.exit(options(oopts), add = TRUE)
[10:19:25.908]                     }
[10:19:25.908]                     {
[10:19:25.908]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.908]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.908]                         USE.NAMES = FALSE)
[10:19:25.908]                       do.call(mapply, args = args)
[10:19:25.908]                     }
[10:19:25.908]                   }
[10:19:25.908]                 }, immediateCondition = function(cond) {
[10:19:25.908]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.908]                   sendCondition(cond)
[10:19:25.908]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.908]                   {
[10:19:25.908]                     inherits <- base::inherits
[10:19:25.908]                     invokeRestart <- base::invokeRestart
[10:19:25.908]                     is.null <- base::is.null
[10:19:25.908]                     muffled <- FALSE
[10:19:25.908]                     if (inherits(cond, "message")) {
[10:19:25.908]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.908]                       if (muffled) 
[10:19:25.908]                         invokeRestart("muffleMessage")
[10:19:25.908]                     }
[10:19:25.908]                     else if (inherits(cond, "warning")) {
[10:19:25.908]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.908]                       if (muffled) 
[10:19:25.908]                         invokeRestart("muffleWarning")
[10:19:25.908]                     }
[10:19:25.908]                     else if (inherits(cond, "condition")) {
[10:19:25.908]                       if (!is.null(pattern)) {
[10:19:25.908]                         computeRestarts <- base::computeRestarts
[10:19:25.908]                         grepl <- base::grepl
[10:19:25.908]                         restarts <- computeRestarts(cond)
[10:19:25.908]                         for (restart in restarts) {
[10:19:25.908]                           name <- restart$name
[10:19:25.908]                           if (is.null(name)) 
[10:19:25.908]                             next
[10:19:25.908]                           if (!grepl(pattern, name)) 
[10:19:25.908]                             next
[10:19:25.908]                           invokeRestart(restart)
[10:19:25.908]                           muffled <- TRUE
[10:19:25.908]                           break
[10:19:25.908]                         }
[10:19:25.908]                       }
[10:19:25.908]                     }
[10:19:25.908]                     invisible(muffled)
[10:19:25.908]                   }
[10:19:25.908]                   muffleCondition(cond)
[10:19:25.908]                 })
[10:19:25.908]             }))
[10:19:25.908]             future::FutureResult(value = ...future.value$value, 
[10:19:25.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.908]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.908]                     ...future.globalenv.names))
[10:19:25.908]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.908]         }, condition = base::local({
[10:19:25.908]             c <- base::c
[10:19:25.908]             inherits <- base::inherits
[10:19:25.908]             invokeRestart <- base::invokeRestart
[10:19:25.908]             length <- base::length
[10:19:25.908]             list <- base::list
[10:19:25.908]             seq.int <- base::seq.int
[10:19:25.908]             signalCondition <- base::signalCondition
[10:19:25.908]             sys.calls <- base::sys.calls
[10:19:25.908]             `[[` <- base::`[[`
[10:19:25.908]             `+` <- base::`+`
[10:19:25.908]             `<<-` <- base::`<<-`
[10:19:25.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.908]                   3L)]
[10:19:25.908]             }
[10:19:25.908]             function(cond) {
[10:19:25.908]                 is_error <- inherits(cond, "error")
[10:19:25.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.908]                   NULL)
[10:19:25.908]                 if (is_error) {
[10:19:25.908]                   sessionInformation <- function() {
[10:19:25.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.908]                       search = base::search(), system = base::Sys.info())
[10:19:25.908]                   }
[10:19:25.908]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.908]                     cond$call), session = sessionInformation(), 
[10:19:25.908]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.908]                   signalCondition(cond)
[10:19:25.908]                 }
[10:19:25.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.908]                 "immediateCondition"))) {
[10:19:25.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.908]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.908]                   if (TRUE && !signal) {
[10:19:25.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.908]                     {
[10:19:25.908]                       inherits <- base::inherits
[10:19:25.908]                       invokeRestart <- base::invokeRestart
[10:19:25.908]                       is.null <- base::is.null
[10:19:25.908]                       muffled <- FALSE
[10:19:25.908]                       if (inherits(cond, "message")) {
[10:19:25.908]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.908]                         if (muffled) 
[10:19:25.908]                           invokeRestart("muffleMessage")
[10:19:25.908]                       }
[10:19:25.908]                       else if (inherits(cond, "warning")) {
[10:19:25.908]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.908]                         if (muffled) 
[10:19:25.908]                           invokeRestart("muffleWarning")
[10:19:25.908]                       }
[10:19:25.908]                       else if (inherits(cond, "condition")) {
[10:19:25.908]                         if (!is.null(pattern)) {
[10:19:25.908]                           computeRestarts <- base::computeRestarts
[10:19:25.908]                           grepl <- base::grepl
[10:19:25.908]                           restarts <- computeRestarts(cond)
[10:19:25.908]                           for (restart in restarts) {
[10:19:25.908]                             name <- restart$name
[10:19:25.908]                             if (is.null(name)) 
[10:19:25.908]                               next
[10:19:25.908]                             if (!grepl(pattern, name)) 
[10:19:25.908]                               next
[10:19:25.908]                             invokeRestart(restart)
[10:19:25.908]                             muffled <- TRUE
[10:19:25.908]                             break
[10:19:25.908]                           }
[10:19:25.908]                         }
[10:19:25.908]                       }
[10:19:25.908]                       invisible(muffled)
[10:19:25.908]                     }
[10:19:25.908]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.908]                   }
[10:19:25.908]                 }
[10:19:25.908]                 else {
[10:19:25.908]                   if (TRUE) {
[10:19:25.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.908]                     {
[10:19:25.908]                       inherits <- base::inherits
[10:19:25.908]                       invokeRestart <- base::invokeRestart
[10:19:25.908]                       is.null <- base::is.null
[10:19:25.908]                       muffled <- FALSE
[10:19:25.908]                       if (inherits(cond, "message")) {
[10:19:25.908]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.908]                         if (muffled) 
[10:19:25.908]                           invokeRestart("muffleMessage")
[10:19:25.908]                       }
[10:19:25.908]                       else if (inherits(cond, "warning")) {
[10:19:25.908]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.908]                         if (muffled) 
[10:19:25.908]                           invokeRestart("muffleWarning")
[10:19:25.908]                       }
[10:19:25.908]                       else if (inherits(cond, "condition")) {
[10:19:25.908]                         if (!is.null(pattern)) {
[10:19:25.908]                           computeRestarts <- base::computeRestarts
[10:19:25.908]                           grepl <- base::grepl
[10:19:25.908]                           restarts <- computeRestarts(cond)
[10:19:25.908]                           for (restart in restarts) {
[10:19:25.908]                             name <- restart$name
[10:19:25.908]                             if (is.null(name)) 
[10:19:25.908]                               next
[10:19:25.908]                             if (!grepl(pattern, name)) 
[10:19:25.908]                               next
[10:19:25.908]                             invokeRestart(restart)
[10:19:25.908]                             muffled <- TRUE
[10:19:25.908]                             break
[10:19:25.908]                           }
[10:19:25.908]                         }
[10:19:25.908]                       }
[10:19:25.908]                       invisible(muffled)
[10:19:25.908]                     }
[10:19:25.908]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.908]                   }
[10:19:25.908]                 }
[10:19:25.908]             }
[10:19:25.908]         }))
[10:19:25.908]     }, error = function(ex) {
[10:19:25.908]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.908]                 ...future.rng), started = ...future.startTime, 
[10:19:25.908]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.908]             version = "1.8"), class = "FutureResult")
[10:19:25.908]     }, finally = {
[10:19:25.908]         if (!identical(...future.workdir, getwd())) 
[10:19:25.908]             setwd(...future.workdir)
[10:19:25.908]         {
[10:19:25.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.908]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.908]             }
[10:19:25.908]             base::options(...future.oldOptions)
[10:19:25.908]             if (.Platform$OS.type == "windows") {
[10:19:25.908]                 old_names <- names(...future.oldEnvVars)
[10:19:25.908]                 envs <- base::Sys.getenv()
[10:19:25.908]                 names <- names(envs)
[10:19:25.908]                 common <- intersect(names, old_names)
[10:19:25.908]                 added <- setdiff(names, old_names)
[10:19:25.908]                 removed <- setdiff(old_names, names)
[10:19:25.908]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.908]                   envs[common]]
[10:19:25.908]                 NAMES <- toupper(changed)
[10:19:25.908]                 args <- list()
[10:19:25.908]                 for (kk in seq_along(NAMES)) {
[10:19:25.908]                   name <- changed[[kk]]
[10:19:25.908]                   NAME <- NAMES[[kk]]
[10:19:25.908]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.908]                     next
[10:19:25.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.908]                 }
[10:19:25.908]                 NAMES <- toupper(added)
[10:19:25.908]                 for (kk in seq_along(NAMES)) {
[10:19:25.908]                   name <- added[[kk]]
[10:19:25.908]                   NAME <- NAMES[[kk]]
[10:19:25.908]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.908]                     next
[10:19:25.908]                   args[[name]] <- ""
[10:19:25.908]                 }
[10:19:25.908]                 NAMES <- toupper(removed)
[10:19:25.908]                 for (kk in seq_along(NAMES)) {
[10:19:25.908]                   name <- removed[[kk]]
[10:19:25.908]                   NAME <- NAMES[[kk]]
[10:19:25.908]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.908]                     next
[10:19:25.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.908]                 }
[10:19:25.908]                 if (length(args) > 0) 
[10:19:25.908]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.908]             }
[10:19:25.908]             else {
[10:19:25.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.908]             }
[10:19:25.908]             {
[10:19:25.908]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.908]                   0L) {
[10:19:25.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.908]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.908]                   base::options(opts)
[10:19:25.908]                 }
[10:19:25.908]                 {
[10:19:25.908]                   {
[10:19:25.908]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.908]                     NULL
[10:19:25.908]                   }
[10:19:25.908]                   options(future.plan = NULL)
[10:19:25.908]                   if (is.na(NA_character_)) 
[10:19:25.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.908]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.908]                     .init = FALSE)
[10:19:25.908]                 }
[10:19:25.908]             }
[10:19:25.908]         }
[10:19:25.908]     })
[10:19:25.908]     if (TRUE) {
[10:19:25.908]         base::sink(type = "output", split = FALSE)
[10:19:25.908]         if (TRUE) {
[10:19:25.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.908]         }
[10:19:25.908]         else {
[10:19:25.908]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.908]         }
[10:19:25.908]         base::close(...future.stdout)
[10:19:25.908]         ...future.stdout <- NULL
[10:19:25.908]     }
[10:19:25.908]     ...future.result$conditions <- ...future.conditions
[10:19:25.908]     ...future.result$finished <- base::Sys.time()
[10:19:25.908]     ...future.result
[10:19:25.908] }
[10:19:25.911] Exporting 5 global objects (1.32 KiB) to cluster node #2 ...
[10:19:25.911] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:19:25.911] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:19:25.912] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:25.912] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.912] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[10:19:25.912] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[10:19:25.912] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:25.913] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.913] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:25.913] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:25.913] Exporting 5 global objects (1.32 KiB) to cluster node #2 ... DONE
[10:19:25.914] MultisessionFuture started
[10:19:25.914] - Launch lazy future ... done
[10:19:25.914] run() for ‘MultisessionFuture’ ... done
[10:19:25.914] Created future:
[10:19:25.914] MultisessionFuture:
[10:19:25.914] Label: ‘future_mapply-2’
[10:19:25.914] Expression:
[10:19:25.914] {
[10:19:25.914]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.914]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.914]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.914]         on.exit(options(oopts), add = TRUE)
[10:19:25.914]     }
[10:19:25.914]     {
[10:19:25.914]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.914]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.914]         do.call(mapply, args = args)
[10:19:25.914]     }
[10:19:25.914] }
[10:19:25.914] Lazy evaluation: FALSE
[10:19:25.914] Asynchronous evaluation: TRUE
[10:19:25.914] Local evaluation: TRUE
[10:19:25.914] Environment: R_GlobalEnv
[10:19:25.914] Capture standard output: TRUE
[10:19:25.914] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.914] Globals: 5 objects totaling 905 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.914] Packages: <none>
[10:19:25.914] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.914] Resolved: FALSE
[10:19:25.914] Value: <not collected>
[10:19:25.914] Conditions captured: <none>
[10:19:25.914] Early signaling: FALSE
[10:19:25.914] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.914] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.925] Chunk #2 of 2 ... DONE
[10:19:25.925] Launching 2 futures (chunks) ... DONE
[10:19:25.925] Resolving 2 futures (chunks) ...
[10:19:25.925] resolve() on list ...
[10:19:25.926]  recursive: 0
[10:19:25.926]  length: 2
[10:19:25.926] 
[10:19:25.926] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.926] - Validating connection of MultisessionFuture
[10:19:25.926] - received message: FutureResult
[10:19:25.927] - Received FutureResult
[10:19:25.927] - Erased future from FutureRegistry
[10:19:25.927] result() for ClusterFuture ...
[10:19:25.927] - result already collected: FutureResult
[10:19:25.927] result() for ClusterFuture ... done
[10:19:25.927] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.927] Future #1
[10:19:25.927] result() for ClusterFuture ...
[10:19:25.927] - result already collected: FutureResult
[10:19:25.927] result() for ClusterFuture ... done
[10:19:25.927] result() for ClusterFuture ...
[10:19:25.927] - result already collected: FutureResult
[10:19:25.928] result() for ClusterFuture ... done
[10:19:25.928] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:25.928] - nx: 2
[10:19:25.928] - relay: TRUE
[10:19:25.928] - stdout: TRUE
[10:19:25.928] - signal: TRUE
[10:19:25.928] - resignal: FALSE
[10:19:25.928] - force: TRUE
[10:19:25.928] - relayed: [n=2] FALSE, FALSE
[10:19:25.928] - queued futures: [n=2] FALSE, FALSE
[10:19:25.928]  - until=1
[10:19:25.928]  - relaying element #1
[10:19:25.929] result() for ClusterFuture ...
[10:19:25.929] - result already collected: FutureResult
[10:19:25.929] result() for ClusterFuture ... done
[10:19:25.929] result() for ClusterFuture ...
[10:19:25.929] - result already collected: FutureResult
[10:19:25.929] result() for ClusterFuture ... done
[10:19:25.929] result() for ClusterFuture ...
[10:19:25.929] - result already collected: FutureResult
[10:19:25.929] result() for ClusterFuture ... done
[10:19:25.929] result() for ClusterFuture ...
[10:19:25.929] - result already collected: FutureResult
[10:19:25.929] result() for ClusterFuture ... done
[10:19:25.930] - relayed: [n=2] TRUE, FALSE
[10:19:25.930] - queued futures: [n=2] TRUE, FALSE
[10:19:25.930] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:25.930]  length: 1 (resolved future 1)
[10:19:25.956] receiveMessageFromWorker() for ClusterFuture ...
[10:19:25.956] - Validating connection of MultisessionFuture
[10:19:25.956] - received message: FutureResult
[10:19:25.956] - Received FutureResult
[10:19:25.956] - Erased future from FutureRegistry
[10:19:25.956] result() for ClusterFuture ...
[10:19:25.957] - result already collected: FutureResult
[10:19:25.957] result() for ClusterFuture ... done
[10:19:25.957] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:25.957] Future #2
[10:19:25.957] result() for ClusterFuture ...
[10:19:25.957] - result already collected: FutureResult
[10:19:25.957] result() for ClusterFuture ... done
[10:19:25.957] result() for ClusterFuture ...
[10:19:25.957] - result already collected: FutureResult
[10:19:25.957] result() for ClusterFuture ... done
[10:19:25.957] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:25.957] - nx: 2
[10:19:25.958] - relay: TRUE
[10:19:25.958] - stdout: TRUE
[10:19:25.958] - signal: TRUE
[10:19:25.958] - resignal: FALSE
[10:19:25.958] - force: TRUE
[10:19:25.958] - relayed: [n=2] TRUE, FALSE
[10:19:25.958] - queued futures: [n=2] TRUE, FALSE
[10:19:25.958]  - until=2
[10:19:25.958]  - relaying element #2
[10:19:25.958] result() for ClusterFuture ...
[10:19:25.958] - result already collected: FutureResult
[10:19:25.958] result() for ClusterFuture ... done
[10:19:25.958] result() for ClusterFuture ...
[10:19:25.959] - result already collected: FutureResult
[10:19:25.959] result() for ClusterFuture ... done
[10:19:25.959] result() for ClusterFuture ...
[10:19:25.959] - result already collected: FutureResult
[10:19:25.959] result() for ClusterFuture ... done
[10:19:25.959] result() for ClusterFuture ...
[10:19:25.959] - result already collected: FutureResult
[10:19:25.959] result() for ClusterFuture ... done
[10:19:25.959] - relayed: [n=2] TRUE, TRUE
[10:19:25.959] - queued futures: [n=2] TRUE, TRUE
[10:19:25.959] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:25.959]  length: 0 (resolved future 2)
[10:19:25.960] Relaying remaining futures
[10:19:25.960] signalConditionsASAP(NULL, pos=0) ...
[10:19:25.960] - nx: 2
[10:19:25.960] - relay: TRUE
[10:19:25.960] - stdout: TRUE
[10:19:25.960] - signal: TRUE
[10:19:25.960] - resignal: FALSE
[10:19:25.960] - force: TRUE
[10:19:25.960] - relayed: [n=2] TRUE, TRUE
[10:19:25.960] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:25.960] - relayed: [n=2] TRUE, TRUE
[10:19:25.960] - queued futures: [n=2] TRUE, TRUE
[10:19:25.961] signalConditionsASAP(NULL, pos=0) ... done
[10:19:25.961] resolve() on list ... DONE
[10:19:25.961] result() for ClusterFuture ...
[10:19:25.961] - result already collected: FutureResult
[10:19:25.961] result() for ClusterFuture ... done
[10:19:25.961] result() for ClusterFuture ...
[10:19:25.961] - result already collected: FutureResult
[10:19:25.961] result() for ClusterFuture ... done
[10:19:25.961] result() for ClusterFuture ...
[10:19:25.961] - result already collected: FutureResult
[10:19:25.961] result() for ClusterFuture ... done
[10:19:25.962] result() for ClusterFuture ...
[10:19:25.962] - result already collected: FutureResult
[10:19:25.962] result() for ClusterFuture ... done
[10:19:25.962]  - Number of value chunks collected: 2
[10:19:25.962] Resolving 2 futures (chunks) ... DONE
[10:19:25.962] Reducing values from 2 chunks ...
[10:19:25.962]  - Number of values collected after concatenation: 5
[10:19:25.962]  - Number of values expected: 5
[10:19:25.962] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[10:19:25.962] Reducing values from 2 chunks ... DONE
[10:19:25.962] future_mapply() ... DONE
[10:19:25.963] future_mapply() ...
[10:19:25.964] Number of chunks: 2
[10:19:25.964] getGlobalsAndPackagesXApply() ...
[10:19:25.964]  - future.globals: TRUE
[10:19:25.965] getGlobalsAndPackages() ...
[10:19:25.965] Searching for globals...
[10:19:25.966] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[10:19:25.966] Searching for globals ... DONE
[10:19:25.966] Resolving globals: FALSE
[10:19:25.966] The total size of the 1 globals is 690 bytes (690 bytes)
[10:19:25.967] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[10:19:25.967] - globals: [1] ‘FUN’
[10:19:25.967] 
[10:19:25.967] getGlobalsAndPackages() ... DONE
[10:19:25.967]  - globals found/used: [n=1] ‘FUN’
[10:19:25.967]  - needed namespaces: [n=0] 
[10:19:25.967] Finding globals ... DONE
[10:19:25.967] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:25.968] List of 2
[10:19:25.968]  $ ...future.FUN:function (C, k)  
[10:19:25.968]  $ MoreArgs     : list()
[10:19:25.968]  - attr(*, "where")=List of 2
[10:19:25.968]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:25.968]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:25.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:25.968]  - attr(*, "resolved")= logi FALSE
[10:19:25.968]  - attr(*, "total_size")= num NA
[10:19:25.970] Packages to be attached in all futures: [n=0] 
[10:19:25.970] getGlobalsAndPackagesXApply() ... DONE
[10:19:25.970] Number of futures (= number of chunks): 2
[10:19:25.970] Launching 2 futures (chunks) ...
[10:19:25.970] Chunk #1 of 2 ...
[10:19:25.971]  - Finding globals in '...' for chunk #1 ...
[10:19:25.971] getGlobalsAndPackages() ...
[10:19:25.971] Searching for globals...
[10:19:25.971] 
[10:19:25.971] Searching for globals ... DONE
[10:19:25.971] - globals: [0] <none>
[10:19:25.971] getGlobalsAndPackages() ... DONE
[10:19:25.971]    + additional globals found: [n=0] 
[10:19:25.971]    + additional namespaces needed: [n=0] 
[10:19:25.972]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:25.972]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:25.972]  - seeds: <none>
[10:19:25.972]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.972] getGlobalsAndPackages() ...
[10:19:25.972] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.972] Resolving globals: FALSE
[10:19:25.972] The total size of the 5 globals is 880 bytes (880 bytes)
[10:19:25.973] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:25.973] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:25.973] 
[10:19:25.973] getGlobalsAndPackages() ... DONE
[10:19:25.973] run() for ‘Future’ ...
[10:19:25.974] - state: ‘created’
[10:19:25.974] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:25.987] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:25.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:25.987]   - Field: ‘node’
[10:19:25.988]   - Field: ‘label’
[10:19:25.988]   - Field: ‘local’
[10:19:25.988]   - Field: ‘owner’
[10:19:25.988]   - Field: ‘envir’
[10:19:25.988]   - Field: ‘workers’
[10:19:25.988]   - Field: ‘packages’
[10:19:25.988]   - Field: ‘gc’
[10:19:25.988]   - Field: ‘conditions’
[10:19:25.988]   - Field: ‘persistent’
[10:19:25.988]   - Field: ‘expr’
[10:19:25.988]   - Field: ‘uuid’
[10:19:25.988]   - Field: ‘seed’
[10:19:25.989]   - Field: ‘version’
[10:19:25.989]   - Field: ‘result’
[10:19:25.989]   - Field: ‘asynchronous’
[10:19:25.989]   - Field: ‘calls’
[10:19:25.989]   - Field: ‘globals’
[10:19:25.989]   - Field: ‘stdout’
[10:19:25.989]   - Field: ‘earlySignal’
[10:19:25.989]   - Field: ‘lazy’
[10:19:25.989]   - Field: ‘state’
[10:19:25.989] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:25.989] - Launch lazy future ...
[10:19:25.990] Packages needed by the future expression (n = 0): <none>
[10:19:25.990] Packages needed by future strategies (n = 0): <none>
[10:19:25.990] {
[10:19:25.990]     {
[10:19:25.990]         {
[10:19:25.990]             ...future.startTime <- base::Sys.time()
[10:19:25.990]             {
[10:19:25.990]                 {
[10:19:25.990]                   {
[10:19:25.990]                     {
[10:19:25.990]                       base::local({
[10:19:25.990]                         has_future <- base::requireNamespace("future", 
[10:19:25.990]                           quietly = TRUE)
[10:19:25.990]                         if (has_future) {
[10:19:25.990]                           ns <- base::getNamespace("future")
[10:19:25.990]                           version <- ns[[".package"]][["version"]]
[10:19:25.990]                           if (is.null(version)) 
[10:19:25.990]                             version <- utils::packageVersion("future")
[10:19:25.990]                         }
[10:19:25.990]                         else {
[10:19:25.990]                           version <- NULL
[10:19:25.990]                         }
[10:19:25.990]                         if (!has_future || version < "1.8.0") {
[10:19:25.990]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:25.990]                             "", base::R.version$version.string), 
[10:19:25.990]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:25.990]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:25.990]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:25.990]                               "release", "version")], collapse = " "), 
[10:19:25.990]                             hostname = base::Sys.info()[["nodename"]])
[10:19:25.990]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:25.990]                             info)
[10:19:25.990]                           info <- base::paste(info, collapse = "; ")
[10:19:25.990]                           if (!has_future) {
[10:19:25.990]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:25.990]                               info)
[10:19:25.990]                           }
[10:19:25.990]                           else {
[10:19:25.990]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:25.990]                               info, version)
[10:19:25.990]                           }
[10:19:25.990]                           base::stop(msg)
[10:19:25.990]                         }
[10:19:25.990]                       })
[10:19:25.990]                     }
[10:19:25.990]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:25.990]                     base::options(mc.cores = 1L)
[10:19:25.990]                   }
[10:19:25.990]                   ...future.strategy.old <- future::plan("list")
[10:19:25.990]                   options(future.plan = NULL)
[10:19:25.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:25.990]                 }
[10:19:25.990]                 ...future.workdir <- getwd()
[10:19:25.990]             }
[10:19:25.990]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:25.990]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:25.990]         }
[10:19:25.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:25.990]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:25.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:25.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:25.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:25.990]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:25.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:25.990]             base::names(...future.oldOptions))
[10:19:25.990]     }
[10:19:25.990]     if (FALSE) {
[10:19:25.990]     }
[10:19:25.990]     else {
[10:19:25.990]         if (TRUE) {
[10:19:25.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:25.990]                 open = "w")
[10:19:25.990]         }
[10:19:25.990]         else {
[10:19:25.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:25.990]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:25.990]         }
[10:19:25.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:25.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:25.990]             base::sink(type = "output", split = FALSE)
[10:19:25.990]             base::close(...future.stdout)
[10:19:25.990]         }, add = TRUE)
[10:19:25.990]     }
[10:19:25.990]     ...future.frame <- base::sys.nframe()
[10:19:25.990]     ...future.conditions <- base::list()
[10:19:25.990]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:25.990]     if (FALSE) {
[10:19:25.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:25.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:25.990]     }
[10:19:25.990]     ...future.result <- base::tryCatch({
[10:19:25.990]         base::withCallingHandlers({
[10:19:25.990]             ...future.value <- base::withVisible(base::local({
[10:19:25.990]                 ...future.makeSendCondition <- base::local({
[10:19:25.990]                   sendCondition <- NULL
[10:19:25.990]                   function(frame = 1L) {
[10:19:25.990]                     if (is.function(sendCondition)) 
[10:19:25.990]                       return(sendCondition)
[10:19:25.990]                     ns <- getNamespace("parallel")
[10:19:25.990]                     if (exists("sendData", mode = "function", 
[10:19:25.990]                       envir = ns)) {
[10:19:25.990]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:25.990]                         envir = ns)
[10:19:25.990]                       envir <- sys.frame(frame)
[10:19:25.990]                       master <- NULL
[10:19:25.990]                       while (!identical(envir, .GlobalEnv) && 
[10:19:25.990]                         !identical(envir, emptyenv())) {
[10:19:25.990]                         if (exists("master", mode = "list", envir = envir, 
[10:19:25.990]                           inherits = FALSE)) {
[10:19:25.990]                           master <- get("master", mode = "list", 
[10:19:25.990]                             envir = envir, inherits = FALSE)
[10:19:25.990]                           if (inherits(master, c("SOCKnode", 
[10:19:25.990]                             "SOCK0node"))) {
[10:19:25.990]                             sendCondition <<- function(cond) {
[10:19:25.990]                               data <- list(type = "VALUE", value = cond, 
[10:19:25.990]                                 success = TRUE)
[10:19:25.990]                               parallel_sendData(master, data)
[10:19:25.990]                             }
[10:19:25.990]                             return(sendCondition)
[10:19:25.990]                           }
[10:19:25.990]                         }
[10:19:25.990]                         frame <- frame + 1L
[10:19:25.990]                         envir <- sys.frame(frame)
[10:19:25.990]                       }
[10:19:25.990]                     }
[10:19:25.990]                     sendCondition <<- function(cond) NULL
[10:19:25.990]                   }
[10:19:25.990]                 })
[10:19:25.990]                 withCallingHandlers({
[10:19:25.990]                   {
[10:19:25.990]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.990]                     if (!identical(...future.globals.maxSize.org, 
[10:19:25.990]                       ...future.globals.maxSize)) {
[10:19:25.990]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.990]                       on.exit(options(oopts), add = TRUE)
[10:19:25.990]                     }
[10:19:25.990]                     {
[10:19:25.990]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.990]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:25.990]                         USE.NAMES = FALSE)
[10:19:25.990]                       do.call(mapply, args = args)
[10:19:25.990]                     }
[10:19:25.990]                   }
[10:19:25.990]                 }, immediateCondition = function(cond) {
[10:19:25.990]                   sendCondition <- ...future.makeSendCondition()
[10:19:25.990]                   sendCondition(cond)
[10:19:25.990]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.990]                   {
[10:19:25.990]                     inherits <- base::inherits
[10:19:25.990]                     invokeRestart <- base::invokeRestart
[10:19:25.990]                     is.null <- base::is.null
[10:19:25.990]                     muffled <- FALSE
[10:19:25.990]                     if (inherits(cond, "message")) {
[10:19:25.990]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:25.990]                       if (muffled) 
[10:19:25.990]                         invokeRestart("muffleMessage")
[10:19:25.990]                     }
[10:19:25.990]                     else if (inherits(cond, "warning")) {
[10:19:25.990]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:25.990]                       if (muffled) 
[10:19:25.990]                         invokeRestart("muffleWarning")
[10:19:25.990]                     }
[10:19:25.990]                     else if (inherits(cond, "condition")) {
[10:19:25.990]                       if (!is.null(pattern)) {
[10:19:25.990]                         computeRestarts <- base::computeRestarts
[10:19:25.990]                         grepl <- base::grepl
[10:19:25.990]                         restarts <- computeRestarts(cond)
[10:19:25.990]                         for (restart in restarts) {
[10:19:25.990]                           name <- restart$name
[10:19:25.990]                           if (is.null(name)) 
[10:19:25.990]                             next
[10:19:25.990]                           if (!grepl(pattern, name)) 
[10:19:25.990]                             next
[10:19:25.990]                           invokeRestart(restart)
[10:19:25.990]                           muffled <- TRUE
[10:19:25.990]                           break
[10:19:25.990]                         }
[10:19:25.990]                       }
[10:19:25.990]                     }
[10:19:25.990]                     invisible(muffled)
[10:19:25.990]                   }
[10:19:25.990]                   muffleCondition(cond)
[10:19:25.990]                 })
[10:19:25.990]             }))
[10:19:25.990]             future::FutureResult(value = ...future.value$value, 
[10:19:25.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.990]                   ...future.rng), globalenv = if (FALSE) 
[10:19:25.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:25.990]                     ...future.globalenv.names))
[10:19:25.990]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:25.990]         }, condition = base::local({
[10:19:25.990]             c <- base::c
[10:19:25.990]             inherits <- base::inherits
[10:19:25.990]             invokeRestart <- base::invokeRestart
[10:19:25.990]             length <- base::length
[10:19:25.990]             list <- base::list
[10:19:25.990]             seq.int <- base::seq.int
[10:19:25.990]             signalCondition <- base::signalCondition
[10:19:25.990]             sys.calls <- base::sys.calls
[10:19:25.990]             `[[` <- base::`[[`
[10:19:25.990]             `+` <- base::`+`
[10:19:25.990]             `<<-` <- base::`<<-`
[10:19:25.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:25.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:25.990]                   3L)]
[10:19:25.990]             }
[10:19:25.990]             function(cond) {
[10:19:25.990]                 is_error <- inherits(cond, "error")
[10:19:25.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:25.990]                   NULL)
[10:19:25.990]                 if (is_error) {
[10:19:25.990]                   sessionInformation <- function() {
[10:19:25.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:25.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:25.990]                       search = base::search(), system = base::Sys.info())
[10:19:25.990]                   }
[10:19:25.990]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:25.990]                     cond$call), session = sessionInformation(), 
[10:19:25.990]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:25.990]                   signalCondition(cond)
[10:19:25.990]                 }
[10:19:25.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:25.990]                 "immediateCondition"))) {
[10:19:25.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:25.990]                   ...future.conditions[[length(...future.conditions) + 
[10:19:25.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:25.990]                   if (TRUE && !signal) {
[10:19:25.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.990]                     {
[10:19:25.990]                       inherits <- base::inherits
[10:19:25.990]                       invokeRestart <- base::invokeRestart
[10:19:25.990]                       is.null <- base::is.null
[10:19:25.990]                       muffled <- FALSE
[10:19:25.990]                       if (inherits(cond, "message")) {
[10:19:25.990]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.990]                         if (muffled) 
[10:19:25.990]                           invokeRestart("muffleMessage")
[10:19:25.990]                       }
[10:19:25.990]                       else if (inherits(cond, "warning")) {
[10:19:25.990]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.990]                         if (muffled) 
[10:19:25.990]                           invokeRestart("muffleWarning")
[10:19:25.990]                       }
[10:19:25.990]                       else if (inherits(cond, "condition")) {
[10:19:25.990]                         if (!is.null(pattern)) {
[10:19:25.990]                           computeRestarts <- base::computeRestarts
[10:19:25.990]                           grepl <- base::grepl
[10:19:25.990]                           restarts <- computeRestarts(cond)
[10:19:25.990]                           for (restart in restarts) {
[10:19:25.990]                             name <- restart$name
[10:19:25.990]                             if (is.null(name)) 
[10:19:25.990]                               next
[10:19:25.990]                             if (!grepl(pattern, name)) 
[10:19:25.990]                               next
[10:19:25.990]                             invokeRestart(restart)
[10:19:25.990]                             muffled <- TRUE
[10:19:25.990]                             break
[10:19:25.990]                           }
[10:19:25.990]                         }
[10:19:25.990]                       }
[10:19:25.990]                       invisible(muffled)
[10:19:25.990]                     }
[10:19:25.990]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.990]                   }
[10:19:25.990]                 }
[10:19:25.990]                 else {
[10:19:25.990]                   if (TRUE) {
[10:19:25.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:25.990]                     {
[10:19:25.990]                       inherits <- base::inherits
[10:19:25.990]                       invokeRestart <- base::invokeRestart
[10:19:25.990]                       is.null <- base::is.null
[10:19:25.990]                       muffled <- FALSE
[10:19:25.990]                       if (inherits(cond, "message")) {
[10:19:25.990]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:25.990]                         if (muffled) 
[10:19:25.990]                           invokeRestart("muffleMessage")
[10:19:25.990]                       }
[10:19:25.990]                       else if (inherits(cond, "warning")) {
[10:19:25.990]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:25.990]                         if (muffled) 
[10:19:25.990]                           invokeRestart("muffleWarning")
[10:19:25.990]                       }
[10:19:25.990]                       else if (inherits(cond, "condition")) {
[10:19:25.990]                         if (!is.null(pattern)) {
[10:19:25.990]                           computeRestarts <- base::computeRestarts
[10:19:25.990]                           grepl <- base::grepl
[10:19:25.990]                           restarts <- computeRestarts(cond)
[10:19:25.990]                           for (restart in restarts) {
[10:19:25.990]                             name <- restart$name
[10:19:25.990]                             if (is.null(name)) 
[10:19:25.990]                               next
[10:19:25.990]                             if (!grepl(pattern, name)) 
[10:19:25.990]                               next
[10:19:25.990]                             invokeRestart(restart)
[10:19:25.990]                             muffled <- TRUE
[10:19:25.990]                             break
[10:19:25.990]                           }
[10:19:25.990]                         }
[10:19:25.990]                       }
[10:19:25.990]                       invisible(muffled)
[10:19:25.990]                     }
[10:19:25.990]                     muffleCondition(cond, pattern = "^muffle")
[10:19:25.990]                   }
[10:19:25.990]                 }
[10:19:25.990]             }
[10:19:25.990]         }))
[10:19:25.990]     }, error = function(ex) {
[10:19:25.990]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:25.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:25.990]                 ...future.rng), started = ...future.startTime, 
[10:19:25.990]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:25.990]             version = "1.8"), class = "FutureResult")
[10:19:25.990]     }, finally = {
[10:19:25.990]         if (!identical(...future.workdir, getwd())) 
[10:19:25.990]             setwd(...future.workdir)
[10:19:25.990]         {
[10:19:25.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:25.990]                 ...future.oldOptions$nwarnings <- NULL
[10:19:25.990]             }
[10:19:25.990]             base::options(...future.oldOptions)
[10:19:25.990]             if (.Platform$OS.type == "windows") {
[10:19:25.990]                 old_names <- names(...future.oldEnvVars)
[10:19:25.990]                 envs <- base::Sys.getenv()
[10:19:25.990]                 names <- names(envs)
[10:19:25.990]                 common <- intersect(names, old_names)
[10:19:25.990]                 added <- setdiff(names, old_names)
[10:19:25.990]                 removed <- setdiff(old_names, names)
[10:19:25.990]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:25.990]                   envs[common]]
[10:19:25.990]                 NAMES <- toupper(changed)
[10:19:25.990]                 args <- list()
[10:19:25.990]                 for (kk in seq_along(NAMES)) {
[10:19:25.990]                   name <- changed[[kk]]
[10:19:25.990]                   NAME <- NAMES[[kk]]
[10:19:25.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.990]                     next
[10:19:25.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.990]                 }
[10:19:25.990]                 NAMES <- toupper(added)
[10:19:25.990]                 for (kk in seq_along(NAMES)) {
[10:19:25.990]                   name <- added[[kk]]
[10:19:25.990]                   NAME <- NAMES[[kk]]
[10:19:25.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.990]                     next
[10:19:25.990]                   args[[name]] <- ""
[10:19:25.990]                 }
[10:19:25.990]                 NAMES <- toupper(removed)
[10:19:25.990]                 for (kk in seq_along(NAMES)) {
[10:19:25.990]                   name <- removed[[kk]]
[10:19:25.990]                   NAME <- NAMES[[kk]]
[10:19:25.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:25.990]                     next
[10:19:25.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:25.990]                 }
[10:19:25.990]                 if (length(args) > 0) 
[10:19:25.990]                   base::do.call(base::Sys.setenv, args = args)
[10:19:25.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:25.990]             }
[10:19:25.990]             else {
[10:19:25.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:25.990]             }
[10:19:25.990]             {
[10:19:25.990]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:25.990]                   0L) {
[10:19:25.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:25.990]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:25.990]                   base::options(opts)
[10:19:25.990]                 }
[10:19:25.990]                 {
[10:19:25.990]                   {
[10:19:25.990]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:25.990]                     NULL
[10:19:25.990]                   }
[10:19:25.990]                   options(future.plan = NULL)
[10:19:25.990]                   if (is.na(NA_character_)) 
[10:19:25.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:25.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:25.990]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:25.990]                     .init = FALSE)
[10:19:25.990]                 }
[10:19:25.990]             }
[10:19:25.990]         }
[10:19:25.990]     })
[10:19:25.990]     if (TRUE) {
[10:19:25.990]         base::sink(type = "output", split = FALSE)
[10:19:25.990]         if (TRUE) {
[10:19:25.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:25.990]         }
[10:19:25.990]         else {
[10:19:25.990]             ...future.result["stdout"] <- base::list(NULL)
[10:19:25.990]         }
[10:19:25.990]         base::close(...future.stdout)
[10:19:25.990]         ...future.stdout <- NULL
[10:19:25.990]     }
[10:19:25.990]     ...future.result$conditions <- ...future.conditions
[10:19:25.990]     ...future.result$finished <- base::Sys.time()
[10:19:25.990]     ...future.result
[10:19:25.990] }
[10:19:25.993] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[10:19:25.993] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[10:19:25.993] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[10:19:25.994] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[10:19:25.994] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[10:19:25.994] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[10:19:25.994] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[10:19:25.995] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:25.995] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.995] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:25.995] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:25.996] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[10:19:25.996] MultisessionFuture started
[10:19:25.996] - Launch lazy future ... done
[10:19:25.996] run() for ‘MultisessionFuture’ ... done
[10:19:25.996] Created future:
[10:19:25.996] MultisessionFuture:
[10:19:25.996] Label: ‘future_.mapply-1’
[10:19:25.996] Expression:
[10:19:25.996] {
[10:19:25.996]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:25.996]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:25.996]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:25.996]         on.exit(options(oopts), add = TRUE)
[10:19:25.996]     }
[10:19:25.996]     {
[10:19:25.996]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:25.996]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:25.996]         do.call(mapply, args = args)
[10:19:25.996]     }
[10:19:25.996] }
[10:19:25.996] Lazy evaluation: FALSE
[10:19:25.996] Asynchronous evaluation: TRUE
[10:19:25.996] Local evaluation: TRUE
[10:19:25.996] Environment: R_GlobalEnv
[10:19:25.996] Capture standard output: TRUE
[10:19:25.996] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:25.996] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:25.996] Packages: <none>
[10:19:25.996] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:25.996] Resolved: FALSE
[10:19:25.996] Value: <not collected>
[10:19:25.996] Conditions captured: <none>
[10:19:25.996] Early signaling: FALSE
[10:19:25.996] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:25.996] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.008] Chunk #1 of 2 ... DONE
[10:19:26.008] Chunk #2 of 2 ...
[10:19:26.008]  - Finding globals in '...' for chunk #2 ...
[10:19:26.008] getGlobalsAndPackages() ...
[10:19:26.008] Searching for globals...
[10:19:26.009] 
[10:19:26.009] Searching for globals ... DONE
[10:19:26.009] - globals: [0] <none>
[10:19:26.009] getGlobalsAndPackages() ... DONE
[10:19:26.009]    + additional globals found: [n=0] 
[10:19:26.009]    + additional namespaces needed: [n=0] 
[10:19:26.009]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:26.009]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.009]  - seeds: <none>
[10:19:26.009]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.010] getGlobalsAndPackages() ...
[10:19:26.010] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.010] Resolving globals: FALSE
[10:19:26.010] The total size of the 5 globals is 909 bytes (909 bytes)
[10:19:26.011] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:26.011] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.011] 
[10:19:26.011] getGlobalsAndPackages() ... DONE
[10:19:26.011] run() for ‘Future’ ...
[10:19:26.011] - state: ‘created’
[10:19:26.011] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.025] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.026]   - Field: ‘node’
[10:19:26.026]   - Field: ‘label’
[10:19:26.026]   - Field: ‘local’
[10:19:26.026]   - Field: ‘owner’
[10:19:26.026]   - Field: ‘envir’
[10:19:26.026]   - Field: ‘workers’
[10:19:26.026]   - Field: ‘packages’
[10:19:26.026]   - Field: ‘gc’
[10:19:26.026]   - Field: ‘conditions’
[10:19:26.026]   - Field: ‘persistent’
[10:19:26.026]   - Field: ‘expr’
[10:19:26.027]   - Field: ‘uuid’
[10:19:26.027]   - Field: ‘seed’
[10:19:26.027]   - Field: ‘version’
[10:19:26.027]   - Field: ‘result’
[10:19:26.027]   - Field: ‘asynchronous’
[10:19:26.027]   - Field: ‘calls’
[10:19:26.027]   - Field: ‘globals’
[10:19:26.027]   - Field: ‘stdout’
[10:19:26.027]   - Field: ‘earlySignal’
[10:19:26.027]   - Field: ‘lazy’
[10:19:26.027]   - Field: ‘state’
[10:19:26.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.028] - Launch lazy future ...
[10:19:26.028] Packages needed by the future expression (n = 0): <none>
[10:19:26.028] Packages needed by future strategies (n = 0): <none>
[10:19:26.028] {
[10:19:26.028]     {
[10:19:26.028]         {
[10:19:26.028]             ...future.startTime <- base::Sys.time()
[10:19:26.028]             {
[10:19:26.028]                 {
[10:19:26.028]                   {
[10:19:26.028]                     {
[10:19:26.028]                       base::local({
[10:19:26.028]                         has_future <- base::requireNamespace("future", 
[10:19:26.028]                           quietly = TRUE)
[10:19:26.028]                         if (has_future) {
[10:19:26.028]                           ns <- base::getNamespace("future")
[10:19:26.028]                           version <- ns[[".package"]][["version"]]
[10:19:26.028]                           if (is.null(version)) 
[10:19:26.028]                             version <- utils::packageVersion("future")
[10:19:26.028]                         }
[10:19:26.028]                         else {
[10:19:26.028]                           version <- NULL
[10:19:26.028]                         }
[10:19:26.028]                         if (!has_future || version < "1.8.0") {
[10:19:26.028]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.028]                             "", base::R.version$version.string), 
[10:19:26.028]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.028]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.028]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.028]                               "release", "version")], collapse = " "), 
[10:19:26.028]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.028]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.028]                             info)
[10:19:26.028]                           info <- base::paste(info, collapse = "; ")
[10:19:26.028]                           if (!has_future) {
[10:19:26.028]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.028]                               info)
[10:19:26.028]                           }
[10:19:26.028]                           else {
[10:19:26.028]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.028]                               info, version)
[10:19:26.028]                           }
[10:19:26.028]                           base::stop(msg)
[10:19:26.028]                         }
[10:19:26.028]                       })
[10:19:26.028]                     }
[10:19:26.028]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.028]                     base::options(mc.cores = 1L)
[10:19:26.028]                   }
[10:19:26.028]                   ...future.strategy.old <- future::plan("list")
[10:19:26.028]                   options(future.plan = NULL)
[10:19:26.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.028]                 }
[10:19:26.028]                 ...future.workdir <- getwd()
[10:19:26.028]             }
[10:19:26.028]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.028]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.028]         }
[10:19:26.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.028]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.028]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.028]             base::names(...future.oldOptions))
[10:19:26.028]     }
[10:19:26.028]     if (FALSE) {
[10:19:26.028]     }
[10:19:26.028]     else {
[10:19:26.028]         if (TRUE) {
[10:19:26.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.028]                 open = "w")
[10:19:26.028]         }
[10:19:26.028]         else {
[10:19:26.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.028]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.028]         }
[10:19:26.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.028]             base::sink(type = "output", split = FALSE)
[10:19:26.028]             base::close(...future.stdout)
[10:19:26.028]         }, add = TRUE)
[10:19:26.028]     }
[10:19:26.028]     ...future.frame <- base::sys.nframe()
[10:19:26.028]     ...future.conditions <- base::list()
[10:19:26.028]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.028]     if (FALSE) {
[10:19:26.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.028]     }
[10:19:26.028]     ...future.result <- base::tryCatch({
[10:19:26.028]         base::withCallingHandlers({
[10:19:26.028]             ...future.value <- base::withVisible(base::local({
[10:19:26.028]                 ...future.makeSendCondition <- base::local({
[10:19:26.028]                   sendCondition <- NULL
[10:19:26.028]                   function(frame = 1L) {
[10:19:26.028]                     if (is.function(sendCondition)) 
[10:19:26.028]                       return(sendCondition)
[10:19:26.028]                     ns <- getNamespace("parallel")
[10:19:26.028]                     if (exists("sendData", mode = "function", 
[10:19:26.028]                       envir = ns)) {
[10:19:26.028]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.028]                         envir = ns)
[10:19:26.028]                       envir <- sys.frame(frame)
[10:19:26.028]                       master <- NULL
[10:19:26.028]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.028]                         !identical(envir, emptyenv())) {
[10:19:26.028]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.028]                           inherits = FALSE)) {
[10:19:26.028]                           master <- get("master", mode = "list", 
[10:19:26.028]                             envir = envir, inherits = FALSE)
[10:19:26.028]                           if (inherits(master, c("SOCKnode", 
[10:19:26.028]                             "SOCK0node"))) {
[10:19:26.028]                             sendCondition <<- function(cond) {
[10:19:26.028]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.028]                                 success = TRUE)
[10:19:26.028]                               parallel_sendData(master, data)
[10:19:26.028]                             }
[10:19:26.028]                             return(sendCondition)
[10:19:26.028]                           }
[10:19:26.028]                         }
[10:19:26.028]                         frame <- frame + 1L
[10:19:26.028]                         envir <- sys.frame(frame)
[10:19:26.028]                       }
[10:19:26.028]                     }
[10:19:26.028]                     sendCondition <<- function(cond) NULL
[10:19:26.028]                   }
[10:19:26.028]                 })
[10:19:26.028]                 withCallingHandlers({
[10:19:26.028]                   {
[10:19:26.028]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.028]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.028]                       ...future.globals.maxSize)) {
[10:19:26.028]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.028]                       on.exit(options(oopts), add = TRUE)
[10:19:26.028]                     }
[10:19:26.028]                     {
[10:19:26.028]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.028]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.028]                         USE.NAMES = FALSE)
[10:19:26.028]                       do.call(mapply, args = args)
[10:19:26.028]                     }
[10:19:26.028]                   }
[10:19:26.028]                 }, immediateCondition = function(cond) {
[10:19:26.028]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.028]                   sendCondition(cond)
[10:19:26.028]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.028]                   {
[10:19:26.028]                     inherits <- base::inherits
[10:19:26.028]                     invokeRestart <- base::invokeRestart
[10:19:26.028]                     is.null <- base::is.null
[10:19:26.028]                     muffled <- FALSE
[10:19:26.028]                     if (inherits(cond, "message")) {
[10:19:26.028]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.028]                       if (muffled) 
[10:19:26.028]                         invokeRestart("muffleMessage")
[10:19:26.028]                     }
[10:19:26.028]                     else if (inherits(cond, "warning")) {
[10:19:26.028]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.028]                       if (muffled) 
[10:19:26.028]                         invokeRestart("muffleWarning")
[10:19:26.028]                     }
[10:19:26.028]                     else if (inherits(cond, "condition")) {
[10:19:26.028]                       if (!is.null(pattern)) {
[10:19:26.028]                         computeRestarts <- base::computeRestarts
[10:19:26.028]                         grepl <- base::grepl
[10:19:26.028]                         restarts <- computeRestarts(cond)
[10:19:26.028]                         for (restart in restarts) {
[10:19:26.028]                           name <- restart$name
[10:19:26.028]                           if (is.null(name)) 
[10:19:26.028]                             next
[10:19:26.028]                           if (!grepl(pattern, name)) 
[10:19:26.028]                             next
[10:19:26.028]                           invokeRestart(restart)
[10:19:26.028]                           muffled <- TRUE
[10:19:26.028]                           break
[10:19:26.028]                         }
[10:19:26.028]                       }
[10:19:26.028]                     }
[10:19:26.028]                     invisible(muffled)
[10:19:26.028]                   }
[10:19:26.028]                   muffleCondition(cond)
[10:19:26.028]                 })
[10:19:26.028]             }))
[10:19:26.028]             future::FutureResult(value = ...future.value$value, 
[10:19:26.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.028]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.028]                     ...future.globalenv.names))
[10:19:26.028]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.028]         }, condition = base::local({
[10:19:26.028]             c <- base::c
[10:19:26.028]             inherits <- base::inherits
[10:19:26.028]             invokeRestart <- base::invokeRestart
[10:19:26.028]             length <- base::length
[10:19:26.028]             list <- base::list
[10:19:26.028]             seq.int <- base::seq.int
[10:19:26.028]             signalCondition <- base::signalCondition
[10:19:26.028]             sys.calls <- base::sys.calls
[10:19:26.028]             `[[` <- base::`[[`
[10:19:26.028]             `+` <- base::`+`
[10:19:26.028]             `<<-` <- base::`<<-`
[10:19:26.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.028]                   3L)]
[10:19:26.028]             }
[10:19:26.028]             function(cond) {
[10:19:26.028]                 is_error <- inherits(cond, "error")
[10:19:26.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.028]                   NULL)
[10:19:26.028]                 if (is_error) {
[10:19:26.028]                   sessionInformation <- function() {
[10:19:26.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.028]                       search = base::search(), system = base::Sys.info())
[10:19:26.028]                   }
[10:19:26.028]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.028]                     cond$call), session = sessionInformation(), 
[10:19:26.028]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.028]                   signalCondition(cond)
[10:19:26.028]                 }
[10:19:26.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.028]                 "immediateCondition"))) {
[10:19:26.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.028]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.028]                   if (TRUE && !signal) {
[10:19:26.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.028]                     {
[10:19:26.028]                       inherits <- base::inherits
[10:19:26.028]                       invokeRestart <- base::invokeRestart
[10:19:26.028]                       is.null <- base::is.null
[10:19:26.028]                       muffled <- FALSE
[10:19:26.028]                       if (inherits(cond, "message")) {
[10:19:26.028]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.028]                         if (muffled) 
[10:19:26.028]                           invokeRestart("muffleMessage")
[10:19:26.028]                       }
[10:19:26.028]                       else if (inherits(cond, "warning")) {
[10:19:26.028]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.028]                         if (muffled) 
[10:19:26.028]                           invokeRestart("muffleWarning")
[10:19:26.028]                       }
[10:19:26.028]                       else if (inherits(cond, "condition")) {
[10:19:26.028]                         if (!is.null(pattern)) {
[10:19:26.028]                           computeRestarts <- base::computeRestarts
[10:19:26.028]                           grepl <- base::grepl
[10:19:26.028]                           restarts <- computeRestarts(cond)
[10:19:26.028]                           for (restart in restarts) {
[10:19:26.028]                             name <- restart$name
[10:19:26.028]                             if (is.null(name)) 
[10:19:26.028]                               next
[10:19:26.028]                             if (!grepl(pattern, name)) 
[10:19:26.028]                               next
[10:19:26.028]                             invokeRestart(restart)
[10:19:26.028]                             muffled <- TRUE
[10:19:26.028]                             break
[10:19:26.028]                           }
[10:19:26.028]                         }
[10:19:26.028]                       }
[10:19:26.028]                       invisible(muffled)
[10:19:26.028]                     }
[10:19:26.028]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.028]                   }
[10:19:26.028]                 }
[10:19:26.028]                 else {
[10:19:26.028]                   if (TRUE) {
[10:19:26.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.028]                     {
[10:19:26.028]                       inherits <- base::inherits
[10:19:26.028]                       invokeRestart <- base::invokeRestart
[10:19:26.028]                       is.null <- base::is.null
[10:19:26.028]                       muffled <- FALSE
[10:19:26.028]                       if (inherits(cond, "message")) {
[10:19:26.028]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.028]                         if (muffled) 
[10:19:26.028]                           invokeRestart("muffleMessage")
[10:19:26.028]                       }
[10:19:26.028]                       else if (inherits(cond, "warning")) {
[10:19:26.028]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.028]                         if (muffled) 
[10:19:26.028]                           invokeRestart("muffleWarning")
[10:19:26.028]                       }
[10:19:26.028]                       else if (inherits(cond, "condition")) {
[10:19:26.028]                         if (!is.null(pattern)) {
[10:19:26.028]                           computeRestarts <- base::computeRestarts
[10:19:26.028]                           grepl <- base::grepl
[10:19:26.028]                           restarts <- computeRestarts(cond)
[10:19:26.028]                           for (restart in restarts) {
[10:19:26.028]                             name <- restart$name
[10:19:26.028]                             if (is.null(name)) 
[10:19:26.028]                               next
[10:19:26.028]                             if (!grepl(pattern, name)) 
[10:19:26.028]                               next
[10:19:26.028]                             invokeRestart(restart)
[10:19:26.028]                             muffled <- TRUE
[10:19:26.028]                             break
[10:19:26.028]                           }
[10:19:26.028]                         }
[10:19:26.028]                       }
[10:19:26.028]                       invisible(muffled)
[10:19:26.028]                     }
[10:19:26.028]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.028]                   }
[10:19:26.028]                 }
[10:19:26.028]             }
[10:19:26.028]         }))
[10:19:26.028]     }, error = function(ex) {
[10:19:26.028]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.028]                 ...future.rng), started = ...future.startTime, 
[10:19:26.028]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.028]             version = "1.8"), class = "FutureResult")
[10:19:26.028]     }, finally = {
[10:19:26.028]         if (!identical(...future.workdir, getwd())) 
[10:19:26.028]             setwd(...future.workdir)
[10:19:26.028]         {
[10:19:26.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.028]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.028]             }
[10:19:26.028]             base::options(...future.oldOptions)
[10:19:26.028]             if (.Platform$OS.type == "windows") {
[10:19:26.028]                 old_names <- names(...future.oldEnvVars)
[10:19:26.028]                 envs <- base::Sys.getenv()
[10:19:26.028]                 names <- names(envs)
[10:19:26.028]                 common <- intersect(names, old_names)
[10:19:26.028]                 added <- setdiff(names, old_names)
[10:19:26.028]                 removed <- setdiff(old_names, names)
[10:19:26.028]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.028]                   envs[common]]
[10:19:26.028]                 NAMES <- toupper(changed)
[10:19:26.028]                 args <- list()
[10:19:26.028]                 for (kk in seq_along(NAMES)) {
[10:19:26.028]                   name <- changed[[kk]]
[10:19:26.028]                   NAME <- NAMES[[kk]]
[10:19:26.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.028]                     next
[10:19:26.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.028]                 }
[10:19:26.028]                 NAMES <- toupper(added)
[10:19:26.028]                 for (kk in seq_along(NAMES)) {
[10:19:26.028]                   name <- added[[kk]]
[10:19:26.028]                   NAME <- NAMES[[kk]]
[10:19:26.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.028]                     next
[10:19:26.028]                   args[[name]] <- ""
[10:19:26.028]                 }
[10:19:26.028]                 NAMES <- toupper(removed)
[10:19:26.028]                 for (kk in seq_along(NAMES)) {
[10:19:26.028]                   name <- removed[[kk]]
[10:19:26.028]                   NAME <- NAMES[[kk]]
[10:19:26.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.028]                     next
[10:19:26.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.028]                 }
[10:19:26.028]                 if (length(args) > 0) 
[10:19:26.028]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.028]             }
[10:19:26.028]             else {
[10:19:26.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.028]             }
[10:19:26.028]             {
[10:19:26.028]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.028]                   0L) {
[10:19:26.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.028]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.028]                   base::options(opts)
[10:19:26.028]                 }
[10:19:26.028]                 {
[10:19:26.028]                   {
[10:19:26.028]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.028]                     NULL
[10:19:26.028]                   }
[10:19:26.028]                   options(future.plan = NULL)
[10:19:26.028]                   if (is.na(NA_character_)) 
[10:19:26.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.028]                     .init = FALSE)
[10:19:26.028]                 }
[10:19:26.028]             }
[10:19:26.028]         }
[10:19:26.028]     })
[10:19:26.028]     if (TRUE) {
[10:19:26.028]         base::sink(type = "output", split = FALSE)
[10:19:26.028]         if (TRUE) {
[10:19:26.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.028]         }
[10:19:26.028]         else {
[10:19:26.028]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.028]         }
[10:19:26.028]         base::close(...future.stdout)
[10:19:26.028]         ...future.stdout <- NULL
[10:19:26.028]     }
[10:19:26.028]     ...future.result$conditions <- ...future.conditions
[10:19:26.028]     ...future.result$finished <- base::Sys.time()
[10:19:26.028]     ...future.result
[10:19:26.028] }
[10:19:26.031] Exporting 5 global objects (1.33 KiB) to cluster node #2 ...
[10:19:26.031] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[10:19:26.032] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[10:19:26.032] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[10:19:26.032] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[10:19:26.032] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[10:19:26.032] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[10:19:26.033] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:26.033] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.033] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:26.033] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.033] Exporting 5 global objects (1.33 KiB) to cluster node #2 ... DONE
[10:19:26.034] MultisessionFuture started
[10:19:26.034] - Launch lazy future ... done
[10:19:26.034] run() for ‘MultisessionFuture’ ... done
[10:19:26.034] Created future:
[10:19:26.034] MultisessionFuture:
[10:19:26.034] Label: ‘future_.mapply-2’
[10:19:26.034] Expression:
[10:19:26.034] {
[10:19:26.034]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.034]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.034]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.034]         on.exit(options(oopts), add = TRUE)
[10:19:26.034]     }
[10:19:26.034]     {
[10:19:26.034]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.034]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.034]         do.call(mapply, args = args)
[10:19:26.034]     }
[10:19:26.034] }
[10:19:26.034] Lazy evaluation: FALSE
[10:19:26.034] Asynchronous evaluation: TRUE
[10:19:26.034] Local evaluation: TRUE
[10:19:26.034] Environment: R_GlobalEnv
[10:19:26.034] Capture standard output: TRUE
[10:19:26.034] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.034] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.034] Packages: <none>
[10:19:26.034] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.034] Resolved: FALSE
[10:19:26.034] Value: <not collected>
[10:19:26.034] Conditions captured: <none>
[10:19:26.034] Early signaling: FALSE
[10:19:26.034] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.034] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.045] Chunk #2 of 2 ... DONE
[10:19:26.046] Launching 2 futures (chunks) ... DONE
[10:19:26.046] Resolving 2 futures (chunks) ...
[10:19:26.046] resolve() on list ...
[10:19:26.046]  recursive: 0
[10:19:26.046]  length: 2
[10:19:26.046] 
[10:19:26.046] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.047] - Validating connection of MultisessionFuture
[10:19:26.047] - received message: FutureResult
[10:19:26.047] - Received FutureResult
[10:19:26.047] - Erased future from FutureRegistry
[10:19:26.047] result() for ClusterFuture ...
[10:19:26.047] - result already collected: FutureResult
[10:19:26.047] result() for ClusterFuture ... done
[10:19:26.047] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.047] Future #1
[10:19:26.047] result() for ClusterFuture ...
[10:19:26.048] - result already collected: FutureResult
[10:19:26.048] result() for ClusterFuture ... done
[10:19:26.048] result() for ClusterFuture ...
[10:19:26.048] - result already collected: FutureResult
[10:19:26.048] result() for ClusterFuture ... done
[10:19:26.048] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:26.048] - nx: 2
[10:19:26.048] - relay: TRUE
[10:19:26.048] - stdout: TRUE
[10:19:26.048] - signal: TRUE
[10:19:26.048] - resignal: FALSE
[10:19:26.048] - force: TRUE
[10:19:26.049] - relayed: [n=2] FALSE, FALSE
[10:19:26.049] - queued futures: [n=2] FALSE, FALSE
[10:19:26.049]  - until=1
[10:19:26.049]  - relaying element #1
[10:19:26.049] result() for ClusterFuture ...
[10:19:26.049] - result already collected: FutureResult
[10:19:26.049] result() for ClusterFuture ... done
[10:19:26.050] result() for ClusterFuture ...
[10:19:26.050] - result already collected: FutureResult
[10:19:26.050] result() for ClusterFuture ... done
[10:19:26.050] result() for ClusterFuture ...
[10:19:26.050] - result already collected: FutureResult
[10:19:26.050] result() for ClusterFuture ... done
[10:19:26.050] result() for ClusterFuture ...
[10:19:26.050] - result already collected: FutureResult
[10:19:26.051] result() for ClusterFuture ... done
[10:19:26.051] - relayed: [n=2] TRUE, FALSE
[10:19:26.051] - queued futures: [n=2] TRUE, FALSE
[10:19:26.051] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:26.051]  length: 1 (resolved future 1)
[10:19:26.076] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.076] - Validating connection of MultisessionFuture
[10:19:26.076] - received message: FutureResult
[10:19:26.076] - Received FutureResult
[10:19:26.077] - Erased future from FutureRegistry
[10:19:26.077] result() for ClusterFuture ...
[10:19:26.077] - result already collected: FutureResult
[10:19:26.077] result() for ClusterFuture ... done
[10:19:26.077] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.077] Future #2
[10:19:26.077] result() for ClusterFuture ...
[10:19:26.077] - result already collected: FutureResult
[10:19:26.077] result() for ClusterFuture ... done
[10:19:26.077] result() for ClusterFuture ...
[10:19:26.077] - result already collected: FutureResult
[10:19:26.078] result() for ClusterFuture ... done
[10:19:26.078] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:26.078] - nx: 2
[10:19:26.078] - relay: TRUE
[10:19:26.078] - stdout: TRUE
[10:19:26.078] - signal: TRUE
[10:19:26.078] - resignal: FALSE
[10:19:26.078] - force: TRUE
[10:19:26.078] - relayed: [n=2] TRUE, FALSE
[10:19:26.078] - queued futures: [n=2] TRUE, FALSE
[10:19:26.078]  - until=2
[10:19:26.078]  - relaying element #2
[10:19:26.079] result() for ClusterFuture ...
[10:19:26.079] - result already collected: FutureResult
[10:19:26.079] result() for ClusterFuture ... done
[10:19:26.079] result() for ClusterFuture ...
[10:19:26.079] - result already collected: FutureResult
[10:19:26.079] result() for ClusterFuture ... done
[10:19:26.079] result() for ClusterFuture ...
[10:19:26.079] - result already collected: FutureResult
[10:19:26.079] result() for ClusterFuture ... done
[10:19:26.079] result() for ClusterFuture ...
[10:19:26.079] - result already collected: FutureResult
[10:19:26.079] result() for ClusterFuture ... done
[10:19:26.080] - relayed: [n=2] TRUE, TRUE
[10:19:26.080] - queued futures: [n=2] TRUE, TRUE
[10:19:26.080] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:26.080]  length: 0 (resolved future 2)
[10:19:26.080] Relaying remaining futures
[10:19:26.080] signalConditionsASAP(NULL, pos=0) ...
[10:19:26.080] - nx: 2
[10:19:26.082] - relay: TRUE
[10:19:26.083] - stdout: TRUE
[10:19:26.083] - signal: TRUE
[10:19:26.083] - resignal: FALSE
[10:19:26.083] - force: TRUE
[10:19:26.083] - relayed: [n=2] TRUE, TRUE
[10:19:26.083] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:26.083] - relayed: [n=2] TRUE, TRUE
[10:19:26.083] - queued futures: [n=2] TRUE, TRUE
[10:19:26.083] signalConditionsASAP(NULL, pos=0) ... done
[10:19:26.083] resolve() on list ... DONE
[10:19:26.083] result() for ClusterFuture ...
[10:19:26.084] - result already collected: FutureResult
[10:19:26.084] result() for ClusterFuture ... done
[10:19:26.084] result() for ClusterFuture ...
[10:19:26.084] - result already collected: FutureResult
[10:19:26.084] result() for ClusterFuture ... done
[10:19:26.084] result() for ClusterFuture ...
[10:19:26.084] - result already collected: FutureResult
[10:19:26.084] result() for ClusterFuture ... done
[10:19:26.084] result() for ClusterFuture ...
[10:19:26.084] - result already collected: FutureResult
[10:19:26.084] result() for ClusterFuture ... done
[10:19:26.084]  - Number of value chunks collected: 2
[10:19:26.085] Resolving 2 futures (chunks) ... DONE
[10:19:26.085] Reducing values from 2 chunks ...
[10:19:26.085]  - Number of values collected after concatenation: 5
[10:19:26.085]  - Number of values expected: 5
[10:19:26.085] Reducing values from 2 chunks ... DONE
[10:19:26.085] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[10:19:26.085] future_mapply() ...
[10:19:26.087] Number of chunks: 1
[10:19:26.087] getGlobalsAndPackagesXApply() ...
[10:19:26.087]  - future.globals: TRUE
[10:19:26.087] getGlobalsAndPackages() ...
[10:19:26.087] Searching for globals...
[10:19:26.088] - globals found: [1] ‘FUN’
[10:19:26.088] Searching for globals ... DONE
[10:19:26.088] Resolving globals: FALSE
[10:19:26.089] The total size of the 1 globals is 185 bytes (185 bytes)
[10:19:26.089] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:19:26.089] - globals: [1] ‘FUN’
[10:19:26.089] 
[10:19:26.089] getGlobalsAndPackages() ... DONE
[10:19:26.089]  - globals found/used: [n=1] ‘FUN’
[10:19:26.089]  - needed namespaces: [n=0] 
[10:19:26.089] Finding globals ... DONE
[10:19:26.090] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:26.090] List of 2
[10:19:26.090]  $ ...future.FUN:function (x)  
[10:19:26.090]  $ MoreArgs     : NULL
[10:19:26.090]  - attr(*, "where")=List of 2
[10:19:26.090]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:26.090]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:26.090]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:26.090]  - attr(*, "resolved")= logi FALSE
[10:19:26.090]  - attr(*, "total_size")= num NA
[10:19:26.092] Packages to be attached in all futures: [n=0] 
[10:19:26.092] getGlobalsAndPackagesXApply() ... DONE
[10:19:26.093] Number of futures (= number of chunks): 1
[10:19:26.093] Launching 1 futures (chunks) ...
[10:19:26.093] Chunk #1 of 1 ...
[10:19:26.093]  - Finding globals in '...' for chunk #1 ...
[10:19:26.093] getGlobalsAndPackages() ...
[10:19:26.093] Searching for globals...
[10:19:26.093] 
[10:19:26.093] Searching for globals ... DONE
[10:19:26.093] - globals: [0] <none>
[10:19:26.094] getGlobalsAndPackages() ... DONE
[10:19:26.094]    + additional globals found: [n=0] 
[10:19:26.094]    + additional namespaces needed: [n=0] 
[10:19:26.094]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:26.094]  - seeds: <none>
[10:19:26.094]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.094] getGlobalsAndPackages() ...
[10:19:26.094] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.094] Resolving globals: FALSE
[10:19:26.095] The total size of the 5 globals is 366 bytes (366 bytes)
[10:19:26.095] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 366 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:26.095] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.095] 
[10:19:26.095] getGlobalsAndPackages() ... DONE
[10:19:26.096] run() for ‘Future’ ...
[10:19:26.096] - state: ‘created’
[10:19:26.096] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.110]   - Field: ‘node’
[10:19:26.110]   - Field: ‘label’
[10:19:26.110]   - Field: ‘local’
[10:19:26.110]   - Field: ‘owner’
[10:19:26.110]   - Field: ‘envir’
[10:19:26.110]   - Field: ‘workers’
[10:19:26.111]   - Field: ‘packages’
[10:19:26.111]   - Field: ‘gc’
[10:19:26.111]   - Field: ‘conditions’
[10:19:26.111]   - Field: ‘persistent’
[10:19:26.111]   - Field: ‘expr’
[10:19:26.111]   - Field: ‘uuid’
[10:19:26.111]   - Field: ‘seed’
[10:19:26.111]   - Field: ‘version’
[10:19:26.111]   - Field: ‘result’
[10:19:26.111]   - Field: ‘asynchronous’
[10:19:26.111]   - Field: ‘calls’
[10:19:26.111]   - Field: ‘globals’
[10:19:26.112]   - Field: ‘stdout’
[10:19:26.112]   - Field: ‘earlySignal’
[10:19:26.112]   - Field: ‘lazy’
[10:19:26.112]   - Field: ‘state’
[10:19:26.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.112] - Launch lazy future ...
[10:19:26.112] Packages needed by the future expression (n = 0): <none>
[10:19:26.112] Packages needed by future strategies (n = 0): <none>
[10:19:26.113] {
[10:19:26.113]     {
[10:19:26.113]         {
[10:19:26.113]             ...future.startTime <- base::Sys.time()
[10:19:26.113]             {
[10:19:26.113]                 {
[10:19:26.113]                   {
[10:19:26.113]                     {
[10:19:26.113]                       base::local({
[10:19:26.113]                         has_future <- base::requireNamespace("future", 
[10:19:26.113]                           quietly = TRUE)
[10:19:26.113]                         if (has_future) {
[10:19:26.113]                           ns <- base::getNamespace("future")
[10:19:26.113]                           version <- ns[[".package"]][["version"]]
[10:19:26.113]                           if (is.null(version)) 
[10:19:26.113]                             version <- utils::packageVersion("future")
[10:19:26.113]                         }
[10:19:26.113]                         else {
[10:19:26.113]                           version <- NULL
[10:19:26.113]                         }
[10:19:26.113]                         if (!has_future || version < "1.8.0") {
[10:19:26.113]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.113]                             "", base::R.version$version.string), 
[10:19:26.113]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.113]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.113]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.113]                               "release", "version")], collapse = " "), 
[10:19:26.113]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.113]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.113]                             info)
[10:19:26.113]                           info <- base::paste(info, collapse = "; ")
[10:19:26.113]                           if (!has_future) {
[10:19:26.113]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.113]                               info)
[10:19:26.113]                           }
[10:19:26.113]                           else {
[10:19:26.113]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.113]                               info, version)
[10:19:26.113]                           }
[10:19:26.113]                           base::stop(msg)
[10:19:26.113]                         }
[10:19:26.113]                       })
[10:19:26.113]                     }
[10:19:26.113]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.113]                     base::options(mc.cores = 1L)
[10:19:26.113]                   }
[10:19:26.113]                   ...future.strategy.old <- future::plan("list")
[10:19:26.113]                   options(future.plan = NULL)
[10:19:26.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.113]                 }
[10:19:26.113]                 ...future.workdir <- getwd()
[10:19:26.113]             }
[10:19:26.113]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.113]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.113]         }
[10:19:26.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.113]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:26.113]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.113]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.113]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.113]             base::names(...future.oldOptions))
[10:19:26.113]     }
[10:19:26.113]     if (FALSE) {
[10:19:26.113]     }
[10:19:26.113]     else {
[10:19:26.113]         if (TRUE) {
[10:19:26.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.113]                 open = "w")
[10:19:26.113]         }
[10:19:26.113]         else {
[10:19:26.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.113]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.113]         }
[10:19:26.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.113]             base::sink(type = "output", split = FALSE)
[10:19:26.113]             base::close(...future.stdout)
[10:19:26.113]         }, add = TRUE)
[10:19:26.113]     }
[10:19:26.113]     ...future.frame <- base::sys.nframe()
[10:19:26.113]     ...future.conditions <- base::list()
[10:19:26.113]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.113]     if (FALSE) {
[10:19:26.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.113]     }
[10:19:26.113]     ...future.result <- base::tryCatch({
[10:19:26.113]         base::withCallingHandlers({
[10:19:26.113]             ...future.value <- base::withVisible(base::local({
[10:19:26.113]                 ...future.makeSendCondition <- base::local({
[10:19:26.113]                   sendCondition <- NULL
[10:19:26.113]                   function(frame = 1L) {
[10:19:26.113]                     if (is.function(sendCondition)) 
[10:19:26.113]                       return(sendCondition)
[10:19:26.113]                     ns <- getNamespace("parallel")
[10:19:26.113]                     if (exists("sendData", mode = "function", 
[10:19:26.113]                       envir = ns)) {
[10:19:26.113]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.113]                         envir = ns)
[10:19:26.113]                       envir <- sys.frame(frame)
[10:19:26.113]                       master <- NULL
[10:19:26.113]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.113]                         !identical(envir, emptyenv())) {
[10:19:26.113]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.113]                           inherits = FALSE)) {
[10:19:26.113]                           master <- get("master", mode = "list", 
[10:19:26.113]                             envir = envir, inherits = FALSE)
[10:19:26.113]                           if (inherits(master, c("SOCKnode", 
[10:19:26.113]                             "SOCK0node"))) {
[10:19:26.113]                             sendCondition <<- function(cond) {
[10:19:26.113]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.113]                                 success = TRUE)
[10:19:26.113]                               parallel_sendData(master, data)
[10:19:26.113]                             }
[10:19:26.113]                             return(sendCondition)
[10:19:26.113]                           }
[10:19:26.113]                         }
[10:19:26.113]                         frame <- frame + 1L
[10:19:26.113]                         envir <- sys.frame(frame)
[10:19:26.113]                       }
[10:19:26.113]                     }
[10:19:26.113]                     sendCondition <<- function(cond) NULL
[10:19:26.113]                   }
[10:19:26.113]                 })
[10:19:26.113]                 withCallingHandlers({
[10:19:26.113]                   {
[10:19:26.113]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.113]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.113]                       ...future.globals.maxSize)) {
[10:19:26.113]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.113]                       on.exit(options(oopts), add = TRUE)
[10:19:26.113]                     }
[10:19:26.113]                     {
[10:19:26.113]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.113]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.113]                         USE.NAMES = FALSE)
[10:19:26.113]                       do.call(mapply, args = args)
[10:19:26.113]                     }
[10:19:26.113]                   }
[10:19:26.113]                 }, immediateCondition = function(cond) {
[10:19:26.113]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.113]                   sendCondition(cond)
[10:19:26.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.113]                   {
[10:19:26.113]                     inherits <- base::inherits
[10:19:26.113]                     invokeRestart <- base::invokeRestart
[10:19:26.113]                     is.null <- base::is.null
[10:19:26.113]                     muffled <- FALSE
[10:19:26.113]                     if (inherits(cond, "message")) {
[10:19:26.113]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.113]                       if (muffled) 
[10:19:26.113]                         invokeRestart("muffleMessage")
[10:19:26.113]                     }
[10:19:26.113]                     else if (inherits(cond, "warning")) {
[10:19:26.113]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.113]                       if (muffled) 
[10:19:26.113]                         invokeRestart("muffleWarning")
[10:19:26.113]                     }
[10:19:26.113]                     else if (inherits(cond, "condition")) {
[10:19:26.113]                       if (!is.null(pattern)) {
[10:19:26.113]                         computeRestarts <- base::computeRestarts
[10:19:26.113]                         grepl <- base::grepl
[10:19:26.113]                         restarts <- computeRestarts(cond)
[10:19:26.113]                         for (restart in restarts) {
[10:19:26.113]                           name <- restart$name
[10:19:26.113]                           if (is.null(name)) 
[10:19:26.113]                             next
[10:19:26.113]                           if (!grepl(pattern, name)) 
[10:19:26.113]                             next
[10:19:26.113]                           invokeRestart(restart)
[10:19:26.113]                           muffled <- TRUE
[10:19:26.113]                           break
[10:19:26.113]                         }
[10:19:26.113]                       }
[10:19:26.113]                     }
[10:19:26.113]                     invisible(muffled)
[10:19:26.113]                   }
[10:19:26.113]                   muffleCondition(cond)
[10:19:26.113]                 })
[10:19:26.113]             }))
[10:19:26.113]             future::FutureResult(value = ...future.value$value, 
[10:19:26.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.113]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.113]                     ...future.globalenv.names))
[10:19:26.113]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.113]         }, condition = base::local({
[10:19:26.113]             c <- base::c
[10:19:26.113]             inherits <- base::inherits
[10:19:26.113]             invokeRestart <- base::invokeRestart
[10:19:26.113]             length <- base::length
[10:19:26.113]             list <- base::list
[10:19:26.113]             seq.int <- base::seq.int
[10:19:26.113]             signalCondition <- base::signalCondition
[10:19:26.113]             sys.calls <- base::sys.calls
[10:19:26.113]             `[[` <- base::`[[`
[10:19:26.113]             `+` <- base::`+`
[10:19:26.113]             `<<-` <- base::`<<-`
[10:19:26.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.113]                   3L)]
[10:19:26.113]             }
[10:19:26.113]             function(cond) {
[10:19:26.113]                 is_error <- inherits(cond, "error")
[10:19:26.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.113]                   NULL)
[10:19:26.113]                 if (is_error) {
[10:19:26.113]                   sessionInformation <- function() {
[10:19:26.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.113]                       search = base::search(), system = base::Sys.info())
[10:19:26.113]                   }
[10:19:26.113]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.113]                     cond$call), session = sessionInformation(), 
[10:19:26.113]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.113]                   signalCondition(cond)
[10:19:26.113]                 }
[10:19:26.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.113]                 "immediateCondition"))) {
[10:19:26.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.113]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.113]                   if (TRUE && !signal) {
[10:19:26.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.113]                     {
[10:19:26.113]                       inherits <- base::inherits
[10:19:26.113]                       invokeRestart <- base::invokeRestart
[10:19:26.113]                       is.null <- base::is.null
[10:19:26.113]                       muffled <- FALSE
[10:19:26.113]                       if (inherits(cond, "message")) {
[10:19:26.113]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.113]                         if (muffled) 
[10:19:26.113]                           invokeRestart("muffleMessage")
[10:19:26.113]                       }
[10:19:26.113]                       else if (inherits(cond, "warning")) {
[10:19:26.113]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.113]                         if (muffled) 
[10:19:26.113]                           invokeRestart("muffleWarning")
[10:19:26.113]                       }
[10:19:26.113]                       else if (inherits(cond, "condition")) {
[10:19:26.113]                         if (!is.null(pattern)) {
[10:19:26.113]                           computeRestarts <- base::computeRestarts
[10:19:26.113]                           grepl <- base::grepl
[10:19:26.113]                           restarts <- computeRestarts(cond)
[10:19:26.113]                           for (restart in restarts) {
[10:19:26.113]                             name <- restart$name
[10:19:26.113]                             if (is.null(name)) 
[10:19:26.113]                               next
[10:19:26.113]                             if (!grepl(pattern, name)) 
[10:19:26.113]                               next
[10:19:26.113]                             invokeRestart(restart)
[10:19:26.113]                             muffled <- TRUE
[10:19:26.113]                             break
[10:19:26.113]                           }
[10:19:26.113]                         }
[10:19:26.113]                       }
[10:19:26.113]                       invisible(muffled)
[10:19:26.113]                     }
[10:19:26.113]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.113]                   }
[10:19:26.113]                 }
[10:19:26.113]                 else {
[10:19:26.113]                   if (TRUE) {
[10:19:26.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.113]                     {
[10:19:26.113]                       inherits <- base::inherits
[10:19:26.113]                       invokeRestart <- base::invokeRestart
[10:19:26.113]                       is.null <- base::is.null
[10:19:26.113]                       muffled <- FALSE
[10:19:26.113]                       if (inherits(cond, "message")) {
[10:19:26.113]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.113]                         if (muffled) 
[10:19:26.113]                           invokeRestart("muffleMessage")
[10:19:26.113]                       }
[10:19:26.113]                       else if (inherits(cond, "warning")) {
[10:19:26.113]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.113]                         if (muffled) 
[10:19:26.113]                           invokeRestart("muffleWarning")
[10:19:26.113]                       }
[10:19:26.113]                       else if (inherits(cond, "condition")) {
[10:19:26.113]                         if (!is.null(pattern)) {
[10:19:26.113]                           computeRestarts <- base::computeRestarts
[10:19:26.113]                           grepl <- base::grepl
[10:19:26.113]                           restarts <- computeRestarts(cond)
[10:19:26.113]                           for (restart in restarts) {
[10:19:26.113]                             name <- restart$name
[10:19:26.113]                             if (is.null(name)) 
[10:19:26.113]                               next
[10:19:26.113]                             if (!grepl(pattern, name)) 
[10:19:26.113]                               next
[10:19:26.113]                             invokeRestart(restart)
[10:19:26.113]                             muffled <- TRUE
[10:19:26.113]                             break
[10:19:26.113]                           }
[10:19:26.113]                         }
[10:19:26.113]                       }
[10:19:26.113]                       invisible(muffled)
[10:19:26.113]                     }
[10:19:26.113]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.113]                   }
[10:19:26.113]                 }
[10:19:26.113]             }
[10:19:26.113]         }))
[10:19:26.113]     }, error = function(ex) {
[10:19:26.113]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.113]                 ...future.rng), started = ...future.startTime, 
[10:19:26.113]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.113]             version = "1.8"), class = "FutureResult")
[10:19:26.113]     }, finally = {
[10:19:26.113]         if (!identical(...future.workdir, getwd())) 
[10:19:26.113]             setwd(...future.workdir)
[10:19:26.113]         {
[10:19:26.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.113]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.113]             }
[10:19:26.113]             base::options(...future.oldOptions)
[10:19:26.113]             if (.Platform$OS.type == "windows") {
[10:19:26.113]                 old_names <- names(...future.oldEnvVars)
[10:19:26.113]                 envs <- base::Sys.getenv()
[10:19:26.113]                 names <- names(envs)
[10:19:26.113]                 common <- intersect(names, old_names)
[10:19:26.113]                 added <- setdiff(names, old_names)
[10:19:26.113]                 removed <- setdiff(old_names, names)
[10:19:26.113]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.113]                   envs[common]]
[10:19:26.113]                 NAMES <- toupper(changed)
[10:19:26.113]                 args <- list()
[10:19:26.113]                 for (kk in seq_along(NAMES)) {
[10:19:26.113]                   name <- changed[[kk]]
[10:19:26.113]                   NAME <- NAMES[[kk]]
[10:19:26.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.113]                     next
[10:19:26.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.113]                 }
[10:19:26.113]                 NAMES <- toupper(added)
[10:19:26.113]                 for (kk in seq_along(NAMES)) {
[10:19:26.113]                   name <- added[[kk]]
[10:19:26.113]                   NAME <- NAMES[[kk]]
[10:19:26.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.113]                     next
[10:19:26.113]                   args[[name]] <- ""
[10:19:26.113]                 }
[10:19:26.113]                 NAMES <- toupper(removed)
[10:19:26.113]                 for (kk in seq_along(NAMES)) {
[10:19:26.113]                   name <- removed[[kk]]
[10:19:26.113]                   NAME <- NAMES[[kk]]
[10:19:26.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.113]                     next
[10:19:26.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.113]                 }
[10:19:26.113]                 if (length(args) > 0) 
[10:19:26.113]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.113]             }
[10:19:26.113]             else {
[10:19:26.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.113]             }
[10:19:26.113]             {
[10:19:26.113]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.113]                   0L) {
[10:19:26.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.113]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.113]                   base::options(opts)
[10:19:26.113]                 }
[10:19:26.113]                 {
[10:19:26.113]                   {
[10:19:26.113]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.113]                     NULL
[10:19:26.113]                   }
[10:19:26.113]                   options(future.plan = NULL)
[10:19:26.113]                   if (is.na(NA_character_)) 
[10:19:26.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.113]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.113]                     .init = FALSE)
[10:19:26.113]                 }
[10:19:26.113]             }
[10:19:26.113]         }
[10:19:26.113]     })
[10:19:26.113]     if (TRUE) {
[10:19:26.113]         base::sink(type = "output", split = FALSE)
[10:19:26.113]         if (TRUE) {
[10:19:26.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.113]         }
[10:19:26.113]         else {
[10:19:26.113]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.113]         }
[10:19:26.113]         base::close(...future.stdout)
[10:19:26.113]         ...future.stdout <- NULL
[10:19:26.113]     }
[10:19:26.113]     ...future.result$conditions <- ...future.conditions
[10:19:26.113]     ...future.result$finished <- base::Sys.time()
[10:19:26.113]     ...future.result
[10:19:26.113] }
[10:19:26.115] Exporting 5 global objects (803 bytes) to cluster node #1 ...
[10:19:26.116] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:19:26.116] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:19:26.116] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:26.116] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.117] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ...
[10:19:26.117] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ... DONE
[10:19:26.117] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:26.118] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.118] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:26.118] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.118] Exporting 5 global objects (803 bytes) to cluster node #1 ... DONE
[10:19:26.119] MultisessionFuture started
[10:19:26.119] - Launch lazy future ... done
[10:19:26.119] run() for ‘MultisessionFuture’ ... done
[10:19:26.119] Created future:
[10:19:26.119] MultisessionFuture:
[10:19:26.119] Label: ‘future_mapply-1’
[10:19:26.119] Expression:
[10:19:26.119] {
[10:19:26.119]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.119]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.119]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.119]         on.exit(options(oopts), add = TRUE)
[10:19:26.119]     }
[10:19:26.119]     {
[10:19:26.119]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.119]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.119]         do.call(mapply, args = args)
[10:19:26.119]     }
[10:19:26.119] }
[10:19:26.119] Lazy evaluation: FALSE
[10:19:26.119] Asynchronous evaluation: TRUE
[10:19:26.119] Local evaluation: TRUE
[10:19:26.119] Environment: R_GlobalEnv
[10:19:26.119] Capture standard output: TRUE
[10:19:26.119] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.119] Globals: 5 objects totaling 366 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.119] Packages: <none>
[10:19:26.119] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.119] Resolved: FALSE
[10:19:26.119] Value: <not collected>
[10:19:26.119] Conditions captured: <none>
[10:19:26.119] Early signaling: FALSE
[10:19:26.119] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.119] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.130] Chunk #1 of 1 ... DONE
[10:19:26.130] Launching 1 futures (chunks) ... DONE
[10:19:26.131] Resolving 1 futures (chunks) ...
[10:19:26.131] resolve() on list ...
[10:19:26.131]  recursive: 0
[10:19:26.131]  length: 1
[10:19:26.131] 
[10:19:26.161] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.161] - Validating connection of MultisessionFuture
[10:19:26.161] - received message: FutureResult
[10:19:26.162] - Received FutureResult
[10:19:26.162] - Erased future from FutureRegistry
[10:19:26.162] result() for ClusterFuture ...
[10:19:26.162] - result already collected: FutureResult
[10:19:26.162] result() for ClusterFuture ... done
[10:19:26.162] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.162] Future #1
[10:19:26.162] result() for ClusterFuture ...
[10:19:26.162] - result already collected: FutureResult
[10:19:26.162] result() for ClusterFuture ... done
[10:19:26.162] result() for ClusterFuture ...
[10:19:26.163] - result already collected: FutureResult
[10:19:26.163] result() for ClusterFuture ... done
[10:19:26.163] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:26.163] - nx: 1
[10:19:26.163] - relay: TRUE
[10:19:26.163] - stdout: TRUE
[10:19:26.163] - signal: TRUE
[10:19:26.163] - resignal: FALSE
[10:19:26.163] - force: TRUE
[10:19:26.163] - relayed: [n=1] FALSE
[10:19:26.163] - queued futures: [n=1] FALSE
[10:19:26.164]  - until=1
[10:19:26.164]  - relaying element #1
[10:19:26.164] result() for ClusterFuture ...
[10:19:26.164] - result already collected: FutureResult
[10:19:26.164] result() for ClusterFuture ... done
[10:19:26.164] result() for ClusterFuture ...
[10:19:26.164] - result already collected: FutureResult
[10:19:26.164] result() for ClusterFuture ... done
[10:19:26.164] result() for ClusterFuture ...
[10:19:26.164] - result already collected: FutureResult
[10:19:26.164] result() for ClusterFuture ... done
[10:19:26.165] result() for ClusterFuture ...
[10:19:26.165] - result already collected: FutureResult
[10:19:26.165] result() for ClusterFuture ... done
[10:19:26.165] - relayed: [n=1] TRUE
[10:19:26.165] - queued futures: [n=1] TRUE
[10:19:26.165] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:26.165]  length: 0 (resolved future 1)
[10:19:26.165] Relaying remaining futures
[10:19:26.165] signalConditionsASAP(NULL, pos=0) ...
[10:19:26.165] - nx: 1
[10:19:26.165] - relay: TRUE
[10:19:26.165] - stdout: TRUE
[10:19:26.166] - signal: TRUE
[10:19:26.166] - resignal: FALSE
[10:19:26.166] - force: TRUE
[10:19:26.166] - relayed: [n=1] TRUE
[10:19:26.166] - queued futures: [n=1] TRUE
 - flush all
[10:19:26.166] - relayed: [n=1] TRUE
[10:19:26.166] - queued futures: [n=1] TRUE
[10:19:26.166] signalConditionsASAP(NULL, pos=0) ... done
[10:19:26.166] resolve() on list ... DONE
[10:19:26.166] result() for ClusterFuture ...
[10:19:26.166] - result already collected: FutureResult
[10:19:26.167] result() for ClusterFuture ... done
[10:19:26.167] result() for ClusterFuture ...
[10:19:26.167] - result already collected: FutureResult
[10:19:26.167] result() for ClusterFuture ... done
[10:19:26.167]  - Number of value chunks collected: 1
[10:19:26.167] Resolving 1 futures (chunks) ... DONE
[10:19:26.167] Reducing values from 1 chunks ...
[10:19:26.167]  - Number of values collected after concatenation: 1
[10:19:26.167]  - Number of values expected: 1
[10:19:26.167] Reducing values from 1 chunks ... DONE
[10:19:26.167] future_mapply() ... DONE
[10:19:26.168] future_mapply() ...
[10:19:26.169] Number of chunks: 1
[10:19:26.169] getGlobalsAndPackagesXApply() ...
[10:19:26.169]  - future.globals: TRUE
[10:19:26.169] getGlobalsAndPackages() ...
[10:19:26.169] Searching for globals...
[10:19:26.171] - globals found: [1] ‘FUN’
[10:19:26.171] Searching for globals ... DONE
[10:19:26.171] Resolving globals: FALSE
[10:19:26.171] The total size of the 1 globals is 185 bytes (185 bytes)
[10:19:26.171] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:19:26.171] - globals: [1] ‘FUN’
[10:19:26.172] 
[10:19:26.172] getGlobalsAndPackages() ... DONE
[10:19:26.172]  - globals found/used: [n=1] ‘FUN’
[10:19:26.172]  - needed namespaces: [n=0] 
[10:19:26.172] Finding globals ... DONE
[10:19:26.172] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:26.172] List of 2
[10:19:26.172]  $ ...future.FUN:function (x)  
[10:19:26.172]  $ MoreArgs     : list()
[10:19:26.172]  - attr(*, "where")=List of 2
[10:19:26.172]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:26.172]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:26.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:26.172]  - attr(*, "resolved")= logi FALSE
[10:19:26.172]  - attr(*, "total_size")= num NA
[10:19:26.175] Packages to be attached in all futures: [n=0] 
[10:19:26.175] getGlobalsAndPackagesXApply() ... DONE
[10:19:26.175] Number of futures (= number of chunks): 1
[10:19:26.175] Launching 1 futures (chunks) ...
[10:19:26.175] Chunk #1 of 1 ...
[10:19:26.175]  - Finding globals in '...' for chunk #1 ...
[10:19:26.175] getGlobalsAndPackages() ...
[10:19:26.176] Searching for globals...
[10:19:26.176] 
[10:19:26.176] Searching for globals ... DONE
[10:19:26.176] - globals: [0] <none>
[10:19:26.176] getGlobalsAndPackages() ... DONE
[10:19:26.176]    + additional globals found: [n=0] 
[10:19:26.176]    + additional namespaces needed: [n=0] 
[10:19:26.176]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:26.176]  - seeds: <none>
[10:19:26.176]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.177] getGlobalsAndPackages() ...
[10:19:26.177] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.177] Resolving globals: FALSE
[10:19:26.177] The total size of the 5 globals is 370 bytes (370 bytes)
[10:19:26.178] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 370 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[10:19:26.178] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.178] 
[10:19:26.178] getGlobalsAndPackages() ... DONE
[10:19:26.178] run() for ‘Future’ ...
[10:19:26.178] - state: ‘created’
[10:19:26.179] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.192] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.192] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.192]   - Field: ‘node’
[10:19:26.193]   - Field: ‘label’
[10:19:26.193]   - Field: ‘local’
[10:19:26.193]   - Field: ‘owner’
[10:19:26.193]   - Field: ‘envir’
[10:19:26.193]   - Field: ‘workers’
[10:19:26.193]   - Field: ‘packages’
[10:19:26.193]   - Field: ‘gc’
[10:19:26.193]   - Field: ‘conditions’
[10:19:26.193]   - Field: ‘persistent’
[10:19:26.193]   - Field: ‘expr’
[10:19:26.193]   - Field: ‘uuid’
[10:19:26.193]   - Field: ‘seed’
[10:19:26.194]   - Field: ‘version’
[10:19:26.194]   - Field: ‘result’
[10:19:26.194]   - Field: ‘asynchronous’
[10:19:26.194]   - Field: ‘calls’
[10:19:26.194]   - Field: ‘globals’
[10:19:26.194]   - Field: ‘stdout’
[10:19:26.194]   - Field: ‘earlySignal’
[10:19:26.194]   - Field: ‘lazy’
[10:19:26.194]   - Field: ‘state’
[10:19:26.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.194] - Launch lazy future ...
[10:19:26.195] Packages needed by the future expression (n = 0): <none>
[10:19:26.195] Packages needed by future strategies (n = 0): <none>
[10:19:26.195] {
[10:19:26.195]     {
[10:19:26.195]         {
[10:19:26.195]             ...future.startTime <- base::Sys.time()
[10:19:26.195]             {
[10:19:26.195]                 {
[10:19:26.195]                   {
[10:19:26.195]                     {
[10:19:26.195]                       base::local({
[10:19:26.195]                         has_future <- base::requireNamespace("future", 
[10:19:26.195]                           quietly = TRUE)
[10:19:26.195]                         if (has_future) {
[10:19:26.195]                           ns <- base::getNamespace("future")
[10:19:26.195]                           version <- ns[[".package"]][["version"]]
[10:19:26.195]                           if (is.null(version)) 
[10:19:26.195]                             version <- utils::packageVersion("future")
[10:19:26.195]                         }
[10:19:26.195]                         else {
[10:19:26.195]                           version <- NULL
[10:19:26.195]                         }
[10:19:26.195]                         if (!has_future || version < "1.8.0") {
[10:19:26.195]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.195]                             "", base::R.version$version.string), 
[10:19:26.195]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.195]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.195]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.195]                               "release", "version")], collapse = " "), 
[10:19:26.195]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.195]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.195]                             info)
[10:19:26.195]                           info <- base::paste(info, collapse = "; ")
[10:19:26.195]                           if (!has_future) {
[10:19:26.195]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.195]                               info)
[10:19:26.195]                           }
[10:19:26.195]                           else {
[10:19:26.195]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.195]                               info, version)
[10:19:26.195]                           }
[10:19:26.195]                           base::stop(msg)
[10:19:26.195]                         }
[10:19:26.195]                       })
[10:19:26.195]                     }
[10:19:26.195]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.195]                     base::options(mc.cores = 1L)
[10:19:26.195]                   }
[10:19:26.195]                   ...future.strategy.old <- future::plan("list")
[10:19:26.195]                   options(future.plan = NULL)
[10:19:26.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.195]                 }
[10:19:26.195]                 ...future.workdir <- getwd()
[10:19:26.195]             }
[10:19:26.195]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.195]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.195]         }
[10:19:26.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.195]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:19:26.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.195]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.195]             base::names(...future.oldOptions))
[10:19:26.195]     }
[10:19:26.195]     if (FALSE) {
[10:19:26.195]     }
[10:19:26.195]     else {
[10:19:26.195]         if (TRUE) {
[10:19:26.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.195]                 open = "w")
[10:19:26.195]         }
[10:19:26.195]         else {
[10:19:26.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.195]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.195]         }
[10:19:26.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.195]             base::sink(type = "output", split = FALSE)
[10:19:26.195]             base::close(...future.stdout)
[10:19:26.195]         }, add = TRUE)
[10:19:26.195]     }
[10:19:26.195]     ...future.frame <- base::sys.nframe()
[10:19:26.195]     ...future.conditions <- base::list()
[10:19:26.195]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.195]     if (FALSE) {
[10:19:26.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.195]     }
[10:19:26.195]     ...future.result <- base::tryCatch({
[10:19:26.195]         base::withCallingHandlers({
[10:19:26.195]             ...future.value <- base::withVisible(base::local({
[10:19:26.195]                 ...future.makeSendCondition <- base::local({
[10:19:26.195]                   sendCondition <- NULL
[10:19:26.195]                   function(frame = 1L) {
[10:19:26.195]                     if (is.function(sendCondition)) 
[10:19:26.195]                       return(sendCondition)
[10:19:26.195]                     ns <- getNamespace("parallel")
[10:19:26.195]                     if (exists("sendData", mode = "function", 
[10:19:26.195]                       envir = ns)) {
[10:19:26.195]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.195]                         envir = ns)
[10:19:26.195]                       envir <- sys.frame(frame)
[10:19:26.195]                       master <- NULL
[10:19:26.195]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.195]                         !identical(envir, emptyenv())) {
[10:19:26.195]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.195]                           inherits = FALSE)) {
[10:19:26.195]                           master <- get("master", mode = "list", 
[10:19:26.195]                             envir = envir, inherits = FALSE)
[10:19:26.195]                           if (inherits(master, c("SOCKnode", 
[10:19:26.195]                             "SOCK0node"))) {
[10:19:26.195]                             sendCondition <<- function(cond) {
[10:19:26.195]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.195]                                 success = TRUE)
[10:19:26.195]                               parallel_sendData(master, data)
[10:19:26.195]                             }
[10:19:26.195]                             return(sendCondition)
[10:19:26.195]                           }
[10:19:26.195]                         }
[10:19:26.195]                         frame <- frame + 1L
[10:19:26.195]                         envir <- sys.frame(frame)
[10:19:26.195]                       }
[10:19:26.195]                     }
[10:19:26.195]                     sendCondition <<- function(cond) NULL
[10:19:26.195]                   }
[10:19:26.195]                 })
[10:19:26.195]                 withCallingHandlers({
[10:19:26.195]                   {
[10:19:26.195]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.195]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.195]                       ...future.globals.maxSize)) {
[10:19:26.195]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.195]                       on.exit(options(oopts), add = TRUE)
[10:19:26.195]                     }
[10:19:26.195]                     {
[10:19:26.195]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.195]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.195]                         USE.NAMES = FALSE)
[10:19:26.195]                       do.call(mapply, args = args)
[10:19:26.195]                     }
[10:19:26.195]                   }
[10:19:26.195]                 }, immediateCondition = function(cond) {
[10:19:26.195]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.195]                   sendCondition(cond)
[10:19:26.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.195]                   {
[10:19:26.195]                     inherits <- base::inherits
[10:19:26.195]                     invokeRestart <- base::invokeRestart
[10:19:26.195]                     is.null <- base::is.null
[10:19:26.195]                     muffled <- FALSE
[10:19:26.195]                     if (inherits(cond, "message")) {
[10:19:26.195]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.195]                       if (muffled) 
[10:19:26.195]                         invokeRestart("muffleMessage")
[10:19:26.195]                     }
[10:19:26.195]                     else if (inherits(cond, "warning")) {
[10:19:26.195]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.195]                       if (muffled) 
[10:19:26.195]                         invokeRestart("muffleWarning")
[10:19:26.195]                     }
[10:19:26.195]                     else if (inherits(cond, "condition")) {
[10:19:26.195]                       if (!is.null(pattern)) {
[10:19:26.195]                         computeRestarts <- base::computeRestarts
[10:19:26.195]                         grepl <- base::grepl
[10:19:26.195]                         restarts <- computeRestarts(cond)
[10:19:26.195]                         for (restart in restarts) {
[10:19:26.195]                           name <- restart$name
[10:19:26.195]                           if (is.null(name)) 
[10:19:26.195]                             next
[10:19:26.195]                           if (!grepl(pattern, name)) 
[10:19:26.195]                             next
[10:19:26.195]                           invokeRestart(restart)
[10:19:26.195]                           muffled <- TRUE
[10:19:26.195]                           break
[10:19:26.195]                         }
[10:19:26.195]                       }
[10:19:26.195]                     }
[10:19:26.195]                     invisible(muffled)
[10:19:26.195]                   }
[10:19:26.195]                   muffleCondition(cond)
[10:19:26.195]                 })
[10:19:26.195]             }))
[10:19:26.195]             future::FutureResult(value = ...future.value$value, 
[10:19:26.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.195]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.195]                     ...future.globalenv.names))
[10:19:26.195]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.195]         }, condition = base::local({
[10:19:26.195]             c <- base::c
[10:19:26.195]             inherits <- base::inherits
[10:19:26.195]             invokeRestart <- base::invokeRestart
[10:19:26.195]             length <- base::length
[10:19:26.195]             list <- base::list
[10:19:26.195]             seq.int <- base::seq.int
[10:19:26.195]             signalCondition <- base::signalCondition
[10:19:26.195]             sys.calls <- base::sys.calls
[10:19:26.195]             `[[` <- base::`[[`
[10:19:26.195]             `+` <- base::`+`
[10:19:26.195]             `<<-` <- base::`<<-`
[10:19:26.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.195]                   3L)]
[10:19:26.195]             }
[10:19:26.195]             function(cond) {
[10:19:26.195]                 is_error <- inherits(cond, "error")
[10:19:26.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.195]                   NULL)
[10:19:26.195]                 if (is_error) {
[10:19:26.195]                   sessionInformation <- function() {
[10:19:26.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.195]                       search = base::search(), system = base::Sys.info())
[10:19:26.195]                   }
[10:19:26.195]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.195]                     cond$call), session = sessionInformation(), 
[10:19:26.195]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.195]                   signalCondition(cond)
[10:19:26.195]                 }
[10:19:26.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.195]                 "immediateCondition"))) {
[10:19:26.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.195]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.195]                   if (TRUE && !signal) {
[10:19:26.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.195]                     {
[10:19:26.195]                       inherits <- base::inherits
[10:19:26.195]                       invokeRestart <- base::invokeRestart
[10:19:26.195]                       is.null <- base::is.null
[10:19:26.195]                       muffled <- FALSE
[10:19:26.195]                       if (inherits(cond, "message")) {
[10:19:26.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.195]                         if (muffled) 
[10:19:26.195]                           invokeRestart("muffleMessage")
[10:19:26.195]                       }
[10:19:26.195]                       else if (inherits(cond, "warning")) {
[10:19:26.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.195]                         if (muffled) 
[10:19:26.195]                           invokeRestart("muffleWarning")
[10:19:26.195]                       }
[10:19:26.195]                       else if (inherits(cond, "condition")) {
[10:19:26.195]                         if (!is.null(pattern)) {
[10:19:26.195]                           computeRestarts <- base::computeRestarts
[10:19:26.195]                           grepl <- base::grepl
[10:19:26.195]                           restarts <- computeRestarts(cond)
[10:19:26.195]                           for (restart in restarts) {
[10:19:26.195]                             name <- restart$name
[10:19:26.195]                             if (is.null(name)) 
[10:19:26.195]                               next
[10:19:26.195]                             if (!grepl(pattern, name)) 
[10:19:26.195]                               next
[10:19:26.195]                             invokeRestart(restart)
[10:19:26.195]                             muffled <- TRUE
[10:19:26.195]                             break
[10:19:26.195]                           }
[10:19:26.195]                         }
[10:19:26.195]                       }
[10:19:26.195]                       invisible(muffled)
[10:19:26.195]                     }
[10:19:26.195]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.195]                   }
[10:19:26.195]                 }
[10:19:26.195]                 else {
[10:19:26.195]                   if (TRUE) {
[10:19:26.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.195]                     {
[10:19:26.195]                       inherits <- base::inherits
[10:19:26.195]                       invokeRestart <- base::invokeRestart
[10:19:26.195]                       is.null <- base::is.null
[10:19:26.195]                       muffled <- FALSE
[10:19:26.195]                       if (inherits(cond, "message")) {
[10:19:26.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.195]                         if (muffled) 
[10:19:26.195]                           invokeRestart("muffleMessage")
[10:19:26.195]                       }
[10:19:26.195]                       else if (inherits(cond, "warning")) {
[10:19:26.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.195]                         if (muffled) 
[10:19:26.195]                           invokeRestart("muffleWarning")
[10:19:26.195]                       }
[10:19:26.195]                       else if (inherits(cond, "condition")) {
[10:19:26.195]                         if (!is.null(pattern)) {
[10:19:26.195]                           computeRestarts <- base::computeRestarts
[10:19:26.195]                           grepl <- base::grepl
[10:19:26.195]                           restarts <- computeRestarts(cond)
[10:19:26.195]                           for (restart in restarts) {
[10:19:26.195]                             name <- restart$name
[10:19:26.195]                             if (is.null(name)) 
[10:19:26.195]                               next
[10:19:26.195]                             if (!grepl(pattern, name)) 
[10:19:26.195]                               next
[10:19:26.195]                             invokeRestart(restart)
[10:19:26.195]                             muffled <- TRUE
[10:19:26.195]                             break
[10:19:26.195]                           }
[10:19:26.195]                         }
[10:19:26.195]                       }
[10:19:26.195]                       invisible(muffled)
[10:19:26.195]                     }
[10:19:26.195]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.195]                   }
[10:19:26.195]                 }
[10:19:26.195]             }
[10:19:26.195]         }))
[10:19:26.195]     }, error = function(ex) {
[10:19:26.195]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.195]                 ...future.rng), started = ...future.startTime, 
[10:19:26.195]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.195]             version = "1.8"), class = "FutureResult")
[10:19:26.195]     }, finally = {
[10:19:26.195]         if (!identical(...future.workdir, getwd())) 
[10:19:26.195]             setwd(...future.workdir)
[10:19:26.195]         {
[10:19:26.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.195]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.195]             }
[10:19:26.195]             base::options(...future.oldOptions)
[10:19:26.195]             if (.Platform$OS.type == "windows") {
[10:19:26.195]                 old_names <- names(...future.oldEnvVars)
[10:19:26.195]                 envs <- base::Sys.getenv()
[10:19:26.195]                 names <- names(envs)
[10:19:26.195]                 common <- intersect(names, old_names)
[10:19:26.195]                 added <- setdiff(names, old_names)
[10:19:26.195]                 removed <- setdiff(old_names, names)
[10:19:26.195]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.195]                   envs[common]]
[10:19:26.195]                 NAMES <- toupper(changed)
[10:19:26.195]                 args <- list()
[10:19:26.195]                 for (kk in seq_along(NAMES)) {
[10:19:26.195]                   name <- changed[[kk]]
[10:19:26.195]                   NAME <- NAMES[[kk]]
[10:19:26.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.195]                     next
[10:19:26.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.195]                 }
[10:19:26.195]                 NAMES <- toupper(added)
[10:19:26.195]                 for (kk in seq_along(NAMES)) {
[10:19:26.195]                   name <- added[[kk]]
[10:19:26.195]                   NAME <- NAMES[[kk]]
[10:19:26.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.195]                     next
[10:19:26.195]                   args[[name]] <- ""
[10:19:26.195]                 }
[10:19:26.195]                 NAMES <- toupper(removed)
[10:19:26.195]                 for (kk in seq_along(NAMES)) {
[10:19:26.195]                   name <- removed[[kk]]
[10:19:26.195]                   NAME <- NAMES[[kk]]
[10:19:26.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.195]                     next
[10:19:26.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.195]                 }
[10:19:26.195]                 if (length(args) > 0) 
[10:19:26.195]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.195]             }
[10:19:26.195]             else {
[10:19:26.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.195]             }
[10:19:26.195]             {
[10:19:26.195]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.195]                   0L) {
[10:19:26.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.195]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.195]                   base::options(opts)
[10:19:26.195]                 }
[10:19:26.195]                 {
[10:19:26.195]                   {
[10:19:26.195]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.195]                     NULL
[10:19:26.195]                   }
[10:19:26.195]                   options(future.plan = NULL)
[10:19:26.195]                   if (is.na(NA_character_)) 
[10:19:26.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.195]                     .init = FALSE)
[10:19:26.195]                 }
[10:19:26.195]             }
[10:19:26.195]         }
[10:19:26.195]     })
[10:19:26.195]     if (TRUE) {
[10:19:26.195]         base::sink(type = "output", split = FALSE)
[10:19:26.195]         if (TRUE) {
[10:19:26.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.195]         }
[10:19:26.195]         else {
[10:19:26.195]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.195]         }
[10:19:26.195]         base::close(...future.stdout)
[10:19:26.195]         ...future.stdout <- NULL
[10:19:26.195]     }
[10:19:26.195]     ...future.result$conditions <- ...future.conditions
[10:19:26.195]     ...future.result$finished <- base::Sys.time()
[10:19:26.195]     ...future.result
[10:19:26.195] }
[10:19:26.198] Exporting 5 global objects (807 bytes) to cluster node #1 ...
[10:19:26.198] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:19:26.199] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:19:26.199] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[10:19:26.199] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[10:19:26.199] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ...
[10:19:26.200] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ... DONE
[10:19:26.200] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:26.200] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.200] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:26.201] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.201] Exporting 5 global objects (807 bytes) to cluster node #1 ... DONE
[10:19:26.201] MultisessionFuture started
[10:19:26.201] - Launch lazy future ... done
[10:19:26.201] run() for ‘MultisessionFuture’ ... done
[10:19:26.202] Created future:
[10:19:26.202] MultisessionFuture:
[10:19:26.202] Label: ‘future_.mapply-1’
[10:19:26.202] Expression:
[10:19:26.202] {
[10:19:26.202]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.202]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.202]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.202]         on.exit(options(oopts), add = TRUE)
[10:19:26.202]     }
[10:19:26.202]     {
[10:19:26.202]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.202]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.202]         do.call(mapply, args = args)
[10:19:26.202]     }
[10:19:26.202] }
[10:19:26.202] Lazy evaluation: FALSE
[10:19:26.202] Asynchronous evaluation: TRUE
[10:19:26.202] Local evaluation: TRUE
[10:19:26.202] Environment: R_GlobalEnv
[10:19:26.202] Capture standard output: TRUE
[10:19:26.202] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.202] Globals: 5 objects totaling 370 bytes (function ‘...future.FUN’ of 185 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.202] Packages: <none>
[10:19:26.202] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.202] Resolved: FALSE
[10:19:26.202] Value: <not collected>
[10:19:26.202] Conditions captured: <none>
[10:19:26.202] Early signaling: FALSE
[10:19:26.202] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.202] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.213] Chunk #1 of 1 ... DONE
[10:19:26.213] Launching 1 futures (chunks) ... DONE
[10:19:26.213] Resolving 1 futures (chunks) ...
[10:19:26.213] resolve() on list ...
[10:19:26.213]  recursive: 0
[10:19:26.214]  length: 1
[10:19:26.214] 
[10:19:26.243] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.243] - Validating connection of MultisessionFuture
[10:19:26.243] - received message: FutureResult
[10:19:26.243] - Received FutureResult
[10:19:26.244] - Erased future from FutureRegistry
[10:19:26.244] result() for ClusterFuture ...
[10:19:26.244] - result already collected: FutureResult
[10:19:26.244] result() for ClusterFuture ... done
[10:19:26.244] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.244] Future #1
[10:19:26.244] result() for ClusterFuture ...
[10:19:26.244] - result already collected: FutureResult
[10:19:26.244] result() for ClusterFuture ... done
[10:19:26.244] result() for ClusterFuture ...
[10:19:26.244] - result already collected: FutureResult
[10:19:26.244] result() for ClusterFuture ... done
[10:19:26.245] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:26.245] - nx: 1
[10:19:26.245] - relay: TRUE
[10:19:26.245] - stdout: TRUE
[10:19:26.245] - signal: TRUE
[10:19:26.245] - resignal: FALSE
[10:19:26.245] - force: TRUE
[10:19:26.245] - relayed: [n=1] FALSE
[10:19:26.245] - queued futures: [n=1] FALSE
[10:19:26.245]  - until=1
[10:19:26.245]  - relaying element #1
[10:19:26.245] result() for ClusterFuture ...
[10:19:26.246] - result already collected: FutureResult
[10:19:26.246] result() for ClusterFuture ... done
[10:19:26.246] result() for ClusterFuture ...
[10:19:26.246] - result already collected: FutureResult
[10:19:26.246] result() for ClusterFuture ... done
[10:19:26.246] result() for ClusterFuture ...
[10:19:26.246] - result already collected: FutureResult
[10:19:26.246] result() for ClusterFuture ... done
[10:19:26.246] result() for ClusterFuture ...
[10:19:26.246] - result already collected: FutureResult
[10:19:26.246] result() for ClusterFuture ... done
[10:19:26.247] - relayed: [n=1] TRUE
[10:19:26.247] - queued futures: [n=1] TRUE
[10:19:26.247] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:26.247]  length: 0 (resolved future 1)
[10:19:26.247] Relaying remaining futures
[10:19:26.247] signalConditionsASAP(NULL, pos=0) ...
[10:19:26.247] - nx: 1
[10:19:26.247] - relay: TRUE
[10:19:26.247] - stdout: TRUE
[10:19:26.247] - signal: TRUE
[10:19:26.247] - resignal: FALSE
[10:19:26.247] - force: TRUE
[10:19:26.248] - relayed: [n=1] TRUE
[10:19:26.248] - queued futures: [n=1] TRUE
 - flush all
[10:19:26.248] - relayed: [n=1] TRUE
[10:19:26.248] - queued futures: [n=1] TRUE
[10:19:26.248] signalConditionsASAP(NULL, pos=0) ... done
[10:19:26.248] resolve() on list ... DONE
[10:19:26.248] result() for ClusterFuture ...
[10:19:26.248] - result already collected: FutureResult
[10:19:26.248] result() for ClusterFuture ... done
[10:19:26.248] result() for ClusterFuture ...
[10:19:26.248] - result already collected: FutureResult
[10:19:26.248] result() for ClusterFuture ... done
[10:19:26.249]  - Number of value chunks collected: 1
[10:19:26.249] Resolving 1 futures (chunks) ... DONE
[10:19:26.249] Reducing values from 1 chunks ...
[10:19:26.249]  - Number of values collected after concatenation: 1
[10:19:26.249]  - Number of values expected: 1
[10:19:26.249] Reducing values from 1 chunks ... DONE
[10:19:26.249] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[10:19:26.249] future_mapply() ...
[10:19:26.251] Number of chunks: 2
[10:19:26.251] getGlobalsAndPackagesXApply() ...
[10:19:26.251]  - future.globals: TRUE
[10:19:26.251] getGlobalsAndPackages() ...
[10:19:26.251] Searching for globals...
[10:19:26.252] - globals found: [1] ‘FUN’
[10:19:26.253] Searching for globals ... DONE
[10:19:26.253] Resolving globals: FALSE
[10:19:26.253] The total size of the 1 globals is 326 bytes (326 bytes)
[10:19:26.253] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:19:26.253] - globals: [1] ‘FUN’
[10:19:26.253] 
[10:19:26.254] getGlobalsAndPackages() ... DONE
[10:19:26.254]  - globals found/used: [n=1] ‘FUN’
[10:19:26.254]  - needed namespaces: [n=0] 
[10:19:26.254] Finding globals ... DONE
[10:19:26.254] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:26.254] List of 2
[10:19:26.254]  $ ...future.FUN:function (x, y)  
[10:19:26.254]  $ MoreArgs     :List of 1
[10:19:26.254]   ..$ y: int [1:2] 3 4
[10:19:26.254]  - attr(*, "where")=List of 2
[10:19:26.254]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:26.254]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:26.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:26.254]  - attr(*, "resolved")= logi FALSE
[10:19:26.254]  - attr(*, "total_size")= num NA
[10:19:26.257] Packages to be attached in all futures: [n=0] 
[10:19:26.257] getGlobalsAndPackagesXApply() ... DONE
[10:19:26.257] Number of futures (= number of chunks): 2
[10:19:26.257] Launching 2 futures (chunks) ...
[10:19:26.257] Chunk #1 of 2 ...
[10:19:26.257]  - Finding globals in '...' for chunk #1 ...
[10:19:26.258] getGlobalsAndPackages() ...
[10:19:26.258] Searching for globals...
[10:19:26.258] 
[10:19:26.258] Searching for globals ... DONE
[10:19:26.258] - globals: [0] <none>
[10:19:26.258] getGlobalsAndPackages() ... DONE
[10:19:26.258]    + additional globals found: [n=0] 
[10:19:26.258]    + additional namespaces needed: [n=0] 
[10:19:26.258]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:26.258]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.259]  - seeds: <none>
[10:19:26.259]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.259] getGlobalsAndPackages() ...
[10:19:26.259] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.259] Resolving globals: FALSE
[10:19:26.259] The total size of the 5 globals is 656 bytes (656 bytes)
[10:19:26.260] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:26.260] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.260] 
[10:19:26.262] getGlobalsAndPackages() ... DONE
[10:19:26.263] run() for ‘Future’ ...
[10:19:26.263] - state: ‘created’
[10:19:26.263] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.277] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.277]   - Field: ‘node’
[10:19:26.277]   - Field: ‘label’
[10:19:26.277]   - Field: ‘local’
[10:19:26.278]   - Field: ‘owner’
[10:19:26.278]   - Field: ‘envir’
[10:19:26.278]   - Field: ‘workers’
[10:19:26.278]   - Field: ‘packages’
[10:19:26.278]   - Field: ‘gc’
[10:19:26.278]   - Field: ‘conditions’
[10:19:26.278]   - Field: ‘persistent’
[10:19:26.278]   - Field: ‘expr’
[10:19:26.278]   - Field: ‘uuid’
[10:19:26.278]   - Field: ‘seed’
[10:19:26.278]   - Field: ‘version’
[10:19:26.278]   - Field: ‘result’
[10:19:26.279]   - Field: ‘asynchronous’
[10:19:26.279]   - Field: ‘calls’
[10:19:26.279]   - Field: ‘globals’
[10:19:26.279]   - Field: ‘stdout’
[10:19:26.279]   - Field: ‘earlySignal’
[10:19:26.279]   - Field: ‘lazy’
[10:19:26.279]   - Field: ‘state’
[10:19:26.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.279] - Launch lazy future ...
[10:19:26.279] Packages needed by the future expression (n = 0): <none>
[10:19:26.280] Packages needed by future strategies (n = 0): <none>
[10:19:26.280] {
[10:19:26.280]     {
[10:19:26.280]         {
[10:19:26.280]             ...future.startTime <- base::Sys.time()
[10:19:26.280]             {
[10:19:26.280]                 {
[10:19:26.280]                   {
[10:19:26.280]                     {
[10:19:26.280]                       base::local({
[10:19:26.280]                         has_future <- base::requireNamespace("future", 
[10:19:26.280]                           quietly = TRUE)
[10:19:26.280]                         if (has_future) {
[10:19:26.280]                           ns <- base::getNamespace("future")
[10:19:26.280]                           version <- ns[[".package"]][["version"]]
[10:19:26.280]                           if (is.null(version)) 
[10:19:26.280]                             version <- utils::packageVersion("future")
[10:19:26.280]                         }
[10:19:26.280]                         else {
[10:19:26.280]                           version <- NULL
[10:19:26.280]                         }
[10:19:26.280]                         if (!has_future || version < "1.8.0") {
[10:19:26.280]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.280]                             "", base::R.version$version.string), 
[10:19:26.280]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.280]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.280]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.280]                               "release", "version")], collapse = " "), 
[10:19:26.280]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.280]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.280]                             info)
[10:19:26.280]                           info <- base::paste(info, collapse = "; ")
[10:19:26.280]                           if (!has_future) {
[10:19:26.280]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.280]                               info)
[10:19:26.280]                           }
[10:19:26.280]                           else {
[10:19:26.280]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.280]                               info, version)
[10:19:26.280]                           }
[10:19:26.280]                           base::stop(msg)
[10:19:26.280]                         }
[10:19:26.280]                       })
[10:19:26.280]                     }
[10:19:26.280]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.280]                     base::options(mc.cores = 1L)
[10:19:26.280]                   }
[10:19:26.280]                   ...future.strategy.old <- future::plan("list")
[10:19:26.280]                   options(future.plan = NULL)
[10:19:26.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.280]                 }
[10:19:26.280]                 ...future.workdir <- getwd()
[10:19:26.280]             }
[10:19:26.280]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.280]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.280]         }
[10:19:26.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.280]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.280]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.280]             base::names(...future.oldOptions))
[10:19:26.280]     }
[10:19:26.280]     if (FALSE) {
[10:19:26.280]     }
[10:19:26.280]     else {
[10:19:26.280]         if (TRUE) {
[10:19:26.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.280]                 open = "w")
[10:19:26.280]         }
[10:19:26.280]         else {
[10:19:26.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.280]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.280]         }
[10:19:26.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.280]             base::sink(type = "output", split = FALSE)
[10:19:26.280]             base::close(...future.stdout)
[10:19:26.280]         }, add = TRUE)
[10:19:26.280]     }
[10:19:26.280]     ...future.frame <- base::sys.nframe()
[10:19:26.280]     ...future.conditions <- base::list()
[10:19:26.280]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.280]     if (FALSE) {
[10:19:26.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.280]     }
[10:19:26.280]     ...future.result <- base::tryCatch({
[10:19:26.280]         base::withCallingHandlers({
[10:19:26.280]             ...future.value <- base::withVisible(base::local({
[10:19:26.280]                 ...future.makeSendCondition <- base::local({
[10:19:26.280]                   sendCondition <- NULL
[10:19:26.280]                   function(frame = 1L) {
[10:19:26.280]                     if (is.function(sendCondition)) 
[10:19:26.280]                       return(sendCondition)
[10:19:26.280]                     ns <- getNamespace("parallel")
[10:19:26.280]                     if (exists("sendData", mode = "function", 
[10:19:26.280]                       envir = ns)) {
[10:19:26.280]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.280]                         envir = ns)
[10:19:26.280]                       envir <- sys.frame(frame)
[10:19:26.280]                       master <- NULL
[10:19:26.280]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.280]                         !identical(envir, emptyenv())) {
[10:19:26.280]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.280]                           inherits = FALSE)) {
[10:19:26.280]                           master <- get("master", mode = "list", 
[10:19:26.280]                             envir = envir, inherits = FALSE)
[10:19:26.280]                           if (inherits(master, c("SOCKnode", 
[10:19:26.280]                             "SOCK0node"))) {
[10:19:26.280]                             sendCondition <<- function(cond) {
[10:19:26.280]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.280]                                 success = TRUE)
[10:19:26.280]                               parallel_sendData(master, data)
[10:19:26.280]                             }
[10:19:26.280]                             return(sendCondition)
[10:19:26.280]                           }
[10:19:26.280]                         }
[10:19:26.280]                         frame <- frame + 1L
[10:19:26.280]                         envir <- sys.frame(frame)
[10:19:26.280]                       }
[10:19:26.280]                     }
[10:19:26.280]                     sendCondition <<- function(cond) NULL
[10:19:26.280]                   }
[10:19:26.280]                 })
[10:19:26.280]                 withCallingHandlers({
[10:19:26.280]                   {
[10:19:26.280]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.280]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.280]                       ...future.globals.maxSize)) {
[10:19:26.280]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.280]                       on.exit(options(oopts), add = TRUE)
[10:19:26.280]                     }
[10:19:26.280]                     {
[10:19:26.280]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.280]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.280]                         USE.NAMES = FALSE)
[10:19:26.280]                       do.call(mapply, args = args)
[10:19:26.280]                     }
[10:19:26.280]                   }
[10:19:26.280]                 }, immediateCondition = function(cond) {
[10:19:26.280]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.280]                   sendCondition(cond)
[10:19:26.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.280]                   {
[10:19:26.280]                     inherits <- base::inherits
[10:19:26.280]                     invokeRestart <- base::invokeRestart
[10:19:26.280]                     is.null <- base::is.null
[10:19:26.280]                     muffled <- FALSE
[10:19:26.280]                     if (inherits(cond, "message")) {
[10:19:26.280]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.280]                       if (muffled) 
[10:19:26.280]                         invokeRestart("muffleMessage")
[10:19:26.280]                     }
[10:19:26.280]                     else if (inherits(cond, "warning")) {
[10:19:26.280]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.280]                       if (muffled) 
[10:19:26.280]                         invokeRestart("muffleWarning")
[10:19:26.280]                     }
[10:19:26.280]                     else if (inherits(cond, "condition")) {
[10:19:26.280]                       if (!is.null(pattern)) {
[10:19:26.280]                         computeRestarts <- base::computeRestarts
[10:19:26.280]                         grepl <- base::grepl
[10:19:26.280]                         restarts <- computeRestarts(cond)
[10:19:26.280]                         for (restart in restarts) {
[10:19:26.280]                           name <- restart$name
[10:19:26.280]                           if (is.null(name)) 
[10:19:26.280]                             next
[10:19:26.280]                           if (!grepl(pattern, name)) 
[10:19:26.280]                             next
[10:19:26.280]                           invokeRestart(restart)
[10:19:26.280]                           muffled <- TRUE
[10:19:26.280]                           break
[10:19:26.280]                         }
[10:19:26.280]                       }
[10:19:26.280]                     }
[10:19:26.280]                     invisible(muffled)
[10:19:26.280]                   }
[10:19:26.280]                   muffleCondition(cond)
[10:19:26.280]                 })
[10:19:26.280]             }))
[10:19:26.280]             future::FutureResult(value = ...future.value$value, 
[10:19:26.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.280]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.280]                     ...future.globalenv.names))
[10:19:26.280]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.280]         }, condition = base::local({
[10:19:26.280]             c <- base::c
[10:19:26.280]             inherits <- base::inherits
[10:19:26.280]             invokeRestart <- base::invokeRestart
[10:19:26.280]             length <- base::length
[10:19:26.280]             list <- base::list
[10:19:26.280]             seq.int <- base::seq.int
[10:19:26.280]             signalCondition <- base::signalCondition
[10:19:26.280]             sys.calls <- base::sys.calls
[10:19:26.280]             `[[` <- base::`[[`
[10:19:26.280]             `+` <- base::`+`
[10:19:26.280]             `<<-` <- base::`<<-`
[10:19:26.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.280]                   3L)]
[10:19:26.280]             }
[10:19:26.280]             function(cond) {
[10:19:26.280]                 is_error <- inherits(cond, "error")
[10:19:26.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.280]                   NULL)
[10:19:26.280]                 if (is_error) {
[10:19:26.280]                   sessionInformation <- function() {
[10:19:26.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.280]                       search = base::search(), system = base::Sys.info())
[10:19:26.280]                   }
[10:19:26.280]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.280]                     cond$call), session = sessionInformation(), 
[10:19:26.280]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.280]                   signalCondition(cond)
[10:19:26.280]                 }
[10:19:26.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.280]                 "immediateCondition"))) {
[10:19:26.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.280]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.280]                   if (TRUE && !signal) {
[10:19:26.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.280]                     {
[10:19:26.280]                       inherits <- base::inherits
[10:19:26.280]                       invokeRestart <- base::invokeRestart
[10:19:26.280]                       is.null <- base::is.null
[10:19:26.280]                       muffled <- FALSE
[10:19:26.280]                       if (inherits(cond, "message")) {
[10:19:26.280]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.280]                         if (muffled) 
[10:19:26.280]                           invokeRestart("muffleMessage")
[10:19:26.280]                       }
[10:19:26.280]                       else if (inherits(cond, "warning")) {
[10:19:26.280]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.280]                         if (muffled) 
[10:19:26.280]                           invokeRestart("muffleWarning")
[10:19:26.280]                       }
[10:19:26.280]                       else if (inherits(cond, "condition")) {
[10:19:26.280]                         if (!is.null(pattern)) {
[10:19:26.280]                           computeRestarts <- base::computeRestarts
[10:19:26.280]                           grepl <- base::grepl
[10:19:26.280]                           restarts <- computeRestarts(cond)
[10:19:26.280]                           for (restart in restarts) {
[10:19:26.280]                             name <- restart$name
[10:19:26.280]                             if (is.null(name)) 
[10:19:26.280]                               next
[10:19:26.280]                             if (!grepl(pattern, name)) 
[10:19:26.280]                               next
[10:19:26.280]                             invokeRestart(restart)
[10:19:26.280]                             muffled <- TRUE
[10:19:26.280]                             break
[10:19:26.280]                           }
[10:19:26.280]                         }
[10:19:26.280]                       }
[10:19:26.280]                       invisible(muffled)
[10:19:26.280]                     }
[10:19:26.280]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.280]                   }
[10:19:26.280]                 }
[10:19:26.280]                 else {
[10:19:26.280]                   if (TRUE) {
[10:19:26.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.280]                     {
[10:19:26.280]                       inherits <- base::inherits
[10:19:26.280]                       invokeRestart <- base::invokeRestart
[10:19:26.280]                       is.null <- base::is.null
[10:19:26.280]                       muffled <- FALSE
[10:19:26.280]                       if (inherits(cond, "message")) {
[10:19:26.280]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.280]                         if (muffled) 
[10:19:26.280]                           invokeRestart("muffleMessage")
[10:19:26.280]                       }
[10:19:26.280]                       else if (inherits(cond, "warning")) {
[10:19:26.280]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.280]                         if (muffled) 
[10:19:26.280]                           invokeRestart("muffleWarning")
[10:19:26.280]                       }
[10:19:26.280]                       else if (inherits(cond, "condition")) {
[10:19:26.280]                         if (!is.null(pattern)) {
[10:19:26.280]                           computeRestarts <- base::computeRestarts
[10:19:26.280]                           grepl <- base::grepl
[10:19:26.280]                           restarts <- computeRestarts(cond)
[10:19:26.280]                           for (restart in restarts) {
[10:19:26.280]                             name <- restart$name
[10:19:26.280]                             if (is.null(name)) 
[10:19:26.280]                               next
[10:19:26.280]                             if (!grepl(pattern, name)) 
[10:19:26.280]                               next
[10:19:26.280]                             invokeRestart(restart)
[10:19:26.280]                             muffled <- TRUE
[10:19:26.280]                             break
[10:19:26.280]                           }
[10:19:26.280]                         }
[10:19:26.280]                       }
[10:19:26.280]                       invisible(muffled)
[10:19:26.280]                     }
[10:19:26.280]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.280]                   }
[10:19:26.280]                 }
[10:19:26.280]             }
[10:19:26.280]         }))
[10:19:26.280]     }, error = function(ex) {
[10:19:26.280]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.280]                 ...future.rng), started = ...future.startTime, 
[10:19:26.280]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.280]             version = "1.8"), class = "FutureResult")
[10:19:26.280]     }, finally = {
[10:19:26.280]         if (!identical(...future.workdir, getwd())) 
[10:19:26.280]             setwd(...future.workdir)
[10:19:26.280]         {
[10:19:26.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.280]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.280]             }
[10:19:26.280]             base::options(...future.oldOptions)
[10:19:26.280]             if (.Platform$OS.type == "windows") {
[10:19:26.280]                 old_names <- names(...future.oldEnvVars)
[10:19:26.280]                 envs <- base::Sys.getenv()
[10:19:26.280]                 names <- names(envs)
[10:19:26.280]                 common <- intersect(names, old_names)
[10:19:26.280]                 added <- setdiff(names, old_names)
[10:19:26.280]                 removed <- setdiff(old_names, names)
[10:19:26.280]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.280]                   envs[common]]
[10:19:26.280]                 NAMES <- toupper(changed)
[10:19:26.280]                 args <- list()
[10:19:26.280]                 for (kk in seq_along(NAMES)) {
[10:19:26.280]                   name <- changed[[kk]]
[10:19:26.280]                   NAME <- NAMES[[kk]]
[10:19:26.280]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.280]                     next
[10:19:26.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.280]                 }
[10:19:26.280]                 NAMES <- toupper(added)
[10:19:26.280]                 for (kk in seq_along(NAMES)) {
[10:19:26.280]                   name <- added[[kk]]
[10:19:26.280]                   NAME <- NAMES[[kk]]
[10:19:26.280]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.280]                     next
[10:19:26.280]                   args[[name]] <- ""
[10:19:26.280]                 }
[10:19:26.280]                 NAMES <- toupper(removed)
[10:19:26.280]                 for (kk in seq_along(NAMES)) {
[10:19:26.280]                   name <- removed[[kk]]
[10:19:26.280]                   NAME <- NAMES[[kk]]
[10:19:26.280]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.280]                     next
[10:19:26.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.280]                 }
[10:19:26.280]                 if (length(args) > 0) 
[10:19:26.280]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.280]             }
[10:19:26.280]             else {
[10:19:26.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.280]             }
[10:19:26.280]             {
[10:19:26.280]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.280]                   0L) {
[10:19:26.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.280]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.280]                   base::options(opts)
[10:19:26.280]                 }
[10:19:26.280]                 {
[10:19:26.280]                   {
[10:19:26.280]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.280]                     NULL
[10:19:26.280]                   }
[10:19:26.280]                   options(future.plan = NULL)
[10:19:26.280]                   if (is.na(NA_character_)) 
[10:19:26.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.280]                     .init = FALSE)
[10:19:26.280]                 }
[10:19:26.280]             }
[10:19:26.280]         }
[10:19:26.280]     })
[10:19:26.280]     if (TRUE) {
[10:19:26.280]         base::sink(type = "output", split = FALSE)
[10:19:26.280]         if (TRUE) {
[10:19:26.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.280]         }
[10:19:26.280]         else {
[10:19:26.280]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.280]         }
[10:19:26.280]         base::close(...future.stdout)
[10:19:26.280]         ...future.stdout <- NULL
[10:19:26.280]     }
[10:19:26.280]     ...future.result$conditions <- ...future.conditions
[10:19:26.280]     ...future.result$finished <- base::Sys.time()
[10:19:26.280]     ...future.result
[10:19:26.280] }
[10:19:26.283] Exporting 5 global objects (1.05 KiB) to cluster node #1 ...
[10:19:26.283] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ...
[10:19:26.283] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ... DONE
[10:19:26.283] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ...
[10:19:26.284] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ... DONE
[10:19:26.284] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ...
[10:19:26.284] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ... DONE
[10:19:26.284] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:26.285] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.285] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:26.285] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.285] Exporting 5 global objects (1.05 KiB) to cluster node #1 ... DONE
[10:19:26.286] MultisessionFuture started
[10:19:26.286] - Launch lazy future ... done
[10:19:26.286] run() for ‘MultisessionFuture’ ... done
[10:19:26.286] Created future:
[10:19:26.286] MultisessionFuture:
[10:19:26.286] Label: ‘future_mapply-1’
[10:19:26.286] Expression:
[10:19:26.286] {
[10:19:26.286]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.286]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.286]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.286]         on.exit(options(oopts), add = TRUE)
[10:19:26.286]     }
[10:19:26.286]     {
[10:19:26.286]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.286]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.286]         do.call(mapply, args = args)
[10:19:26.286]     }
[10:19:26.286] }
[10:19:26.286] Lazy evaluation: FALSE
[10:19:26.286] Asynchronous evaluation: TRUE
[10:19:26.286] Local evaluation: TRUE
[10:19:26.286] Environment: R_GlobalEnv
[10:19:26.286] Capture standard output: TRUE
[10:19:26.286] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.286] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.286] Packages: <none>
[10:19:26.286] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.286] Resolved: FALSE
[10:19:26.286] Value: <not collected>
[10:19:26.286] Conditions captured: <none>
[10:19:26.286] Early signaling: FALSE
[10:19:26.286] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.286] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.297] Chunk #1 of 2 ... DONE
[10:19:26.297] Chunk #2 of 2 ...
[10:19:26.298]  - Finding globals in '...' for chunk #2 ...
[10:19:26.298] getGlobalsAndPackages() ...
[10:19:26.298] Searching for globals...
[10:19:26.298] 
[10:19:26.298] Searching for globals ... DONE
[10:19:26.298] - globals: [0] <none>
[10:19:26.298] getGlobalsAndPackages() ... DONE
[10:19:26.298]    + additional globals found: [n=0] 
[10:19:26.298]    + additional namespaces needed: [n=0] 
[10:19:26.299]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:26.299]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.299]  - seeds: <none>
[10:19:26.299]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.299] getGlobalsAndPackages() ...
[10:19:26.299] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.299] Resolving globals: FALSE
[10:19:26.299] The total size of the 5 globals is 656 bytes (656 bytes)
[10:19:26.300] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:26.300] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.300] 
[10:19:26.300] getGlobalsAndPackages() ... DONE
[10:19:26.300] run() for ‘Future’ ...
[10:19:26.301] - state: ‘created’
[10:19:26.301] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.315] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.315]   - Field: ‘node’
[10:19:26.315]   - Field: ‘label’
[10:19:26.315]   - Field: ‘local’
[10:19:26.315]   - Field: ‘owner’
[10:19:26.316]   - Field: ‘envir’
[10:19:26.316]   - Field: ‘workers’
[10:19:26.316]   - Field: ‘packages’
[10:19:26.316]   - Field: ‘gc’
[10:19:26.316]   - Field: ‘conditions’
[10:19:26.316]   - Field: ‘persistent’
[10:19:26.316]   - Field: ‘expr’
[10:19:26.316]   - Field: ‘uuid’
[10:19:26.316]   - Field: ‘seed’
[10:19:26.316]   - Field: ‘version’
[10:19:26.316]   - Field: ‘result’
[10:19:26.316]   - Field: ‘asynchronous’
[10:19:26.317]   - Field: ‘calls’
[10:19:26.317]   - Field: ‘globals’
[10:19:26.317]   - Field: ‘stdout’
[10:19:26.317]   - Field: ‘earlySignal’
[10:19:26.317]   - Field: ‘lazy’
[10:19:26.317]   - Field: ‘state’
[10:19:26.317] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.317] - Launch lazy future ...
[10:19:26.317] Packages needed by the future expression (n = 0): <none>
[10:19:26.317] Packages needed by future strategies (n = 0): <none>
[10:19:26.318] {
[10:19:26.318]     {
[10:19:26.318]         {
[10:19:26.318]             ...future.startTime <- base::Sys.time()
[10:19:26.318]             {
[10:19:26.318]                 {
[10:19:26.318]                   {
[10:19:26.318]                     {
[10:19:26.318]                       base::local({
[10:19:26.318]                         has_future <- base::requireNamespace("future", 
[10:19:26.318]                           quietly = TRUE)
[10:19:26.318]                         if (has_future) {
[10:19:26.318]                           ns <- base::getNamespace("future")
[10:19:26.318]                           version <- ns[[".package"]][["version"]]
[10:19:26.318]                           if (is.null(version)) 
[10:19:26.318]                             version <- utils::packageVersion("future")
[10:19:26.318]                         }
[10:19:26.318]                         else {
[10:19:26.318]                           version <- NULL
[10:19:26.318]                         }
[10:19:26.318]                         if (!has_future || version < "1.8.0") {
[10:19:26.318]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.318]                             "", base::R.version$version.string), 
[10:19:26.318]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.318]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.318]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.318]                               "release", "version")], collapse = " "), 
[10:19:26.318]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.318]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.318]                             info)
[10:19:26.318]                           info <- base::paste(info, collapse = "; ")
[10:19:26.318]                           if (!has_future) {
[10:19:26.318]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.318]                               info)
[10:19:26.318]                           }
[10:19:26.318]                           else {
[10:19:26.318]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.318]                               info, version)
[10:19:26.318]                           }
[10:19:26.318]                           base::stop(msg)
[10:19:26.318]                         }
[10:19:26.318]                       })
[10:19:26.318]                     }
[10:19:26.318]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.318]                     base::options(mc.cores = 1L)
[10:19:26.318]                   }
[10:19:26.318]                   ...future.strategy.old <- future::plan("list")
[10:19:26.318]                   options(future.plan = NULL)
[10:19:26.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.318]                 }
[10:19:26.318]                 ...future.workdir <- getwd()
[10:19:26.318]             }
[10:19:26.318]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.318]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.318]         }
[10:19:26.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.318]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.318]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.318]             base::names(...future.oldOptions))
[10:19:26.318]     }
[10:19:26.318]     if (FALSE) {
[10:19:26.318]     }
[10:19:26.318]     else {
[10:19:26.318]         if (TRUE) {
[10:19:26.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.318]                 open = "w")
[10:19:26.318]         }
[10:19:26.318]         else {
[10:19:26.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.318]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.318]         }
[10:19:26.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.318]             base::sink(type = "output", split = FALSE)
[10:19:26.318]             base::close(...future.stdout)
[10:19:26.318]         }, add = TRUE)
[10:19:26.318]     }
[10:19:26.318]     ...future.frame <- base::sys.nframe()
[10:19:26.318]     ...future.conditions <- base::list()
[10:19:26.318]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.318]     if (FALSE) {
[10:19:26.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.318]     }
[10:19:26.318]     ...future.result <- base::tryCatch({
[10:19:26.318]         base::withCallingHandlers({
[10:19:26.318]             ...future.value <- base::withVisible(base::local({
[10:19:26.318]                 ...future.makeSendCondition <- base::local({
[10:19:26.318]                   sendCondition <- NULL
[10:19:26.318]                   function(frame = 1L) {
[10:19:26.318]                     if (is.function(sendCondition)) 
[10:19:26.318]                       return(sendCondition)
[10:19:26.318]                     ns <- getNamespace("parallel")
[10:19:26.318]                     if (exists("sendData", mode = "function", 
[10:19:26.318]                       envir = ns)) {
[10:19:26.318]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.318]                         envir = ns)
[10:19:26.318]                       envir <- sys.frame(frame)
[10:19:26.318]                       master <- NULL
[10:19:26.318]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.318]                         !identical(envir, emptyenv())) {
[10:19:26.318]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.318]                           inherits = FALSE)) {
[10:19:26.318]                           master <- get("master", mode = "list", 
[10:19:26.318]                             envir = envir, inherits = FALSE)
[10:19:26.318]                           if (inherits(master, c("SOCKnode", 
[10:19:26.318]                             "SOCK0node"))) {
[10:19:26.318]                             sendCondition <<- function(cond) {
[10:19:26.318]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.318]                                 success = TRUE)
[10:19:26.318]                               parallel_sendData(master, data)
[10:19:26.318]                             }
[10:19:26.318]                             return(sendCondition)
[10:19:26.318]                           }
[10:19:26.318]                         }
[10:19:26.318]                         frame <- frame + 1L
[10:19:26.318]                         envir <- sys.frame(frame)
[10:19:26.318]                       }
[10:19:26.318]                     }
[10:19:26.318]                     sendCondition <<- function(cond) NULL
[10:19:26.318]                   }
[10:19:26.318]                 })
[10:19:26.318]                 withCallingHandlers({
[10:19:26.318]                   {
[10:19:26.318]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.318]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.318]                       ...future.globals.maxSize)) {
[10:19:26.318]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.318]                       on.exit(options(oopts), add = TRUE)
[10:19:26.318]                     }
[10:19:26.318]                     {
[10:19:26.318]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.318]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.318]                         USE.NAMES = FALSE)
[10:19:26.318]                       do.call(mapply, args = args)
[10:19:26.318]                     }
[10:19:26.318]                   }
[10:19:26.318]                 }, immediateCondition = function(cond) {
[10:19:26.318]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.318]                   sendCondition(cond)
[10:19:26.318]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.318]                   {
[10:19:26.318]                     inherits <- base::inherits
[10:19:26.318]                     invokeRestart <- base::invokeRestart
[10:19:26.318]                     is.null <- base::is.null
[10:19:26.318]                     muffled <- FALSE
[10:19:26.318]                     if (inherits(cond, "message")) {
[10:19:26.318]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.318]                       if (muffled) 
[10:19:26.318]                         invokeRestart("muffleMessage")
[10:19:26.318]                     }
[10:19:26.318]                     else if (inherits(cond, "warning")) {
[10:19:26.318]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.318]                       if (muffled) 
[10:19:26.318]                         invokeRestart("muffleWarning")
[10:19:26.318]                     }
[10:19:26.318]                     else if (inherits(cond, "condition")) {
[10:19:26.318]                       if (!is.null(pattern)) {
[10:19:26.318]                         computeRestarts <- base::computeRestarts
[10:19:26.318]                         grepl <- base::grepl
[10:19:26.318]                         restarts <- computeRestarts(cond)
[10:19:26.318]                         for (restart in restarts) {
[10:19:26.318]                           name <- restart$name
[10:19:26.318]                           if (is.null(name)) 
[10:19:26.318]                             next
[10:19:26.318]                           if (!grepl(pattern, name)) 
[10:19:26.318]                             next
[10:19:26.318]                           invokeRestart(restart)
[10:19:26.318]                           muffled <- TRUE
[10:19:26.318]                           break
[10:19:26.318]                         }
[10:19:26.318]                       }
[10:19:26.318]                     }
[10:19:26.318]                     invisible(muffled)
[10:19:26.318]                   }
[10:19:26.318]                   muffleCondition(cond)
[10:19:26.318]                 })
[10:19:26.318]             }))
[10:19:26.318]             future::FutureResult(value = ...future.value$value, 
[10:19:26.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.318]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.318]                     ...future.globalenv.names))
[10:19:26.318]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.318]         }, condition = base::local({
[10:19:26.318]             c <- base::c
[10:19:26.318]             inherits <- base::inherits
[10:19:26.318]             invokeRestart <- base::invokeRestart
[10:19:26.318]             length <- base::length
[10:19:26.318]             list <- base::list
[10:19:26.318]             seq.int <- base::seq.int
[10:19:26.318]             signalCondition <- base::signalCondition
[10:19:26.318]             sys.calls <- base::sys.calls
[10:19:26.318]             `[[` <- base::`[[`
[10:19:26.318]             `+` <- base::`+`
[10:19:26.318]             `<<-` <- base::`<<-`
[10:19:26.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.318]                   3L)]
[10:19:26.318]             }
[10:19:26.318]             function(cond) {
[10:19:26.318]                 is_error <- inherits(cond, "error")
[10:19:26.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.318]                   NULL)
[10:19:26.318]                 if (is_error) {
[10:19:26.318]                   sessionInformation <- function() {
[10:19:26.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.318]                       search = base::search(), system = base::Sys.info())
[10:19:26.318]                   }
[10:19:26.318]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.318]                     cond$call), session = sessionInformation(), 
[10:19:26.318]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.318]                   signalCondition(cond)
[10:19:26.318]                 }
[10:19:26.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.318]                 "immediateCondition"))) {
[10:19:26.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.318]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.318]                   if (TRUE && !signal) {
[10:19:26.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.318]                     {
[10:19:26.318]                       inherits <- base::inherits
[10:19:26.318]                       invokeRestart <- base::invokeRestart
[10:19:26.318]                       is.null <- base::is.null
[10:19:26.318]                       muffled <- FALSE
[10:19:26.318]                       if (inherits(cond, "message")) {
[10:19:26.318]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.318]                         if (muffled) 
[10:19:26.318]                           invokeRestart("muffleMessage")
[10:19:26.318]                       }
[10:19:26.318]                       else if (inherits(cond, "warning")) {
[10:19:26.318]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.318]                         if (muffled) 
[10:19:26.318]                           invokeRestart("muffleWarning")
[10:19:26.318]                       }
[10:19:26.318]                       else if (inherits(cond, "condition")) {
[10:19:26.318]                         if (!is.null(pattern)) {
[10:19:26.318]                           computeRestarts <- base::computeRestarts
[10:19:26.318]                           grepl <- base::grepl
[10:19:26.318]                           restarts <- computeRestarts(cond)
[10:19:26.318]                           for (restart in restarts) {
[10:19:26.318]                             name <- restart$name
[10:19:26.318]                             if (is.null(name)) 
[10:19:26.318]                               next
[10:19:26.318]                             if (!grepl(pattern, name)) 
[10:19:26.318]                               next
[10:19:26.318]                             invokeRestart(restart)
[10:19:26.318]                             muffled <- TRUE
[10:19:26.318]                             break
[10:19:26.318]                           }
[10:19:26.318]                         }
[10:19:26.318]                       }
[10:19:26.318]                       invisible(muffled)
[10:19:26.318]                     }
[10:19:26.318]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.318]                   }
[10:19:26.318]                 }
[10:19:26.318]                 else {
[10:19:26.318]                   if (TRUE) {
[10:19:26.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.318]                     {
[10:19:26.318]                       inherits <- base::inherits
[10:19:26.318]                       invokeRestart <- base::invokeRestart
[10:19:26.318]                       is.null <- base::is.null
[10:19:26.318]                       muffled <- FALSE
[10:19:26.318]                       if (inherits(cond, "message")) {
[10:19:26.318]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.318]                         if (muffled) 
[10:19:26.318]                           invokeRestart("muffleMessage")
[10:19:26.318]                       }
[10:19:26.318]                       else if (inherits(cond, "warning")) {
[10:19:26.318]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.318]                         if (muffled) 
[10:19:26.318]                           invokeRestart("muffleWarning")
[10:19:26.318]                       }
[10:19:26.318]                       else if (inherits(cond, "condition")) {
[10:19:26.318]                         if (!is.null(pattern)) {
[10:19:26.318]                           computeRestarts <- base::computeRestarts
[10:19:26.318]                           grepl <- base::grepl
[10:19:26.318]                           restarts <- computeRestarts(cond)
[10:19:26.318]                           for (restart in restarts) {
[10:19:26.318]                             name <- restart$name
[10:19:26.318]                             if (is.null(name)) 
[10:19:26.318]                               next
[10:19:26.318]                             if (!grepl(pattern, name)) 
[10:19:26.318]                               next
[10:19:26.318]                             invokeRestart(restart)
[10:19:26.318]                             muffled <- TRUE
[10:19:26.318]                             break
[10:19:26.318]                           }
[10:19:26.318]                         }
[10:19:26.318]                       }
[10:19:26.318]                       invisible(muffled)
[10:19:26.318]                     }
[10:19:26.318]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.318]                   }
[10:19:26.318]                 }
[10:19:26.318]             }
[10:19:26.318]         }))
[10:19:26.318]     }, error = function(ex) {
[10:19:26.318]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.318]                 ...future.rng), started = ...future.startTime, 
[10:19:26.318]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.318]             version = "1.8"), class = "FutureResult")
[10:19:26.318]     }, finally = {
[10:19:26.318]         if (!identical(...future.workdir, getwd())) 
[10:19:26.318]             setwd(...future.workdir)
[10:19:26.318]         {
[10:19:26.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.318]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.318]             }
[10:19:26.318]             base::options(...future.oldOptions)
[10:19:26.318]             if (.Platform$OS.type == "windows") {
[10:19:26.318]                 old_names <- names(...future.oldEnvVars)
[10:19:26.318]                 envs <- base::Sys.getenv()
[10:19:26.318]                 names <- names(envs)
[10:19:26.318]                 common <- intersect(names, old_names)
[10:19:26.318]                 added <- setdiff(names, old_names)
[10:19:26.318]                 removed <- setdiff(old_names, names)
[10:19:26.318]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.318]                   envs[common]]
[10:19:26.318]                 NAMES <- toupper(changed)
[10:19:26.318]                 args <- list()
[10:19:26.318]                 for (kk in seq_along(NAMES)) {
[10:19:26.318]                   name <- changed[[kk]]
[10:19:26.318]                   NAME <- NAMES[[kk]]
[10:19:26.318]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.318]                     next
[10:19:26.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.318]                 }
[10:19:26.318]                 NAMES <- toupper(added)
[10:19:26.318]                 for (kk in seq_along(NAMES)) {
[10:19:26.318]                   name <- added[[kk]]
[10:19:26.318]                   NAME <- NAMES[[kk]]
[10:19:26.318]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.318]                     next
[10:19:26.318]                   args[[name]] <- ""
[10:19:26.318]                 }
[10:19:26.318]                 NAMES <- toupper(removed)
[10:19:26.318]                 for (kk in seq_along(NAMES)) {
[10:19:26.318]                   name <- removed[[kk]]
[10:19:26.318]                   NAME <- NAMES[[kk]]
[10:19:26.318]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.318]                     next
[10:19:26.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.318]                 }
[10:19:26.318]                 if (length(args) > 0) 
[10:19:26.318]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.318]             }
[10:19:26.318]             else {
[10:19:26.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.318]             }
[10:19:26.318]             {
[10:19:26.318]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.318]                   0L) {
[10:19:26.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.318]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.318]                   base::options(opts)
[10:19:26.318]                 }
[10:19:26.318]                 {
[10:19:26.318]                   {
[10:19:26.318]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.318]                     NULL
[10:19:26.318]                   }
[10:19:26.318]                   options(future.plan = NULL)
[10:19:26.318]                   if (is.na(NA_character_)) 
[10:19:26.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.318]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.318]                     .init = FALSE)
[10:19:26.318]                 }
[10:19:26.318]             }
[10:19:26.318]         }
[10:19:26.318]     })
[10:19:26.318]     if (TRUE) {
[10:19:26.318]         base::sink(type = "output", split = FALSE)
[10:19:26.318]         if (TRUE) {
[10:19:26.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.318]         }
[10:19:26.318]         else {
[10:19:26.318]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.318]         }
[10:19:26.318]         base::close(...future.stdout)
[10:19:26.318]         ...future.stdout <- NULL
[10:19:26.318]     }
[10:19:26.318]     ...future.result$conditions <- ...future.conditions
[10:19:26.318]     ...future.result$finished <- base::Sys.time()
[10:19:26.318]     ...future.result
[10:19:26.318] }
[10:19:26.321] Exporting 5 global objects (1.05 KiB) to cluster node #2 ...
[10:19:26.321] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ...
[10:19:26.321] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ... DONE
[10:19:26.321] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ...
[10:19:26.322] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ... DONE
[10:19:26.322] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ...
[10:19:26.322] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ... DONE
[10:19:26.322] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:26.322] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.323] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:26.323] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.323] Exporting 5 global objects (1.05 KiB) to cluster node #2 ... DONE
[10:19:26.324] MultisessionFuture started
[10:19:26.324] - Launch lazy future ... done
[10:19:26.324] run() for ‘MultisessionFuture’ ... done
[10:19:26.324] Created future:
[10:19:26.324] MultisessionFuture:
[10:19:26.324] Label: ‘future_mapply-2’
[10:19:26.324] Expression:
[10:19:26.324] {
[10:19:26.324]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.324]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.324]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.324]         on.exit(options(oopts), add = TRUE)
[10:19:26.324]     }
[10:19:26.324]     {
[10:19:26.324]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.324]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.324]         do.call(mapply, args = args)
[10:19:26.324]     }
[10:19:26.324] }
[10:19:26.324] Lazy evaluation: FALSE
[10:19:26.324] Asynchronous evaluation: TRUE
[10:19:26.324] Local evaluation: TRUE
[10:19:26.324] Environment: R_GlobalEnv
[10:19:26.324] Capture standard output: TRUE
[10:19:26.324] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.324] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.324] Packages: <none>
[10:19:26.324] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.324] Resolved: FALSE
[10:19:26.324] Value: <not collected>
[10:19:26.324] Conditions captured: <none>
[10:19:26.324] Early signaling: FALSE
[10:19:26.324] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.324] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.335] Chunk #2 of 2 ... DONE
[10:19:26.335] Launching 2 futures (chunks) ... DONE
[10:19:26.335] Resolving 2 futures (chunks) ...
[10:19:26.336] resolve() on list ...
[10:19:26.336]  recursive: 0
[10:19:26.336]  length: 2
[10:19:26.336] 
[10:19:26.336] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.337] - Validating connection of MultisessionFuture
[10:19:26.337] - received message: FutureResult
[10:19:26.337] - Received FutureResult
[10:19:26.337] - Erased future from FutureRegistry
[10:19:26.337] result() for ClusterFuture ...
[10:19:26.337] - result already collected: FutureResult
[10:19:26.337] result() for ClusterFuture ... done
[10:19:26.337] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.337] Future #1
[10:19:26.337] result() for ClusterFuture ...
[10:19:26.338] - result already collected: FutureResult
[10:19:26.338] result() for ClusterFuture ... done
[10:19:26.338] result() for ClusterFuture ...
[10:19:26.338] - result already collected: FutureResult
[10:19:26.338] result() for ClusterFuture ... done
[10:19:26.338] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:26.338] - nx: 2
[10:19:26.338] - relay: TRUE
[10:19:26.338] - stdout: TRUE
[10:19:26.338] - signal: TRUE
[10:19:26.338] - resignal: FALSE
[10:19:26.338] - force: TRUE
[10:19:26.338] - relayed: [n=2] FALSE, FALSE
[10:19:26.339] - queued futures: [n=2] FALSE, FALSE
[10:19:26.339]  - until=1
[10:19:26.339]  - relaying element #1
[10:19:26.339] result() for ClusterFuture ...
[10:19:26.339] - result already collected: FutureResult
[10:19:26.339] result() for ClusterFuture ... done
[10:19:26.339] result() for ClusterFuture ...
[10:19:26.339] - result already collected: FutureResult
[10:19:26.339] result() for ClusterFuture ... done
[10:19:26.339] result() for ClusterFuture ...
[10:19:26.339] - result already collected: FutureResult
[10:19:26.340] result() for ClusterFuture ... done
[10:19:26.340] result() for ClusterFuture ...
[10:19:26.340] - result already collected: FutureResult
[10:19:26.340] result() for ClusterFuture ... done
[10:19:26.340] - relayed: [n=2] TRUE, FALSE
[10:19:26.340] - queued futures: [n=2] TRUE, FALSE
[10:19:26.340] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:26.340]  length: 1 (resolved future 1)
[10:19:26.366] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.366] - Validating connection of MultisessionFuture
[10:19:26.366] - received message: FutureResult
[10:19:26.366] - Received FutureResult
[10:19:26.366] - Erased future from FutureRegistry
[10:19:26.367] result() for ClusterFuture ...
[10:19:26.367] - result already collected: FutureResult
[10:19:26.367] result() for ClusterFuture ... done
[10:19:26.367] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.367] Future #2
[10:19:26.367] result() for ClusterFuture ...
[10:19:26.367] - result already collected: FutureResult
[10:19:26.367] result() for ClusterFuture ... done
[10:19:26.367] result() for ClusterFuture ...
[10:19:26.367] - result already collected: FutureResult
[10:19:26.367] result() for ClusterFuture ... done
[10:19:26.368] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:26.368] - nx: 2
[10:19:26.368] - relay: TRUE
[10:19:26.368] - stdout: TRUE
[10:19:26.368] - signal: TRUE
[10:19:26.368] - resignal: FALSE
[10:19:26.368] - force: TRUE
[10:19:26.368] - relayed: [n=2] TRUE, FALSE
[10:19:26.368] - queued futures: [n=2] TRUE, FALSE
[10:19:26.368]  - until=2
[10:19:26.368]  - relaying element #2
[10:19:26.368] result() for ClusterFuture ...
[10:19:26.369] - result already collected: FutureResult
[10:19:26.369] result() for ClusterFuture ... done
[10:19:26.369] result() for ClusterFuture ...
[10:19:26.369] - result already collected: FutureResult
[10:19:26.369] result() for ClusterFuture ... done
[10:19:26.369] result() for ClusterFuture ...
[10:19:26.369] - result already collected: FutureResult
[10:19:26.369] result() for ClusterFuture ... done
[10:19:26.369] result() for ClusterFuture ...
[10:19:26.369] - result already collected: FutureResult
[10:19:26.369] result() for ClusterFuture ... done
[10:19:26.369] - relayed: [n=2] TRUE, TRUE
[10:19:26.370] - queued futures: [n=2] TRUE, TRUE
[10:19:26.370] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:26.370]  length: 0 (resolved future 2)
[10:19:26.370] Relaying remaining futures
[10:19:26.370] signalConditionsASAP(NULL, pos=0) ...
[10:19:26.370] - nx: 2
[10:19:26.370] - relay: TRUE
[10:19:26.370] - stdout: TRUE
[10:19:26.370] - signal: TRUE
[10:19:26.370] - resignal: FALSE
[10:19:26.370] - force: TRUE
[10:19:26.370] - relayed: [n=2] TRUE, TRUE
[10:19:26.371] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:26.371] - relayed: [n=2] TRUE, TRUE
[10:19:26.371] - queued futures: [n=2] TRUE, TRUE
[10:19:26.371] signalConditionsASAP(NULL, pos=0) ... done
[10:19:26.371] resolve() on list ... DONE
[10:19:26.371] result() for ClusterFuture ...
[10:19:26.371] - result already collected: FutureResult
[10:19:26.371] result() for ClusterFuture ... done
[10:19:26.371] result() for ClusterFuture ...
[10:19:26.371] - result already collected: FutureResult
[10:19:26.371] result() for ClusterFuture ... done
[10:19:26.372] result() for ClusterFuture ...
[10:19:26.372] - result already collected: FutureResult
[10:19:26.372] result() for ClusterFuture ... done
[10:19:26.372] result() for ClusterFuture ...
[10:19:26.372] - result already collected: FutureResult
[10:19:26.372] result() for ClusterFuture ... done
[10:19:26.372]  - Number of value chunks collected: 2
[10:19:26.372] Resolving 2 futures (chunks) ... DONE
[10:19:26.372] Reducing values from 2 chunks ...
[10:19:26.372]  - Number of values collected after concatenation: 2
[10:19:26.372]  - Number of values expected: 2
[10:19:26.372] Reducing values from 2 chunks ... DONE
[10:19:26.373] future_mapply() ... DONE
[10:19:26.373] future_mapply() ...
[10:19:26.373] Generating random seeds ...
[10:19:26.373] Generating random seed streams for 2 elements ...
[10:19:26.373] Generating random seed streams for 2 elements ... DONE
[10:19:26.373] Generating random seeds ... DONE
[10:19:26.373] Will set RNG state on exit: 10407, -125127479, -527556946, -65890499, 923626590, 1496835495, -932761993
[10:19:26.375] Number of chunks: 2
[10:19:26.375] getGlobalsAndPackagesXApply() ...
[10:19:26.375]  - future.globals: TRUE
[10:19:26.375] getGlobalsAndPackages() ...
[10:19:26.375] Searching for globals...
[10:19:26.376] - globals found: [1] ‘FUN’
[10:19:26.376] Searching for globals ... DONE
[10:19:26.376] Resolving globals: FALSE
[10:19:26.377] The total size of the 1 globals is 326 bytes (326 bytes)
[10:19:26.377] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:19:26.377] - globals: [1] ‘FUN’
[10:19:26.377] 
[10:19:26.377] getGlobalsAndPackages() ... DONE
[10:19:26.377]  - globals found/used: [n=1] ‘FUN’
[10:19:26.377]  - needed namespaces: [n=0] 
[10:19:26.377] Finding globals ... DONE
[10:19:26.378] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:26.378] List of 2
[10:19:26.378]  $ ...future.FUN:function (x, y)  
[10:19:26.378]  $ MoreArgs     :List of 1
[10:19:26.378]   ..$ y: int [1:2] 3 4
[10:19:26.378]  - attr(*, "where")=List of 2
[10:19:26.378]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:26.378]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:26.378]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:26.378]  - attr(*, "resolved")= logi FALSE
[10:19:26.378]  - attr(*, "total_size")= num NA
[10:19:26.380] Packages to be attached in all futures: [n=0] 
[10:19:26.381] getGlobalsAndPackagesXApply() ... DONE
[10:19:26.381] Number of futures (= number of chunks): 2
[10:19:26.381] Launching 2 futures (chunks) ...
[10:19:26.381] Chunk #1 of 2 ...
[10:19:26.381]  - Finding globals in '...' for chunk #1 ...
[10:19:26.381] getGlobalsAndPackages() ...
[10:19:26.381] Searching for globals...
[10:19:26.382] 
[10:19:26.382] Searching for globals ... DONE
[10:19:26.382] - globals: [0] <none>
[10:19:26.382] getGlobalsAndPackages() ... DONE
[10:19:26.382]    + additional globals found: [n=0] 
[10:19:26.382]    + additional namespaces needed: [n=0] 
[10:19:26.382]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:26.382]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.382]  - seeds: [1] <seeds>
[10:19:26.382]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.382] getGlobalsAndPackages() ...
[10:19:26.382] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.383] Resolving globals: FALSE
[10:19:26.383] The total size of the 5 globals is 696 bytes (696 bytes)
[10:19:26.383] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:26.384] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.384] 
[10:19:26.384] getGlobalsAndPackages() ... DONE
[10:19:26.384] run() for ‘Future’ ...
[10:19:26.384] - state: ‘created’
[10:19:26.384] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.398] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.398]   - Field: ‘node’
[10:19:26.398]   - Field: ‘label’
[10:19:26.398]   - Field: ‘local’
[10:19:26.398]   - Field: ‘owner’
[10:19:26.399]   - Field: ‘envir’
[10:19:26.399]   - Field: ‘workers’
[10:19:26.399]   - Field: ‘packages’
[10:19:26.399]   - Field: ‘gc’
[10:19:26.399]   - Field: ‘conditions’
[10:19:26.399]   - Field: ‘persistent’
[10:19:26.399]   - Field: ‘expr’
[10:19:26.399]   - Field: ‘uuid’
[10:19:26.399]   - Field: ‘seed’
[10:19:26.399]   - Field: ‘version’
[10:19:26.399]   - Field: ‘result’
[10:19:26.399]   - Field: ‘asynchronous’
[10:19:26.400]   - Field: ‘calls’
[10:19:26.400]   - Field: ‘globals’
[10:19:26.400]   - Field: ‘stdout’
[10:19:26.400]   - Field: ‘earlySignal’
[10:19:26.400]   - Field: ‘lazy’
[10:19:26.400]   - Field: ‘state’
[10:19:26.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.400] - Launch lazy future ...
[10:19:26.400] Packages needed by the future expression (n = 0): <none>
[10:19:26.401] Packages needed by future strategies (n = 0): <none>
[10:19:26.401] {
[10:19:26.401]     {
[10:19:26.401]         {
[10:19:26.401]             ...future.startTime <- base::Sys.time()
[10:19:26.401]             {
[10:19:26.401]                 {
[10:19:26.401]                   {
[10:19:26.401]                     {
[10:19:26.401]                       base::local({
[10:19:26.401]                         has_future <- base::requireNamespace("future", 
[10:19:26.401]                           quietly = TRUE)
[10:19:26.401]                         if (has_future) {
[10:19:26.401]                           ns <- base::getNamespace("future")
[10:19:26.401]                           version <- ns[[".package"]][["version"]]
[10:19:26.401]                           if (is.null(version)) 
[10:19:26.401]                             version <- utils::packageVersion("future")
[10:19:26.401]                         }
[10:19:26.401]                         else {
[10:19:26.401]                           version <- NULL
[10:19:26.401]                         }
[10:19:26.401]                         if (!has_future || version < "1.8.0") {
[10:19:26.401]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.401]                             "", base::R.version$version.string), 
[10:19:26.401]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.401]                               "release", "version")], collapse = " "), 
[10:19:26.401]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.401]                             info)
[10:19:26.401]                           info <- base::paste(info, collapse = "; ")
[10:19:26.401]                           if (!has_future) {
[10:19:26.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.401]                               info)
[10:19:26.401]                           }
[10:19:26.401]                           else {
[10:19:26.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.401]                               info, version)
[10:19:26.401]                           }
[10:19:26.401]                           base::stop(msg)
[10:19:26.401]                         }
[10:19:26.401]                       })
[10:19:26.401]                     }
[10:19:26.401]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.401]                     base::options(mc.cores = 1L)
[10:19:26.401]                   }
[10:19:26.401]                   ...future.strategy.old <- future::plan("list")
[10:19:26.401]                   options(future.plan = NULL)
[10:19:26.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.401]                 }
[10:19:26.401]                 ...future.workdir <- getwd()
[10:19:26.401]             }
[10:19:26.401]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.401]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.401]         }
[10:19:26.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.401]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.401]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.401]             base::names(...future.oldOptions))
[10:19:26.401]     }
[10:19:26.401]     if (FALSE) {
[10:19:26.401]     }
[10:19:26.401]     else {
[10:19:26.401]         if (TRUE) {
[10:19:26.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.401]                 open = "w")
[10:19:26.401]         }
[10:19:26.401]         else {
[10:19:26.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.401]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.401]         }
[10:19:26.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.401]             base::sink(type = "output", split = FALSE)
[10:19:26.401]             base::close(...future.stdout)
[10:19:26.401]         }, add = TRUE)
[10:19:26.401]     }
[10:19:26.401]     ...future.frame <- base::sys.nframe()
[10:19:26.401]     ...future.conditions <- base::list()
[10:19:26.401]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.401]     if (FALSE) {
[10:19:26.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.401]     }
[10:19:26.401]     ...future.result <- base::tryCatch({
[10:19:26.401]         base::withCallingHandlers({
[10:19:26.401]             ...future.value <- base::withVisible(base::local({
[10:19:26.401]                 ...future.makeSendCondition <- base::local({
[10:19:26.401]                   sendCondition <- NULL
[10:19:26.401]                   function(frame = 1L) {
[10:19:26.401]                     if (is.function(sendCondition)) 
[10:19:26.401]                       return(sendCondition)
[10:19:26.401]                     ns <- getNamespace("parallel")
[10:19:26.401]                     if (exists("sendData", mode = "function", 
[10:19:26.401]                       envir = ns)) {
[10:19:26.401]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.401]                         envir = ns)
[10:19:26.401]                       envir <- sys.frame(frame)
[10:19:26.401]                       master <- NULL
[10:19:26.401]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.401]                         !identical(envir, emptyenv())) {
[10:19:26.401]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.401]                           inherits = FALSE)) {
[10:19:26.401]                           master <- get("master", mode = "list", 
[10:19:26.401]                             envir = envir, inherits = FALSE)
[10:19:26.401]                           if (inherits(master, c("SOCKnode", 
[10:19:26.401]                             "SOCK0node"))) {
[10:19:26.401]                             sendCondition <<- function(cond) {
[10:19:26.401]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.401]                                 success = TRUE)
[10:19:26.401]                               parallel_sendData(master, data)
[10:19:26.401]                             }
[10:19:26.401]                             return(sendCondition)
[10:19:26.401]                           }
[10:19:26.401]                         }
[10:19:26.401]                         frame <- frame + 1L
[10:19:26.401]                         envir <- sys.frame(frame)
[10:19:26.401]                       }
[10:19:26.401]                     }
[10:19:26.401]                     sendCondition <<- function(cond) NULL
[10:19:26.401]                   }
[10:19:26.401]                 })
[10:19:26.401]                 withCallingHandlers({
[10:19:26.401]                   {
[10:19:26.401]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.401]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.401]                       ...future.globals.maxSize)) {
[10:19:26.401]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.401]                       on.exit(options(oopts), add = TRUE)
[10:19:26.401]                     }
[10:19:26.401]                     {
[10:19:26.401]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:26.401]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:26.401]                           envir = globalenv(), inherits = FALSE)
[10:19:26.401]                         ...future.FUN(...)
[10:19:26.401]                       }
[10:19:26.401]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:26.401]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:26.401]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.401]                         USE.NAMES = FALSE)
[10:19:26.401]                       do.call(mapply, args = args)
[10:19:26.401]                     }
[10:19:26.401]                   }
[10:19:26.401]                 }, immediateCondition = function(cond) {
[10:19:26.401]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.401]                   sendCondition(cond)
[10:19:26.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.401]                   {
[10:19:26.401]                     inherits <- base::inherits
[10:19:26.401]                     invokeRestart <- base::invokeRestart
[10:19:26.401]                     is.null <- base::is.null
[10:19:26.401]                     muffled <- FALSE
[10:19:26.401]                     if (inherits(cond, "message")) {
[10:19:26.401]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.401]                       if (muffled) 
[10:19:26.401]                         invokeRestart("muffleMessage")
[10:19:26.401]                     }
[10:19:26.401]                     else if (inherits(cond, "warning")) {
[10:19:26.401]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.401]                       if (muffled) 
[10:19:26.401]                         invokeRestart("muffleWarning")
[10:19:26.401]                     }
[10:19:26.401]                     else if (inherits(cond, "condition")) {
[10:19:26.401]                       if (!is.null(pattern)) {
[10:19:26.401]                         computeRestarts <- base::computeRestarts
[10:19:26.401]                         grepl <- base::grepl
[10:19:26.401]                         restarts <- computeRestarts(cond)
[10:19:26.401]                         for (restart in restarts) {
[10:19:26.401]                           name <- restart$name
[10:19:26.401]                           if (is.null(name)) 
[10:19:26.401]                             next
[10:19:26.401]                           if (!grepl(pattern, name)) 
[10:19:26.401]                             next
[10:19:26.401]                           invokeRestart(restart)
[10:19:26.401]                           muffled <- TRUE
[10:19:26.401]                           break
[10:19:26.401]                         }
[10:19:26.401]                       }
[10:19:26.401]                     }
[10:19:26.401]                     invisible(muffled)
[10:19:26.401]                   }
[10:19:26.401]                   muffleCondition(cond)
[10:19:26.401]                 })
[10:19:26.401]             }))
[10:19:26.401]             future::FutureResult(value = ...future.value$value, 
[10:19:26.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.401]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.401]                     ...future.globalenv.names))
[10:19:26.401]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.401]         }, condition = base::local({
[10:19:26.401]             c <- base::c
[10:19:26.401]             inherits <- base::inherits
[10:19:26.401]             invokeRestart <- base::invokeRestart
[10:19:26.401]             length <- base::length
[10:19:26.401]             list <- base::list
[10:19:26.401]             seq.int <- base::seq.int
[10:19:26.401]             signalCondition <- base::signalCondition
[10:19:26.401]             sys.calls <- base::sys.calls
[10:19:26.401]             `[[` <- base::`[[`
[10:19:26.401]             `+` <- base::`+`
[10:19:26.401]             `<<-` <- base::`<<-`
[10:19:26.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.401]                   3L)]
[10:19:26.401]             }
[10:19:26.401]             function(cond) {
[10:19:26.401]                 is_error <- inherits(cond, "error")
[10:19:26.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.401]                   NULL)
[10:19:26.401]                 if (is_error) {
[10:19:26.401]                   sessionInformation <- function() {
[10:19:26.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.401]                       search = base::search(), system = base::Sys.info())
[10:19:26.401]                   }
[10:19:26.401]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.401]                     cond$call), session = sessionInformation(), 
[10:19:26.401]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.401]                   signalCondition(cond)
[10:19:26.401]                 }
[10:19:26.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.401]                 "immediateCondition"))) {
[10:19:26.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.401]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.401]                   if (TRUE && !signal) {
[10:19:26.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.401]                     {
[10:19:26.401]                       inherits <- base::inherits
[10:19:26.401]                       invokeRestart <- base::invokeRestart
[10:19:26.401]                       is.null <- base::is.null
[10:19:26.401]                       muffled <- FALSE
[10:19:26.401]                       if (inherits(cond, "message")) {
[10:19:26.401]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.401]                         if (muffled) 
[10:19:26.401]                           invokeRestart("muffleMessage")
[10:19:26.401]                       }
[10:19:26.401]                       else if (inherits(cond, "warning")) {
[10:19:26.401]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.401]                         if (muffled) 
[10:19:26.401]                           invokeRestart("muffleWarning")
[10:19:26.401]                       }
[10:19:26.401]                       else if (inherits(cond, "condition")) {
[10:19:26.401]                         if (!is.null(pattern)) {
[10:19:26.401]                           computeRestarts <- base::computeRestarts
[10:19:26.401]                           grepl <- base::grepl
[10:19:26.401]                           restarts <- computeRestarts(cond)
[10:19:26.401]                           for (restart in restarts) {
[10:19:26.401]                             name <- restart$name
[10:19:26.401]                             if (is.null(name)) 
[10:19:26.401]                               next
[10:19:26.401]                             if (!grepl(pattern, name)) 
[10:19:26.401]                               next
[10:19:26.401]                             invokeRestart(restart)
[10:19:26.401]                             muffled <- TRUE
[10:19:26.401]                             break
[10:19:26.401]                           }
[10:19:26.401]                         }
[10:19:26.401]                       }
[10:19:26.401]                       invisible(muffled)
[10:19:26.401]                     }
[10:19:26.401]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.401]                   }
[10:19:26.401]                 }
[10:19:26.401]                 else {
[10:19:26.401]                   if (TRUE) {
[10:19:26.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.401]                     {
[10:19:26.401]                       inherits <- base::inherits
[10:19:26.401]                       invokeRestart <- base::invokeRestart
[10:19:26.401]                       is.null <- base::is.null
[10:19:26.401]                       muffled <- FALSE
[10:19:26.401]                       if (inherits(cond, "message")) {
[10:19:26.401]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.401]                         if (muffled) 
[10:19:26.401]                           invokeRestart("muffleMessage")
[10:19:26.401]                       }
[10:19:26.401]                       else if (inherits(cond, "warning")) {
[10:19:26.401]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.401]                         if (muffled) 
[10:19:26.401]                           invokeRestart("muffleWarning")
[10:19:26.401]                       }
[10:19:26.401]                       else if (inherits(cond, "condition")) {
[10:19:26.401]                         if (!is.null(pattern)) {
[10:19:26.401]                           computeRestarts <- base::computeRestarts
[10:19:26.401]                           grepl <- base::grepl
[10:19:26.401]                           restarts <- computeRestarts(cond)
[10:19:26.401]                           for (restart in restarts) {
[10:19:26.401]                             name <- restart$name
[10:19:26.401]                             if (is.null(name)) 
[10:19:26.401]                               next
[10:19:26.401]                             if (!grepl(pattern, name)) 
[10:19:26.401]                               next
[10:19:26.401]                             invokeRestart(restart)
[10:19:26.401]                             muffled <- TRUE
[10:19:26.401]                             break
[10:19:26.401]                           }
[10:19:26.401]                         }
[10:19:26.401]                       }
[10:19:26.401]                       invisible(muffled)
[10:19:26.401]                     }
[10:19:26.401]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.401]                   }
[10:19:26.401]                 }
[10:19:26.401]             }
[10:19:26.401]         }))
[10:19:26.401]     }, error = function(ex) {
[10:19:26.401]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.401]                 ...future.rng), started = ...future.startTime, 
[10:19:26.401]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.401]             version = "1.8"), class = "FutureResult")
[10:19:26.401]     }, finally = {
[10:19:26.401]         if (!identical(...future.workdir, getwd())) 
[10:19:26.401]             setwd(...future.workdir)
[10:19:26.401]         {
[10:19:26.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.401]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.401]             }
[10:19:26.401]             base::options(...future.oldOptions)
[10:19:26.401]             if (.Platform$OS.type == "windows") {
[10:19:26.401]                 old_names <- names(...future.oldEnvVars)
[10:19:26.401]                 envs <- base::Sys.getenv()
[10:19:26.401]                 names <- names(envs)
[10:19:26.401]                 common <- intersect(names, old_names)
[10:19:26.401]                 added <- setdiff(names, old_names)
[10:19:26.401]                 removed <- setdiff(old_names, names)
[10:19:26.401]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.401]                   envs[common]]
[10:19:26.401]                 NAMES <- toupper(changed)
[10:19:26.401]                 args <- list()
[10:19:26.401]                 for (kk in seq_along(NAMES)) {
[10:19:26.401]                   name <- changed[[kk]]
[10:19:26.401]                   NAME <- NAMES[[kk]]
[10:19:26.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.401]                     next
[10:19:26.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.401]                 }
[10:19:26.401]                 NAMES <- toupper(added)
[10:19:26.401]                 for (kk in seq_along(NAMES)) {
[10:19:26.401]                   name <- added[[kk]]
[10:19:26.401]                   NAME <- NAMES[[kk]]
[10:19:26.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.401]                     next
[10:19:26.401]                   args[[name]] <- ""
[10:19:26.401]                 }
[10:19:26.401]                 NAMES <- toupper(removed)
[10:19:26.401]                 for (kk in seq_along(NAMES)) {
[10:19:26.401]                   name <- removed[[kk]]
[10:19:26.401]                   NAME <- NAMES[[kk]]
[10:19:26.401]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.401]                     next
[10:19:26.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.401]                 }
[10:19:26.401]                 if (length(args) > 0) 
[10:19:26.401]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.401]             }
[10:19:26.401]             else {
[10:19:26.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.401]             }
[10:19:26.401]             {
[10:19:26.401]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.401]                   0L) {
[10:19:26.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.401]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.401]                   base::options(opts)
[10:19:26.401]                 }
[10:19:26.401]                 {
[10:19:26.401]                   {
[10:19:26.401]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.401]                     NULL
[10:19:26.401]                   }
[10:19:26.401]                   options(future.plan = NULL)
[10:19:26.401]                   if (is.na(NA_character_)) 
[10:19:26.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.401]                     .init = FALSE)
[10:19:26.401]                 }
[10:19:26.401]             }
[10:19:26.401]         }
[10:19:26.401]     })
[10:19:26.401]     if (TRUE) {
[10:19:26.401]         base::sink(type = "output", split = FALSE)
[10:19:26.401]         if (TRUE) {
[10:19:26.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.401]         }
[10:19:26.401]         else {
[10:19:26.401]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.401]         }
[10:19:26.401]         base::close(...future.stdout)
[10:19:26.401]         ...future.stdout <- NULL
[10:19:26.401]     }
[10:19:26.401]     ...future.result$conditions <- ...future.conditions
[10:19:26.401]     ...future.result$finished <- base::Sys.time()
[10:19:26.401]     ...future.result
[10:19:26.401] }
[10:19:26.404] Exporting 5 global objects (1.09 KiB) to cluster node #1 ...
[10:19:26.404] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ...
[10:19:26.404] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ... DONE
[10:19:26.404] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ...
[10:19:26.405] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ... DONE
[10:19:26.405] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ...
[10:19:26.405] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ... DONE
[10:19:26.405] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ...
[10:19:26.406] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ... DONE
[10:19:26.406] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:26.406] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.406] Exporting 5 global objects (1.09 KiB) to cluster node #1 ... DONE
[10:19:26.407] MultisessionFuture started
[10:19:26.407] - Launch lazy future ... done
[10:19:26.407] run() for ‘MultisessionFuture’ ... done
[10:19:26.407] Created future:
[10:19:26.407] MultisessionFuture:
[10:19:26.407] Label: ‘future_mapply-1’
[10:19:26.407] Expression:
[10:19:26.407] {
[10:19:26.407]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.407]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.407]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.407]         on.exit(options(oopts), add = TRUE)
[10:19:26.407]     }
[10:19:26.407]     {
[10:19:26.407]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:26.407]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:26.407]                 inherits = FALSE)
[10:19:26.407]             ...future.FUN(...)
[10:19:26.407]         }
[10:19:26.407]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:26.407]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:26.407]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.407]         do.call(mapply, args = args)
[10:19:26.407]     }
[10:19:26.407] }
[10:19:26.407] Lazy evaluation: FALSE
[10:19:26.407] Asynchronous evaluation: TRUE
[10:19:26.407] Local evaluation: TRUE
[10:19:26.407] Environment: R_GlobalEnv
[10:19:26.407] Capture standard output: TRUE
[10:19:26.407] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.407] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.407] Packages: <none>
[10:19:26.407] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:26.407] Resolved: FALSE
[10:19:26.407] Value: <not collected>
[10:19:26.407] Conditions captured: <none>
[10:19:26.407] Early signaling: FALSE
[10:19:26.407] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.407] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.419] Chunk #1 of 2 ... DONE
[10:19:26.419] Chunk #2 of 2 ...
[10:19:26.419]  - Finding globals in '...' for chunk #2 ...
[10:19:26.419] getGlobalsAndPackages() ...
[10:19:26.419] Searching for globals...
[10:19:26.419] 
[10:19:26.419] Searching for globals ... DONE
[10:19:26.420] - globals: [0] <none>
[10:19:26.420] getGlobalsAndPackages() ... DONE
[10:19:26.420]    + additional globals found: [n=0] 
[10:19:26.420]    + additional namespaces needed: [n=0] 
[10:19:26.420]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:26.420]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.420]  - seeds: [1] <seeds>
[10:19:26.420]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.420] getGlobalsAndPackages() ...
[10:19:26.420] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.420] Resolving globals: FALSE
[10:19:26.421] The total size of the 5 globals is 696 bytes (696 bytes)
[10:19:26.421] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:26.421] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.422] 
[10:19:26.422] getGlobalsAndPackages() ... DONE
[10:19:26.422] run() for ‘Future’ ...
[10:19:26.422] - state: ‘created’
[10:19:26.422] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.436]   - Field: ‘node’
[10:19:26.436]   - Field: ‘label’
[10:19:26.437]   - Field: ‘local’
[10:19:26.437]   - Field: ‘owner’
[10:19:26.437]   - Field: ‘envir’
[10:19:26.437]   - Field: ‘workers’
[10:19:26.437]   - Field: ‘packages’
[10:19:26.437]   - Field: ‘gc’
[10:19:26.437]   - Field: ‘conditions’
[10:19:26.437]   - Field: ‘persistent’
[10:19:26.437]   - Field: ‘expr’
[10:19:26.437]   - Field: ‘uuid’
[10:19:26.437]   - Field: ‘seed’
[10:19:26.438]   - Field: ‘version’
[10:19:26.438]   - Field: ‘result’
[10:19:26.438]   - Field: ‘asynchronous’
[10:19:26.438]   - Field: ‘calls’
[10:19:26.438]   - Field: ‘globals’
[10:19:26.438]   - Field: ‘stdout’
[10:19:26.438]   - Field: ‘earlySignal’
[10:19:26.438]   - Field: ‘lazy’
[10:19:26.438]   - Field: ‘state’
[10:19:26.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.438] - Launch lazy future ...
[10:19:26.439] Packages needed by the future expression (n = 0): <none>
[10:19:26.439] Packages needed by future strategies (n = 0): <none>
[10:19:26.439] {
[10:19:26.439]     {
[10:19:26.439]         {
[10:19:26.439]             ...future.startTime <- base::Sys.time()
[10:19:26.439]             {
[10:19:26.439]                 {
[10:19:26.439]                   {
[10:19:26.439]                     {
[10:19:26.439]                       base::local({
[10:19:26.439]                         has_future <- base::requireNamespace("future", 
[10:19:26.439]                           quietly = TRUE)
[10:19:26.439]                         if (has_future) {
[10:19:26.439]                           ns <- base::getNamespace("future")
[10:19:26.439]                           version <- ns[[".package"]][["version"]]
[10:19:26.439]                           if (is.null(version)) 
[10:19:26.439]                             version <- utils::packageVersion("future")
[10:19:26.439]                         }
[10:19:26.439]                         else {
[10:19:26.439]                           version <- NULL
[10:19:26.439]                         }
[10:19:26.439]                         if (!has_future || version < "1.8.0") {
[10:19:26.439]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.439]                             "", base::R.version$version.string), 
[10:19:26.439]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.439]                               "release", "version")], collapse = " "), 
[10:19:26.439]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.439]                             info)
[10:19:26.439]                           info <- base::paste(info, collapse = "; ")
[10:19:26.439]                           if (!has_future) {
[10:19:26.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.439]                               info)
[10:19:26.439]                           }
[10:19:26.439]                           else {
[10:19:26.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.439]                               info, version)
[10:19:26.439]                           }
[10:19:26.439]                           base::stop(msg)
[10:19:26.439]                         }
[10:19:26.439]                       })
[10:19:26.439]                     }
[10:19:26.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.439]                     base::options(mc.cores = 1L)
[10:19:26.439]                   }
[10:19:26.439]                   ...future.strategy.old <- future::plan("list")
[10:19:26.439]                   options(future.plan = NULL)
[10:19:26.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.439]                 }
[10:19:26.439]                 ...future.workdir <- getwd()
[10:19:26.439]             }
[10:19:26.439]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.439]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.439]         }
[10:19:26.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.439]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.439]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.439]             base::names(...future.oldOptions))
[10:19:26.439]     }
[10:19:26.439]     if (FALSE) {
[10:19:26.439]     }
[10:19:26.439]     else {
[10:19:26.439]         if (TRUE) {
[10:19:26.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.439]                 open = "w")
[10:19:26.439]         }
[10:19:26.439]         else {
[10:19:26.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.439]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.439]         }
[10:19:26.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.439]             base::sink(type = "output", split = FALSE)
[10:19:26.439]             base::close(...future.stdout)
[10:19:26.439]         }, add = TRUE)
[10:19:26.439]     }
[10:19:26.439]     ...future.frame <- base::sys.nframe()
[10:19:26.439]     ...future.conditions <- base::list()
[10:19:26.439]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.439]     if (FALSE) {
[10:19:26.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.439]     }
[10:19:26.439]     ...future.result <- base::tryCatch({
[10:19:26.439]         base::withCallingHandlers({
[10:19:26.439]             ...future.value <- base::withVisible(base::local({
[10:19:26.439]                 ...future.makeSendCondition <- base::local({
[10:19:26.439]                   sendCondition <- NULL
[10:19:26.439]                   function(frame = 1L) {
[10:19:26.439]                     if (is.function(sendCondition)) 
[10:19:26.439]                       return(sendCondition)
[10:19:26.439]                     ns <- getNamespace("parallel")
[10:19:26.439]                     if (exists("sendData", mode = "function", 
[10:19:26.439]                       envir = ns)) {
[10:19:26.439]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.439]                         envir = ns)
[10:19:26.439]                       envir <- sys.frame(frame)
[10:19:26.439]                       master <- NULL
[10:19:26.439]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.439]                         !identical(envir, emptyenv())) {
[10:19:26.439]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.439]                           inherits = FALSE)) {
[10:19:26.439]                           master <- get("master", mode = "list", 
[10:19:26.439]                             envir = envir, inherits = FALSE)
[10:19:26.439]                           if (inherits(master, c("SOCKnode", 
[10:19:26.439]                             "SOCK0node"))) {
[10:19:26.439]                             sendCondition <<- function(cond) {
[10:19:26.439]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.439]                                 success = TRUE)
[10:19:26.439]                               parallel_sendData(master, data)
[10:19:26.439]                             }
[10:19:26.439]                             return(sendCondition)
[10:19:26.439]                           }
[10:19:26.439]                         }
[10:19:26.439]                         frame <- frame + 1L
[10:19:26.439]                         envir <- sys.frame(frame)
[10:19:26.439]                       }
[10:19:26.439]                     }
[10:19:26.439]                     sendCondition <<- function(cond) NULL
[10:19:26.439]                   }
[10:19:26.439]                 })
[10:19:26.439]                 withCallingHandlers({
[10:19:26.439]                   {
[10:19:26.439]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.439]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.439]                       ...future.globals.maxSize)) {
[10:19:26.439]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.439]                       on.exit(options(oopts), add = TRUE)
[10:19:26.439]                     }
[10:19:26.439]                     {
[10:19:26.439]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:26.439]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:26.439]                           envir = globalenv(), inherits = FALSE)
[10:19:26.439]                         ...future.FUN(...)
[10:19:26.439]                       }
[10:19:26.439]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:26.439]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:26.439]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.439]                         USE.NAMES = FALSE)
[10:19:26.439]                       do.call(mapply, args = args)
[10:19:26.439]                     }
[10:19:26.439]                   }
[10:19:26.439]                 }, immediateCondition = function(cond) {
[10:19:26.439]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.439]                   sendCondition(cond)
[10:19:26.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.439]                   {
[10:19:26.439]                     inherits <- base::inherits
[10:19:26.439]                     invokeRestart <- base::invokeRestart
[10:19:26.439]                     is.null <- base::is.null
[10:19:26.439]                     muffled <- FALSE
[10:19:26.439]                     if (inherits(cond, "message")) {
[10:19:26.439]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.439]                       if (muffled) 
[10:19:26.439]                         invokeRestart("muffleMessage")
[10:19:26.439]                     }
[10:19:26.439]                     else if (inherits(cond, "warning")) {
[10:19:26.439]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.439]                       if (muffled) 
[10:19:26.439]                         invokeRestart("muffleWarning")
[10:19:26.439]                     }
[10:19:26.439]                     else if (inherits(cond, "condition")) {
[10:19:26.439]                       if (!is.null(pattern)) {
[10:19:26.439]                         computeRestarts <- base::computeRestarts
[10:19:26.439]                         grepl <- base::grepl
[10:19:26.439]                         restarts <- computeRestarts(cond)
[10:19:26.439]                         for (restart in restarts) {
[10:19:26.439]                           name <- restart$name
[10:19:26.439]                           if (is.null(name)) 
[10:19:26.439]                             next
[10:19:26.439]                           if (!grepl(pattern, name)) 
[10:19:26.439]                             next
[10:19:26.439]                           invokeRestart(restart)
[10:19:26.439]                           muffled <- TRUE
[10:19:26.439]                           break
[10:19:26.439]                         }
[10:19:26.439]                       }
[10:19:26.439]                     }
[10:19:26.439]                     invisible(muffled)
[10:19:26.439]                   }
[10:19:26.439]                   muffleCondition(cond)
[10:19:26.439]                 })
[10:19:26.439]             }))
[10:19:26.439]             future::FutureResult(value = ...future.value$value, 
[10:19:26.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.439]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.439]                     ...future.globalenv.names))
[10:19:26.439]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.439]         }, condition = base::local({
[10:19:26.439]             c <- base::c
[10:19:26.439]             inherits <- base::inherits
[10:19:26.439]             invokeRestart <- base::invokeRestart
[10:19:26.439]             length <- base::length
[10:19:26.439]             list <- base::list
[10:19:26.439]             seq.int <- base::seq.int
[10:19:26.439]             signalCondition <- base::signalCondition
[10:19:26.439]             sys.calls <- base::sys.calls
[10:19:26.439]             `[[` <- base::`[[`
[10:19:26.439]             `+` <- base::`+`
[10:19:26.439]             `<<-` <- base::`<<-`
[10:19:26.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.439]                   3L)]
[10:19:26.439]             }
[10:19:26.439]             function(cond) {
[10:19:26.439]                 is_error <- inherits(cond, "error")
[10:19:26.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.439]                   NULL)
[10:19:26.439]                 if (is_error) {
[10:19:26.439]                   sessionInformation <- function() {
[10:19:26.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.439]                       search = base::search(), system = base::Sys.info())
[10:19:26.439]                   }
[10:19:26.439]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.439]                     cond$call), session = sessionInformation(), 
[10:19:26.439]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.439]                   signalCondition(cond)
[10:19:26.439]                 }
[10:19:26.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.439]                 "immediateCondition"))) {
[10:19:26.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.439]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.439]                   if (TRUE && !signal) {
[10:19:26.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.439]                     {
[10:19:26.439]                       inherits <- base::inherits
[10:19:26.439]                       invokeRestart <- base::invokeRestart
[10:19:26.439]                       is.null <- base::is.null
[10:19:26.439]                       muffled <- FALSE
[10:19:26.439]                       if (inherits(cond, "message")) {
[10:19:26.439]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.439]                         if (muffled) 
[10:19:26.439]                           invokeRestart("muffleMessage")
[10:19:26.439]                       }
[10:19:26.439]                       else if (inherits(cond, "warning")) {
[10:19:26.439]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.439]                         if (muffled) 
[10:19:26.439]                           invokeRestart("muffleWarning")
[10:19:26.439]                       }
[10:19:26.439]                       else if (inherits(cond, "condition")) {
[10:19:26.439]                         if (!is.null(pattern)) {
[10:19:26.439]                           computeRestarts <- base::computeRestarts
[10:19:26.439]                           grepl <- base::grepl
[10:19:26.439]                           restarts <- computeRestarts(cond)
[10:19:26.439]                           for (restart in restarts) {
[10:19:26.439]                             name <- restart$name
[10:19:26.439]                             if (is.null(name)) 
[10:19:26.439]                               next
[10:19:26.439]                             if (!grepl(pattern, name)) 
[10:19:26.439]                               next
[10:19:26.439]                             invokeRestart(restart)
[10:19:26.439]                             muffled <- TRUE
[10:19:26.439]                             break
[10:19:26.439]                           }
[10:19:26.439]                         }
[10:19:26.439]                       }
[10:19:26.439]                       invisible(muffled)
[10:19:26.439]                     }
[10:19:26.439]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.439]                   }
[10:19:26.439]                 }
[10:19:26.439]                 else {
[10:19:26.439]                   if (TRUE) {
[10:19:26.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.439]                     {
[10:19:26.439]                       inherits <- base::inherits
[10:19:26.439]                       invokeRestart <- base::invokeRestart
[10:19:26.439]                       is.null <- base::is.null
[10:19:26.439]                       muffled <- FALSE
[10:19:26.439]                       if (inherits(cond, "message")) {
[10:19:26.439]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.439]                         if (muffled) 
[10:19:26.439]                           invokeRestart("muffleMessage")
[10:19:26.439]                       }
[10:19:26.439]                       else if (inherits(cond, "warning")) {
[10:19:26.439]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.439]                         if (muffled) 
[10:19:26.439]                           invokeRestart("muffleWarning")
[10:19:26.439]                       }
[10:19:26.439]                       else if (inherits(cond, "condition")) {
[10:19:26.439]                         if (!is.null(pattern)) {
[10:19:26.439]                           computeRestarts <- base::computeRestarts
[10:19:26.439]                           grepl <- base::grepl
[10:19:26.439]                           restarts <- computeRestarts(cond)
[10:19:26.439]                           for (restart in restarts) {
[10:19:26.439]                             name <- restart$name
[10:19:26.439]                             if (is.null(name)) 
[10:19:26.439]                               next
[10:19:26.439]                             if (!grepl(pattern, name)) 
[10:19:26.439]                               next
[10:19:26.439]                             invokeRestart(restart)
[10:19:26.439]                             muffled <- TRUE
[10:19:26.439]                             break
[10:19:26.439]                           }
[10:19:26.439]                         }
[10:19:26.439]                       }
[10:19:26.439]                       invisible(muffled)
[10:19:26.439]                     }
[10:19:26.439]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.439]                   }
[10:19:26.439]                 }
[10:19:26.439]             }
[10:19:26.439]         }))
[10:19:26.439]     }, error = function(ex) {
[10:19:26.439]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.439]                 ...future.rng), started = ...future.startTime, 
[10:19:26.439]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.439]             version = "1.8"), class = "FutureResult")
[10:19:26.439]     }, finally = {
[10:19:26.439]         if (!identical(...future.workdir, getwd())) 
[10:19:26.439]             setwd(...future.workdir)
[10:19:26.439]         {
[10:19:26.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.439]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.439]             }
[10:19:26.439]             base::options(...future.oldOptions)
[10:19:26.439]             if (.Platform$OS.type == "windows") {
[10:19:26.439]                 old_names <- names(...future.oldEnvVars)
[10:19:26.439]                 envs <- base::Sys.getenv()
[10:19:26.439]                 names <- names(envs)
[10:19:26.439]                 common <- intersect(names, old_names)
[10:19:26.439]                 added <- setdiff(names, old_names)
[10:19:26.439]                 removed <- setdiff(old_names, names)
[10:19:26.439]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.439]                   envs[common]]
[10:19:26.439]                 NAMES <- toupper(changed)
[10:19:26.439]                 args <- list()
[10:19:26.439]                 for (kk in seq_along(NAMES)) {
[10:19:26.439]                   name <- changed[[kk]]
[10:19:26.439]                   NAME <- NAMES[[kk]]
[10:19:26.439]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.439]                     next
[10:19:26.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.439]                 }
[10:19:26.439]                 NAMES <- toupper(added)
[10:19:26.439]                 for (kk in seq_along(NAMES)) {
[10:19:26.439]                   name <- added[[kk]]
[10:19:26.439]                   NAME <- NAMES[[kk]]
[10:19:26.439]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.439]                     next
[10:19:26.439]                   args[[name]] <- ""
[10:19:26.439]                 }
[10:19:26.439]                 NAMES <- toupper(removed)
[10:19:26.439]                 for (kk in seq_along(NAMES)) {
[10:19:26.439]                   name <- removed[[kk]]
[10:19:26.439]                   NAME <- NAMES[[kk]]
[10:19:26.439]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.439]                     next
[10:19:26.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.439]                 }
[10:19:26.439]                 if (length(args) > 0) 
[10:19:26.439]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.439]             }
[10:19:26.439]             else {
[10:19:26.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.439]             }
[10:19:26.439]             {
[10:19:26.439]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.439]                   0L) {
[10:19:26.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.439]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.439]                   base::options(opts)
[10:19:26.439]                 }
[10:19:26.439]                 {
[10:19:26.439]                   {
[10:19:26.439]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.439]                     NULL
[10:19:26.439]                   }
[10:19:26.439]                   options(future.plan = NULL)
[10:19:26.439]                   if (is.na(NA_character_)) 
[10:19:26.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.439]                     .init = FALSE)
[10:19:26.439]                 }
[10:19:26.439]             }
[10:19:26.439]         }
[10:19:26.439]     })
[10:19:26.439]     if (TRUE) {
[10:19:26.439]         base::sink(type = "output", split = FALSE)
[10:19:26.439]         if (TRUE) {
[10:19:26.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.439]         }
[10:19:26.439]         else {
[10:19:26.439]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.439]         }
[10:19:26.439]         base::close(...future.stdout)
[10:19:26.439]         ...future.stdout <- NULL
[10:19:26.439]     }
[10:19:26.439]     ...future.result$conditions <- ...future.conditions
[10:19:26.439]     ...future.result$finished <- base::Sys.time()
[10:19:26.439]     ...future.result
[10:19:26.439] }
[10:19:26.442] Exporting 5 global objects (1.09 KiB) to cluster node #2 ...
[10:19:26.442] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ...
[10:19:26.443] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ... DONE
[10:19:26.443] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ...
[10:19:26.443] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ... DONE
[10:19:26.443] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ...
[10:19:26.444] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ... DONE
[10:19:26.444] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ...
[10:19:26.444] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ... DONE
[10:19:26.444] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:26.445] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.445] Exporting 5 global objects (1.09 KiB) to cluster node #2 ... DONE
[10:19:26.445] MultisessionFuture started
[10:19:26.445] - Launch lazy future ... done
[10:19:26.446] run() for ‘MultisessionFuture’ ... done
[10:19:26.446] Created future:
[10:19:26.446] MultisessionFuture:
[10:19:26.446] Label: ‘future_mapply-2’
[10:19:26.446] Expression:
[10:19:26.446] {
[10:19:26.446]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.446]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.446]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.446]         on.exit(options(oopts), add = TRUE)
[10:19:26.446]     }
[10:19:26.446]     {
[10:19:26.446]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:26.446]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:26.446]                 inherits = FALSE)
[10:19:26.446]             ...future.FUN(...)
[10:19:26.446]         }
[10:19:26.446]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:26.446]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:26.446]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.446]         do.call(mapply, args = args)
[10:19:26.446]     }
[10:19:26.446] }
[10:19:26.446] Lazy evaluation: FALSE
[10:19:26.446] Asynchronous evaluation: TRUE
[10:19:26.446] Local evaluation: TRUE
[10:19:26.446] Environment: R_GlobalEnv
[10:19:26.446] Capture standard output: TRUE
[10:19:26.446] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.446] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.446] Packages: <none>
[10:19:26.446] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:26.446] Resolved: FALSE
[10:19:26.446] Value: <not collected>
[10:19:26.446] Conditions captured: <none>
[10:19:26.446] Early signaling: FALSE
[10:19:26.446] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.446] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.460] Chunk #2 of 2 ... DONE
[10:19:26.461] Launching 2 futures (chunks) ... DONE
[10:19:26.461] Resolving 2 futures (chunks) ...
[10:19:26.461] resolve() on list ...
[10:19:26.461]  recursive: 0
[10:19:26.461]  length: 2
[10:19:26.461] 
[10:19:26.462] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.462] - Validating connection of MultisessionFuture
[10:19:26.462] - received message: FutureResult
[10:19:26.462] - Received FutureResult
[10:19:26.462] - Erased future from FutureRegistry
[10:19:26.462] result() for ClusterFuture ...
[10:19:26.462] - result already collected: FutureResult
[10:19:26.462] result() for ClusterFuture ... done
[10:19:26.462] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.462] Future #1
[10:19:26.463] result() for ClusterFuture ...
[10:19:26.463] - result already collected: FutureResult
[10:19:26.463] result() for ClusterFuture ... done
[10:19:26.463] result() for ClusterFuture ...
[10:19:26.463] - result already collected: FutureResult
[10:19:26.463] result() for ClusterFuture ... done
[10:19:26.463] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:26.463] - nx: 2
[10:19:26.463] - relay: TRUE
[10:19:26.463] - stdout: TRUE
[10:19:26.463] - signal: TRUE
[10:19:26.463] - resignal: FALSE
[10:19:26.464] - force: TRUE
[10:19:26.464] - relayed: [n=2] FALSE, FALSE
[10:19:26.464] - queued futures: [n=2] FALSE, FALSE
[10:19:26.464]  - until=1
[10:19:26.464]  - relaying element #1
[10:19:26.464] result() for ClusterFuture ...
[10:19:26.464] - result already collected: FutureResult
[10:19:26.464] result() for ClusterFuture ... done
[10:19:26.464] result() for ClusterFuture ...
[10:19:26.464] - result already collected: FutureResult
[10:19:26.464] result() for ClusterFuture ... done
[10:19:26.464] result() for ClusterFuture ...
[10:19:26.465] - result already collected: FutureResult
[10:19:26.465] result() for ClusterFuture ... done
[10:19:26.465] result() for ClusterFuture ...
[10:19:26.465] - result already collected: FutureResult
[10:19:26.465] result() for ClusterFuture ... done
[10:19:26.465] - relayed: [n=2] TRUE, FALSE
[10:19:26.465] - queued futures: [n=2] TRUE, FALSE
[10:19:26.465] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:26.465]  length: 1 (resolved future 1)
[10:19:26.487] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.487] - Validating connection of MultisessionFuture
[10:19:26.487] - received message: FutureResult
[10:19:26.488] - Received FutureResult
[10:19:26.488] - Erased future from FutureRegistry
[10:19:26.488] result() for ClusterFuture ...
[10:19:26.488] - result already collected: FutureResult
[10:19:26.488] result() for ClusterFuture ... done
[10:19:26.488] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.488] Future #2
[10:19:26.488] result() for ClusterFuture ...
[10:19:26.488] - result already collected: FutureResult
[10:19:26.488] result() for ClusterFuture ... done
[10:19:26.488] result() for ClusterFuture ...
[10:19:26.488] - result already collected: FutureResult
[10:19:26.489] result() for ClusterFuture ... done
[10:19:26.489] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:26.489] - nx: 2
[10:19:26.489] - relay: TRUE
[10:19:26.489] - stdout: TRUE
[10:19:26.489] - signal: TRUE
[10:19:26.489] - resignal: FALSE
[10:19:26.489] - force: TRUE
[10:19:26.489] - relayed: [n=2] TRUE, FALSE
[10:19:26.489] - queued futures: [n=2] TRUE, FALSE
[10:19:26.489]  - until=2
[10:19:26.489]  - relaying element #2
[10:19:26.490] result() for ClusterFuture ...
[10:19:26.490] - result already collected: FutureResult
[10:19:26.490] result() for ClusterFuture ... done
[10:19:26.490] result() for ClusterFuture ...
[10:19:26.490] - result already collected: FutureResult
[10:19:26.490] result() for ClusterFuture ... done
[10:19:26.490] result() for ClusterFuture ...
[10:19:26.490] - result already collected: FutureResult
[10:19:26.490] result() for ClusterFuture ... done
[10:19:26.490] result() for ClusterFuture ...
[10:19:26.490] - result already collected: FutureResult
[10:19:26.490] result() for ClusterFuture ... done
[10:19:26.491] - relayed: [n=2] TRUE, TRUE
[10:19:26.491] - queued futures: [n=2] TRUE, TRUE
[10:19:26.491] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:26.491]  length: 0 (resolved future 2)
[10:19:26.491] Relaying remaining futures
[10:19:26.491] signalConditionsASAP(NULL, pos=0) ...
[10:19:26.491] - nx: 2
[10:19:26.491] - relay: TRUE
[10:19:26.491] - stdout: TRUE
[10:19:26.491] - signal: TRUE
[10:19:26.491] - resignal: FALSE
[10:19:26.491] - force: TRUE
[10:19:26.491] - relayed: [n=2] TRUE, TRUE
[10:19:26.492] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:26.492] - relayed: [n=2] TRUE, TRUE
[10:19:26.492] - queued futures: [n=2] TRUE, TRUE
[10:19:26.492] signalConditionsASAP(NULL, pos=0) ... done
[10:19:26.492] resolve() on list ... DONE
[10:19:26.492] result() for ClusterFuture ...
[10:19:26.492] - result already collected: FutureResult
[10:19:26.492] result() for ClusterFuture ... done
[10:19:26.492] result() for ClusterFuture ...
[10:19:26.492] - result already collected: FutureResult
[10:19:26.492] result() for ClusterFuture ... done
[10:19:26.492] result() for ClusterFuture ...
[10:19:26.493] - result already collected: FutureResult
[10:19:26.493] result() for ClusterFuture ... done
[10:19:26.493] result() for ClusterFuture ...
[10:19:26.493] - result already collected: FutureResult
[10:19:26.493] result() for ClusterFuture ... done
[10:19:26.493]  - Number of value chunks collected: 2
[10:19:26.493] Resolving 2 futures (chunks) ... DONE
[10:19:26.493] Reducing values from 2 chunks ...
[10:19:26.493]  - Number of values collected after concatenation: 2
[10:19:26.493]  - Number of values expected: 2
[10:19:26.493] Reducing values from 2 chunks ... DONE
[10:19:26.494] future_mapply() ... DONE
[10:19:26.494] future_mapply() ...
[10:19:26.495] Number of chunks: 2
[10:19:26.495] getGlobalsAndPackagesXApply() ...
[10:19:26.496]  - future.globals: TRUE
[10:19:26.496] getGlobalsAndPackages() ...
[10:19:26.496] Searching for globals...
[10:19:26.497] - globals found: [1] ‘FUN’
[10:19:26.497] Searching for globals ... DONE
[10:19:26.497] Resolving globals: FALSE
[10:19:26.497] The total size of the 1 globals is 326 bytes (326 bytes)
[10:19:26.498] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[10:19:26.498] - globals: [1] ‘FUN’
[10:19:26.498] 
[10:19:26.498] getGlobalsAndPackages() ... DONE
[10:19:26.498]  - globals found/used: [n=1] ‘FUN’
[10:19:26.498]  - needed namespaces: [n=0] 
[10:19:26.498] Finding globals ... DONE
[10:19:26.498] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:26.498] List of 2
[10:19:26.498]  $ ...future.FUN:function (x, y)  
[10:19:26.498]  $ MoreArgs     :List of 1
[10:19:26.498]   ..$ y: int [1:2] 3 4
[10:19:26.498]  - attr(*, "where")=List of 2
[10:19:26.498]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:26.498]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:26.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:26.498]  - attr(*, "resolved")= logi FALSE
[10:19:26.498]  - attr(*, "total_size")= num NA
[10:19:26.501] Packages to be attached in all futures: [n=0] 
[10:19:26.501] getGlobalsAndPackagesXApply() ... DONE
[10:19:26.502] Number of futures (= number of chunks): 2
[10:19:26.502] Launching 2 futures (chunks) ...
[10:19:26.502] Chunk #1 of 2 ...
[10:19:26.502]  - Finding globals in '...' for chunk #1 ...
[10:19:26.502] getGlobalsAndPackages() ...
[10:19:26.502] Searching for globals...
[10:19:26.502] 
[10:19:26.502] Searching for globals ... DONE
[10:19:26.503] - globals: [0] <none>
[10:19:26.503] getGlobalsAndPackages() ... DONE
[10:19:26.503]    + additional globals found: [n=0] 
[10:19:26.503]    + additional namespaces needed: [n=0] 
[10:19:26.503]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:26.503]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.503]  - seeds: <none>
[10:19:26.503]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.503] getGlobalsAndPackages() ...
[10:19:26.503] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.503] Resolving globals: FALSE
[10:19:26.504] The total size of the 5 globals is 656 bytes (656 bytes)
[10:19:26.504] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:26.504] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.505] 
[10:19:26.505] getGlobalsAndPackages() ... DONE
[10:19:26.505] run() for ‘Future’ ...
[10:19:26.505] - state: ‘created’
[10:19:26.505] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.519] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.519] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.519]   - Field: ‘node’
[10:19:26.519]   - Field: ‘label’
[10:19:26.520]   - Field: ‘local’
[10:19:26.520]   - Field: ‘owner’
[10:19:26.520]   - Field: ‘envir’
[10:19:26.520]   - Field: ‘workers’
[10:19:26.520]   - Field: ‘packages’
[10:19:26.520]   - Field: ‘gc’
[10:19:26.520]   - Field: ‘conditions’
[10:19:26.520]   - Field: ‘persistent’
[10:19:26.520]   - Field: ‘expr’
[10:19:26.520]   - Field: ‘uuid’
[10:19:26.520]   - Field: ‘seed’
[10:19:26.520]   - Field: ‘version’
[10:19:26.521]   - Field: ‘result’
[10:19:26.521]   - Field: ‘asynchronous’
[10:19:26.521]   - Field: ‘calls’
[10:19:26.521]   - Field: ‘globals’
[10:19:26.521]   - Field: ‘stdout’
[10:19:26.521]   - Field: ‘earlySignal’
[10:19:26.521]   - Field: ‘lazy’
[10:19:26.521]   - Field: ‘state’
[10:19:26.521] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.521] - Launch lazy future ...
[10:19:26.522] Packages needed by the future expression (n = 0): <none>
[10:19:26.522] Packages needed by future strategies (n = 0): <none>
[10:19:26.522] {
[10:19:26.522]     {
[10:19:26.522]         {
[10:19:26.522]             ...future.startTime <- base::Sys.time()
[10:19:26.522]             {
[10:19:26.522]                 {
[10:19:26.522]                   {
[10:19:26.522]                     {
[10:19:26.522]                       base::local({
[10:19:26.522]                         has_future <- base::requireNamespace("future", 
[10:19:26.522]                           quietly = TRUE)
[10:19:26.522]                         if (has_future) {
[10:19:26.522]                           ns <- base::getNamespace("future")
[10:19:26.522]                           version <- ns[[".package"]][["version"]]
[10:19:26.522]                           if (is.null(version)) 
[10:19:26.522]                             version <- utils::packageVersion("future")
[10:19:26.522]                         }
[10:19:26.522]                         else {
[10:19:26.522]                           version <- NULL
[10:19:26.522]                         }
[10:19:26.522]                         if (!has_future || version < "1.8.0") {
[10:19:26.522]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.522]                             "", base::R.version$version.string), 
[10:19:26.522]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.522]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.522]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.522]                               "release", "version")], collapse = " "), 
[10:19:26.522]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.522]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.522]                             info)
[10:19:26.522]                           info <- base::paste(info, collapse = "; ")
[10:19:26.522]                           if (!has_future) {
[10:19:26.522]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.522]                               info)
[10:19:26.522]                           }
[10:19:26.522]                           else {
[10:19:26.522]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.522]                               info, version)
[10:19:26.522]                           }
[10:19:26.522]                           base::stop(msg)
[10:19:26.522]                         }
[10:19:26.522]                       })
[10:19:26.522]                     }
[10:19:26.522]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.522]                     base::options(mc.cores = 1L)
[10:19:26.522]                   }
[10:19:26.522]                   ...future.strategy.old <- future::plan("list")
[10:19:26.522]                   options(future.plan = NULL)
[10:19:26.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.522]                 }
[10:19:26.522]                 ...future.workdir <- getwd()
[10:19:26.522]             }
[10:19:26.522]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.522]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.522]         }
[10:19:26.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.522]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.522]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.522]             base::names(...future.oldOptions))
[10:19:26.522]     }
[10:19:26.522]     if (FALSE) {
[10:19:26.522]     }
[10:19:26.522]     else {
[10:19:26.522]         if (TRUE) {
[10:19:26.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.522]                 open = "w")
[10:19:26.522]         }
[10:19:26.522]         else {
[10:19:26.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.522]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.522]         }
[10:19:26.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.522]             base::sink(type = "output", split = FALSE)
[10:19:26.522]             base::close(...future.stdout)
[10:19:26.522]         }, add = TRUE)
[10:19:26.522]     }
[10:19:26.522]     ...future.frame <- base::sys.nframe()
[10:19:26.522]     ...future.conditions <- base::list()
[10:19:26.522]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.522]     if (FALSE) {
[10:19:26.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.522]     }
[10:19:26.522]     ...future.result <- base::tryCatch({
[10:19:26.522]         base::withCallingHandlers({
[10:19:26.522]             ...future.value <- base::withVisible(base::local({
[10:19:26.522]                 ...future.makeSendCondition <- base::local({
[10:19:26.522]                   sendCondition <- NULL
[10:19:26.522]                   function(frame = 1L) {
[10:19:26.522]                     if (is.function(sendCondition)) 
[10:19:26.522]                       return(sendCondition)
[10:19:26.522]                     ns <- getNamespace("parallel")
[10:19:26.522]                     if (exists("sendData", mode = "function", 
[10:19:26.522]                       envir = ns)) {
[10:19:26.522]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.522]                         envir = ns)
[10:19:26.522]                       envir <- sys.frame(frame)
[10:19:26.522]                       master <- NULL
[10:19:26.522]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.522]                         !identical(envir, emptyenv())) {
[10:19:26.522]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.522]                           inherits = FALSE)) {
[10:19:26.522]                           master <- get("master", mode = "list", 
[10:19:26.522]                             envir = envir, inherits = FALSE)
[10:19:26.522]                           if (inherits(master, c("SOCKnode", 
[10:19:26.522]                             "SOCK0node"))) {
[10:19:26.522]                             sendCondition <<- function(cond) {
[10:19:26.522]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.522]                                 success = TRUE)
[10:19:26.522]                               parallel_sendData(master, data)
[10:19:26.522]                             }
[10:19:26.522]                             return(sendCondition)
[10:19:26.522]                           }
[10:19:26.522]                         }
[10:19:26.522]                         frame <- frame + 1L
[10:19:26.522]                         envir <- sys.frame(frame)
[10:19:26.522]                       }
[10:19:26.522]                     }
[10:19:26.522]                     sendCondition <<- function(cond) NULL
[10:19:26.522]                   }
[10:19:26.522]                 })
[10:19:26.522]                 withCallingHandlers({
[10:19:26.522]                   {
[10:19:26.522]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.522]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.522]                       ...future.globals.maxSize)) {
[10:19:26.522]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.522]                       on.exit(options(oopts), add = TRUE)
[10:19:26.522]                     }
[10:19:26.522]                     {
[10:19:26.522]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.522]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.522]                         USE.NAMES = FALSE)
[10:19:26.522]                       do.call(mapply, args = args)
[10:19:26.522]                     }
[10:19:26.522]                   }
[10:19:26.522]                 }, immediateCondition = function(cond) {
[10:19:26.522]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.522]                   sendCondition(cond)
[10:19:26.522]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.522]                   {
[10:19:26.522]                     inherits <- base::inherits
[10:19:26.522]                     invokeRestart <- base::invokeRestart
[10:19:26.522]                     is.null <- base::is.null
[10:19:26.522]                     muffled <- FALSE
[10:19:26.522]                     if (inherits(cond, "message")) {
[10:19:26.522]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.522]                       if (muffled) 
[10:19:26.522]                         invokeRestart("muffleMessage")
[10:19:26.522]                     }
[10:19:26.522]                     else if (inherits(cond, "warning")) {
[10:19:26.522]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.522]                       if (muffled) 
[10:19:26.522]                         invokeRestart("muffleWarning")
[10:19:26.522]                     }
[10:19:26.522]                     else if (inherits(cond, "condition")) {
[10:19:26.522]                       if (!is.null(pattern)) {
[10:19:26.522]                         computeRestarts <- base::computeRestarts
[10:19:26.522]                         grepl <- base::grepl
[10:19:26.522]                         restarts <- computeRestarts(cond)
[10:19:26.522]                         for (restart in restarts) {
[10:19:26.522]                           name <- restart$name
[10:19:26.522]                           if (is.null(name)) 
[10:19:26.522]                             next
[10:19:26.522]                           if (!grepl(pattern, name)) 
[10:19:26.522]                             next
[10:19:26.522]                           invokeRestart(restart)
[10:19:26.522]                           muffled <- TRUE
[10:19:26.522]                           break
[10:19:26.522]                         }
[10:19:26.522]                       }
[10:19:26.522]                     }
[10:19:26.522]                     invisible(muffled)
[10:19:26.522]                   }
[10:19:26.522]                   muffleCondition(cond)
[10:19:26.522]                 })
[10:19:26.522]             }))
[10:19:26.522]             future::FutureResult(value = ...future.value$value, 
[10:19:26.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.522]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.522]                     ...future.globalenv.names))
[10:19:26.522]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.522]         }, condition = base::local({
[10:19:26.522]             c <- base::c
[10:19:26.522]             inherits <- base::inherits
[10:19:26.522]             invokeRestart <- base::invokeRestart
[10:19:26.522]             length <- base::length
[10:19:26.522]             list <- base::list
[10:19:26.522]             seq.int <- base::seq.int
[10:19:26.522]             signalCondition <- base::signalCondition
[10:19:26.522]             sys.calls <- base::sys.calls
[10:19:26.522]             `[[` <- base::`[[`
[10:19:26.522]             `+` <- base::`+`
[10:19:26.522]             `<<-` <- base::`<<-`
[10:19:26.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.522]                   3L)]
[10:19:26.522]             }
[10:19:26.522]             function(cond) {
[10:19:26.522]                 is_error <- inherits(cond, "error")
[10:19:26.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.522]                   NULL)
[10:19:26.522]                 if (is_error) {
[10:19:26.522]                   sessionInformation <- function() {
[10:19:26.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.522]                       search = base::search(), system = base::Sys.info())
[10:19:26.522]                   }
[10:19:26.522]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.522]                     cond$call), session = sessionInformation(), 
[10:19:26.522]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.522]                   signalCondition(cond)
[10:19:26.522]                 }
[10:19:26.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.522]                 "immediateCondition"))) {
[10:19:26.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.522]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.522]                   if (TRUE && !signal) {
[10:19:26.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.522]                     {
[10:19:26.522]                       inherits <- base::inherits
[10:19:26.522]                       invokeRestart <- base::invokeRestart
[10:19:26.522]                       is.null <- base::is.null
[10:19:26.522]                       muffled <- FALSE
[10:19:26.522]                       if (inherits(cond, "message")) {
[10:19:26.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.522]                         if (muffled) 
[10:19:26.522]                           invokeRestart("muffleMessage")
[10:19:26.522]                       }
[10:19:26.522]                       else if (inherits(cond, "warning")) {
[10:19:26.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.522]                         if (muffled) 
[10:19:26.522]                           invokeRestart("muffleWarning")
[10:19:26.522]                       }
[10:19:26.522]                       else if (inherits(cond, "condition")) {
[10:19:26.522]                         if (!is.null(pattern)) {
[10:19:26.522]                           computeRestarts <- base::computeRestarts
[10:19:26.522]                           grepl <- base::grepl
[10:19:26.522]                           restarts <- computeRestarts(cond)
[10:19:26.522]                           for (restart in restarts) {
[10:19:26.522]                             name <- restart$name
[10:19:26.522]                             if (is.null(name)) 
[10:19:26.522]                               next
[10:19:26.522]                             if (!grepl(pattern, name)) 
[10:19:26.522]                               next
[10:19:26.522]                             invokeRestart(restart)
[10:19:26.522]                             muffled <- TRUE
[10:19:26.522]                             break
[10:19:26.522]                           }
[10:19:26.522]                         }
[10:19:26.522]                       }
[10:19:26.522]                       invisible(muffled)
[10:19:26.522]                     }
[10:19:26.522]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.522]                   }
[10:19:26.522]                 }
[10:19:26.522]                 else {
[10:19:26.522]                   if (TRUE) {
[10:19:26.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.522]                     {
[10:19:26.522]                       inherits <- base::inherits
[10:19:26.522]                       invokeRestart <- base::invokeRestart
[10:19:26.522]                       is.null <- base::is.null
[10:19:26.522]                       muffled <- FALSE
[10:19:26.522]                       if (inherits(cond, "message")) {
[10:19:26.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.522]                         if (muffled) 
[10:19:26.522]                           invokeRestart("muffleMessage")
[10:19:26.522]                       }
[10:19:26.522]                       else if (inherits(cond, "warning")) {
[10:19:26.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.522]                         if (muffled) 
[10:19:26.522]                           invokeRestart("muffleWarning")
[10:19:26.522]                       }
[10:19:26.522]                       else if (inherits(cond, "condition")) {
[10:19:26.522]                         if (!is.null(pattern)) {
[10:19:26.522]                           computeRestarts <- base::computeRestarts
[10:19:26.522]                           grepl <- base::grepl
[10:19:26.522]                           restarts <- computeRestarts(cond)
[10:19:26.522]                           for (restart in restarts) {
[10:19:26.522]                             name <- restart$name
[10:19:26.522]                             if (is.null(name)) 
[10:19:26.522]                               next
[10:19:26.522]                             if (!grepl(pattern, name)) 
[10:19:26.522]                               next
[10:19:26.522]                             invokeRestart(restart)
[10:19:26.522]                             muffled <- TRUE
[10:19:26.522]                             break
[10:19:26.522]                           }
[10:19:26.522]                         }
[10:19:26.522]                       }
[10:19:26.522]                       invisible(muffled)
[10:19:26.522]                     }
[10:19:26.522]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.522]                   }
[10:19:26.522]                 }
[10:19:26.522]             }
[10:19:26.522]         }))
[10:19:26.522]     }, error = function(ex) {
[10:19:26.522]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.522]                 ...future.rng), started = ...future.startTime, 
[10:19:26.522]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.522]             version = "1.8"), class = "FutureResult")
[10:19:26.522]     }, finally = {
[10:19:26.522]         if (!identical(...future.workdir, getwd())) 
[10:19:26.522]             setwd(...future.workdir)
[10:19:26.522]         {
[10:19:26.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.522]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.522]             }
[10:19:26.522]             base::options(...future.oldOptions)
[10:19:26.522]             if (.Platform$OS.type == "windows") {
[10:19:26.522]                 old_names <- names(...future.oldEnvVars)
[10:19:26.522]                 envs <- base::Sys.getenv()
[10:19:26.522]                 names <- names(envs)
[10:19:26.522]                 common <- intersect(names, old_names)
[10:19:26.522]                 added <- setdiff(names, old_names)
[10:19:26.522]                 removed <- setdiff(old_names, names)
[10:19:26.522]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.522]                   envs[common]]
[10:19:26.522]                 NAMES <- toupper(changed)
[10:19:26.522]                 args <- list()
[10:19:26.522]                 for (kk in seq_along(NAMES)) {
[10:19:26.522]                   name <- changed[[kk]]
[10:19:26.522]                   NAME <- NAMES[[kk]]
[10:19:26.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.522]                     next
[10:19:26.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.522]                 }
[10:19:26.522]                 NAMES <- toupper(added)
[10:19:26.522]                 for (kk in seq_along(NAMES)) {
[10:19:26.522]                   name <- added[[kk]]
[10:19:26.522]                   NAME <- NAMES[[kk]]
[10:19:26.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.522]                     next
[10:19:26.522]                   args[[name]] <- ""
[10:19:26.522]                 }
[10:19:26.522]                 NAMES <- toupper(removed)
[10:19:26.522]                 for (kk in seq_along(NAMES)) {
[10:19:26.522]                   name <- removed[[kk]]
[10:19:26.522]                   NAME <- NAMES[[kk]]
[10:19:26.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.522]                     next
[10:19:26.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.522]                 }
[10:19:26.522]                 if (length(args) > 0) 
[10:19:26.522]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.522]             }
[10:19:26.522]             else {
[10:19:26.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.522]             }
[10:19:26.522]             {
[10:19:26.522]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.522]                   0L) {
[10:19:26.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.522]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.522]                   base::options(opts)
[10:19:26.522]                 }
[10:19:26.522]                 {
[10:19:26.522]                   {
[10:19:26.522]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.522]                     NULL
[10:19:26.522]                   }
[10:19:26.522]                   options(future.plan = NULL)
[10:19:26.522]                   if (is.na(NA_character_)) 
[10:19:26.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.522]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.522]                     .init = FALSE)
[10:19:26.522]                 }
[10:19:26.522]             }
[10:19:26.522]         }
[10:19:26.522]     })
[10:19:26.522]     if (TRUE) {
[10:19:26.522]         base::sink(type = "output", split = FALSE)
[10:19:26.522]         if (TRUE) {
[10:19:26.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.522]         }
[10:19:26.522]         else {
[10:19:26.522]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.522]         }
[10:19:26.522]         base::close(...future.stdout)
[10:19:26.522]         ...future.stdout <- NULL
[10:19:26.522]     }
[10:19:26.522]     ...future.result$conditions <- ...future.conditions
[10:19:26.522]     ...future.result$finished <- base::Sys.time()
[10:19:26.522]     ...future.result
[10:19:26.522] }
[10:19:26.525] Exporting 5 global objects (1.05 KiB) to cluster node #1 ...
[10:19:26.525] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ...
[10:19:26.526] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ... DONE
[10:19:26.526] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ...
[10:19:26.526] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ... DONE
[10:19:26.526] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ...
[10:19:26.527] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ... DONE
[10:19:26.527] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:26.527] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.527] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:26.527] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.528] Exporting 5 global objects (1.05 KiB) to cluster node #1 ... DONE
[10:19:26.528] MultisessionFuture started
[10:19:26.528] - Launch lazy future ... done
[10:19:26.528] run() for ‘MultisessionFuture’ ... done
[10:19:26.528] Created future:
[10:19:26.528] MultisessionFuture:
[10:19:26.528] Label: ‘future_.mapply-1’
[10:19:26.528] Expression:
[10:19:26.528] {
[10:19:26.528]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.528]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.528]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.528]         on.exit(options(oopts), add = TRUE)
[10:19:26.528]     }
[10:19:26.528]     {
[10:19:26.528]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.528]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.528]         do.call(mapply, args = args)
[10:19:26.528]     }
[10:19:26.528] }
[10:19:26.528] Lazy evaluation: FALSE
[10:19:26.528] Asynchronous evaluation: TRUE
[10:19:26.528] Local evaluation: TRUE
[10:19:26.528] Environment: R_GlobalEnv
[10:19:26.528] Capture standard output: TRUE
[10:19:26.528] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.528] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.528] Packages: <none>
[10:19:26.528] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.528] Resolved: FALSE
[10:19:26.528] Value: <not collected>
[10:19:26.528] Conditions captured: <none>
[10:19:26.528] Early signaling: FALSE
[10:19:26.528] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.528] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.540] Chunk #1 of 2 ... DONE
[10:19:26.540] Chunk #2 of 2 ...
[10:19:26.540]  - Finding globals in '...' for chunk #2 ...
[10:19:26.540] getGlobalsAndPackages() ...
[10:19:26.540] Searching for globals...
[10:19:26.541] 
[10:19:26.541] Searching for globals ... DONE
[10:19:26.541] - globals: [0] <none>
[10:19:26.541] getGlobalsAndPackages() ... DONE
[10:19:26.541]    + additional globals found: [n=0] 
[10:19:26.541]    + additional namespaces needed: [n=0] 
[10:19:26.541]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:26.541]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.541]  - seeds: <none>
[10:19:26.541]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.541] getGlobalsAndPackages() ...
[10:19:26.542] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.542] Resolving globals: FALSE
[10:19:26.542] The total size of the 5 globals is 656 bytes (656 bytes)
[10:19:26.543] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[10:19:26.543] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.543] 
[10:19:26.543] getGlobalsAndPackages() ... DONE
[10:19:26.543] run() for ‘Future’ ...
[10:19:26.543] - state: ‘created’
[10:19:26.543] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.557] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.557]   - Field: ‘node’
[10:19:26.557]   - Field: ‘label’
[10:19:26.557]   - Field: ‘local’
[10:19:26.558]   - Field: ‘owner’
[10:19:26.558]   - Field: ‘envir’
[10:19:26.558]   - Field: ‘workers’
[10:19:26.558]   - Field: ‘packages’
[10:19:26.558]   - Field: ‘gc’
[10:19:26.558]   - Field: ‘conditions’
[10:19:26.558]   - Field: ‘persistent’
[10:19:26.558]   - Field: ‘expr’
[10:19:26.558]   - Field: ‘uuid’
[10:19:26.558]   - Field: ‘seed’
[10:19:26.558]   - Field: ‘version’
[10:19:26.559]   - Field: ‘result’
[10:19:26.559]   - Field: ‘asynchronous’
[10:19:26.559]   - Field: ‘calls’
[10:19:26.559]   - Field: ‘globals’
[10:19:26.559]   - Field: ‘stdout’
[10:19:26.559]   - Field: ‘earlySignal’
[10:19:26.559]   - Field: ‘lazy’
[10:19:26.559]   - Field: ‘state’
[10:19:26.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.559] - Launch lazy future ...
[10:19:26.560] Packages needed by the future expression (n = 0): <none>
[10:19:26.560] Packages needed by future strategies (n = 0): <none>
[10:19:26.560] {
[10:19:26.560]     {
[10:19:26.560]         {
[10:19:26.560]             ...future.startTime <- base::Sys.time()
[10:19:26.560]             {
[10:19:26.560]                 {
[10:19:26.560]                   {
[10:19:26.560]                     {
[10:19:26.560]                       base::local({
[10:19:26.560]                         has_future <- base::requireNamespace("future", 
[10:19:26.560]                           quietly = TRUE)
[10:19:26.560]                         if (has_future) {
[10:19:26.560]                           ns <- base::getNamespace("future")
[10:19:26.560]                           version <- ns[[".package"]][["version"]]
[10:19:26.560]                           if (is.null(version)) 
[10:19:26.560]                             version <- utils::packageVersion("future")
[10:19:26.560]                         }
[10:19:26.560]                         else {
[10:19:26.560]                           version <- NULL
[10:19:26.560]                         }
[10:19:26.560]                         if (!has_future || version < "1.8.0") {
[10:19:26.560]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.560]                             "", base::R.version$version.string), 
[10:19:26.560]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.560]                               "release", "version")], collapse = " "), 
[10:19:26.560]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.560]                             info)
[10:19:26.560]                           info <- base::paste(info, collapse = "; ")
[10:19:26.560]                           if (!has_future) {
[10:19:26.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.560]                               info)
[10:19:26.560]                           }
[10:19:26.560]                           else {
[10:19:26.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.560]                               info, version)
[10:19:26.560]                           }
[10:19:26.560]                           base::stop(msg)
[10:19:26.560]                         }
[10:19:26.560]                       })
[10:19:26.560]                     }
[10:19:26.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.560]                     base::options(mc.cores = 1L)
[10:19:26.560]                   }
[10:19:26.560]                   ...future.strategy.old <- future::plan("list")
[10:19:26.560]                   options(future.plan = NULL)
[10:19:26.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.560]                 }
[10:19:26.560]                 ...future.workdir <- getwd()
[10:19:26.560]             }
[10:19:26.560]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.560]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.560]         }
[10:19:26.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.560]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.560]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.560]             base::names(...future.oldOptions))
[10:19:26.560]     }
[10:19:26.560]     if (FALSE) {
[10:19:26.560]     }
[10:19:26.560]     else {
[10:19:26.560]         if (TRUE) {
[10:19:26.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.560]                 open = "w")
[10:19:26.560]         }
[10:19:26.560]         else {
[10:19:26.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.560]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.560]         }
[10:19:26.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.560]             base::sink(type = "output", split = FALSE)
[10:19:26.560]             base::close(...future.stdout)
[10:19:26.560]         }, add = TRUE)
[10:19:26.560]     }
[10:19:26.560]     ...future.frame <- base::sys.nframe()
[10:19:26.560]     ...future.conditions <- base::list()
[10:19:26.560]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.560]     if (FALSE) {
[10:19:26.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.560]     }
[10:19:26.560]     ...future.result <- base::tryCatch({
[10:19:26.560]         base::withCallingHandlers({
[10:19:26.560]             ...future.value <- base::withVisible(base::local({
[10:19:26.560]                 ...future.makeSendCondition <- base::local({
[10:19:26.560]                   sendCondition <- NULL
[10:19:26.560]                   function(frame = 1L) {
[10:19:26.560]                     if (is.function(sendCondition)) 
[10:19:26.560]                       return(sendCondition)
[10:19:26.560]                     ns <- getNamespace("parallel")
[10:19:26.560]                     if (exists("sendData", mode = "function", 
[10:19:26.560]                       envir = ns)) {
[10:19:26.560]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.560]                         envir = ns)
[10:19:26.560]                       envir <- sys.frame(frame)
[10:19:26.560]                       master <- NULL
[10:19:26.560]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.560]                         !identical(envir, emptyenv())) {
[10:19:26.560]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.560]                           inherits = FALSE)) {
[10:19:26.560]                           master <- get("master", mode = "list", 
[10:19:26.560]                             envir = envir, inherits = FALSE)
[10:19:26.560]                           if (inherits(master, c("SOCKnode", 
[10:19:26.560]                             "SOCK0node"))) {
[10:19:26.560]                             sendCondition <<- function(cond) {
[10:19:26.560]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.560]                                 success = TRUE)
[10:19:26.560]                               parallel_sendData(master, data)
[10:19:26.560]                             }
[10:19:26.560]                             return(sendCondition)
[10:19:26.560]                           }
[10:19:26.560]                         }
[10:19:26.560]                         frame <- frame + 1L
[10:19:26.560]                         envir <- sys.frame(frame)
[10:19:26.560]                       }
[10:19:26.560]                     }
[10:19:26.560]                     sendCondition <<- function(cond) NULL
[10:19:26.560]                   }
[10:19:26.560]                 })
[10:19:26.560]                 withCallingHandlers({
[10:19:26.560]                   {
[10:19:26.560]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.560]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.560]                       ...future.globals.maxSize)) {
[10:19:26.560]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.560]                       on.exit(options(oopts), add = TRUE)
[10:19:26.560]                     }
[10:19:26.560]                     {
[10:19:26.560]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.560]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.560]                         USE.NAMES = FALSE)
[10:19:26.560]                       do.call(mapply, args = args)
[10:19:26.560]                     }
[10:19:26.560]                   }
[10:19:26.560]                 }, immediateCondition = function(cond) {
[10:19:26.560]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.560]                   sendCondition(cond)
[10:19:26.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.560]                   {
[10:19:26.560]                     inherits <- base::inherits
[10:19:26.560]                     invokeRestart <- base::invokeRestart
[10:19:26.560]                     is.null <- base::is.null
[10:19:26.560]                     muffled <- FALSE
[10:19:26.560]                     if (inherits(cond, "message")) {
[10:19:26.560]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.560]                       if (muffled) 
[10:19:26.560]                         invokeRestart("muffleMessage")
[10:19:26.560]                     }
[10:19:26.560]                     else if (inherits(cond, "warning")) {
[10:19:26.560]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.560]                       if (muffled) 
[10:19:26.560]                         invokeRestart("muffleWarning")
[10:19:26.560]                     }
[10:19:26.560]                     else if (inherits(cond, "condition")) {
[10:19:26.560]                       if (!is.null(pattern)) {
[10:19:26.560]                         computeRestarts <- base::computeRestarts
[10:19:26.560]                         grepl <- base::grepl
[10:19:26.560]                         restarts <- computeRestarts(cond)
[10:19:26.560]                         for (restart in restarts) {
[10:19:26.560]                           name <- restart$name
[10:19:26.560]                           if (is.null(name)) 
[10:19:26.560]                             next
[10:19:26.560]                           if (!grepl(pattern, name)) 
[10:19:26.560]                             next
[10:19:26.560]                           invokeRestart(restart)
[10:19:26.560]                           muffled <- TRUE
[10:19:26.560]                           break
[10:19:26.560]                         }
[10:19:26.560]                       }
[10:19:26.560]                     }
[10:19:26.560]                     invisible(muffled)
[10:19:26.560]                   }
[10:19:26.560]                   muffleCondition(cond)
[10:19:26.560]                 })
[10:19:26.560]             }))
[10:19:26.560]             future::FutureResult(value = ...future.value$value, 
[10:19:26.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.560]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.560]                     ...future.globalenv.names))
[10:19:26.560]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.560]         }, condition = base::local({
[10:19:26.560]             c <- base::c
[10:19:26.560]             inherits <- base::inherits
[10:19:26.560]             invokeRestart <- base::invokeRestart
[10:19:26.560]             length <- base::length
[10:19:26.560]             list <- base::list
[10:19:26.560]             seq.int <- base::seq.int
[10:19:26.560]             signalCondition <- base::signalCondition
[10:19:26.560]             sys.calls <- base::sys.calls
[10:19:26.560]             `[[` <- base::`[[`
[10:19:26.560]             `+` <- base::`+`
[10:19:26.560]             `<<-` <- base::`<<-`
[10:19:26.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.560]                   3L)]
[10:19:26.560]             }
[10:19:26.560]             function(cond) {
[10:19:26.560]                 is_error <- inherits(cond, "error")
[10:19:26.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.560]                   NULL)
[10:19:26.560]                 if (is_error) {
[10:19:26.560]                   sessionInformation <- function() {
[10:19:26.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.560]                       search = base::search(), system = base::Sys.info())
[10:19:26.560]                   }
[10:19:26.560]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.560]                     cond$call), session = sessionInformation(), 
[10:19:26.560]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.560]                   signalCondition(cond)
[10:19:26.560]                 }
[10:19:26.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.560]                 "immediateCondition"))) {
[10:19:26.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.560]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.560]                   if (TRUE && !signal) {
[10:19:26.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.560]                     {
[10:19:26.560]                       inherits <- base::inherits
[10:19:26.560]                       invokeRestart <- base::invokeRestart
[10:19:26.560]                       is.null <- base::is.null
[10:19:26.560]                       muffled <- FALSE
[10:19:26.560]                       if (inherits(cond, "message")) {
[10:19:26.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.560]                         if (muffled) 
[10:19:26.560]                           invokeRestart("muffleMessage")
[10:19:26.560]                       }
[10:19:26.560]                       else if (inherits(cond, "warning")) {
[10:19:26.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.560]                         if (muffled) 
[10:19:26.560]                           invokeRestart("muffleWarning")
[10:19:26.560]                       }
[10:19:26.560]                       else if (inherits(cond, "condition")) {
[10:19:26.560]                         if (!is.null(pattern)) {
[10:19:26.560]                           computeRestarts <- base::computeRestarts
[10:19:26.560]                           grepl <- base::grepl
[10:19:26.560]                           restarts <- computeRestarts(cond)
[10:19:26.560]                           for (restart in restarts) {
[10:19:26.560]                             name <- restart$name
[10:19:26.560]                             if (is.null(name)) 
[10:19:26.560]                               next
[10:19:26.560]                             if (!grepl(pattern, name)) 
[10:19:26.560]                               next
[10:19:26.560]                             invokeRestart(restart)
[10:19:26.560]                             muffled <- TRUE
[10:19:26.560]                             break
[10:19:26.560]                           }
[10:19:26.560]                         }
[10:19:26.560]                       }
[10:19:26.560]                       invisible(muffled)
[10:19:26.560]                     }
[10:19:26.560]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.560]                   }
[10:19:26.560]                 }
[10:19:26.560]                 else {
[10:19:26.560]                   if (TRUE) {
[10:19:26.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.560]                     {
[10:19:26.560]                       inherits <- base::inherits
[10:19:26.560]                       invokeRestart <- base::invokeRestart
[10:19:26.560]                       is.null <- base::is.null
[10:19:26.560]                       muffled <- FALSE
[10:19:26.560]                       if (inherits(cond, "message")) {
[10:19:26.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.560]                         if (muffled) 
[10:19:26.560]                           invokeRestart("muffleMessage")
[10:19:26.560]                       }
[10:19:26.560]                       else if (inherits(cond, "warning")) {
[10:19:26.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.560]                         if (muffled) 
[10:19:26.560]                           invokeRestart("muffleWarning")
[10:19:26.560]                       }
[10:19:26.560]                       else if (inherits(cond, "condition")) {
[10:19:26.560]                         if (!is.null(pattern)) {
[10:19:26.560]                           computeRestarts <- base::computeRestarts
[10:19:26.560]                           grepl <- base::grepl
[10:19:26.560]                           restarts <- computeRestarts(cond)
[10:19:26.560]                           for (restart in restarts) {
[10:19:26.560]                             name <- restart$name
[10:19:26.560]                             if (is.null(name)) 
[10:19:26.560]                               next
[10:19:26.560]                             if (!grepl(pattern, name)) 
[10:19:26.560]                               next
[10:19:26.560]                             invokeRestart(restart)
[10:19:26.560]                             muffled <- TRUE
[10:19:26.560]                             break
[10:19:26.560]                           }
[10:19:26.560]                         }
[10:19:26.560]                       }
[10:19:26.560]                       invisible(muffled)
[10:19:26.560]                     }
[10:19:26.560]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.560]                   }
[10:19:26.560]                 }
[10:19:26.560]             }
[10:19:26.560]         }))
[10:19:26.560]     }, error = function(ex) {
[10:19:26.560]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.560]                 ...future.rng), started = ...future.startTime, 
[10:19:26.560]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.560]             version = "1.8"), class = "FutureResult")
[10:19:26.560]     }, finally = {
[10:19:26.560]         if (!identical(...future.workdir, getwd())) 
[10:19:26.560]             setwd(...future.workdir)
[10:19:26.560]         {
[10:19:26.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.560]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.560]             }
[10:19:26.560]             base::options(...future.oldOptions)
[10:19:26.560]             if (.Platform$OS.type == "windows") {
[10:19:26.560]                 old_names <- names(...future.oldEnvVars)
[10:19:26.560]                 envs <- base::Sys.getenv()
[10:19:26.560]                 names <- names(envs)
[10:19:26.560]                 common <- intersect(names, old_names)
[10:19:26.560]                 added <- setdiff(names, old_names)
[10:19:26.560]                 removed <- setdiff(old_names, names)
[10:19:26.560]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.560]                   envs[common]]
[10:19:26.560]                 NAMES <- toupper(changed)
[10:19:26.560]                 args <- list()
[10:19:26.560]                 for (kk in seq_along(NAMES)) {
[10:19:26.560]                   name <- changed[[kk]]
[10:19:26.560]                   NAME <- NAMES[[kk]]
[10:19:26.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.560]                     next
[10:19:26.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.560]                 }
[10:19:26.560]                 NAMES <- toupper(added)
[10:19:26.560]                 for (kk in seq_along(NAMES)) {
[10:19:26.560]                   name <- added[[kk]]
[10:19:26.560]                   NAME <- NAMES[[kk]]
[10:19:26.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.560]                     next
[10:19:26.560]                   args[[name]] <- ""
[10:19:26.560]                 }
[10:19:26.560]                 NAMES <- toupper(removed)
[10:19:26.560]                 for (kk in seq_along(NAMES)) {
[10:19:26.560]                   name <- removed[[kk]]
[10:19:26.560]                   NAME <- NAMES[[kk]]
[10:19:26.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.560]                     next
[10:19:26.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.560]                 }
[10:19:26.560]                 if (length(args) > 0) 
[10:19:26.560]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.560]             }
[10:19:26.560]             else {
[10:19:26.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.560]             }
[10:19:26.560]             {
[10:19:26.560]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.560]                   0L) {
[10:19:26.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.560]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.560]                   base::options(opts)
[10:19:26.560]                 }
[10:19:26.560]                 {
[10:19:26.560]                   {
[10:19:26.560]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.560]                     NULL
[10:19:26.560]                   }
[10:19:26.560]                   options(future.plan = NULL)
[10:19:26.560]                   if (is.na(NA_character_)) 
[10:19:26.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.560]                     .init = FALSE)
[10:19:26.560]                 }
[10:19:26.560]             }
[10:19:26.560]         }
[10:19:26.560]     })
[10:19:26.560]     if (TRUE) {
[10:19:26.560]         base::sink(type = "output", split = FALSE)
[10:19:26.560]         if (TRUE) {
[10:19:26.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.560]         }
[10:19:26.560]         else {
[10:19:26.560]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.560]         }
[10:19:26.560]         base::close(...future.stdout)
[10:19:26.560]         ...future.stdout <- NULL
[10:19:26.560]     }
[10:19:26.560]     ...future.result$conditions <- ...future.conditions
[10:19:26.560]     ...future.result$finished <- base::Sys.time()
[10:19:26.560]     ...future.result
[10:19:26.560] }
[10:19:26.563] Exporting 5 global objects (1.05 KiB) to cluster node #2 ...
[10:19:26.563] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ...
[10:19:26.563] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ... DONE
[10:19:26.563] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ...
[10:19:26.564] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ... DONE
[10:19:26.564] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ...
[10:19:26.564] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ... DONE
[10:19:26.564] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:26.565] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.565] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:26.565] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.565] Exporting 5 global objects (1.05 KiB) to cluster node #2 ... DONE
[10:19:26.566] MultisessionFuture started
[10:19:26.566] - Launch lazy future ... done
[10:19:26.566] run() for ‘MultisessionFuture’ ... done
[10:19:26.566] Created future:
[10:19:26.566] MultisessionFuture:
[10:19:26.566] Label: ‘future_.mapply-2’
[10:19:26.566] Expression:
[10:19:26.566] {
[10:19:26.566]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.566]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.566]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.566]         on.exit(options(oopts), add = TRUE)
[10:19:26.566]     }
[10:19:26.566]     {
[10:19:26.566]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.566]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.566]         do.call(mapply, args = args)
[10:19:26.566]     }
[10:19:26.566] }
[10:19:26.566] Lazy evaluation: FALSE
[10:19:26.566] Asynchronous evaluation: TRUE
[10:19:26.566] Local evaluation: TRUE
[10:19:26.566] Environment: R_GlobalEnv
[10:19:26.566] Capture standard output: TRUE
[10:19:26.566] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.566] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.566] Packages: <none>
[10:19:26.566] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.566] Resolved: FALSE
[10:19:26.566] Value: <not collected>
[10:19:26.566] Conditions captured: <none>
[10:19:26.566] Early signaling: FALSE
[10:19:26.566] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.566] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.577] Chunk #2 of 2 ... DONE
[10:19:26.577] Launching 2 futures (chunks) ... DONE
[10:19:26.578] Resolving 2 futures (chunks) ...
[10:19:26.578] resolve() on list ...
[10:19:26.578]  recursive: 0
[10:19:26.578]  length: 2
[10:19:26.578] 
[10:19:26.578] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.578] - Validating connection of MultisessionFuture
[10:19:26.579] - received message: FutureResult
[10:19:26.579] - Received FutureResult
[10:19:26.579] - Erased future from FutureRegistry
[10:19:26.579] result() for ClusterFuture ...
[10:19:26.579] - result already collected: FutureResult
[10:19:26.579] result() for ClusterFuture ... done
[10:19:26.579] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.579] Future #1
[10:19:26.579] result() for ClusterFuture ...
[10:19:26.579] - result already collected: FutureResult
[10:19:26.580] result() for ClusterFuture ... done
[10:19:26.580] result() for ClusterFuture ...
[10:19:26.580] - result already collected: FutureResult
[10:19:26.580] result() for ClusterFuture ... done
[10:19:26.580] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:26.580] - nx: 2
[10:19:26.580] - relay: TRUE
[10:19:26.580] - stdout: TRUE
[10:19:26.580] - signal: TRUE
[10:19:26.580] - resignal: FALSE
[10:19:26.580] - force: TRUE
[10:19:26.580] - relayed: [n=2] FALSE, FALSE
[10:19:26.580] - queued futures: [n=2] FALSE, FALSE
[10:19:26.581]  - until=1
[10:19:26.581]  - relaying element #1
[10:19:26.581] result() for ClusterFuture ...
[10:19:26.581] - result already collected: FutureResult
[10:19:26.581] result() for ClusterFuture ... done
[10:19:26.581] result() for ClusterFuture ...
[10:19:26.581] - result already collected: FutureResult
[10:19:26.581] result() for ClusterFuture ... done
[10:19:26.581] result() for ClusterFuture ...
[10:19:26.581] - result already collected: FutureResult
[10:19:26.581] result() for ClusterFuture ... done
[10:19:26.582] result() for ClusterFuture ...
[10:19:26.582] - result already collected: FutureResult
[10:19:26.582] result() for ClusterFuture ... done
[10:19:26.582] - relayed: [n=2] TRUE, FALSE
[10:19:26.582] - queued futures: [n=2] TRUE, FALSE
[10:19:26.582] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:26.582]  length: 1 (resolved future 1)
[10:19:26.608] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.608] - Validating connection of MultisessionFuture
[10:19:26.608] - received message: FutureResult
[10:19:26.608] - Received FutureResult
[10:19:26.609] - Erased future from FutureRegistry
[10:19:26.609] result() for ClusterFuture ...
[10:19:26.609] - result already collected: FutureResult
[10:19:26.609] result() for ClusterFuture ... done
[10:19:26.609] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.609] Future #2
[10:19:26.609] result() for ClusterFuture ...
[10:19:26.609] - result already collected: FutureResult
[10:19:26.609] result() for ClusterFuture ... done
[10:19:26.609] result() for ClusterFuture ...
[10:19:26.609] - result already collected: FutureResult
[10:19:26.609] result() for ClusterFuture ... done
[10:19:26.610] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:26.610] - nx: 2
[10:19:26.610] - relay: TRUE
[10:19:26.610] - stdout: TRUE
[10:19:26.610] - signal: TRUE
[10:19:26.610] - resignal: FALSE
[10:19:26.610] - force: TRUE
[10:19:26.610] - relayed: [n=2] TRUE, FALSE
[10:19:26.610] - queued futures: [n=2] TRUE, FALSE
[10:19:26.610]  - until=2
[10:19:26.610]  - relaying element #2
[10:19:26.611] result() for ClusterFuture ...
[10:19:26.611] - result already collected: FutureResult
[10:19:26.611] result() for ClusterFuture ... done
[10:19:26.611] result() for ClusterFuture ...
[10:19:26.611] - result already collected: FutureResult
[10:19:26.611] result() for ClusterFuture ... done
[10:19:26.611] result() for ClusterFuture ...
[10:19:26.611] - result already collected: FutureResult
[10:19:26.611] result() for ClusterFuture ... done
[10:19:26.611] result() for ClusterFuture ...
[10:19:26.611] - result already collected: FutureResult
[10:19:26.611] result() for ClusterFuture ... done
[10:19:26.612] - relayed: [n=2] TRUE, TRUE
[10:19:26.612] - queued futures: [n=2] TRUE, TRUE
[10:19:26.612] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:26.612]  length: 0 (resolved future 2)
[10:19:26.612] Relaying remaining futures
[10:19:26.612] signalConditionsASAP(NULL, pos=0) ...
[10:19:26.612] - nx: 2
[10:19:26.612] - relay: TRUE
[10:19:26.612] - stdout: TRUE
[10:19:26.612] - signal: TRUE
[10:19:26.612] - resignal: FALSE
[10:19:26.612] - force: TRUE
[10:19:26.612] - relayed: [n=2] TRUE, TRUE
[10:19:26.613] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:26.613] - relayed: [n=2] TRUE, TRUE
[10:19:26.613] - queued futures: [n=2] TRUE, TRUE
[10:19:26.613] signalConditionsASAP(NULL, pos=0) ... done
[10:19:26.613] resolve() on list ... DONE
[10:19:26.613] result() for ClusterFuture ...
[10:19:26.613] - result already collected: FutureResult
[10:19:26.613] result() for ClusterFuture ... done
[10:19:26.613] result() for ClusterFuture ...
[10:19:26.613] - result already collected: FutureResult
[10:19:26.613] result() for ClusterFuture ... done
[10:19:26.614] result() for ClusterFuture ...
[10:19:26.614] - result already collected: FutureResult
[10:19:26.614] result() for ClusterFuture ... done
[10:19:26.614] result() for ClusterFuture ...
[10:19:26.614] - result already collected: FutureResult
[10:19:26.614] result() for ClusterFuture ... done
[10:19:26.614]  - Number of value chunks collected: 2
[10:19:26.614] Resolving 2 futures (chunks) ... DONE
[10:19:26.614] Reducing values from 2 chunks ...
[10:19:26.614]  - Number of values collected after concatenation: 2
[10:19:26.614]  - Number of values expected: 2
[10:19:26.614] Reducing values from 2 chunks ... DONE
[10:19:26.615] future_mapply() ... DONE
- Recycle arguments to same length ...
[10:19:26.615] future_mapply() ...
[10:19:26.616] Number of chunks: 2
[10:19:26.616] getGlobalsAndPackagesXApply() ...
[10:19:26.617]  - future.globals: TRUE
[10:19:26.617] getGlobalsAndPackages() ...
[10:19:26.617] Searching for globals...
[10:19:26.617] - globals found: [1] ‘FUN’
[10:19:26.618] Searching for globals ... DONE
[10:19:26.618] Resolving globals: FALSE
[10:19:26.618] The total size of the 1 globals is 34 bytes (34 bytes)
[10:19:26.618] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[10:19:26.618] - globals: [1] ‘FUN’
[10:19:26.618] 
[10:19:26.619] getGlobalsAndPackages() ... DONE
[10:19:26.619]  - globals found/used: [n=1] ‘FUN’
[10:19:26.619]  - needed namespaces: [n=0] 
[10:19:26.619] Finding globals ... DONE
[10:19:26.619] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:26.619] List of 2
[10:19:26.619]  $ ...future.FUN:function (x, ...)  
[10:19:26.619]  $ MoreArgs     : NULL
[10:19:26.619]  - attr(*, "where")=List of 2
[10:19:26.619]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:26.619]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:26.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:26.619]  - attr(*, "resolved")= logi FALSE
[10:19:26.619]  - attr(*, "total_size")= num NA
[10:19:26.622] Packages to be attached in all futures: [n=0] 
[10:19:26.622] getGlobalsAndPackagesXApply() ... DONE
[10:19:26.622] Number of futures (= number of chunks): 2
[10:19:26.622] Launching 2 futures (chunks) ...
[10:19:26.622] Chunk #1 of 2 ...
[10:19:26.622]  - Finding globals in '...' for chunk #1 ...
[10:19:26.622] getGlobalsAndPackages() ...
[10:19:26.622] Searching for globals...
[10:19:26.623] 
[10:19:26.623] Searching for globals ... DONE
[10:19:26.623] - globals: [0] <none>
[10:19:26.623] getGlobalsAndPackages() ... DONE
[10:19:26.623]    + additional globals found: [n=0] 
[10:19:26.623]    + additional namespaces needed: [n=0] 
[10:19:26.623]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:26.623]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.623]  - seeds: <none>
[10:19:26.626]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.626] getGlobalsAndPackages() ...
[10:19:26.626] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.626] Resolving globals: FALSE
[10:19:26.627] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:26.627] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:26.627] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.627] 
[10:19:26.627] getGlobalsAndPackages() ... DONE
[10:19:26.628] run() for ‘Future’ ...
[10:19:26.628] - state: ‘created’
[10:19:26.628] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.642] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.642]   - Field: ‘node’
[10:19:26.642]   - Field: ‘label’
[10:19:26.642]   - Field: ‘local’
[10:19:26.642]   - Field: ‘owner’
[10:19:26.642]   - Field: ‘envir’
[10:19:26.642]   - Field: ‘workers’
[10:19:26.642]   - Field: ‘packages’
[10:19:26.643]   - Field: ‘gc’
[10:19:26.643]   - Field: ‘conditions’
[10:19:26.643]   - Field: ‘persistent’
[10:19:26.643]   - Field: ‘expr’
[10:19:26.643]   - Field: ‘uuid’
[10:19:26.643]   - Field: ‘seed’
[10:19:26.643]   - Field: ‘version’
[10:19:26.643]   - Field: ‘result’
[10:19:26.643]   - Field: ‘asynchronous’
[10:19:26.643]   - Field: ‘calls’
[10:19:26.643]   - Field: ‘globals’
[10:19:26.643]   - Field: ‘stdout’
[10:19:26.644]   - Field: ‘earlySignal’
[10:19:26.644]   - Field: ‘lazy’
[10:19:26.644]   - Field: ‘state’
[10:19:26.644] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.644] - Launch lazy future ...
[10:19:26.644] Packages needed by the future expression (n = 0): <none>
[10:19:26.644] Packages needed by future strategies (n = 0): <none>
[10:19:26.645] {
[10:19:26.645]     {
[10:19:26.645]         {
[10:19:26.645]             ...future.startTime <- base::Sys.time()
[10:19:26.645]             {
[10:19:26.645]                 {
[10:19:26.645]                   {
[10:19:26.645]                     {
[10:19:26.645]                       base::local({
[10:19:26.645]                         has_future <- base::requireNamespace("future", 
[10:19:26.645]                           quietly = TRUE)
[10:19:26.645]                         if (has_future) {
[10:19:26.645]                           ns <- base::getNamespace("future")
[10:19:26.645]                           version <- ns[[".package"]][["version"]]
[10:19:26.645]                           if (is.null(version)) 
[10:19:26.645]                             version <- utils::packageVersion("future")
[10:19:26.645]                         }
[10:19:26.645]                         else {
[10:19:26.645]                           version <- NULL
[10:19:26.645]                         }
[10:19:26.645]                         if (!has_future || version < "1.8.0") {
[10:19:26.645]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.645]                             "", base::R.version$version.string), 
[10:19:26.645]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.645]                               "release", "version")], collapse = " "), 
[10:19:26.645]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.645]                             info)
[10:19:26.645]                           info <- base::paste(info, collapse = "; ")
[10:19:26.645]                           if (!has_future) {
[10:19:26.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.645]                               info)
[10:19:26.645]                           }
[10:19:26.645]                           else {
[10:19:26.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.645]                               info, version)
[10:19:26.645]                           }
[10:19:26.645]                           base::stop(msg)
[10:19:26.645]                         }
[10:19:26.645]                       })
[10:19:26.645]                     }
[10:19:26.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.645]                     base::options(mc.cores = 1L)
[10:19:26.645]                   }
[10:19:26.645]                   ...future.strategy.old <- future::plan("list")
[10:19:26.645]                   options(future.plan = NULL)
[10:19:26.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.645]                 }
[10:19:26.645]                 ...future.workdir <- getwd()
[10:19:26.645]             }
[10:19:26.645]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.645]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.645]         }
[10:19:26.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.645]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.645]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.645]             base::names(...future.oldOptions))
[10:19:26.645]     }
[10:19:26.645]     if (FALSE) {
[10:19:26.645]     }
[10:19:26.645]     else {
[10:19:26.645]         if (TRUE) {
[10:19:26.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.645]                 open = "w")
[10:19:26.645]         }
[10:19:26.645]         else {
[10:19:26.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.645]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.645]         }
[10:19:26.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.645]             base::sink(type = "output", split = FALSE)
[10:19:26.645]             base::close(...future.stdout)
[10:19:26.645]         }, add = TRUE)
[10:19:26.645]     }
[10:19:26.645]     ...future.frame <- base::sys.nframe()
[10:19:26.645]     ...future.conditions <- base::list()
[10:19:26.645]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.645]     if (FALSE) {
[10:19:26.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.645]     }
[10:19:26.645]     ...future.result <- base::tryCatch({
[10:19:26.645]         base::withCallingHandlers({
[10:19:26.645]             ...future.value <- base::withVisible(base::local({
[10:19:26.645]                 ...future.makeSendCondition <- base::local({
[10:19:26.645]                   sendCondition <- NULL
[10:19:26.645]                   function(frame = 1L) {
[10:19:26.645]                     if (is.function(sendCondition)) 
[10:19:26.645]                       return(sendCondition)
[10:19:26.645]                     ns <- getNamespace("parallel")
[10:19:26.645]                     if (exists("sendData", mode = "function", 
[10:19:26.645]                       envir = ns)) {
[10:19:26.645]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.645]                         envir = ns)
[10:19:26.645]                       envir <- sys.frame(frame)
[10:19:26.645]                       master <- NULL
[10:19:26.645]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.645]                         !identical(envir, emptyenv())) {
[10:19:26.645]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.645]                           inherits = FALSE)) {
[10:19:26.645]                           master <- get("master", mode = "list", 
[10:19:26.645]                             envir = envir, inherits = FALSE)
[10:19:26.645]                           if (inherits(master, c("SOCKnode", 
[10:19:26.645]                             "SOCK0node"))) {
[10:19:26.645]                             sendCondition <<- function(cond) {
[10:19:26.645]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.645]                                 success = TRUE)
[10:19:26.645]                               parallel_sendData(master, data)
[10:19:26.645]                             }
[10:19:26.645]                             return(sendCondition)
[10:19:26.645]                           }
[10:19:26.645]                         }
[10:19:26.645]                         frame <- frame + 1L
[10:19:26.645]                         envir <- sys.frame(frame)
[10:19:26.645]                       }
[10:19:26.645]                     }
[10:19:26.645]                     sendCondition <<- function(cond) NULL
[10:19:26.645]                   }
[10:19:26.645]                 })
[10:19:26.645]                 withCallingHandlers({
[10:19:26.645]                   {
[10:19:26.645]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.645]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.645]                       ...future.globals.maxSize)) {
[10:19:26.645]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.645]                       on.exit(options(oopts), add = TRUE)
[10:19:26.645]                     }
[10:19:26.645]                     {
[10:19:26.645]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.645]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.645]                         USE.NAMES = FALSE)
[10:19:26.645]                       do.call(mapply, args = args)
[10:19:26.645]                     }
[10:19:26.645]                   }
[10:19:26.645]                 }, immediateCondition = function(cond) {
[10:19:26.645]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.645]                   sendCondition(cond)
[10:19:26.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.645]                   {
[10:19:26.645]                     inherits <- base::inherits
[10:19:26.645]                     invokeRestart <- base::invokeRestart
[10:19:26.645]                     is.null <- base::is.null
[10:19:26.645]                     muffled <- FALSE
[10:19:26.645]                     if (inherits(cond, "message")) {
[10:19:26.645]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.645]                       if (muffled) 
[10:19:26.645]                         invokeRestart("muffleMessage")
[10:19:26.645]                     }
[10:19:26.645]                     else if (inherits(cond, "warning")) {
[10:19:26.645]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.645]                       if (muffled) 
[10:19:26.645]                         invokeRestart("muffleWarning")
[10:19:26.645]                     }
[10:19:26.645]                     else if (inherits(cond, "condition")) {
[10:19:26.645]                       if (!is.null(pattern)) {
[10:19:26.645]                         computeRestarts <- base::computeRestarts
[10:19:26.645]                         grepl <- base::grepl
[10:19:26.645]                         restarts <- computeRestarts(cond)
[10:19:26.645]                         for (restart in restarts) {
[10:19:26.645]                           name <- restart$name
[10:19:26.645]                           if (is.null(name)) 
[10:19:26.645]                             next
[10:19:26.645]                           if (!grepl(pattern, name)) 
[10:19:26.645]                             next
[10:19:26.645]                           invokeRestart(restart)
[10:19:26.645]                           muffled <- TRUE
[10:19:26.645]                           break
[10:19:26.645]                         }
[10:19:26.645]                       }
[10:19:26.645]                     }
[10:19:26.645]                     invisible(muffled)
[10:19:26.645]                   }
[10:19:26.645]                   muffleCondition(cond)
[10:19:26.645]                 })
[10:19:26.645]             }))
[10:19:26.645]             future::FutureResult(value = ...future.value$value, 
[10:19:26.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.645]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.645]                     ...future.globalenv.names))
[10:19:26.645]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.645]         }, condition = base::local({
[10:19:26.645]             c <- base::c
[10:19:26.645]             inherits <- base::inherits
[10:19:26.645]             invokeRestart <- base::invokeRestart
[10:19:26.645]             length <- base::length
[10:19:26.645]             list <- base::list
[10:19:26.645]             seq.int <- base::seq.int
[10:19:26.645]             signalCondition <- base::signalCondition
[10:19:26.645]             sys.calls <- base::sys.calls
[10:19:26.645]             `[[` <- base::`[[`
[10:19:26.645]             `+` <- base::`+`
[10:19:26.645]             `<<-` <- base::`<<-`
[10:19:26.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.645]                   3L)]
[10:19:26.645]             }
[10:19:26.645]             function(cond) {
[10:19:26.645]                 is_error <- inherits(cond, "error")
[10:19:26.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.645]                   NULL)
[10:19:26.645]                 if (is_error) {
[10:19:26.645]                   sessionInformation <- function() {
[10:19:26.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.645]                       search = base::search(), system = base::Sys.info())
[10:19:26.645]                   }
[10:19:26.645]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.645]                     cond$call), session = sessionInformation(), 
[10:19:26.645]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.645]                   signalCondition(cond)
[10:19:26.645]                 }
[10:19:26.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.645]                 "immediateCondition"))) {
[10:19:26.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.645]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.645]                   if (TRUE && !signal) {
[10:19:26.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.645]                     {
[10:19:26.645]                       inherits <- base::inherits
[10:19:26.645]                       invokeRestart <- base::invokeRestart
[10:19:26.645]                       is.null <- base::is.null
[10:19:26.645]                       muffled <- FALSE
[10:19:26.645]                       if (inherits(cond, "message")) {
[10:19:26.645]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.645]                         if (muffled) 
[10:19:26.645]                           invokeRestart("muffleMessage")
[10:19:26.645]                       }
[10:19:26.645]                       else if (inherits(cond, "warning")) {
[10:19:26.645]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.645]                         if (muffled) 
[10:19:26.645]                           invokeRestart("muffleWarning")
[10:19:26.645]                       }
[10:19:26.645]                       else if (inherits(cond, "condition")) {
[10:19:26.645]                         if (!is.null(pattern)) {
[10:19:26.645]                           computeRestarts <- base::computeRestarts
[10:19:26.645]                           grepl <- base::grepl
[10:19:26.645]                           restarts <- computeRestarts(cond)
[10:19:26.645]                           for (restart in restarts) {
[10:19:26.645]                             name <- restart$name
[10:19:26.645]                             if (is.null(name)) 
[10:19:26.645]                               next
[10:19:26.645]                             if (!grepl(pattern, name)) 
[10:19:26.645]                               next
[10:19:26.645]                             invokeRestart(restart)
[10:19:26.645]                             muffled <- TRUE
[10:19:26.645]                             break
[10:19:26.645]                           }
[10:19:26.645]                         }
[10:19:26.645]                       }
[10:19:26.645]                       invisible(muffled)
[10:19:26.645]                     }
[10:19:26.645]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.645]                   }
[10:19:26.645]                 }
[10:19:26.645]                 else {
[10:19:26.645]                   if (TRUE) {
[10:19:26.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.645]                     {
[10:19:26.645]                       inherits <- base::inherits
[10:19:26.645]                       invokeRestart <- base::invokeRestart
[10:19:26.645]                       is.null <- base::is.null
[10:19:26.645]                       muffled <- FALSE
[10:19:26.645]                       if (inherits(cond, "message")) {
[10:19:26.645]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.645]                         if (muffled) 
[10:19:26.645]                           invokeRestart("muffleMessage")
[10:19:26.645]                       }
[10:19:26.645]                       else if (inherits(cond, "warning")) {
[10:19:26.645]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.645]                         if (muffled) 
[10:19:26.645]                           invokeRestart("muffleWarning")
[10:19:26.645]                       }
[10:19:26.645]                       else if (inherits(cond, "condition")) {
[10:19:26.645]                         if (!is.null(pattern)) {
[10:19:26.645]                           computeRestarts <- base::computeRestarts
[10:19:26.645]                           grepl <- base::grepl
[10:19:26.645]                           restarts <- computeRestarts(cond)
[10:19:26.645]                           for (restart in restarts) {
[10:19:26.645]                             name <- restart$name
[10:19:26.645]                             if (is.null(name)) 
[10:19:26.645]                               next
[10:19:26.645]                             if (!grepl(pattern, name)) 
[10:19:26.645]                               next
[10:19:26.645]                             invokeRestart(restart)
[10:19:26.645]                             muffled <- TRUE
[10:19:26.645]                             break
[10:19:26.645]                           }
[10:19:26.645]                         }
[10:19:26.645]                       }
[10:19:26.645]                       invisible(muffled)
[10:19:26.645]                     }
[10:19:26.645]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.645]                   }
[10:19:26.645]                 }
[10:19:26.645]             }
[10:19:26.645]         }))
[10:19:26.645]     }, error = function(ex) {
[10:19:26.645]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.645]                 ...future.rng), started = ...future.startTime, 
[10:19:26.645]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.645]             version = "1.8"), class = "FutureResult")
[10:19:26.645]     }, finally = {
[10:19:26.645]         if (!identical(...future.workdir, getwd())) 
[10:19:26.645]             setwd(...future.workdir)
[10:19:26.645]         {
[10:19:26.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.645]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.645]             }
[10:19:26.645]             base::options(...future.oldOptions)
[10:19:26.645]             if (.Platform$OS.type == "windows") {
[10:19:26.645]                 old_names <- names(...future.oldEnvVars)
[10:19:26.645]                 envs <- base::Sys.getenv()
[10:19:26.645]                 names <- names(envs)
[10:19:26.645]                 common <- intersect(names, old_names)
[10:19:26.645]                 added <- setdiff(names, old_names)
[10:19:26.645]                 removed <- setdiff(old_names, names)
[10:19:26.645]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.645]                   envs[common]]
[10:19:26.645]                 NAMES <- toupper(changed)
[10:19:26.645]                 args <- list()
[10:19:26.645]                 for (kk in seq_along(NAMES)) {
[10:19:26.645]                   name <- changed[[kk]]
[10:19:26.645]                   NAME <- NAMES[[kk]]
[10:19:26.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.645]                     next
[10:19:26.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.645]                 }
[10:19:26.645]                 NAMES <- toupper(added)
[10:19:26.645]                 for (kk in seq_along(NAMES)) {
[10:19:26.645]                   name <- added[[kk]]
[10:19:26.645]                   NAME <- NAMES[[kk]]
[10:19:26.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.645]                     next
[10:19:26.645]                   args[[name]] <- ""
[10:19:26.645]                 }
[10:19:26.645]                 NAMES <- toupper(removed)
[10:19:26.645]                 for (kk in seq_along(NAMES)) {
[10:19:26.645]                   name <- removed[[kk]]
[10:19:26.645]                   NAME <- NAMES[[kk]]
[10:19:26.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.645]                     next
[10:19:26.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.645]                 }
[10:19:26.645]                 if (length(args) > 0) 
[10:19:26.645]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.645]             }
[10:19:26.645]             else {
[10:19:26.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.645]             }
[10:19:26.645]             {
[10:19:26.645]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.645]                   0L) {
[10:19:26.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.645]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.645]                   base::options(opts)
[10:19:26.645]                 }
[10:19:26.645]                 {
[10:19:26.645]                   {
[10:19:26.645]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.645]                     NULL
[10:19:26.645]                   }
[10:19:26.645]                   options(future.plan = NULL)
[10:19:26.645]                   if (is.na(NA_character_)) 
[10:19:26.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.645]                     .init = FALSE)
[10:19:26.645]                 }
[10:19:26.645]             }
[10:19:26.645]         }
[10:19:26.645]     })
[10:19:26.645]     if (TRUE) {
[10:19:26.645]         base::sink(type = "output", split = FALSE)
[10:19:26.645]         if (TRUE) {
[10:19:26.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.645]         }
[10:19:26.645]         else {
[10:19:26.645]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.645]         }
[10:19:26.645]         base::close(...future.stdout)
[10:19:26.645]         ...future.stdout <- NULL
[10:19:26.645]     }
[10:19:26.645]     ...future.result$conditions <- ...future.conditions
[10:19:26.645]     ...future.result$finished <- base::Sys.time()
[10:19:26.645]     ...future.result
[10:19:26.645] }
[10:19:26.648] Exporting 5 global objects (673 bytes) to cluster node #1 ...
[10:19:26.648] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[10:19:26.648] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[10:19:26.648] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:26.649] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.649] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ...
[10:19:26.649] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ... DONE
[10:19:26.649] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:26.650] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.650] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:26.650] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.650] Exporting 5 global objects (673 bytes) to cluster node #1 ... DONE
[10:19:26.651] MultisessionFuture started
[10:19:26.651] - Launch lazy future ... done
[10:19:26.651] run() for ‘MultisessionFuture’ ... done
[10:19:26.651] Created future:
[10:19:26.651] MultisessionFuture:
[10:19:26.651] Label: ‘future_mapply-1’
[10:19:26.651] Expression:
[10:19:26.651] {
[10:19:26.651]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.651]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.651]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.651]         on.exit(options(oopts), add = TRUE)
[10:19:26.651]     }
[10:19:26.651]     {
[10:19:26.651]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.651]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.651]         do.call(mapply, args = args)
[10:19:26.651]     }
[10:19:26.651] }
[10:19:26.651] Lazy evaluation: FALSE
[10:19:26.651] Asynchronous evaluation: TRUE
[10:19:26.651] Local evaluation: TRUE
[10:19:26.651] Environment: R_GlobalEnv
[10:19:26.651] Capture standard output: TRUE
[10:19:26.651] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.651] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.651] Packages: <none>
[10:19:26.651] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.651] Resolved: FALSE
[10:19:26.651] Value: <not collected>
[10:19:26.651] Conditions captured: <none>
[10:19:26.651] Early signaling: FALSE
[10:19:26.651] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.651] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.662] Chunk #1 of 2 ... DONE
[10:19:26.662] Chunk #2 of 2 ...
[10:19:26.662]  - Finding globals in '...' for chunk #2 ...
[10:19:26.663] getGlobalsAndPackages() ...
[10:19:26.663] Searching for globals...
[10:19:26.663] 
[10:19:26.663] Searching for globals ... DONE
[10:19:26.663] - globals: [0] <none>
[10:19:26.663] getGlobalsAndPackages() ... DONE
[10:19:26.663]    + additional globals found: [n=0] 
[10:19:26.663]    + additional namespaces needed: [n=0] 
[10:19:26.664]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:26.664]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.664]  - seeds: <none>
[10:19:26.664]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.664] getGlobalsAndPackages() ...
[10:19:26.664] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.664] Resolving globals: FALSE
[10:19:26.664] The total size of the 5 globals is 210 bytes (210 bytes)
[10:19:26.665] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:26.665] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.665] 
[10:19:26.665] getGlobalsAndPackages() ... DONE
[10:19:26.666] run() for ‘Future’ ...
[10:19:26.666] - state: ‘created’
[10:19:26.666] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.680] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.680]   - Field: ‘node’
[10:19:26.680]   - Field: ‘label’
[10:19:26.680]   - Field: ‘local’
[10:19:26.680]   - Field: ‘owner’
[10:19:26.680]   - Field: ‘envir’
[10:19:26.680]   - Field: ‘workers’
[10:19:26.681]   - Field: ‘packages’
[10:19:26.681]   - Field: ‘gc’
[10:19:26.681]   - Field: ‘conditions’
[10:19:26.681]   - Field: ‘persistent’
[10:19:26.681]   - Field: ‘expr’
[10:19:26.681]   - Field: ‘uuid’
[10:19:26.681]   - Field: ‘seed’
[10:19:26.681]   - Field: ‘version’
[10:19:26.681]   - Field: ‘result’
[10:19:26.681]   - Field: ‘asynchronous’
[10:19:26.681]   - Field: ‘calls’
[10:19:26.682]   - Field: ‘globals’
[10:19:26.682]   - Field: ‘stdout’
[10:19:26.682]   - Field: ‘earlySignal’
[10:19:26.682]   - Field: ‘lazy’
[10:19:26.682]   - Field: ‘state’
[10:19:26.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.682] - Launch lazy future ...
[10:19:26.682] Packages needed by the future expression (n = 0): <none>
[10:19:26.682] Packages needed by future strategies (n = 0): <none>
[10:19:26.683] {
[10:19:26.683]     {
[10:19:26.683]         {
[10:19:26.683]             ...future.startTime <- base::Sys.time()
[10:19:26.683]             {
[10:19:26.683]                 {
[10:19:26.683]                   {
[10:19:26.683]                     {
[10:19:26.683]                       base::local({
[10:19:26.683]                         has_future <- base::requireNamespace("future", 
[10:19:26.683]                           quietly = TRUE)
[10:19:26.683]                         if (has_future) {
[10:19:26.683]                           ns <- base::getNamespace("future")
[10:19:26.683]                           version <- ns[[".package"]][["version"]]
[10:19:26.683]                           if (is.null(version)) 
[10:19:26.683]                             version <- utils::packageVersion("future")
[10:19:26.683]                         }
[10:19:26.683]                         else {
[10:19:26.683]                           version <- NULL
[10:19:26.683]                         }
[10:19:26.683]                         if (!has_future || version < "1.8.0") {
[10:19:26.683]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.683]                             "", base::R.version$version.string), 
[10:19:26.683]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:26.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:26.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.683]                               "release", "version")], collapse = " "), 
[10:19:26.683]                             hostname = base::Sys.info()[["nodename"]])
[10:19:26.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.683]                             info)
[10:19:26.683]                           info <- base::paste(info, collapse = "; ")
[10:19:26.683]                           if (!has_future) {
[10:19:26.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.683]                               info)
[10:19:26.683]                           }
[10:19:26.683]                           else {
[10:19:26.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.683]                               info, version)
[10:19:26.683]                           }
[10:19:26.683]                           base::stop(msg)
[10:19:26.683]                         }
[10:19:26.683]                       })
[10:19:26.683]                     }
[10:19:26.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.683]                     base::options(mc.cores = 1L)
[10:19:26.683]                   }
[10:19:26.683]                   ...future.strategy.old <- future::plan("list")
[10:19:26.683]                   options(future.plan = NULL)
[10:19:26.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.683]                 }
[10:19:26.683]                 ...future.workdir <- getwd()
[10:19:26.683]             }
[10:19:26.683]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.683]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.683]         }
[10:19:26.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.683]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.683]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.683]             base::names(...future.oldOptions))
[10:19:26.683]     }
[10:19:26.683]     if (FALSE) {
[10:19:26.683]     }
[10:19:26.683]     else {
[10:19:26.683]         if (TRUE) {
[10:19:26.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.683]                 open = "w")
[10:19:26.683]         }
[10:19:26.683]         else {
[10:19:26.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.683]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.683]         }
[10:19:26.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.683]             base::sink(type = "output", split = FALSE)
[10:19:26.683]             base::close(...future.stdout)
[10:19:26.683]         }, add = TRUE)
[10:19:26.683]     }
[10:19:26.683]     ...future.frame <- base::sys.nframe()
[10:19:26.683]     ...future.conditions <- base::list()
[10:19:26.683]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.683]     if (FALSE) {
[10:19:26.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.683]     }
[10:19:26.683]     ...future.result <- base::tryCatch({
[10:19:26.683]         base::withCallingHandlers({
[10:19:26.683]             ...future.value <- base::withVisible(base::local({
[10:19:26.683]                 ...future.makeSendCondition <- base::local({
[10:19:26.683]                   sendCondition <- NULL
[10:19:26.683]                   function(frame = 1L) {
[10:19:26.683]                     if (is.function(sendCondition)) 
[10:19:26.683]                       return(sendCondition)
[10:19:26.683]                     ns <- getNamespace("parallel")
[10:19:26.683]                     if (exists("sendData", mode = "function", 
[10:19:26.683]                       envir = ns)) {
[10:19:26.683]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.683]                         envir = ns)
[10:19:26.683]                       envir <- sys.frame(frame)
[10:19:26.683]                       master <- NULL
[10:19:26.683]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.683]                         !identical(envir, emptyenv())) {
[10:19:26.683]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.683]                           inherits = FALSE)) {
[10:19:26.683]                           master <- get("master", mode = "list", 
[10:19:26.683]                             envir = envir, inherits = FALSE)
[10:19:26.683]                           if (inherits(master, c("SOCKnode", 
[10:19:26.683]                             "SOCK0node"))) {
[10:19:26.683]                             sendCondition <<- function(cond) {
[10:19:26.683]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.683]                                 success = TRUE)
[10:19:26.683]                               parallel_sendData(master, data)
[10:19:26.683]                             }
[10:19:26.683]                             return(sendCondition)
[10:19:26.683]                           }
[10:19:26.683]                         }
[10:19:26.683]                         frame <- frame + 1L
[10:19:26.683]                         envir <- sys.frame(frame)
[10:19:26.683]                       }
[10:19:26.683]                     }
[10:19:26.683]                     sendCondition <<- function(cond) NULL
[10:19:26.683]                   }
[10:19:26.683]                 })
[10:19:26.683]                 withCallingHandlers({
[10:19:26.683]                   {
[10:19:26.683]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.683]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.683]                       ...future.globals.maxSize)) {
[10:19:26.683]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.683]                       on.exit(options(oopts), add = TRUE)
[10:19:26.683]                     }
[10:19:26.683]                     {
[10:19:26.683]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.683]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.683]                         USE.NAMES = FALSE)
[10:19:26.683]                       do.call(mapply, args = args)
[10:19:26.683]                     }
[10:19:26.683]                   }
[10:19:26.683]                 }, immediateCondition = function(cond) {
[10:19:26.683]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.683]                   sendCondition(cond)
[10:19:26.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.683]                   {
[10:19:26.683]                     inherits <- base::inherits
[10:19:26.683]                     invokeRestart <- base::invokeRestart
[10:19:26.683]                     is.null <- base::is.null
[10:19:26.683]                     muffled <- FALSE
[10:19:26.683]                     if (inherits(cond, "message")) {
[10:19:26.683]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.683]                       if (muffled) 
[10:19:26.683]                         invokeRestart("muffleMessage")
[10:19:26.683]                     }
[10:19:26.683]                     else if (inherits(cond, "warning")) {
[10:19:26.683]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.683]                       if (muffled) 
[10:19:26.683]                         invokeRestart("muffleWarning")
[10:19:26.683]                     }
[10:19:26.683]                     else if (inherits(cond, "condition")) {
[10:19:26.683]                       if (!is.null(pattern)) {
[10:19:26.683]                         computeRestarts <- base::computeRestarts
[10:19:26.683]                         grepl <- base::grepl
[10:19:26.683]                         restarts <- computeRestarts(cond)
[10:19:26.683]                         for (restart in restarts) {
[10:19:26.683]                           name <- restart$name
[10:19:26.683]                           if (is.null(name)) 
[10:19:26.683]                             next
[10:19:26.683]                           if (!grepl(pattern, name)) 
[10:19:26.683]                             next
[10:19:26.683]                           invokeRestart(restart)
[10:19:26.683]                           muffled <- TRUE
[10:19:26.683]                           break
[10:19:26.683]                         }
[10:19:26.683]                       }
[10:19:26.683]                     }
[10:19:26.683]                     invisible(muffled)
[10:19:26.683]                   }
[10:19:26.683]                   muffleCondition(cond)
[10:19:26.683]                 })
[10:19:26.683]             }))
[10:19:26.683]             future::FutureResult(value = ...future.value$value, 
[10:19:26.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.683]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.683]                     ...future.globalenv.names))
[10:19:26.683]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.683]         }, condition = base::local({
[10:19:26.683]             c <- base::c
[10:19:26.683]             inherits <- base::inherits
[10:19:26.683]             invokeRestart <- base::invokeRestart
[10:19:26.683]             length <- base::length
[10:19:26.683]             list <- base::list
[10:19:26.683]             seq.int <- base::seq.int
[10:19:26.683]             signalCondition <- base::signalCondition
[10:19:26.683]             sys.calls <- base::sys.calls
[10:19:26.683]             `[[` <- base::`[[`
[10:19:26.683]             `+` <- base::`+`
[10:19:26.683]             `<<-` <- base::`<<-`
[10:19:26.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.683]                   3L)]
[10:19:26.683]             }
[10:19:26.683]             function(cond) {
[10:19:26.683]                 is_error <- inherits(cond, "error")
[10:19:26.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.683]                   NULL)
[10:19:26.683]                 if (is_error) {
[10:19:26.683]                   sessionInformation <- function() {
[10:19:26.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.683]                       search = base::search(), system = base::Sys.info())
[10:19:26.683]                   }
[10:19:26.683]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.683]                     cond$call), session = sessionInformation(), 
[10:19:26.683]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.683]                   signalCondition(cond)
[10:19:26.683]                 }
[10:19:26.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.683]                 "immediateCondition"))) {
[10:19:26.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.683]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.683]                   if (TRUE && !signal) {
[10:19:26.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.683]                     {
[10:19:26.683]                       inherits <- base::inherits
[10:19:26.683]                       invokeRestart <- base::invokeRestart
[10:19:26.683]                       is.null <- base::is.null
[10:19:26.683]                       muffled <- FALSE
[10:19:26.683]                       if (inherits(cond, "message")) {
[10:19:26.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.683]                         if (muffled) 
[10:19:26.683]                           invokeRestart("muffleMessage")
[10:19:26.683]                       }
[10:19:26.683]                       else if (inherits(cond, "warning")) {
[10:19:26.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.683]                         if (muffled) 
[10:19:26.683]                           invokeRestart("muffleWarning")
[10:19:26.683]                       }
[10:19:26.683]                       else if (inherits(cond, "condition")) {
[10:19:26.683]                         if (!is.null(pattern)) {
[10:19:26.683]                           computeRestarts <- base::computeRestarts
[10:19:26.683]                           grepl <- base::grepl
[10:19:26.683]                           restarts <- computeRestarts(cond)
[10:19:26.683]                           for (restart in restarts) {
[10:19:26.683]                             name <- restart$name
[10:19:26.683]                             if (is.null(name)) 
[10:19:26.683]                               next
[10:19:26.683]                             if (!grepl(pattern, name)) 
[10:19:26.683]                               next
[10:19:26.683]                             invokeRestart(restart)
[10:19:26.683]                             muffled <- TRUE
[10:19:26.683]                             break
[10:19:26.683]                           }
[10:19:26.683]                         }
[10:19:26.683]                       }
[10:19:26.683]                       invisible(muffled)
[10:19:26.683]                     }
[10:19:26.683]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.683]                   }
[10:19:26.683]                 }
[10:19:26.683]                 else {
[10:19:26.683]                   if (TRUE) {
[10:19:26.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.683]                     {
[10:19:26.683]                       inherits <- base::inherits
[10:19:26.683]                       invokeRestart <- base::invokeRestart
[10:19:26.683]                       is.null <- base::is.null
[10:19:26.683]                       muffled <- FALSE
[10:19:26.683]                       if (inherits(cond, "message")) {
[10:19:26.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.683]                         if (muffled) 
[10:19:26.683]                           invokeRestart("muffleMessage")
[10:19:26.683]                       }
[10:19:26.683]                       else if (inherits(cond, "warning")) {
[10:19:26.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.683]                         if (muffled) 
[10:19:26.683]                           invokeRestart("muffleWarning")
[10:19:26.683]                       }
[10:19:26.683]                       else if (inherits(cond, "condition")) {
[10:19:26.683]                         if (!is.null(pattern)) {
[10:19:26.683]                           computeRestarts <- base::computeRestarts
[10:19:26.683]                           grepl <- base::grepl
[10:19:26.683]                           restarts <- computeRestarts(cond)
[10:19:26.683]                           for (restart in restarts) {
[10:19:26.683]                             name <- restart$name
[10:19:26.683]                             if (is.null(name)) 
[10:19:26.683]                               next
[10:19:26.683]                             if (!grepl(pattern, name)) 
[10:19:26.683]                               next
[10:19:26.683]                             invokeRestart(restart)
[10:19:26.683]                             muffled <- TRUE
[10:19:26.683]                             break
[10:19:26.683]                           }
[10:19:26.683]                         }
[10:19:26.683]                       }
[10:19:26.683]                       invisible(muffled)
[10:19:26.683]                     }
[10:19:26.683]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.683]                   }
[10:19:26.683]                 }
[10:19:26.683]             }
[10:19:26.683]         }))
[10:19:26.683]     }, error = function(ex) {
[10:19:26.683]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.683]                 ...future.rng), started = ...future.startTime, 
[10:19:26.683]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.683]             version = "1.8"), class = "FutureResult")
[10:19:26.683]     }, finally = {
[10:19:26.683]         if (!identical(...future.workdir, getwd())) 
[10:19:26.683]             setwd(...future.workdir)
[10:19:26.683]         {
[10:19:26.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.683]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.683]             }
[10:19:26.683]             base::options(...future.oldOptions)
[10:19:26.683]             if (.Platform$OS.type == "windows") {
[10:19:26.683]                 old_names <- names(...future.oldEnvVars)
[10:19:26.683]                 envs <- base::Sys.getenv()
[10:19:26.683]                 names <- names(envs)
[10:19:26.683]                 common <- intersect(names, old_names)
[10:19:26.683]                 added <- setdiff(names, old_names)
[10:19:26.683]                 removed <- setdiff(old_names, names)
[10:19:26.683]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.683]                   envs[common]]
[10:19:26.683]                 NAMES <- toupper(changed)
[10:19:26.683]                 args <- list()
[10:19:26.683]                 for (kk in seq_along(NAMES)) {
[10:19:26.683]                   name <- changed[[kk]]
[10:19:26.683]                   NAME <- NAMES[[kk]]
[10:19:26.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.683]                     next
[10:19:26.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.683]                 }
[10:19:26.683]                 NAMES <- toupper(added)
[10:19:26.683]                 for (kk in seq_along(NAMES)) {
[10:19:26.683]                   name <- added[[kk]]
[10:19:26.683]                   NAME <- NAMES[[kk]]
[10:19:26.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.683]                     next
[10:19:26.683]                   args[[name]] <- ""
[10:19:26.683]                 }
[10:19:26.683]                 NAMES <- toupper(removed)
[10:19:26.683]                 for (kk in seq_along(NAMES)) {
[10:19:26.683]                   name <- removed[[kk]]
[10:19:26.683]                   NAME <- NAMES[[kk]]
[10:19:26.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.683]                     next
[10:19:26.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.683]                 }
[10:19:26.683]                 if (length(args) > 0) 
[10:19:26.683]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.683]             }
[10:19:26.683]             else {
[10:19:26.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.683]             }
[10:19:26.683]             {
[10:19:26.683]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.683]                   0L) {
[10:19:26.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.683]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.683]                   base::options(opts)
[10:19:26.683]                 }
[10:19:26.683]                 {
[10:19:26.683]                   {
[10:19:26.683]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.683]                     NULL
[10:19:26.683]                   }
[10:19:26.683]                   options(future.plan = NULL)
[10:19:26.683]                   if (is.na(NA_character_)) 
[10:19:26.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.683]                     .init = FALSE)
[10:19:26.683]                 }
[10:19:26.683]             }
[10:19:26.683]         }
[10:19:26.683]     })
[10:19:26.683]     if (TRUE) {
[10:19:26.683]         base::sink(type = "output", split = FALSE)
[10:19:26.683]         if (TRUE) {
[10:19:26.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.683]         }
[10:19:26.683]         else {
[10:19:26.683]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.683]         }
[10:19:26.683]         base::close(...future.stdout)
[10:19:26.683]         ...future.stdout <- NULL
[10:19:26.683]     }
[10:19:26.683]     ...future.result$conditions <- ...future.conditions
[10:19:26.683]     ...future.result$finished <- base::Sys.time()
[10:19:26.683]     ...future.result
[10:19:26.683] }
[10:19:26.686] Exporting 5 global objects (673 bytes) to cluster node #2 ...
[10:19:26.686] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[10:19:26.686] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[10:19:26.686] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:26.687] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.687] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ...
[10:19:26.687] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ... DONE
[10:19:26.687] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:26.688] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.688] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:26.688] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.688] Exporting 5 global objects (673 bytes) to cluster node #2 ... DONE
[10:19:26.689] MultisessionFuture started
[10:19:26.689] - Launch lazy future ... done
[10:19:26.689] run() for ‘MultisessionFuture’ ... done
[10:19:26.689] Created future:
[10:19:26.689] MultisessionFuture:
[10:19:26.689] Label: ‘future_mapply-2’
[10:19:26.689] Expression:
[10:19:26.689] {
[10:19:26.689]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.689]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.689]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.689]         on.exit(options(oopts), add = TRUE)
[10:19:26.689]     }
[10:19:26.689]     {
[10:19:26.689]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.689]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.689]         do.call(mapply, args = args)
[10:19:26.689]     }
[10:19:26.689] }
[10:19:26.689] Lazy evaluation: FALSE
[10:19:26.689] Asynchronous evaluation: TRUE
[10:19:26.689] Local evaluation: TRUE
[10:19:26.689] Environment: R_GlobalEnv
[10:19:26.689] Capture standard output: TRUE
[10:19:26.689] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.689] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.689] Packages: <none>
[10:19:26.689] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.689] Resolved: FALSE
[10:19:26.689] Value: <not collected>
[10:19:26.689] Conditions captured: <none>
[10:19:26.689] Early signaling: FALSE
[10:19:26.689] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.689] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.700] Chunk #2 of 2 ... DONE
[10:19:26.701] Launching 2 futures (chunks) ... DONE
[10:19:26.701] Resolving 2 futures (chunks) ...
[10:19:26.701] resolve() on list ...
[10:19:26.701]  recursive: 0
[10:19:26.701]  length: 2
[10:19:26.701] 
[10:19:26.702] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.702] - Validating connection of MultisessionFuture
[10:19:26.702] - received message: FutureResult
[10:19:26.702] - Received FutureResult
[10:19:26.702] - Erased future from FutureRegistry
[10:19:26.702] result() for ClusterFuture ...
[10:19:26.702] - result already collected: FutureResult
[10:19:26.702] result() for ClusterFuture ... done
[10:19:26.702] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.703] Future #1
[10:19:26.703] result() for ClusterFuture ...
[10:19:26.703] - result already collected: FutureResult
[10:19:26.703] result() for ClusterFuture ... done
[10:19:26.703] result() for ClusterFuture ...
[10:19:26.703] - result already collected: FutureResult
[10:19:26.703] result() for ClusterFuture ... done
[10:19:26.703] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:26.703] - nx: 2
[10:19:26.703] - relay: TRUE
[10:19:26.703] - stdout: TRUE
[10:19:26.703] - signal: TRUE
[10:19:26.704] - resignal: FALSE
[10:19:26.704] - force: TRUE
[10:19:26.704] - relayed: [n=2] FALSE, FALSE
[10:19:26.704] - queued futures: [n=2] FALSE, FALSE
[10:19:26.704]  - until=1
[10:19:26.704]  - relaying element #1
[10:19:26.704] result() for ClusterFuture ...
[10:19:26.704] - result already collected: FutureResult
[10:19:26.704] result() for ClusterFuture ... done
[10:19:26.704] result() for ClusterFuture ...
[10:19:26.704] - result already collected: FutureResult
[10:19:26.704] result() for ClusterFuture ... done
[10:19:26.705] result() for ClusterFuture ...
[10:19:26.705] - result already collected: FutureResult
[10:19:26.705] result() for ClusterFuture ... done
[10:19:26.705] result() for ClusterFuture ...
[10:19:26.705] - result already collected: FutureResult
[10:19:26.705] result() for ClusterFuture ... done
[10:19:26.705] - relayed: [n=2] TRUE, FALSE
[10:19:26.705] - queued futures: [n=2] TRUE, FALSE
[10:19:26.705] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:26.705]  length: 1 (resolved future 1)
[10:19:26.731] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.731] - Validating connection of MultisessionFuture
[10:19:26.731] - received message: FutureResult
[10:19:26.731] - Received FutureResult
[10:19:26.732] - Erased future from FutureRegistry
[10:19:26.732] result() for ClusterFuture ...
[10:19:26.732] - result already collected: FutureResult
[10:19:26.732] result() for ClusterFuture ... done
[10:19:26.732] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.732] Future #2
[10:19:26.732] result() for ClusterFuture ...
[10:19:26.732] - result already collected: FutureResult
[10:19:26.732] result() for ClusterFuture ... done
[10:19:26.732] result() for ClusterFuture ...
[10:19:26.732] - result already collected: FutureResult
[10:19:26.733] result() for ClusterFuture ... done
[10:19:26.733] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:26.733] - nx: 2
[10:19:26.733] - relay: TRUE
[10:19:26.733] - stdout: TRUE
[10:19:26.733] - signal: TRUE
[10:19:26.733] - resignal: FALSE
[10:19:26.733] - force: TRUE
[10:19:26.733] - relayed: [n=2] TRUE, FALSE
[10:19:26.733] - queued futures: [n=2] TRUE, FALSE
[10:19:26.733]  - until=2
[10:19:26.733]  - relaying element #2
[10:19:26.734] result() for ClusterFuture ...
[10:19:26.734] - result already collected: FutureResult
[10:19:26.734] result() for ClusterFuture ... done
[10:19:26.734] result() for ClusterFuture ...
[10:19:26.734] - result already collected: FutureResult
[10:19:26.734] result() for ClusterFuture ... done
[10:19:26.734] result() for ClusterFuture ...
[10:19:26.734] - result already collected: FutureResult
[10:19:26.734] result() for ClusterFuture ... done
[10:19:26.734] result() for ClusterFuture ...
[10:19:26.734] - result already collected: FutureResult
[10:19:26.734] result() for ClusterFuture ... done
[10:19:26.735] - relayed: [n=2] TRUE, TRUE
[10:19:26.735] - queued futures: [n=2] TRUE, TRUE
[10:19:26.735] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:26.735]  length: 0 (resolved future 2)
[10:19:26.735] Relaying remaining futures
[10:19:26.735] signalConditionsASAP(NULL, pos=0) ...
[10:19:26.735] - nx: 2
[10:19:26.735] - relay: TRUE
[10:19:26.735] - stdout: TRUE
[10:19:26.735] - signal: TRUE
[10:19:26.735] - resignal: FALSE
[10:19:26.735] - force: TRUE
[10:19:26.736] - relayed: [n=2] TRUE, TRUE
[10:19:26.736] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:26.736] - relayed: [n=2] TRUE, TRUE
[10:19:26.736] - queued futures: [n=2] TRUE, TRUE
[10:19:26.736] signalConditionsASAP(NULL, pos=0) ... done
[10:19:26.736] resolve() on list ... DONE
[10:19:26.736] result() for ClusterFuture ...
[10:19:26.736] - result already collected: FutureResult
[10:19:26.736] result() for ClusterFuture ... done
[10:19:26.736] result() for ClusterFuture ...
[10:19:26.736] - result already collected: FutureResult
[10:19:26.737] result() for ClusterFuture ... done
[10:19:26.737] result() for ClusterFuture ...
[10:19:26.737] - result already collected: FutureResult
[10:19:26.737] result() for ClusterFuture ... done
[10:19:26.737] result() for ClusterFuture ...
[10:19:26.737] - result already collected: FutureResult
[10:19:26.737] result() for ClusterFuture ... done
[10:19:26.737]  - Number of value chunks collected: 2
[10:19:26.737] Resolving 2 futures (chunks) ... DONE
[10:19:26.737] Reducing values from 2 chunks ...
[10:19:26.737]  - Number of values collected after concatenation: 4
[10:19:26.738]  - Number of values expected: 4
[10:19:26.738] Reducing values from 2 chunks ... DONE
[10:19:26.738] future_mapply() ... DONE
- Parallel RNG ...
[10:19:26.738] future_mapply() ...
[10:19:26.738] Generating random seeds ...
[10:19:26.738] Generating random seed streams for 4 elements ...
[10:19:26.738] Generating random seed streams for 4 elements ... DONE
[10:19:26.738] Generating random seeds ... DONE
[10:19:26.738] Will set RNG state on exit: 10407, -65890499, -1520493901, 543895986, -932761993, -83498182, 443087657
[10:19:26.740] Number of chunks: 2
[10:19:26.740] getGlobalsAndPackagesXApply() ...
[10:19:26.740]  - future.globals: TRUE
[10:19:26.740] getGlobalsAndPackages() ...
[10:19:26.740] Searching for globals...
[10:19:26.742] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[10:19:26.742] Searching for globals ... DONE
[10:19:26.742] Resolving globals: FALSE
[10:19:26.743] The total size of the 1 globals is 501 bytes (501 bytes)
[10:19:26.743] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[10:19:26.743] - globals: [1] ‘FUN’
[10:19:26.743] - packages: [1] ‘stats’
[10:19:26.743] getGlobalsAndPackages() ... DONE
[10:19:26.743]  - globals found/used: [n=1] ‘FUN’
[10:19:26.743]  - needed namespaces: [n=1] ‘stats’
[10:19:26.744] Finding globals ... DONE
[10:19:26.744] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:26.744] List of 2
[10:19:26.744]  $ ...future.FUN:function (n, min = 0, max = 1)  
[10:19:26.744]  $ MoreArgs     :List of 1
[10:19:26.744]   ..$ min: num 1
[10:19:26.744]  - attr(*, "where")=List of 2
[10:19:26.744]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:26.744]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:26.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:26.744]  - attr(*, "resolved")= logi FALSE
[10:19:26.744]  - attr(*, "total_size")= num NA
[10:19:26.747] Packages to be attached in all futures: [n=1] ‘stats’
[10:19:26.747] getGlobalsAndPackagesXApply() ... DONE
[10:19:26.747] Number of futures (= number of chunks): 2
[10:19:26.748] Launching 2 futures (chunks) ...
[10:19:26.748] Chunk #1 of 2 ...
[10:19:26.748]  - Finding globals in '...' for chunk #1 ...
[10:19:26.748] getGlobalsAndPackages() ...
[10:19:26.748] Searching for globals...
[10:19:26.748] 
[10:19:26.748] Searching for globals ... DONE
[10:19:26.749] - globals: [0] <none>
[10:19:26.749] getGlobalsAndPackages() ... DONE
[10:19:26.749]    + additional globals found: [n=0] 
[10:19:26.749]    + additional namespaces needed: [n=0] 
[10:19:26.749]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:26.749]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.749]  - seeds: [2] <seeds>
[10:19:26.749]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.749] getGlobalsAndPackages() ...
[10:19:26.749] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.749] Resolving globals: FALSE
[10:19:26.750] The total size of the 5 globals is 870 bytes (870 bytes)
[10:19:26.750] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[10:19:26.750] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.751] - packages: [1] ‘stats’
[10:19:26.751] getGlobalsAndPackages() ... DONE
[10:19:26.751] run() for ‘Future’ ...
[10:19:26.751] - state: ‘created’
[10:19:26.751] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.765] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.765]   - Field: ‘node’
[10:19:26.765]   - Field: ‘label’
[10:19:26.765]   - Field: ‘local’
[10:19:26.765]   - Field: ‘owner’
[10:19:26.765]   - Field: ‘envir’
[10:19:26.766]   - Field: ‘workers’
[10:19:26.766]   - Field: ‘packages’
[10:19:26.766]   - Field: ‘gc’
[10:19:26.766]   - Field: ‘conditions’
[10:19:26.766]   - Field: ‘persistent’
[10:19:26.766]   - Field: ‘expr’
[10:19:26.766]   - Field: ‘uuid’
[10:19:26.766]   - Field: ‘seed’
[10:19:26.766]   - Field: ‘version’
[10:19:26.766]   - Field: ‘result’
[10:19:26.766]   - Field: ‘asynchronous’
[10:19:26.767]   - Field: ‘calls’
[10:19:26.767]   - Field: ‘globals’
[10:19:26.767]   - Field: ‘stdout’
[10:19:26.767]   - Field: ‘earlySignal’
[10:19:26.767]   - Field: ‘lazy’
[10:19:26.767]   - Field: ‘state’
[10:19:26.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.767] - Launch lazy future ...
[10:19:26.767] Packages needed by the future expression (n = 1): ‘stats’
[10:19:26.768] Packages needed by future strategies (n = 0): <none>
[10:19:26.768] {
[10:19:26.768]     {
[10:19:26.768]         {
[10:19:26.768]             ...future.startTime <- base::Sys.time()
[10:19:26.768]             {
[10:19:26.768]                 {
[10:19:26.768]                   {
[10:19:26.768]                     {
[10:19:26.768]                       {
[10:19:26.768]                         base::local({
[10:19:26.768]                           has_future <- base::requireNamespace("future", 
[10:19:26.768]                             quietly = TRUE)
[10:19:26.768]                           if (has_future) {
[10:19:26.768]                             ns <- base::getNamespace("future")
[10:19:26.768]                             version <- ns[[".package"]][["version"]]
[10:19:26.768]                             if (is.null(version)) 
[10:19:26.768]                               version <- utils::packageVersion("future")
[10:19:26.768]                           }
[10:19:26.768]                           else {
[10:19:26.768]                             version <- NULL
[10:19:26.768]                           }
[10:19:26.768]                           if (!has_future || version < "1.8.0") {
[10:19:26.768]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.768]                               "", base::R.version$version.string), 
[10:19:26.768]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:26.768]                                 base::R.version$platform, 8 * 
[10:19:26.768]                                   base::.Machine$sizeof.pointer), 
[10:19:26.768]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.768]                                 "release", "version")], collapse = " "), 
[10:19:26.768]                               hostname = base::Sys.info()[["nodename"]])
[10:19:26.768]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.768]                               info)
[10:19:26.768]                             info <- base::paste(info, collapse = "; ")
[10:19:26.768]                             if (!has_future) {
[10:19:26.768]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.768]                                 info)
[10:19:26.768]                             }
[10:19:26.768]                             else {
[10:19:26.768]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.768]                                 info, version)
[10:19:26.768]                             }
[10:19:26.768]                             base::stop(msg)
[10:19:26.768]                           }
[10:19:26.768]                         })
[10:19:26.768]                       }
[10:19:26.768]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.768]                       base::options(mc.cores = 1L)
[10:19:26.768]                     }
[10:19:26.768]                     base::local({
[10:19:26.768]                       for (pkg in "stats") {
[10:19:26.768]                         base::loadNamespace(pkg)
[10:19:26.768]                         base::library(pkg, character.only = TRUE)
[10:19:26.768]                       }
[10:19:26.768]                     })
[10:19:26.768]                   }
[10:19:26.768]                   ...future.strategy.old <- future::plan("list")
[10:19:26.768]                   options(future.plan = NULL)
[10:19:26.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.768]                 }
[10:19:26.768]                 ...future.workdir <- getwd()
[10:19:26.768]             }
[10:19:26.768]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.768]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.768]         }
[10:19:26.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.768]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.768]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.768]             base::names(...future.oldOptions))
[10:19:26.768]     }
[10:19:26.768]     if (FALSE) {
[10:19:26.768]     }
[10:19:26.768]     else {
[10:19:26.768]         if (TRUE) {
[10:19:26.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.768]                 open = "w")
[10:19:26.768]         }
[10:19:26.768]         else {
[10:19:26.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.768]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.768]         }
[10:19:26.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.768]             base::sink(type = "output", split = FALSE)
[10:19:26.768]             base::close(...future.stdout)
[10:19:26.768]         }, add = TRUE)
[10:19:26.768]     }
[10:19:26.768]     ...future.frame <- base::sys.nframe()
[10:19:26.768]     ...future.conditions <- base::list()
[10:19:26.768]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.768]     if (FALSE) {
[10:19:26.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.768]     }
[10:19:26.768]     ...future.result <- base::tryCatch({
[10:19:26.768]         base::withCallingHandlers({
[10:19:26.768]             ...future.value <- base::withVisible(base::local({
[10:19:26.768]                 ...future.makeSendCondition <- base::local({
[10:19:26.768]                   sendCondition <- NULL
[10:19:26.768]                   function(frame = 1L) {
[10:19:26.768]                     if (is.function(sendCondition)) 
[10:19:26.768]                       return(sendCondition)
[10:19:26.768]                     ns <- getNamespace("parallel")
[10:19:26.768]                     if (exists("sendData", mode = "function", 
[10:19:26.768]                       envir = ns)) {
[10:19:26.768]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.768]                         envir = ns)
[10:19:26.768]                       envir <- sys.frame(frame)
[10:19:26.768]                       master <- NULL
[10:19:26.768]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.768]                         !identical(envir, emptyenv())) {
[10:19:26.768]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.768]                           inherits = FALSE)) {
[10:19:26.768]                           master <- get("master", mode = "list", 
[10:19:26.768]                             envir = envir, inherits = FALSE)
[10:19:26.768]                           if (inherits(master, c("SOCKnode", 
[10:19:26.768]                             "SOCK0node"))) {
[10:19:26.768]                             sendCondition <<- function(cond) {
[10:19:26.768]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.768]                                 success = TRUE)
[10:19:26.768]                               parallel_sendData(master, data)
[10:19:26.768]                             }
[10:19:26.768]                             return(sendCondition)
[10:19:26.768]                           }
[10:19:26.768]                         }
[10:19:26.768]                         frame <- frame + 1L
[10:19:26.768]                         envir <- sys.frame(frame)
[10:19:26.768]                       }
[10:19:26.768]                     }
[10:19:26.768]                     sendCondition <<- function(cond) NULL
[10:19:26.768]                   }
[10:19:26.768]                 })
[10:19:26.768]                 withCallingHandlers({
[10:19:26.768]                   {
[10:19:26.768]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.768]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.768]                       ...future.globals.maxSize)) {
[10:19:26.768]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.768]                       on.exit(options(oopts), add = TRUE)
[10:19:26.768]                     }
[10:19:26.768]                     {
[10:19:26.768]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:26.768]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:26.768]                           envir = globalenv(), inherits = FALSE)
[10:19:26.768]                         ...future.FUN(...)
[10:19:26.768]                       }
[10:19:26.768]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:26.768]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:26.768]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.768]                         USE.NAMES = FALSE)
[10:19:26.768]                       do.call(mapply, args = args)
[10:19:26.768]                     }
[10:19:26.768]                   }
[10:19:26.768]                 }, immediateCondition = function(cond) {
[10:19:26.768]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.768]                   sendCondition(cond)
[10:19:26.768]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.768]                   {
[10:19:26.768]                     inherits <- base::inherits
[10:19:26.768]                     invokeRestart <- base::invokeRestart
[10:19:26.768]                     is.null <- base::is.null
[10:19:26.768]                     muffled <- FALSE
[10:19:26.768]                     if (inherits(cond, "message")) {
[10:19:26.768]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.768]                       if (muffled) 
[10:19:26.768]                         invokeRestart("muffleMessage")
[10:19:26.768]                     }
[10:19:26.768]                     else if (inherits(cond, "warning")) {
[10:19:26.768]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.768]                       if (muffled) 
[10:19:26.768]                         invokeRestart("muffleWarning")
[10:19:26.768]                     }
[10:19:26.768]                     else if (inherits(cond, "condition")) {
[10:19:26.768]                       if (!is.null(pattern)) {
[10:19:26.768]                         computeRestarts <- base::computeRestarts
[10:19:26.768]                         grepl <- base::grepl
[10:19:26.768]                         restarts <- computeRestarts(cond)
[10:19:26.768]                         for (restart in restarts) {
[10:19:26.768]                           name <- restart$name
[10:19:26.768]                           if (is.null(name)) 
[10:19:26.768]                             next
[10:19:26.768]                           if (!grepl(pattern, name)) 
[10:19:26.768]                             next
[10:19:26.768]                           invokeRestart(restart)
[10:19:26.768]                           muffled <- TRUE
[10:19:26.768]                           break
[10:19:26.768]                         }
[10:19:26.768]                       }
[10:19:26.768]                     }
[10:19:26.768]                     invisible(muffled)
[10:19:26.768]                   }
[10:19:26.768]                   muffleCondition(cond)
[10:19:26.768]                 })
[10:19:26.768]             }))
[10:19:26.768]             future::FutureResult(value = ...future.value$value, 
[10:19:26.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.768]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.768]                     ...future.globalenv.names))
[10:19:26.768]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.768]         }, condition = base::local({
[10:19:26.768]             c <- base::c
[10:19:26.768]             inherits <- base::inherits
[10:19:26.768]             invokeRestart <- base::invokeRestart
[10:19:26.768]             length <- base::length
[10:19:26.768]             list <- base::list
[10:19:26.768]             seq.int <- base::seq.int
[10:19:26.768]             signalCondition <- base::signalCondition
[10:19:26.768]             sys.calls <- base::sys.calls
[10:19:26.768]             `[[` <- base::`[[`
[10:19:26.768]             `+` <- base::`+`
[10:19:26.768]             `<<-` <- base::`<<-`
[10:19:26.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.768]                   3L)]
[10:19:26.768]             }
[10:19:26.768]             function(cond) {
[10:19:26.768]                 is_error <- inherits(cond, "error")
[10:19:26.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.768]                   NULL)
[10:19:26.768]                 if (is_error) {
[10:19:26.768]                   sessionInformation <- function() {
[10:19:26.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.768]                       search = base::search(), system = base::Sys.info())
[10:19:26.768]                   }
[10:19:26.768]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.768]                     cond$call), session = sessionInformation(), 
[10:19:26.768]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.768]                   signalCondition(cond)
[10:19:26.768]                 }
[10:19:26.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.768]                 "immediateCondition"))) {
[10:19:26.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.768]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.768]                   if (TRUE && !signal) {
[10:19:26.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.768]                     {
[10:19:26.768]                       inherits <- base::inherits
[10:19:26.768]                       invokeRestart <- base::invokeRestart
[10:19:26.768]                       is.null <- base::is.null
[10:19:26.768]                       muffled <- FALSE
[10:19:26.768]                       if (inherits(cond, "message")) {
[10:19:26.768]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.768]                         if (muffled) 
[10:19:26.768]                           invokeRestart("muffleMessage")
[10:19:26.768]                       }
[10:19:26.768]                       else if (inherits(cond, "warning")) {
[10:19:26.768]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.768]                         if (muffled) 
[10:19:26.768]                           invokeRestart("muffleWarning")
[10:19:26.768]                       }
[10:19:26.768]                       else if (inherits(cond, "condition")) {
[10:19:26.768]                         if (!is.null(pattern)) {
[10:19:26.768]                           computeRestarts <- base::computeRestarts
[10:19:26.768]                           grepl <- base::grepl
[10:19:26.768]                           restarts <- computeRestarts(cond)
[10:19:26.768]                           for (restart in restarts) {
[10:19:26.768]                             name <- restart$name
[10:19:26.768]                             if (is.null(name)) 
[10:19:26.768]                               next
[10:19:26.768]                             if (!grepl(pattern, name)) 
[10:19:26.768]                               next
[10:19:26.768]                             invokeRestart(restart)
[10:19:26.768]                             muffled <- TRUE
[10:19:26.768]                             break
[10:19:26.768]                           }
[10:19:26.768]                         }
[10:19:26.768]                       }
[10:19:26.768]                       invisible(muffled)
[10:19:26.768]                     }
[10:19:26.768]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.768]                   }
[10:19:26.768]                 }
[10:19:26.768]                 else {
[10:19:26.768]                   if (TRUE) {
[10:19:26.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.768]                     {
[10:19:26.768]                       inherits <- base::inherits
[10:19:26.768]                       invokeRestart <- base::invokeRestart
[10:19:26.768]                       is.null <- base::is.null
[10:19:26.768]                       muffled <- FALSE
[10:19:26.768]                       if (inherits(cond, "message")) {
[10:19:26.768]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.768]                         if (muffled) 
[10:19:26.768]                           invokeRestart("muffleMessage")
[10:19:26.768]                       }
[10:19:26.768]                       else if (inherits(cond, "warning")) {
[10:19:26.768]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.768]                         if (muffled) 
[10:19:26.768]                           invokeRestart("muffleWarning")
[10:19:26.768]                       }
[10:19:26.768]                       else if (inherits(cond, "condition")) {
[10:19:26.768]                         if (!is.null(pattern)) {
[10:19:26.768]                           computeRestarts <- base::computeRestarts
[10:19:26.768]                           grepl <- base::grepl
[10:19:26.768]                           restarts <- computeRestarts(cond)
[10:19:26.768]                           for (restart in restarts) {
[10:19:26.768]                             name <- restart$name
[10:19:26.768]                             if (is.null(name)) 
[10:19:26.768]                               next
[10:19:26.768]                             if (!grepl(pattern, name)) 
[10:19:26.768]                               next
[10:19:26.768]                             invokeRestart(restart)
[10:19:26.768]                             muffled <- TRUE
[10:19:26.768]                             break
[10:19:26.768]                           }
[10:19:26.768]                         }
[10:19:26.768]                       }
[10:19:26.768]                       invisible(muffled)
[10:19:26.768]                     }
[10:19:26.768]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.768]                   }
[10:19:26.768]                 }
[10:19:26.768]             }
[10:19:26.768]         }))
[10:19:26.768]     }, error = function(ex) {
[10:19:26.768]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.768]                 ...future.rng), started = ...future.startTime, 
[10:19:26.768]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.768]             version = "1.8"), class = "FutureResult")
[10:19:26.768]     }, finally = {
[10:19:26.768]         if (!identical(...future.workdir, getwd())) 
[10:19:26.768]             setwd(...future.workdir)
[10:19:26.768]         {
[10:19:26.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.768]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.768]             }
[10:19:26.768]             base::options(...future.oldOptions)
[10:19:26.768]             if (.Platform$OS.type == "windows") {
[10:19:26.768]                 old_names <- names(...future.oldEnvVars)
[10:19:26.768]                 envs <- base::Sys.getenv()
[10:19:26.768]                 names <- names(envs)
[10:19:26.768]                 common <- intersect(names, old_names)
[10:19:26.768]                 added <- setdiff(names, old_names)
[10:19:26.768]                 removed <- setdiff(old_names, names)
[10:19:26.768]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.768]                   envs[common]]
[10:19:26.768]                 NAMES <- toupper(changed)
[10:19:26.768]                 args <- list()
[10:19:26.768]                 for (kk in seq_along(NAMES)) {
[10:19:26.768]                   name <- changed[[kk]]
[10:19:26.768]                   NAME <- NAMES[[kk]]
[10:19:26.768]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.768]                     next
[10:19:26.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.768]                 }
[10:19:26.768]                 NAMES <- toupper(added)
[10:19:26.768]                 for (kk in seq_along(NAMES)) {
[10:19:26.768]                   name <- added[[kk]]
[10:19:26.768]                   NAME <- NAMES[[kk]]
[10:19:26.768]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.768]                     next
[10:19:26.768]                   args[[name]] <- ""
[10:19:26.768]                 }
[10:19:26.768]                 NAMES <- toupper(removed)
[10:19:26.768]                 for (kk in seq_along(NAMES)) {
[10:19:26.768]                   name <- removed[[kk]]
[10:19:26.768]                   NAME <- NAMES[[kk]]
[10:19:26.768]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.768]                     next
[10:19:26.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.768]                 }
[10:19:26.768]                 if (length(args) > 0) 
[10:19:26.768]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.768]             }
[10:19:26.768]             else {
[10:19:26.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.768]             }
[10:19:26.768]             {
[10:19:26.768]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.768]                   0L) {
[10:19:26.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.768]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.768]                   base::options(opts)
[10:19:26.768]                 }
[10:19:26.768]                 {
[10:19:26.768]                   {
[10:19:26.768]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.768]                     NULL
[10:19:26.768]                   }
[10:19:26.768]                   options(future.plan = NULL)
[10:19:26.768]                   if (is.na(NA_character_)) 
[10:19:26.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.768]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.768]                     .init = FALSE)
[10:19:26.768]                 }
[10:19:26.768]             }
[10:19:26.768]         }
[10:19:26.768]     })
[10:19:26.768]     if (TRUE) {
[10:19:26.768]         base::sink(type = "output", split = FALSE)
[10:19:26.768]         if (TRUE) {
[10:19:26.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.768]         }
[10:19:26.768]         else {
[10:19:26.768]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.768]         }
[10:19:26.768]         base::close(...future.stdout)
[10:19:26.768]         ...future.stdout <- NULL
[10:19:26.768]     }
[10:19:26.768]     ...future.result$conditions <- ...future.conditions
[10:19:26.768]     ...future.result$finished <- base::Sys.time()
[10:19:26.768]     ...future.result
[10:19:26.768] }
[10:19:26.771] Exporting 5 global objects (1.26 KiB) to cluster node #1 ...
[10:19:26.771] Exporting ‘...future.FUN’ (501 bytes) to cluster node #1 ...
[10:19:26.772] Exporting ‘...future.FUN’ (501 bytes) to cluster node #1 ... DONE
[10:19:26.772] Exporting ‘MoreArgs’ (91 bytes) to cluster node #1 ...
[10:19:26.772] Exporting ‘MoreArgs’ (91 bytes) to cluster node #1 ... DONE
[10:19:26.772] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #1 ...
[10:19:26.772] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #1 ... DONE
[10:19:26.773] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #1 ...
[10:19:26.773] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #1 ... DONE
[10:19:26.773] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:26.773] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.774] Exporting 5 global objects (1.26 KiB) to cluster node #1 ... DONE
[10:19:26.774] MultisessionFuture started
[10:19:26.774] - Launch lazy future ... done
[10:19:26.774] run() for ‘MultisessionFuture’ ... done
[10:19:26.774] Created future:
[10:19:26.774] MultisessionFuture:
[10:19:26.774] Label: ‘future_mapply-1’
[10:19:26.774] Expression:
[10:19:26.774] {
[10:19:26.774]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.774]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.774]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.774]         on.exit(options(oopts), add = TRUE)
[10:19:26.774]     }
[10:19:26.774]     {
[10:19:26.774]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:26.774]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:26.774]                 inherits = FALSE)
[10:19:26.774]             ...future.FUN(...)
[10:19:26.774]         }
[10:19:26.774]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:26.774]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:26.774]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.774]         do.call(mapply, args = args)
[10:19:26.774]     }
[10:19:26.774] }
[10:19:26.774] Lazy evaluation: FALSE
[10:19:26.774] Asynchronous evaluation: TRUE
[10:19:26.774] Local evaluation: TRUE
[10:19:26.774] Environment: R_GlobalEnv
[10:19:26.774] Capture standard output: TRUE
[10:19:26.774] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.774] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.774] Packages: 1 packages (‘stats’)
[10:19:26.774] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:26.774] Resolved: FALSE
[10:19:26.774] Value: <not collected>
[10:19:26.774] Conditions captured: <none>
[10:19:26.774] Early signaling: FALSE
[10:19:26.774] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.774] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.786] Chunk #1 of 2 ... DONE
[10:19:26.786] Chunk #2 of 2 ...
[10:19:26.786]  - Finding globals in '...' for chunk #2 ...
[10:19:26.786] getGlobalsAndPackages() ...
[10:19:26.786] Searching for globals...
[10:19:26.786] 
[10:19:26.787] Searching for globals ... DONE
[10:19:26.787] - globals: [0] <none>
[10:19:26.787] getGlobalsAndPackages() ... DONE
[10:19:26.787]    + additional globals found: [n=0] 
[10:19:26.787]    + additional namespaces needed: [n=0] 
[10:19:26.787]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:26.787]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.787]  - seeds: [2] <seeds>
[10:19:26.787]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.787] getGlobalsAndPackages() ...
[10:19:26.788] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.788] Resolving globals: FALSE
[10:19:26.788] The total size of the 5 globals is 870 bytes (870 bytes)
[10:19:26.788] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[10:19:26.789] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.789] - packages: [1] ‘stats’
[10:19:26.789] getGlobalsAndPackages() ... DONE
[10:19:26.789] run() for ‘Future’ ...
[10:19:26.789] - state: ‘created’
[10:19:26.789] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.803] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.804]   - Field: ‘node’
[10:19:26.804]   - Field: ‘label’
[10:19:26.804]   - Field: ‘local’
[10:19:26.804]   - Field: ‘owner’
[10:19:26.804]   - Field: ‘envir’
[10:19:26.804]   - Field: ‘workers’
[10:19:26.804]   - Field: ‘packages’
[10:19:26.804]   - Field: ‘gc’
[10:19:26.804]   - Field: ‘conditions’
[10:19:26.804]   - Field: ‘persistent’
[10:19:26.804]   - Field: ‘expr’
[10:19:26.805]   - Field: ‘uuid’
[10:19:26.805]   - Field: ‘seed’
[10:19:26.805]   - Field: ‘version’
[10:19:26.805]   - Field: ‘result’
[10:19:26.805]   - Field: ‘asynchronous’
[10:19:26.805]   - Field: ‘calls’
[10:19:26.805]   - Field: ‘globals’
[10:19:26.805]   - Field: ‘stdout’
[10:19:26.805]   - Field: ‘earlySignal’
[10:19:26.805]   - Field: ‘lazy’
[10:19:26.805]   - Field: ‘state’
[10:19:26.806] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.806] - Launch lazy future ...
[10:19:26.806] Packages needed by the future expression (n = 1): ‘stats’
[10:19:26.806] Packages needed by future strategies (n = 0): <none>
[10:19:26.809] {
[10:19:26.809]     {
[10:19:26.809]         {
[10:19:26.809]             ...future.startTime <- base::Sys.time()
[10:19:26.809]             {
[10:19:26.809]                 {
[10:19:26.809]                   {
[10:19:26.809]                     {
[10:19:26.809]                       {
[10:19:26.809]                         base::local({
[10:19:26.809]                           has_future <- base::requireNamespace("future", 
[10:19:26.809]                             quietly = TRUE)
[10:19:26.809]                           if (has_future) {
[10:19:26.809]                             ns <- base::getNamespace("future")
[10:19:26.809]                             version <- ns[[".package"]][["version"]]
[10:19:26.809]                             if (is.null(version)) 
[10:19:26.809]                               version <- utils::packageVersion("future")
[10:19:26.809]                           }
[10:19:26.809]                           else {
[10:19:26.809]                             version <- NULL
[10:19:26.809]                           }
[10:19:26.809]                           if (!has_future || version < "1.8.0") {
[10:19:26.809]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.809]                               "", base::R.version$version.string), 
[10:19:26.809]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:26.809]                                 base::R.version$platform, 8 * 
[10:19:26.809]                                   base::.Machine$sizeof.pointer), 
[10:19:26.809]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.809]                                 "release", "version")], collapse = " "), 
[10:19:26.809]                               hostname = base::Sys.info()[["nodename"]])
[10:19:26.809]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.809]                               info)
[10:19:26.809]                             info <- base::paste(info, collapse = "; ")
[10:19:26.809]                             if (!has_future) {
[10:19:26.809]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.809]                                 info)
[10:19:26.809]                             }
[10:19:26.809]                             else {
[10:19:26.809]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.809]                                 info, version)
[10:19:26.809]                             }
[10:19:26.809]                             base::stop(msg)
[10:19:26.809]                           }
[10:19:26.809]                         })
[10:19:26.809]                       }
[10:19:26.809]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.809]                       base::options(mc.cores = 1L)
[10:19:26.809]                     }
[10:19:26.809]                     base::local({
[10:19:26.809]                       for (pkg in "stats") {
[10:19:26.809]                         base::loadNamespace(pkg)
[10:19:26.809]                         base::library(pkg, character.only = TRUE)
[10:19:26.809]                       }
[10:19:26.809]                     })
[10:19:26.809]                   }
[10:19:26.809]                   ...future.strategy.old <- future::plan("list")
[10:19:26.809]                   options(future.plan = NULL)
[10:19:26.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.809]                 }
[10:19:26.809]                 ...future.workdir <- getwd()
[10:19:26.809]             }
[10:19:26.809]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.809]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.809]         }
[10:19:26.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.809]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.809]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.809]             base::names(...future.oldOptions))
[10:19:26.809]     }
[10:19:26.809]     if (FALSE) {
[10:19:26.809]     }
[10:19:26.809]     else {
[10:19:26.809]         if (TRUE) {
[10:19:26.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.809]                 open = "w")
[10:19:26.809]         }
[10:19:26.809]         else {
[10:19:26.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.809]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.809]         }
[10:19:26.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.809]             base::sink(type = "output", split = FALSE)
[10:19:26.809]             base::close(...future.stdout)
[10:19:26.809]         }, add = TRUE)
[10:19:26.809]     }
[10:19:26.809]     ...future.frame <- base::sys.nframe()
[10:19:26.809]     ...future.conditions <- base::list()
[10:19:26.809]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.809]     if (FALSE) {
[10:19:26.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.809]     }
[10:19:26.809]     ...future.result <- base::tryCatch({
[10:19:26.809]         base::withCallingHandlers({
[10:19:26.809]             ...future.value <- base::withVisible(base::local({
[10:19:26.809]                 ...future.makeSendCondition <- base::local({
[10:19:26.809]                   sendCondition <- NULL
[10:19:26.809]                   function(frame = 1L) {
[10:19:26.809]                     if (is.function(sendCondition)) 
[10:19:26.809]                       return(sendCondition)
[10:19:26.809]                     ns <- getNamespace("parallel")
[10:19:26.809]                     if (exists("sendData", mode = "function", 
[10:19:26.809]                       envir = ns)) {
[10:19:26.809]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.809]                         envir = ns)
[10:19:26.809]                       envir <- sys.frame(frame)
[10:19:26.809]                       master <- NULL
[10:19:26.809]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.809]                         !identical(envir, emptyenv())) {
[10:19:26.809]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.809]                           inherits = FALSE)) {
[10:19:26.809]                           master <- get("master", mode = "list", 
[10:19:26.809]                             envir = envir, inherits = FALSE)
[10:19:26.809]                           if (inherits(master, c("SOCKnode", 
[10:19:26.809]                             "SOCK0node"))) {
[10:19:26.809]                             sendCondition <<- function(cond) {
[10:19:26.809]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.809]                                 success = TRUE)
[10:19:26.809]                               parallel_sendData(master, data)
[10:19:26.809]                             }
[10:19:26.809]                             return(sendCondition)
[10:19:26.809]                           }
[10:19:26.809]                         }
[10:19:26.809]                         frame <- frame + 1L
[10:19:26.809]                         envir <- sys.frame(frame)
[10:19:26.809]                       }
[10:19:26.809]                     }
[10:19:26.809]                     sendCondition <<- function(cond) NULL
[10:19:26.809]                   }
[10:19:26.809]                 })
[10:19:26.809]                 withCallingHandlers({
[10:19:26.809]                   {
[10:19:26.809]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.809]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.809]                       ...future.globals.maxSize)) {
[10:19:26.809]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.809]                       on.exit(options(oopts), add = TRUE)
[10:19:26.809]                     }
[10:19:26.809]                     {
[10:19:26.809]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:26.809]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[10:19:26.809]                           envir = globalenv(), inherits = FALSE)
[10:19:26.809]                         ...future.FUN(...)
[10:19:26.809]                       }
[10:19:26.809]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:26.809]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:26.809]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.809]                         USE.NAMES = FALSE)
[10:19:26.809]                       do.call(mapply, args = args)
[10:19:26.809]                     }
[10:19:26.809]                   }
[10:19:26.809]                 }, immediateCondition = function(cond) {
[10:19:26.809]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.809]                   sendCondition(cond)
[10:19:26.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.809]                   {
[10:19:26.809]                     inherits <- base::inherits
[10:19:26.809]                     invokeRestart <- base::invokeRestart
[10:19:26.809]                     is.null <- base::is.null
[10:19:26.809]                     muffled <- FALSE
[10:19:26.809]                     if (inherits(cond, "message")) {
[10:19:26.809]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.809]                       if (muffled) 
[10:19:26.809]                         invokeRestart("muffleMessage")
[10:19:26.809]                     }
[10:19:26.809]                     else if (inherits(cond, "warning")) {
[10:19:26.809]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.809]                       if (muffled) 
[10:19:26.809]                         invokeRestart("muffleWarning")
[10:19:26.809]                     }
[10:19:26.809]                     else if (inherits(cond, "condition")) {
[10:19:26.809]                       if (!is.null(pattern)) {
[10:19:26.809]                         computeRestarts <- base::computeRestarts
[10:19:26.809]                         grepl <- base::grepl
[10:19:26.809]                         restarts <- computeRestarts(cond)
[10:19:26.809]                         for (restart in restarts) {
[10:19:26.809]                           name <- restart$name
[10:19:26.809]                           if (is.null(name)) 
[10:19:26.809]                             next
[10:19:26.809]                           if (!grepl(pattern, name)) 
[10:19:26.809]                             next
[10:19:26.809]                           invokeRestart(restart)
[10:19:26.809]                           muffled <- TRUE
[10:19:26.809]                           break
[10:19:26.809]                         }
[10:19:26.809]                       }
[10:19:26.809]                     }
[10:19:26.809]                     invisible(muffled)
[10:19:26.809]                   }
[10:19:26.809]                   muffleCondition(cond)
[10:19:26.809]                 })
[10:19:26.809]             }))
[10:19:26.809]             future::FutureResult(value = ...future.value$value, 
[10:19:26.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.809]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.809]                     ...future.globalenv.names))
[10:19:26.809]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.809]         }, condition = base::local({
[10:19:26.809]             c <- base::c
[10:19:26.809]             inherits <- base::inherits
[10:19:26.809]             invokeRestart <- base::invokeRestart
[10:19:26.809]             length <- base::length
[10:19:26.809]             list <- base::list
[10:19:26.809]             seq.int <- base::seq.int
[10:19:26.809]             signalCondition <- base::signalCondition
[10:19:26.809]             sys.calls <- base::sys.calls
[10:19:26.809]             `[[` <- base::`[[`
[10:19:26.809]             `+` <- base::`+`
[10:19:26.809]             `<<-` <- base::`<<-`
[10:19:26.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.809]                   3L)]
[10:19:26.809]             }
[10:19:26.809]             function(cond) {
[10:19:26.809]                 is_error <- inherits(cond, "error")
[10:19:26.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.809]                   NULL)
[10:19:26.809]                 if (is_error) {
[10:19:26.809]                   sessionInformation <- function() {
[10:19:26.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.809]                       search = base::search(), system = base::Sys.info())
[10:19:26.809]                   }
[10:19:26.809]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.809]                     cond$call), session = sessionInformation(), 
[10:19:26.809]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.809]                   signalCondition(cond)
[10:19:26.809]                 }
[10:19:26.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.809]                 "immediateCondition"))) {
[10:19:26.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.809]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.809]                   if (TRUE && !signal) {
[10:19:26.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.809]                     {
[10:19:26.809]                       inherits <- base::inherits
[10:19:26.809]                       invokeRestart <- base::invokeRestart
[10:19:26.809]                       is.null <- base::is.null
[10:19:26.809]                       muffled <- FALSE
[10:19:26.809]                       if (inherits(cond, "message")) {
[10:19:26.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.809]                         if (muffled) 
[10:19:26.809]                           invokeRestart("muffleMessage")
[10:19:26.809]                       }
[10:19:26.809]                       else if (inherits(cond, "warning")) {
[10:19:26.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.809]                         if (muffled) 
[10:19:26.809]                           invokeRestart("muffleWarning")
[10:19:26.809]                       }
[10:19:26.809]                       else if (inherits(cond, "condition")) {
[10:19:26.809]                         if (!is.null(pattern)) {
[10:19:26.809]                           computeRestarts <- base::computeRestarts
[10:19:26.809]                           grepl <- base::grepl
[10:19:26.809]                           restarts <- computeRestarts(cond)
[10:19:26.809]                           for (restart in restarts) {
[10:19:26.809]                             name <- restart$name
[10:19:26.809]                             if (is.null(name)) 
[10:19:26.809]                               next
[10:19:26.809]                             if (!grepl(pattern, name)) 
[10:19:26.809]                               next
[10:19:26.809]                             invokeRestart(restart)
[10:19:26.809]                             muffled <- TRUE
[10:19:26.809]                             break
[10:19:26.809]                           }
[10:19:26.809]                         }
[10:19:26.809]                       }
[10:19:26.809]                       invisible(muffled)
[10:19:26.809]                     }
[10:19:26.809]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.809]                   }
[10:19:26.809]                 }
[10:19:26.809]                 else {
[10:19:26.809]                   if (TRUE) {
[10:19:26.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.809]                     {
[10:19:26.809]                       inherits <- base::inherits
[10:19:26.809]                       invokeRestart <- base::invokeRestart
[10:19:26.809]                       is.null <- base::is.null
[10:19:26.809]                       muffled <- FALSE
[10:19:26.809]                       if (inherits(cond, "message")) {
[10:19:26.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.809]                         if (muffled) 
[10:19:26.809]                           invokeRestart("muffleMessage")
[10:19:26.809]                       }
[10:19:26.809]                       else if (inherits(cond, "warning")) {
[10:19:26.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.809]                         if (muffled) 
[10:19:26.809]                           invokeRestart("muffleWarning")
[10:19:26.809]                       }
[10:19:26.809]                       else if (inherits(cond, "condition")) {
[10:19:26.809]                         if (!is.null(pattern)) {
[10:19:26.809]                           computeRestarts <- base::computeRestarts
[10:19:26.809]                           grepl <- base::grepl
[10:19:26.809]                           restarts <- computeRestarts(cond)
[10:19:26.809]                           for (restart in restarts) {
[10:19:26.809]                             name <- restart$name
[10:19:26.809]                             if (is.null(name)) 
[10:19:26.809]                               next
[10:19:26.809]                             if (!grepl(pattern, name)) 
[10:19:26.809]                               next
[10:19:26.809]                             invokeRestart(restart)
[10:19:26.809]                             muffled <- TRUE
[10:19:26.809]                             break
[10:19:26.809]                           }
[10:19:26.809]                         }
[10:19:26.809]                       }
[10:19:26.809]                       invisible(muffled)
[10:19:26.809]                     }
[10:19:26.809]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.809]                   }
[10:19:26.809]                 }
[10:19:26.809]             }
[10:19:26.809]         }))
[10:19:26.809]     }, error = function(ex) {
[10:19:26.809]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.809]                 ...future.rng), started = ...future.startTime, 
[10:19:26.809]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.809]             version = "1.8"), class = "FutureResult")
[10:19:26.809]     }, finally = {
[10:19:26.809]         if (!identical(...future.workdir, getwd())) 
[10:19:26.809]             setwd(...future.workdir)
[10:19:26.809]         {
[10:19:26.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.809]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.809]             }
[10:19:26.809]             base::options(...future.oldOptions)
[10:19:26.809]             if (.Platform$OS.type == "windows") {
[10:19:26.809]                 old_names <- names(...future.oldEnvVars)
[10:19:26.809]                 envs <- base::Sys.getenv()
[10:19:26.809]                 names <- names(envs)
[10:19:26.809]                 common <- intersect(names, old_names)
[10:19:26.809]                 added <- setdiff(names, old_names)
[10:19:26.809]                 removed <- setdiff(old_names, names)
[10:19:26.809]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.809]                   envs[common]]
[10:19:26.809]                 NAMES <- toupper(changed)
[10:19:26.809]                 args <- list()
[10:19:26.809]                 for (kk in seq_along(NAMES)) {
[10:19:26.809]                   name <- changed[[kk]]
[10:19:26.809]                   NAME <- NAMES[[kk]]
[10:19:26.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.809]                     next
[10:19:26.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.809]                 }
[10:19:26.809]                 NAMES <- toupper(added)
[10:19:26.809]                 for (kk in seq_along(NAMES)) {
[10:19:26.809]                   name <- added[[kk]]
[10:19:26.809]                   NAME <- NAMES[[kk]]
[10:19:26.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.809]                     next
[10:19:26.809]                   args[[name]] <- ""
[10:19:26.809]                 }
[10:19:26.809]                 NAMES <- toupper(removed)
[10:19:26.809]                 for (kk in seq_along(NAMES)) {
[10:19:26.809]                   name <- removed[[kk]]
[10:19:26.809]                   NAME <- NAMES[[kk]]
[10:19:26.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.809]                     next
[10:19:26.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.809]                 }
[10:19:26.809]                 if (length(args) > 0) 
[10:19:26.809]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.809]             }
[10:19:26.809]             else {
[10:19:26.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.809]             }
[10:19:26.809]             {
[10:19:26.809]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.809]                   0L) {
[10:19:26.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.809]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.809]                   base::options(opts)
[10:19:26.809]                 }
[10:19:26.809]                 {
[10:19:26.809]                   {
[10:19:26.809]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.809]                     NULL
[10:19:26.809]                   }
[10:19:26.809]                   options(future.plan = NULL)
[10:19:26.809]                   if (is.na(NA_character_)) 
[10:19:26.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.809]                     .init = FALSE)
[10:19:26.809]                 }
[10:19:26.809]             }
[10:19:26.809]         }
[10:19:26.809]     })
[10:19:26.809]     if (TRUE) {
[10:19:26.809]         base::sink(type = "output", split = FALSE)
[10:19:26.809]         if (TRUE) {
[10:19:26.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.809]         }
[10:19:26.809]         else {
[10:19:26.809]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.809]         }
[10:19:26.809]         base::close(...future.stdout)
[10:19:26.809]         ...future.stdout <- NULL
[10:19:26.809]     }
[10:19:26.809]     ...future.result$conditions <- ...future.conditions
[10:19:26.809]     ...future.result$finished <- base::Sys.time()
[10:19:26.809]     ...future.result
[10:19:26.809] }
[10:19:26.812] Exporting 5 global objects (1.26 KiB) to cluster node #2 ...
[10:19:26.812] Exporting ‘...future.FUN’ (501 bytes) to cluster node #2 ...
[10:19:26.813] Exporting ‘...future.FUN’ (501 bytes) to cluster node #2 ... DONE
[10:19:26.813] Exporting ‘MoreArgs’ (91 bytes) to cluster node #2 ...
[10:19:26.813] Exporting ‘MoreArgs’ (91 bytes) to cluster node #2 ... DONE
[10:19:26.813] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #2 ...
[10:19:26.814] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #2 ... DONE
[10:19:26.814] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #2 ...
[10:19:26.814] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #2 ... DONE
[10:19:26.814] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:26.814] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.815] Exporting 5 global objects (1.26 KiB) to cluster node #2 ... DONE
[10:19:26.815] MultisessionFuture started
[10:19:26.815] - Launch lazy future ... done
[10:19:26.815] run() for ‘MultisessionFuture’ ... done
[10:19:26.815] Created future:
[10:19:26.815] MultisessionFuture:
[10:19:26.815] Label: ‘future_mapply-2’
[10:19:26.815] Expression:
[10:19:26.815] {
[10:19:26.815]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.815]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.815]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.815]         on.exit(options(oopts), add = TRUE)
[10:19:26.815]     }
[10:19:26.815]     {
[10:19:26.815]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[10:19:26.815]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[10:19:26.815]                 inherits = FALSE)
[10:19:26.815]             ...future.FUN(...)
[10:19:26.815]         }
[10:19:26.815]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[10:19:26.815]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[10:19:26.815]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.815]         do.call(mapply, args = args)
[10:19:26.815]     }
[10:19:26.815] }
[10:19:26.815] Lazy evaluation: FALSE
[10:19:26.815] Asynchronous evaluation: TRUE
[10:19:26.815] Local evaluation: TRUE
[10:19:26.815] Environment: R_GlobalEnv
[10:19:26.815] Capture standard output: TRUE
[10:19:26.815] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.815] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.815] Packages: 1 packages (‘stats’)
[10:19:26.815] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:19:26.815] Resolved: FALSE
[10:19:26.815] Value: <not collected>
[10:19:26.815] Conditions captured: <none>
[10:19:26.815] Early signaling: FALSE
[10:19:26.815] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.815] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.827] Chunk #2 of 2 ... DONE
[10:19:26.827] Launching 2 futures (chunks) ... DONE
[10:19:26.827] Resolving 2 futures (chunks) ...
[10:19:26.827] resolve() on list ...
[10:19:26.827]  recursive: 0
[10:19:26.827]  length: 2
[10:19:26.827] 
[10:19:26.828] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.828] - Validating connection of MultisessionFuture
[10:19:26.828] - received message: FutureResult
[10:19:26.828] - Received FutureResult
[10:19:26.828] - Erased future from FutureRegistry
[10:19:26.828] result() for ClusterFuture ...
[10:19:26.829] - result already collected: FutureResult
[10:19:26.829] result() for ClusterFuture ... done
[10:19:26.829] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.829] Future #1
[10:19:26.829] result() for ClusterFuture ...
[10:19:26.829] - result already collected: FutureResult
[10:19:26.829] result() for ClusterFuture ... done
[10:19:26.829] result() for ClusterFuture ...
[10:19:26.829] - result already collected: FutureResult
[10:19:26.829] result() for ClusterFuture ... done
[10:19:26.829] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:26.829] - nx: 2
[10:19:26.829] - relay: TRUE
[10:19:26.830] - stdout: TRUE
[10:19:26.830] - signal: TRUE
[10:19:26.830] - resignal: FALSE
[10:19:26.830] - force: TRUE
[10:19:26.830] - relayed: [n=2] FALSE, FALSE
[10:19:26.830] - queued futures: [n=2] FALSE, FALSE
[10:19:26.830]  - until=1
[10:19:26.830]  - relaying element #1
[10:19:26.830] result() for ClusterFuture ...
[10:19:26.830] - result already collected: FutureResult
[10:19:26.830] result() for ClusterFuture ... done
[10:19:26.830] result() for ClusterFuture ...
[10:19:26.831] - result already collected: FutureResult
[10:19:26.831] result() for ClusterFuture ... done
[10:19:26.831] result() for ClusterFuture ...
[10:19:26.831] - result already collected: FutureResult
[10:19:26.831] result() for ClusterFuture ... done
[10:19:26.831] result() for ClusterFuture ...
[10:19:26.831] - result already collected: FutureResult
[10:19:26.831] result() for ClusterFuture ... done
[10:19:26.831] - relayed: [n=2] TRUE, FALSE
[10:19:26.831] - queued futures: [n=2] TRUE, FALSE
[10:19:26.831] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:26.831]  length: 1 (resolved future 1)
[10:19:26.857] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.857] - Validating connection of MultisessionFuture
[10:19:26.858] - received message: FutureResult
[10:19:26.858] - Received FutureResult
[10:19:26.858] - Erased future from FutureRegistry
[10:19:26.858] result() for ClusterFuture ...
[10:19:26.858] - result already collected: FutureResult
[10:19:26.858] result() for ClusterFuture ... done
[10:19:26.858] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.858] Future #2
[10:19:26.858] result() for ClusterFuture ...
[10:19:26.858] - result already collected: FutureResult
[10:19:26.858] result() for ClusterFuture ... done
[10:19:26.859] result() for ClusterFuture ...
[10:19:26.859] - result already collected: FutureResult
[10:19:26.859] result() for ClusterFuture ... done
[10:19:26.859] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:26.859] - nx: 2
[10:19:26.859] - relay: TRUE
[10:19:26.859] - stdout: TRUE
[10:19:26.859] - signal: TRUE
[10:19:26.859] - resignal: FALSE
[10:19:26.859] - force: TRUE
[10:19:26.859] - relayed: [n=2] TRUE, FALSE
[10:19:26.859] - queued futures: [n=2] TRUE, FALSE
[10:19:26.860]  - until=2
[10:19:26.860]  - relaying element #2
[10:19:26.860] result() for ClusterFuture ...
[10:19:26.860] - result already collected: FutureResult
[10:19:26.860] result() for ClusterFuture ... done
[10:19:26.860] result() for ClusterFuture ...
[10:19:26.860] - result already collected: FutureResult
[10:19:26.860] result() for ClusterFuture ... done
[10:19:26.860] result() for ClusterFuture ...
[10:19:26.860] - result already collected: FutureResult
[10:19:26.860] result() for ClusterFuture ... done
[10:19:26.860] result() for ClusterFuture ...
[10:19:26.861] - result already collected: FutureResult
[10:19:26.861] result() for ClusterFuture ... done
[10:19:26.861] - relayed: [n=2] TRUE, TRUE
[10:19:26.861] - queued futures: [n=2] TRUE, TRUE
[10:19:26.861] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:26.861]  length: 0 (resolved future 2)
[10:19:26.861] Relaying remaining futures
[10:19:26.861] signalConditionsASAP(NULL, pos=0) ...
[10:19:26.861] - nx: 2
[10:19:26.861] - relay: TRUE
[10:19:26.861] - stdout: TRUE
[10:19:26.861] - signal: TRUE
[10:19:26.862] - resignal: FALSE
[10:19:26.862] - force: TRUE
[10:19:26.862] - relayed: [n=2] TRUE, TRUE
[10:19:26.862] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:26.862] - relayed: [n=2] TRUE, TRUE
[10:19:26.862] - queued futures: [n=2] TRUE, TRUE
[10:19:26.862] signalConditionsASAP(NULL, pos=0) ... done
[10:19:26.862] resolve() on list ... DONE
[10:19:26.862] result() for ClusterFuture ...
[10:19:26.862] - result already collected: FutureResult
[10:19:26.862] result() for ClusterFuture ... done
[10:19:26.862] result() for ClusterFuture ...
[10:19:26.863] - result already collected: FutureResult
[10:19:26.863] result() for ClusterFuture ... done
[10:19:26.863] result() for ClusterFuture ...
[10:19:26.863] - result already collected: FutureResult
[10:19:26.863] result() for ClusterFuture ... done
[10:19:26.863] result() for ClusterFuture ...
[10:19:26.863] - result already collected: FutureResult
[10:19:26.863] result() for ClusterFuture ... done
[10:19:26.863]  - Number of value chunks collected: 2
[10:19:26.863] Resolving 2 futures (chunks) ... DONE
[10:19:26.863] Reducing values from 2 chunks ...
[10:19:26.863]  - Number of values collected after concatenation: 4
[10:19:26.864]  - Number of values expected: 4
[10:19:26.864] Reducing values from 2 chunks ... DONE
[10:19:26.864] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[10:19:26.864] future_mapply() ...
[10:19:26.866] Number of chunks: 2
[10:19:26.866] getGlobalsAndPackagesXApply() ...
[10:19:26.866]  - future.globals: TRUE
[10:19:26.866] getGlobalsAndPackages() ...
[10:19:26.866] Searching for globals...
[10:19:26.867] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:19:26.868] Searching for globals ... DONE
[10:19:26.868] Resolving globals: FALSE
[10:19:26.868] The total size of the 1 globals is 337 bytes (337 bytes)
[10:19:26.868] The total size of the 1 globals exported for future expression (‘FUN()’) is 337 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (337 bytes of class ‘function’)
[10:19:26.868] - globals: [1] ‘FUN’
[10:19:26.869] - packages: [1] ‘stats’
[10:19:26.869] getGlobalsAndPackages() ... DONE
[10:19:26.869]  - globals found/used: [n=1] ‘FUN’
[10:19:26.869]  - needed namespaces: [n=1] ‘stats’
[10:19:26.869] Finding globals ... DONE
[10:19:26.869] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:26.869] List of 2
[10:19:26.869]  $ ...future.FUN:function (x, w, ...)  
[10:19:26.869]  $ MoreArgs     : NULL
[10:19:26.869]  - attr(*, "where")=List of 2
[10:19:26.869]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:26.869]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:26.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:26.869]  - attr(*, "resolved")= logi FALSE
[10:19:26.869]  - attr(*, "total_size")= num NA
[10:19:26.872] Packages to be attached in all futures: [n=1] ‘stats’
[10:19:26.872] getGlobalsAndPackagesXApply() ... DONE
[10:19:26.872] Number of futures (= number of chunks): 2
[10:19:26.872] Launching 2 futures (chunks) ...
[10:19:26.872] Chunk #1 of 2 ...
[10:19:26.872]  - Finding globals in '...' for chunk #1 ...
[10:19:26.872] getGlobalsAndPackages() ...
[10:19:26.873] Searching for globals...
[10:19:26.873] 
[10:19:26.873] Searching for globals ... DONE
[10:19:26.873] - globals: [0] <none>
[10:19:26.873] getGlobalsAndPackages() ... DONE
[10:19:26.873]    + additional globals found: [n=0] 
[10:19:26.873]    + additional namespaces needed: [n=0] 
[10:19:26.873]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:26.873]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.874]  - seeds: <none>
[10:19:26.874]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.874] getGlobalsAndPackages() ...
[10:19:26.874] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.874] Resolving globals: FALSE
[10:19:26.874] The total size of the 5 globals is 817 bytes (817 bytes)
[10:19:26.875] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 817 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (399 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:26.875] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.875] - packages: [1] ‘stats’
[10:19:26.875] getGlobalsAndPackages() ... DONE
[10:19:26.875] run() for ‘Future’ ...
[10:19:26.875] - state: ‘created’
[10:19:26.876] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.889] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.889] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.889]   - Field: ‘node’
[10:19:26.890]   - Field: ‘label’
[10:19:26.890]   - Field: ‘local’
[10:19:26.890]   - Field: ‘owner’
[10:19:26.890]   - Field: ‘envir’
[10:19:26.890]   - Field: ‘workers’
[10:19:26.890]   - Field: ‘packages’
[10:19:26.890]   - Field: ‘gc’
[10:19:26.890]   - Field: ‘conditions’
[10:19:26.890]   - Field: ‘persistent’
[10:19:26.890]   - Field: ‘expr’
[10:19:26.890]   - Field: ‘uuid’
[10:19:26.891]   - Field: ‘seed’
[10:19:26.891]   - Field: ‘version’
[10:19:26.891]   - Field: ‘result’
[10:19:26.891]   - Field: ‘asynchronous’
[10:19:26.891]   - Field: ‘calls’
[10:19:26.891]   - Field: ‘globals’
[10:19:26.891]   - Field: ‘stdout’
[10:19:26.891]   - Field: ‘earlySignal’
[10:19:26.891]   - Field: ‘lazy’
[10:19:26.891]   - Field: ‘state’
[10:19:26.891] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.892] - Launch lazy future ...
[10:19:26.892] Packages needed by the future expression (n = 1): ‘stats’
[10:19:26.892] Packages needed by future strategies (n = 0): <none>
[10:19:26.892] {
[10:19:26.892]     {
[10:19:26.892]         {
[10:19:26.892]             ...future.startTime <- base::Sys.time()
[10:19:26.892]             {
[10:19:26.892]                 {
[10:19:26.892]                   {
[10:19:26.892]                     {
[10:19:26.892]                       {
[10:19:26.892]                         base::local({
[10:19:26.892]                           has_future <- base::requireNamespace("future", 
[10:19:26.892]                             quietly = TRUE)
[10:19:26.892]                           if (has_future) {
[10:19:26.892]                             ns <- base::getNamespace("future")
[10:19:26.892]                             version <- ns[[".package"]][["version"]]
[10:19:26.892]                             if (is.null(version)) 
[10:19:26.892]                               version <- utils::packageVersion("future")
[10:19:26.892]                           }
[10:19:26.892]                           else {
[10:19:26.892]                             version <- NULL
[10:19:26.892]                           }
[10:19:26.892]                           if (!has_future || version < "1.8.0") {
[10:19:26.892]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.892]                               "", base::R.version$version.string), 
[10:19:26.892]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:26.892]                                 base::R.version$platform, 8 * 
[10:19:26.892]                                   base::.Machine$sizeof.pointer), 
[10:19:26.892]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.892]                                 "release", "version")], collapse = " "), 
[10:19:26.892]                               hostname = base::Sys.info()[["nodename"]])
[10:19:26.892]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.892]                               info)
[10:19:26.892]                             info <- base::paste(info, collapse = "; ")
[10:19:26.892]                             if (!has_future) {
[10:19:26.892]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.892]                                 info)
[10:19:26.892]                             }
[10:19:26.892]                             else {
[10:19:26.892]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.892]                                 info, version)
[10:19:26.892]                             }
[10:19:26.892]                             base::stop(msg)
[10:19:26.892]                           }
[10:19:26.892]                         })
[10:19:26.892]                       }
[10:19:26.892]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.892]                       base::options(mc.cores = 1L)
[10:19:26.892]                     }
[10:19:26.892]                     base::local({
[10:19:26.892]                       for (pkg in "stats") {
[10:19:26.892]                         base::loadNamespace(pkg)
[10:19:26.892]                         base::library(pkg, character.only = TRUE)
[10:19:26.892]                       }
[10:19:26.892]                     })
[10:19:26.892]                   }
[10:19:26.892]                   ...future.strategy.old <- future::plan("list")
[10:19:26.892]                   options(future.plan = NULL)
[10:19:26.892]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.892]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.892]                 }
[10:19:26.892]                 ...future.workdir <- getwd()
[10:19:26.892]             }
[10:19:26.892]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.892]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.892]         }
[10:19:26.892]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.892]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.892]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.892]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.892]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.892]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.892]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.892]             base::names(...future.oldOptions))
[10:19:26.892]     }
[10:19:26.892]     if (FALSE) {
[10:19:26.892]     }
[10:19:26.892]     else {
[10:19:26.892]         if (TRUE) {
[10:19:26.892]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.892]                 open = "w")
[10:19:26.892]         }
[10:19:26.892]         else {
[10:19:26.892]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.892]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.892]         }
[10:19:26.892]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.892]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.892]             base::sink(type = "output", split = FALSE)
[10:19:26.892]             base::close(...future.stdout)
[10:19:26.892]         }, add = TRUE)
[10:19:26.892]     }
[10:19:26.892]     ...future.frame <- base::sys.nframe()
[10:19:26.892]     ...future.conditions <- base::list()
[10:19:26.892]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.892]     if (FALSE) {
[10:19:26.892]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.892]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.892]     }
[10:19:26.892]     ...future.result <- base::tryCatch({
[10:19:26.892]         base::withCallingHandlers({
[10:19:26.892]             ...future.value <- base::withVisible(base::local({
[10:19:26.892]                 ...future.makeSendCondition <- base::local({
[10:19:26.892]                   sendCondition <- NULL
[10:19:26.892]                   function(frame = 1L) {
[10:19:26.892]                     if (is.function(sendCondition)) 
[10:19:26.892]                       return(sendCondition)
[10:19:26.892]                     ns <- getNamespace("parallel")
[10:19:26.892]                     if (exists("sendData", mode = "function", 
[10:19:26.892]                       envir = ns)) {
[10:19:26.892]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.892]                         envir = ns)
[10:19:26.892]                       envir <- sys.frame(frame)
[10:19:26.892]                       master <- NULL
[10:19:26.892]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.892]                         !identical(envir, emptyenv())) {
[10:19:26.892]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.892]                           inherits = FALSE)) {
[10:19:26.892]                           master <- get("master", mode = "list", 
[10:19:26.892]                             envir = envir, inherits = FALSE)
[10:19:26.892]                           if (inherits(master, c("SOCKnode", 
[10:19:26.892]                             "SOCK0node"))) {
[10:19:26.892]                             sendCondition <<- function(cond) {
[10:19:26.892]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.892]                                 success = TRUE)
[10:19:26.892]                               parallel_sendData(master, data)
[10:19:26.892]                             }
[10:19:26.892]                             return(sendCondition)
[10:19:26.892]                           }
[10:19:26.892]                         }
[10:19:26.892]                         frame <- frame + 1L
[10:19:26.892]                         envir <- sys.frame(frame)
[10:19:26.892]                       }
[10:19:26.892]                     }
[10:19:26.892]                     sendCondition <<- function(cond) NULL
[10:19:26.892]                   }
[10:19:26.892]                 })
[10:19:26.892]                 withCallingHandlers({
[10:19:26.892]                   {
[10:19:26.892]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.892]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.892]                       ...future.globals.maxSize)) {
[10:19:26.892]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.892]                       on.exit(options(oopts), add = TRUE)
[10:19:26.892]                     }
[10:19:26.892]                     {
[10:19:26.892]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.892]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.892]                         USE.NAMES = FALSE)
[10:19:26.892]                       do.call(mapply, args = args)
[10:19:26.892]                     }
[10:19:26.892]                   }
[10:19:26.892]                 }, immediateCondition = function(cond) {
[10:19:26.892]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.892]                   sendCondition(cond)
[10:19:26.892]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.892]                   {
[10:19:26.892]                     inherits <- base::inherits
[10:19:26.892]                     invokeRestart <- base::invokeRestart
[10:19:26.892]                     is.null <- base::is.null
[10:19:26.892]                     muffled <- FALSE
[10:19:26.892]                     if (inherits(cond, "message")) {
[10:19:26.892]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.892]                       if (muffled) 
[10:19:26.892]                         invokeRestart("muffleMessage")
[10:19:26.892]                     }
[10:19:26.892]                     else if (inherits(cond, "warning")) {
[10:19:26.892]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.892]                       if (muffled) 
[10:19:26.892]                         invokeRestart("muffleWarning")
[10:19:26.892]                     }
[10:19:26.892]                     else if (inherits(cond, "condition")) {
[10:19:26.892]                       if (!is.null(pattern)) {
[10:19:26.892]                         computeRestarts <- base::computeRestarts
[10:19:26.892]                         grepl <- base::grepl
[10:19:26.892]                         restarts <- computeRestarts(cond)
[10:19:26.892]                         for (restart in restarts) {
[10:19:26.892]                           name <- restart$name
[10:19:26.892]                           if (is.null(name)) 
[10:19:26.892]                             next
[10:19:26.892]                           if (!grepl(pattern, name)) 
[10:19:26.892]                             next
[10:19:26.892]                           invokeRestart(restart)
[10:19:26.892]                           muffled <- TRUE
[10:19:26.892]                           break
[10:19:26.892]                         }
[10:19:26.892]                       }
[10:19:26.892]                     }
[10:19:26.892]                     invisible(muffled)
[10:19:26.892]                   }
[10:19:26.892]                   muffleCondition(cond)
[10:19:26.892]                 })
[10:19:26.892]             }))
[10:19:26.892]             future::FutureResult(value = ...future.value$value, 
[10:19:26.892]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.892]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.892]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.892]                     ...future.globalenv.names))
[10:19:26.892]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.892]         }, condition = base::local({
[10:19:26.892]             c <- base::c
[10:19:26.892]             inherits <- base::inherits
[10:19:26.892]             invokeRestart <- base::invokeRestart
[10:19:26.892]             length <- base::length
[10:19:26.892]             list <- base::list
[10:19:26.892]             seq.int <- base::seq.int
[10:19:26.892]             signalCondition <- base::signalCondition
[10:19:26.892]             sys.calls <- base::sys.calls
[10:19:26.892]             `[[` <- base::`[[`
[10:19:26.892]             `+` <- base::`+`
[10:19:26.892]             `<<-` <- base::`<<-`
[10:19:26.892]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.892]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.892]                   3L)]
[10:19:26.892]             }
[10:19:26.892]             function(cond) {
[10:19:26.892]                 is_error <- inherits(cond, "error")
[10:19:26.892]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.892]                   NULL)
[10:19:26.892]                 if (is_error) {
[10:19:26.892]                   sessionInformation <- function() {
[10:19:26.892]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.892]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.892]                       search = base::search(), system = base::Sys.info())
[10:19:26.892]                   }
[10:19:26.892]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.892]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.892]                     cond$call), session = sessionInformation(), 
[10:19:26.892]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.892]                   signalCondition(cond)
[10:19:26.892]                 }
[10:19:26.892]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.892]                 "immediateCondition"))) {
[10:19:26.892]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.892]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.892]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.892]                   if (TRUE && !signal) {
[10:19:26.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.892]                     {
[10:19:26.892]                       inherits <- base::inherits
[10:19:26.892]                       invokeRestart <- base::invokeRestart
[10:19:26.892]                       is.null <- base::is.null
[10:19:26.892]                       muffled <- FALSE
[10:19:26.892]                       if (inherits(cond, "message")) {
[10:19:26.892]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.892]                         if (muffled) 
[10:19:26.892]                           invokeRestart("muffleMessage")
[10:19:26.892]                       }
[10:19:26.892]                       else if (inherits(cond, "warning")) {
[10:19:26.892]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.892]                         if (muffled) 
[10:19:26.892]                           invokeRestart("muffleWarning")
[10:19:26.892]                       }
[10:19:26.892]                       else if (inherits(cond, "condition")) {
[10:19:26.892]                         if (!is.null(pattern)) {
[10:19:26.892]                           computeRestarts <- base::computeRestarts
[10:19:26.892]                           grepl <- base::grepl
[10:19:26.892]                           restarts <- computeRestarts(cond)
[10:19:26.892]                           for (restart in restarts) {
[10:19:26.892]                             name <- restart$name
[10:19:26.892]                             if (is.null(name)) 
[10:19:26.892]                               next
[10:19:26.892]                             if (!grepl(pattern, name)) 
[10:19:26.892]                               next
[10:19:26.892]                             invokeRestart(restart)
[10:19:26.892]                             muffled <- TRUE
[10:19:26.892]                             break
[10:19:26.892]                           }
[10:19:26.892]                         }
[10:19:26.892]                       }
[10:19:26.892]                       invisible(muffled)
[10:19:26.892]                     }
[10:19:26.892]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.892]                   }
[10:19:26.892]                 }
[10:19:26.892]                 else {
[10:19:26.892]                   if (TRUE) {
[10:19:26.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.892]                     {
[10:19:26.892]                       inherits <- base::inherits
[10:19:26.892]                       invokeRestart <- base::invokeRestart
[10:19:26.892]                       is.null <- base::is.null
[10:19:26.892]                       muffled <- FALSE
[10:19:26.892]                       if (inherits(cond, "message")) {
[10:19:26.892]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.892]                         if (muffled) 
[10:19:26.892]                           invokeRestart("muffleMessage")
[10:19:26.892]                       }
[10:19:26.892]                       else if (inherits(cond, "warning")) {
[10:19:26.892]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.892]                         if (muffled) 
[10:19:26.892]                           invokeRestart("muffleWarning")
[10:19:26.892]                       }
[10:19:26.892]                       else if (inherits(cond, "condition")) {
[10:19:26.892]                         if (!is.null(pattern)) {
[10:19:26.892]                           computeRestarts <- base::computeRestarts
[10:19:26.892]                           grepl <- base::grepl
[10:19:26.892]                           restarts <- computeRestarts(cond)
[10:19:26.892]                           for (restart in restarts) {
[10:19:26.892]                             name <- restart$name
[10:19:26.892]                             if (is.null(name)) 
[10:19:26.892]                               next
[10:19:26.892]                             if (!grepl(pattern, name)) 
[10:19:26.892]                               next
[10:19:26.892]                             invokeRestart(restart)
[10:19:26.892]                             muffled <- TRUE
[10:19:26.892]                             break
[10:19:26.892]                           }
[10:19:26.892]                         }
[10:19:26.892]                       }
[10:19:26.892]                       invisible(muffled)
[10:19:26.892]                     }
[10:19:26.892]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.892]                   }
[10:19:26.892]                 }
[10:19:26.892]             }
[10:19:26.892]         }))
[10:19:26.892]     }, error = function(ex) {
[10:19:26.892]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.892]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.892]                 ...future.rng), started = ...future.startTime, 
[10:19:26.892]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.892]             version = "1.8"), class = "FutureResult")
[10:19:26.892]     }, finally = {
[10:19:26.892]         if (!identical(...future.workdir, getwd())) 
[10:19:26.892]             setwd(...future.workdir)
[10:19:26.892]         {
[10:19:26.892]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.892]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.892]             }
[10:19:26.892]             base::options(...future.oldOptions)
[10:19:26.892]             if (.Platform$OS.type == "windows") {
[10:19:26.892]                 old_names <- names(...future.oldEnvVars)
[10:19:26.892]                 envs <- base::Sys.getenv()
[10:19:26.892]                 names <- names(envs)
[10:19:26.892]                 common <- intersect(names, old_names)
[10:19:26.892]                 added <- setdiff(names, old_names)
[10:19:26.892]                 removed <- setdiff(old_names, names)
[10:19:26.892]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.892]                   envs[common]]
[10:19:26.892]                 NAMES <- toupper(changed)
[10:19:26.892]                 args <- list()
[10:19:26.892]                 for (kk in seq_along(NAMES)) {
[10:19:26.892]                   name <- changed[[kk]]
[10:19:26.892]                   NAME <- NAMES[[kk]]
[10:19:26.892]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.892]                     next
[10:19:26.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.892]                 }
[10:19:26.892]                 NAMES <- toupper(added)
[10:19:26.892]                 for (kk in seq_along(NAMES)) {
[10:19:26.892]                   name <- added[[kk]]
[10:19:26.892]                   NAME <- NAMES[[kk]]
[10:19:26.892]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.892]                     next
[10:19:26.892]                   args[[name]] <- ""
[10:19:26.892]                 }
[10:19:26.892]                 NAMES <- toupper(removed)
[10:19:26.892]                 for (kk in seq_along(NAMES)) {
[10:19:26.892]                   name <- removed[[kk]]
[10:19:26.892]                   NAME <- NAMES[[kk]]
[10:19:26.892]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.892]                     next
[10:19:26.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.892]                 }
[10:19:26.892]                 if (length(args) > 0) 
[10:19:26.892]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.892]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.892]             }
[10:19:26.892]             else {
[10:19:26.892]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.892]             }
[10:19:26.892]             {
[10:19:26.892]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.892]                   0L) {
[10:19:26.892]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.892]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.892]                   base::options(opts)
[10:19:26.892]                 }
[10:19:26.892]                 {
[10:19:26.892]                   {
[10:19:26.892]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.892]                     NULL
[10:19:26.892]                   }
[10:19:26.892]                   options(future.plan = NULL)
[10:19:26.892]                   if (is.na(NA_character_)) 
[10:19:26.892]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.892]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.892]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.892]                     .init = FALSE)
[10:19:26.892]                 }
[10:19:26.892]             }
[10:19:26.892]         }
[10:19:26.892]     })
[10:19:26.892]     if (TRUE) {
[10:19:26.892]         base::sink(type = "output", split = FALSE)
[10:19:26.892]         if (TRUE) {
[10:19:26.892]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.892]         }
[10:19:26.892]         else {
[10:19:26.892]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.892]         }
[10:19:26.892]         base::close(...future.stdout)
[10:19:26.892]         ...future.stdout <- NULL
[10:19:26.892]     }
[10:19:26.892]     ...future.result$conditions <- ...future.conditions
[10:19:26.892]     ...future.result$finished <- base::Sys.time()
[10:19:26.892]     ...future.result
[10:19:26.892] }
[10:19:26.895] Exporting 5 global objects (1.24 KiB) to cluster node #1 ...
[10:19:26.895] Exporting ‘...future.FUN’ (337 bytes) to cluster node #1 ...
[10:19:26.896] Exporting ‘...future.FUN’ (337 bytes) to cluster node #1 ... DONE
[10:19:26.896] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:26.896] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.897] Exporting ‘...future.elements_ii’ (399 bytes) to cluster node #1 ...
[10:19:26.897] Exporting ‘...future.elements_ii’ (399 bytes) to cluster node #1 ... DONE
[10:19:26.897] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:26.897] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.898] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:26.898] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:26.898] Exporting 5 global objects (1.24 KiB) to cluster node #1 ... DONE
[10:19:26.898] MultisessionFuture started
[10:19:26.899] - Launch lazy future ... done
[10:19:26.899] run() for ‘MultisessionFuture’ ... done
[10:19:26.899] Created future:
[10:19:26.899] MultisessionFuture:
[10:19:26.899] Label: ‘future_Map-1’
[10:19:26.899] Expression:
[10:19:26.899] {
[10:19:26.899]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.899]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.899]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.899]         on.exit(options(oopts), add = TRUE)
[10:19:26.899]     }
[10:19:26.899]     {
[10:19:26.899]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.899]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.899]         do.call(mapply, args = args)
[10:19:26.899]     }
[10:19:26.899] }
[10:19:26.899] Lazy evaluation: FALSE
[10:19:26.899] Asynchronous evaluation: TRUE
[10:19:26.899] Local evaluation: TRUE
[10:19:26.899] Environment: R_GlobalEnv
[10:19:26.899] Capture standard output: TRUE
[10:19:26.899] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.899] Globals: 5 objects totaling 817 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 399 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.899] Packages: 1 packages (‘stats’)
[10:19:26.899] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.899] Resolved: FALSE
[10:19:26.899] Value: <not collected>
[10:19:26.899] Conditions captured: <none>
[10:19:26.899] Early signaling: FALSE
[10:19:26.899] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.899] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.910] Chunk #1 of 2 ... DONE
[10:19:26.910] Chunk #2 of 2 ...
[10:19:26.910]  - Finding globals in '...' for chunk #2 ...
[10:19:26.911] getGlobalsAndPackages() ...
[10:19:26.911] Searching for globals...
[10:19:26.911] 
[10:19:26.911] Searching for globals ... DONE
[10:19:26.911] - globals: [0] <none>
[10:19:26.911] getGlobalsAndPackages() ... DONE
[10:19:26.911]    + additional globals found: [n=0] 
[10:19:26.911]    + additional namespaces needed: [n=0] 
[10:19:26.912]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:26.912]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.912]  - seeds: <none>
[10:19:26.912]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.912] getGlobalsAndPackages() ...
[10:19:26.912] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.912] Resolving globals: FALSE
[10:19:26.913] The total size of the 5 globals is 993 bytes (993 bytes)
[10:19:26.913] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 993 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (575 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:26.913] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.913] - packages: [1] ‘stats’
[10:19:26.913] getGlobalsAndPackages() ... DONE
[10:19:26.914] run() for ‘Future’ ...
[10:19:26.914] - state: ‘created’
[10:19:26.914] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:26.927] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:26.928]   - Field: ‘node’
[10:19:26.928]   - Field: ‘label’
[10:19:26.928]   - Field: ‘local’
[10:19:26.928]   - Field: ‘owner’
[10:19:26.928]   - Field: ‘envir’
[10:19:26.928]   - Field: ‘workers’
[10:19:26.928]   - Field: ‘packages’
[10:19:26.928]   - Field: ‘gc’
[10:19:26.928]   - Field: ‘conditions’
[10:19:26.929]   - Field: ‘persistent’
[10:19:26.929]   - Field: ‘expr’
[10:19:26.929]   - Field: ‘uuid’
[10:19:26.929]   - Field: ‘seed’
[10:19:26.929]   - Field: ‘version’
[10:19:26.929]   - Field: ‘result’
[10:19:26.929]   - Field: ‘asynchronous’
[10:19:26.929]   - Field: ‘calls’
[10:19:26.929]   - Field: ‘globals’
[10:19:26.929]   - Field: ‘stdout’
[10:19:26.929]   - Field: ‘earlySignal’
[10:19:26.929]   - Field: ‘lazy’
[10:19:26.930]   - Field: ‘state’
[10:19:26.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:26.930] - Launch lazy future ...
[10:19:26.930] Packages needed by the future expression (n = 1): ‘stats’
[10:19:26.930] Packages needed by future strategies (n = 0): <none>
[10:19:26.931] {
[10:19:26.931]     {
[10:19:26.931]         {
[10:19:26.931]             ...future.startTime <- base::Sys.time()
[10:19:26.931]             {
[10:19:26.931]                 {
[10:19:26.931]                   {
[10:19:26.931]                     {
[10:19:26.931]                       {
[10:19:26.931]                         base::local({
[10:19:26.931]                           has_future <- base::requireNamespace("future", 
[10:19:26.931]                             quietly = TRUE)
[10:19:26.931]                           if (has_future) {
[10:19:26.931]                             ns <- base::getNamespace("future")
[10:19:26.931]                             version <- ns[[".package"]][["version"]]
[10:19:26.931]                             if (is.null(version)) 
[10:19:26.931]                               version <- utils::packageVersion("future")
[10:19:26.931]                           }
[10:19:26.931]                           else {
[10:19:26.931]                             version <- NULL
[10:19:26.931]                           }
[10:19:26.931]                           if (!has_future || version < "1.8.0") {
[10:19:26.931]                             info <- base::c(r_version = base::gsub("R version ", 
[10:19:26.931]                               "", base::R.version$version.string), 
[10:19:26.931]                               platform = base::sprintf("%s (%s-bit)", 
[10:19:26.931]                                 base::R.version$platform, 8 * 
[10:19:26.931]                                   base::.Machine$sizeof.pointer), 
[10:19:26.931]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:26.931]                                 "release", "version")], collapse = " "), 
[10:19:26.931]                               hostname = base::Sys.info()[["nodename"]])
[10:19:26.931]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:19:26.931]                               info)
[10:19:26.931]                             info <- base::paste(info, collapse = "; ")
[10:19:26.931]                             if (!has_future) {
[10:19:26.931]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:26.931]                                 info)
[10:19:26.931]                             }
[10:19:26.931]                             else {
[10:19:26.931]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:26.931]                                 info, version)
[10:19:26.931]                             }
[10:19:26.931]                             base::stop(msg)
[10:19:26.931]                           }
[10:19:26.931]                         })
[10:19:26.931]                       }
[10:19:26.931]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:26.931]                       base::options(mc.cores = 1L)
[10:19:26.931]                     }
[10:19:26.931]                     base::local({
[10:19:26.931]                       for (pkg in "stats") {
[10:19:26.931]                         base::loadNamespace(pkg)
[10:19:26.931]                         base::library(pkg, character.only = TRUE)
[10:19:26.931]                       }
[10:19:26.931]                     })
[10:19:26.931]                   }
[10:19:26.931]                   ...future.strategy.old <- future::plan("list")
[10:19:26.931]                   options(future.plan = NULL)
[10:19:26.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:26.931]                 }
[10:19:26.931]                 ...future.workdir <- getwd()
[10:19:26.931]             }
[10:19:26.931]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:26.931]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:26.931]         }
[10:19:26.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:26.931]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:26.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:26.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:26.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:26.931]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:26.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:26.931]             base::names(...future.oldOptions))
[10:19:26.931]     }
[10:19:26.931]     if (FALSE) {
[10:19:26.931]     }
[10:19:26.931]     else {
[10:19:26.931]         if (TRUE) {
[10:19:26.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:26.931]                 open = "w")
[10:19:26.931]         }
[10:19:26.931]         else {
[10:19:26.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:26.931]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:26.931]         }
[10:19:26.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:26.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:26.931]             base::sink(type = "output", split = FALSE)
[10:19:26.931]             base::close(...future.stdout)
[10:19:26.931]         }, add = TRUE)
[10:19:26.931]     }
[10:19:26.931]     ...future.frame <- base::sys.nframe()
[10:19:26.931]     ...future.conditions <- base::list()
[10:19:26.931]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:26.931]     if (FALSE) {
[10:19:26.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:26.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:26.931]     }
[10:19:26.931]     ...future.result <- base::tryCatch({
[10:19:26.931]         base::withCallingHandlers({
[10:19:26.931]             ...future.value <- base::withVisible(base::local({
[10:19:26.931]                 ...future.makeSendCondition <- base::local({
[10:19:26.931]                   sendCondition <- NULL
[10:19:26.931]                   function(frame = 1L) {
[10:19:26.931]                     if (is.function(sendCondition)) 
[10:19:26.931]                       return(sendCondition)
[10:19:26.931]                     ns <- getNamespace("parallel")
[10:19:26.931]                     if (exists("sendData", mode = "function", 
[10:19:26.931]                       envir = ns)) {
[10:19:26.931]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:26.931]                         envir = ns)
[10:19:26.931]                       envir <- sys.frame(frame)
[10:19:26.931]                       master <- NULL
[10:19:26.931]                       while (!identical(envir, .GlobalEnv) && 
[10:19:26.931]                         !identical(envir, emptyenv())) {
[10:19:26.931]                         if (exists("master", mode = "list", envir = envir, 
[10:19:26.931]                           inherits = FALSE)) {
[10:19:26.931]                           master <- get("master", mode = "list", 
[10:19:26.931]                             envir = envir, inherits = FALSE)
[10:19:26.931]                           if (inherits(master, c("SOCKnode", 
[10:19:26.931]                             "SOCK0node"))) {
[10:19:26.931]                             sendCondition <<- function(cond) {
[10:19:26.931]                               data <- list(type = "VALUE", value = cond, 
[10:19:26.931]                                 success = TRUE)
[10:19:26.931]                               parallel_sendData(master, data)
[10:19:26.931]                             }
[10:19:26.931]                             return(sendCondition)
[10:19:26.931]                           }
[10:19:26.931]                         }
[10:19:26.931]                         frame <- frame + 1L
[10:19:26.931]                         envir <- sys.frame(frame)
[10:19:26.931]                       }
[10:19:26.931]                     }
[10:19:26.931]                     sendCondition <<- function(cond) NULL
[10:19:26.931]                   }
[10:19:26.931]                 })
[10:19:26.931]                 withCallingHandlers({
[10:19:26.931]                   {
[10:19:26.931]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.931]                     if (!identical(...future.globals.maxSize.org, 
[10:19:26.931]                       ...future.globals.maxSize)) {
[10:19:26.931]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.931]                       on.exit(options(oopts), add = TRUE)
[10:19:26.931]                     }
[10:19:26.931]                     {
[10:19:26.931]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.931]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:26.931]                         USE.NAMES = FALSE)
[10:19:26.931]                       do.call(mapply, args = args)
[10:19:26.931]                     }
[10:19:26.931]                   }
[10:19:26.931]                 }, immediateCondition = function(cond) {
[10:19:26.931]                   sendCondition <- ...future.makeSendCondition()
[10:19:26.931]                   sendCondition(cond)
[10:19:26.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.931]                   {
[10:19:26.931]                     inherits <- base::inherits
[10:19:26.931]                     invokeRestart <- base::invokeRestart
[10:19:26.931]                     is.null <- base::is.null
[10:19:26.931]                     muffled <- FALSE
[10:19:26.931]                     if (inherits(cond, "message")) {
[10:19:26.931]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:26.931]                       if (muffled) 
[10:19:26.931]                         invokeRestart("muffleMessage")
[10:19:26.931]                     }
[10:19:26.931]                     else if (inherits(cond, "warning")) {
[10:19:26.931]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:26.931]                       if (muffled) 
[10:19:26.931]                         invokeRestart("muffleWarning")
[10:19:26.931]                     }
[10:19:26.931]                     else if (inherits(cond, "condition")) {
[10:19:26.931]                       if (!is.null(pattern)) {
[10:19:26.931]                         computeRestarts <- base::computeRestarts
[10:19:26.931]                         grepl <- base::grepl
[10:19:26.931]                         restarts <- computeRestarts(cond)
[10:19:26.931]                         for (restart in restarts) {
[10:19:26.931]                           name <- restart$name
[10:19:26.931]                           if (is.null(name)) 
[10:19:26.931]                             next
[10:19:26.931]                           if (!grepl(pattern, name)) 
[10:19:26.931]                             next
[10:19:26.931]                           invokeRestart(restart)
[10:19:26.931]                           muffled <- TRUE
[10:19:26.931]                           break
[10:19:26.931]                         }
[10:19:26.931]                       }
[10:19:26.931]                     }
[10:19:26.931]                     invisible(muffled)
[10:19:26.931]                   }
[10:19:26.931]                   muffleCondition(cond)
[10:19:26.931]                 })
[10:19:26.931]             }))
[10:19:26.931]             future::FutureResult(value = ...future.value$value, 
[10:19:26.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.931]                   ...future.rng), globalenv = if (FALSE) 
[10:19:26.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:26.931]                     ...future.globalenv.names))
[10:19:26.931]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:26.931]         }, condition = base::local({
[10:19:26.931]             c <- base::c
[10:19:26.931]             inherits <- base::inherits
[10:19:26.931]             invokeRestart <- base::invokeRestart
[10:19:26.931]             length <- base::length
[10:19:26.931]             list <- base::list
[10:19:26.931]             seq.int <- base::seq.int
[10:19:26.931]             signalCondition <- base::signalCondition
[10:19:26.931]             sys.calls <- base::sys.calls
[10:19:26.931]             `[[` <- base::`[[`
[10:19:26.931]             `+` <- base::`+`
[10:19:26.931]             `<<-` <- base::`<<-`
[10:19:26.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:26.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:26.931]                   3L)]
[10:19:26.931]             }
[10:19:26.931]             function(cond) {
[10:19:26.931]                 is_error <- inherits(cond, "error")
[10:19:26.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:26.931]                   NULL)
[10:19:26.931]                 if (is_error) {
[10:19:26.931]                   sessionInformation <- function() {
[10:19:26.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:26.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:26.931]                       search = base::search(), system = base::Sys.info())
[10:19:26.931]                   }
[10:19:26.931]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:26.931]                     cond$call), session = sessionInformation(), 
[10:19:26.931]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:26.931]                   signalCondition(cond)
[10:19:26.931]                 }
[10:19:26.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:26.931]                 "immediateCondition"))) {
[10:19:26.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:26.931]                   ...future.conditions[[length(...future.conditions) + 
[10:19:26.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:26.931]                   if (TRUE && !signal) {
[10:19:26.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.931]                     {
[10:19:26.931]                       inherits <- base::inherits
[10:19:26.931]                       invokeRestart <- base::invokeRestart
[10:19:26.931]                       is.null <- base::is.null
[10:19:26.931]                       muffled <- FALSE
[10:19:26.931]                       if (inherits(cond, "message")) {
[10:19:26.931]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.931]                         if (muffled) 
[10:19:26.931]                           invokeRestart("muffleMessage")
[10:19:26.931]                       }
[10:19:26.931]                       else if (inherits(cond, "warning")) {
[10:19:26.931]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.931]                         if (muffled) 
[10:19:26.931]                           invokeRestart("muffleWarning")
[10:19:26.931]                       }
[10:19:26.931]                       else if (inherits(cond, "condition")) {
[10:19:26.931]                         if (!is.null(pattern)) {
[10:19:26.931]                           computeRestarts <- base::computeRestarts
[10:19:26.931]                           grepl <- base::grepl
[10:19:26.931]                           restarts <- computeRestarts(cond)
[10:19:26.931]                           for (restart in restarts) {
[10:19:26.931]                             name <- restart$name
[10:19:26.931]                             if (is.null(name)) 
[10:19:26.931]                               next
[10:19:26.931]                             if (!grepl(pattern, name)) 
[10:19:26.931]                               next
[10:19:26.931]                             invokeRestart(restart)
[10:19:26.931]                             muffled <- TRUE
[10:19:26.931]                             break
[10:19:26.931]                           }
[10:19:26.931]                         }
[10:19:26.931]                       }
[10:19:26.931]                       invisible(muffled)
[10:19:26.931]                     }
[10:19:26.931]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.931]                   }
[10:19:26.931]                 }
[10:19:26.931]                 else {
[10:19:26.931]                   if (TRUE) {
[10:19:26.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:26.931]                     {
[10:19:26.931]                       inherits <- base::inherits
[10:19:26.931]                       invokeRestart <- base::invokeRestart
[10:19:26.931]                       is.null <- base::is.null
[10:19:26.931]                       muffled <- FALSE
[10:19:26.931]                       if (inherits(cond, "message")) {
[10:19:26.931]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:26.931]                         if (muffled) 
[10:19:26.931]                           invokeRestart("muffleMessage")
[10:19:26.931]                       }
[10:19:26.931]                       else if (inherits(cond, "warning")) {
[10:19:26.931]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:26.931]                         if (muffled) 
[10:19:26.931]                           invokeRestart("muffleWarning")
[10:19:26.931]                       }
[10:19:26.931]                       else if (inherits(cond, "condition")) {
[10:19:26.931]                         if (!is.null(pattern)) {
[10:19:26.931]                           computeRestarts <- base::computeRestarts
[10:19:26.931]                           grepl <- base::grepl
[10:19:26.931]                           restarts <- computeRestarts(cond)
[10:19:26.931]                           for (restart in restarts) {
[10:19:26.931]                             name <- restart$name
[10:19:26.931]                             if (is.null(name)) 
[10:19:26.931]                               next
[10:19:26.931]                             if (!grepl(pattern, name)) 
[10:19:26.931]                               next
[10:19:26.931]                             invokeRestart(restart)
[10:19:26.931]                             muffled <- TRUE
[10:19:26.931]                             break
[10:19:26.931]                           }
[10:19:26.931]                         }
[10:19:26.931]                       }
[10:19:26.931]                       invisible(muffled)
[10:19:26.931]                     }
[10:19:26.931]                     muffleCondition(cond, pattern = "^muffle")
[10:19:26.931]                   }
[10:19:26.931]                 }
[10:19:26.931]             }
[10:19:26.931]         }))
[10:19:26.931]     }, error = function(ex) {
[10:19:26.931]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:26.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:26.931]                 ...future.rng), started = ...future.startTime, 
[10:19:26.931]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:26.931]             version = "1.8"), class = "FutureResult")
[10:19:26.931]     }, finally = {
[10:19:26.931]         if (!identical(...future.workdir, getwd())) 
[10:19:26.931]             setwd(...future.workdir)
[10:19:26.931]         {
[10:19:26.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:26.931]                 ...future.oldOptions$nwarnings <- NULL
[10:19:26.931]             }
[10:19:26.931]             base::options(...future.oldOptions)
[10:19:26.931]             if (.Platform$OS.type == "windows") {
[10:19:26.931]                 old_names <- names(...future.oldEnvVars)
[10:19:26.931]                 envs <- base::Sys.getenv()
[10:19:26.931]                 names <- names(envs)
[10:19:26.931]                 common <- intersect(names, old_names)
[10:19:26.931]                 added <- setdiff(names, old_names)
[10:19:26.931]                 removed <- setdiff(old_names, names)
[10:19:26.931]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:26.931]                   envs[common]]
[10:19:26.931]                 NAMES <- toupper(changed)
[10:19:26.931]                 args <- list()
[10:19:26.931]                 for (kk in seq_along(NAMES)) {
[10:19:26.931]                   name <- changed[[kk]]
[10:19:26.931]                   NAME <- NAMES[[kk]]
[10:19:26.931]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.931]                     next
[10:19:26.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.931]                 }
[10:19:26.931]                 NAMES <- toupper(added)
[10:19:26.931]                 for (kk in seq_along(NAMES)) {
[10:19:26.931]                   name <- added[[kk]]
[10:19:26.931]                   NAME <- NAMES[[kk]]
[10:19:26.931]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.931]                     next
[10:19:26.931]                   args[[name]] <- ""
[10:19:26.931]                 }
[10:19:26.931]                 NAMES <- toupper(removed)
[10:19:26.931]                 for (kk in seq_along(NAMES)) {
[10:19:26.931]                   name <- removed[[kk]]
[10:19:26.931]                   NAME <- NAMES[[kk]]
[10:19:26.931]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:26.931]                     next
[10:19:26.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:26.931]                 }
[10:19:26.931]                 if (length(args) > 0) 
[10:19:26.931]                   base::do.call(base::Sys.setenv, args = args)
[10:19:26.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:26.931]             }
[10:19:26.931]             else {
[10:19:26.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:26.931]             }
[10:19:26.931]             {
[10:19:26.931]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:26.931]                   0L) {
[10:19:26.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:26.931]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:26.931]                   base::options(opts)
[10:19:26.931]                 }
[10:19:26.931]                 {
[10:19:26.931]                   {
[10:19:26.931]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:26.931]                     NULL
[10:19:26.931]                   }
[10:19:26.931]                   options(future.plan = NULL)
[10:19:26.931]                   if (is.na(NA_character_)) 
[10:19:26.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:26.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:26.931]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:26.931]                     .init = FALSE)
[10:19:26.931]                 }
[10:19:26.931]             }
[10:19:26.931]         }
[10:19:26.931]     })
[10:19:26.931]     if (TRUE) {
[10:19:26.931]         base::sink(type = "output", split = FALSE)
[10:19:26.931]         if (TRUE) {
[10:19:26.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:26.931]         }
[10:19:26.931]         else {
[10:19:26.931]             ...future.result["stdout"] <- base::list(NULL)
[10:19:26.931]         }
[10:19:26.931]         base::close(...future.stdout)
[10:19:26.931]         ...future.stdout <- NULL
[10:19:26.931]     }
[10:19:26.931]     ...future.result$conditions <- ...future.conditions
[10:19:26.931]     ...future.result$finished <- base::Sys.time()
[10:19:26.931]     ...future.result
[10:19:26.931] }
[10:19:26.933] Exporting 5 global objects (1.41 KiB) to cluster node #2 ...
[10:19:26.934] Exporting ‘...future.FUN’ (337 bytes) to cluster node #2 ...
[10:19:26.934] Exporting ‘...future.FUN’ (337 bytes) to cluster node #2 ... DONE
[10:19:26.934] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:26.935] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.935] Exporting ‘...future.elements_ii’ (575 bytes) to cluster node #2 ...
[10:19:26.935] Exporting ‘...future.elements_ii’ (575 bytes) to cluster node #2 ... DONE
[10:19:26.935] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:26.935] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.936] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:26.936] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:26.936] Exporting 5 global objects (1.41 KiB) to cluster node #2 ... DONE
[10:19:26.936] MultisessionFuture started
[10:19:26.937] - Launch lazy future ... done
[10:19:26.937] run() for ‘MultisessionFuture’ ... done
[10:19:26.937] Created future:
[10:19:26.937] MultisessionFuture:
[10:19:26.937] Label: ‘future_Map-2’
[10:19:26.937] Expression:
[10:19:26.937] {
[10:19:26.937]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:26.937]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:26.937]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:26.937]         on.exit(options(oopts), add = TRUE)
[10:19:26.937]     }
[10:19:26.937]     {
[10:19:26.937]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:26.937]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:26.937]         do.call(mapply, args = args)
[10:19:26.937]     }
[10:19:26.937] }
[10:19:26.937] Lazy evaluation: FALSE
[10:19:26.937] Asynchronous evaluation: TRUE
[10:19:26.937] Local evaluation: TRUE
[10:19:26.937] Environment: R_GlobalEnv
[10:19:26.937] Capture standard output: TRUE
[10:19:26.937] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:26.937] Globals: 5 objects totaling 993 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 575 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:26.937] Packages: 1 packages (‘stats’)
[10:19:26.937] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:26.937] Resolved: FALSE
[10:19:26.937] Value: <not collected>
[10:19:26.937] Conditions captured: <none>
[10:19:26.937] Early signaling: FALSE
[10:19:26.937] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:26.937] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:26.948] Chunk #2 of 2 ... DONE
[10:19:26.948] Launching 2 futures (chunks) ... DONE
[10:19:26.948] Resolving 2 futures (chunks) ...
[10:19:26.948] resolve() on list ...
[10:19:26.949]  recursive: 0
[10:19:26.949]  length: 2
[10:19:26.949] 
[10:19:26.949] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.949] - Validating connection of MultisessionFuture
[10:19:26.949] - received message: FutureResult
[10:19:26.950] - Received FutureResult
[10:19:26.950] - Erased future from FutureRegistry
[10:19:26.950] result() for ClusterFuture ...
[10:19:26.950] - result already collected: FutureResult
[10:19:26.950] result() for ClusterFuture ... done
[10:19:26.950] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.950] Future #1
[10:19:26.950] result() for ClusterFuture ...
[10:19:26.950] - result already collected: FutureResult
[10:19:26.950] result() for ClusterFuture ... done
[10:19:26.950] result() for ClusterFuture ...
[10:19:26.950] - result already collected: FutureResult
[10:19:26.951] result() for ClusterFuture ... done
[10:19:26.951] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:26.951] - nx: 2
[10:19:26.951] - relay: TRUE
[10:19:26.951] - stdout: TRUE
[10:19:26.951] - signal: TRUE
[10:19:26.951] - resignal: FALSE
[10:19:26.951] - force: TRUE
[10:19:26.951] - relayed: [n=2] FALSE, FALSE
[10:19:26.951] - queued futures: [n=2] FALSE, FALSE
[10:19:26.951]  - until=1
[10:19:26.951]  - relaying element #1
[10:19:26.952] result() for ClusterFuture ...
[10:19:26.952] - result already collected: FutureResult
[10:19:26.952] result() for ClusterFuture ... done
[10:19:26.952] result() for ClusterFuture ...
[10:19:26.952] - result already collected: FutureResult
[10:19:26.952] result() for ClusterFuture ... done
[10:19:26.952] result() for ClusterFuture ...
[10:19:26.952] - result already collected: FutureResult
[10:19:26.952] result() for ClusterFuture ... done
[10:19:26.952] result() for ClusterFuture ...
[10:19:26.952] - result already collected: FutureResult
[10:19:26.953] result() for ClusterFuture ... done
[10:19:26.953] - relayed: [n=2] TRUE, FALSE
[10:19:26.953] - queued futures: [n=2] TRUE, FALSE
[10:19:26.953] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:26.953]  length: 1 (resolved future 1)
[10:19:26.979] receiveMessageFromWorker() for ClusterFuture ...
[10:19:26.979] - Validating connection of MultisessionFuture
[10:19:26.980] - received message: FutureResult
[10:19:26.980] - Received FutureResult
[10:19:26.980] - Erased future from FutureRegistry
[10:19:26.980] result() for ClusterFuture ...
[10:19:26.980] - result already collected: FutureResult
[10:19:26.980] result() for ClusterFuture ... done
[10:19:26.980] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:26.980] Future #2
[10:19:26.980] result() for ClusterFuture ...
[10:19:26.980] - result already collected: FutureResult
[10:19:26.981] result() for ClusterFuture ... done
[10:19:26.981] result() for ClusterFuture ...
[10:19:26.981] - result already collected: FutureResult
[10:19:26.981] result() for ClusterFuture ... done
[10:19:26.981] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:26.981] - nx: 2
[10:19:26.981] - relay: TRUE
[10:19:26.981] - stdout: TRUE
[10:19:26.981] - signal: TRUE
[10:19:26.981] - resignal: FALSE
[10:19:26.981] - force: TRUE
[10:19:26.981] - relayed: [n=2] TRUE, FALSE
[10:19:26.982] - queued futures: [n=2] TRUE, FALSE
[10:19:26.982]  - until=2
[10:19:26.982]  - relaying element #2
[10:19:26.982] result() for ClusterFuture ...
[10:19:26.982] - result already collected: FutureResult
[10:19:26.982] result() for ClusterFuture ... done
[10:19:26.982] result() for ClusterFuture ...
[10:19:26.982] - result already collected: FutureResult
[10:19:26.982] result() for ClusterFuture ... done
[10:19:26.982] result() for ClusterFuture ...
[10:19:26.982] - result already collected: FutureResult
[10:19:26.983] result() for ClusterFuture ... done
[10:19:26.983] result() for ClusterFuture ...
[10:19:26.983] - result already collected: FutureResult
[10:19:26.983] result() for ClusterFuture ... done
[10:19:26.983] - relayed: [n=2] TRUE, TRUE
[10:19:26.983] - queued futures: [n=2] TRUE, TRUE
[10:19:26.983] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:26.983]  length: 0 (resolved future 2)
[10:19:26.983] Relaying remaining futures
[10:19:26.983] signalConditionsASAP(NULL, pos=0) ...
[10:19:26.983] - nx: 2
[10:19:26.983] - relay: TRUE
[10:19:26.983] - stdout: TRUE
[10:19:26.984] - signal: TRUE
[10:19:26.984] - resignal: FALSE
[10:19:26.984] - force: TRUE
[10:19:26.984] - relayed: [n=2] TRUE, TRUE
[10:19:26.984] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:26.984] - relayed: [n=2] TRUE, TRUE
[10:19:26.984] - queued futures: [n=2] TRUE, TRUE
[10:19:26.984] signalConditionsASAP(NULL, pos=0) ... done
[10:19:26.984] resolve() on list ... DONE
[10:19:26.984] result() for ClusterFuture ...
[10:19:26.984] - result already collected: FutureResult
[10:19:26.984] result() for ClusterFuture ... done
[10:19:26.985] result() for ClusterFuture ...
[10:19:26.985] - result already collected: FutureResult
[10:19:26.985] result() for ClusterFuture ... done
[10:19:26.985] result() for ClusterFuture ...
[10:19:26.985] - result already collected: FutureResult
[10:19:26.985] result() for ClusterFuture ... done
[10:19:26.985] result() for ClusterFuture ...
[10:19:26.985] - result already collected: FutureResult
[10:19:26.985] result() for ClusterFuture ... done
[10:19:26.985]  - Number of value chunks collected: 2
[10:19:26.985] Resolving 2 futures (chunks) ... DONE
[10:19:26.986] Reducing values from 2 chunks ...
[10:19:26.986]  - Number of values collected after concatenation: 5
[10:19:26.986]  - Number of values expected: 5
[10:19:26.986] Reducing values from 2 chunks ... DONE
[10:19:26.986] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[10:19:26.988] future_mapply() ...
[10:19:26.989] Number of chunks: 2
[10:19:26.989] getGlobalsAndPackagesXApply() ...
[10:19:26.989]  - future.globals: TRUE
[10:19:26.989] getGlobalsAndPackages() ...
[10:19:26.990] Searching for globals...
[10:19:26.990] - globals found: [1] ‘FUN’
[10:19:26.990] Searching for globals ... DONE
[10:19:26.990] Resolving globals: FALSE
[10:19:26.991] The total size of the 1 globals is 32 bytes (32 bytes)
[10:19:26.994] The total size of the 1 globals exported for future expression (‘FUN()’) is 32 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (32 bytes of class ‘function’)
[10:19:26.994] - globals: [1] ‘FUN’
[10:19:26.994] 
[10:19:26.994] getGlobalsAndPackages() ... DONE
[10:19:26.994]  - globals found/used: [n=1] ‘FUN’
[10:19:26.994]  - needed namespaces: [n=0] 
[10:19:26.994] Finding globals ... DONE
[10:19:26.994] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:26.995] List of 2
[10:19:26.995]  $ ...future.FUN:function (e1, e2)  
[10:19:26.995]  $ MoreArgs     : NULL
[10:19:26.995]  - attr(*, "where")=List of 2
[10:19:26.995]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:26.995]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:26.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:26.995]  - attr(*, "resolved")= logi FALSE
[10:19:26.995]  - attr(*, "total_size")= num NA
[10:19:26.997] Packages to be attached in all futures: [n=0] 
[10:19:26.997] getGlobalsAndPackagesXApply() ... DONE
[10:19:26.997] Number of futures (= number of chunks): 2
[10:19:26.997] Launching 2 futures (chunks) ...
[10:19:26.997] Chunk #1 of 2 ...
[10:19:26.998]  - Finding globals in '...' for chunk #1 ...
[10:19:26.998] getGlobalsAndPackages() ...
[10:19:26.998] Searching for globals...
[10:19:26.998] 
[10:19:26.998] Searching for globals ... DONE
[10:19:26.998] - globals: [0] <none>
[10:19:26.998] getGlobalsAndPackages() ... DONE
[10:19:26.998]    + additional globals found: [n=0] 
[10:19:26.998]    + additional namespaces needed: [n=0] 
[10:19:26.999]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:26.999]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:26.999]  - seeds: <none>
[10:19:26.999]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.999] getGlobalsAndPackages() ...
[10:19:26.999] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:26.999] Resolving globals: FALSE
[10:19:26.999] The total size of the 5 globals is 188 bytes (188 bytes)
[10:19:27.000] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 188 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (75 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:27.000] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:27.000] 
[10:19:27.000] getGlobalsAndPackages() ... DONE
[10:19:27.000] run() for ‘Future’ ...
[10:19:27.001] - state: ‘created’
[10:19:27.001] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:27.015] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:27.015] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:27.015]   - Field: ‘node’
[10:19:27.015]   - Field: ‘label’
[10:19:27.015]   - Field: ‘local’
[10:19:27.016]   - Field: ‘owner’
[10:19:27.016]   - Field: ‘envir’
[10:19:27.016]   - Field: ‘workers’
[10:19:27.016]   - Field: ‘packages’
[10:19:27.016]   - Field: ‘gc’
[10:19:27.016]   - Field: ‘conditions’
[10:19:27.016]   - Field: ‘persistent’
[10:19:27.016]   - Field: ‘expr’
[10:19:27.016]   - Field: ‘uuid’
[10:19:27.016]   - Field: ‘seed’
[10:19:27.016]   - Field: ‘version’
[10:19:27.016]   - Field: ‘result’
[10:19:27.017]   - Field: ‘asynchronous’
[10:19:27.017]   - Field: ‘calls’
[10:19:27.017]   - Field: ‘globals’
[10:19:27.017]   - Field: ‘stdout’
[10:19:27.017]   - Field: ‘earlySignal’
[10:19:27.017]   - Field: ‘lazy’
[10:19:27.017]   - Field: ‘state’
[10:19:27.017] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:27.017] - Launch lazy future ...
[10:19:27.017] Packages needed by the future expression (n = 0): <none>
[10:19:27.018] Packages needed by future strategies (n = 0): <none>
[10:19:27.018] {
[10:19:27.018]     {
[10:19:27.018]         {
[10:19:27.018]             ...future.startTime <- base::Sys.time()
[10:19:27.018]             {
[10:19:27.018]                 {
[10:19:27.018]                   {
[10:19:27.018]                     {
[10:19:27.018]                       base::local({
[10:19:27.018]                         has_future <- base::requireNamespace("future", 
[10:19:27.018]                           quietly = TRUE)
[10:19:27.018]                         if (has_future) {
[10:19:27.018]                           ns <- base::getNamespace("future")
[10:19:27.018]                           version <- ns[[".package"]][["version"]]
[10:19:27.018]                           if (is.null(version)) 
[10:19:27.018]                             version <- utils::packageVersion("future")
[10:19:27.018]                         }
[10:19:27.018]                         else {
[10:19:27.018]                           version <- NULL
[10:19:27.018]                         }
[10:19:27.018]                         if (!has_future || version < "1.8.0") {
[10:19:27.018]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:27.018]                             "", base::R.version$version.string), 
[10:19:27.018]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:27.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:27.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:27.018]                               "release", "version")], collapse = " "), 
[10:19:27.018]                             hostname = base::Sys.info()[["nodename"]])
[10:19:27.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:27.018]                             info)
[10:19:27.018]                           info <- base::paste(info, collapse = "; ")
[10:19:27.018]                           if (!has_future) {
[10:19:27.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:27.018]                               info)
[10:19:27.018]                           }
[10:19:27.018]                           else {
[10:19:27.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:27.018]                               info, version)
[10:19:27.018]                           }
[10:19:27.018]                           base::stop(msg)
[10:19:27.018]                         }
[10:19:27.018]                       })
[10:19:27.018]                     }
[10:19:27.018]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:27.018]                     base::options(mc.cores = 1L)
[10:19:27.018]                   }
[10:19:27.018]                   ...future.strategy.old <- future::plan("list")
[10:19:27.018]                   options(future.plan = NULL)
[10:19:27.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:27.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:27.018]                 }
[10:19:27.018]                 ...future.workdir <- getwd()
[10:19:27.018]             }
[10:19:27.018]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:27.018]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:27.018]         }
[10:19:27.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:27.018]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:27.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:27.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:27.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:27.018]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:27.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:27.018]             base::names(...future.oldOptions))
[10:19:27.018]     }
[10:19:27.018]     if (FALSE) {
[10:19:27.018]     }
[10:19:27.018]     else {
[10:19:27.018]         if (TRUE) {
[10:19:27.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:27.018]                 open = "w")
[10:19:27.018]         }
[10:19:27.018]         else {
[10:19:27.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:27.018]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:27.018]         }
[10:19:27.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:27.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:27.018]             base::sink(type = "output", split = FALSE)
[10:19:27.018]             base::close(...future.stdout)
[10:19:27.018]         }, add = TRUE)
[10:19:27.018]     }
[10:19:27.018]     ...future.frame <- base::sys.nframe()
[10:19:27.018]     ...future.conditions <- base::list()
[10:19:27.018]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:27.018]     if (FALSE) {
[10:19:27.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:27.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:27.018]     }
[10:19:27.018]     ...future.result <- base::tryCatch({
[10:19:27.018]         base::withCallingHandlers({
[10:19:27.018]             ...future.value <- base::withVisible(base::local({
[10:19:27.018]                 ...future.makeSendCondition <- base::local({
[10:19:27.018]                   sendCondition <- NULL
[10:19:27.018]                   function(frame = 1L) {
[10:19:27.018]                     if (is.function(sendCondition)) 
[10:19:27.018]                       return(sendCondition)
[10:19:27.018]                     ns <- getNamespace("parallel")
[10:19:27.018]                     if (exists("sendData", mode = "function", 
[10:19:27.018]                       envir = ns)) {
[10:19:27.018]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:27.018]                         envir = ns)
[10:19:27.018]                       envir <- sys.frame(frame)
[10:19:27.018]                       master <- NULL
[10:19:27.018]                       while (!identical(envir, .GlobalEnv) && 
[10:19:27.018]                         !identical(envir, emptyenv())) {
[10:19:27.018]                         if (exists("master", mode = "list", envir = envir, 
[10:19:27.018]                           inherits = FALSE)) {
[10:19:27.018]                           master <- get("master", mode = "list", 
[10:19:27.018]                             envir = envir, inherits = FALSE)
[10:19:27.018]                           if (inherits(master, c("SOCKnode", 
[10:19:27.018]                             "SOCK0node"))) {
[10:19:27.018]                             sendCondition <<- function(cond) {
[10:19:27.018]                               data <- list(type = "VALUE", value = cond, 
[10:19:27.018]                                 success = TRUE)
[10:19:27.018]                               parallel_sendData(master, data)
[10:19:27.018]                             }
[10:19:27.018]                             return(sendCondition)
[10:19:27.018]                           }
[10:19:27.018]                         }
[10:19:27.018]                         frame <- frame + 1L
[10:19:27.018]                         envir <- sys.frame(frame)
[10:19:27.018]                       }
[10:19:27.018]                     }
[10:19:27.018]                     sendCondition <<- function(cond) NULL
[10:19:27.018]                   }
[10:19:27.018]                 })
[10:19:27.018]                 withCallingHandlers({
[10:19:27.018]                   {
[10:19:27.018]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:27.018]                     if (!identical(...future.globals.maxSize.org, 
[10:19:27.018]                       ...future.globals.maxSize)) {
[10:19:27.018]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:27.018]                       on.exit(options(oopts), add = TRUE)
[10:19:27.018]                     }
[10:19:27.018]                     {
[10:19:27.018]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:27.018]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:27.018]                         USE.NAMES = FALSE)
[10:19:27.018]                       do.call(mapply, args = args)
[10:19:27.018]                     }
[10:19:27.018]                   }
[10:19:27.018]                 }, immediateCondition = function(cond) {
[10:19:27.018]                   sendCondition <- ...future.makeSendCondition()
[10:19:27.018]                   sendCondition(cond)
[10:19:27.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.018]                   {
[10:19:27.018]                     inherits <- base::inherits
[10:19:27.018]                     invokeRestart <- base::invokeRestart
[10:19:27.018]                     is.null <- base::is.null
[10:19:27.018]                     muffled <- FALSE
[10:19:27.018]                     if (inherits(cond, "message")) {
[10:19:27.018]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:27.018]                       if (muffled) 
[10:19:27.018]                         invokeRestart("muffleMessage")
[10:19:27.018]                     }
[10:19:27.018]                     else if (inherits(cond, "warning")) {
[10:19:27.018]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:27.018]                       if (muffled) 
[10:19:27.018]                         invokeRestart("muffleWarning")
[10:19:27.018]                     }
[10:19:27.018]                     else if (inherits(cond, "condition")) {
[10:19:27.018]                       if (!is.null(pattern)) {
[10:19:27.018]                         computeRestarts <- base::computeRestarts
[10:19:27.018]                         grepl <- base::grepl
[10:19:27.018]                         restarts <- computeRestarts(cond)
[10:19:27.018]                         for (restart in restarts) {
[10:19:27.018]                           name <- restart$name
[10:19:27.018]                           if (is.null(name)) 
[10:19:27.018]                             next
[10:19:27.018]                           if (!grepl(pattern, name)) 
[10:19:27.018]                             next
[10:19:27.018]                           invokeRestart(restart)
[10:19:27.018]                           muffled <- TRUE
[10:19:27.018]                           break
[10:19:27.018]                         }
[10:19:27.018]                       }
[10:19:27.018]                     }
[10:19:27.018]                     invisible(muffled)
[10:19:27.018]                   }
[10:19:27.018]                   muffleCondition(cond)
[10:19:27.018]                 })
[10:19:27.018]             }))
[10:19:27.018]             future::FutureResult(value = ...future.value$value, 
[10:19:27.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:27.018]                   ...future.rng), globalenv = if (FALSE) 
[10:19:27.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:27.018]                     ...future.globalenv.names))
[10:19:27.018]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:27.018]         }, condition = base::local({
[10:19:27.018]             c <- base::c
[10:19:27.018]             inherits <- base::inherits
[10:19:27.018]             invokeRestart <- base::invokeRestart
[10:19:27.018]             length <- base::length
[10:19:27.018]             list <- base::list
[10:19:27.018]             seq.int <- base::seq.int
[10:19:27.018]             signalCondition <- base::signalCondition
[10:19:27.018]             sys.calls <- base::sys.calls
[10:19:27.018]             `[[` <- base::`[[`
[10:19:27.018]             `+` <- base::`+`
[10:19:27.018]             `<<-` <- base::`<<-`
[10:19:27.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:27.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:27.018]                   3L)]
[10:19:27.018]             }
[10:19:27.018]             function(cond) {
[10:19:27.018]                 is_error <- inherits(cond, "error")
[10:19:27.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:27.018]                   NULL)
[10:19:27.018]                 if (is_error) {
[10:19:27.018]                   sessionInformation <- function() {
[10:19:27.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:27.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:27.018]                       search = base::search(), system = base::Sys.info())
[10:19:27.018]                   }
[10:19:27.018]                   ...future.conditions[[length(...future.conditions) + 
[10:19:27.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:27.018]                     cond$call), session = sessionInformation(), 
[10:19:27.018]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:27.018]                   signalCondition(cond)
[10:19:27.018]                 }
[10:19:27.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:27.018]                 "immediateCondition"))) {
[10:19:27.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:27.018]                   ...future.conditions[[length(...future.conditions) + 
[10:19:27.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:27.018]                   if (TRUE && !signal) {
[10:19:27.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.018]                     {
[10:19:27.018]                       inherits <- base::inherits
[10:19:27.018]                       invokeRestart <- base::invokeRestart
[10:19:27.018]                       is.null <- base::is.null
[10:19:27.018]                       muffled <- FALSE
[10:19:27.018]                       if (inherits(cond, "message")) {
[10:19:27.018]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:27.018]                         if (muffled) 
[10:19:27.018]                           invokeRestart("muffleMessage")
[10:19:27.018]                       }
[10:19:27.018]                       else if (inherits(cond, "warning")) {
[10:19:27.018]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:27.018]                         if (muffled) 
[10:19:27.018]                           invokeRestart("muffleWarning")
[10:19:27.018]                       }
[10:19:27.018]                       else if (inherits(cond, "condition")) {
[10:19:27.018]                         if (!is.null(pattern)) {
[10:19:27.018]                           computeRestarts <- base::computeRestarts
[10:19:27.018]                           grepl <- base::grepl
[10:19:27.018]                           restarts <- computeRestarts(cond)
[10:19:27.018]                           for (restart in restarts) {
[10:19:27.018]                             name <- restart$name
[10:19:27.018]                             if (is.null(name)) 
[10:19:27.018]                               next
[10:19:27.018]                             if (!grepl(pattern, name)) 
[10:19:27.018]                               next
[10:19:27.018]                             invokeRestart(restart)
[10:19:27.018]                             muffled <- TRUE
[10:19:27.018]                             break
[10:19:27.018]                           }
[10:19:27.018]                         }
[10:19:27.018]                       }
[10:19:27.018]                       invisible(muffled)
[10:19:27.018]                     }
[10:19:27.018]                     muffleCondition(cond, pattern = "^muffle")
[10:19:27.018]                   }
[10:19:27.018]                 }
[10:19:27.018]                 else {
[10:19:27.018]                   if (TRUE) {
[10:19:27.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.018]                     {
[10:19:27.018]                       inherits <- base::inherits
[10:19:27.018]                       invokeRestart <- base::invokeRestart
[10:19:27.018]                       is.null <- base::is.null
[10:19:27.018]                       muffled <- FALSE
[10:19:27.018]                       if (inherits(cond, "message")) {
[10:19:27.018]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:27.018]                         if (muffled) 
[10:19:27.018]                           invokeRestart("muffleMessage")
[10:19:27.018]                       }
[10:19:27.018]                       else if (inherits(cond, "warning")) {
[10:19:27.018]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:27.018]                         if (muffled) 
[10:19:27.018]                           invokeRestart("muffleWarning")
[10:19:27.018]                       }
[10:19:27.018]                       else if (inherits(cond, "condition")) {
[10:19:27.018]                         if (!is.null(pattern)) {
[10:19:27.018]                           computeRestarts <- base::computeRestarts
[10:19:27.018]                           grepl <- base::grepl
[10:19:27.018]                           restarts <- computeRestarts(cond)
[10:19:27.018]                           for (restart in restarts) {
[10:19:27.018]                             name <- restart$name
[10:19:27.018]                             if (is.null(name)) 
[10:19:27.018]                               next
[10:19:27.018]                             if (!grepl(pattern, name)) 
[10:19:27.018]                               next
[10:19:27.018]                             invokeRestart(restart)
[10:19:27.018]                             muffled <- TRUE
[10:19:27.018]                             break
[10:19:27.018]                           }
[10:19:27.018]                         }
[10:19:27.018]                       }
[10:19:27.018]                       invisible(muffled)
[10:19:27.018]                     }
[10:19:27.018]                     muffleCondition(cond, pattern = "^muffle")
[10:19:27.018]                   }
[10:19:27.018]                 }
[10:19:27.018]             }
[10:19:27.018]         }))
[10:19:27.018]     }, error = function(ex) {
[10:19:27.018]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:27.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:27.018]                 ...future.rng), started = ...future.startTime, 
[10:19:27.018]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:27.018]             version = "1.8"), class = "FutureResult")
[10:19:27.018]     }, finally = {
[10:19:27.018]         if (!identical(...future.workdir, getwd())) 
[10:19:27.018]             setwd(...future.workdir)
[10:19:27.018]         {
[10:19:27.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:27.018]                 ...future.oldOptions$nwarnings <- NULL
[10:19:27.018]             }
[10:19:27.018]             base::options(...future.oldOptions)
[10:19:27.018]             if (.Platform$OS.type == "windows") {
[10:19:27.018]                 old_names <- names(...future.oldEnvVars)
[10:19:27.018]                 envs <- base::Sys.getenv()
[10:19:27.018]                 names <- names(envs)
[10:19:27.018]                 common <- intersect(names, old_names)
[10:19:27.018]                 added <- setdiff(names, old_names)
[10:19:27.018]                 removed <- setdiff(old_names, names)
[10:19:27.018]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:27.018]                   envs[common]]
[10:19:27.018]                 NAMES <- toupper(changed)
[10:19:27.018]                 args <- list()
[10:19:27.018]                 for (kk in seq_along(NAMES)) {
[10:19:27.018]                   name <- changed[[kk]]
[10:19:27.018]                   NAME <- NAMES[[kk]]
[10:19:27.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.018]                     next
[10:19:27.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:27.018]                 }
[10:19:27.018]                 NAMES <- toupper(added)
[10:19:27.018]                 for (kk in seq_along(NAMES)) {
[10:19:27.018]                   name <- added[[kk]]
[10:19:27.018]                   NAME <- NAMES[[kk]]
[10:19:27.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.018]                     next
[10:19:27.018]                   args[[name]] <- ""
[10:19:27.018]                 }
[10:19:27.018]                 NAMES <- toupper(removed)
[10:19:27.018]                 for (kk in seq_along(NAMES)) {
[10:19:27.018]                   name <- removed[[kk]]
[10:19:27.018]                   NAME <- NAMES[[kk]]
[10:19:27.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.018]                     next
[10:19:27.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:27.018]                 }
[10:19:27.018]                 if (length(args) > 0) 
[10:19:27.018]                   base::do.call(base::Sys.setenv, args = args)
[10:19:27.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:27.018]             }
[10:19:27.018]             else {
[10:19:27.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:27.018]             }
[10:19:27.018]             {
[10:19:27.018]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:27.018]                   0L) {
[10:19:27.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:27.018]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:27.018]                   base::options(opts)
[10:19:27.018]                 }
[10:19:27.018]                 {
[10:19:27.018]                   {
[10:19:27.018]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:27.018]                     NULL
[10:19:27.018]                   }
[10:19:27.018]                   options(future.plan = NULL)
[10:19:27.018]                   if (is.na(NA_character_)) 
[10:19:27.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:27.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:27.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:27.018]                     .init = FALSE)
[10:19:27.018]                 }
[10:19:27.018]             }
[10:19:27.018]         }
[10:19:27.018]     })
[10:19:27.018]     if (TRUE) {
[10:19:27.018]         base::sink(type = "output", split = FALSE)
[10:19:27.018]         if (TRUE) {
[10:19:27.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:27.018]         }
[10:19:27.018]         else {
[10:19:27.018]             ...future.result["stdout"] <- base::list(NULL)
[10:19:27.018]         }
[10:19:27.018]         base::close(...future.stdout)
[10:19:27.018]         ...future.stdout <- NULL
[10:19:27.018]     }
[10:19:27.018]     ...future.result$conditions <- ...future.conditions
[10:19:27.018]     ...future.result$finished <- base::Sys.time()
[10:19:27.018]     ...future.result
[10:19:27.018] }
[10:19:27.021] Exporting 5 global objects (651 bytes) to cluster node #1 ...
[10:19:27.021] Exporting ‘...future.FUN’ (32 bytes) to cluster node #1 ...
[10:19:27.021] Exporting ‘...future.FUN’ (32 bytes) to cluster node #1 ... DONE
[10:19:27.022] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:27.022] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:27.022] Exporting ‘...future.elements_ii’ (75 bytes) to cluster node #1 ...
[10:19:27.022] Exporting ‘...future.elements_ii’ (75 bytes) to cluster node #1 ... DONE
[10:19:27.022] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:27.023] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:27.023] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:27.023] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:27.023] Exporting 5 global objects (651 bytes) to cluster node #1 ... DONE
[10:19:27.024] MultisessionFuture started
[10:19:27.024] - Launch lazy future ... done
[10:19:27.024] run() for ‘MultisessionFuture’ ... done
[10:19:27.024] Created future:
[10:19:27.024] MultisessionFuture:
[10:19:27.024] Label: ‘future_Map-1’
[10:19:27.024] Expression:
[10:19:27.024] {
[10:19:27.024]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:27.024]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:27.024]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:27.024]         on.exit(options(oopts), add = TRUE)
[10:19:27.024]     }
[10:19:27.024]     {
[10:19:27.024]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:27.024]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:27.024]         do.call(mapply, args = args)
[10:19:27.024]     }
[10:19:27.024] }
[10:19:27.024] Lazy evaluation: FALSE
[10:19:27.024] Asynchronous evaluation: TRUE
[10:19:27.024] Local evaluation: TRUE
[10:19:27.024] Environment: R_GlobalEnv
[10:19:27.024] Capture standard output: TRUE
[10:19:27.024] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:27.024] Globals: 5 objects totaling 188 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 75 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:27.024] Packages: <none>
[10:19:27.024] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:27.024] Resolved: FALSE
[10:19:27.024] Value: <not collected>
[10:19:27.024] Conditions captured: <none>
[10:19:27.024] Early signaling: FALSE
[10:19:27.024] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:27.024] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:27.036] Chunk #1 of 2 ... DONE
[10:19:27.036] Chunk #2 of 2 ...
[10:19:27.036]  - Finding globals in '...' for chunk #2 ...
[10:19:27.036] getGlobalsAndPackages() ...
[10:19:27.036] Searching for globals...
[10:19:27.036] 
[10:19:27.037] Searching for globals ... DONE
[10:19:27.037] - globals: [0] <none>
[10:19:27.037] getGlobalsAndPackages() ... DONE
[10:19:27.037]    + additional globals found: [n=0] 
[10:19:27.037]    + additional namespaces needed: [n=0] 
[10:19:27.037]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:27.037]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:27.037]  - seeds: <none>
[10:19:27.037]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:27.037] getGlobalsAndPackages() ...
[10:19:27.037] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:27.038] Resolving globals: FALSE
[10:19:27.038] The total size of the 5 globals is 216 bytes (216 bytes)
[10:19:27.038] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 216 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (103 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:27.038] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:27.039] 
[10:19:27.039] getGlobalsAndPackages() ... DONE
[10:19:27.039] run() for ‘Future’ ...
[10:19:27.039] - state: ‘created’
[10:19:27.039] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:27.055] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:27.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:27.055]   - Field: ‘node’
[10:19:27.056]   - Field: ‘label’
[10:19:27.056]   - Field: ‘local’
[10:19:27.056]   - Field: ‘owner’
[10:19:27.056]   - Field: ‘envir’
[10:19:27.056]   - Field: ‘workers’
[10:19:27.056]   - Field: ‘packages’
[10:19:27.056]   - Field: ‘gc’
[10:19:27.056]   - Field: ‘conditions’
[10:19:27.056]   - Field: ‘persistent’
[10:19:27.056]   - Field: ‘expr’
[10:19:27.056]   - Field: ‘uuid’
[10:19:27.056]   - Field: ‘seed’
[10:19:27.057]   - Field: ‘version’
[10:19:27.057]   - Field: ‘result’
[10:19:27.057]   - Field: ‘asynchronous’
[10:19:27.057]   - Field: ‘calls’
[10:19:27.057]   - Field: ‘globals’
[10:19:27.057]   - Field: ‘stdout’
[10:19:27.057]   - Field: ‘earlySignal’
[10:19:27.057]   - Field: ‘lazy’
[10:19:27.057]   - Field: ‘state’
[10:19:27.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:27.057] - Launch lazy future ...
[10:19:27.058] Packages needed by the future expression (n = 0): <none>
[10:19:27.058] Packages needed by future strategies (n = 0): <none>
[10:19:27.058] {
[10:19:27.058]     {
[10:19:27.058]         {
[10:19:27.058]             ...future.startTime <- base::Sys.time()
[10:19:27.058]             {
[10:19:27.058]                 {
[10:19:27.058]                   {
[10:19:27.058]                     {
[10:19:27.058]                       base::local({
[10:19:27.058]                         has_future <- base::requireNamespace("future", 
[10:19:27.058]                           quietly = TRUE)
[10:19:27.058]                         if (has_future) {
[10:19:27.058]                           ns <- base::getNamespace("future")
[10:19:27.058]                           version <- ns[[".package"]][["version"]]
[10:19:27.058]                           if (is.null(version)) 
[10:19:27.058]                             version <- utils::packageVersion("future")
[10:19:27.058]                         }
[10:19:27.058]                         else {
[10:19:27.058]                           version <- NULL
[10:19:27.058]                         }
[10:19:27.058]                         if (!has_future || version < "1.8.0") {
[10:19:27.058]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:27.058]                             "", base::R.version$version.string), 
[10:19:27.058]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:27.058]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:27.058]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:27.058]                               "release", "version")], collapse = " "), 
[10:19:27.058]                             hostname = base::Sys.info()[["nodename"]])
[10:19:27.058]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:27.058]                             info)
[10:19:27.058]                           info <- base::paste(info, collapse = "; ")
[10:19:27.058]                           if (!has_future) {
[10:19:27.058]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:27.058]                               info)
[10:19:27.058]                           }
[10:19:27.058]                           else {
[10:19:27.058]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:27.058]                               info, version)
[10:19:27.058]                           }
[10:19:27.058]                           base::stop(msg)
[10:19:27.058]                         }
[10:19:27.058]                       })
[10:19:27.058]                     }
[10:19:27.058]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:27.058]                     base::options(mc.cores = 1L)
[10:19:27.058]                   }
[10:19:27.058]                   ...future.strategy.old <- future::plan("list")
[10:19:27.058]                   options(future.plan = NULL)
[10:19:27.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:27.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:27.058]                 }
[10:19:27.058]                 ...future.workdir <- getwd()
[10:19:27.058]             }
[10:19:27.058]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:27.058]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:27.058]         }
[10:19:27.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:27.058]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:27.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:27.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:27.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:27.058]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:27.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:27.058]             base::names(...future.oldOptions))
[10:19:27.058]     }
[10:19:27.058]     if (FALSE) {
[10:19:27.058]     }
[10:19:27.058]     else {
[10:19:27.058]         if (TRUE) {
[10:19:27.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:27.058]                 open = "w")
[10:19:27.058]         }
[10:19:27.058]         else {
[10:19:27.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:27.058]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:27.058]         }
[10:19:27.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:27.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:27.058]             base::sink(type = "output", split = FALSE)
[10:19:27.058]             base::close(...future.stdout)
[10:19:27.058]         }, add = TRUE)
[10:19:27.058]     }
[10:19:27.058]     ...future.frame <- base::sys.nframe()
[10:19:27.058]     ...future.conditions <- base::list()
[10:19:27.058]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:27.058]     if (FALSE) {
[10:19:27.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:27.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:27.058]     }
[10:19:27.058]     ...future.result <- base::tryCatch({
[10:19:27.058]         base::withCallingHandlers({
[10:19:27.058]             ...future.value <- base::withVisible(base::local({
[10:19:27.058]                 ...future.makeSendCondition <- base::local({
[10:19:27.058]                   sendCondition <- NULL
[10:19:27.058]                   function(frame = 1L) {
[10:19:27.058]                     if (is.function(sendCondition)) 
[10:19:27.058]                       return(sendCondition)
[10:19:27.058]                     ns <- getNamespace("parallel")
[10:19:27.058]                     if (exists("sendData", mode = "function", 
[10:19:27.058]                       envir = ns)) {
[10:19:27.058]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:27.058]                         envir = ns)
[10:19:27.058]                       envir <- sys.frame(frame)
[10:19:27.058]                       master <- NULL
[10:19:27.058]                       while (!identical(envir, .GlobalEnv) && 
[10:19:27.058]                         !identical(envir, emptyenv())) {
[10:19:27.058]                         if (exists("master", mode = "list", envir = envir, 
[10:19:27.058]                           inherits = FALSE)) {
[10:19:27.058]                           master <- get("master", mode = "list", 
[10:19:27.058]                             envir = envir, inherits = FALSE)
[10:19:27.058]                           if (inherits(master, c("SOCKnode", 
[10:19:27.058]                             "SOCK0node"))) {
[10:19:27.058]                             sendCondition <<- function(cond) {
[10:19:27.058]                               data <- list(type = "VALUE", value = cond, 
[10:19:27.058]                                 success = TRUE)
[10:19:27.058]                               parallel_sendData(master, data)
[10:19:27.058]                             }
[10:19:27.058]                             return(sendCondition)
[10:19:27.058]                           }
[10:19:27.058]                         }
[10:19:27.058]                         frame <- frame + 1L
[10:19:27.058]                         envir <- sys.frame(frame)
[10:19:27.058]                       }
[10:19:27.058]                     }
[10:19:27.058]                     sendCondition <<- function(cond) NULL
[10:19:27.058]                   }
[10:19:27.058]                 })
[10:19:27.058]                 withCallingHandlers({
[10:19:27.058]                   {
[10:19:27.058]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:27.058]                     if (!identical(...future.globals.maxSize.org, 
[10:19:27.058]                       ...future.globals.maxSize)) {
[10:19:27.058]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:27.058]                       on.exit(options(oopts), add = TRUE)
[10:19:27.058]                     }
[10:19:27.058]                     {
[10:19:27.058]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:27.058]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:27.058]                         USE.NAMES = FALSE)
[10:19:27.058]                       do.call(mapply, args = args)
[10:19:27.058]                     }
[10:19:27.058]                   }
[10:19:27.058]                 }, immediateCondition = function(cond) {
[10:19:27.058]                   sendCondition <- ...future.makeSendCondition()
[10:19:27.058]                   sendCondition(cond)
[10:19:27.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.058]                   {
[10:19:27.058]                     inherits <- base::inherits
[10:19:27.058]                     invokeRestart <- base::invokeRestart
[10:19:27.058]                     is.null <- base::is.null
[10:19:27.058]                     muffled <- FALSE
[10:19:27.058]                     if (inherits(cond, "message")) {
[10:19:27.058]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:27.058]                       if (muffled) 
[10:19:27.058]                         invokeRestart("muffleMessage")
[10:19:27.058]                     }
[10:19:27.058]                     else if (inherits(cond, "warning")) {
[10:19:27.058]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:27.058]                       if (muffled) 
[10:19:27.058]                         invokeRestart("muffleWarning")
[10:19:27.058]                     }
[10:19:27.058]                     else if (inherits(cond, "condition")) {
[10:19:27.058]                       if (!is.null(pattern)) {
[10:19:27.058]                         computeRestarts <- base::computeRestarts
[10:19:27.058]                         grepl <- base::grepl
[10:19:27.058]                         restarts <- computeRestarts(cond)
[10:19:27.058]                         for (restart in restarts) {
[10:19:27.058]                           name <- restart$name
[10:19:27.058]                           if (is.null(name)) 
[10:19:27.058]                             next
[10:19:27.058]                           if (!grepl(pattern, name)) 
[10:19:27.058]                             next
[10:19:27.058]                           invokeRestart(restart)
[10:19:27.058]                           muffled <- TRUE
[10:19:27.058]                           break
[10:19:27.058]                         }
[10:19:27.058]                       }
[10:19:27.058]                     }
[10:19:27.058]                     invisible(muffled)
[10:19:27.058]                   }
[10:19:27.058]                   muffleCondition(cond)
[10:19:27.058]                 })
[10:19:27.058]             }))
[10:19:27.058]             future::FutureResult(value = ...future.value$value, 
[10:19:27.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:27.058]                   ...future.rng), globalenv = if (FALSE) 
[10:19:27.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:27.058]                     ...future.globalenv.names))
[10:19:27.058]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:27.058]         }, condition = base::local({
[10:19:27.058]             c <- base::c
[10:19:27.058]             inherits <- base::inherits
[10:19:27.058]             invokeRestart <- base::invokeRestart
[10:19:27.058]             length <- base::length
[10:19:27.058]             list <- base::list
[10:19:27.058]             seq.int <- base::seq.int
[10:19:27.058]             signalCondition <- base::signalCondition
[10:19:27.058]             sys.calls <- base::sys.calls
[10:19:27.058]             `[[` <- base::`[[`
[10:19:27.058]             `+` <- base::`+`
[10:19:27.058]             `<<-` <- base::`<<-`
[10:19:27.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:27.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:27.058]                   3L)]
[10:19:27.058]             }
[10:19:27.058]             function(cond) {
[10:19:27.058]                 is_error <- inherits(cond, "error")
[10:19:27.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:27.058]                   NULL)
[10:19:27.058]                 if (is_error) {
[10:19:27.058]                   sessionInformation <- function() {
[10:19:27.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:27.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:27.058]                       search = base::search(), system = base::Sys.info())
[10:19:27.058]                   }
[10:19:27.058]                   ...future.conditions[[length(...future.conditions) + 
[10:19:27.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:27.058]                     cond$call), session = sessionInformation(), 
[10:19:27.058]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:27.058]                   signalCondition(cond)
[10:19:27.058]                 }
[10:19:27.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:27.058]                 "immediateCondition"))) {
[10:19:27.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:27.058]                   ...future.conditions[[length(...future.conditions) + 
[10:19:27.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:27.058]                   if (TRUE && !signal) {
[10:19:27.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.058]                     {
[10:19:27.058]                       inherits <- base::inherits
[10:19:27.058]                       invokeRestart <- base::invokeRestart
[10:19:27.058]                       is.null <- base::is.null
[10:19:27.058]                       muffled <- FALSE
[10:19:27.058]                       if (inherits(cond, "message")) {
[10:19:27.058]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:27.058]                         if (muffled) 
[10:19:27.058]                           invokeRestart("muffleMessage")
[10:19:27.058]                       }
[10:19:27.058]                       else if (inherits(cond, "warning")) {
[10:19:27.058]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:27.058]                         if (muffled) 
[10:19:27.058]                           invokeRestart("muffleWarning")
[10:19:27.058]                       }
[10:19:27.058]                       else if (inherits(cond, "condition")) {
[10:19:27.058]                         if (!is.null(pattern)) {
[10:19:27.058]                           computeRestarts <- base::computeRestarts
[10:19:27.058]                           grepl <- base::grepl
[10:19:27.058]                           restarts <- computeRestarts(cond)
[10:19:27.058]                           for (restart in restarts) {
[10:19:27.058]                             name <- restart$name
[10:19:27.058]                             if (is.null(name)) 
[10:19:27.058]                               next
[10:19:27.058]                             if (!grepl(pattern, name)) 
[10:19:27.058]                               next
[10:19:27.058]                             invokeRestart(restart)
[10:19:27.058]                             muffled <- TRUE
[10:19:27.058]                             break
[10:19:27.058]                           }
[10:19:27.058]                         }
[10:19:27.058]                       }
[10:19:27.058]                       invisible(muffled)
[10:19:27.058]                     }
[10:19:27.058]                     muffleCondition(cond, pattern = "^muffle")
[10:19:27.058]                   }
[10:19:27.058]                 }
[10:19:27.058]                 else {
[10:19:27.058]                   if (TRUE) {
[10:19:27.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.058]                     {
[10:19:27.058]                       inherits <- base::inherits
[10:19:27.058]                       invokeRestart <- base::invokeRestart
[10:19:27.058]                       is.null <- base::is.null
[10:19:27.058]                       muffled <- FALSE
[10:19:27.058]                       if (inherits(cond, "message")) {
[10:19:27.058]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:27.058]                         if (muffled) 
[10:19:27.058]                           invokeRestart("muffleMessage")
[10:19:27.058]                       }
[10:19:27.058]                       else if (inherits(cond, "warning")) {
[10:19:27.058]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:27.058]                         if (muffled) 
[10:19:27.058]                           invokeRestart("muffleWarning")
[10:19:27.058]                       }
[10:19:27.058]                       else if (inherits(cond, "condition")) {
[10:19:27.058]                         if (!is.null(pattern)) {
[10:19:27.058]                           computeRestarts <- base::computeRestarts
[10:19:27.058]                           grepl <- base::grepl
[10:19:27.058]                           restarts <- computeRestarts(cond)
[10:19:27.058]                           for (restart in restarts) {
[10:19:27.058]                             name <- restart$name
[10:19:27.058]                             if (is.null(name)) 
[10:19:27.058]                               next
[10:19:27.058]                             if (!grepl(pattern, name)) 
[10:19:27.058]                               next
[10:19:27.058]                             invokeRestart(restart)
[10:19:27.058]                             muffled <- TRUE
[10:19:27.058]                             break
[10:19:27.058]                           }
[10:19:27.058]                         }
[10:19:27.058]                       }
[10:19:27.058]                       invisible(muffled)
[10:19:27.058]                     }
[10:19:27.058]                     muffleCondition(cond, pattern = "^muffle")
[10:19:27.058]                   }
[10:19:27.058]                 }
[10:19:27.058]             }
[10:19:27.058]         }))
[10:19:27.058]     }, error = function(ex) {
[10:19:27.058]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:27.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:27.058]                 ...future.rng), started = ...future.startTime, 
[10:19:27.058]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:27.058]             version = "1.8"), class = "FutureResult")
[10:19:27.058]     }, finally = {
[10:19:27.058]         if (!identical(...future.workdir, getwd())) 
[10:19:27.058]             setwd(...future.workdir)
[10:19:27.058]         {
[10:19:27.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:27.058]                 ...future.oldOptions$nwarnings <- NULL
[10:19:27.058]             }
[10:19:27.058]             base::options(...future.oldOptions)
[10:19:27.058]             if (.Platform$OS.type == "windows") {
[10:19:27.058]                 old_names <- names(...future.oldEnvVars)
[10:19:27.058]                 envs <- base::Sys.getenv()
[10:19:27.058]                 names <- names(envs)
[10:19:27.058]                 common <- intersect(names, old_names)
[10:19:27.058]                 added <- setdiff(names, old_names)
[10:19:27.058]                 removed <- setdiff(old_names, names)
[10:19:27.058]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:27.058]                   envs[common]]
[10:19:27.058]                 NAMES <- toupper(changed)
[10:19:27.058]                 args <- list()
[10:19:27.058]                 for (kk in seq_along(NAMES)) {
[10:19:27.058]                   name <- changed[[kk]]
[10:19:27.058]                   NAME <- NAMES[[kk]]
[10:19:27.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.058]                     next
[10:19:27.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:27.058]                 }
[10:19:27.058]                 NAMES <- toupper(added)
[10:19:27.058]                 for (kk in seq_along(NAMES)) {
[10:19:27.058]                   name <- added[[kk]]
[10:19:27.058]                   NAME <- NAMES[[kk]]
[10:19:27.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.058]                     next
[10:19:27.058]                   args[[name]] <- ""
[10:19:27.058]                 }
[10:19:27.058]                 NAMES <- toupper(removed)
[10:19:27.058]                 for (kk in seq_along(NAMES)) {
[10:19:27.058]                   name <- removed[[kk]]
[10:19:27.058]                   NAME <- NAMES[[kk]]
[10:19:27.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.058]                     next
[10:19:27.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:27.058]                 }
[10:19:27.058]                 if (length(args) > 0) 
[10:19:27.058]                   base::do.call(base::Sys.setenv, args = args)
[10:19:27.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:27.058]             }
[10:19:27.058]             else {
[10:19:27.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:27.058]             }
[10:19:27.058]             {
[10:19:27.058]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:27.058]                   0L) {
[10:19:27.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:27.058]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:27.058]                   base::options(opts)
[10:19:27.058]                 }
[10:19:27.058]                 {
[10:19:27.058]                   {
[10:19:27.058]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:27.058]                     NULL
[10:19:27.058]                   }
[10:19:27.058]                   options(future.plan = NULL)
[10:19:27.058]                   if (is.na(NA_character_)) 
[10:19:27.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:27.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:27.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:27.058]                     .init = FALSE)
[10:19:27.058]                 }
[10:19:27.058]             }
[10:19:27.058]         }
[10:19:27.058]     })
[10:19:27.058]     if (TRUE) {
[10:19:27.058]         base::sink(type = "output", split = FALSE)
[10:19:27.058]         if (TRUE) {
[10:19:27.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:27.058]         }
[10:19:27.058]         else {
[10:19:27.058]             ...future.result["stdout"] <- base::list(NULL)
[10:19:27.058]         }
[10:19:27.058]         base::close(...future.stdout)
[10:19:27.058]         ...future.stdout <- NULL
[10:19:27.058]     }
[10:19:27.058]     ...future.result$conditions <- ...future.conditions
[10:19:27.058]     ...future.result$finished <- base::Sys.time()
[10:19:27.058]     ...future.result
[10:19:27.058] }
[10:19:27.061] Exporting 5 global objects (679 bytes) to cluster node #2 ...
[10:19:27.061] Exporting ‘...future.FUN’ (32 bytes) to cluster node #2 ...
[10:19:27.062] Exporting ‘...future.FUN’ (32 bytes) to cluster node #2 ... DONE
[10:19:27.062] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:27.062] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:27.062] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ...
[10:19:27.063] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ... DONE
[10:19:27.063] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:27.063] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:27.063] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:27.063] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:27.064] Exporting 5 global objects (679 bytes) to cluster node #2 ... DONE
[10:19:27.064] MultisessionFuture started
[10:19:27.064] - Launch lazy future ... done
[10:19:27.064] run() for ‘MultisessionFuture’ ... done
[10:19:27.064] Created future:
[10:19:27.064] MultisessionFuture:
[10:19:27.064] Label: ‘future_Map-2’
[10:19:27.064] Expression:
[10:19:27.064] {
[10:19:27.064]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:27.064]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:27.064]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:27.064]         on.exit(options(oopts), add = TRUE)
[10:19:27.064]     }
[10:19:27.064]     {
[10:19:27.064]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:27.064]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:27.064]         do.call(mapply, args = args)
[10:19:27.064]     }
[10:19:27.064] }
[10:19:27.064] Lazy evaluation: FALSE
[10:19:27.064] Asynchronous evaluation: TRUE
[10:19:27.064] Local evaluation: TRUE
[10:19:27.064] Environment: R_GlobalEnv
[10:19:27.064] Capture standard output: TRUE
[10:19:27.064] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:27.064] Globals: 5 objects totaling 216 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:27.064] Packages: <none>
[10:19:27.064] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:27.064] Resolved: FALSE
[10:19:27.064] Value: <not collected>
[10:19:27.064] Conditions captured: <none>
[10:19:27.064] Early signaling: FALSE
[10:19:27.064] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:27.064] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:27.076] Chunk #2 of 2 ... DONE
[10:19:27.076] Launching 2 futures (chunks) ... DONE
[10:19:27.076] Resolving 2 futures (chunks) ...
[10:19:27.076] resolve() on list ...
[10:19:27.076]  recursive: 0
[10:19:27.076]  length: 2
[10:19:27.076] 
[10:19:27.077] receiveMessageFromWorker() for ClusterFuture ...
[10:19:27.077] - Validating connection of MultisessionFuture
[10:19:27.077] - received message: FutureResult
[10:19:27.077] - Received FutureResult
[10:19:27.077] - Erased future from FutureRegistry
[10:19:27.078] result() for ClusterFuture ...
[10:19:27.078] - result already collected: FutureResult
[10:19:27.078] result() for ClusterFuture ... done
[10:19:27.078] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:27.078] Future #1
[10:19:27.078] result() for ClusterFuture ...
[10:19:27.078] - result already collected: FutureResult
[10:19:27.078] result() for ClusterFuture ... done
[10:19:27.078] result() for ClusterFuture ...
[10:19:27.078] - result already collected: FutureResult
[10:19:27.078] result() for ClusterFuture ... done
[10:19:27.078] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:27.079] - nx: 2
[10:19:27.079] - relay: TRUE
[10:19:27.079] - stdout: TRUE
[10:19:27.079] - signal: TRUE
[10:19:27.079] - resignal: FALSE
[10:19:27.079] - force: TRUE
[10:19:27.079] - relayed: [n=2] FALSE, FALSE
[10:19:27.079] - queued futures: [n=2] FALSE, FALSE
[10:19:27.079]  - until=1
[10:19:27.079]  - relaying element #1
[10:19:27.079] result() for ClusterFuture ...
[10:19:27.079] - result already collected: FutureResult
[10:19:27.079] result() for ClusterFuture ... done
[10:19:27.080] result() for ClusterFuture ...
[10:19:27.080] - result already collected: FutureResult
[10:19:27.080] result() for ClusterFuture ... done
[10:19:27.080] result() for ClusterFuture ...
[10:19:27.080] - result already collected: FutureResult
[10:19:27.080] result() for ClusterFuture ... done
[10:19:27.080] result() for ClusterFuture ...
[10:19:27.080] - result already collected: FutureResult
[10:19:27.080] result() for ClusterFuture ... done
[10:19:27.080] - relayed: [n=2] TRUE, FALSE
[10:19:27.080] - queued futures: [n=2] TRUE, FALSE
[10:19:27.080] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:27.081]  length: 1 (resolved future 1)
[10:19:27.106] receiveMessageFromWorker() for ClusterFuture ...
[10:19:27.106] - Validating connection of MultisessionFuture
[10:19:27.106] - received message: FutureResult
[10:19:27.106] - Received FutureResult
[10:19:27.107] - Erased future from FutureRegistry
[10:19:27.107] result() for ClusterFuture ...
[10:19:27.107] - result already collected: FutureResult
[10:19:27.107] result() for ClusterFuture ... done
[10:19:27.107] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:27.107] Future #2
[10:19:27.107] result() for ClusterFuture ...
[10:19:27.107] - result already collected: FutureResult
[10:19:27.107] result() for ClusterFuture ... done
[10:19:27.107] result() for ClusterFuture ...
[10:19:27.107] - result already collected: FutureResult
[10:19:27.107] result() for ClusterFuture ... done
[10:19:27.108] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:27.108] - nx: 2
[10:19:27.108] - relay: TRUE
[10:19:27.108] - stdout: TRUE
[10:19:27.108] - signal: TRUE
[10:19:27.108] - resignal: FALSE
[10:19:27.108] - force: TRUE
[10:19:27.108] - relayed: [n=2] TRUE, FALSE
[10:19:27.108] - queued futures: [n=2] TRUE, FALSE
[10:19:27.108]  - until=2
[10:19:27.108]  - relaying element #2
[10:19:27.109] result() for ClusterFuture ...
[10:19:27.109] - result already collected: FutureResult
[10:19:27.109] result() for ClusterFuture ... done
[10:19:27.109] result() for ClusterFuture ...
[10:19:27.109] - result already collected: FutureResult
[10:19:27.109] result() for ClusterFuture ... done
[10:19:27.109] result() for ClusterFuture ...
[10:19:27.109] - result already collected: FutureResult
[10:19:27.109] result() for ClusterFuture ... done
[10:19:27.109] result() for ClusterFuture ...
[10:19:27.109] - result already collected: FutureResult
[10:19:27.109] result() for ClusterFuture ... done
[10:19:27.110] - relayed: [n=2] TRUE, TRUE
[10:19:27.110] - queued futures: [n=2] TRUE, TRUE
[10:19:27.110] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:27.110]  length: 0 (resolved future 2)
[10:19:27.110] Relaying remaining futures
[10:19:27.110] signalConditionsASAP(NULL, pos=0) ...
[10:19:27.110] - nx: 2
[10:19:27.110] - relay: TRUE
[10:19:27.110] - stdout: TRUE
[10:19:27.110] - signal: TRUE
[10:19:27.110] - resignal: FALSE
[10:19:27.110] - force: TRUE
[10:19:27.111] - relayed: [n=2] TRUE, TRUE
[10:19:27.111] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:27.111] - relayed: [n=2] TRUE, TRUE
[10:19:27.111] - queued futures: [n=2] TRUE, TRUE
[10:19:27.111] signalConditionsASAP(NULL, pos=0) ... done
[10:19:27.111] resolve() on list ... DONE
[10:19:27.111] result() for ClusterFuture ...
[10:19:27.111] - result already collected: FutureResult
[10:19:27.111] result() for ClusterFuture ... done
[10:19:27.111] result() for ClusterFuture ...
[10:19:27.111] - result already collected: FutureResult
[10:19:27.111] result() for ClusterFuture ... done
[10:19:27.112] result() for ClusterFuture ...
[10:19:27.112] - result already collected: FutureResult
[10:19:27.112] result() for ClusterFuture ... done
[10:19:27.112] result() for ClusterFuture ...
[10:19:27.112] - result already collected: FutureResult
[10:19:27.112] result() for ClusterFuture ... done
[10:19:27.112]  - Number of value chunks collected: 2
[10:19:27.112] Resolving 2 futures (chunks) ... DONE
[10:19:27.112] Reducing values from 2 chunks ...
[10:19:27.112]  - Number of values collected after concatenation: 3
[10:19:27.112]  - Number of values expected: 3
[10:19:27.113] Reducing values from 2 chunks ... DONE
[10:19:27.113] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[10:19:27.113] future_mapply() ...
[10:19:27.115] Number of chunks: 2
[10:19:27.115] getGlobalsAndPackagesXApply() ...
[10:19:27.115]  - future.globals: TRUE
[10:19:27.115] getGlobalsAndPackages() ...
[10:19:27.115] Searching for globals...
[10:19:27.116] - globals found: [1] ‘FUN’
[10:19:27.116] Searching for globals ... DONE
[10:19:27.116] Resolving globals: FALSE
[10:19:27.117] The total size of the 1 globals is 185 bytes (185 bytes)
[10:19:27.117] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:19:27.117] - globals: [1] ‘FUN’
[10:19:27.117] 
[10:19:27.117] getGlobalsAndPackages() ... DONE
[10:19:27.117]  - globals found/used: [n=1] ‘FUN’
[10:19:27.118]  - needed namespaces: [n=0] 
[10:19:27.118] Finding globals ... DONE
[10:19:27.118] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:19:27.118] List of 2
[10:19:27.118]  $ ...future.FUN:function (x)  
[10:19:27.118]  $ MoreArgs     : NULL
[10:19:27.118]  - attr(*, "where")=List of 2
[10:19:27.118]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:19:27.118]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:19:27.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:19:27.118]  - attr(*, "resolved")= logi FALSE
[10:19:27.118]  - attr(*, "total_size")= num NA
[10:19:27.120] Packages to be attached in all futures: [n=0] 
[10:19:27.121] getGlobalsAndPackagesXApply() ... DONE
[10:19:27.121] Number of futures (= number of chunks): 2
[10:19:27.121] Launching 2 futures (chunks) ...
[10:19:27.121] Chunk #1 of 2 ...
[10:19:27.121]  - Finding globals in '...' for chunk #1 ...
[10:19:27.121] getGlobalsAndPackages() ...
[10:19:27.121] Searching for globals...
[10:19:27.122] 
[10:19:27.122] Searching for globals ... DONE
[10:19:27.122] - globals: [0] <none>
[10:19:27.122] getGlobalsAndPackages() ... DONE
[10:19:27.122]    + additional globals found: [n=0] 
[10:19:27.122]    + additional namespaces needed: [n=0] 
[10:19:27.122]  - Finding globals in '...' for chunk #1 ... DONE
[10:19:27.122]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:27.122]  - seeds: <none>
[10:19:27.122]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:27.122] getGlobalsAndPackages() ...
[10:19:27.123] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:27.123] Resolving globals: FALSE
[10:19:27.123] The total size of the 5 globals is 363 bytes (363 bytes)
[10:19:27.123] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:27.124] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:27.124] 
[10:19:27.124] getGlobalsAndPackages() ... DONE
[10:19:27.124] run() for ‘Future’ ...
[10:19:27.124] - state: ‘created’
[10:19:27.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:27.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:27.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:27.138]   - Field: ‘node’
[10:19:27.138]   - Field: ‘label’
[10:19:27.138]   - Field: ‘local’
[10:19:27.138]   - Field: ‘owner’
[10:19:27.139]   - Field: ‘envir’
[10:19:27.139]   - Field: ‘workers’
[10:19:27.139]   - Field: ‘packages’
[10:19:27.139]   - Field: ‘gc’
[10:19:27.139]   - Field: ‘conditions’
[10:19:27.139]   - Field: ‘persistent’
[10:19:27.139]   - Field: ‘expr’
[10:19:27.139]   - Field: ‘uuid’
[10:19:27.139]   - Field: ‘seed’
[10:19:27.139]   - Field: ‘version’
[10:19:27.139]   - Field: ‘result’
[10:19:27.140]   - Field: ‘asynchronous’
[10:19:27.140]   - Field: ‘calls’
[10:19:27.140]   - Field: ‘globals’
[10:19:27.140]   - Field: ‘stdout’
[10:19:27.140]   - Field: ‘earlySignal’
[10:19:27.140]   - Field: ‘lazy’
[10:19:27.140]   - Field: ‘state’
[10:19:27.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:27.140] - Launch lazy future ...
[10:19:27.141] Packages needed by the future expression (n = 0): <none>
[10:19:27.141] Packages needed by future strategies (n = 0): <none>
[10:19:27.141] {
[10:19:27.141]     {
[10:19:27.141]         {
[10:19:27.141]             ...future.startTime <- base::Sys.time()
[10:19:27.141]             {
[10:19:27.141]                 {
[10:19:27.141]                   {
[10:19:27.141]                     {
[10:19:27.141]                       base::local({
[10:19:27.141]                         has_future <- base::requireNamespace("future", 
[10:19:27.141]                           quietly = TRUE)
[10:19:27.141]                         if (has_future) {
[10:19:27.141]                           ns <- base::getNamespace("future")
[10:19:27.141]                           version <- ns[[".package"]][["version"]]
[10:19:27.141]                           if (is.null(version)) 
[10:19:27.141]                             version <- utils::packageVersion("future")
[10:19:27.141]                         }
[10:19:27.141]                         else {
[10:19:27.141]                           version <- NULL
[10:19:27.141]                         }
[10:19:27.141]                         if (!has_future || version < "1.8.0") {
[10:19:27.141]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:27.141]                             "", base::R.version$version.string), 
[10:19:27.141]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:27.141]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:27.141]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:27.141]                               "release", "version")], collapse = " "), 
[10:19:27.141]                             hostname = base::Sys.info()[["nodename"]])
[10:19:27.141]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:27.141]                             info)
[10:19:27.141]                           info <- base::paste(info, collapse = "; ")
[10:19:27.141]                           if (!has_future) {
[10:19:27.141]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:27.141]                               info)
[10:19:27.141]                           }
[10:19:27.141]                           else {
[10:19:27.141]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:27.141]                               info, version)
[10:19:27.141]                           }
[10:19:27.141]                           base::stop(msg)
[10:19:27.141]                         }
[10:19:27.141]                       })
[10:19:27.141]                     }
[10:19:27.141]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:27.141]                     base::options(mc.cores = 1L)
[10:19:27.141]                   }
[10:19:27.141]                   ...future.strategy.old <- future::plan("list")
[10:19:27.141]                   options(future.plan = NULL)
[10:19:27.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:27.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:27.141]                 }
[10:19:27.141]                 ...future.workdir <- getwd()
[10:19:27.141]             }
[10:19:27.141]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:27.141]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:27.141]         }
[10:19:27.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:27.141]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:27.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:27.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:27.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:27.141]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:27.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:27.141]             base::names(...future.oldOptions))
[10:19:27.141]     }
[10:19:27.141]     if (FALSE) {
[10:19:27.141]     }
[10:19:27.141]     else {
[10:19:27.141]         if (TRUE) {
[10:19:27.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:27.141]                 open = "w")
[10:19:27.141]         }
[10:19:27.141]         else {
[10:19:27.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:27.141]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:27.141]         }
[10:19:27.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:27.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:27.141]             base::sink(type = "output", split = FALSE)
[10:19:27.141]             base::close(...future.stdout)
[10:19:27.141]         }, add = TRUE)
[10:19:27.141]     }
[10:19:27.141]     ...future.frame <- base::sys.nframe()
[10:19:27.141]     ...future.conditions <- base::list()
[10:19:27.141]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:27.141]     if (FALSE) {
[10:19:27.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:27.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:27.141]     }
[10:19:27.141]     ...future.result <- base::tryCatch({
[10:19:27.141]         base::withCallingHandlers({
[10:19:27.141]             ...future.value <- base::withVisible(base::local({
[10:19:27.141]                 ...future.makeSendCondition <- base::local({
[10:19:27.141]                   sendCondition <- NULL
[10:19:27.141]                   function(frame = 1L) {
[10:19:27.141]                     if (is.function(sendCondition)) 
[10:19:27.141]                       return(sendCondition)
[10:19:27.141]                     ns <- getNamespace("parallel")
[10:19:27.141]                     if (exists("sendData", mode = "function", 
[10:19:27.141]                       envir = ns)) {
[10:19:27.141]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:27.141]                         envir = ns)
[10:19:27.141]                       envir <- sys.frame(frame)
[10:19:27.141]                       master <- NULL
[10:19:27.141]                       while (!identical(envir, .GlobalEnv) && 
[10:19:27.141]                         !identical(envir, emptyenv())) {
[10:19:27.141]                         if (exists("master", mode = "list", envir = envir, 
[10:19:27.141]                           inherits = FALSE)) {
[10:19:27.141]                           master <- get("master", mode = "list", 
[10:19:27.141]                             envir = envir, inherits = FALSE)
[10:19:27.141]                           if (inherits(master, c("SOCKnode", 
[10:19:27.141]                             "SOCK0node"))) {
[10:19:27.141]                             sendCondition <<- function(cond) {
[10:19:27.141]                               data <- list(type = "VALUE", value = cond, 
[10:19:27.141]                                 success = TRUE)
[10:19:27.141]                               parallel_sendData(master, data)
[10:19:27.141]                             }
[10:19:27.141]                             return(sendCondition)
[10:19:27.141]                           }
[10:19:27.141]                         }
[10:19:27.141]                         frame <- frame + 1L
[10:19:27.141]                         envir <- sys.frame(frame)
[10:19:27.141]                       }
[10:19:27.141]                     }
[10:19:27.141]                     sendCondition <<- function(cond) NULL
[10:19:27.141]                   }
[10:19:27.141]                 })
[10:19:27.141]                 withCallingHandlers({
[10:19:27.141]                   {
[10:19:27.141]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:27.141]                     if (!identical(...future.globals.maxSize.org, 
[10:19:27.141]                       ...future.globals.maxSize)) {
[10:19:27.141]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:27.141]                       on.exit(options(oopts), add = TRUE)
[10:19:27.141]                     }
[10:19:27.141]                     {
[10:19:27.141]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:27.141]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:27.141]                         USE.NAMES = FALSE)
[10:19:27.141]                       do.call(mapply, args = args)
[10:19:27.141]                     }
[10:19:27.141]                   }
[10:19:27.141]                 }, immediateCondition = function(cond) {
[10:19:27.141]                   sendCondition <- ...future.makeSendCondition()
[10:19:27.141]                   sendCondition(cond)
[10:19:27.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.141]                   {
[10:19:27.141]                     inherits <- base::inherits
[10:19:27.141]                     invokeRestart <- base::invokeRestart
[10:19:27.141]                     is.null <- base::is.null
[10:19:27.141]                     muffled <- FALSE
[10:19:27.141]                     if (inherits(cond, "message")) {
[10:19:27.141]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:27.141]                       if (muffled) 
[10:19:27.141]                         invokeRestart("muffleMessage")
[10:19:27.141]                     }
[10:19:27.141]                     else if (inherits(cond, "warning")) {
[10:19:27.141]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:27.141]                       if (muffled) 
[10:19:27.141]                         invokeRestart("muffleWarning")
[10:19:27.141]                     }
[10:19:27.141]                     else if (inherits(cond, "condition")) {
[10:19:27.141]                       if (!is.null(pattern)) {
[10:19:27.141]                         computeRestarts <- base::computeRestarts
[10:19:27.141]                         grepl <- base::grepl
[10:19:27.141]                         restarts <- computeRestarts(cond)
[10:19:27.141]                         for (restart in restarts) {
[10:19:27.141]                           name <- restart$name
[10:19:27.141]                           if (is.null(name)) 
[10:19:27.141]                             next
[10:19:27.141]                           if (!grepl(pattern, name)) 
[10:19:27.141]                             next
[10:19:27.141]                           invokeRestart(restart)
[10:19:27.141]                           muffled <- TRUE
[10:19:27.141]                           break
[10:19:27.141]                         }
[10:19:27.141]                       }
[10:19:27.141]                     }
[10:19:27.141]                     invisible(muffled)
[10:19:27.141]                   }
[10:19:27.141]                   muffleCondition(cond)
[10:19:27.141]                 })
[10:19:27.141]             }))
[10:19:27.141]             future::FutureResult(value = ...future.value$value, 
[10:19:27.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:27.141]                   ...future.rng), globalenv = if (FALSE) 
[10:19:27.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:27.141]                     ...future.globalenv.names))
[10:19:27.141]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:27.141]         }, condition = base::local({
[10:19:27.141]             c <- base::c
[10:19:27.141]             inherits <- base::inherits
[10:19:27.141]             invokeRestart <- base::invokeRestart
[10:19:27.141]             length <- base::length
[10:19:27.141]             list <- base::list
[10:19:27.141]             seq.int <- base::seq.int
[10:19:27.141]             signalCondition <- base::signalCondition
[10:19:27.141]             sys.calls <- base::sys.calls
[10:19:27.141]             `[[` <- base::`[[`
[10:19:27.141]             `+` <- base::`+`
[10:19:27.141]             `<<-` <- base::`<<-`
[10:19:27.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:27.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:27.141]                   3L)]
[10:19:27.141]             }
[10:19:27.141]             function(cond) {
[10:19:27.141]                 is_error <- inherits(cond, "error")
[10:19:27.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:27.141]                   NULL)
[10:19:27.141]                 if (is_error) {
[10:19:27.141]                   sessionInformation <- function() {
[10:19:27.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:27.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:27.141]                       search = base::search(), system = base::Sys.info())
[10:19:27.141]                   }
[10:19:27.141]                   ...future.conditions[[length(...future.conditions) + 
[10:19:27.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:27.141]                     cond$call), session = sessionInformation(), 
[10:19:27.141]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:27.141]                   signalCondition(cond)
[10:19:27.141]                 }
[10:19:27.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:27.141]                 "immediateCondition"))) {
[10:19:27.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:27.141]                   ...future.conditions[[length(...future.conditions) + 
[10:19:27.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:27.141]                   if (TRUE && !signal) {
[10:19:27.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.141]                     {
[10:19:27.141]                       inherits <- base::inherits
[10:19:27.141]                       invokeRestart <- base::invokeRestart
[10:19:27.141]                       is.null <- base::is.null
[10:19:27.141]                       muffled <- FALSE
[10:19:27.141]                       if (inherits(cond, "message")) {
[10:19:27.141]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:27.141]                         if (muffled) 
[10:19:27.141]                           invokeRestart("muffleMessage")
[10:19:27.141]                       }
[10:19:27.141]                       else if (inherits(cond, "warning")) {
[10:19:27.141]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:27.141]                         if (muffled) 
[10:19:27.141]                           invokeRestart("muffleWarning")
[10:19:27.141]                       }
[10:19:27.141]                       else if (inherits(cond, "condition")) {
[10:19:27.141]                         if (!is.null(pattern)) {
[10:19:27.141]                           computeRestarts <- base::computeRestarts
[10:19:27.141]                           grepl <- base::grepl
[10:19:27.141]                           restarts <- computeRestarts(cond)
[10:19:27.141]                           for (restart in restarts) {
[10:19:27.141]                             name <- restart$name
[10:19:27.141]                             if (is.null(name)) 
[10:19:27.141]                               next
[10:19:27.141]                             if (!grepl(pattern, name)) 
[10:19:27.141]                               next
[10:19:27.141]                             invokeRestart(restart)
[10:19:27.141]                             muffled <- TRUE
[10:19:27.141]                             break
[10:19:27.141]                           }
[10:19:27.141]                         }
[10:19:27.141]                       }
[10:19:27.141]                       invisible(muffled)
[10:19:27.141]                     }
[10:19:27.141]                     muffleCondition(cond, pattern = "^muffle")
[10:19:27.141]                   }
[10:19:27.141]                 }
[10:19:27.141]                 else {
[10:19:27.141]                   if (TRUE) {
[10:19:27.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.141]                     {
[10:19:27.141]                       inherits <- base::inherits
[10:19:27.141]                       invokeRestart <- base::invokeRestart
[10:19:27.141]                       is.null <- base::is.null
[10:19:27.141]                       muffled <- FALSE
[10:19:27.141]                       if (inherits(cond, "message")) {
[10:19:27.141]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:27.141]                         if (muffled) 
[10:19:27.141]                           invokeRestart("muffleMessage")
[10:19:27.141]                       }
[10:19:27.141]                       else if (inherits(cond, "warning")) {
[10:19:27.141]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:27.141]                         if (muffled) 
[10:19:27.141]                           invokeRestart("muffleWarning")
[10:19:27.141]                       }
[10:19:27.141]                       else if (inherits(cond, "condition")) {
[10:19:27.141]                         if (!is.null(pattern)) {
[10:19:27.141]                           computeRestarts <- base::computeRestarts
[10:19:27.141]                           grepl <- base::grepl
[10:19:27.141]                           restarts <- computeRestarts(cond)
[10:19:27.141]                           for (restart in restarts) {
[10:19:27.141]                             name <- restart$name
[10:19:27.141]                             if (is.null(name)) 
[10:19:27.141]                               next
[10:19:27.141]                             if (!grepl(pattern, name)) 
[10:19:27.141]                               next
[10:19:27.141]                             invokeRestart(restart)
[10:19:27.141]                             muffled <- TRUE
[10:19:27.141]                             break
[10:19:27.141]                           }
[10:19:27.141]                         }
[10:19:27.141]                       }
[10:19:27.141]                       invisible(muffled)
[10:19:27.141]                     }
[10:19:27.141]                     muffleCondition(cond, pattern = "^muffle")
[10:19:27.141]                   }
[10:19:27.141]                 }
[10:19:27.141]             }
[10:19:27.141]         }))
[10:19:27.141]     }, error = function(ex) {
[10:19:27.141]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:27.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:27.141]                 ...future.rng), started = ...future.startTime, 
[10:19:27.141]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:27.141]             version = "1.8"), class = "FutureResult")
[10:19:27.141]     }, finally = {
[10:19:27.141]         if (!identical(...future.workdir, getwd())) 
[10:19:27.141]             setwd(...future.workdir)
[10:19:27.141]         {
[10:19:27.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:27.141]                 ...future.oldOptions$nwarnings <- NULL
[10:19:27.141]             }
[10:19:27.141]             base::options(...future.oldOptions)
[10:19:27.141]             if (.Platform$OS.type == "windows") {
[10:19:27.141]                 old_names <- names(...future.oldEnvVars)
[10:19:27.141]                 envs <- base::Sys.getenv()
[10:19:27.141]                 names <- names(envs)
[10:19:27.141]                 common <- intersect(names, old_names)
[10:19:27.141]                 added <- setdiff(names, old_names)
[10:19:27.141]                 removed <- setdiff(old_names, names)
[10:19:27.141]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:27.141]                   envs[common]]
[10:19:27.141]                 NAMES <- toupper(changed)
[10:19:27.141]                 args <- list()
[10:19:27.141]                 for (kk in seq_along(NAMES)) {
[10:19:27.141]                   name <- changed[[kk]]
[10:19:27.141]                   NAME <- NAMES[[kk]]
[10:19:27.141]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.141]                     next
[10:19:27.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:27.141]                 }
[10:19:27.141]                 NAMES <- toupper(added)
[10:19:27.141]                 for (kk in seq_along(NAMES)) {
[10:19:27.141]                   name <- added[[kk]]
[10:19:27.141]                   NAME <- NAMES[[kk]]
[10:19:27.141]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.141]                     next
[10:19:27.141]                   args[[name]] <- ""
[10:19:27.141]                 }
[10:19:27.141]                 NAMES <- toupper(removed)
[10:19:27.141]                 for (kk in seq_along(NAMES)) {
[10:19:27.141]                   name <- removed[[kk]]
[10:19:27.141]                   NAME <- NAMES[[kk]]
[10:19:27.141]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.141]                     next
[10:19:27.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:27.141]                 }
[10:19:27.141]                 if (length(args) > 0) 
[10:19:27.141]                   base::do.call(base::Sys.setenv, args = args)
[10:19:27.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:27.141]             }
[10:19:27.141]             else {
[10:19:27.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:27.141]             }
[10:19:27.141]             {
[10:19:27.141]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:27.141]                   0L) {
[10:19:27.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:27.141]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:27.141]                   base::options(opts)
[10:19:27.141]                 }
[10:19:27.141]                 {
[10:19:27.141]                   {
[10:19:27.141]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:27.141]                     NULL
[10:19:27.141]                   }
[10:19:27.141]                   options(future.plan = NULL)
[10:19:27.141]                   if (is.na(NA_character_)) 
[10:19:27.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:27.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:27.141]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:27.141]                     .init = FALSE)
[10:19:27.141]                 }
[10:19:27.141]             }
[10:19:27.141]         }
[10:19:27.141]     })
[10:19:27.141]     if (TRUE) {
[10:19:27.141]         base::sink(type = "output", split = FALSE)
[10:19:27.141]         if (TRUE) {
[10:19:27.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:27.141]         }
[10:19:27.141]         else {
[10:19:27.141]             ...future.result["stdout"] <- base::list(NULL)
[10:19:27.141]         }
[10:19:27.141]         base::close(...future.stdout)
[10:19:27.141]         ...future.stdout <- NULL
[10:19:27.141]     }
[10:19:27.141]     ...future.result$conditions <- ...future.conditions
[10:19:27.141]     ...future.result$finished <- base::Sys.time()
[10:19:27.141]     ...future.result
[10:19:27.141] }
[10:19:27.144] Exporting 5 global objects (800 bytes) to cluster node #1 ...
[10:19:27.144] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:19:27.145] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:19:27.145] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:19:27.145] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:19:27.145] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #1 ...
[10:19:27.146] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #1 ... DONE
[10:19:27.146] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:19:27.146] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:19:27.146] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:19:27.147] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:19:27.147] Exporting 5 global objects (800 bytes) to cluster node #1 ... DONE
[10:19:27.147] MultisessionFuture started
[10:19:27.147] - Launch lazy future ... done
[10:19:27.147] run() for ‘MultisessionFuture’ ... done
[10:19:27.148] Created future:
[10:19:27.148] MultisessionFuture:
[10:19:27.148] Label: ‘future_mapply-1’
[10:19:27.148] Expression:
[10:19:27.148] {
[10:19:27.148]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:27.148]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:27.148]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:27.148]         on.exit(options(oopts), add = TRUE)
[10:19:27.148]     }
[10:19:27.148]     {
[10:19:27.148]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:27.148]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:27.148]         do.call(mapply, args = args)
[10:19:27.148]     }
[10:19:27.148] }
[10:19:27.148] Lazy evaluation: FALSE
[10:19:27.148] Asynchronous evaluation: TRUE
[10:19:27.148] Local evaluation: TRUE
[10:19:27.148] Environment: R_GlobalEnv
[10:19:27.148] Capture standard output: TRUE
[10:19:27.148] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:27.148] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:27.148] Packages: <none>
[10:19:27.148] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:27.148] Resolved: FALSE
[10:19:27.148] Value: <not collected>
[10:19:27.148] Conditions captured: <none>
[10:19:27.148] Early signaling: FALSE
[10:19:27.148] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:27.148] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:27.159] Chunk #1 of 2 ... DONE
[10:19:27.159] Chunk #2 of 2 ...
[10:19:27.159]  - Finding globals in '...' for chunk #2 ...
[10:19:27.160] getGlobalsAndPackages() ...
[10:19:27.160] Searching for globals...
[10:19:27.160] 
[10:19:27.160] Searching for globals ... DONE
[10:19:27.160] - globals: [0] <none>
[10:19:27.160] getGlobalsAndPackages() ... DONE
[10:19:27.160]    + additional globals found: [n=0] 
[10:19:27.160]    + additional namespaces needed: [n=0] 
[10:19:27.160]  - Finding globals in '...' for chunk #2 ... DONE
[10:19:27.161]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:19:27.161]  - seeds: <none>
[10:19:27.161]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:27.161] getGlobalsAndPackages() ...
[10:19:27.161] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:27.161] Resolving globals: FALSE
[10:19:27.161] The total size of the 5 globals is 363 bytes (363 bytes)
[10:19:27.162] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:19:27.162] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:19:27.162] 
[10:19:27.162] getGlobalsAndPackages() ... DONE
[10:19:27.162] run() for ‘Future’ ...
[10:19:27.163] - state: ‘created’
[10:19:27.163] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:19:27.179] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:27.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:19:27.180]   - Field: ‘node’
[10:19:27.180]   - Field: ‘label’
[10:19:27.180]   - Field: ‘local’
[10:19:27.180]   - Field: ‘owner’
[10:19:27.180]   - Field: ‘envir’
[10:19:27.180]   - Field: ‘workers’
[10:19:27.180]   - Field: ‘packages’
[10:19:27.180]   - Field: ‘gc’
[10:19:27.180]   - Field: ‘conditions’
[10:19:27.181]   - Field: ‘persistent’
[10:19:27.181]   - Field: ‘expr’
[10:19:27.181]   - Field: ‘uuid’
[10:19:27.181]   - Field: ‘seed’
[10:19:27.181]   - Field: ‘version’
[10:19:27.181]   - Field: ‘result’
[10:19:27.181]   - Field: ‘asynchronous’
[10:19:27.181]   - Field: ‘calls’
[10:19:27.181]   - Field: ‘globals’
[10:19:27.181]   - Field: ‘stdout’
[10:19:27.181]   - Field: ‘earlySignal’
[10:19:27.181]   - Field: ‘lazy’
[10:19:27.182]   - Field: ‘state’
[10:19:27.182] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:19:27.182] - Launch lazy future ...
[10:19:27.182] Packages needed by the future expression (n = 0): <none>
[10:19:27.182] Packages needed by future strategies (n = 0): <none>
[10:19:27.183] {
[10:19:27.183]     {
[10:19:27.183]         {
[10:19:27.183]             ...future.startTime <- base::Sys.time()
[10:19:27.183]             {
[10:19:27.183]                 {
[10:19:27.183]                   {
[10:19:27.183]                     {
[10:19:27.183]                       base::local({
[10:19:27.183]                         has_future <- base::requireNamespace("future", 
[10:19:27.183]                           quietly = TRUE)
[10:19:27.183]                         if (has_future) {
[10:19:27.183]                           ns <- base::getNamespace("future")
[10:19:27.183]                           version <- ns[[".package"]][["version"]]
[10:19:27.183]                           if (is.null(version)) 
[10:19:27.183]                             version <- utils::packageVersion("future")
[10:19:27.183]                         }
[10:19:27.183]                         else {
[10:19:27.183]                           version <- NULL
[10:19:27.183]                         }
[10:19:27.183]                         if (!has_future || version < "1.8.0") {
[10:19:27.183]                           info <- base::c(r_version = base::gsub("R version ", 
[10:19:27.183]                             "", base::R.version$version.string), 
[10:19:27.183]                             platform = base::sprintf("%s (%s-bit)", 
[10:19:27.183]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:19:27.183]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:19:27.183]                               "release", "version")], collapse = " "), 
[10:19:27.183]                             hostname = base::Sys.info()[["nodename"]])
[10:19:27.183]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:19:27.183]                             info)
[10:19:27.183]                           info <- base::paste(info, collapse = "; ")
[10:19:27.183]                           if (!has_future) {
[10:19:27.183]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:19:27.183]                               info)
[10:19:27.183]                           }
[10:19:27.183]                           else {
[10:19:27.183]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:19:27.183]                               info, version)
[10:19:27.183]                           }
[10:19:27.183]                           base::stop(msg)
[10:19:27.183]                         }
[10:19:27.183]                       })
[10:19:27.183]                     }
[10:19:27.183]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:19:27.183]                     base::options(mc.cores = 1L)
[10:19:27.183]                   }
[10:19:27.183]                   ...future.strategy.old <- future::plan("list")
[10:19:27.183]                   options(future.plan = NULL)
[10:19:27.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:19:27.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:19:27.183]                 }
[10:19:27.183]                 ...future.workdir <- getwd()
[10:19:27.183]             }
[10:19:27.183]             ...future.oldOptions <- base::as.list(base::.Options)
[10:19:27.183]             ...future.oldEnvVars <- base::Sys.getenv()
[10:19:27.183]         }
[10:19:27.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:19:27.183]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:19:27.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:19:27.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:19:27.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:19:27.183]             future.stdout.windows.reencode = NULL, width = 80L)
[10:19:27.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:19:27.183]             base::names(...future.oldOptions))
[10:19:27.183]     }
[10:19:27.183]     if (FALSE) {
[10:19:27.183]     }
[10:19:27.183]     else {
[10:19:27.183]         if (TRUE) {
[10:19:27.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:19:27.183]                 open = "w")
[10:19:27.183]         }
[10:19:27.183]         else {
[10:19:27.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:19:27.183]                 windows = "NUL", "/dev/null"), open = "w")
[10:19:27.183]         }
[10:19:27.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:19:27.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:19:27.183]             base::sink(type = "output", split = FALSE)
[10:19:27.183]             base::close(...future.stdout)
[10:19:27.183]         }, add = TRUE)
[10:19:27.183]     }
[10:19:27.183]     ...future.frame <- base::sys.nframe()
[10:19:27.183]     ...future.conditions <- base::list()
[10:19:27.183]     ...future.rng <- base::globalenv()$.Random.seed
[10:19:27.183]     if (FALSE) {
[10:19:27.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:19:27.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:19:27.183]     }
[10:19:27.183]     ...future.result <- base::tryCatch({
[10:19:27.183]         base::withCallingHandlers({
[10:19:27.183]             ...future.value <- base::withVisible(base::local({
[10:19:27.183]                 ...future.makeSendCondition <- base::local({
[10:19:27.183]                   sendCondition <- NULL
[10:19:27.183]                   function(frame = 1L) {
[10:19:27.183]                     if (is.function(sendCondition)) 
[10:19:27.183]                       return(sendCondition)
[10:19:27.183]                     ns <- getNamespace("parallel")
[10:19:27.183]                     if (exists("sendData", mode = "function", 
[10:19:27.183]                       envir = ns)) {
[10:19:27.183]                       parallel_sendData <- get("sendData", mode = "function", 
[10:19:27.183]                         envir = ns)
[10:19:27.183]                       envir <- sys.frame(frame)
[10:19:27.183]                       master <- NULL
[10:19:27.183]                       while (!identical(envir, .GlobalEnv) && 
[10:19:27.183]                         !identical(envir, emptyenv())) {
[10:19:27.183]                         if (exists("master", mode = "list", envir = envir, 
[10:19:27.183]                           inherits = FALSE)) {
[10:19:27.183]                           master <- get("master", mode = "list", 
[10:19:27.183]                             envir = envir, inherits = FALSE)
[10:19:27.183]                           if (inherits(master, c("SOCKnode", 
[10:19:27.183]                             "SOCK0node"))) {
[10:19:27.183]                             sendCondition <<- function(cond) {
[10:19:27.183]                               data <- list(type = "VALUE", value = cond, 
[10:19:27.183]                                 success = TRUE)
[10:19:27.183]                               parallel_sendData(master, data)
[10:19:27.183]                             }
[10:19:27.183]                             return(sendCondition)
[10:19:27.183]                           }
[10:19:27.183]                         }
[10:19:27.183]                         frame <- frame + 1L
[10:19:27.183]                         envir <- sys.frame(frame)
[10:19:27.183]                       }
[10:19:27.183]                     }
[10:19:27.183]                     sendCondition <<- function(cond) NULL
[10:19:27.183]                   }
[10:19:27.183]                 })
[10:19:27.183]                 withCallingHandlers({
[10:19:27.183]                   {
[10:19:27.183]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:27.183]                     if (!identical(...future.globals.maxSize.org, 
[10:19:27.183]                       ...future.globals.maxSize)) {
[10:19:27.183]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:27.183]                       on.exit(options(oopts), add = TRUE)
[10:19:27.183]                     }
[10:19:27.183]                     {
[10:19:27.183]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:27.183]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:19:27.183]                         USE.NAMES = FALSE)
[10:19:27.183]                       do.call(mapply, args = args)
[10:19:27.183]                     }
[10:19:27.183]                   }
[10:19:27.183]                 }, immediateCondition = function(cond) {
[10:19:27.183]                   sendCondition <- ...future.makeSendCondition()
[10:19:27.183]                   sendCondition(cond)
[10:19:27.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.183]                   {
[10:19:27.183]                     inherits <- base::inherits
[10:19:27.183]                     invokeRestart <- base::invokeRestart
[10:19:27.183]                     is.null <- base::is.null
[10:19:27.183]                     muffled <- FALSE
[10:19:27.183]                     if (inherits(cond, "message")) {
[10:19:27.183]                       muffled <- grepl(pattern, "muffleMessage")
[10:19:27.183]                       if (muffled) 
[10:19:27.183]                         invokeRestart("muffleMessage")
[10:19:27.183]                     }
[10:19:27.183]                     else if (inherits(cond, "warning")) {
[10:19:27.183]                       muffled <- grepl(pattern, "muffleWarning")
[10:19:27.183]                       if (muffled) 
[10:19:27.183]                         invokeRestart("muffleWarning")
[10:19:27.183]                     }
[10:19:27.183]                     else if (inherits(cond, "condition")) {
[10:19:27.183]                       if (!is.null(pattern)) {
[10:19:27.183]                         computeRestarts <- base::computeRestarts
[10:19:27.183]                         grepl <- base::grepl
[10:19:27.183]                         restarts <- computeRestarts(cond)
[10:19:27.183]                         for (restart in restarts) {
[10:19:27.183]                           name <- restart$name
[10:19:27.183]                           if (is.null(name)) 
[10:19:27.183]                             next
[10:19:27.183]                           if (!grepl(pattern, name)) 
[10:19:27.183]                             next
[10:19:27.183]                           invokeRestart(restart)
[10:19:27.183]                           muffled <- TRUE
[10:19:27.183]                           break
[10:19:27.183]                         }
[10:19:27.183]                       }
[10:19:27.183]                     }
[10:19:27.183]                     invisible(muffled)
[10:19:27.183]                   }
[10:19:27.183]                   muffleCondition(cond)
[10:19:27.183]                 })
[10:19:27.183]             }))
[10:19:27.183]             future::FutureResult(value = ...future.value$value, 
[10:19:27.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:27.183]                   ...future.rng), globalenv = if (FALSE) 
[10:19:27.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:19:27.183]                     ...future.globalenv.names))
[10:19:27.183]                 else NULL, started = ...future.startTime, version = "1.8")
[10:19:27.183]         }, condition = base::local({
[10:19:27.183]             c <- base::c
[10:19:27.183]             inherits <- base::inherits
[10:19:27.183]             invokeRestart <- base::invokeRestart
[10:19:27.183]             length <- base::length
[10:19:27.183]             list <- base::list
[10:19:27.183]             seq.int <- base::seq.int
[10:19:27.183]             signalCondition <- base::signalCondition
[10:19:27.183]             sys.calls <- base::sys.calls
[10:19:27.183]             `[[` <- base::`[[`
[10:19:27.183]             `+` <- base::`+`
[10:19:27.183]             `<<-` <- base::`<<-`
[10:19:27.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:19:27.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:19:27.183]                   3L)]
[10:19:27.183]             }
[10:19:27.183]             function(cond) {
[10:19:27.183]                 is_error <- inherits(cond, "error")
[10:19:27.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:19:27.183]                   NULL)
[10:19:27.183]                 if (is_error) {
[10:19:27.183]                   sessionInformation <- function() {
[10:19:27.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:19:27.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:19:27.183]                       search = base::search(), system = base::Sys.info())
[10:19:27.183]                   }
[10:19:27.183]                   ...future.conditions[[length(...future.conditions) + 
[10:19:27.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:19:27.183]                     cond$call), session = sessionInformation(), 
[10:19:27.183]                     timestamp = base::Sys.time(), signaled = 0L)
[10:19:27.183]                   signalCondition(cond)
[10:19:27.183]                 }
[10:19:27.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:19:27.183]                 "immediateCondition"))) {
[10:19:27.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:19:27.183]                   ...future.conditions[[length(...future.conditions) + 
[10:19:27.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:19:27.183]                   if (TRUE && !signal) {
[10:19:27.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.183]                     {
[10:19:27.183]                       inherits <- base::inherits
[10:19:27.183]                       invokeRestart <- base::invokeRestart
[10:19:27.183]                       is.null <- base::is.null
[10:19:27.183]                       muffled <- FALSE
[10:19:27.183]                       if (inherits(cond, "message")) {
[10:19:27.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:27.183]                         if (muffled) 
[10:19:27.183]                           invokeRestart("muffleMessage")
[10:19:27.183]                       }
[10:19:27.183]                       else if (inherits(cond, "warning")) {
[10:19:27.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:27.183]                         if (muffled) 
[10:19:27.183]                           invokeRestart("muffleWarning")
[10:19:27.183]                       }
[10:19:27.183]                       else if (inherits(cond, "condition")) {
[10:19:27.183]                         if (!is.null(pattern)) {
[10:19:27.183]                           computeRestarts <- base::computeRestarts
[10:19:27.183]                           grepl <- base::grepl
[10:19:27.183]                           restarts <- computeRestarts(cond)
[10:19:27.183]                           for (restart in restarts) {
[10:19:27.183]                             name <- restart$name
[10:19:27.183]                             if (is.null(name)) 
[10:19:27.183]                               next
[10:19:27.183]                             if (!grepl(pattern, name)) 
[10:19:27.183]                               next
[10:19:27.183]                             invokeRestart(restart)
[10:19:27.183]                             muffled <- TRUE
[10:19:27.183]                             break
[10:19:27.183]                           }
[10:19:27.183]                         }
[10:19:27.183]                       }
[10:19:27.183]                       invisible(muffled)
[10:19:27.183]                     }
[10:19:27.183]                     muffleCondition(cond, pattern = "^muffle")
[10:19:27.183]                   }
[10:19:27.183]                 }
[10:19:27.183]                 else {
[10:19:27.183]                   if (TRUE) {
[10:19:27.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:19:27.183]                     {
[10:19:27.183]                       inherits <- base::inherits
[10:19:27.183]                       invokeRestart <- base::invokeRestart
[10:19:27.183]                       is.null <- base::is.null
[10:19:27.183]                       muffled <- FALSE
[10:19:27.183]                       if (inherits(cond, "message")) {
[10:19:27.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:19:27.183]                         if (muffled) 
[10:19:27.183]                           invokeRestart("muffleMessage")
[10:19:27.183]                       }
[10:19:27.183]                       else if (inherits(cond, "warning")) {
[10:19:27.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:19:27.183]                         if (muffled) 
[10:19:27.183]                           invokeRestart("muffleWarning")
[10:19:27.183]                       }
[10:19:27.183]                       else if (inherits(cond, "condition")) {
[10:19:27.183]                         if (!is.null(pattern)) {
[10:19:27.183]                           computeRestarts <- base::computeRestarts
[10:19:27.183]                           grepl <- base::grepl
[10:19:27.183]                           restarts <- computeRestarts(cond)
[10:19:27.183]                           for (restart in restarts) {
[10:19:27.183]                             name <- restart$name
[10:19:27.183]                             if (is.null(name)) 
[10:19:27.183]                               next
[10:19:27.183]                             if (!grepl(pattern, name)) 
[10:19:27.183]                               next
[10:19:27.183]                             invokeRestart(restart)
[10:19:27.183]                             muffled <- TRUE
[10:19:27.183]                             break
[10:19:27.183]                           }
[10:19:27.183]                         }
[10:19:27.183]                       }
[10:19:27.183]                       invisible(muffled)
[10:19:27.183]                     }
[10:19:27.183]                     muffleCondition(cond, pattern = "^muffle")
[10:19:27.183]                   }
[10:19:27.183]                 }
[10:19:27.183]             }
[10:19:27.183]         }))
[10:19:27.183]     }, error = function(ex) {
[10:19:27.183]         base::structure(base::list(value = NULL, visible = NULL, 
[10:19:27.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:19:27.183]                 ...future.rng), started = ...future.startTime, 
[10:19:27.183]             finished = Sys.time(), session_uuid = NA_character_, 
[10:19:27.183]             version = "1.8"), class = "FutureResult")
[10:19:27.183]     }, finally = {
[10:19:27.183]         if (!identical(...future.workdir, getwd())) 
[10:19:27.183]             setwd(...future.workdir)
[10:19:27.183]         {
[10:19:27.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:19:27.183]                 ...future.oldOptions$nwarnings <- NULL
[10:19:27.183]             }
[10:19:27.183]             base::options(...future.oldOptions)
[10:19:27.183]             if (.Platform$OS.type == "windows") {
[10:19:27.183]                 old_names <- names(...future.oldEnvVars)
[10:19:27.183]                 envs <- base::Sys.getenv()
[10:19:27.183]                 names <- names(envs)
[10:19:27.183]                 common <- intersect(names, old_names)
[10:19:27.183]                 added <- setdiff(names, old_names)
[10:19:27.183]                 removed <- setdiff(old_names, names)
[10:19:27.183]                 changed <- common[...future.oldEnvVars[common] != 
[10:19:27.183]                   envs[common]]
[10:19:27.183]                 NAMES <- toupper(changed)
[10:19:27.183]                 args <- list()
[10:19:27.183]                 for (kk in seq_along(NAMES)) {
[10:19:27.183]                   name <- changed[[kk]]
[10:19:27.183]                   NAME <- NAMES[[kk]]
[10:19:27.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.183]                     next
[10:19:27.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:27.183]                 }
[10:19:27.183]                 NAMES <- toupper(added)
[10:19:27.183]                 for (kk in seq_along(NAMES)) {
[10:19:27.183]                   name <- added[[kk]]
[10:19:27.183]                   NAME <- NAMES[[kk]]
[10:19:27.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.183]                     next
[10:19:27.183]                   args[[name]] <- ""
[10:19:27.183]                 }
[10:19:27.183]                 NAMES <- toupper(removed)
[10:19:27.183]                 for (kk in seq_along(NAMES)) {
[10:19:27.183]                   name <- removed[[kk]]
[10:19:27.183]                   NAME <- NAMES[[kk]]
[10:19:27.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:19:27.183]                     next
[10:19:27.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:19:27.183]                 }
[10:19:27.183]                 if (length(args) > 0) 
[10:19:27.183]                   base::do.call(base::Sys.setenv, args = args)
[10:19:27.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:19:27.183]             }
[10:19:27.183]             else {
[10:19:27.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:19:27.183]             }
[10:19:27.183]             {
[10:19:27.183]                 if (base::length(...future.futureOptionsAdded) > 
[10:19:27.183]                   0L) {
[10:19:27.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:19:27.183]                   base::names(opts) <- ...future.futureOptionsAdded
[10:19:27.183]                   base::options(opts)
[10:19:27.183]                 }
[10:19:27.183]                 {
[10:19:27.183]                   {
[10:19:27.183]                     base::options(mc.cores = ...future.mc.cores.old)
[10:19:27.183]                     NULL
[10:19:27.183]                   }
[10:19:27.183]                   options(future.plan = NULL)
[10:19:27.183]                   if (is.na(NA_character_)) 
[10:19:27.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:19:27.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:19:27.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:19:27.183]                     .init = FALSE)
[10:19:27.183]                 }
[10:19:27.183]             }
[10:19:27.183]         }
[10:19:27.183]     })
[10:19:27.183]     if (TRUE) {
[10:19:27.183]         base::sink(type = "output", split = FALSE)
[10:19:27.183]         if (TRUE) {
[10:19:27.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:19:27.183]         }
[10:19:27.183]         else {
[10:19:27.183]             ...future.result["stdout"] <- base::list(NULL)
[10:19:27.183]         }
[10:19:27.183]         base::close(...future.stdout)
[10:19:27.183]         ...future.stdout <- NULL
[10:19:27.183]     }
[10:19:27.183]     ...future.result$conditions <- ...future.conditions
[10:19:27.183]     ...future.result$finished <- base::Sys.time()
[10:19:27.183]     ...future.result
[10:19:27.183] }
[10:19:27.185] Exporting 5 global objects (800 bytes) to cluster node #2 ...
[10:19:27.185] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[10:19:27.186] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[10:19:27.186] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:19:27.186] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:19:27.186] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #2 ...
[10:19:27.187] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #2 ... DONE
[10:19:27.187] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:19:27.187] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:19:27.188] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:19:27.188] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:19:27.188] Exporting 5 global objects (800 bytes) to cluster node #2 ... DONE
[10:19:27.188] MultisessionFuture started
[10:19:27.189] - Launch lazy future ... done
[10:19:27.189] run() for ‘MultisessionFuture’ ... done
[10:19:27.189] Created future:
[10:19:27.189] MultisessionFuture:
[10:19:27.189] Label: ‘future_mapply-2’
[10:19:27.189] Expression:
[10:19:27.189] {
[10:19:27.189]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:19:27.189]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:19:27.189]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:19:27.189]         on.exit(options(oopts), add = TRUE)
[10:19:27.189]     }
[10:19:27.189]     {
[10:19:27.189]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:19:27.189]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:19:27.189]         do.call(mapply, args = args)
[10:19:27.189]     }
[10:19:27.189] }
[10:19:27.189] Lazy evaluation: FALSE
[10:19:27.189] Asynchronous evaluation: TRUE
[10:19:27.189] Local evaluation: TRUE
[10:19:27.189] Environment: R_GlobalEnv
[10:19:27.189] Capture standard output: TRUE
[10:19:27.189] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:19:27.189] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:19:27.189] Packages: <none>
[10:19:27.189] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:19:27.189] Resolved: FALSE
[10:19:27.189] Value: <not collected>
[10:19:27.189] Conditions captured: <none>
[10:19:27.189] Early signaling: FALSE
[10:19:27.189] Owner process: 9c393906-5cad-ed85-9f6b-792d9e6b381b
[10:19:27.189] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:19:27.200] Chunk #2 of 2 ... DONE
[10:19:27.200] Launching 2 futures (chunks) ... DONE
[10:19:27.200] Resolving 2 futures (chunks) ...
[10:19:27.201] resolve() on list ...
[10:19:27.201]  recursive: 0
[10:19:27.201]  length: 2
[10:19:27.201] 
[10:19:27.201] receiveMessageFromWorker() for ClusterFuture ...
[10:19:27.201] - Validating connection of MultisessionFuture
[10:19:27.202] - received message: FutureResult
[10:19:27.202] - Received FutureResult
[10:19:27.202] - Erased future from FutureRegistry
[10:19:27.202] result() for ClusterFuture ...
[10:19:27.202] - result already collected: FutureResult
[10:19:27.202] result() for ClusterFuture ... done
[10:19:27.202] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:27.202] Future #1
[10:19:27.202] result() for ClusterFuture ...
[10:19:27.202] - result already collected: FutureResult
[10:19:27.203] result() for ClusterFuture ... done
[10:19:27.203] result() for ClusterFuture ...
[10:19:27.203] - result already collected: FutureResult
[10:19:27.203] result() for ClusterFuture ... done
[10:19:27.203] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:19:27.203] - nx: 2
[10:19:27.203] - relay: TRUE
[10:19:27.203] - stdout: TRUE
[10:19:27.203] - signal: TRUE
[10:19:27.203] - resignal: FALSE
[10:19:27.203] - force: TRUE
[10:19:27.203] - relayed: [n=2] FALSE, FALSE
[10:19:27.203] - queued futures: [n=2] FALSE, FALSE
[10:19:27.204]  - until=1
[10:19:27.204]  - relaying element #1
[10:19:27.204] result() for ClusterFuture ...
[10:19:27.204] - result already collected: FutureResult
[10:19:27.204] result() for ClusterFuture ... done
[10:19:27.204] result() for ClusterFuture ...
[10:19:27.204] - result already collected: FutureResult
[10:19:27.204] result() for ClusterFuture ... done
[10:19:27.204] result() for ClusterFuture ...
[10:19:27.204] - result already collected: FutureResult
[10:19:27.204] result() for ClusterFuture ... done
[10:19:27.204] result() for ClusterFuture ...
[10:19:27.205] - result already collected: FutureResult
[10:19:27.205] result() for ClusterFuture ... done
[10:19:27.205] - relayed: [n=2] TRUE, FALSE
[10:19:27.205] - queued futures: [n=2] TRUE, FALSE
[10:19:27.205] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:19:27.205]  length: 1 (resolved future 1)
[10:19:27.231] receiveMessageFromWorker() for ClusterFuture ...
[10:19:27.231] - Validating connection of MultisessionFuture
[10:19:27.231] - received message: FutureResult
[10:19:27.231] - Received FutureResult
[10:19:27.232] - Erased future from FutureRegistry
[10:19:27.232] result() for ClusterFuture ...
[10:19:27.232] - result already collected: FutureResult
[10:19:27.232] result() for ClusterFuture ... done
[10:19:27.232] receiveMessageFromWorker() for ClusterFuture ... done
[10:19:27.232] Future #2
[10:19:27.232] result() for ClusterFuture ...
[10:19:27.232] - result already collected: FutureResult
[10:19:27.232] result() for ClusterFuture ... done
[10:19:27.232] result() for ClusterFuture ...
[10:19:27.232] - result already collected: FutureResult
[10:19:27.232] result() for ClusterFuture ... done
[10:19:27.233] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:19:27.233] - nx: 2
[10:19:27.233] - relay: TRUE
[10:19:27.233] - stdout: TRUE
[10:19:27.233] - signal: TRUE
[10:19:27.233] - resignal: FALSE
[10:19:27.233] - force: TRUE
[10:19:27.233] - relayed: [n=2] TRUE, FALSE
[10:19:27.233] - queued futures: [n=2] TRUE, FALSE
[10:19:27.233]  - until=2
[10:19:27.233]  - relaying element #2
[10:19:27.233] result() for ClusterFuture ...
[10:19:27.234] - result already collected: FutureResult
[10:19:27.234] result() for ClusterFuture ... done
[10:19:27.234] result() for ClusterFuture ...
[10:19:27.234] - result already collected: FutureResult
[10:19:27.234] result() for ClusterFuture ... done
[10:19:27.234] result() for ClusterFuture ...
[10:19:27.234] - result already collected: FutureResult
[10:19:27.234] result() for ClusterFuture ... done
[10:19:27.234] result() for ClusterFuture ...
[10:19:27.234] - result already collected: FutureResult
[10:19:27.234] result() for ClusterFuture ... done
[10:19:27.234] - relayed: [n=2] TRUE, TRUE
[10:19:27.235] - queued futures: [n=2] TRUE, TRUE
[10:19:27.235] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:19:27.235]  length: 0 (resolved future 2)
[10:19:27.235] Relaying remaining futures
[10:19:27.235] signalConditionsASAP(NULL, pos=0) ...
[10:19:27.235] - nx: 2
[10:19:27.235] - relay: TRUE
[10:19:27.235] - stdout: TRUE
[10:19:27.235] - signal: TRUE
[10:19:27.235] - resignal: FALSE
[10:19:27.235] - force: TRUE
[10:19:27.235] - relayed: [n=2] TRUE, TRUE
[10:19:27.236] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:19:27.236] - relayed: [n=2] TRUE, TRUE
[10:19:27.236] - queued futures: [n=2] TRUE, TRUE
[10:19:27.236] signalConditionsASAP(NULL, pos=0) ... done
[10:19:27.236] resolve() on list ... DONE
[10:19:27.236] result() for ClusterFuture ...
[10:19:27.236] - result already collected: FutureResult
[10:19:27.236] result() for ClusterFuture ... done
[10:19:27.236] result() for ClusterFuture ...
[10:19:27.236] - result already collected: FutureResult
[10:19:27.236] result() for ClusterFuture ... done
[10:19:27.237] result() for ClusterFuture ...
[10:19:27.237] - result already collected: FutureResult
[10:19:27.237] result() for ClusterFuture ... done
[10:19:27.237] result() for ClusterFuture ...
[10:19:27.237] - result already collected: FutureResult
[10:19:27.237] result() for ClusterFuture ... done
[10:19:27.237]  - Number of value chunks collected: 2
[10:19:27.237] Resolving 2 futures (chunks) ... DONE
[10:19:27.237] Reducing values from 2 chunks ...
[10:19:27.237]  - Number of values collected after concatenation: 2
[10:19:27.237]  - Number of values expected: 2
[10:19:27.237] Reducing values from 2 chunks ... DONE
[10:19:27.238] future_mapply() ... DONE
[10:19:27.238] plan(): Setting new future strategy stack:
[10:19:27.238] List of future strategies:
[10:19:27.238] 1. sequential:
[10:19:27.238]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:27.238]    - tweaked: FALSE
[10:19:27.238]    - call: plan(sequential)
[10:19:27.239] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[10:19:27.240] plan(): Setting new future strategy stack:
[10:19:27.240] List of future strategies:
[10:19:27.240] 1. FutureStrategy:
[10:19:27.240]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:19:27.240]    - tweaked: FALSE
[10:19:27.240]    - call: future::plan(oplan)
[10:19:27.241] plan(): nbrOfWorkers() = 1
> 
