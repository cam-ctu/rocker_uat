
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[08:25:46.898] plan(): Setting new future strategy stack:
[08:25:46.898] List of future strategies:
[08:25:46.898] 1. sequential:
[08:25:46.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:46.898]    - tweaked: FALSE
[08:25:46.898]    - call: future::plan("sequential")
[08:25:46.913] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[08:25:46.928] plan(): Setting new future strategy stack:
[08:25:46.928] List of future strategies:
[08:25:46.928] 1. sequential:
[08:25:46.928]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:46.928]    - tweaked: FALSE
[08:25:46.928]    - call: plan(sequential)
[08:25:46.939] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[08:25:46.940] future_mapply() ...
[08:25:46.940] Generating random seeds ...
[08:25:46.941] Generating random seed streams for 4 elements ...
[08:25:46.941] Generating random seed streams for 4 elements ... DONE
[08:25:46.941] Generating random seeds ... DONE
[08:25:46.941] Will set RNG state on exit: 10407, -1254127537, -1740134832, -1939992472, 1463167666, 1935667987, -1219978863
[08:25:46.941] Number of chunks: 1
[08:25:46.942] getGlobalsAndPackagesXApply() ...
[08:25:46.942]  - future.globals: TRUE
[08:25:46.942] getGlobalsAndPackages() ...
[08:25:46.943] Searching for globals...
[08:25:46.947] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[08:25:46.947] Searching for globals ... DONE
[08:25:46.948] Resolving globals: FALSE
[08:25:46.949] The total size of the 1 globals is 501 bytes (501 bytes)
[08:25:46.949] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[08:25:46.949] - globals: [1] ‘FUN’
[08:25:46.949] - packages: [1] ‘stats’
[08:25:46.949] getGlobalsAndPackages() ... DONE
[08:25:46.950]  - globals found/used: [n=1] ‘FUN’
[08:25:46.950]  - needed namespaces: [n=1] ‘stats’
[08:25:46.950] Finding globals ... DONE
[08:25:46.950] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:46.950] List of 2
[08:25:46.950]  $ ...future.FUN:function (n, min = 0, max = 1)  
[08:25:46.950]  $ MoreArgs     :List of 1
[08:25:46.950]   ..$ min: num 1
[08:25:46.950]  - attr(*, "where")=List of 2
[08:25:46.950]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:46.950]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:46.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:46.950]  - attr(*, "resolved")= logi FALSE
[08:25:46.950]  - attr(*, "total_size")= num NA
[08:25:46.958] Packages to be attached in all futures: [n=1] ‘stats’
[08:25:46.958] getGlobalsAndPackagesXApply() ... DONE
[08:25:46.959] Number of futures (= number of chunks): 1
[08:25:46.959] Launching 1 futures (chunks) ...
[08:25:46.959] Chunk #1 of 1 ...
[08:25:46.959]  - Finding globals in '...' for chunk #1 ...
[08:25:46.959] getGlobalsAndPackages() ...
[08:25:46.959] Searching for globals...
[08:25:46.960] 
[08:25:46.960] Searching for globals ... DONE
[08:25:46.960] - globals: [0] <none>
[08:25:46.960] getGlobalsAndPackages() ... DONE
[08:25:46.960]    + additional globals found: [n=0] 
[08:25:46.960]    + additional namespaces needed: [n=0] 
[08:25:46.960]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:46.960]  - seeds: [4] <seeds>
[08:25:46.960]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:46.961] getGlobalsAndPackages() ...
[08:25:46.961] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:46.961] Resolving globals: FALSE
[08:25:46.961] The total size of the 5 globals is 990 bytes (990 bytes)
[08:25:46.962] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 990 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (196 bytes of class ‘list’) and ‘...future.seeds_ii’ (175 bytes of class ‘list’)
[08:25:46.962] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:46.962] - packages: [1] ‘stats’
[08:25:46.962] getGlobalsAndPackages() ... DONE
[08:25:46.963] run() for ‘Future’ ...
[08:25:46.963] - state: ‘created’
[08:25:46.963] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:46.963] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:46.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:46.964]   - Field: ‘label’
[08:25:46.964]   - Field: ‘local’
[08:25:46.964]   - Field: ‘owner’
[08:25:46.964]   - Field: ‘envir’
[08:25:46.964]   - Field: ‘packages’
[08:25:46.964]   - Field: ‘gc’
[08:25:46.964]   - Field: ‘conditions’
[08:25:46.964]   - Field: ‘expr’
[08:25:46.964]   - Field: ‘uuid’
[08:25:46.965]   - Field: ‘seed’
[08:25:46.965]   - Field: ‘version’
[08:25:46.965]   - Field: ‘result’
[08:25:46.965]   - Field: ‘asynchronous’
[08:25:46.965]   - Field: ‘calls’
[08:25:46.965]   - Field: ‘globals’
[08:25:46.965]   - Field: ‘stdout’
[08:25:46.965]   - Field: ‘earlySignal’
[08:25:46.965]   - Field: ‘lazy’
[08:25:46.965]   - Field: ‘state’
[08:25:46.965] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:46.965] - Launch lazy future ...
[08:25:46.966] Packages needed by the future expression (n = 1): ‘stats’
[08:25:46.966] Packages needed by future strategies (n = 0): <none>
[08:25:46.967] {
[08:25:46.967]     {
[08:25:46.967]         {
[08:25:46.967]             ...future.startTime <- base::Sys.time()
[08:25:46.967]             {
[08:25:46.967]                 {
[08:25:46.967]                   {
[08:25:46.967]                     {
[08:25:46.967]                       base::local({
[08:25:46.967]                         has_future <- base::requireNamespace("future", 
[08:25:46.967]                           quietly = TRUE)
[08:25:46.967]                         if (has_future) {
[08:25:46.967]                           ns <- base::getNamespace("future")
[08:25:46.967]                           version <- ns[[".package"]][["version"]]
[08:25:46.967]                           if (is.null(version)) 
[08:25:46.967]                             version <- utils::packageVersion("future")
[08:25:46.967]                         }
[08:25:46.967]                         else {
[08:25:46.967]                           version <- NULL
[08:25:46.967]                         }
[08:25:46.967]                         if (!has_future || version < "1.8.0") {
[08:25:46.967]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:46.967]                             "", base::R.version$version.string), 
[08:25:46.967]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:46.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:46.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:46.967]                               "release", "version")], collapse = " "), 
[08:25:46.967]                             hostname = base::Sys.info()[["nodename"]])
[08:25:46.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:46.967]                             info)
[08:25:46.967]                           info <- base::paste(info, collapse = "; ")
[08:25:46.967]                           if (!has_future) {
[08:25:46.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:46.967]                               info)
[08:25:46.967]                           }
[08:25:46.967]                           else {
[08:25:46.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:46.967]                               info, version)
[08:25:46.967]                           }
[08:25:46.967]                           base::stop(msg)
[08:25:46.967]                         }
[08:25:46.967]                       })
[08:25:46.967]                     }
[08:25:46.967]                     base::local({
[08:25:46.967]                       for (pkg in "stats") {
[08:25:46.967]                         base::loadNamespace(pkg)
[08:25:46.967]                         base::library(pkg, character.only = TRUE)
[08:25:46.967]                       }
[08:25:46.967]                     })
[08:25:46.967]                   }
[08:25:46.967]                   ...future.strategy.old <- future::plan("list")
[08:25:46.967]                   options(future.plan = NULL)
[08:25:46.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:46.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:46.967]                 }
[08:25:46.967]                 ...future.workdir <- getwd()
[08:25:46.967]             }
[08:25:46.967]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:46.967]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:46.967]         }
[08:25:46.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:46.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:46.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:46.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:46.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:46.967]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:46.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:46.967]             base::names(...future.oldOptions))
[08:25:46.967]     }
[08:25:46.967]     if (FALSE) {
[08:25:46.967]     }
[08:25:46.967]     else {
[08:25:46.967]         if (TRUE) {
[08:25:46.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:46.967]                 open = "w")
[08:25:46.967]         }
[08:25:46.967]         else {
[08:25:46.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:46.967]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:46.967]         }
[08:25:46.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:46.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:46.967]             base::sink(type = "output", split = FALSE)
[08:25:46.967]             base::close(...future.stdout)
[08:25:46.967]         }, add = TRUE)
[08:25:46.967]     }
[08:25:46.967]     ...future.frame <- base::sys.nframe()
[08:25:46.967]     ...future.conditions <- base::list()
[08:25:46.967]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:46.967]     if (FALSE) {
[08:25:46.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:46.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:46.967]     }
[08:25:46.967]     ...future.result <- base::tryCatch({
[08:25:46.967]         base::withCallingHandlers({
[08:25:46.967]             ...future.value <- base::withVisible(base::local({
[08:25:46.967]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:46.967]                 if (!identical(...future.globals.maxSize.org, 
[08:25:46.967]                   ...future.globals.maxSize)) {
[08:25:46.967]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:46.967]                   on.exit(options(oopts), add = TRUE)
[08:25:46.967]                 }
[08:25:46.967]                 {
[08:25:46.967]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:46.967]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:46.967]                       envir = globalenv(), inherits = FALSE)
[08:25:46.967]                     ...future.FUN(...)
[08:25:46.967]                   }
[08:25:46.967]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:46.967]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:46.967]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:46.967]                     USE.NAMES = FALSE)
[08:25:46.967]                   do.call(mapply, args = args)
[08:25:46.967]                 }
[08:25:46.967]             }))
[08:25:46.967]             future::FutureResult(value = ...future.value$value, 
[08:25:46.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:46.967]                   ...future.rng), globalenv = if (FALSE) 
[08:25:46.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:46.967]                     ...future.globalenv.names))
[08:25:46.967]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:46.967]         }, condition = base::local({
[08:25:46.967]             c <- base::c
[08:25:46.967]             inherits <- base::inherits
[08:25:46.967]             invokeRestart <- base::invokeRestart
[08:25:46.967]             length <- base::length
[08:25:46.967]             list <- base::list
[08:25:46.967]             seq.int <- base::seq.int
[08:25:46.967]             signalCondition <- base::signalCondition
[08:25:46.967]             sys.calls <- base::sys.calls
[08:25:46.967]             `[[` <- base::`[[`
[08:25:46.967]             `+` <- base::`+`
[08:25:46.967]             `<<-` <- base::`<<-`
[08:25:46.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:46.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:46.967]                   3L)]
[08:25:46.967]             }
[08:25:46.967]             function(cond) {
[08:25:46.967]                 is_error <- inherits(cond, "error")
[08:25:46.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:46.967]                   NULL)
[08:25:46.967]                 if (is_error) {
[08:25:46.967]                   sessionInformation <- function() {
[08:25:46.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:46.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:46.967]                       search = base::search(), system = base::Sys.info())
[08:25:46.967]                   }
[08:25:46.967]                   ...future.conditions[[length(...future.conditions) + 
[08:25:46.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:46.967]                     cond$call), session = sessionInformation(), 
[08:25:46.967]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:46.967]                   signalCondition(cond)
[08:25:46.967]                 }
[08:25:46.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:46.967]                 "immediateCondition"))) {
[08:25:46.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:46.967]                   ...future.conditions[[length(...future.conditions) + 
[08:25:46.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:46.967]                   if (TRUE && !signal) {
[08:25:46.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:46.967]                     {
[08:25:46.967]                       inherits <- base::inherits
[08:25:46.967]                       invokeRestart <- base::invokeRestart
[08:25:46.967]                       is.null <- base::is.null
[08:25:46.967]                       muffled <- FALSE
[08:25:46.967]                       if (inherits(cond, "message")) {
[08:25:46.967]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:46.967]                         if (muffled) 
[08:25:46.967]                           invokeRestart("muffleMessage")
[08:25:46.967]                       }
[08:25:46.967]                       else if (inherits(cond, "warning")) {
[08:25:46.967]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:46.967]                         if (muffled) 
[08:25:46.967]                           invokeRestart("muffleWarning")
[08:25:46.967]                       }
[08:25:46.967]                       else if (inherits(cond, "condition")) {
[08:25:46.967]                         if (!is.null(pattern)) {
[08:25:46.967]                           computeRestarts <- base::computeRestarts
[08:25:46.967]                           grepl <- base::grepl
[08:25:46.967]                           restarts <- computeRestarts(cond)
[08:25:46.967]                           for (restart in restarts) {
[08:25:46.967]                             name <- restart$name
[08:25:46.967]                             if (is.null(name)) 
[08:25:46.967]                               next
[08:25:46.967]                             if (!grepl(pattern, name)) 
[08:25:46.967]                               next
[08:25:46.967]                             invokeRestart(restart)
[08:25:46.967]                             muffled <- TRUE
[08:25:46.967]                             break
[08:25:46.967]                           }
[08:25:46.967]                         }
[08:25:46.967]                       }
[08:25:46.967]                       invisible(muffled)
[08:25:46.967]                     }
[08:25:46.967]                     muffleCondition(cond, pattern = "^muffle")
[08:25:46.967]                   }
[08:25:46.967]                 }
[08:25:46.967]                 else {
[08:25:46.967]                   if (TRUE) {
[08:25:46.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:46.967]                     {
[08:25:46.967]                       inherits <- base::inherits
[08:25:46.967]                       invokeRestart <- base::invokeRestart
[08:25:46.967]                       is.null <- base::is.null
[08:25:46.967]                       muffled <- FALSE
[08:25:46.967]                       if (inherits(cond, "message")) {
[08:25:46.967]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:46.967]                         if (muffled) 
[08:25:46.967]                           invokeRestart("muffleMessage")
[08:25:46.967]                       }
[08:25:46.967]                       else if (inherits(cond, "warning")) {
[08:25:46.967]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:46.967]                         if (muffled) 
[08:25:46.967]                           invokeRestart("muffleWarning")
[08:25:46.967]                       }
[08:25:46.967]                       else if (inherits(cond, "condition")) {
[08:25:46.967]                         if (!is.null(pattern)) {
[08:25:46.967]                           computeRestarts <- base::computeRestarts
[08:25:46.967]                           grepl <- base::grepl
[08:25:46.967]                           restarts <- computeRestarts(cond)
[08:25:46.967]                           for (restart in restarts) {
[08:25:46.967]                             name <- restart$name
[08:25:46.967]                             if (is.null(name)) 
[08:25:46.967]                               next
[08:25:46.967]                             if (!grepl(pattern, name)) 
[08:25:46.967]                               next
[08:25:46.967]                             invokeRestart(restart)
[08:25:46.967]                             muffled <- TRUE
[08:25:46.967]                             break
[08:25:46.967]                           }
[08:25:46.967]                         }
[08:25:46.967]                       }
[08:25:46.967]                       invisible(muffled)
[08:25:46.967]                     }
[08:25:46.967]                     muffleCondition(cond, pattern = "^muffle")
[08:25:46.967]                   }
[08:25:46.967]                 }
[08:25:46.967]             }
[08:25:46.967]         }))
[08:25:46.967]     }, error = function(ex) {
[08:25:46.967]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:46.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:46.967]                 ...future.rng), started = ...future.startTime, 
[08:25:46.967]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:46.967]             version = "1.8"), class = "FutureResult")
[08:25:46.967]     }, finally = {
[08:25:46.967]         if (!identical(...future.workdir, getwd())) 
[08:25:46.967]             setwd(...future.workdir)
[08:25:46.967]         {
[08:25:46.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:46.967]                 ...future.oldOptions$nwarnings <- NULL
[08:25:46.967]             }
[08:25:46.967]             base::options(...future.oldOptions)
[08:25:46.967]             if (.Platform$OS.type == "windows") {
[08:25:46.967]                 old_names <- names(...future.oldEnvVars)
[08:25:46.967]                 envs <- base::Sys.getenv()
[08:25:46.967]                 names <- names(envs)
[08:25:46.967]                 common <- intersect(names, old_names)
[08:25:46.967]                 added <- setdiff(names, old_names)
[08:25:46.967]                 removed <- setdiff(old_names, names)
[08:25:46.967]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:46.967]                   envs[common]]
[08:25:46.967]                 NAMES <- toupper(changed)
[08:25:46.967]                 args <- list()
[08:25:46.967]                 for (kk in seq_along(NAMES)) {
[08:25:46.967]                   name <- changed[[kk]]
[08:25:46.967]                   NAME <- NAMES[[kk]]
[08:25:46.967]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:46.967]                     next
[08:25:46.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:46.967]                 }
[08:25:46.967]                 NAMES <- toupper(added)
[08:25:46.967]                 for (kk in seq_along(NAMES)) {
[08:25:46.967]                   name <- added[[kk]]
[08:25:46.967]                   NAME <- NAMES[[kk]]
[08:25:46.967]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:46.967]                     next
[08:25:46.967]                   args[[name]] <- ""
[08:25:46.967]                 }
[08:25:46.967]                 NAMES <- toupper(removed)
[08:25:46.967]                 for (kk in seq_along(NAMES)) {
[08:25:46.967]                   name <- removed[[kk]]
[08:25:46.967]                   NAME <- NAMES[[kk]]
[08:25:46.967]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:46.967]                     next
[08:25:46.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:46.967]                 }
[08:25:46.967]                 if (length(args) > 0) 
[08:25:46.967]                   base::do.call(base::Sys.setenv, args = args)
[08:25:46.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:46.967]             }
[08:25:46.967]             else {
[08:25:46.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:46.967]             }
[08:25:46.967]             {
[08:25:46.967]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:46.967]                   0L) {
[08:25:46.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:46.967]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:46.967]                   base::options(opts)
[08:25:46.967]                 }
[08:25:46.967]                 {
[08:25:46.967]                   {
[08:25:46.967]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:46.967]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:46.967]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:46.967]                       inherits = FALSE)
[08:25:46.967]                     NULL
[08:25:46.967]                   }
[08:25:46.967]                   options(future.plan = NULL)
[08:25:46.967]                   if (is.na(NA_character_)) 
[08:25:46.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:46.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:46.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:46.967]                     .init = FALSE)
[08:25:46.967]                 }
[08:25:46.967]             }
[08:25:46.967]         }
[08:25:46.967]     })
[08:25:46.967]     if (TRUE) {
[08:25:46.967]         base::sink(type = "output", split = FALSE)
[08:25:46.967]         if (TRUE) {
[08:25:46.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:46.967]         }
[08:25:46.967]         else {
[08:25:46.967]             ...future.result["stdout"] <- base::list(NULL)
[08:25:46.967]         }
[08:25:46.967]         base::close(...future.stdout)
[08:25:46.967]         ...future.stdout <- NULL
[08:25:46.967]     }
[08:25:46.967]     ...future.result$conditions <- ...future.conditions
[08:25:46.967]     ...future.result$finished <- base::Sys.time()
[08:25:46.967]     ...future.result
[08:25:46.967] }
[08:25:46.969] assign_globals() ...
[08:25:46.969] List of 5
[08:25:46.969]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[08:25:46.969]  $ MoreArgs                 :List of 1
[08:25:46.969]   ..$ min: num 1
[08:25:46.969]  $ ...future.elements_ii    :List of 2
[08:25:46.969]   ..$ n  :List of 4
[08:25:46.969]   .. ..$ : int 1
[08:25:46.969]   .. ..$ : int 2
[08:25:46.969]   .. ..$ : int 3
[08:25:46.969]   .. ..$ : int 4
[08:25:46.969]   ..$ max:List of 4
[08:25:46.969]   .. ..$ : int 2
[08:25:46.969]   .. ..$ : int 3
[08:25:46.969]   .. ..$ : int 4
[08:25:46.969]   .. ..$ : int 5
[08:25:46.969]  $ ...future.seeds_ii       :List of 4
[08:25:46.969]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[08:25:46.969]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[08:25:46.969]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[08:25:46.969]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[08:25:46.969]  $ ...future.globals.maxSize: NULL
[08:25:46.969]  - attr(*, "where")=List of 5
[08:25:46.969]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:46.969]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:46.969]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:46.969]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:46.969]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:46.969]  - attr(*, "resolved")= logi FALSE
[08:25:46.969]  - attr(*, "total_size")= num 990
[08:25:46.969]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:46.969]  - attr(*, "already-done")= logi TRUE
[08:25:46.978] - copied ‘...future.FUN’ to environment
[08:25:46.978] - copied ‘MoreArgs’ to environment
[08:25:46.978] - copied ‘...future.elements_ii’ to environment
[08:25:46.978] - copied ‘...future.seeds_ii’ to environment
[08:25:46.978] - copied ‘...future.globals.maxSize’ to environment
[08:25:46.978] assign_globals() ... done
[08:25:46.979] plan(): Setting new future strategy stack:
[08:25:46.979] List of future strategies:
[08:25:46.979] 1. sequential:
[08:25:46.979]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:46.979]    - tweaked: FALSE
[08:25:46.979]    - call: NULL
[08:25:46.980] plan(): nbrOfWorkers() = 1
[08:25:46.981] plan(): Setting new future strategy stack:
[08:25:46.981] List of future strategies:
[08:25:46.981] 1. sequential:
[08:25:46.981]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:46.981]    - tweaked: FALSE
[08:25:46.981]    - call: plan(sequential)
[08:25:46.982] plan(): nbrOfWorkers() = 1
[08:25:46.982] SequentialFuture started (and completed)
[08:25:46.982] - Launch lazy future ... done
[08:25:46.982] run() for ‘SequentialFuture’ ... done
[08:25:46.982] Created future:
[08:25:46.983] SequentialFuture:
[08:25:46.983] Label: ‘future_mapply-1’
[08:25:46.983] Expression:
[08:25:46.983] {
[08:25:46.983]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:46.983]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:46.983]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:46.983]         on.exit(options(oopts), add = TRUE)
[08:25:46.983]     }
[08:25:46.983]     {
[08:25:46.983]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:46.983]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:46.983]                 inherits = FALSE)
[08:25:46.983]             ...future.FUN(...)
[08:25:46.983]         }
[08:25:46.983]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:46.983]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:46.983]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:46.983]         do.call(mapply, args = args)
[08:25:46.983]     }
[08:25:46.983] }
[08:25:46.983] Lazy evaluation: FALSE
[08:25:46.983] Asynchronous evaluation: FALSE
[08:25:46.983] Local evaluation: TRUE
[08:25:46.983] Environment: R_GlobalEnv
[08:25:46.983] Capture standard output: TRUE
[08:25:46.983] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:46.983] Globals: 5 objects totaling 990 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 196 bytes, list ‘...future.seeds_ii’ of 175 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:46.983] Packages: 1 packages (‘stats’)
[08:25:46.983] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:46.983] Resolved: TRUE
[08:25:46.983] Value: 143 bytes of class ‘list’
[08:25:46.983] Early signaling: FALSE
[08:25:46.983] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:46.983] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:46.984] Chunk #1 of 1 ... DONE
[08:25:46.984] Launching 1 futures (chunks) ... DONE
[08:25:46.984] Resolving 1 futures (chunks) ...
[08:25:46.984] resolve() on list ...
[08:25:46.984]  recursive: 0
[08:25:46.985]  length: 1
[08:25:46.985] 
[08:25:46.985] resolved() for ‘SequentialFuture’ ...
[08:25:46.985] - state: ‘finished’
[08:25:46.985] - run: TRUE
[08:25:46.985] - result: ‘FutureResult’
[08:25:46.985] resolved() for ‘SequentialFuture’ ... done
[08:25:46.986] Future #1
[08:25:46.989] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:46.989] - nx: 1
[08:25:46.989] - relay: TRUE
[08:25:46.989] - stdout: TRUE
[08:25:46.989] - signal: TRUE
[08:25:46.989] - resignal: FALSE
[08:25:46.989] - force: TRUE
[08:25:46.989] - relayed: [n=1] FALSE
[08:25:46.989] - queued futures: [n=1] FALSE
[08:25:46.989]  - until=1
[08:25:46.989]  - relaying element #1
[08:25:46.990] - relayed: [n=1] TRUE
[08:25:46.990] - queued futures: [n=1] TRUE
[08:25:46.990] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:46.990]  length: 0 (resolved future 1)
[08:25:46.990] Relaying remaining futures
[08:25:46.990] signalConditionsASAP(NULL, pos=0) ...
[08:25:46.990] - nx: 1
[08:25:46.990] - relay: TRUE
[08:25:46.990] - stdout: TRUE
[08:25:46.990] - signal: TRUE
[08:25:46.991] - resignal: FALSE
[08:25:46.991] - force: TRUE
[08:25:46.991] - relayed: [n=1] TRUE
[08:25:46.991] - queued futures: [n=1] TRUE
 - flush all
[08:25:46.991] - relayed: [n=1] TRUE
[08:25:46.991] - queued futures: [n=1] TRUE
[08:25:46.991] signalConditionsASAP(NULL, pos=0) ... done
[08:25:46.991] resolve() on list ... DONE
[08:25:46.991]  - Number of value chunks collected: 1
[08:25:46.991] Resolving 1 futures (chunks) ... DONE
[08:25:46.992] Reducing values from 1 chunks ...
[08:25:46.992]  - Number of values collected after concatenation: 4
[08:25:46.992]  - Number of values expected: 4
[08:25:46.992] Reducing values from 1 chunks ... DONE
[08:25:46.992] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[08:25:47.156] plan(): Setting new future strategy stack:
[08:25:47.156] List of future strategies:
[08:25:47.156] 1. sequential:
[08:25:47.156]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.156]    - tweaked: FALSE
[08:25:47.156]    - call: plan(strategy)
[08:25:47.159] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[08:25:47.159] future_mapply() ...
[08:25:47.159] Number of chunks: 1
[08:25:47.159] getGlobalsAndPackagesXApply() ...
[08:25:47.159]  - future.globals: TRUE
[08:25:47.159] getGlobalsAndPackages() ...
[08:25:47.159] Searching for globals...
[08:25:47.160] - globals found: [1] ‘FUN’
[08:25:47.160] Searching for globals ... DONE
[08:25:47.160] Resolving globals: FALSE
[08:25:47.161] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:47.161] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:47.161] - globals: [1] ‘FUN’
[08:25:47.161] 
[08:25:47.161] getGlobalsAndPackages() ... DONE
[08:25:47.161]  - globals found/used: [n=1] ‘FUN’
[08:25:47.161]  - needed namespaces: [n=0] 
[08:25:47.162] Finding globals ... DONE
[08:25:47.162] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.162] List of 2
[08:25:47.162]  $ ...future.FUN:function (x, ...)  
[08:25:47.162]  $ MoreArgs     : NULL
[08:25:47.162]  - attr(*, "where")=List of 2
[08:25:47.162]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.162]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.162]  - attr(*, "resolved")= logi FALSE
[08:25:47.162]  - attr(*, "total_size")= num NA
[08:25:47.164] Packages to be attached in all futures: [n=0] 
[08:25:47.165] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.165] Number of futures (= number of chunks): 1
[08:25:47.165] Launching 1 futures (chunks) ...
[08:25:47.165] Chunk #1 of 1 ...
[08:25:47.165]  - Finding globals in '...' for chunk #1 ...
[08:25:47.165] getGlobalsAndPackages() ...
[08:25:47.165] Searching for globals...
[08:25:47.166] 
[08:25:47.166] Searching for globals ... DONE
[08:25:47.166] - globals: [0] <none>
[08:25:47.166] getGlobalsAndPackages() ... DONE
[08:25:47.166]    + additional globals found: [n=0] 
[08:25:47.166]    + additional namespaces needed: [n=0] 
[08:25:47.166]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.166]  - seeds: <none>
[08:25:47.166]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.166] getGlobalsAndPackages() ...
[08:25:47.167] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.167] Resolving globals: FALSE
[08:25:47.167] The total size of the 5 globals is 258 bytes (258 bytes)
[08:25:47.168] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 258 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (143 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.168] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.168] 
[08:25:47.168] getGlobalsAndPackages() ... DONE
[08:25:47.168] run() for ‘Future’ ...
[08:25:47.168] - state: ‘created’
[08:25:47.168] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.169] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.169] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.169]   - Field: ‘label’
[08:25:47.169]   - Field: ‘local’
[08:25:47.169]   - Field: ‘owner’
[08:25:47.169]   - Field: ‘envir’
[08:25:47.169]   - Field: ‘packages’
[08:25:47.169]   - Field: ‘gc’
[08:25:47.169]   - Field: ‘conditions’
[08:25:47.170]   - Field: ‘expr’
[08:25:47.170]   - Field: ‘uuid’
[08:25:47.170]   - Field: ‘seed’
[08:25:47.170]   - Field: ‘version’
[08:25:47.170]   - Field: ‘result’
[08:25:47.170]   - Field: ‘asynchronous’
[08:25:47.170]   - Field: ‘calls’
[08:25:47.170]   - Field: ‘globals’
[08:25:47.170]   - Field: ‘stdout’
[08:25:47.170]   - Field: ‘earlySignal’
[08:25:47.171]   - Field: ‘lazy’
[08:25:47.171]   - Field: ‘state’
[08:25:47.171] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.171] - Launch lazy future ...
[08:25:47.171] Packages needed by the future expression (n = 0): <none>
[08:25:47.171] Packages needed by future strategies (n = 0): <none>
[08:25:47.172] {
[08:25:47.172]     {
[08:25:47.172]         {
[08:25:47.172]             ...future.startTime <- base::Sys.time()
[08:25:47.172]             {
[08:25:47.172]                 {
[08:25:47.172]                   {
[08:25:47.172]                     base::local({
[08:25:47.172]                       has_future <- base::requireNamespace("future", 
[08:25:47.172]                         quietly = TRUE)
[08:25:47.172]                       if (has_future) {
[08:25:47.172]                         ns <- base::getNamespace("future")
[08:25:47.172]                         version <- ns[[".package"]][["version"]]
[08:25:47.172]                         if (is.null(version)) 
[08:25:47.172]                           version <- utils::packageVersion("future")
[08:25:47.172]                       }
[08:25:47.172]                       else {
[08:25:47.172]                         version <- NULL
[08:25:47.172]                       }
[08:25:47.172]                       if (!has_future || version < "1.8.0") {
[08:25:47.172]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.172]                           "", base::R.version$version.string), 
[08:25:47.172]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.172]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.172]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.172]                             "release", "version")], collapse = " "), 
[08:25:47.172]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.172]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.172]                           info)
[08:25:47.172]                         info <- base::paste(info, collapse = "; ")
[08:25:47.172]                         if (!has_future) {
[08:25:47.172]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.172]                             info)
[08:25:47.172]                         }
[08:25:47.172]                         else {
[08:25:47.172]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.172]                             info, version)
[08:25:47.172]                         }
[08:25:47.172]                         base::stop(msg)
[08:25:47.172]                       }
[08:25:47.172]                     })
[08:25:47.172]                   }
[08:25:47.172]                   ...future.strategy.old <- future::plan("list")
[08:25:47.172]                   options(future.plan = NULL)
[08:25:47.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.172]                 }
[08:25:47.172]                 ...future.workdir <- getwd()
[08:25:47.172]             }
[08:25:47.172]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.172]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.172]         }
[08:25:47.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.172]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.172]             base::names(...future.oldOptions))
[08:25:47.172]     }
[08:25:47.172]     if (FALSE) {
[08:25:47.172]     }
[08:25:47.172]     else {
[08:25:47.172]         if (TRUE) {
[08:25:47.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.172]                 open = "w")
[08:25:47.172]         }
[08:25:47.172]         else {
[08:25:47.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.172]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.172]         }
[08:25:47.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.172]             base::sink(type = "output", split = FALSE)
[08:25:47.172]             base::close(...future.stdout)
[08:25:47.172]         }, add = TRUE)
[08:25:47.172]     }
[08:25:47.172]     ...future.frame <- base::sys.nframe()
[08:25:47.172]     ...future.conditions <- base::list()
[08:25:47.172]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.172]     if (FALSE) {
[08:25:47.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.172]     }
[08:25:47.172]     ...future.result <- base::tryCatch({
[08:25:47.172]         base::withCallingHandlers({
[08:25:47.172]             ...future.value <- base::withVisible(base::local({
[08:25:47.172]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.172]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.172]                   ...future.globals.maxSize)) {
[08:25:47.172]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.172]                   on.exit(options(oopts), add = TRUE)
[08:25:47.172]                 }
[08:25:47.172]                 {
[08:25:47.172]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.172]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.172]                     USE.NAMES = FALSE)
[08:25:47.172]                   do.call(mapply, args = args)
[08:25:47.172]                 }
[08:25:47.172]             }))
[08:25:47.172]             future::FutureResult(value = ...future.value$value, 
[08:25:47.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.172]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.172]                     ...future.globalenv.names))
[08:25:47.172]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.172]         }, condition = base::local({
[08:25:47.172]             c <- base::c
[08:25:47.172]             inherits <- base::inherits
[08:25:47.172]             invokeRestart <- base::invokeRestart
[08:25:47.172]             length <- base::length
[08:25:47.172]             list <- base::list
[08:25:47.172]             seq.int <- base::seq.int
[08:25:47.172]             signalCondition <- base::signalCondition
[08:25:47.172]             sys.calls <- base::sys.calls
[08:25:47.172]             `[[` <- base::`[[`
[08:25:47.172]             `+` <- base::`+`
[08:25:47.172]             `<<-` <- base::`<<-`
[08:25:47.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.172]                   3L)]
[08:25:47.172]             }
[08:25:47.172]             function(cond) {
[08:25:47.172]                 is_error <- inherits(cond, "error")
[08:25:47.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.172]                   NULL)
[08:25:47.172]                 if (is_error) {
[08:25:47.172]                   sessionInformation <- function() {
[08:25:47.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.172]                       search = base::search(), system = base::Sys.info())
[08:25:47.172]                   }
[08:25:47.172]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.172]                     cond$call), session = sessionInformation(), 
[08:25:47.172]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.172]                   signalCondition(cond)
[08:25:47.172]                 }
[08:25:47.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.172]                 "immediateCondition"))) {
[08:25:47.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.172]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.172]                   if (TRUE && !signal) {
[08:25:47.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.172]                     {
[08:25:47.172]                       inherits <- base::inherits
[08:25:47.172]                       invokeRestart <- base::invokeRestart
[08:25:47.172]                       is.null <- base::is.null
[08:25:47.172]                       muffled <- FALSE
[08:25:47.172]                       if (inherits(cond, "message")) {
[08:25:47.172]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.172]                         if (muffled) 
[08:25:47.172]                           invokeRestart("muffleMessage")
[08:25:47.172]                       }
[08:25:47.172]                       else if (inherits(cond, "warning")) {
[08:25:47.172]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.172]                         if (muffled) 
[08:25:47.172]                           invokeRestart("muffleWarning")
[08:25:47.172]                       }
[08:25:47.172]                       else if (inherits(cond, "condition")) {
[08:25:47.172]                         if (!is.null(pattern)) {
[08:25:47.172]                           computeRestarts <- base::computeRestarts
[08:25:47.172]                           grepl <- base::grepl
[08:25:47.172]                           restarts <- computeRestarts(cond)
[08:25:47.172]                           for (restart in restarts) {
[08:25:47.172]                             name <- restart$name
[08:25:47.172]                             if (is.null(name)) 
[08:25:47.172]                               next
[08:25:47.172]                             if (!grepl(pattern, name)) 
[08:25:47.172]                               next
[08:25:47.172]                             invokeRestart(restart)
[08:25:47.172]                             muffled <- TRUE
[08:25:47.172]                             break
[08:25:47.172]                           }
[08:25:47.172]                         }
[08:25:47.172]                       }
[08:25:47.172]                       invisible(muffled)
[08:25:47.172]                     }
[08:25:47.172]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.172]                   }
[08:25:47.172]                 }
[08:25:47.172]                 else {
[08:25:47.172]                   if (TRUE) {
[08:25:47.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.172]                     {
[08:25:47.172]                       inherits <- base::inherits
[08:25:47.172]                       invokeRestart <- base::invokeRestart
[08:25:47.172]                       is.null <- base::is.null
[08:25:47.172]                       muffled <- FALSE
[08:25:47.172]                       if (inherits(cond, "message")) {
[08:25:47.172]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.172]                         if (muffled) 
[08:25:47.172]                           invokeRestart("muffleMessage")
[08:25:47.172]                       }
[08:25:47.172]                       else if (inherits(cond, "warning")) {
[08:25:47.172]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.172]                         if (muffled) 
[08:25:47.172]                           invokeRestart("muffleWarning")
[08:25:47.172]                       }
[08:25:47.172]                       else if (inherits(cond, "condition")) {
[08:25:47.172]                         if (!is.null(pattern)) {
[08:25:47.172]                           computeRestarts <- base::computeRestarts
[08:25:47.172]                           grepl <- base::grepl
[08:25:47.172]                           restarts <- computeRestarts(cond)
[08:25:47.172]                           for (restart in restarts) {
[08:25:47.172]                             name <- restart$name
[08:25:47.172]                             if (is.null(name)) 
[08:25:47.172]                               next
[08:25:47.172]                             if (!grepl(pattern, name)) 
[08:25:47.172]                               next
[08:25:47.172]                             invokeRestart(restart)
[08:25:47.172]                             muffled <- TRUE
[08:25:47.172]                             break
[08:25:47.172]                           }
[08:25:47.172]                         }
[08:25:47.172]                       }
[08:25:47.172]                       invisible(muffled)
[08:25:47.172]                     }
[08:25:47.172]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.172]                   }
[08:25:47.172]                 }
[08:25:47.172]             }
[08:25:47.172]         }))
[08:25:47.172]     }, error = function(ex) {
[08:25:47.172]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.172]                 ...future.rng), started = ...future.startTime, 
[08:25:47.172]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.172]             version = "1.8"), class = "FutureResult")
[08:25:47.172]     }, finally = {
[08:25:47.172]         if (!identical(...future.workdir, getwd())) 
[08:25:47.172]             setwd(...future.workdir)
[08:25:47.172]         {
[08:25:47.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.172]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.172]             }
[08:25:47.172]             base::options(...future.oldOptions)
[08:25:47.172]             if (.Platform$OS.type == "windows") {
[08:25:47.172]                 old_names <- names(...future.oldEnvVars)
[08:25:47.172]                 envs <- base::Sys.getenv()
[08:25:47.172]                 names <- names(envs)
[08:25:47.172]                 common <- intersect(names, old_names)
[08:25:47.172]                 added <- setdiff(names, old_names)
[08:25:47.172]                 removed <- setdiff(old_names, names)
[08:25:47.172]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.172]                   envs[common]]
[08:25:47.172]                 NAMES <- toupper(changed)
[08:25:47.172]                 args <- list()
[08:25:47.172]                 for (kk in seq_along(NAMES)) {
[08:25:47.172]                   name <- changed[[kk]]
[08:25:47.172]                   NAME <- NAMES[[kk]]
[08:25:47.172]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.172]                     next
[08:25:47.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.172]                 }
[08:25:47.172]                 NAMES <- toupper(added)
[08:25:47.172]                 for (kk in seq_along(NAMES)) {
[08:25:47.172]                   name <- added[[kk]]
[08:25:47.172]                   NAME <- NAMES[[kk]]
[08:25:47.172]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.172]                     next
[08:25:47.172]                   args[[name]] <- ""
[08:25:47.172]                 }
[08:25:47.172]                 NAMES <- toupper(removed)
[08:25:47.172]                 for (kk in seq_along(NAMES)) {
[08:25:47.172]                   name <- removed[[kk]]
[08:25:47.172]                   NAME <- NAMES[[kk]]
[08:25:47.172]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.172]                     next
[08:25:47.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.172]                 }
[08:25:47.172]                 if (length(args) > 0) 
[08:25:47.172]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.172]             }
[08:25:47.172]             else {
[08:25:47.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.172]             }
[08:25:47.172]             {
[08:25:47.172]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.172]                   0L) {
[08:25:47.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.172]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.172]                   base::options(opts)
[08:25:47.172]                 }
[08:25:47.172]                 {
[08:25:47.172]                   {
[08:25:47.172]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.172]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.172]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.172]                       inherits = FALSE)
[08:25:47.172]                     NULL
[08:25:47.172]                   }
[08:25:47.172]                   options(future.plan = NULL)
[08:25:47.172]                   if (is.na(NA_character_)) 
[08:25:47.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.172]                     .init = FALSE)
[08:25:47.172]                 }
[08:25:47.172]             }
[08:25:47.172]         }
[08:25:47.172]     })
[08:25:47.172]     if (TRUE) {
[08:25:47.172]         base::sink(type = "output", split = FALSE)
[08:25:47.172]         if (TRUE) {
[08:25:47.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.172]         }
[08:25:47.172]         else {
[08:25:47.172]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.172]         }
[08:25:47.172]         base::close(...future.stdout)
[08:25:47.172]         ...future.stdout <- NULL
[08:25:47.172]     }
[08:25:47.172]     ...future.result$conditions <- ...future.conditions
[08:25:47.172]     ...future.result$finished <- base::Sys.time()
[08:25:47.172]     ...future.result
[08:25:47.172] }
[08:25:47.173] assign_globals() ...
[08:25:47.174] List of 5
[08:25:47.174]  $ ...future.FUN            :function (x, ...)  
[08:25:47.174]  $ MoreArgs                 : NULL
[08:25:47.174]  $ ...future.elements_ii    :List of 2
[08:25:47.174]   ..$ :List of 4
[08:25:47.174]   .. ..$ : int 1
[08:25:47.174]   .. ..$ : int 2
[08:25:47.174]   .. ..$ : int 3
[08:25:47.174]   .. ..$ : int 4
[08:25:47.174]   ..$ :List of 4
[08:25:47.174]   .. ..$ : int 4
[08:25:47.174]   .. ..$ : int 3
[08:25:47.174]   .. ..$ : int 2
[08:25:47.174]   .. ..$ : int 1
[08:25:47.174]  $ ...future.seeds_ii       : NULL
[08:25:47.174]  $ ...future.globals.maxSize: NULL
[08:25:47.174]  - attr(*, "where")=List of 5
[08:25:47.174]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.174]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.174]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.174]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.174]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.174]  - attr(*, "resolved")= logi FALSE
[08:25:47.174]  - attr(*, "total_size")= num 258
[08:25:47.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.174]  - attr(*, "already-done")= logi TRUE
[08:25:47.180] - copied ‘...future.FUN’ to environment
[08:25:47.181] - copied ‘MoreArgs’ to environment
[08:25:47.181] - copied ‘...future.elements_ii’ to environment
[08:25:47.181] - copied ‘...future.seeds_ii’ to environment
[08:25:47.181] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.181] assign_globals() ... done
[08:25:47.181] plan(): Setting new future strategy stack:
[08:25:47.181] List of future strategies:
[08:25:47.181] 1. sequential:
[08:25:47.181]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.181]    - tweaked: FALSE
[08:25:47.181]    - call: NULL
[08:25:47.182] plan(): nbrOfWorkers() = 1
[08:25:47.183] plan(): Setting new future strategy stack:
[08:25:47.183] List of future strategies:
[08:25:47.183] 1. sequential:
[08:25:47.183]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.183]    - tweaked: FALSE
[08:25:47.183]    - call: plan(strategy)
[08:25:47.183] plan(): nbrOfWorkers() = 1
[08:25:47.183] SequentialFuture started (and completed)
[08:25:47.183] - Launch lazy future ... done
[08:25:47.184] run() for ‘SequentialFuture’ ... done
[08:25:47.184] Created future:
[08:25:47.184] SequentialFuture:
[08:25:47.184] Label: ‘future_mapply-1’
[08:25:47.184] Expression:
[08:25:47.184] {
[08:25:47.184]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.184]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.184]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.184]         on.exit(options(oopts), add = TRUE)
[08:25:47.184]     }
[08:25:47.184]     {
[08:25:47.184]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.184]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.184]         do.call(mapply, args = args)
[08:25:47.184]     }
[08:25:47.184] }
[08:25:47.184] Lazy evaluation: FALSE
[08:25:47.184] Asynchronous evaluation: FALSE
[08:25:47.184] Local evaluation: TRUE
[08:25:47.184] Environment: R_GlobalEnv
[08:25:47.184] Capture standard output: TRUE
[08:25:47.184] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.184] Globals: 5 objects totaling 258 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 143 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.184] Packages: <none>
[08:25:47.184] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.184] Resolved: TRUE
[08:25:47.184] Value: 103 bytes of class ‘list’
[08:25:47.184] Early signaling: FALSE
[08:25:47.184] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.184] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.186] Chunk #1 of 1 ... DONE
[08:25:47.186] Launching 1 futures (chunks) ... DONE
[08:25:47.187] Resolving 1 futures (chunks) ...
[08:25:47.187] resolve() on list ...
[08:25:47.187]  recursive: 0
[08:25:47.187]  length: 1
[08:25:47.187] 
[08:25:47.187] resolved() for ‘SequentialFuture’ ...
[08:25:47.187] - state: ‘finished’
[08:25:47.187] - run: TRUE
[08:25:47.187] - result: ‘FutureResult’
[08:25:47.187] resolved() for ‘SequentialFuture’ ... done
[08:25:47.188] Future #1
[08:25:47.188] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.188] - nx: 1
[08:25:47.188] - relay: TRUE
[08:25:47.188] - stdout: TRUE
[08:25:47.188] - signal: TRUE
[08:25:47.188] - resignal: FALSE
[08:25:47.188] - force: TRUE
[08:25:47.188] - relayed: [n=1] FALSE
[08:25:47.188] - queued futures: [n=1] FALSE
[08:25:47.188]  - until=1
[08:25:47.189]  - relaying element #1
[08:25:47.189] - relayed: [n=1] TRUE
[08:25:47.189] - queued futures: [n=1] TRUE
[08:25:47.189] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.189]  length: 0 (resolved future 1)
[08:25:47.189] Relaying remaining futures
[08:25:47.189] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.189] - nx: 1
[08:25:47.189] - relay: TRUE
[08:25:47.189] - stdout: TRUE
[08:25:47.190] - signal: TRUE
[08:25:47.190] - resignal: FALSE
[08:25:47.190] - force: TRUE
[08:25:47.190] - relayed: [n=1] TRUE
[08:25:47.190] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.190] - relayed: [n=1] TRUE
[08:25:47.190] - queued futures: [n=1] TRUE
[08:25:47.190] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.190] resolve() on list ... DONE
[08:25:47.190]  - Number of value chunks collected: 1
[08:25:47.190] Resolving 1 futures (chunks) ... DONE
[08:25:47.191] Reducing values from 1 chunks ...
[08:25:47.191]  - Number of values collected after concatenation: 4
[08:25:47.191]  - Number of values expected: 4
[08:25:47.191] Reducing values from 1 chunks ... DONE
[08:25:47.191] future_mapply() ... DONE
[08:25:47.191] future_mapply() ...
[08:25:47.191] Number of chunks: 1
[08:25:47.191] getGlobalsAndPackagesXApply() ...
[08:25:47.191]  - future.globals: TRUE
[08:25:47.191] getGlobalsAndPackages() ...
[08:25:47.192] Searching for globals...
[08:25:47.192] - globals found: [1] ‘FUN’
[08:25:47.192] Searching for globals ... DONE
[08:25:47.192] Resolving globals: FALSE
[08:25:47.193] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:47.193] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:47.193] - globals: [1] ‘FUN’
[08:25:47.193] 
[08:25:47.193] getGlobalsAndPackages() ... DONE
[08:25:47.193]  - globals found/used: [n=1] ‘FUN’
[08:25:47.194]  - needed namespaces: [n=0] 
[08:25:47.194] Finding globals ... DONE
[08:25:47.194] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.194] List of 2
[08:25:47.194]  $ ...future.FUN:function (x, ...)  
[08:25:47.194]  $ MoreArgs     : NULL
[08:25:47.194]  - attr(*, "where")=List of 2
[08:25:47.194]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.194]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.194]  - attr(*, "resolved")= logi FALSE
[08:25:47.194]  - attr(*, "total_size")= num NA
[08:25:47.196] Packages to be attached in all futures: [n=0] 
[08:25:47.197] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.197] Number of futures (= number of chunks): 1
[08:25:47.197] Launching 1 futures (chunks) ...
[08:25:47.197] Chunk #1 of 1 ...
[08:25:47.197]  - Finding globals in '...' for chunk #1 ...
[08:25:47.197] getGlobalsAndPackages() ...
[08:25:47.197] Searching for globals...
[08:25:47.198] 
[08:25:47.198] Searching for globals ... DONE
[08:25:47.198] - globals: [0] <none>
[08:25:47.198] getGlobalsAndPackages() ... DONE
[08:25:47.198]    + additional globals found: [n=0] 
[08:25:47.198]    + additional namespaces needed: [n=0] 
[08:25:47.198]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.198]  - seeds: <none>
[08:25:47.198]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.198] getGlobalsAndPackages() ...
[08:25:47.198] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.199] Resolving globals: FALSE
[08:25:47.199] The total size of the 5 globals is 258 bytes (258 bytes)
[08:25:47.199] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 258 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (143 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.200] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.200] 
[08:25:47.200] getGlobalsAndPackages() ... DONE
[08:25:47.200] run() for ‘Future’ ...
[08:25:47.200] - state: ‘created’
[08:25:47.200] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.201] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.201]   - Field: ‘label’
[08:25:47.201]   - Field: ‘local’
[08:25:47.201]   - Field: ‘owner’
[08:25:47.201]   - Field: ‘envir’
[08:25:47.201]   - Field: ‘packages’
[08:25:47.201]   - Field: ‘gc’
[08:25:47.201]   - Field: ‘conditions’
[08:25:47.201]   - Field: ‘expr’
[08:25:47.202]   - Field: ‘uuid’
[08:25:47.202]   - Field: ‘seed’
[08:25:47.202]   - Field: ‘version’
[08:25:47.202]   - Field: ‘result’
[08:25:47.202]   - Field: ‘asynchronous’
[08:25:47.202]   - Field: ‘calls’
[08:25:47.202]   - Field: ‘globals’
[08:25:47.202]   - Field: ‘stdout’
[08:25:47.202]   - Field: ‘earlySignal’
[08:25:47.202]   - Field: ‘lazy’
[08:25:47.202]   - Field: ‘state’
[08:25:47.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.203] - Launch lazy future ...
[08:25:47.203] Packages needed by the future expression (n = 0): <none>
[08:25:47.203] Packages needed by future strategies (n = 0): <none>
[08:25:47.203] {
[08:25:47.203]     {
[08:25:47.203]         {
[08:25:47.203]             ...future.startTime <- base::Sys.time()
[08:25:47.203]             {
[08:25:47.203]                 {
[08:25:47.203]                   {
[08:25:47.203]                     base::local({
[08:25:47.203]                       has_future <- base::requireNamespace("future", 
[08:25:47.203]                         quietly = TRUE)
[08:25:47.203]                       if (has_future) {
[08:25:47.203]                         ns <- base::getNamespace("future")
[08:25:47.203]                         version <- ns[[".package"]][["version"]]
[08:25:47.203]                         if (is.null(version)) 
[08:25:47.203]                           version <- utils::packageVersion("future")
[08:25:47.203]                       }
[08:25:47.203]                       else {
[08:25:47.203]                         version <- NULL
[08:25:47.203]                       }
[08:25:47.203]                       if (!has_future || version < "1.8.0") {
[08:25:47.203]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.203]                           "", base::R.version$version.string), 
[08:25:47.203]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.203]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.203]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.203]                             "release", "version")], collapse = " "), 
[08:25:47.203]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.203]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.203]                           info)
[08:25:47.203]                         info <- base::paste(info, collapse = "; ")
[08:25:47.203]                         if (!has_future) {
[08:25:47.203]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.203]                             info)
[08:25:47.203]                         }
[08:25:47.203]                         else {
[08:25:47.203]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.203]                             info, version)
[08:25:47.203]                         }
[08:25:47.203]                         base::stop(msg)
[08:25:47.203]                       }
[08:25:47.203]                     })
[08:25:47.203]                   }
[08:25:47.203]                   ...future.strategy.old <- future::plan("list")
[08:25:47.203]                   options(future.plan = NULL)
[08:25:47.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.203]                 }
[08:25:47.203]                 ...future.workdir <- getwd()
[08:25:47.203]             }
[08:25:47.203]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.203]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.203]         }
[08:25:47.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.203]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.203]             base::names(...future.oldOptions))
[08:25:47.203]     }
[08:25:47.203]     if (FALSE) {
[08:25:47.203]     }
[08:25:47.203]     else {
[08:25:47.203]         if (TRUE) {
[08:25:47.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.203]                 open = "w")
[08:25:47.203]         }
[08:25:47.203]         else {
[08:25:47.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.203]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.203]         }
[08:25:47.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.203]             base::sink(type = "output", split = FALSE)
[08:25:47.203]             base::close(...future.stdout)
[08:25:47.203]         }, add = TRUE)
[08:25:47.203]     }
[08:25:47.203]     ...future.frame <- base::sys.nframe()
[08:25:47.203]     ...future.conditions <- base::list()
[08:25:47.203]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.203]     if (FALSE) {
[08:25:47.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.203]     }
[08:25:47.203]     ...future.result <- base::tryCatch({
[08:25:47.203]         base::withCallingHandlers({
[08:25:47.203]             ...future.value <- base::withVisible(base::local({
[08:25:47.203]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.203]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.203]                   ...future.globals.maxSize)) {
[08:25:47.203]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.203]                   on.exit(options(oopts), add = TRUE)
[08:25:47.203]                 }
[08:25:47.203]                 {
[08:25:47.203]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.203]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.203]                     USE.NAMES = FALSE)
[08:25:47.203]                   do.call(mapply, args = args)
[08:25:47.203]                 }
[08:25:47.203]             }))
[08:25:47.203]             future::FutureResult(value = ...future.value$value, 
[08:25:47.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.203]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.203]                     ...future.globalenv.names))
[08:25:47.203]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.203]         }, condition = base::local({
[08:25:47.203]             c <- base::c
[08:25:47.203]             inherits <- base::inherits
[08:25:47.203]             invokeRestart <- base::invokeRestart
[08:25:47.203]             length <- base::length
[08:25:47.203]             list <- base::list
[08:25:47.203]             seq.int <- base::seq.int
[08:25:47.203]             signalCondition <- base::signalCondition
[08:25:47.203]             sys.calls <- base::sys.calls
[08:25:47.203]             `[[` <- base::`[[`
[08:25:47.203]             `+` <- base::`+`
[08:25:47.203]             `<<-` <- base::`<<-`
[08:25:47.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.203]                   3L)]
[08:25:47.203]             }
[08:25:47.203]             function(cond) {
[08:25:47.203]                 is_error <- inherits(cond, "error")
[08:25:47.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.203]                   NULL)
[08:25:47.203]                 if (is_error) {
[08:25:47.203]                   sessionInformation <- function() {
[08:25:47.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.203]                       search = base::search(), system = base::Sys.info())
[08:25:47.203]                   }
[08:25:47.203]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.203]                     cond$call), session = sessionInformation(), 
[08:25:47.203]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.203]                   signalCondition(cond)
[08:25:47.203]                 }
[08:25:47.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.203]                 "immediateCondition"))) {
[08:25:47.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.203]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.203]                   if (TRUE && !signal) {
[08:25:47.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.203]                     {
[08:25:47.203]                       inherits <- base::inherits
[08:25:47.203]                       invokeRestart <- base::invokeRestart
[08:25:47.203]                       is.null <- base::is.null
[08:25:47.203]                       muffled <- FALSE
[08:25:47.203]                       if (inherits(cond, "message")) {
[08:25:47.203]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.203]                         if (muffled) 
[08:25:47.203]                           invokeRestart("muffleMessage")
[08:25:47.203]                       }
[08:25:47.203]                       else if (inherits(cond, "warning")) {
[08:25:47.203]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.203]                         if (muffled) 
[08:25:47.203]                           invokeRestart("muffleWarning")
[08:25:47.203]                       }
[08:25:47.203]                       else if (inherits(cond, "condition")) {
[08:25:47.203]                         if (!is.null(pattern)) {
[08:25:47.203]                           computeRestarts <- base::computeRestarts
[08:25:47.203]                           grepl <- base::grepl
[08:25:47.203]                           restarts <- computeRestarts(cond)
[08:25:47.203]                           for (restart in restarts) {
[08:25:47.203]                             name <- restart$name
[08:25:47.203]                             if (is.null(name)) 
[08:25:47.203]                               next
[08:25:47.203]                             if (!grepl(pattern, name)) 
[08:25:47.203]                               next
[08:25:47.203]                             invokeRestart(restart)
[08:25:47.203]                             muffled <- TRUE
[08:25:47.203]                             break
[08:25:47.203]                           }
[08:25:47.203]                         }
[08:25:47.203]                       }
[08:25:47.203]                       invisible(muffled)
[08:25:47.203]                     }
[08:25:47.203]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.203]                   }
[08:25:47.203]                 }
[08:25:47.203]                 else {
[08:25:47.203]                   if (TRUE) {
[08:25:47.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.203]                     {
[08:25:47.203]                       inherits <- base::inherits
[08:25:47.203]                       invokeRestart <- base::invokeRestart
[08:25:47.203]                       is.null <- base::is.null
[08:25:47.203]                       muffled <- FALSE
[08:25:47.203]                       if (inherits(cond, "message")) {
[08:25:47.203]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.203]                         if (muffled) 
[08:25:47.203]                           invokeRestart("muffleMessage")
[08:25:47.203]                       }
[08:25:47.203]                       else if (inherits(cond, "warning")) {
[08:25:47.203]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.203]                         if (muffled) 
[08:25:47.203]                           invokeRestart("muffleWarning")
[08:25:47.203]                       }
[08:25:47.203]                       else if (inherits(cond, "condition")) {
[08:25:47.203]                         if (!is.null(pattern)) {
[08:25:47.203]                           computeRestarts <- base::computeRestarts
[08:25:47.203]                           grepl <- base::grepl
[08:25:47.203]                           restarts <- computeRestarts(cond)
[08:25:47.203]                           for (restart in restarts) {
[08:25:47.203]                             name <- restart$name
[08:25:47.203]                             if (is.null(name)) 
[08:25:47.203]                               next
[08:25:47.203]                             if (!grepl(pattern, name)) 
[08:25:47.203]                               next
[08:25:47.203]                             invokeRestart(restart)
[08:25:47.203]                             muffled <- TRUE
[08:25:47.203]                             break
[08:25:47.203]                           }
[08:25:47.203]                         }
[08:25:47.203]                       }
[08:25:47.203]                       invisible(muffled)
[08:25:47.203]                     }
[08:25:47.203]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.203]                   }
[08:25:47.203]                 }
[08:25:47.203]             }
[08:25:47.203]         }))
[08:25:47.203]     }, error = function(ex) {
[08:25:47.203]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.203]                 ...future.rng), started = ...future.startTime, 
[08:25:47.203]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.203]             version = "1.8"), class = "FutureResult")
[08:25:47.203]     }, finally = {
[08:25:47.203]         if (!identical(...future.workdir, getwd())) 
[08:25:47.203]             setwd(...future.workdir)
[08:25:47.203]         {
[08:25:47.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.203]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.203]             }
[08:25:47.203]             base::options(...future.oldOptions)
[08:25:47.203]             if (.Platform$OS.type == "windows") {
[08:25:47.203]                 old_names <- names(...future.oldEnvVars)
[08:25:47.203]                 envs <- base::Sys.getenv()
[08:25:47.203]                 names <- names(envs)
[08:25:47.203]                 common <- intersect(names, old_names)
[08:25:47.203]                 added <- setdiff(names, old_names)
[08:25:47.203]                 removed <- setdiff(old_names, names)
[08:25:47.203]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.203]                   envs[common]]
[08:25:47.203]                 NAMES <- toupper(changed)
[08:25:47.203]                 args <- list()
[08:25:47.203]                 for (kk in seq_along(NAMES)) {
[08:25:47.203]                   name <- changed[[kk]]
[08:25:47.203]                   NAME <- NAMES[[kk]]
[08:25:47.203]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.203]                     next
[08:25:47.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.203]                 }
[08:25:47.203]                 NAMES <- toupper(added)
[08:25:47.203]                 for (kk in seq_along(NAMES)) {
[08:25:47.203]                   name <- added[[kk]]
[08:25:47.203]                   NAME <- NAMES[[kk]]
[08:25:47.203]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.203]                     next
[08:25:47.203]                   args[[name]] <- ""
[08:25:47.203]                 }
[08:25:47.203]                 NAMES <- toupper(removed)
[08:25:47.203]                 for (kk in seq_along(NAMES)) {
[08:25:47.203]                   name <- removed[[kk]]
[08:25:47.203]                   NAME <- NAMES[[kk]]
[08:25:47.203]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.203]                     next
[08:25:47.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.203]                 }
[08:25:47.203]                 if (length(args) > 0) 
[08:25:47.203]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.203]             }
[08:25:47.203]             else {
[08:25:47.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.203]             }
[08:25:47.203]             {
[08:25:47.203]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.203]                   0L) {
[08:25:47.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.203]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.203]                   base::options(opts)
[08:25:47.203]                 }
[08:25:47.203]                 {
[08:25:47.203]                   {
[08:25:47.203]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.203]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.203]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.203]                       inherits = FALSE)
[08:25:47.203]                     NULL
[08:25:47.203]                   }
[08:25:47.203]                   options(future.plan = NULL)
[08:25:47.203]                   if (is.na(NA_character_)) 
[08:25:47.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.203]                     .init = FALSE)
[08:25:47.203]                 }
[08:25:47.203]             }
[08:25:47.203]         }
[08:25:47.203]     })
[08:25:47.203]     if (TRUE) {
[08:25:47.203]         base::sink(type = "output", split = FALSE)
[08:25:47.203]         if (TRUE) {
[08:25:47.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.203]         }
[08:25:47.203]         else {
[08:25:47.203]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.203]         }
[08:25:47.203]         base::close(...future.stdout)
[08:25:47.203]         ...future.stdout <- NULL
[08:25:47.203]     }
[08:25:47.203]     ...future.result$conditions <- ...future.conditions
[08:25:47.203]     ...future.result$finished <- base::Sys.time()
[08:25:47.203]     ...future.result
[08:25:47.203] }
[08:25:47.205] assign_globals() ...
[08:25:47.205] List of 5
[08:25:47.205]  $ ...future.FUN            :function (x, ...)  
[08:25:47.205]  $ MoreArgs                 : NULL
[08:25:47.205]  $ ...future.elements_ii    :List of 2
[08:25:47.205]   ..$ :List of 4
[08:25:47.205]   .. ..$ : int 1
[08:25:47.205]   .. ..$ : int 2
[08:25:47.205]   .. ..$ : int 3
[08:25:47.205]   .. ..$ : int 4
[08:25:47.205]   ..$ :List of 4
[08:25:47.205]   .. ..$ : int 4
[08:25:47.205]   .. ..$ : int 3
[08:25:47.205]   .. ..$ : int 2
[08:25:47.205]   .. ..$ : int 1
[08:25:47.205]  $ ...future.seeds_ii       : NULL
[08:25:47.205]  $ ...future.globals.maxSize: NULL
[08:25:47.205]  - attr(*, "where")=List of 5
[08:25:47.205]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.205]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.205]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.205]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.205]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.205]  - attr(*, "resolved")= logi FALSE
[08:25:47.205]  - attr(*, "total_size")= num 258
[08:25:47.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.205]  - attr(*, "already-done")= logi TRUE
[08:25:47.214] - copied ‘...future.FUN’ to environment
[08:25:47.214] - copied ‘MoreArgs’ to environment
[08:25:47.214] - copied ‘...future.elements_ii’ to environment
[08:25:47.214] - copied ‘...future.seeds_ii’ to environment
[08:25:47.214] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.214] assign_globals() ... done
[08:25:47.215] plan(): Setting new future strategy stack:
[08:25:47.215] List of future strategies:
[08:25:47.215] 1. sequential:
[08:25:47.215]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.215]    - tweaked: FALSE
[08:25:47.215]    - call: NULL
[08:25:47.215] plan(): nbrOfWorkers() = 1
[08:25:47.216] plan(): Setting new future strategy stack:
[08:25:47.216] List of future strategies:
[08:25:47.216] 1. sequential:
[08:25:47.216]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.216]    - tweaked: FALSE
[08:25:47.216]    - call: plan(strategy)
[08:25:47.217] plan(): nbrOfWorkers() = 1
[08:25:47.217] SequentialFuture started (and completed)
[08:25:47.217] - Launch lazy future ... done
[08:25:47.217] run() for ‘SequentialFuture’ ... done
[08:25:47.217] Created future:
[08:25:47.217] SequentialFuture:
[08:25:47.217] Label: ‘future_mapply-1’
[08:25:47.217] Expression:
[08:25:47.217] {
[08:25:47.217]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.217]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.217]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.217]         on.exit(options(oopts), add = TRUE)
[08:25:47.217]     }
[08:25:47.217]     {
[08:25:47.217]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.217]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.217]         do.call(mapply, args = args)
[08:25:47.217]     }
[08:25:47.217] }
[08:25:47.217] Lazy evaluation: FALSE
[08:25:47.217] Asynchronous evaluation: FALSE
[08:25:47.217] Local evaluation: TRUE
[08:25:47.217] Environment: R_GlobalEnv
[08:25:47.217] Capture standard output: TRUE
[08:25:47.217] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.217] Globals: 5 objects totaling 258 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 143 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.217] Packages: <none>
[08:25:47.217] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.217] Resolved: TRUE
[08:25:47.217] Value: 103 bytes of class ‘list’
[08:25:47.217] Early signaling: FALSE
[08:25:47.217] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.217] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.218] Chunk #1 of 1 ... DONE
[08:25:47.218] Launching 1 futures (chunks) ... DONE
[08:25:47.218] Resolving 1 futures (chunks) ...
[08:25:47.218] resolve() on list ...
[08:25:47.218]  recursive: 0
[08:25:47.218]  length: 1
[08:25:47.218] 
[08:25:47.219] resolved() for ‘SequentialFuture’ ...
[08:25:47.219] - state: ‘finished’
[08:25:47.219] - run: TRUE
[08:25:47.219] - result: ‘FutureResult’
[08:25:47.219] resolved() for ‘SequentialFuture’ ... done
[08:25:47.219] Future #1
[08:25:47.219] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.219] - nx: 1
[08:25:47.219] - relay: TRUE
[08:25:47.219] - stdout: TRUE
[08:25:47.220] - signal: TRUE
[08:25:47.220] - resignal: FALSE
[08:25:47.220] - force: TRUE
[08:25:47.220] - relayed: [n=1] FALSE
[08:25:47.220] - queued futures: [n=1] FALSE
[08:25:47.220]  - until=1
[08:25:47.220]  - relaying element #1
[08:25:47.220] - relayed: [n=1] TRUE
[08:25:47.220] - queued futures: [n=1] TRUE
[08:25:47.220] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.221]  length: 0 (resolved future 1)
[08:25:47.221] Relaying remaining futures
[08:25:47.221] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.221] - nx: 1
[08:25:47.221] - relay: TRUE
[08:25:47.221] - stdout: TRUE
[08:25:47.221] - signal: TRUE
[08:25:47.221] - resignal: FALSE
[08:25:47.221] - force: TRUE
[08:25:47.221] - relayed: [n=1] TRUE
[08:25:47.221] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.221] - relayed: [n=1] TRUE
[08:25:47.222] - queued futures: [n=1] TRUE
[08:25:47.222] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.222] resolve() on list ... DONE
[08:25:47.222]  - Number of value chunks collected: 1
[08:25:47.222] Resolving 1 futures (chunks) ... DONE
[08:25:47.222] Reducing values from 1 chunks ...
[08:25:47.222]  - Number of values collected after concatenation: 4
[08:25:47.222]  - Number of values expected: 4
[08:25:47.222] Reducing values from 1 chunks ... DONE
[08:25:47.222] future_mapply() ... DONE
[08:25:47.223] future_mapply() ...
[08:25:47.223] Number of chunks: 1
[08:25:47.223] getGlobalsAndPackagesXApply() ...
[08:25:47.223]  - future.globals: TRUE
[08:25:47.223] getGlobalsAndPackages() ...
[08:25:47.223] Searching for globals...
[08:25:47.224] - globals found: [1] ‘FUN’
[08:25:47.224] Searching for globals ... DONE
[08:25:47.224] Resolving globals: FALSE
[08:25:47.224] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:47.224] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:47.225] - globals: [1] ‘FUN’
[08:25:47.225] 
[08:25:47.225] getGlobalsAndPackages() ... DONE
[08:25:47.225]  - globals found/used: [n=1] ‘FUN’
[08:25:47.225]  - needed namespaces: [n=0] 
[08:25:47.225] Finding globals ... DONE
[08:25:47.225] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.225] List of 2
[08:25:47.225]  $ ...future.FUN:function (x, ...)  
[08:25:47.225]  $ MoreArgs     : NULL
[08:25:47.225]  - attr(*, "where")=List of 2
[08:25:47.225]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.225]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.225]  - attr(*, "resolved")= logi FALSE
[08:25:47.225]  - attr(*, "total_size")= num NA
[08:25:47.228] Packages to be attached in all futures: [n=0] 
[08:25:47.228] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.228] Number of futures (= number of chunks): 1
[08:25:47.228] Launching 1 futures (chunks) ...
[08:25:47.228] Chunk #1 of 1 ...
[08:25:47.228]  - Finding globals in '...' for chunk #1 ...
[08:25:47.229] getGlobalsAndPackages() ...
[08:25:47.229] Searching for globals...
[08:25:47.229] 
[08:25:47.229] Searching for globals ... DONE
[08:25:47.229] - globals: [0] <none>
[08:25:47.229] getGlobalsAndPackages() ... DONE
[08:25:47.229]    + additional globals found: [n=0] 
[08:25:47.229]    + additional namespaces needed: [n=0] 
[08:25:47.230]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.230]  - seeds: <none>
[08:25:47.230]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.230] getGlobalsAndPackages() ...
[08:25:47.230] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.230] Resolving globals: FALSE
[08:25:47.230] The total size of the 5 globals is 313 bytes (313 bytes)
[08:25:47.231] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 313 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (198 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.231] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.231] 
[08:25:47.231] getGlobalsAndPackages() ... DONE
[08:25:47.232] run() for ‘Future’ ...
[08:25:47.232] - state: ‘created’
[08:25:47.232] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.232] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.232] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.232]   - Field: ‘label’
[08:25:47.232]   - Field: ‘local’
[08:25:47.232]   - Field: ‘owner’
[08:25:47.233]   - Field: ‘envir’
[08:25:47.233]   - Field: ‘packages’
[08:25:47.233]   - Field: ‘gc’
[08:25:47.233]   - Field: ‘conditions’
[08:25:47.233]   - Field: ‘expr’
[08:25:47.233]   - Field: ‘uuid’
[08:25:47.233]   - Field: ‘seed’
[08:25:47.233]   - Field: ‘version’
[08:25:47.233]   - Field: ‘result’
[08:25:47.233]   - Field: ‘asynchronous’
[08:25:47.233]   - Field: ‘calls’
[08:25:47.233]   - Field: ‘globals’
[08:25:47.234]   - Field: ‘stdout’
[08:25:47.234]   - Field: ‘earlySignal’
[08:25:47.234]   - Field: ‘lazy’
[08:25:47.234]   - Field: ‘state’
[08:25:47.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.234] - Launch lazy future ...
[08:25:47.234] Packages needed by the future expression (n = 0): <none>
[08:25:47.234] Packages needed by future strategies (n = 0): <none>
[08:25:47.235] {
[08:25:47.235]     {
[08:25:47.235]         {
[08:25:47.235]             ...future.startTime <- base::Sys.time()
[08:25:47.235]             {
[08:25:47.235]                 {
[08:25:47.235]                   {
[08:25:47.235]                     base::local({
[08:25:47.235]                       has_future <- base::requireNamespace("future", 
[08:25:47.235]                         quietly = TRUE)
[08:25:47.235]                       if (has_future) {
[08:25:47.235]                         ns <- base::getNamespace("future")
[08:25:47.235]                         version <- ns[[".package"]][["version"]]
[08:25:47.235]                         if (is.null(version)) 
[08:25:47.235]                           version <- utils::packageVersion("future")
[08:25:47.235]                       }
[08:25:47.235]                       else {
[08:25:47.235]                         version <- NULL
[08:25:47.235]                       }
[08:25:47.235]                       if (!has_future || version < "1.8.0") {
[08:25:47.235]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.235]                           "", base::R.version$version.string), 
[08:25:47.235]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.235]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.235]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.235]                             "release", "version")], collapse = " "), 
[08:25:47.235]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.235]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.235]                           info)
[08:25:47.235]                         info <- base::paste(info, collapse = "; ")
[08:25:47.235]                         if (!has_future) {
[08:25:47.235]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.235]                             info)
[08:25:47.235]                         }
[08:25:47.235]                         else {
[08:25:47.235]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.235]                             info, version)
[08:25:47.235]                         }
[08:25:47.235]                         base::stop(msg)
[08:25:47.235]                       }
[08:25:47.235]                     })
[08:25:47.235]                   }
[08:25:47.235]                   ...future.strategy.old <- future::plan("list")
[08:25:47.235]                   options(future.plan = NULL)
[08:25:47.235]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.235]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.235]                 }
[08:25:47.235]                 ...future.workdir <- getwd()
[08:25:47.235]             }
[08:25:47.235]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.235]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.235]         }
[08:25:47.235]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.235]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.235]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.235]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.235]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.235]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.235]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.235]             base::names(...future.oldOptions))
[08:25:47.235]     }
[08:25:47.235]     if (FALSE) {
[08:25:47.235]     }
[08:25:47.235]     else {
[08:25:47.235]         if (TRUE) {
[08:25:47.235]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.235]                 open = "w")
[08:25:47.235]         }
[08:25:47.235]         else {
[08:25:47.235]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.235]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.235]         }
[08:25:47.235]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.235]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.235]             base::sink(type = "output", split = FALSE)
[08:25:47.235]             base::close(...future.stdout)
[08:25:47.235]         }, add = TRUE)
[08:25:47.235]     }
[08:25:47.235]     ...future.frame <- base::sys.nframe()
[08:25:47.235]     ...future.conditions <- base::list()
[08:25:47.235]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.235]     if (FALSE) {
[08:25:47.235]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.235]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.235]     }
[08:25:47.235]     ...future.result <- base::tryCatch({
[08:25:47.235]         base::withCallingHandlers({
[08:25:47.235]             ...future.value <- base::withVisible(base::local({
[08:25:47.235]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.235]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.235]                   ...future.globals.maxSize)) {
[08:25:47.235]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.235]                   on.exit(options(oopts), add = TRUE)
[08:25:47.235]                 }
[08:25:47.235]                 {
[08:25:47.235]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.235]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.235]                     USE.NAMES = FALSE)
[08:25:47.235]                   do.call(mapply, args = args)
[08:25:47.235]                 }
[08:25:47.235]             }))
[08:25:47.235]             future::FutureResult(value = ...future.value$value, 
[08:25:47.235]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.235]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.235]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.235]                     ...future.globalenv.names))
[08:25:47.235]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.235]         }, condition = base::local({
[08:25:47.235]             c <- base::c
[08:25:47.235]             inherits <- base::inherits
[08:25:47.235]             invokeRestart <- base::invokeRestart
[08:25:47.235]             length <- base::length
[08:25:47.235]             list <- base::list
[08:25:47.235]             seq.int <- base::seq.int
[08:25:47.235]             signalCondition <- base::signalCondition
[08:25:47.235]             sys.calls <- base::sys.calls
[08:25:47.235]             `[[` <- base::`[[`
[08:25:47.235]             `+` <- base::`+`
[08:25:47.235]             `<<-` <- base::`<<-`
[08:25:47.235]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.235]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.235]                   3L)]
[08:25:47.235]             }
[08:25:47.235]             function(cond) {
[08:25:47.235]                 is_error <- inherits(cond, "error")
[08:25:47.235]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.235]                   NULL)
[08:25:47.235]                 if (is_error) {
[08:25:47.235]                   sessionInformation <- function() {
[08:25:47.235]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.235]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.235]                       search = base::search(), system = base::Sys.info())
[08:25:47.235]                   }
[08:25:47.235]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.235]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.235]                     cond$call), session = sessionInformation(), 
[08:25:47.235]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.235]                   signalCondition(cond)
[08:25:47.235]                 }
[08:25:47.235]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.235]                 "immediateCondition"))) {
[08:25:47.235]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.235]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.235]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.235]                   if (TRUE && !signal) {
[08:25:47.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.235]                     {
[08:25:47.235]                       inherits <- base::inherits
[08:25:47.235]                       invokeRestart <- base::invokeRestart
[08:25:47.235]                       is.null <- base::is.null
[08:25:47.235]                       muffled <- FALSE
[08:25:47.235]                       if (inherits(cond, "message")) {
[08:25:47.235]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.235]                         if (muffled) 
[08:25:47.235]                           invokeRestart("muffleMessage")
[08:25:47.235]                       }
[08:25:47.235]                       else if (inherits(cond, "warning")) {
[08:25:47.235]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.235]                         if (muffled) 
[08:25:47.235]                           invokeRestart("muffleWarning")
[08:25:47.235]                       }
[08:25:47.235]                       else if (inherits(cond, "condition")) {
[08:25:47.235]                         if (!is.null(pattern)) {
[08:25:47.235]                           computeRestarts <- base::computeRestarts
[08:25:47.235]                           grepl <- base::grepl
[08:25:47.235]                           restarts <- computeRestarts(cond)
[08:25:47.235]                           for (restart in restarts) {
[08:25:47.235]                             name <- restart$name
[08:25:47.235]                             if (is.null(name)) 
[08:25:47.235]                               next
[08:25:47.235]                             if (!grepl(pattern, name)) 
[08:25:47.235]                               next
[08:25:47.235]                             invokeRestart(restart)
[08:25:47.235]                             muffled <- TRUE
[08:25:47.235]                             break
[08:25:47.235]                           }
[08:25:47.235]                         }
[08:25:47.235]                       }
[08:25:47.235]                       invisible(muffled)
[08:25:47.235]                     }
[08:25:47.235]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.235]                   }
[08:25:47.235]                 }
[08:25:47.235]                 else {
[08:25:47.235]                   if (TRUE) {
[08:25:47.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.235]                     {
[08:25:47.235]                       inherits <- base::inherits
[08:25:47.235]                       invokeRestart <- base::invokeRestart
[08:25:47.235]                       is.null <- base::is.null
[08:25:47.235]                       muffled <- FALSE
[08:25:47.235]                       if (inherits(cond, "message")) {
[08:25:47.235]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.235]                         if (muffled) 
[08:25:47.235]                           invokeRestart("muffleMessage")
[08:25:47.235]                       }
[08:25:47.235]                       else if (inherits(cond, "warning")) {
[08:25:47.235]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.235]                         if (muffled) 
[08:25:47.235]                           invokeRestart("muffleWarning")
[08:25:47.235]                       }
[08:25:47.235]                       else if (inherits(cond, "condition")) {
[08:25:47.235]                         if (!is.null(pattern)) {
[08:25:47.235]                           computeRestarts <- base::computeRestarts
[08:25:47.235]                           grepl <- base::grepl
[08:25:47.235]                           restarts <- computeRestarts(cond)
[08:25:47.235]                           for (restart in restarts) {
[08:25:47.235]                             name <- restart$name
[08:25:47.235]                             if (is.null(name)) 
[08:25:47.235]                               next
[08:25:47.235]                             if (!grepl(pattern, name)) 
[08:25:47.235]                               next
[08:25:47.235]                             invokeRestart(restart)
[08:25:47.235]                             muffled <- TRUE
[08:25:47.235]                             break
[08:25:47.235]                           }
[08:25:47.235]                         }
[08:25:47.235]                       }
[08:25:47.235]                       invisible(muffled)
[08:25:47.235]                     }
[08:25:47.235]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.235]                   }
[08:25:47.235]                 }
[08:25:47.235]             }
[08:25:47.235]         }))
[08:25:47.235]     }, error = function(ex) {
[08:25:47.235]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.235]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.235]                 ...future.rng), started = ...future.startTime, 
[08:25:47.235]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.235]             version = "1.8"), class = "FutureResult")
[08:25:47.235]     }, finally = {
[08:25:47.235]         if (!identical(...future.workdir, getwd())) 
[08:25:47.235]             setwd(...future.workdir)
[08:25:47.235]         {
[08:25:47.235]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.235]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.235]             }
[08:25:47.235]             base::options(...future.oldOptions)
[08:25:47.235]             if (.Platform$OS.type == "windows") {
[08:25:47.235]                 old_names <- names(...future.oldEnvVars)
[08:25:47.235]                 envs <- base::Sys.getenv()
[08:25:47.235]                 names <- names(envs)
[08:25:47.235]                 common <- intersect(names, old_names)
[08:25:47.235]                 added <- setdiff(names, old_names)
[08:25:47.235]                 removed <- setdiff(old_names, names)
[08:25:47.235]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.235]                   envs[common]]
[08:25:47.235]                 NAMES <- toupper(changed)
[08:25:47.235]                 args <- list()
[08:25:47.235]                 for (kk in seq_along(NAMES)) {
[08:25:47.235]                   name <- changed[[kk]]
[08:25:47.235]                   NAME <- NAMES[[kk]]
[08:25:47.235]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.235]                     next
[08:25:47.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.235]                 }
[08:25:47.235]                 NAMES <- toupper(added)
[08:25:47.235]                 for (kk in seq_along(NAMES)) {
[08:25:47.235]                   name <- added[[kk]]
[08:25:47.235]                   NAME <- NAMES[[kk]]
[08:25:47.235]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.235]                     next
[08:25:47.235]                   args[[name]] <- ""
[08:25:47.235]                 }
[08:25:47.235]                 NAMES <- toupper(removed)
[08:25:47.235]                 for (kk in seq_along(NAMES)) {
[08:25:47.235]                   name <- removed[[kk]]
[08:25:47.235]                   NAME <- NAMES[[kk]]
[08:25:47.235]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.235]                     next
[08:25:47.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.235]                 }
[08:25:47.235]                 if (length(args) > 0) 
[08:25:47.235]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.235]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.235]             }
[08:25:47.235]             else {
[08:25:47.235]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.235]             }
[08:25:47.235]             {
[08:25:47.235]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.235]                   0L) {
[08:25:47.235]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.235]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.235]                   base::options(opts)
[08:25:47.235]                 }
[08:25:47.235]                 {
[08:25:47.235]                   {
[08:25:47.235]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.235]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.235]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.235]                       inherits = FALSE)
[08:25:47.235]                     NULL
[08:25:47.235]                   }
[08:25:47.235]                   options(future.plan = NULL)
[08:25:47.235]                   if (is.na(NA_character_)) 
[08:25:47.235]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.235]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.235]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.235]                     .init = FALSE)
[08:25:47.235]                 }
[08:25:47.235]             }
[08:25:47.235]         }
[08:25:47.235]     })
[08:25:47.235]     if (TRUE) {
[08:25:47.235]         base::sink(type = "output", split = FALSE)
[08:25:47.235]         if (TRUE) {
[08:25:47.235]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.235]         }
[08:25:47.235]         else {
[08:25:47.235]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.235]         }
[08:25:47.235]         base::close(...future.stdout)
[08:25:47.235]         ...future.stdout <- NULL
[08:25:47.235]     }
[08:25:47.235]     ...future.result$conditions <- ...future.conditions
[08:25:47.235]     ...future.result$finished <- base::Sys.time()
[08:25:47.235]     ...future.result
[08:25:47.235] }
[08:25:47.237] assign_globals() ...
[08:25:47.237] List of 5
[08:25:47.237]  $ ...future.FUN            :function (x, ...)  
[08:25:47.237]  $ MoreArgs                 : NULL
[08:25:47.237]  $ ...future.elements_ii    :List of 2
[08:25:47.237]   ..$ times:List of 4
[08:25:47.237]   .. ..$ : int 1
[08:25:47.237]   .. ..$ : int 2
[08:25:47.237]   .. ..$ : int 3
[08:25:47.237]   .. ..$ : int 4
[08:25:47.237]   ..$ x    :List of 4
[08:25:47.237]   .. ..$ : int 4
[08:25:47.237]   .. ..$ : int 3
[08:25:47.237]   .. ..$ : int 2
[08:25:47.237]   .. ..$ : int 1
[08:25:47.237]  $ ...future.seeds_ii       : NULL
[08:25:47.237]  $ ...future.globals.maxSize: NULL
[08:25:47.237]  - attr(*, "where")=List of 5
[08:25:47.237]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.237]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.237]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.237]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.237]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.237]  - attr(*, "resolved")= logi FALSE
[08:25:47.237]  - attr(*, "total_size")= num 313
[08:25:47.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.237]  - attr(*, "already-done")= logi TRUE
[08:25:47.246] - copied ‘...future.FUN’ to environment
[08:25:47.246] - copied ‘MoreArgs’ to environment
[08:25:47.246] - copied ‘...future.elements_ii’ to environment
[08:25:47.246] - copied ‘...future.seeds_ii’ to environment
[08:25:47.246] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.246] assign_globals() ... done
[08:25:47.246] plan(): Setting new future strategy stack:
[08:25:47.247] List of future strategies:
[08:25:47.247] 1. sequential:
[08:25:47.247]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.247]    - tweaked: FALSE
[08:25:47.247]    - call: NULL
[08:25:47.247] plan(): nbrOfWorkers() = 1
[08:25:47.248] plan(): Setting new future strategy stack:
[08:25:47.248] List of future strategies:
[08:25:47.248] 1. sequential:
[08:25:47.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.248]    - tweaked: FALSE
[08:25:47.248]    - call: plan(strategy)
[08:25:47.248] plan(): nbrOfWorkers() = 1
[08:25:47.249] SequentialFuture started (and completed)
[08:25:47.249] - Launch lazy future ... done
[08:25:47.249] run() for ‘SequentialFuture’ ... done
[08:25:47.249] Created future:
[08:25:47.249] SequentialFuture:
[08:25:47.249] Label: ‘future_mapply-1’
[08:25:47.249] Expression:
[08:25:47.249] {
[08:25:47.249]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.249]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.249]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.249]         on.exit(options(oopts), add = TRUE)
[08:25:47.249]     }
[08:25:47.249]     {
[08:25:47.249]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.249]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.249]         do.call(mapply, args = args)
[08:25:47.249]     }
[08:25:47.249] }
[08:25:47.249] Lazy evaluation: FALSE
[08:25:47.249] Asynchronous evaluation: FALSE
[08:25:47.249] Local evaluation: TRUE
[08:25:47.249] Environment: R_GlobalEnv
[08:25:47.249] Capture standard output: TRUE
[08:25:47.249] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.249] Globals: 5 objects totaling 313 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 198 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.249] Packages: <none>
[08:25:47.249] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.249] Resolved: TRUE
[08:25:47.249] Value: 103 bytes of class ‘list’
[08:25:47.249] Early signaling: FALSE
[08:25:47.249] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.249] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.250] Chunk #1 of 1 ... DONE
[08:25:47.250] Launching 1 futures (chunks) ... DONE
[08:25:47.250] Resolving 1 futures (chunks) ...
[08:25:47.250] resolve() on list ...
[08:25:47.250]  recursive: 0
[08:25:47.250]  length: 1
[08:25:47.250] 
[08:25:47.251] resolved() for ‘SequentialFuture’ ...
[08:25:47.251] - state: ‘finished’
[08:25:47.251] - run: TRUE
[08:25:47.251] - result: ‘FutureResult’
[08:25:47.251] resolved() for ‘SequentialFuture’ ... done
[08:25:47.251] Future #1
[08:25:47.251] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.251] - nx: 1
[08:25:47.251] - relay: TRUE
[08:25:47.251] - stdout: TRUE
[08:25:47.252] - signal: TRUE
[08:25:47.252] - resignal: FALSE
[08:25:47.252] - force: TRUE
[08:25:47.252] - relayed: [n=1] FALSE
[08:25:47.252] - queued futures: [n=1] FALSE
[08:25:47.252]  - until=1
[08:25:47.252]  - relaying element #1
[08:25:47.252] - relayed: [n=1] TRUE
[08:25:47.252] - queued futures: [n=1] TRUE
[08:25:47.252] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.253]  length: 0 (resolved future 1)
[08:25:47.253] Relaying remaining futures
[08:25:47.253] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.253] - nx: 1
[08:25:47.253] - relay: TRUE
[08:25:47.253] - stdout: TRUE
[08:25:47.253] - signal: TRUE
[08:25:47.253] - resignal: FALSE
[08:25:47.253] - force: TRUE
[08:25:47.253] - relayed: [n=1] TRUE
[08:25:47.253] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.253] - relayed: [n=1] TRUE
[08:25:47.254] - queued futures: [n=1] TRUE
[08:25:47.254] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.254] resolve() on list ... DONE
[08:25:47.254]  - Number of value chunks collected: 1
[08:25:47.254] Resolving 1 futures (chunks) ... DONE
[08:25:47.254] Reducing values from 1 chunks ...
[08:25:47.254]  - Number of values collected after concatenation: 4
[08:25:47.254]  - Number of values expected: 4
[08:25:47.254] Reducing values from 1 chunks ... DONE
[08:25:47.254] future_mapply() ... DONE
[08:25:47.255] future_mapply() ...
[08:25:47.255] Number of chunks: 1
[08:25:47.255] getGlobalsAndPackagesXApply() ...
[08:25:47.255]  - future.globals: TRUE
[08:25:47.255] getGlobalsAndPackages() ...
[08:25:47.255] Searching for globals...
[08:25:47.256] - globals found: [1] ‘FUN’
[08:25:47.256] Searching for globals ... DONE
[08:25:47.256] Resolving globals: FALSE
[08:25:47.256] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:47.257] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:47.257] - globals: [1] ‘FUN’
[08:25:47.257] 
[08:25:47.257] getGlobalsAndPackages() ... DONE
[08:25:47.257]  - globals found/used: [n=1] ‘FUN’
[08:25:47.257]  - needed namespaces: [n=0] 
[08:25:47.257] Finding globals ... DONE
[08:25:47.257] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.258] List of 2
[08:25:47.258]  $ ...future.FUN:function (x, ...)  
[08:25:47.258]  $ MoreArgs     :List of 1
[08:25:47.258]   ..$ x: num 42
[08:25:47.258]  - attr(*, "where")=List of 2
[08:25:47.258]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.258]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.258]  - attr(*, "resolved")= logi FALSE
[08:25:47.258]  - attr(*, "total_size")= num NA
[08:25:47.261] Packages to be attached in all futures: [n=0] 
[08:25:47.261] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.261] Number of futures (= number of chunks): 1
[08:25:47.261] Launching 1 futures (chunks) ...
[08:25:47.261] Chunk #1 of 1 ...
[08:25:47.261]  - Finding globals in '...' for chunk #1 ...
[08:25:47.261] getGlobalsAndPackages() ...
[08:25:47.261] Searching for globals...
[08:25:47.262] 
[08:25:47.262] Searching for globals ... DONE
[08:25:47.262] - globals: [0] <none>
[08:25:47.262] getGlobalsAndPackages() ... DONE
[08:25:47.262]    + additional globals found: [n=0] 
[08:25:47.262]    + additional namespaces needed: [n=0] 
[08:25:47.264]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.264]  - seeds: <none>
[08:25:47.265]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.265] getGlobalsAndPackages() ...
[08:25:47.265] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.265] Resolving globals: FALSE
[08:25:47.265] The total size of the 5 globals is 310 bytes (310 bytes)
[08:25:47.266] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 310 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (133 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[08:25:47.266] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.266] 
[08:25:47.266] getGlobalsAndPackages() ... DONE
[08:25:47.267] run() for ‘Future’ ...
[08:25:47.267] - state: ‘created’
[08:25:47.267] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.267] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.267]   - Field: ‘label’
[08:25:47.268]   - Field: ‘local’
[08:25:47.268]   - Field: ‘owner’
[08:25:47.268]   - Field: ‘envir’
[08:25:47.268]   - Field: ‘packages’
[08:25:47.268]   - Field: ‘gc’
[08:25:47.268]   - Field: ‘conditions’
[08:25:47.268]   - Field: ‘expr’
[08:25:47.268]   - Field: ‘uuid’
[08:25:47.268]   - Field: ‘seed’
[08:25:47.268]   - Field: ‘version’
[08:25:47.268]   - Field: ‘result’
[08:25:47.269]   - Field: ‘asynchronous’
[08:25:47.269]   - Field: ‘calls’
[08:25:47.269]   - Field: ‘globals’
[08:25:47.269]   - Field: ‘stdout’
[08:25:47.269]   - Field: ‘earlySignal’
[08:25:47.269]   - Field: ‘lazy’
[08:25:47.269]   - Field: ‘state’
[08:25:47.269] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.269] - Launch lazy future ...
[08:25:47.270] Packages needed by the future expression (n = 0): <none>
[08:25:47.270] Packages needed by future strategies (n = 0): <none>
[08:25:47.270] {
[08:25:47.270]     {
[08:25:47.270]         {
[08:25:47.270]             ...future.startTime <- base::Sys.time()
[08:25:47.270]             {
[08:25:47.270]                 {
[08:25:47.270]                   {
[08:25:47.270]                     base::local({
[08:25:47.270]                       has_future <- base::requireNamespace("future", 
[08:25:47.270]                         quietly = TRUE)
[08:25:47.270]                       if (has_future) {
[08:25:47.270]                         ns <- base::getNamespace("future")
[08:25:47.270]                         version <- ns[[".package"]][["version"]]
[08:25:47.270]                         if (is.null(version)) 
[08:25:47.270]                           version <- utils::packageVersion("future")
[08:25:47.270]                       }
[08:25:47.270]                       else {
[08:25:47.270]                         version <- NULL
[08:25:47.270]                       }
[08:25:47.270]                       if (!has_future || version < "1.8.0") {
[08:25:47.270]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.270]                           "", base::R.version$version.string), 
[08:25:47.270]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.270]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.270]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.270]                             "release", "version")], collapse = " "), 
[08:25:47.270]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.270]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.270]                           info)
[08:25:47.270]                         info <- base::paste(info, collapse = "; ")
[08:25:47.270]                         if (!has_future) {
[08:25:47.270]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.270]                             info)
[08:25:47.270]                         }
[08:25:47.270]                         else {
[08:25:47.270]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.270]                             info, version)
[08:25:47.270]                         }
[08:25:47.270]                         base::stop(msg)
[08:25:47.270]                       }
[08:25:47.270]                     })
[08:25:47.270]                   }
[08:25:47.270]                   ...future.strategy.old <- future::plan("list")
[08:25:47.270]                   options(future.plan = NULL)
[08:25:47.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.270]                 }
[08:25:47.270]                 ...future.workdir <- getwd()
[08:25:47.270]             }
[08:25:47.270]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.270]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.270]         }
[08:25:47.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.270]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.270]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.270]             base::names(...future.oldOptions))
[08:25:47.270]     }
[08:25:47.270]     if (FALSE) {
[08:25:47.270]     }
[08:25:47.270]     else {
[08:25:47.270]         if (TRUE) {
[08:25:47.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.270]                 open = "w")
[08:25:47.270]         }
[08:25:47.270]         else {
[08:25:47.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.270]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.270]         }
[08:25:47.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.270]             base::sink(type = "output", split = FALSE)
[08:25:47.270]             base::close(...future.stdout)
[08:25:47.270]         }, add = TRUE)
[08:25:47.270]     }
[08:25:47.270]     ...future.frame <- base::sys.nframe()
[08:25:47.270]     ...future.conditions <- base::list()
[08:25:47.270]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.270]     if (FALSE) {
[08:25:47.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.270]     }
[08:25:47.270]     ...future.result <- base::tryCatch({
[08:25:47.270]         base::withCallingHandlers({
[08:25:47.270]             ...future.value <- base::withVisible(base::local({
[08:25:47.270]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.270]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.270]                   ...future.globals.maxSize)) {
[08:25:47.270]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.270]                   on.exit(options(oopts), add = TRUE)
[08:25:47.270]                 }
[08:25:47.270]                 {
[08:25:47.270]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.270]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.270]                     USE.NAMES = FALSE)
[08:25:47.270]                   do.call(mapply, args = args)
[08:25:47.270]                 }
[08:25:47.270]             }))
[08:25:47.270]             future::FutureResult(value = ...future.value$value, 
[08:25:47.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.270]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.270]                     ...future.globalenv.names))
[08:25:47.270]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.270]         }, condition = base::local({
[08:25:47.270]             c <- base::c
[08:25:47.270]             inherits <- base::inherits
[08:25:47.270]             invokeRestart <- base::invokeRestart
[08:25:47.270]             length <- base::length
[08:25:47.270]             list <- base::list
[08:25:47.270]             seq.int <- base::seq.int
[08:25:47.270]             signalCondition <- base::signalCondition
[08:25:47.270]             sys.calls <- base::sys.calls
[08:25:47.270]             `[[` <- base::`[[`
[08:25:47.270]             `+` <- base::`+`
[08:25:47.270]             `<<-` <- base::`<<-`
[08:25:47.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.270]                   3L)]
[08:25:47.270]             }
[08:25:47.270]             function(cond) {
[08:25:47.270]                 is_error <- inherits(cond, "error")
[08:25:47.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.270]                   NULL)
[08:25:47.270]                 if (is_error) {
[08:25:47.270]                   sessionInformation <- function() {
[08:25:47.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.270]                       search = base::search(), system = base::Sys.info())
[08:25:47.270]                   }
[08:25:47.270]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.270]                     cond$call), session = sessionInformation(), 
[08:25:47.270]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.270]                   signalCondition(cond)
[08:25:47.270]                 }
[08:25:47.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.270]                 "immediateCondition"))) {
[08:25:47.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.270]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.270]                   if (TRUE && !signal) {
[08:25:47.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.270]                     {
[08:25:47.270]                       inherits <- base::inherits
[08:25:47.270]                       invokeRestart <- base::invokeRestart
[08:25:47.270]                       is.null <- base::is.null
[08:25:47.270]                       muffled <- FALSE
[08:25:47.270]                       if (inherits(cond, "message")) {
[08:25:47.270]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.270]                         if (muffled) 
[08:25:47.270]                           invokeRestart("muffleMessage")
[08:25:47.270]                       }
[08:25:47.270]                       else if (inherits(cond, "warning")) {
[08:25:47.270]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.270]                         if (muffled) 
[08:25:47.270]                           invokeRestart("muffleWarning")
[08:25:47.270]                       }
[08:25:47.270]                       else if (inherits(cond, "condition")) {
[08:25:47.270]                         if (!is.null(pattern)) {
[08:25:47.270]                           computeRestarts <- base::computeRestarts
[08:25:47.270]                           grepl <- base::grepl
[08:25:47.270]                           restarts <- computeRestarts(cond)
[08:25:47.270]                           for (restart in restarts) {
[08:25:47.270]                             name <- restart$name
[08:25:47.270]                             if (is.null(name)) 
[08:25:47.270]                               next
[08:25:47.270]                             if (!grepl(pattern, name)) 
[08:25:47.270]                               next
[08:25:47.270]                             invokeRestart(restart)
[08:25:47.270]                             muffled <- TRUE
[08:25:47.270]                             break
[08:25:47.270]                           }
[08:25:47.270]                         }
[08:25:47.270]                       }
[08:25:47.270]                       invisible(muffled)
[08:25:47.270]                     }
[08:25:47.270]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.270]                   }
[08:25:47.270]                 }
[08:25:47.270]                 else {
[08:25:47.270]                   if (TRUE) {
[08:25:47.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.270]                     {
[08:25:47.270]                       inherits <- base::inherits
[08:25:47.270]                       invokeRestart <- base::invokeRestart
[08:25:47.270]                       is.null <- base::is.null
[08:25:47.270]                       muffled <- FALSE
[08:25:47.270]                       if (inherits(cond, "message")) {
[08:25:47.270]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.270]                         if (muffled) 
[08:25:47.270]                           invokeRestart("muffleMessage")
[08:25:47.270]                       }
[08:25:47.270]                       else if (inherits(cond, "warning")) {
[08:25:47.270]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.270]                         if (muffled) 
[08:25:47.270]                           invokeRestart("muffleWarning")
[08:25:47.270]                       }
[08:25:47.270]                       else if (inherits(cond, "condition")) {
[08:25:47.270]                         if (!is.null(pattern)) {
[08:25:47.270]                           computeRestarts <- base::computeRestarts
[08:25:47.270]                           grepl <- base::grepl
[08:25:47.270]                           restarts <- computeRestarts(cond)
[08:25:47.270]                           for (restart in restarts) {
[08:25:47.270]                             name <- restart$name
[08:25:47.270]                             if (is.null(name)) 
[08:25:47.270]                               next
[08:25:47.270]                             if (!grepl(pattern, name)) 
[08:25:47.270]                               next
[08:25:47.270]                             invokeRestart(restart)
[08:25:47.270]                             muffled <- TRUE
[08:25:47.270]                             break
[08:25:47.270]                           }
[08:25:47.270]                         }
[08:25:47.270]                       }
[08:25:47.270]                       invisible(muffled)
[08:25:47.270]                     }
[08:25:47.270]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.270]                   }
[08:25:47.270]                 }
[08:25:47.270]             }
[08:25:47.270]         }))
[08:25:47.270]     }, error = function(ex) {
[08:25:47.270]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.270]                 ...future.rng), started = ...future.startTime, 
[08:25:47.270]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.270]             version = "1.8"), class = "FutureResult")
[08:25:47.270]     }, finally = {
[08:25:47.270]         if (!identical(...future.workdir, getwd())) 
[08:25:47.270]             setwd(...future.workdir)
[08:25:47.270]         {
[08:25:47.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.270]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.270]             }
[08:25:47.270]             base::options(...future.oldOptions)
[08:25:47.270]             if (.Platform$OS.type == "windows") {
[08:25:47.270]                 old_names <- names(...future.oldEnvVars)
[08:25:47.270]                 envs <- base::Sys.getenv()
[08:25:47.270]                 names <- names(envs)
[08:25:47.270]                 common <- intersect(names, old_names)
[08:25:47.270]                 added <- setdiff(names, old_names)
[08:25:47.270]                 removed <- setdiff(old_names, names)
[08:25:47.270]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.270]                   envs[common]]
[08:25:47.270]                 NAMES <- toupper(changed)
[08:25:47.270]                 args <- list()
[08:25:47.270]                 for (kk in seq_along(NAMES)) {
[08:25:47.270]                   name <- changed[[kk]]
[08:25:47.270]                   NAME <- NAMES[[kk]]
[08:25:47.270]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.270]                     next
[08:25:47.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.270]                 }
[08:25:47.270]                 NAMES <- toupper(added)
[08:25:47.270]                 for (kk in seq_along(NAMES)) {
[08:25:47.270]                   name <- added[[kk]]
[08:25:47.270]                   NAME <- NAMES[[kk]]
[08:25:47.270]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.270]                     next
[08:25:47.270]                   args[[name]] <- ""
[08:25:47.270]                 }
[08:25:47.270]                 NAMES <- toupper(removed)
[08:25:47.270]                 for (kk in seq_along(NAMES)) {
[08:25:47.270]                   name <- removed[[kk]]
[08:25:47.270]                   NAME <- NAMES[[kk]]
[08:25:47.270]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.270]                     next
[08:25:47.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.270]                 }
[08:25:47.270]                 if (length(args) > 0) 
[08:25:47.270]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.270]             }
[08:25:47.270]             else {
[08:25:47.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.270]             }
[08:25:47.270]             {
[08:25:47.270]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.270]                   0L) {
[08:25:47.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.270]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.270]                   base::options(opts)
[08:25:47.270]                 }
[08:25:47.270]                 {
[08:25:47.270]                   {
[08:25:47.270]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.270]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.270]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.270]                       inherits = FALSE)
[08:25:47.270]                     NULL
[08:25:47.270]                   }
[08:25:47.270]                   options(future.plan = NULL)
[08:25:47.270]                   if (is.na(NA_character_)) 
[08:25:47.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.270]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.270]                     .init = FALSE)
[08:25:47.270]                 }
[08:25:47.270]             }
[08:25:47.270]         }
[08:25:47.270]     })
[08:25:47.270]     if (TRUE) {
[08:25:47.270]         base::sink(type = "output", split = FALSE)
[08:25:47.270]         if (TRUE) {
[08:25:47.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.270]         }
[08:25:47.270]         else {
[08:25:47.270]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.270]         }
[08:25:47.270]         base::close(...future.stdout)
[08:25:47.270]         ...future.stdout <- NULL
[08:25:47.270]     }
[08:25:47.270]     ...future.result$conditions <- ...future.conditions
[08:25:47.270]     ...future.result$finished <- base::Sys.time()
[08:25:47.270]     ...future.result
[08:25:47.270] }
[08:25:47.272] assign_globals() ...
[08:25:47.272] List of 5
[08:25:47.272]  $ ...future.FUN            :function (x, ...)  
[08:25:47.272]  $ MoreArgs                 :List of 1
[08:25:47.272]   ..$ x: num 42
[08:25:47.272]  $ ...future.elements_ii    :List of 1
[08:25:47.272]   ..$ times:List of 4
[08:25:47.272]   .. ..$ : int 1
[08:25:47.272]   .. ..$ : int 2
[08:25:47.272]   .. ..$ : int 3
[08:25:47.272]   .. ..$ : int 4
[08:25:47.272]  $ ...future.seeds_ii       : NULL
[08:25:47.272]  $ ...future.globals.maxSize: NULL
[08:25:47.272]  - attr(*, "where")=List of 5
[08:25:47.272]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.272]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.272]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.272]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.272]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.272]  - attr(*, "resolved")= logi FALSE
[08:25:47.272]  - attr(*, "total_size")= num 310
[08:25:47.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.272]  - attr(*, "already-done")= logi TRUE
[08:25:47.278] - copied ‘...future.FUN’ to environment
[08:25:47.278] - copied ‘MoreArgs’ to environment
[08:25:47.278] - copied ‘...future.elements_ii’ to environment
[08:25:47.279] - copied ‘...future.seeds_ii’ to environment
[08:25:47.279] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.279] assign_globals() ... done
[08:25:47.279] plan(): Setting new future strategy stack:
[08:25:47.279] List of future strategies:
[08:25:47.279] 1. sequential:
[08:25:47.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.279]    - tweaked: FALSE
[08:25:47.279]    - call: NULL
[08:25:47.280] plan(): nbrOfWorkers() = 1
[08:25:47.280] plan(): Setting new future strategy stack:
[08:25:47.281] List of future strategies:
[08:25:47.281] 1. sequential:
[08:25:47.281]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.281]    - tweaked: FALSE
[08:25:47.281]    - call: plan(strategy)
[08:25:47.281] plan(): nbrOfWorkers() = 1
[08:25:47.281] SequentialFuture started (and completed)
[08:25:47.281] - Launch lazy future ... done
[08:25:47.281] run() for ‘SequentialFuture’ ... done
[08:25:47.282] Created future:
[08:25:47.282] SequentialFuture:
[08:25:47.282] Label: ‘future_mapply-1’
[08:25:47.282] Expression:
[08:25:47.282] {
[08:25:47.282]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.282]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.282]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.282]         on.exit(options(oopts), add = TRUE)
[08:25:47.282]     }
[08:25:47.282]     {
[08:25:47.282]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.282]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.282]         do.call(mapply, args = args)
[08:25:47.282]     }
[08:25:47.282] }
[08:25:47.282] Lazy evaluation: FALSE
[08:25:47.282] Asynchronous evaluation: FALSE
[08:25:47.282] Local evaluation: TRUE
[08:25:47.282] Environment: R_GlobalEnv
[08:25:47.282] Capture standard output: TRUE
[08:25:47.282] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.282] Globals: 5 objects totaling 310 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 133 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.282] Packages: <none>
[08:25:47.282] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.282] Resolved: TRUE
[08:25:47.282] Value: 143 bytes of class ‘list’
[08:25:47.282] Early signaling: FALSE
[08:25:47.282] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.282] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.282] Chunk #1 of 1 ... DONE
[08:25:47.283] Launching 1 futures (chunks) ... DONE
[08:25:47.283] Resolving 1 futures (chunks) ...
[08:25:47.283] resolve() on list ...
[08:25:47.283]  recursive: 0
[08:25:47.283]  length: 1
[08:25:47.283] 
[08:25:47.283] resolved() for ‘SequentialFuture’ ...
[08:25:47.283] - state: ‘finished’
[08:25:47.283] - run: TRUE
[08:25:47.283] - result: ‘FutureResult’
[08:25:47.284] resolved() for ‘SequentialFuture’ ... done
[08:25:47.284] Future #1
[08:25:47.284] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.284] - nx: 1
[08:25:47.284] - relay: TRUE
[08:25:47.284] - stdout: TRUE
[08:25:47.284] - signal: TRUE
[08:25:47.284] - resignal: FALSE
[08:25:47.284] - force: TRUE
[08:25:47.284] - relayed: [n=1] FALSE
[08:25:47.285] - queued futures: [n=1] FALSE
[08:25:47.285]  - until=1
[08:25:47.285]  - relaying element #1
[08:25:47.285] - relayed: [n=1] TRUE
[08:25:47.285] - queued futures: [n=1] TRUE
[08:25:47.285] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.285]  length: 0 (resolved future 1)
[08:25:47.285] Relaying remaining futures
[08:25:47.285] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.285] - nx: 1
[08:25:47.286] - relay: TRUE
[08:25:47.286] - stdout: TRUE
[08:25:47.286] - signal: TRUE
[08:25:47.286] - resignal: FALSE
[08:25:47.286] - force: TRUE
[08:25:47.286] - relayed: [n=1] TRUE
[08:25:47.286] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.286] - relayed: [n=1] TRUE
[08:25:47.286] - queued futures: [n=1] TRUE
[08:25:47.286] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.286] resolve() on list ... DONE
[08:25:47.287]  - Number of value chunks collected: 1
[08:25:47.287] Resolving 1 futures (chunks) ... DONE
[08:25:47.287] Reducing values from 1 chunks ...
[08:25:47.287]  - Number of values collected after concatenation: 4
[08:25:47.287]  - Number of values expected: 4
[08:25:47.287] Reducing values from 1 chunks ... DONE
[08:25:47.287] future_mapply() ... DONE
[08:25:47.287] future_mapply() ...
[08:25:47.287] Number of chunks: 1
[08:25:47.288] getGlobalsAndPackagesXApply() ...
[08:25:47.288]  - future.globals: TRUE
[08:25:47.288] getGlobalsAndPackages() ...
[08:25:47.288] Searching for globals...
[08:25:47.289] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[08:25:47.289] Searching for globals ... DONE
[08:25:47.289] Resolving globals: FALSE
[08:25:47.290] The total size of the 1 globals is 414 bytes (414 bytes)
[08:25:47.292] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[08:25:47.292] - globals: [1] ‘FUN’
[08:25:47.292] 
[08:25:47.292] getGlobalsAndPackages() ... DONE
[08:25:47.293]  - globals found/used: [n=1] ‘FUN’
[08:25:47.293]  - needed namespaces: [n=0] 
[08:25:47.293] Finding globals ... DONE
[08:25:47.293] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.293] List of 2
[08:25:47.293]  $ ...future.FUN:function (x, y)  
[08:25:47.293]  $ MoreArgs     : NULL
[08:25:47.293]  - attr(*, "where")=List of 2
[08:25:47.293]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.293]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.293]  - attr(*, "resolved")= logi FALSE
[08:25:47.293]  - attr(*, "total_size")= num NA
[08:25:47.296] Packages to be attached in all futures: [n=0] 
[08:25:47.296] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.296] Number of futures (= number of chunks): 1
[08:25:47.296] Launching 1 futures (chunks) ...
[08:25:47.296] Chunk #1 of 1 ...
[08:25:47.296]  - Finding globals in '...' for chunk #1 ...
[08:25:47.296] getGlobalsAndPackages() ...
[08:25:47.296] Searching for globals...
[08:25:47.297] 
[08:25:47.297] Searching for globals ... DONE
[08:25:47.297] - globals: [0] <none>
[08:25:47.297] getGlobalsAndPackages() ... DONE
[08:25:47.297]    + additional globals found: [n=0] 
[08:25:47.297]    + additional namespaces needed: [n=0] 
[08:25:47.297]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.297]  - seeds: <none>
[08:25:47.297]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.298] getGlobalsAndPackages() ...
[08:25:47.298] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.298] Resolving globals: FALSE
[08:25:47.298] The total size of the 5 globals is 745 bytes (745 bytes)
[08:25:47.299] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 745 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (250 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.299] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.299] 
[08:25:47.299] getGlobalsAndPackages() ... DONE
[08:25:47.299] run() for ‘Future’ ...
[08:25:47.299] - state: ‘created’
[08:25:47.299] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.300] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.300] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.300]   - Field: ‘label’
[08:25:47.300]   - Field: ‘local’
[08:25:47.300]   - Field: ‘owner’
[08:25:47.300]   - Field: ‘envir’
[08:25:47.300]   - Field: ‘packages’
[08:25:47.300]   - Field: ‘gc’
[08:25:47.301]   - Field: ‘conditions’
[08:25:47.301]   - Field: ‘expr’
[08:25:47.301]   - Field: ‘uuid’
[08:25:47.301]   - Field: ‘seed’
[08:25:47.301]   - Field: ‘version’
[08:25:47.301]   - Field: ‘result’
[08:25:47.301]   - Field: ‘asynchronous’
[08:25:47.301]   - Field: ‘calls’
[08:25:47.301]   - Field: ‘globals’
[08:25:47.301]   - Field: ‘stdout’
[08:25:47.301]   - Field: ‘earlySignal’
[08:25:47.301]   - Field: ‘lazy’
[08:25:47.302]   - Field: ‘state’
[08:25:47.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.302] - Launch lazy future ...
[08:25:47.302] Packages needed by the future expression (n = 0): <none>
[08:25:47.302] Packages needed by future strategies (n = 0): <none>
[08:25:47.302] {
[08:25:47.302]     {
[08:25:47.302]         {
[08:25:47.302]             ...future.startTime <- base::Sys.time()
[08:25:47.302]             {
[08:25:47.302]                 {
[08:25:47.302]                   {
[08:25:47.302]                     base::local({
[08:25:47.302]                       has_future <- base::requireNamespace("future", 
[08:25:47.302]                         quietly = TRUE)
[08:25:47.302]                       if (has_future) {
[08:25:47.302]                         ns <- base::getNamespace("future")
[08:25:47.302]                         version <- ns[[".package"]][["version"]]
[08:25:47.302]                         if (is.null(version)) 
[08:25:47.302]                           version <- utils::packageVersion("future")
[08:25:47.302]                       }
[08:25:47.302]                       else {
[08:25:47.302]                         version <- NULL
[08:25:47.302]                       }
[08:25:47.302]                       if (!has_future || version < "1.8.0") {
[08:25:47.302]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.302]                           "", base::R.version$version.string), 
[08:25:47.302]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.302]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.302]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.302]                             "release", "version")], collapse = " "), 
[08:25:47.302]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.302]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.302]                           info)
[08:25:47.302]                         info <- base::paste(info, collapse = "; ")
[08:25:47.302]                         if (!has_future) {
[08:25:47.302]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.302]                             info)
[08:25:47.302]                         }
[08:25:47.302]                         else {
[08:25:47.302]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.302]                             info, version)
[08:25:47.302]                         }
[08:25:47.302]                         base::stop(msg)
[08:25:47.302]                       }
[08:25:47.302]                     })
[08:25:47.302]                   }
[08:25:47.302]                   ...future.strategy.old <- future::plan("list")
[08:25:47.302]                   options(future.plan = NULL)
[08:25:47.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.302]                 }
[08:25:47.302]                 ...future.workdir <- getwd()
[08:25:47.302]             }
[08:25:47.302]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.302]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.302]         }
[08:25:47.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.302]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.302]             base::names(...future.oldOptions))
[08:25:47.302]     }
[08:25:47.302]     if (FALSE) {
[08:25:47.302]     }
[08:25:47.302]     else {
[08:25:47.302]         if (TRUE) {
[08:25:47.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.302]                 open = "w")
[08:25:47.302]         }
[08:25:47.302]         else {
[08:25:47.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.302]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.302]         }
[08:25:47.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.302]             base::sink(type = "output", split = FALSE)
[08:25:47.302]             base::close(...future.stdout)
[08:25:47.302]         }, add = TRUE)
[08:25:47.302]     }
[08:25:47.302]     ...future.frame <- base::sys.nframe()
[08:25:47.302]     ...future.conditions <- base::list()
[08:25:47.302]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.302]     if (FALSE) {
[08:25:47.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.302]     }
[08:25:47.302]     ...future.result <- base::tryCatch({
[08:25:47.302]         base::withCallingHandlers({
[08:25:47.302]             ...future.value <- base::withVisible(base::local({
[08:25:47.302]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.302]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.302]                   ...future.globals.maxSize)) {
[08:25:47.302]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.302]                   on.exit(options(oopts), add = TRUE)
[08:25:47.302]                 }
[08:25:47.302]                 {
[08:25:47.302]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.302]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.302]                     USE.NAMES = FALSE)
[08:25:47.302]                   do.call(mapply, args = args)
[08:25:47.302]                 }
[08:25:47.302]             }))
[08:25:47.302]             future::FutureResult(value = ...future.value$value, 
[08:25:47.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.302]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.302]                     ...future.globalenv.names))
[08:25:47.302]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.302]         }, condition = base::local({
[08:25:47.302]             c <- base::c
[08:25:47.302]             inherits <- base::inherits
[08:25:47.302]             invokeRestart <- base::invokeRestart
[08:25:47.302]             length <- base::length
[08:25:47.302]             list <- base::list
[08:25:47.302]             seq.int <- base::seq.int
[08:25:47.302]             signalCondition <- base::signalCondition
[08:25:47.302]             sys.calls <- base::sys.calls
[08:25:47.302]             `[[` <- base::`[[`
[08:25:47.302]             `+` <- base::`+`
[08:25:47.302]             `<<-` <- base::`<<-`
[08:25:47.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.302]                   3L)]
[08:25:47.302]             }
[08:25:47.302]             function(cond) {
[08:25:47.302]                 is_error <- inherits(cond, "error")
[08:25:47.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.302]                   NULL)
[08:25:47.302]                 if (is_error) {
[08:25:47.302]                   sessionInformation <- function() {
[08:25:47.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.302]                       search = base::search(), system = base::Sys.info())
[08:25:47.302]                   }
[08:25:47.302]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.302]                     cond$call), session = sessionInformation(), 
[08:25:47.302]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.302]                   signalCondition(cond)
[08:25:47.302]                 }
[08:25:47.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.302]                 "immediateCondition"))) {
[08:25:47.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.302]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.302]                   if (TRUE && !signal) {
[08:25:47.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.302]                     {
[08:25:47.302]                       inherits <- base::inherits
[08:25:47.302]                       invokeRestart <- base::invokeRestart
[08:25:47.302]                       is.null <- base::is.null
[08:25:47.302]                       muffled <- FALSE
[08:25:47.302]                       if (inherits(cond, "message")) {
[08:25:47.302]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.302]                         if (muffled) 
[08:25:47.302]                           invokeRestart("muffleMessage")
[08:25:47.302]                       }
[08:25:47.302]                       else if (inherits(cond, "warning")) {
[08:25:47.302]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.302]                         if (muffled) 
[08:25:47.302]                           invokeRestart("muffleWarning")
[08:25:47.302]                       }
[08:25:47.302]                       else if (inherits(cond, "condition")) {
[08:25:47.302]                         if (!is.null(pattern)) {
[08:25:47.302]                           computeRestarts <- base::computeRestarts
[08:25:47.302]                           grepl <- base::grepl
[08:25:47.302]                           restarts <- computeRestarts(cond)
[08:25:47.302]                           for (restart in restarts) {
[08:25:47.302]                             name <- restart$name
[08:25:47.302]                             if (is.null(name)) 
[08:25:47.302]                               next
[08:25:47.302]                             if (!grepl(pattern, name)) 
[08:25:47.302]                               next
[08:25:47.302]                             invokeRestart(restart)
[08:25:47.302]                             muffled <- TRUE
[08:25:47.302]                             break
[08:25:47.302]                           }
[08:25:47.302]                         }
[08:25:47.302]                       }
[08:25:47.302]                       invisible(muffled)
[08:25:47.302]                     }
[08:25:47.302]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.302]                   }
[08:25:47.302]                 }
[08:25:47.302]                 else {
[08:25:47.302]                   if (TRUE) {
[08:25:47.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.302]                     {
[08:25:47.302]                       inherits <- base::inherits
[08:25:47.302]                       invokeRestart <- base::invokeRestart
[08:25:47.302]                       is.null <- base::is.null
[08:25:47.302]                       muffled <- FALSE
[08:25:47.302]                       if (inherits(cond, "message")) {
[08:25:47.302]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.302]                         if (muffled) 
[08:25:47.302]                           invokeRestart("muffleMessage")
[08:25:47.302]                       }
[08:25:47.302]                       else if (inherits(cond, "warning")) {
[08:25:47.302]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.302]                         if (muffled) 
[08:25:47.302]                           invokeRestart("muffleWarning")
[08:25:47.302]                       }
[08:25:47.302]                       else if (inherits(cond, "condition")) {
[08:25:47.302]                         if (!is.null(pattern)) {
[08:25:47.302]                           computeRestarts <- base::computeRestarts
[08:25:47.302]                           grepl <- base::grepl
[08:25:47.302]                           restarts <- computeRestarts(cond)
[08:25:47.302]                           for (restart in restarts) {
[08:25:47.302]                             name <- restart$name
[08:25:47.302]                             if (is.null(name)) 
[08:25:47.302]                               next
[08:25:47.302]                             if (!grepl(pattern, name)) 
[08:25:47.302]                               next
[08:25:47.302]                             invokeRestart(restart)
[08:25:47.302]                             muffled <- TRUE
[08:25:47.302]                             break
[08:25:47.302]                           }
[08:25:47.302]                         }
[08:25:47.302]                       }
[08:25:47.302]                       invisible(muffled)
[08:25:47.302]                     }
[08:25:47.302]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.302]                   }
[08:25:47.302]                 }
[08:25:47.302]             }
[08:25:47.302]         }))
[08:25:47.302]     }, error = function(ex) {
[08:25:47.302]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.302]                 ...future.rng), started = ...future.startTime, 
[08:25:47.302]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.302]             version = "1.8"), class = "FutureResult")
[08:25:47.302]     }, finally = {
[08:25:47.302]         if (!identical(...future.workdir, getwd())) 
[08:25:47.302]             setwd(...future.workdir)
[08:25:47.302]         {
[08:25:47.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.302]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.302]             }
[08:25:47.302]             base::options(...future.oldOptions)
[08:25:47.302]             if (.Platform$OS.type == "windows") {
[08:25:47.302]                 old_names <- names(...future.oldEnvVars)
[08:25:47.302]                 envs <- base::Sys.getenv()
[08:25:47.302]                 names <- names(envs)
[08:25:47.302]                 common <- intersect(names, old_names)
[08:25:47.302]                 added <- setdiff(names, old_names)
[08:25:47.302]                 removed <- setdiff(old_names, names)
[08:25:47.302]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.302]                   envs[common]]
[08:25:47.302]                 NAMES <- toupper(changed)
[08:25:47.302]                 args <- list()
[08:25:47.302]                 for (kk in seq_along(NAMES)) {
[08:25:47.302]                   name <- changed[[kk]]
[08:25:47.302]                   NAME <- NAMES[[kk]]
[08:25:47.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.302]                     next
[08:25:47.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.302]                 }
[08:25:47.302]                 NAMES <- toupper(added)
[08:25:47.302]                 for (kk in seq_along(NAMES)) {
[08:25:47.302]                   name <- added[[kk]]
[08:25:47.302]                   NAME <- NAMES[[kk]]
[08:25:47.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.302]                     next
[08:25:47.302]                   args[[name]] <- ""
[08:25:47.302]                 }
[08:25:47.302]                 NAMES <- toupper(removed)
[08:25:47.302]                 for (kk in seq_along(NAMES)) {
[08:25:47.302]                   name <- removed[[kk]]
[08:25:47.302]                   NAME <- NAMES[[kk]]
[08:25:47.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.302]                     next
[08:25:47.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.302]                 }
[08:25:47.302]                 if (length(args) > 0) 
[08:25:47.302]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.302]             }
[08:25:47.302]             else {
[08:25:47.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.302]             }
[08:25:47.302]             {
[08:25:47.302]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.302]                   0L) {
[08:25:47.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.302]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.302]                   base::options(opts)
[08:25:47.302]                 }
[08:25:47.302]                 {
[08:25:47.302]                   {
[08:25:47.302]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.302]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.302]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.302]                       inherits = FALSE)
[08:25:47.302]                     NULL
[08:25:47.302]                   }
[08:25:47.302]                   options(future.plan = NULL)
[08:25:47.302]                   if (is.na(NA_character_)) 
[08:25:47.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.302]                     .init = FALSE)
[08:25:47.302]                 }
[08:25:47.302]             }
[08:25:47.302]         }
[08:25:47.302]     })
[08:25:47.302]     if (TRUE) {
[08:25:47.302]         base::sink(type = "output", split = FALSE)
[08:25:47.302]         if (TRUE) {
[08:25:47.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.302]         }
[08:25:47.302]         else {
[08:25:47.302]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.302]         }
[08:25:47.302]         base::close(...future.stdout)
[08:25:47.302]         ...future.stdout <- NULL
[08:25:47.302]     }
[08:25:47.302]     ...future.result$conditions <- ...future.conditions
[08:25:47.302]     ...future.result$finished <- base::Sys.time()
[08:25:47.302]     ...future.result
[08:25:47.302] }
[08:25:47.304] assign_globals() ...
[08:25:47.304] List of 5
[08:25:47.304]  $ ...future.FUN            :function (x, y)  
[08:25:47.304]  $ MoreArgs                 : NULL
[08:25:47.304]  $ ...future.elements_ii    :List of 2
[08:25:47.304]   ..$ :List of 3
[08:25:47.304]   .. ..$ a: num 1
[08:25:47.304]   .. ..$ b: num 2
[08:25:47.304]   .. ..$ c: num 3
[08:25:47.304]   ..$ :List of 3
[08:25:47.304]   .. ..$ A: num 10
[08:25:47.304]   .. ..$ B: num 0
[08:25:47.304]   .. ..$ C: num -10
[08:25:47.304]  $ ...future.seeds_ii       : NULL
[08:25:47.304]  $ ...future.globals.maxSize: NULL
[08:25:47.304]  - attr(*, "where")=List of 5
[08:25:47.304]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.304]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.304]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.304]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.304]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.304]  - attr(*, "resolved")= logi FALSE
[08:25:47.304]  - attr(*, "total_size")= num 745
[08:25:47.304]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.304]  - attr(*, "already-done")= logi TRUE
[08:25:47.311] - reassign environment for ‘...future.FUN’
[08:25:47.311] - copied ‘...future.FUN’ to environment
[08:25:47.311] - copied ‘MoreArgs’ to environment
[08:25:47.311] - copied ‘...future.elements_ii’ to environment
[08:25:47.311] - copied ‘...future.seeds_ii’ to environment
[08:25:47.311] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.311] assign_globals() ... done
[08:25:47.312] plan(): Setting new future strategy stack:
[08:25:47.312] List of future strategies:
[08:25:47.312] 1. sequential:
[08:25:47.312]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.312]    - tweaked: FALSE
[08:25:47.312]    - call: NULL
[08:25:47.312] plan(): nbrOfWorkers() = 1
[08:25:47.313] plan(): Setting new future strategy stack:
[08:25:47.313] List of future strategies:
[08:25:47.313] 1. sequential:
[08:25:47.313]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.313]    - tweaked: FALSE
[08:25:47.313]    - call: plan(strategy)
[08:25:47.313] plan(): nbrOfWorkers() = 1
[08:25:47.314] SequentialFuture started (and completed)
[08:25:47.314] - Launch lazy future ... done
[08:25:47.314] run() for ‘SequentialFuture’ ... done
[08:25:47.314] Created future:
[08:25:47.314] SequentialFuture:
[08:25:47.314] Label: ‘future_mapply-1’
[08:25:47.314] Expression:
[08:25:47.314] {
[08:25:47.314]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.314]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.314]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.314]         on.exit(options(oopts), add = TRUE)
[08:25:47.314]     }
[08:25:47.314]     {
[08:25:47.314]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.314]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.314]         do.call(mapply, args = args)
[08:25:47.314]     }
[08:25:47.314] }
[08:25:47.314] Lazy evaluation: FALSE
[08:25:47.314] Asynchronous evaluation: FALSE
[08:25:47.314] Local evaluation: TRUE
[08:25:47.314] Environment: R_GlobalEnv
[08:25:47.314] Capture standard output: TRUE
[08:25:47.314] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.314] Globals: 5 objects totaling 745 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 250 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.314] Packages: <none>
[08:25:47.314] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.314] Resolved: TRUE
[08:25:47.314] Value: 103 bytes of class ‘list’
[08:25:47.314] Early signaling: FALSE
[08:25:47.314] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.314] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.315] Chunk #1 of 1 ... DONE
[08:25:47.315] Launching 1 futures (chunks) ... DONE
[08:25:47.315] Resolving 1 futures (chunks) ...
[08:25:47.315] resolve() on list ...
[08:25:47.315]  recursive: 0
[08:25:47.315]  length: 1
[08:25:47.315] 
[08:25:47.316] resolved() for ‘SequentialFuture’ ...
[08:25:47.316] - state: ‘finished’
[08:25:47.316] - run: TRUE
[08:25:47.316] - result: ‘FutureResult’
[08:25:47.316] resolved() for ‘SequentialFuture’ ... done
[08:25:47.316] Future #1
[08:25:47.316] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.318] - nx: 1
[08:25:47.318] - relay: TRUE
[08:25:47.318] - stdout: TRUE
[08:25:47.319] - signal: TRUE
[08:25:47.319] - resignal: FALSE
[08:25:47.319] - force: TRUE
[08:25:47.319] - relayed: [n=1] FALSE
[08:25:47.319] - queued futures: [n=1] FALSE
[08:25:47.319]  - until=1
[08:25:47.319]  - relaying element #1
[08:25:47.319] - relayed: [n=1] TRUE
[08:25:47.319] - queued futures: [n=1] TRUE
[08:25:47.319] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.320]  length: 0 (resolved future 1)
[08:25:47.320] Relaying remaining futures
[08:25:47.320] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.320] - nx: 1
[08:25:47.320] - relay: TRUE
[08:25:47.320] - stdout: TRUE
[08:25:47.320] - signal: TRUE
[08:25:47.320] - resignal: FALSE
[08:25:47.320] - force: TRUE
[08:25:47.320] - relayed: [n=1] TRUE
[08:25:47.320] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.321] - relayed: [n=1] TRUE
[08:25:47.321] - queued futures: [n=1] TRUE
[08:25:47.321] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.321] resolve() on list ... DONE
[08:25:47.321]  - Number of value chunks collected: 1
[08:25:47.321] Resolving 1 futures (chunks) ... DONE
[08:25:47.321] Reducing values from 1 chunks ...
[08:25:47.321]  - Number of values collected after concatenation: 3
[08:25:47.321]  - Number of values expected: 3
[08:25:47.321] Reducing values from 1 chunks ... DONE
[08:25:47.321] future_mapply() ... DONE
- future_.mapply()
[08:25:47.322] future_mapply() ...
[08:25:47.322] Number of chunks: 1
[08:25:47.323] getGlobalsAndPackagesXApply() ...
[08:25:47.323]  - future.globals: TRUE
[08:25:47.323] getGlobalsAndPackages() ...
[08:25:47.323] Searching for globals...
[08:25:47.324] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[08:25:47.324] Searching for globals ... DONE
[08:25:47.324] Resolving globals: FALSE
[08:25:47.325] The total size of the 1 globals is 414 bytes (414 bytes)
[08:25:47.325] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[08:25:47.325] - globals: [1] ‘FUN’
[08:25:47.325] 
[08:25:47.325] getGlobalsAndPackages() ... DONE
[08:25:47.325]  - globals found/used: [n=1] ‘FUN’
[08:25:47.326]  - needed namespaces: [n=0] 
[08:25:47.326] Finding globals ... DONE
[08:25:47.326] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.326] List of 2
[08:25:47.326]  $ ...future.FUN:function (x, y)  
[08:25:47.326]  $ MoreArgs     : list()
[08:25:47.326]  - attr(*, "where")=List of 2
[08:25:47.326]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.326]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.326]  - attr(*, "resolved")= logi FALSE
[08:25:47.326]  - attr(*, "total_size")= num NA
[08:25:47.328] Packages to be attached in all futures: [n=0] 
[08:25:47.328] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.329] Number of futures (= number of chunks): 1
[08:25:47.329] Launching 1 futures (chunks) ...
[08:25:47.329] Chunk #1 of 1 ...
[08:25:47.329]  - Finding globals in '...' for chunk #1 ...
[08:25:47.329] getGlobalsAndPackages() ...
[08:25:47.329] Searching for globals...
[08:25:47.329] 
[08:25:47.330] Searching for globals ... DONE
[08:25:47.330] - globals: [0] <none>
[08:25:47.330] getGlobalsAndPackages() ... DONE
[08:25:47.330]    + additional globals found: [n=0] 
[08:25:47.330]    + additional namespaces needed: [n=0] 
[08:25:47.330]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.330]  - seeds: <none>
[08:25:47.330]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.330] getGlobalsAndPackages() ...
[08:25:47.330] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.331] Resolving globals: FALSE
[08:25:47.331] The total size of the 5 globals is 749 bytes (749 bytes)
[08:25:47.331] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 749 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (250 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:47.331] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.332] 
[08:25:47.332] getGlobalsAndPackages() ... DONE
[08:25:47.332] run() for ‘Future’ ...
[08:25:47.332] - state: ‘created’
[08:25:47.332] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.332] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.333]   - Field: ‘label’
[08:25:47.333]   - Field: ‘local’
[08:25:47.333]   - Field: ‘owner’
[08:25:47.333]   - Field: ‘envir’
[08:25:47.333]   - Field: ‘packages’
[08:25:47.333]   - Field: ‘gc’
[08:25:47.333]   - Field: ‘conditions’
[08:25:47.333]   - Field: ‘expr’
[08:25:47.333]   - Field: ‘uuid’
[08:25:47.334]   - Field: ‘seed’
[08:25:47.334]   - Field: ‘version’
[08:25:47.334]   - Field: ‘result’
[08:25:47.334]   - Field: ‘asynchronous’
[08:25:47.334]   - Field: ‘calls’
[08:25:47.334]   - Field: ‘globals’
[08:25:47.334]   - Field: ‘stdout’
[08:25:47.334]   - Field: ‘earlySignal’
[08:25:47.334]   - Field: ‘lazy’
[08:25:47.334]   - Field: ‘state’
[08:25:47.334] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.335] - Launch lazy future ...
[08:25:47.335] Packages needed by the future expression (n = 0): <none>
[08:25:47.335] Packages needed by future strategies (n = 0): <none>
[08:25:47.335] {
[08:25:47.335]     {
[08:25:47.335]         {
[08:25:47.335]             ...future.startTime <- base::Sys.time()
[08:25:47.335]             {
[08:25:47.335]                 {
[08:25:47.335]                   {
[08:25:47.335]                     base::local({
[08:25:47.335]                       has_future <- base::requireNamespace("future", 
[08:25:47.335]                         quietly = TRUE)
[08:25:47.335]                       if (has_future) {
[08:25:47.335]                         ns <- base::getNamespace("future")
[08:25:47.335]                         version <- ns[[".package"]][["version"]]
[08:25:47.335]                         if (is.null(version)) 
[08:25:47.335]                           version <- utils::packageVersion("future")
[08:25:47.335]                       }
[08:25:47.335]                       else {
[08:25:47.335]                         version <- NULL
[08:25:47.335]                       }
[08:25:47.335]                       if (!has_future || version < "1.8.0") {
[08:25:47.335]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.335]                           "", base::R.version$version.string), 
[08:25:47.335]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.335]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.335]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.335]                             "release", "version")], collapse = " "), 
[08:25:47.335]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.335]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.335]                           info)
[08:25:47.335]                         info <- base::paste(info, collapse = "; ")
[08:25:47.335]                         if (!has_future) {
[08:25:47.335]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.335]                             info)
[08:25:47.335]                         }
[08:25:47.335]                         else {
[08:25:47.335]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.335]                             info, version)
[08:25:47.335]                         }
[08:25:47.335]                         base::stop(msg)
[08:25:47.335]                       }
[08:25:47.335]                     })
[08:25:47.335]                   }
[08:25:47.335]                   ...future.strategy.old <- future::plan("list")
[08:25:47.335]                   options(future.plan = NULL)
[08:25:47.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.335]                 }
[08:25:47.335]                 ...future.workdir <- getwd()
[08:25:47.335]             }
[08:25:47.335]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.335]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.335]         }
[08:25:47.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.335]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.335]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.335]             base::names(...future.oldOptions))
[08:25:47.335]     }
[08:25:47.335]     if (FALSE) {
[08:25:47.335]     }
[08:25:47.335]     else {
[08:25:47.335]         if (TRUE) {
[08:25:47.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.335]                 open = "w")
[08:25:47.335]         }
[08:25:47.335]         else {
[08:25:47.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.335]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.335]         }
[08:25:47.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.335]             base::sink(type = "output", split = FALSE)
[08:25:47.335]             base::close(...future.stdout)
[08:25:47.335]         }, add = TRUE)
[08:25:47.335]     }
[08:25:47.335]     ...future.frame <- base::sys.nframe()
[08:25:47.335]     ...future.conditions <- base::list()
[08:25:47.335]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.335]     if (FALSE) {
[08:25:47.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.335]     }
[08:25:47.335]     ...future.result <- base::tryCatch({
[08:25:47.335]         base::withCallingHandlers({
[08:25:47.335]             ...future.value <- base::withVisible(base::local({
[08:25:47.335]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.335]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.335]                   ...future.globals.maxSize)) {
[08:25:47.335]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.335]                   on.exit(options(oopts), add = TRUE)
[08:25:47.335]                 }
[08:25:47.335]                 {
[08:25:47.335]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.335]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.335]                     USE.NAMES = FALSE)
[08:25:47.335]                   do.call(mapply, args = args)
[08:25:47.335]                 }
[08:25:47.335]             }))
[08:25:47.335]             future::FutureResult(value = ...future.value$value, 
[08:25:47.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.335]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.335]                     ...future.globalenv.names))
[08:25:47.335]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.335]         }, condition = base::local({
[08:25:47.335]             c <- base::c
[08:25:47.335]             inherits <- base::inherits
[08:25:47.335]             invokeRestart <- base::invokeRestart
[08:25:47.335]             length <- base::length
[08:25:47.335]             list <- base::list
[08:25:47.335]             seq.int <- base::seq.int
[08:25:47.335]             signalCondition <- base::signalCondition
[08:25:47.335]             sys.calls <- base::sys.calls
[08:25:47.335]             `[[` <- base::`[[`
[08:25:47.335]             `+` <- base::`+`
[08:25:47.335]             `<<-` <- base::`<<-`
[08:25:47.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.335]                   3L)]
[08:25:47.335]             }
[08:25:47.335]             function(cond) {
[08:25:47.335]                 is_error <- inherits(cond, "error")
[08:25:47.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.335]                   NULL)
[08:25:47.335]                 if (is_error) {
[08:25:47.335]                   sessionInformation <- function() {
[08:25:47.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.335]                       search = base::search(), system = base::Sys.info())
[08:25:47.335]                   }
[08:25:47.335]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.335]                     cond$call), session = sessionInformation(), 
[08:25:47.335]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.335]                   signalCondition(cond)
[08:25:47.335]                 }
[08:25:47.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.335]                 "immediateCondition"))) {
[08:25:47.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.335]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.335]                   if (TRUE && !signal) {
[08:25:47.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.335]                     {
[08:25:47.335]                       inherits <- base::inherits
[08:25:47.335]                       invokeRestart <- base::invokeRestart
[08:25:47.335]                       is.null <- base::is.null
[08:25:47.335]                       muffled <- FALSE
[08:25:47.335]                       if (inherits(cond, "message")) {
[08:25:47.335]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.335]                         if (muffled) 
[08:25:47.335]                           invokeRestart("muffleMessage")
[08:25:47.335]                       }
[08:25:47.335]                       else if (inherits(cond, "warning")) {
[08:25:47.335]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.335]                         if (muffled) 
[08:25:47.335]                           invokeRestart("muffleWarning")
[08:25:47.335]                       }
[08:25:47.335]                       else if (inherits(cond, "condition")) {
[08:25:47.335]                         if (!is.null(pattern)) {
[08:25:47.335]                           computeRestarts <- base::computeRestarts
[08:25:47.335]                           grepl <- base::grepl
[08:25:47.335]                           restarts <- computeRestarts(cond)
[08:25:47.335]                           for (restart in restarts) {
[08:25:47.335]                             name <- restart$name
[08:25:47.335]                             if (is.null(name)) 
[08:25:47.335]                               next
[08:25:47.335]                             if (!grepl(pattern, name)) 
[08:25:47.335]                               next
[08:25:47.335]                             invokeRestart(restart)
[08:25:47.335]                             muffled <- TRUE
[08:25:47.335]                             break
[08:25:47.335]                           }
[08:25:47.335]                         }
[08:25:47.335]                       }
[08:25:47.335]                       invisible(muffled)
[08:25:47.335]                     }
[08:25:47.335]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.335]                   }
[08:25:47.335]                 }
[08:25:47.335]                 else {
[08:25:47.335]                   if (TRUE) {
[08:25:47.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.335]                     {
[08:25:47.335]                       inherits <- base::inherits
[08:25:47.335]                       invokeRestart <- base::invokeRestart
[08:25:47.335]                       is.null <- base::is.null
[08:25:47.335]                       muffled <- FALSE
[08:25:47.335]                       if (inherits(cond, "message")) {
[08:25:47.335]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.335]                         if (muffled) 
[08:25:47.335]                           invokeRestart("muffleMessage")
[08:25:47.335]                       }
[08:25:47.335]                       else if (inherits(cond, "warning")) {
[08:25:47.335]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.335]                         if (muffled) 
[08:25:47.335]                           invokeRestart("muffleWarning")
[08:25:47.335]                       }
[08:25:47.335]                       else if (inherits(cond, "condition")) {
[08:25:47.335]                         if (!is.null(pattern)) {
[08:25:47.335]                           computeRestarts <- base::computeRestarts
[08:25:47.335]                           grepl <- base::grepl
[08:25:47.335]                           restarts <- computeRestarts(cond)
[08:25:47.335]                           for (restart in restarts) {
[08:25:47.335]                             name <- restart$name
[08:25:47.335]                             if (is.null(name)) 
[08:25:47.335]                               next
[08:25:47.335]                             if (!grepl(pattern, name)) 
[08:25:47.335]                               next
[08:25:47.335]                             invokeRestart(restart)
[08:25:47.335]                             muffled <- TRUE
[08:25:47.335]                             break
[08:25:47.335]                           }
[08:25:47.335]                         }
[08:25:47.335]                       }
[08:25:47.335]                       invisible(muffled)
[08:25:47.335]                     }
[08:25:47.335]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.335]                   }
[08:25:47.335]                 }
[08:25:47.335]             }
[08:25:47.335]         }))
[08:25:47.335]     }, error = function(ex) {
[08:25:47.335]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.335]                 ...future.rng), started = ...future.startTime, 
[08:25:47.335]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.335]             version = "1.8"), class = "FutureResult")
[08:25:47.335]     }, finally = {
[08:25:47.335]         if (!identical(...future.workdir, getwd())) 
[08:25:47.335]             setwd(...future.workdir)
[08:25:47.335]         {
[08:25:47.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.335]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.335]             }
[08:25:47.335]             base::options(...future.oldOptions)
[08:25:47.335]             if (.Platform$OS.type == "windows") {
[08:25:47.335]                 old_names <- names(...future.oldEnvVars)
[08:25:47.335]                 envs <- base::Sys.getenv()
[08:25:47.335]                 names <- names(envs)
[08:25:47.335]                 common <- intersect(names, old_names)
[08:25:47.335]                 added <- setdiff(names, old_names)
[08:25:47.335]                 removed <- setdiff(old_names, names)
[08:25:47.335]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.335]                   envs[common]]
[08:25:47.335]                 NAMES <- toupper(changed)
[08:25:47.335]                 args <- list()
[08:25:47.335]                 for (kk in seq_along(NAMES)) {
[08:25:47.335]                   name <- changed[[kk]]
[08:25:47.335]                   NAME <- NAMES[[kk]]
[08:25:47.335]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.335]                     next
[08:25:47.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.335]                 }
[08:25:47.335]                 NAMES <- toupper(added)
[08:25:47.335]                 for (kk in seq_along(NAMES)) {
[08:25:47.335]                   name <- added[[kk]]
[08:25:47.335]                   NAME <- NAMES[[kk]]
[08:25:47.335]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.335]                     next
[08:25:47.335]                   args[[name]] <- ""
[08:25:47.335]                 }
[08:25:47.335]                 NAMES <- toupper(removed)
[08:25:47.335]                 for (kk in seq_along(NAMES)) {
[08:25:47.335]                   name <- removed[[kk]]
[08:25:47.335]                   NAME <- NAMES[[kk]]
[08:25:47.335]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.335]                     next
[08:25:47.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.335]                 }
[08:25:47.335]                 if (length(args) > 0) 
[08:25:47.335]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.335]             }
[08:25:47.335]             else {
[08:25:47.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.335]             }
[08:25:47.335]             {
[08:25:47.335]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.335]                   0L) {
[08:25:47.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.335]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.335]                   base::options(opts)
[08:25:47.335]                 }
[08:25:47.335]                 {
[08:25:47.335]                   {
[08:25:47.335]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.335]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.335]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.335]                       inherits = FALSE)
[08:25:47.335]                     NULL
[08:25:47.335]                   }
[08:25:47.335]                   options(future.plan = NULL)
[08:25:47.335]                   if (is.na(NA_character_)) 
[08:25:47.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.335]                     .init = FALSE)
[08:25:47.335]                 }
[08:25:47.335]             }
[08:25:47.335]         }
[08:25:47.335]     })
[08:25:47.335]     if (TRUE) {
[08:25:47.335]         base::sink(type = "output", split = FALSE)
[08:25:47.335]         if (TRUE) {
[08:25:47.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.335]         }
[08:25:47.335]         else {
[08:25:47.335]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.335]         }
[08:25:47.335]         base::close(...future.stdout)
[08:25:47.335]         ...future.stdout <- NULL
[08:25:47.335]     }
[08:25:47.335]     ...future.result$conditions <- ...future.conditions
[08:25:47.335]     ...future.result$finished <- base::Sys.time()
[08:25:47.335]     ...future.result
[08:25:47.335] }
[08:25:47.337] assign_globals() ...
[08:25:47.337] List of 5
[08:25:47.337]  $ ...future.FUN            :function (x, y)  
[08:25:47.337]  $ MoreArgs                 : list()
[08:25:47.337]  $ ...future.elements_ii    :List of 2
[08:25:47.337]   ..$ :List of 3
[08:25:47.337]   .. ..$ a: num 1
[08:25:47.337]   .. ..$ b: num 2
[08:25:47.337]   .. ..$ c: num 3
[08:25:47.337]   ..$ :List of 3
[08:25:47.337]   .. ..$ A: num 10
[08:25:47.337]   .. ..$ B: num 0
[08:25:47.337]   .. ..$ C: num -10
[08:25:47.337]  $ ...future.seeds_ii       : NULL
[08:25:47.337]  $ ...future.globals.maxSize: NULL
[08:25:47.337]  - attr(*, "where")=List of 5
[08:25:47.337]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.337]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.337]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.337]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.337]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.337]  - attr(*, "resolved")= logi FALSE
[08:25:47.337]  - attr(*, "total_size")= num 749
[08:25:47.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.337]  - attr(*, "already-done")= logi TRUE
[08:25:47.346] - reassign environment for ‘...future.FUN’
[08:25:47.346] - copied ‘...future.FUN’ to environment
[08:25:47.346] - copied ‘MoreArgs’ to environment
[08:25:47.346] - copied ‘...future.elements_ii’ to environment
[08:25:47.346] - copied ‘...future.seeds_ii’ to environment
[08:25:47.346] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.346] assign_globals() ... done
[08:25:47.347] plan(): Setting new future strategy stack:
[08:25:47.347] List of future strategies:
[08:25:47.347] 1. sequential:
[08:25:47.347]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.347]    - tweaked: FALSE
[08:25:47.347]    - call: NULL
[08:25:47.347] plan(): nbrOfWorkers() = 1
[08:25:47.348] plan(): Setting new future strategy stack:
[08:25:47.348] List of future strategies:
[08:25:47.348] 1. sequential:
[08:25:47.348]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.348]    - tweaked: FALSE
[08:25:47.348]    - call: plan(strategy)
[08:25:47.349] plan(): nbrOfWorkers() = 1
[08:25:47.349] SequentialFuture started (and completed)
[08:25:47.349] - Launch lazy future ... done
[08:25:47.350] run() for ‘SequentialFuture’ ... done
[08:25:47.350] Created future:
[08:25:47.350] SequentialFuture:
[08:25:47.350] Label: ‘future_.mapply-1’
[08:25:47.350] Expression:
[08:25:47.350] {
[08:25:47.350]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.350]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.350]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.350]         on.exit(options(oopts), add = TRUE)
[08:25:47.350]     }
[08:25:47.350]     {
[08:25:47.350]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.350]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.350]         do.call(mapply, args = args)
[08:25:47.350]     }
[08:25:47.350] }
[08:25:47.350] Lazy evaluation: FALSE
[08:25:47.350] Asynchronous evaluation: FALSE
[08:25:47.350] Local evaluation: TRUE
[08:25:47.350] Environment: R_GlobalEnv
[08:25:47.350] Capture standard output: TRUE
[08:25:47.350] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.350] Globals: 5 objects totaling 749 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 250 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.350] Packages: <none>
[08:25:47.350] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.350] Resolved: TRUE
[08:25:47.350] Value: 103 bytes of class ‘list’
[08:25:47.350] Early signaling: FALSE
[08:25:47.350] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.350] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.351] Chunk #1 of 1 ... DONE
[08:25:47.351] Launching 1 futures (chunks) ... DONE
[08:25:47.351] Resolving 1 futures (chunks) ...
[08:25:47.351] resolve() on list ...
[08:25:47.351]  recursive: 0
[08:25:47.351]  length: 1
[08:25:47.351] 
[08:25:47.351] resolved() for ‘SequentialFuture’ ...
[08:25:47.351] - state: ‘finished’
[08:25:47.352] - run: TRUE
[08:25:47.352] - result: ‘FutureResult’
[08:25:47.352] resolved() for ‘SequentialFuture’ ... done
[08:25:47.352] Future #1
[08:25:47.352] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.352] - nx: 1
[08:25:47.352] - relay: TRUE
[08:25:47.352] - stdout: TRUE
[08:25:47.352] - signal: TRUE
[08:25:47.352] - resignal: FALSE
[08:25:47.352] - force: TRUE
[08:25:47.353] - relayed: [n=1] FALSE
[08:25:47.353] - queued futures: [n=1] FALSE
[08:25:47.353]  - until=1
[08:25:47.353]  - relaying element #1
[08:25:47.353] - relayed: [n=1] TRUE
[08:25:47.353] - queued futures: [n=1] TRUE
[08:25:47.353] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.353]  length: 0 (resolved future 1)
[08:25:47.353] Relaying remaining futures
[08:25:47.354] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.354] - nx: 1
[08:25:47.354] - relay: TRUE
[08:25:47.354] - stdout: TRUE
[08:25:47.354] - signal: TRUE
[08:25:47.354] - resignal: FALSE
[08:25:47.354] - force: TRUE
[08:25:47.354] - relayed: [n=1] TRUE
[08:25:47.354] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.354] - relayed: [n=1] TRUE
[08:25:47.354] - queued futures: [n=1] TRUE
[08:25:47.354] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.355] resolve() on list ... DONE
[08:25:47.355]  - Number of value chunks collected: 1
[08:25:47.355] Resolving 1 futures (chunks) ... DONE
[08:25:47.355] Reducing values from 1 chunks ...
[08:25:47.355]  - Number of values collected after concatenation: 3
[08:25:47.355]  - Number of values expected: 3
[08:25:47.355] Reducing values from 1 chunks ... DONE
[08:25:47.355] future_mapply() ... DONE
[08:25:47.356] future_mapply() ...
[08:25:47.357] Number of chunks: 5
[08:25:47.357] getGlobalsAndPackagesXApply() ...
[08:25:47.357]  - future.globals: TRUE
[08:25:47.358] getGlobalsAndPackages() ...
[08:25:47.358] Searching for globals...
[08:25:47.359] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:47.359] Searching for globals ... DONE
[08:25:47.359] Resolving globals: FALSE
[08:25:47.360] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:47.360] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:47.360] - globals: [1] ‘FUN’
[08:25:47.360] 
[08:25:47.360] getGlobalsAndPackages() ... DONE
[08:25:47.361]  - globals found/used: [n=1] ‘FUN’
[08:25:47.361]  - needed namespaces: [n=0] 
[08:25:47.361] Finding globals ... DONE
[08:25:47.361] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.361] List of 2
[08:25:47.361]  $ ...future.FUN:function (C, k)  
[08:25:47.361]  $ MoreArgs     : NULL
[08:25:47.361]  - attr(*, "where")=List of 2
[08:25:47.361]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.361]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.361]  - attr(*, "resolved")= logi FALSE
[08:25:47.361]  - attr(*, "total_size")= num NA
[08:25:47.364] Packages to be attached in all futures: [n=0] 
[08:25:47.364] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.364] Number of futures (= number of chunks): 5
[08:25:47.364] Launching 5 futures (chunks) ...
[08:25:47.364] Chunk #1 of 5 ...
[08:25:47.365]  - Finding globals in '...' for chunk #1 ...
[08:25:47.365] getGlobalsAndPackages() ...
[08:25:47.365] Searching for globals...
[08:25:47.365] 
[08:25:47.365] Searching for globals ... DONE
[08:25:47.365] - globals: [0] <none>
[08:25:47.365] getGlobalsAndPackages() ... DONE
[08:25:47.366]    + additional globals found: [n=0] 
[08:25:47.366]    + additional namespaces needed: [n=0] 
[08:25:47.366]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.366]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:47.366]  - seeds: <none>
[08:25:47.366]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.366] getGlobalsAndPackages() ...
[08:25:47.366] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.366] Resolving globals: FALSE
[08:25:47.367] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:47.367] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.367] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.368] 
[08:25:47.368] getGlobalsAndPackages() ... DONE
[08:25:47.368] run() for ‘Future’ ...
[08:25:47.368] - state: ‘created’
[08:25:47.368] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.369] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.369] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.369]   - Field: ‘label’
[08:25:47.369]   - Field: ‘local’
[08:25:47.369]   - Field: ‘owner’
[08:25:47.369]   - Field: ‘envir’
[08:25:47.369]   - Field: ‘packages’
[08:25:47.372]   - Field: ‘gc’
[08:25:47.372]   - Field: ‘conditions’
[08:25:47.372]   - Field: ‘expr’
[08:25:47.372]   - Field: ‘uuid’
[08:25:47.372]   - Field: ‘seed’
[08:25:47.372]   - Field: ‘version’
[08:25:47.372]   - Field: ‘result’
[08:25:47.373]   - Field: ‘asynchronous’
[08:25:47.373]   - Field: ‘calls’
[08:25:47.373]   - Field: ‘globals’
[08:25:47.373]   - Field: ‘stdout’
[08:25:47.373]   - Field: ‘earlySignal’
[08:25:47.373]   - Field: ‘lazy’
[08:25:47.373]   - Field: ‘state’
[08:25:47.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.373] - Launch lazy future ...
[08:25:47.373] Packages needed by the future expression (n = 0): <none>
[08:25:47.374] Packages needed by future strategies (n = 0): <none>
[08:25:47.374] {
[08:25:47.374]     {
[08:25:47.374]         {
[08:25:47.374]             ...future.startTime <- base::Sys.time()
[08:25:47.374]             {
[08:25:47.374]                 {
[08:25:47.374]                   {
[08:25:47.374]                     base::local({
[08:25:47.374]                       has_future <- base::requireNamespace("future", 
[08:25:47.374]                         quietly = TRUE)
[08:25:47.374]                       if (has_future) {
[08:25:47.374]                         ns <- base::getNamespace("future")
[08:25:47.374]                         version <- ns[[".package"]][["version"]]
[08:25:47.374]                         if (is.null(version)) 
[08:25:47.374]                           version <- utils::packageVersion("future")
[08:25:47.374]                       }
[08:25:47.374]                       else {
[08:25:47.374]                         version <- NULL
[08:25:47.374]                       }
[08:25:47.374]                       if (!has_future || version < "1.8.0") {
[08:25:47.374]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.374]                           "", base::R.version$version.string), 
[08:25:47.374]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.374]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.374]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.374]                             "release", "version")], collapse = " "), 
[08:25:47.374]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.374]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.374]                           info)
[08:25:47.374]                         info <- base::paste(info, collapse = "; ")
[08:25:47.374]                         if (!has_future) {
[08:25:47.374]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.374]                             info)
[08:25:47.374]                         }
[08:25:47.374]                         else {
[08:25:47.374]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.374]                             info, version)
[08:25:47.374]                         }
[08:25:47.374]                         base::stop(msg)
[08:25:47.374]                       }
[08:25:47.374]                     })
[08:25:47.374]                   }
[08:25:47.374]                   ...future.strategy.old <- future::plan("list")
[08:25:47.374]                   options(future.plan = NULL)
[08:25:47.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.374]                 }
[08:25:47.374]                 ...future.workdir <- getwd()
[08:25:47.374]             }
[08:25:47.374]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.374]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.374]         }
[08:25:47.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.374]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:47.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.374]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.374]             base::names(...future.oldOptions))
[08:25:47.374]     }
[08:25:47.374]     if (FALSE) {
[08:25:47.374]     }
[08:25:47.374]     else {
[08:25:47.374]         if (TRUE) {
[08:25:47.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.374]                 open = "w")
[08:25:47.374]         }
[08:25:47.374]         else {
[08:25:47.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.374]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.374]         }
[08:25:47.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.374]             base::sink(type = "output", split = FALSE)
[08:25:47.374]             base::close(...future.stdout)
[08:25:47.374]         }, add = TRUE)
[08:25:47.374]     }
[08:25:47.374]     ...future.frame <- base::sys.nframe()
[08:25:47.374]     ...future.conditions <- base::list()
[08:25:47.374]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.374]     if (FALSE) {
[08:25:47.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.374]     }
[08:25:47.374]     ...future.result <- base::tryCatch({
[08:25:47.374]         base::withCallingHandlers({
[08:25:47.374]             ...future.value <- base::withVisible(base::local({
[08:25:47.374]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.374]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.374]                   ...future.globals.maxSize)) {
[08:25:47.374]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.374]                   on.exit(options(oopts), add = TRUE)
[08:25:47.374]                 }
[08:25:47.374]                 {
[08:25:47.374]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.374]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.374]                     USE.NAMES = FALSE)
[08:25:47.374]                   do.call(mapply, args = args)
[08:25:47.374]                 }
[08:25:47.374]             }))
[08:25:47.374]             future::FutureResult(value = ...future.value$value, 
[08:25:47.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.374]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.374]                     ...future.globalenv.names))
[08:25:47.374]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.374]         }, condition = base::local({
[08:25:47.374]             c <- base::c
[08:25:47.374]             inherits <- base::inherits
[08:25:47.374]             invokeRestart <- base::invokeRestart
[08:25:47.374]             length <- base::length
[08:25:47.374]             list <- base::list
[08:25:47.374]             seq.int <- base::seq.int
[08:25:47.374]             signalCondition <- base::signalCondition
[08:25:47.374]             sys.calls <- base::sys.calls
[08:25:47.374]             `[[` <- base::`[[`
[08:25:47.374]             `+` <- base::`+`
[08:25:47.374]             `<<-` <- base::`<<-`
[08:25:47.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.374]                   3L)]
[08:25:47.374]             }
[08:25:47.374]             function(cond) {
[08:25:47.374]                 is_error <- inherits(cond, "error")
[08:25:47.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.374]                   NULL)
[08:25:47.374]                 if (is_error) {
[08:25:47.374]                   sessionInformation <- function() {
[08:25:47.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.374]                       search = base::search(), system = base::Sys.info())
[08:25:47.374]                   }
[08:25:47.374]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.374]                     cond$call), session = sessionInformation(), 
[08:25:47.374]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.374]                   signalCondition(cond)
[08:25:47.374]                 }
[08:25:47.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.374]                 "immediateCondition"))) {
[08:25:47.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.374]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.374]                   if (TRUE && !signal) {
[08:25:47.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.374]                     {
[08:25:47.374]                       inherits <- base::inherits
[08:25:47.374]                       invokeRestart <- base::invokeRestart
[08:25:47.374]                       is.null <- base::is.null
[08:25:47.374]                       muffled <- FALSE
[08:25:47.374]                       if (inherits(cond, "message")) {
[08:25:47.374]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.374]                         if (muffled) 
[08:25:47.374]                           invokeRestart("muffleMessage")
[08:25:47.374]                       }
[08:25:47.374]                       else if (inherits(cond, "warning")) {
[08:25:47.374]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.374]                         if (muffled) 
[08:25:47.374]                           invokeRestart("muffleWarning")
[08:25:47.374]                       }
[08:25:47.374]                       else if (inherits(cond, "condition")) {
[08:25:47.374]                         if (!is.null(pattern)) {
[08:25:47.374]                           computeRestarts <- base::computeRestarts
[08:25:47.374]                           grepl <- base::grepl
[08:25:47.374]                           restarts <- computeRestarts(cond)
[08:25:47.374]                           for (restart in restarts) {
[08:25:47.374]                             name <- restart$name
[08:25:47.374]                             if (is.null(name)) 
[08:25:47.374]                               next
[08:25:47.374]                             if (!grepl(pattern, name)) 
[08:25:47.374]                               next
[08:25:47.374]                             invokeRestart(restart)
[08:25:47.374]                             muffled <- TRUE
[08:25:47.374]                             break
[08:25:47.374]                           }
[08:25:47.374]                         }
[08:25:47.374]                       }
[08:25:47.374]                       invisible(muffled)
[08:25:47.374]                     }
[08:25:47.374]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.374]                   }
[08:25:47.374]                 }
[08:25:47.374]                 else {
[08:25:47.374]                   if (TRUE) {
[08:25:47.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.374]                     {
[08:25:47.374]                       inherits <- base::inherits
[08:25:47.374]                       invokeRestart <- base::invokeRestart
[08:25:47.374]                       is.null <- base::is.null
[08:25:47.374]                       muffled <- FALSE
[08:25:47.374]                       if (inherits(cond, "message")) {
[08:25:47.374]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.374]                         if (muffled) 
[08:25:47.374]                           invokeRestart("muffleMessage")
[08:25:47.374]                       }
[08:25:47.374]                       else if (inherits(cond, "warning")) {
[08:25:47.374]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.374]                         if (muffled) 
[08:25:47.374]                           invokeRestart("muffleWarning")
[08:25:47.374]                       }
[08:25:47.374]                       else if (inherits(cond, "condition")) {
[08:25:47.374]                         if (!is.null(pattern)) {
[08:25:47.374]                           computeRestarts <- base::computeRestarts
[08:25:47.374]                           grepl <- base::grepl
[08:25:47.374]                           restarts <- computeRestarts(cond)
[08:25:47.374]                           for (restart in restarts) {
[08:25:47.374]                             name <- restart$name
[08:25:47.374]                             if (is.null(name)) 
[08:25:47.374]                               next
[08:25:47.374]                             if (!grepl(pattern, name)) 
[08:25:47.374]                               next
[08:25:47.374]                             invokeRestart(restart)
[08:25:47.374]                             muffled <- TRUE
[08:25:47.374]                             break
[08:25:47.374]                           }
[08:25:47.374]                         }
[08:25:47.374]                       }
[08:25:47.374]                       invisible(muffled)
[08:25:47.374]                     }
[08:25:47.374]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.374]                   }
[08:25:47.374]                 }
[08:25:47.374]             }
[08:25:47.374]         }))
[08:25:47.374]     }, error = function(ex) {
[08:25:47.374]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.374]                 ...future.rng), started = ...future.startTime, 
[08:25:47.374]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.374]             version = "1.8"), class = "FutureResult")
[08:25:47.374]     }, finally = {
[08:25:47.374]         if (!identical(...future.workdir, getwd())) 
[08:25:47.374]             setwd(...future.workdir)
[08:25:47.374]         {
[08:25:47.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.374]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.374]             }
[08:25:47.374]             base::options(...future.oldOptions)
[08:25:47.374]             if (.Platform$OS.type == "windows") {
[08:25:47.374]                 old_names <- names(...future.oldEnvVars)
[08:25:47.374]                 envs <- base::Sys.getenv()
[08:25:47.374]                 names <- names(envs)
[08:25:47.374]                 common <- intersect(names, old_names)
[08:25:47.374]                 added <- setdiff(names, old_names)
[08:25:47.374]                 removed <- setdiff(old_names, names)
[08:25:47.374]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.374]                   envs[common]]
[08:25:47.374]                 NAMES <- toupper(changed)
[08:25:47.374]                 args <- list()
[08:25:47.374]                 for (kk in seq_along(NAMES)) {
[08:25:47.374]                   name <- changed[[kk]]
[08:25:47.374]                   NAME <- NAMES[[kk]]
[08:25:47.374]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.374]                     next
[08:25:47.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.374]                 }
[08:25:47.374]                 NAMES <- toupper(added)
[08:25:47.374]                 for (kk in seq_along(NAMES)) {
[08:25:47.374]                   name <- added[[kk]]
[08:25:47.374]                   NAME <- NAMES[[kk]]
[08:25:47.374]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.374]                     next
[08:25:47.374]                   args[[name]] <- ""
[08:25:47.374]                 }
[08:25:47.374]                 NAMES <- toupper(removed)
[08:25:47.374]                 for (kk in seq_along(NAMES)) {
[08:25:47.374]                   name <- removed[[kk]]
[08:25:47.374]                   NAME <- NAMES[[kk]]
[08:25:47.374]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.374]                     next
[08:25:47.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.374]                 }
[08:25:47.374]                 if (length(args) > 0) 
[08:25:47.374]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.374]             }
[08:25:47.374]             else {
[08:25:47.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.374]             }
[08:25:47.374]             {
[08:25:47.374]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.374]                   0L) {
[08:25:47.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.374]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.374]                   base::options(opts)
[08:25:47.374]                 }
[08:25:47.374]                 {
[08:25:47.374]                   {
[08:25:47.374]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.374]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.374]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.374]                       inherits = FALSE)
[08:25:47.374]                     NULL
[08:25:47.374]                   }
[08:25:47.374]                   options(future.plan = NULL)
[08:25:47.374]                   if (is.na(NA_character_)) 
[08:25:47.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.374]                     .init = FALSE)
[08:25:47.374]                 }
[08:25:47.374]             }
[08:25:47.374]         }
[08:25:47.374]     })
[08:25:47.374]     if (TRUE) {
[08:25:47.374]         base::sink(type = "output", split = FALSE)
[08:25:47.374]         if (TRUE) {
[08:25:47.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.374]         }
[08:25:47.374]         else {
[08:25:47.374]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.374]         }
[08:25:47.374]         base::close(...future.stdout)
[08:25:47.374]         ...future.stdout <- NULL
[08:25:47.374]     }
[08:25:47.374]     ...future.result$conditions <- ...future.conditions
[08:25:47.374]     ...future.result$finished <- base::Sys.time()
[08:25:47.374]     ...future.result
[08:25:47.374] }
[08:25:47.376] assign_globals() ...
[08:25:47.376] List of 5
[08:25:47.376]  $ ...future.FUN            :function (C, k)  
[08:25:47.376]  $ MoreArgs                 : NULL
[08:25:47.376]  $ ...future.elements_ii    :List of 2
[08:25:47.376]   ..$ :List of 1
[08:25:47.376]   .. ..$ : chr "A"
[08:25:47.376]   ..$ :List of 1
[08:25:47.376]   .. ..$ : int 5
[08:25:47.376]  $ ...future.seeds_ii       : NULL
[08:25:47.376]  $ ...future.globals.maxSize: NULL
[08:25:47.376]  - attr(*, "where")=List of 5
[08:25:47.376]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.376]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.376]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.376]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.376]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.376]  - attr(*, "resolved")= logi FALSE
[08:25:47.376]  - attr(*, "total_size")= num 847
[08:25:47.376]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.376]  - attr(*, "already-done")= logi TRUE
[08:25:47.381] - reassign environment for ‘...future.FUN’
[08:25:47.381] - copied ‘...future.FUN’ to environment
[08:25:47.381] - copied ‘MoreArgs’ to environment
[08:25:47.381] - copied ‘...future.elements_ii’ to environment
[08:25:47.382] - copied ‘...future.seeds_ii’ to environment
[08:25:47.382] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.382] assign_globals() ... done
[08:25:47.382] plan(): Setting new future strategy stack:
[08:25:47.382] List of future strategies:
[08:25:47.382] 1. sequential:
[08:25:47.382]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.382]    - tweaked: FALSE
[08:25:47.382]    - call: NULL
[08:25:47.383] plan(): nbrOfWorkers() = 1
[08:25:47.383] plan(): Setting new future strategy stack:
[08:25:47.384] List of future strategies:
[08:25:47.384] 1. sequential:
[08:25:47.384]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.384]    - tweaked: FALSE
[08:25:47.384]    - call: plan(strategy)
[08:25:47.384] plan(): nbrOfWorkers() = 1
[08:25:47.384] SequentialFuture started (and completed)
[08:25:47.384] - Launch lazy future ... done
[08:25:47.384] run() for ‘SequentialFuture’ ... done
[08:25:47.385] Created future:
[08:25:47.385] SequentialFuture:
[08:25:47.385] Label: ‘future_mapply-1’
[08:25:47.385] Expression:
[08:25:47.385] {
[08:25:47.385]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.385]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.385]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.385]         on.exit(options(oopts), add = TRUE)
[08:25:47.385]     }
[08:25:47.385]     {
[08:25:47.385]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.385]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.385]         do.call(mapply, args = args)
[08:25:47.385]     }
[08:25:47.385] }
[08:25:47.385] Lazy evaluation: FALSE
[08:25:47.385] Asynchronous evaluation: FALSE
[08:25:47.385] Local evaluation: TRUE
[08:25:47.385] Environment: R_GlobalEnv
[08:25:47.385] Capture standard output: TRUE
[08:25:47.385] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.385] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.385] Packages: <none>
[08:25:47.385] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.385] Resolved: TRUE
[08:25:47.385] Value: 52 bytes of class ‘list’
[08:25:47.385] Early signaling: FALSE
[08:25:47.385] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.385] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.385] Chunk #1 of 5 ... DONE
[08:25:47.386] Chunk #2 of 5 ...
[08:25:47.386]  - Finding globals in '...' for chunk #2 ...
[08:25:47.386] getGlobalsAndPackages() ...
[08:25:47.386] Searching for globals...
[08:25:47.386] 
[08:25:47.386] Searching for globals ... DONE
[08:25:47.386] - globals: [0] <none>
[08:25:47.386] getGlobalsAndPackages() ... DONE
[08:25:47.387]    + additional globals found: [n=0] 
[08:25:47.387]    + additional namespaces needed: [n=0] 
[08:25:47.387]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:47.387]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:47.387]  - seeds: <none>
[08:25:47.387]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.387] getGlobalsAndPackages() ...
[08:25:47.387] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.387] Resolving globals: FALSE
[08:25:47.388] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:47.388] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.388] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.388] 
[08:25:47.388] getGlobalsAndPackages() ... DONE
[08:25:47.389] run() for ‘Future’ ...
[08:25:47.389] - state: ‘created’
[08:25:47.389] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.389] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.389]   - Field: ‘label’
[08:25:47.390]   - Field: ‘local’
[08:25:47.390]   - Field: ‘owner’
[08:25:47.390]   - Field: ‘envir’
[08:25:47.390]   - Field: ‘packages’
[08:25:47.390]   - Field: ‘gc’
[08:25:47.390]   - Field: ‘conditions’
[08:25:47.390]   - Field: ‘expr’
[08:25:47.390]   - Field: ‘uuid’
[08:25:47.390]   - Field: ‘seed’
[08:25:47.390]   - Field: ‘version’
[08:25:47.390]   - Field: ‘result’
[08:25:47.391]   - Field: ‘asynchronous’
[08:25:47.391]   - Field: ‘calls’
[08:25:47.391]   - Field: ‘globals’
[08:25:47.391]   - Field: ‘stdout’
[08:25:47.391]   - Field: ‘earlySignal’
[08:25:47.391]   - Field: ‘lazy’
[08:25:47.391]   - Field: ‘state’
[08:25:47.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.391] - Launch lazy future ...
[08:25:47.391] Packages needed by the future expression (n = 0): <none>
[08:25:47.392] Packages needed by future strategies (n = 0): <none>
[08:25:47.392] {
[08:25:47.392]     {
[08:25:47.392]         {
[08:25:47.392]             ...future.startTime <- base::Sys.time()
[08:25:47.392]             {
[08:25:47.392]                 {
[08:25:47.392]                   {
[08:25:47.392]                     base::local({
[08:25:47.392]                       has_future <- base::requireNamespace("future", 
[08:25:47.392]                         quietly = TRUE)
[08:25:47.392]                       if (has_future) {
[08:25:47.392]                         ns <- base::getNamespace("future")
[08:25:47.392]                         version <- ns[[".package"]][["version"]]
[08:25:47.392]                         if (is.null(version)) 
[08:25:47.392]                           version <- utils::packageVersion("future")
[08:25:47.392]                       }
[08:25:47.392]                       else {
[08:25:47.392]                         version <- NULL
[08:25:47.392]                       }
[08:25:47.392]                       if (!has_future || version < "1.8.0") {
[08:25:47.392]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.392]                           "", base::R.version$version.string), 
[08:25:47.392]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.392]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.392]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.392]                             "release", "version")], collapse = " "), 
[08:25:47.392]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.392]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.392]                           info)
[08:25:47.392]                         info <- base::paste(info, collapse = "; ")
[08:25:47.392]                         if (!has_future) {
[08:25:47.392]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.392]                             info)
[08:25:47.392]                         }
[08:25:47.392]                         else {
[08:25:47.392]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.392]                             info, version)
[08:25:47.392]                         }
[08:25:47.392]                         base::stop(msg)
[08:25:47.392]                       }
[08:25:47.392]                     })
[08:25:47.392]                   }
[08:25:47.392]                   ...future.strategy.old <- future::plan("list")
[08:25:47.392]                   options(future.plan = NULL)
[08:25:47.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.392]                 }
[08:25:47.392]                 ...future.workdir <- getwd()
[08:25:47.392]             }
[08:25:47.392]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.392]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.392]         }
[08:25:47.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.392]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:47.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.392]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.392]             base::names(...future.oldOptions))
[08:25:47.392]     }
[08:25:47.392]     if (FALSE) {
[08:25:47.392]     }
[08:25:47.392]     else {
[08:25:47.392]         if (TRUE) {
[08:25:47.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.392]                 open = "w")
[08:25:47.392]         }
[08:25:47.392]         else {
[08:25:47.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.392]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.392]         }
[08:25:47.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.392]             base::sink(type = "output", split = FALSE)
[08:25:47.392]             base::close(...future.stdout)
[08:25:47.392]         }, add = TRUE)
[08:25:47.392]     }
[08:25:47.392]     ...future.frame <- base::sys.nframe()
[08:25:47.392]     ...future.conditions <- base::list()
[08:25:47.392]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.392]     if (FALSE) {
[08:25:47.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.392]     }
[08:25:47.392]     ...future.result <- base::tryCatch({
[08:25:47.392]         base::withCallingHandlers({
[08:25:47.392]             ...future.value <- base::withVisible(base::local({
[08:25:47.392]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.392]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.392]                   ...future.globals.maxSize)) {
[08:25:47.392]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.392]                   on.exit(options(oopts), add = TRUE)
[08:25:47.392]                 }
[08:25:47.392]                 {
[08:25:47.392]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.392]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.392]                     USE.NAMES = FALSE)
[08:25:47.392]                   do.call(mapply, args = args)
[08:25:47.392]                 }
[08:25:47.392]             }))
[08:25:47.392]             future::FutureResult(value = ...future.value$value, 
[08:25:47.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.392]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.392]                     ...future.globalenv.names))
[08:25:47.392]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.392]         }, condition = base::local({
[08:25:47.392]             c <- base::c
[08:25:47.392]             inherits <- base::inherits
[08:25:47.392]             invokeRestart <- base::invokeRestart
[08:25:47.392]             length <- base::length
[08:25:47.392]             list <- base::list
[08:25:47.392]             seq.int <- base::seq.int
[08:25:47.392]             signalCondition <- base::signalCondition
[08:25:47.392]             sys.calls <- base::sys.calls
[08:25:47.392]             `[[` <- base::`[[`
[08:25:47.392]             `+` <- base::`+`
[08:25:47.392]             `<<-` <- base::`<<-`
[08:25:47.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.392]                   3L)]
[08:25:47.392]             }
[08:25:47.392]             function(cond) {
[08:25:47.392]                 is_error <- inherits(cond, "error")
[08:25:47.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.392]                   NULL)
[08:25:47.392]                 if (is_error) {
[08:25:47.392]                   sessionInformation <- function() {
[08:25:47.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.392]                       search = base::search(), system = base::Sys.info())
[08:25:47.392]                   }
[08:25:47.392]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.392]                     cond$call), session = sessionInformation(), 
[08:25:47.392]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.392]                   signalCondition(cond)
[08:25:47.392]                 }
[08:25:47.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.392]                 "immediateCondition"))) {
[08:25:47.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.392]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.392]                   if (TRUE && !signal) {
[08:25:47.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.392]                     {
[08:25:47.392]                       inherits <- base::inherits
[08:25:47.392]                       invokeRestart <- base::invokeRestart
[08:25:47.392]                       is.null <- base::is.null
[08:25:47.392]                       muffled <- FALSE
[08:25:47.392]                       if (inherits(cond, "message")) {
[08:25:47.392]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.392]                         if (muffled) 
[08:25:47.392]                           invokeRestart("muffleMessage")
[08:25:47.392]                       }
[08:25:47.392]                       else if (inherits(cond, "warning")) {
[08:25:47.392]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.392]                         if (muffled) 
[08:25:47.392]                           invokeRestart("muffleWarning")
[08:25:47.392]                       }
[08:25:47.392]                       else if (inherits(cond, "condition")) {
[08:25:47.392]                         if (!is.null(pattern)) {
[08:25:47.392]                           computeRestarts <- base::computeRestarts
[08:25:47.392]                           grepl <- base::grepl
[08:25:47.392]                           restarts <- computeRestarts(cond)
[08:25:47.392]                           for (restart in restarts) {
[08:25:47.392]                             name <- restart$name
[08:25:47.392]                             if (is.null(name)) 
[08:25:47.392]                               next
[08:25:47.392]                             if (!grepl(pattern, name)) 
[08:25:47.392]                               next
[08:25:47.392]                             invokeRestart(restart)
[08:25:47.392]                             muffled <- TRUE
[08:25:47.392]                             break
[08:25:47.392]                           }
[08:25:47.392]                         }
[08:25:47.392]                       }
[08:25:47.392]                       invisible(muffled)
[08:25:47.392]                     }
[08:25:47.392]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.392]                   }
[08:25:47.392]                 }
[08:25:47.392]                 else {
[08:25:47.392]                   if (TRUE) {
[08:25:47.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.392]                     {
[08:25:47.392]                       inherits <- base::inherits
[08:25:47.392]                       invokeRestart <- base::invokeRestart
[08:25:47.392]                       is.null <- base::is.null
[08:25:47.392]                       muffled <- FALSE
[08:25:47.392]                       if (inherits(cond, "message")) {
[08:25:47.392]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.392]                         if (muffled) 
[08:25:47.392]                           invokeRestart("muffleMessage")
[08:25:47.392]                       }
[08:25:47.392]                       else if (inherits(cond, "warning")) {
[08:25:47.392]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.392]                         if (muffled) 
[08:25:47.392]                           invokeRestart("muffleWarning")
[08:25:47.392]                       }
[08:25:47.392]                       else if (inherits(cond, "condition")) {
[08:25:47.392]                         if (!is.null(pattern)) {
[08:25:47.392]                           computeRestarts <- base::computeRestarts
[08:25:47.392]                           grepl <- base::grepl
[08:25:47.392]                           restarts <- computeRestarts(cond)
[08:25:47.392]                           for (restart in restarts) {
[08:25:47.392]                             name <- restart$name
[08:25:47.392]                             if (is.null(name)) 
[08:25:47.392]                               next
[08:25:47.392]                             if (!grepl(pattern, name)) 
[08:25:47.392]                               next
[08:25:47.392]                             invokeRestart(restart)
[08:25:47.392]                             muffled <- TRUE
[08:25:47.392]                             break
[08:25:47.392]                           }
[08:25:47.392]                         }
[08:25:47.392]                       }
[08:25:47.392]                       invisible(muffled)
[08:25:47.392]                     }
[08:25:47.392]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.392]                   }
[08:25:47.392]                 }
[08:25:47.392]             }
[08:25:47.392]         }))
[08:25:47.392]     }, error = function(ex) {
[08:25:47.392]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.392]                 ...future.rng), started = ...future.startTime, 
[08:25:47.392]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.392]             version = "1.8"), class = "FutureResult")
[08:25:47.392]     }, finally = {
[08:25:47.392]         if (!identical(...future.workdir, getwd())) 
[08:25:47.392]             setwd(...future.workdir)
[08:25:47.392]         {
[08:25:47.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.392]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.392]             }
[08:25:47.392]             base::options(...future.oldOptions)
[08:25:47.392]             if (.Platform$OS.type == "windows") {
[08:25:47.392]                 old_names <- names(...future.oldEnvVars)
[08:25:47.392]                 envs <- base::Sys.getenv()
[08:25:47.392]                 names <- names(envs)
[08:25:47.392]                 common <- intersect(names, old_names)
[08:25:47.392]                 added <- setdiff(names, old_names)
[08:25:47.392]                 removed <- setdiff(old_names, names)
[08:25:47.392]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.392]                   envs[common]]
[08:25:47.392]                 NAMES <- toupper(changed)
[08:25:47.392]                 args <- list()
[08:25:47.392]                 for (kk in seq_along(NAMES)) {
[08:25:47.392]                   name <- changed[[kk]]
[08:25:47.392]                   NAME <- NAMES[[kk]]
[08:25:47.392]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.392]                     next
[08:25:47.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.392]                 }
[08:25:47.392]                 NAMES <- toupper(added)
[08:25:47.392]                 for (kk in seq_along(NAMES)) {
[08:25:47.392]                   name <- added[[kk]]
[08:25:47.392]                   NAME <- NAMES[[kk]]
[08:25:47.392]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.392]                     next
[08:25:47.392]                   args[[name]] <- ""
[08:25:47.392]                 }
[08:25:47.392]                 NAMES <- toupper(removed)
[08:25:47.392]                 for (kk in seq_along(NAMES)) {
[08:25:47.392]                   name <- removed[[kk]]
[08:25:47.392]                   NAME <- NAMES[[kk]]
[08:25:47.392]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.392]                     next
[08:25:47.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.392]                 }
[08:25:47.392]                 if (length(args) > 0) 
[08:25:47.392]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.392]             }
[08:25:47.392]             else {
[08:25:47.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.392]             }
[08:25:47.392]             {
[08:25:47.392]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.392]                   0L) {
[08:25:47.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.392]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.392]                   base::options(opts)
[08:25:47.392]                 }
[08:25:47.392]                 {
[08:25:47.392]                   {
[08:25:47.392]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.392]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.392]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.392]                       inherits = FALSE)
[08:25:47.392]                     NULL
[08:25:47.392]                   }
[08:25:47.392]                   options(future.plan = NULL)
[08:25:47.392]                   if (is.na(NA_character_)) 
[08:25:47.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.392]                     .init = FALSE)
[08:25:47.392]                 }
[08:25:47.392]             }
[08:25:47.392]         }
[08:25:47.392]     })
[08:25:47.392]     if (TRUE) {
[08:25:47.392]         base::sink(type = "output", split = FALSE)
[08:25:47.392]         if (TRUE) {
[08:25:47.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.392]         }
[08:25:47.392]         else {
[08:25:47.392]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.392]         }
[08:25:47.392]         base::close(...future.stdout)
[08:25:47.392]         ...future.stdout <- NULL
[08:25:47.392]     }
[08:25:47.392]     ...future.result$conditions <- ...future.conditions
[08:25:47.392]     ...future.result$finished <- base::Sys.time()
[08:25:47.392]     ...future.result
[08:25:47.392] }
[08:25:47.394] assign_globals() ...
[08:25:47.394] List of 5
[08:25:47.394]  $ ...future.FUN            :function (C, k)  
[08:25:47.394]  $ MoreArgs                 : NULL
[08:25:47.394]  $ ...future.elements_ii    :List of 2
[08:25:47.394]   ..$ :List of 1
[08:25:47.394]   .. ..$ : chr "B"
[08:25:47.394]   ..$ :List of 1
[08:25:47.394]   .. ..$ : int 4
[08:25:47.394]  $ ...future.seeds_ii       : NULL
[08:25:47.394]  $ ...future.globals.maxSize: NULL
[08:25:47.394]  - attr(*, "where")=List of 5
[08:25:47.394]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.394]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.394]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.394]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.394]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.394]  - attr(*, "resolved")= logi FALSE
[08:25:47.394]  - attr(*, "total_size")= num 847
[08:25:47.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.394]  - attr(*, "already-done")= logi TRUE
[08:25:47.401] - reassign environment for ‘...future.FUN’
[08:25:47.401] - copied ‘...future.FUN’ to environment
[08:25:47.401] - copied ‘MoreArgs’ to environment
[08:25:47.401] - copied ‘...future.elements_ii’ to environment
[08:25:47.401] - copied ‘...future.seeds_ii’ to environment
[08:25:47.401] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.401] assign_globals() ... done
[08:25:47.402] plan(): Setting new future strategy stack:
[08:25:47.402] List of future strategies:
[08:25:47.402] 1. sequential:
[08:25:47.402]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.402]    - tweaked: FALSE
[08:25:47.402]    - call: NULL
[08:25:47.402] plan(): nbrOfWorkers() = 1
[08:25:47.403] plan(): Setting new future strategy stack:
[08:25:47.403] List of future strategies:
[08:25:47.403] 1. sequential:
[08:25:47.403]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.403]    - tweaked: FALSE
[08:25:47.403]    - call: plan(strategy)
[08:25:47.404] plan(): nbrOfWorkers() = 1
[08:25:47.404] SequentialFuture started (and completed)
[08:25:47.404] - Launch lazy future ... done
[08:25:47.404] run() for ‘SequentialFuture’ ... done
[08:25:47.404] Created future:
[08:25:47.404] SequentialFuture:
[08:25:47.404] Label: ‘future_mapply-2’
[08:25:47.404] Expression:
[08:25:47.404] {
[08:25:47.404]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.404]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.404]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.404]         on.exit(options(oopts), add = TRUE)
[08:25:47.404]     }
[08:25:47.404]     {
[08:25:47.404]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.404]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.404]         do.call(mapply, args = args)
[08:25:47.404]     }
[08:25:47.404] }
[08:25:47.404] Lazy evaluation: FALSE
[08:25:47.404] Asynchronous evaluation: FALSE
[08:25:47.404] Local evaluation: TRUE
[08:25:47.404] Environment: R_GlobalEnv
[08:25:47.404] Capture standard output: TRUE
[08:25:47.404] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.404] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.404] Packages: <none>
[08:25:47.404] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.404] Resolved: TRUE
[08:25:47.404] Value: 51 bytes of class ‘list’
[08:25:47.404] Early signaling: FALSE
[08:25:47.404] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.404] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.405] Chunk #2 of 5 ... DONE
[08:25:47.405] Chunk #3 of 5 ...
[08:25:47.405]  - Finding globals in '...' for chunk #3 ...
[08:25:47.405] getGlobalsAndPackages() ...
[08:25:47.405] Searching for globals...
[08:25:47.406] 
[08:25:47.406] Searching for globals ... DONE
[08:25:47.406] - globals: [0] <none>
[08:25:47.406] getGlobalsAndPackages() ... DONE
[08:25:47.406]    + additional globals found: [n=0] 
[08:25:47.406]    + additional namespaces needed: [n=0] 
[08:25:47.406]  - Finding globals in '...' for chunk #3 ... DONE
[08:25:47.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:47.406]  - seeds: <none>
[08:25:47.406]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.407] getGlobalsAndPackages() ...
[08:25:47.407] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.407] Resolving globals: FALSE
[08:25:47.407] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:47.408] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.408] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.408] 
[08:25:47.408] getGlobalsAndPackages() ... DONE
[08:25:47.408] run() for ‘Future’ ...
[08:25:47.408] - state: ‘created’
[08:25:47.408] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.409] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.409] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.409]   - Field: ‘label’
[08:25:47.409]   - Field: ‘local’
[08:25:47.409]   - Field: ‘owner’
[08:25:47.409]   - Field: ‘envir’
[08:25:47.409]   - Field: ‘packages’
[08:25:47.409]   - Field: ‘gc’
[08:25:47.409]   - Field: ‘conditions’
[08:25:47.410]   - Field: ‘expr’
[08:25:47.410]   - Field: ‘uuid’
[08:25:47.410]   - Field: ‘seed’
[08:25:47.410]   - Field: ‘version’
[08:25:47.410]   - Field: ‘result’
[08:25:47.410]   - Field: ‘asynchronous’
[08:25:47.410]   - Field: ‘calls’
[08:25:47.410]   - Field: ‘globals’
[08:25:47.410]   - Field: ‘stdout’
[08:25:47.410]   - Field: ‘earlySignal’
[08:25:47.410]   - Field: ‘lazy’
[08:25:47.411]   - Field: ‘state’
[08:25:47.411] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.411] - Launch lazy future ...
[08:25:47.411] Packages needed by the future expression (n = 0): <none>
[08:25:47.411] Packages needed by future strategies (n = 0): <none>
[08:25:47.411] {
[08:25:47.411]     {
[08:25:47.411]         {
[08:25:47.411]             ...future.startTime <- base::Sys.time()
[08:25:47.411]             {
[08:25:47.411]                 {
[08:25:47.411]                   {
[08:25:47.411]                     base::local({
[08:25:47.411]                       has_future <- base::requireNamespace("future", 
[08:25:47.411]                         quietly = TRUE)
[08:25:47.411]                       if (has_future) {
[08:25:47.411]                         ns <- base::getNamespace("future")
[08:25:47.411]                         version <- ns[[".package"]][["version"]]
[08:25:47.411]                         if (is.null(version)) 
[08:25:47.411]                           version <- utils::packageVersion("future")
[08:25:47.411]                       }
[08:25:47.411]                       else {
[08:25:47.411]                         version <- NULL
[08:25:47.411]                       }
[08:25:47.411]                       if (!has_future || version < "1.8.0") {
[08:25:47.411]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.411]                           "", base::R.version$version.string), 
[08:25:47.411]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.411]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.411]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.411]                             "release", "version")], collapse = " "), 
[08:25:47.411]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.411]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.411]                           info)
[08:25:47.411]                         info <- base::paste(info, collapse = "; ")
[08:25:47.411]                         if (!has_future) {
[08:25:47.411]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.411]                             info)
[08:25:47.411]                         }
[08:25:47.411]                         else {
[08:25:47.411]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.411]                             info, version)
[08:25:47.411]                         }
[08:25:47.411]                         base::stop(msg)
[08:25:47.411]                       }
[08:25:47.411]                     })
[08:25:47.411]                   }
[08:25:47.411]                   ...future.strategy.old <- future::plan("list")
[08:25:47.411]                   options(future.plan = NULL)
[08:25:47.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.411]                 }
[08:25:47.411]                 ...future.workdir <- getwd()
[08:25:47.411]             }
[08:25:47.411]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.411]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.411]         }
[08:25:47.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.411]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:47.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.411]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.411]             base::names(...future.oldOptions))
[08:25:47.411]     }
[08:25:47.411]     if (FALSE) {
[08:25:47.411]     }
[08:25:47.411]     else {
[08:25:47.411]         if (TRUE) {
[08:25:47.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.411]                 open = "w")
[08:25:47.411]         }
[08:25:47.411]         else {
[08:25:47.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.411]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.411]         }
[08:25:47.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.411]             base::sink(type = "output", split = FALSE)
[08:25:47.411]             base::close(...future.stdout)
[08:25:47.411]         }, add = TRUE)
[08:25:47.411]     }
[08:25:47.411]     ...future.frame <- base::sys.nframe()
[08:25:47.411]     ...future.conditions <- base::list()
[08:25:47.411]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.411]     if (FALSE) {
[08:25:47.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.411]     }
[08:25:47.411]     ...future.result <- base::tryCatch({
[08:25:47.411]         base::withCallingHandlers({
[08:25:47.411]             ...future.value <- base::withVisible(base::local({
[08:25:47.411]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.411]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.411]                   ...future.globals.maxSize)) {
[08:25:47.411]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.411]                   on.exit(options(oopts), add = TRUE)
[08:25:47.411]                 }
[08:25:47.411]                 {
[08:25:47.411]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.411]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.411]                     USE.NAMES = FALSE)
[08:25:47.411]                   do.call(mapply, args = args)
[08:25:47.411]                 }
[08:25:47.411]             }))
[08:25:47.411]             future::FutureResult(value = ...future.value$value, 
[08:25:47.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.411]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.411]                     ...future.globalenv.names))
[08:25:47.411]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.411]         }, condition = base::local({
[08:25:47.411]             c <- base::c
[08:25:47.411]             inherits <- base::inherits
[08:25:47.411]             invokeRestart <- base::invokeRestart
[08:25:47.411]             length <- base::length
[08:25:47.411]             list <- base::list
[08:25:47.411]             seq.int <- base::seq.int
[08:25:47.411]             signalCondition <- base::signalCondition
[08:25:47.411]             sys.calls <- base::sys.calls
[08:25:47.411]             `[[` <- base::`[[`
[08:25:47.411]             `+` <- base::`+`
[08:25:47.411]             `<<-` <- base::`<<-`
[08:25:47.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.411]                   3L)]
[08:25:47.411]             }
[08:25:47.411]             function(cond) {
[08:25:47.411]                 is_error <- inherits(cond, "error")
[08:25:47.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.411]                   NULL)
[08:25:47.411]                 if (is_error) {
[08:25:47.411]                   sessionInformation <- function() {
[08:25:47.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.411]                       search = base::search(), system = base::Sys.info())
[08:25:47.411]                   }
[08:25:47.411]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.411]                     cond$call), session = sessionInformation(), 
[08:25:47.411]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.411]                   signalCondition(cond)
[08:25:47.411]                 }
[08:25:47.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.411]                 "immediateCondition"))) {
[08:25:47.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.411]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.411]                   if (TRUE && !signal) {
[08:25:47.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.411]                     {
[08:25:47.411]                       inherits <- base::inherits
[08:25:47.411]                       invokeRestart <- base::invokeRestart
[08:25:47.411]                       is.null <- base::is.null
[08:25:47.411]                       muffled <- FALSE
[08:25:47.411]                       if (inherits(cond, "message")) {
[08:25:47.411]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.411]                         if (muffled) 
[08:25:47.411]                           invokeRestart("muffleMessage")
[08:25:47.411]                       }
[08:25:47.411]                       else if (inherits(cond, "warning")) {
[08:25:47.411]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.411]                         if (muffled) 
[08:25:47.411]                           invokeRestart("muffleWarning")
[08:25:47.411]                       }
[08:25:47.411]                       else if (inherits(cond, "condition")) {
[08:25:47.411]                         if (!is.null(pattern)) {
[08:25:47.411]                           computeRestarts <- base::computeRestarts
[08:25:47.411]                           grepl <- base::grepl
[08:25:47.411]                           restarts <- computeRestarts(cond)
[08:25:47.411]                           for (restart in restarts) {
[08:25:47.411]                             name <- restart$name
[08:25:47.411]                             if (is.null(name)) 
[08:25:47.411]                               next
[08:25:47.411]                             if (!grepl(pattern, name)) 
[08:25:47.411]                               next
[08:25:47.411]                             invokeRestart(restart)
[08:25:47.411]                             muffled <- TRUE
[08:25:47.411]                             break
[08:25:47.411]                           }
[08:25:47.411]                         }
[08:25:47.411]                       }
[08:25:47.411]                       invisible(muffled)
[08:25:47.411]                     }
[08:25:47.411]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.411]                   }
[08:25:47.411]                 }
[08:25:47.411]                 else {
[08:25:47.411]                   if (TRUE) {
[08:25:47.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.411]                     {
[08:25:47.411]                       inherits <- base::inherits
[08:25:47.411]                       invokeRestart <- base::invokeRestart
[08:25:47.411]                       is.null <- base::is.null
[08:25:47.411]                       muffled <- FALSE
[08:25:47.411]                       if (inherits(cond, "message")) {
[08:25:47.411]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.411]                         if (muffled) 
[08:25:47.411]                           invokeRestart("muffleMessage")
[08:25:47.411]                       }
[08:25:47.411]                       else if (inherits(cond, "warning")) {
[08:25:47.411]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.411]                         if (muffled) 
[08:25:47.411]                           invokeRestart("muffleWarning")
[08:25:47.411]                       }
[08:25:47.411]                       else if (inherits(cond, "condition")) {
[08:25:47.411]                         if (!is.null(pattern)) {
[08:25:47.411]                           computeRestarts <- base::computeRestarts
[08:25:47.411]                           grepl <- base::grepl
[08:25:47.411]                           restarts <- computeRestarts(cond)
[08:25:47.411]                           for (restart in restarts) {
[08:25:47.411]                             name <- restart$name
[08:25:47.411]                             if (is.null(name)) 
[08:25:47.411]                               next
[08:25:47.411]                             if (!grepl(pattern, name)) 
[08:25:47.411]                               next
[08:25:47.411]                             invokeRestart(restart)
[08:25:47.411]                             muffled <- TRUE
[08:25:47.411]                             break
[08:25:47.411]                           }
[08:25:47.411]                         }
[08:25:47.411]                       }
[08:25:47.411]                       invisible(muffled)
[08:25:47.411]                     }
[08:25:47.411]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.411]                   }
[08:25:47.411]                 }
[08:25:47.411]             }
[08:25:47.411]         }))
[08:25:47.411]     }, error = function(ex) {
[08:25:47.411]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.411]                 ...future.rng), started = ...future.startTime, 
[08:25:47.411]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.411]             version = "1.8"), class = "FutureResult")
[08:25:47.411]     }, finally = {
[08:25:47.411]         if (!identical(...future.workdir, getwd())) 
[08:25:47.411]             setwd(...future.workdir)
[08:25:47.411]         {
[08:25:47.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.411]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.411]             }
[08:25:47.411]             base::options(...future.oldOptions)
[08:25:47.411]             if (.Platform$OS.type == "windows") {
[08:25:47.411]                 old_names <- names(...future.oldEnvVars)
[08:25:47.411]                 envs <- base::Sys.getenv()
[08:25:47.411]                 names <- names(envs)
[08:25:47.411]                 common <- intersect(names, old_names)
[08:25:47.411]                 added <- setdiff(names, old_names)
[08:25:47.411]                 removed <- setdiff(old_names, names)
[08:25:47.411]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.411]                   envs[common]]
[08:25:47.411]                 NAMES <- toupper(changed)
[08:25:47.411]                 args <- list()
[08:25:47.411]                 for (kk in seq_along(NAMES)) {
[08:25:47.411]                   name <- changed[[kk]]
[08:25:47.411]                   NAME <- NAMES[[kk]]
[08:25:47.411]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.411]                     next
[08:25:47.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.411]                 }
[08:25:47.411]                 NAMES <- toupper(added)
[08:25:47.411]                 for (kk in seq_along(NAMES)) {
[08:25:47.411]                   name <- added[[kk]]
[08:25:47.411]                   NAME <- NAMES[[kk]]
[08:25:47.411]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.411]                     next
[08:25:47.411]                   args[[name]] <- ""
[08:25:47.411]                 }
[08:25:47.411]                 NAMES <- toupper(removed)
[08:25:47.411]                 for (kk in seq_along(NAMES)) {
[08:25:47.411]                   name <- removed[[kk]]
[08:25:47.411]                   NAME <- NAMES[[kk]]
[08:25:47.411]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.411]                     next
[08:25:47.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.411]                 }
[08:25:47.411]                 if (length(args) > 0) 
[08:25:47.411]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.411]             }
[08:25:47.411]             else {
[08:25:47.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.411]             }
[08:25:47.411]             {
[08:25:47.411]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.411]                   0L) {
[08:25:47.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.411]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.411]                   base::options(opts)
[08:25:47.411]                 }
[08:25:47.411]                 {
[08:25:47.411]                   {
[08:25:47.411]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.411]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.411]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.411]                       inherits = FALSE)
[08:25:47.411]                     NULL
[08:25:47.411]                   }
[08:25:47.411]                   options(future.plan = NULL)
[08:25:47.411]                   if (is.na(NA_character_)) 
[08:25:47.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.411]                     .init = FALSE)
[08:25:47.411]                 }
[08:25:47.411]             }
[08:25:47.411]         }
[08:25:47.411]     })
[08:25:47.411]     if (TRUE) {
[08:25:47.411]         base::sink(type = "output", split = FALSE)
[08:25:47.411]         if (TRUE) {
[08:25:47.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.411]         }
[08:25:47.411]         else {
[08:25:47.411]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.411]         }
[08:25:47.411]         base::close(...future.stdout)
[08:25:47.411]         ...future.stdout <- NULL
[08:25:47.411]     }
[08:25:47.411]     ...future.result$conditions <- ...future.conditions
[08:25:47.411]     ...future.result$finished <- base::Sys.time()
[08:25:47.411]     ...future.result
[08:25:47.411] }
[08:25:47.413] assign_globals() ...
[08:25:47.413] List of 5
[08:25:47.413]  $ ...future.FUN            :function (C, k)  
[08:25:47.413]  $ MoreArgs                 : NULL
[08:25:47.413]  $ ...future.elements_ii    :List of 2
[08:25:47.413]   ..$ :List of 1
[08:25:47.413]   .. ..$ : chr "C"
[08:25:47.413]   ..$ :List of 1
[08:25:47.413]   .. ..$ : int 3
[08:25:47.413]  $ ...future.seeds_ii       : NULL
[08:25:47.413]  $ ...future.globals.maxSize: NULL
[08:25:47.413]  - attr(*, "where")=List of 5
[08:25:47.413]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.413]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.413]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.413]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.413]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.413]  - attr(*, "resolved")= logi FALSE
[08:25:47.413]  - attr(*, "total_size")= num 847
[08:25:47.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.413]  - attr(*, "already-done")= logi TRUE
[08:25:47.418] - reassign environment for ‘...future.FUN’
[08:25:47.418] - copied ‘...future.FUN’ to environment
[08:25:47.418] - copied ‘MoreArgs’ to environment
[08:25:47.419] - copied ‘...future.elements_ii’ to environment
[08:25:47.419] - copied ‘...future.seeds_ii’ to environment
[08:25:47.419] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.419] assign_globals() ... done
[08:25:47.419] plan(): Setting new future strategy stack:
[08:25:47.419] List of future strategies:
[08:25:47.419] 1. sequential:
[08:25:47.419]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.419]    - tweaked: FALSE
[08:25:47.419]    - call: NULL
[08:25:47.420] plan(): nbrOfWorkers() = 1
[08:25:47.420] plan(): Setting new future strategy stack:
[08:25:47.420] List of future strategies:
[08:25:47.420] 1. sequential:
[08:25:47.420]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.420]    - tweaked: FALSE
[08:25:47.420]    - call: plan(strategy)
[08:25:47.453] plan(): nbrOfWorkers() = 1
[08:25:47.453] SequentialFuture started (and completed)
[08:25:47.453] - Launch lazy future ... done
[08:25:47.453] run() for ‘SequentialFuture’ ... done
[08:25:47.453] Created future:
[08:25:47.454] SequentialFuture:
[08:25:47.454] Label: ‘future_mapply-3’
[08:25:47.454] Expression:
[08:25:47.454] {
[08:25:47.454]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.454]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.454]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.454]         on.exit(options(oopts), add = TRUE)
[08:25:47.454]     }
[08:25:47.454]     {
[08:25:47.454]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.454]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.454]         do.call(mapply, args = args)
[08:25:47.454]     }
[08:25:47.454] }
[08:25:47.454] Lazy evaluation: FALSE
[08:25:47.454] Asynchronous evaluation: FALSE
[08:25:47.454] Local evaluation: TRUE
[08:25:47.454] Environment: R_GlobalEnv
[08:25:47.454] Capture standard output: TRUE
[08:25:47.454] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.454] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.454] Packages: <none>
[08:25:47.454] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.454] Resolved: TRUE
[08:25:47.454] Value: 50 bytes of class ‘list’
[08:25:47.454] Early signaling: FALSE
[08:25:47.454] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.454] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.455] Chunk #3 of 5 ... DONE
[08:25:47.455] Chunk #4 of 5 ...
[08:25:47.455]  - Finding globals in '...' for chunk #4 ...
[08:25:47.455] getGlobalsAndPackages() ...
[08:25:47.455] Searching for globals...
[08:25:47.456] 
[08:25:47.456] Searching for globals ... DONE
[08:25:47.456] - globals: [0] <none>
[08:25:47.456] getGlobalsAndPackages() ... DONE
[08:25:47.456]    + additional globals found: [n=0] 
[08:25:47.456]    + additional namespaces needed: [n=0] 
[08:25:47.456]  - Finding globals in '...' for chunk #4 ... DONE
[08:25:47.456]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:47.456]  - seeds: <none>
[08:25:47.456]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.456] getGlobalsAndPackages() ...
[08:25:47.457] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.457] Resolving globals: FALSE
[08:25:47.457] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:47.458] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.458] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.458] 
[08:25:47.458] getGlobalsAndPackages() ... DONE
[08:25:47.458] run() for ‘Future’ ...
[08:25:47.458] - state: ‘created’
[08:25:47.458] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.459] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.459]   - Field: ‘label’
[08:25:47.459]   - Field: ‘local’
[08:25:47.459]   - Field: ‘owner’
[08:25:47.459]   - Field: ‘envir’
[08:25:47.459]   - Field: ‘packages’
[08:25:47.459]   - Field: ‘gc’
[08:25:47.459]   - Field: ‘conditions’
[08:25:47.460]   - Field: ‘expr’
[08:25:47.460]   - Field: ‘uuid’
[08:25:47.460]   - Field: ‘seed’
[08:25:47.460]   - Field: ‘version’
[08:25:47.460]   - Field: ‘result’
[08:25:47.460]   - Field: ‘asynchronous’
[08:25:47.460]   - Field: ‘calls’
[08:25:47.460]   - Field: ‘globals’
[08:25:47.460]   - Field: ‘stdout’
[08:25:47.460]   - Field: ‘earlySignal’
[08:25:47.461]   - Field: ‘lazy’
[08:25:47.461]   - Field: ‘state’
[08:25:47.461] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.461] - Launch lazy future ...
[08:25:47.461] Packages needed by the future expression (n = 0): <none>
[08:25:47.461] Packages needed by future strategies (n = 0): <none>
[08:25:47.462] {
[08:25:47.462]     {
[08:25:47.462]         {
[08:25:47.462]             ...future.startTime <- base::Sys.time()
[08:25:47.462]             {
[08:25:47.462]                 {
[08:25:47.462]                   {
[08:25:47.462]                     base::local({
[08:25:47.462]                       has_future <- base::requireNamespace("future", 
[08:25:47.462]                         quietly = TRUE)
[08:25:47.462]                       if (has_future) {
[08:25:47.462]                         ns <- base::getNamespace("future")
[08:25:47.462]                         version <- ns[[".package"]][["version"]]
[08:25:47.462]                         if (is.null(version)) 
[08:25:47.462]                           version <- utils::packageVersion("future")
[08:25:47.462]                       }
[08:25:47.462]                       else {
[08:25:47.462]                         version <- NULL
[08:25:47.462]                       }
[08:25:47.462]                       if (!has_future || version < "1.8.0") {
[08:25:47.462]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.462]                           "", base::R.version$version.string), 
[08:25:47.462]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.462]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.462]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.462]                             "release", "version")], collapse = " "), 
[08:25:47.462]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.462]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.462]                           info)
[08:25:47.462]                         info <- base::paste(info, collapse = "; ")
[08:25:47.462]                         if (!has_future) {
[08:25:47.462]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.462]                             info)
[08:25:47.462]                         }
[08:25:47.462]                         else {
[08:25:47.462]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.462]                             info, version)
[08:25:47.462]                         }
[08:25:47.462]                         base::stop(msg)
[08:25:47.462]                       }
[08:25:47.462]                     })
[08:25:47.462]                   }
[08:25:47.462]                   ...future.strategy.old <- future::plan("list")
[08:25:47.462]                   options(future.plan = NULL)
[08:25:47.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.462]                 }
[08:25:47.462]                 ...future.workdir <- getwd()
[08:25:47.462]             }
[08:25:47.462]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.462]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.462]         }
[08:25:47.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.462]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:47.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.462]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.462]             base::names(...future.oldOptions))
[08:25:47.462]     }
[08:25:47.462]     if (FALSE) {
[08:25:47.462]     }
[08:25:47.462]     else {
[08:25:47.462]         if (TRUE) {
[08:25:47.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.462]                 open = "w")
[08:25:47.462]         }
[08:25:47.462]         else {
[08:25:47.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.462]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.462]         }
[08:25:47.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.462]             base::sink(type = "output", split = FALSE)
[08:25:47.462]             base::close(...future.stdout)
[08:25:47.462]         }, add = TRUE)
[08:25:47.462]     }
[08:25:47.462]     ...future.frame <- base::sys.nframe()
[08:25:47.462]     ...future.conditions <- base::list()
[08:25:47.462]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.462]     if (FALSE) {
[08:25:47.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.462]     }
[08:25:47.462]     ...future.result <- base::tryCatch({
[08:25:47.462]         base::withCallingHandlers({
[08:25:47.462]             ...future.value <- base::withVisible(base::local({
[08:25:47.462]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.462]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.462]                   ...future.globals.maxSize)) {
[08:25:47.462]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.462]                   on.exit(options(oopts), add = TRUE)
[08:25:47.462]                 }
[08:25:47.462]                 {
[08:25:47.462]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.462]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.462]                     USE.NAMES = FALSE)
[08:25:47.462]                   do.call(mapply, args = args)
[08:25:47.462]                 }
[08:25:47.462]             }))
[08:25:47.462]             future::FutureResult(value = ...future.value$value, 
[08:25:47.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.462]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.462]                     ...future.globalenv.names))
[08:25:47.462]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.462]         }, condition = base::local({
[08:25:47.462]             c <- base::c
[08:25:47.462]             inherits <- base::inherits
[08:25:47.462]             invokeRestart <- base::invokeRestart
[08:25:47.462]             length <- base::length
[08:25:47.462]             list <- base::list
[08:25:47.462]             seq.int <- base::seq.int
[08:25:47.462]             signalCondition <- base::signalCondition
[08:25:47.462]             sys.calls <- base::sys.calls
[08:25:47.462]             `[[` <- base::`[[`
[08:25:47.462]             `+` <- base::`+`
[08:25:47.462]             `<<-` <- base::`<<-`
[08:25:47.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.462]                   3L)]
[08:25:47.462]             }
[08:25:47.462]             function(cond) {
[08:25:47.462]                 is_error <- inherits(cond, "error")
[08:25:47.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.462]                   NULL)
[08:25:47.462]                 if (is_error) {
[08:25:47.462]                   sessionInformation <- function() {
[08:25:47.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.462]                       search = base::search(), system = base::Sys.info())
[08:25:47.462]                   }
[08:25:47.462]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.462]                     cond$call), session = sessionInformation(), 
[08:25:47.462]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.462]                   signalCondition(cond)
[08:25:47.462]                 }
[08:25:47.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.462]                 "immediateCondition"))) {
[08:25:47.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.462]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.462]                   if (TRUE && !signal) {
[08:25:47.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.462]                     {
[08:25:47.462]                       inherits <- base::inherits
[08:25:47.462]                       invokeRestart <- base::invokeRestart
[08:25:47.462]                       is.null <- base::is.null
[08:25:47.462]                       muffled <- FALSE
[08:25:47.462]                       if (inherits(cond, "message")) {
[08:25:47.462]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.462]                         if (muffled) 
[08:25:47.462]                           invokeRestart("muffleMessage")
[08:25:47.462]                       }
[08:25:47.462]                       else if (inherits(cond, "warning")) {
[08:25:47.462]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.462]                         if (muffled) 
[08:25:47.462]                           invokeRestart("muffleWarning")
[08:25:47.462]                       }
[08:25:47.462]                       else if (inherits(cond, "condition")) {
[08:25:47.462]                         if (!is.null(pattern)) {
[08:25:47.462]                           computeRestarts <- base::computeRestarts
[08:25:47.462]                           grepl <- base::grepl
[08:25:47.462]                           restarts <- computeRestarts(cond)
[08:25:47.462]                           for (restart in restarts) {
[08:25:47.462]                             name <- restart$name
[08:25:47.462]                             if (is.null(name)) 
[08:25:47.462]                               next
[08:25:47.462]                             if (!grepl(pattern, name)) 
[08:25:47.462]                               next
[08:25:47.462]                             invokeRestart(restart)
[08:25:47.462]                             muffled <- TRUE
[08:25:47.462]                             break
[08:25:47.462]                           }
[08:25:47.462]                         }
[08:25:47.462]                       }
[08:25:47.462]                       invisible(muffled)
[08:25:47.462]                     }
[08:25:47.462]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.462]                   }
[08:25:47.462]                 }
[08:25:47.462]                 else {
[08:25:47.462]                   if (TRUE) {
[08:25:47.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.462]                     {
[08:25:47.462]                       inherits <- base::inherits
[08:25:47.462]                       invokeRestart <- base::invokeRestart
[08:25:47.462]                       is.null <- base::is.null
[08:25:47.462]                       muffled <- FALSE
[08:25:47.462]                       if (inherits(cond, "message")) {
[08:25:47.462]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.462]                         if (muffled) 
[08:25:47.462]                           invokeRestart("muffleMessage")
[08:25:47.462]                       }
[08:25:47.462]                       else if (inherits(cond, "warning")) {
[08:25:47.462]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.462]                         if (muffled) 
[08:25:47.462]                           invokeRestart("muffleWarning")
[08:25:47.462]                       }
[08:25:47.462]                       else if (inherits(cond, "condition")) {
[08:25:47.462]                         if (!is.null(pattern)) {
[08:25:47.462]                           computeRestarts <- base::computeRestarts
[08:25:47.462]                           grepl <- base::grepl
[08:25:47.462]                           restarts <- computeRestarts(cond)
[08:25:47.462]                           for (restart in restarts) {
[08:25:47.462]                             name <- restart$name
[08:25:47.462]                             if (is.null(name)) 
[08:25:47.462]                               next
[08:25:47.462]                             if (!grepl(pattern, name)) 
[08:25:47.462]                               next
[08:25:47.462]                             invokeRestart(restart)
[08:25:47.462]                             muffled <- TRUE
[08:25:47.462]                             break
[08:25:47.462]                           }
[08:25:47.462]                         }
[08:25:47.462]                       }
[08:25:47.462]                       invisible(muffled)
[08:25:47.462]                     }
[08:25:47.462]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.462]                   }
[08:25:47.462]                 }
[08:25:47.462]             }
[08:25:47.462]         }))
[08:25:47.462]     }, error = function(ex) {
[08:25:47.462]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.462]                 ...future.rng), started = ...future.startTime, 
[08:25:47.462]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.462]             version = "1.8"), class = "FutureResult")
[08:25:47.462]     }, finally = {
[08:25:47.462]         if (!identical(...future.workdir, getwd())) 
[08:25:47.462]             setwd(...future.workdir)
[08:25:47.462]         {
[08:25:47.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.462]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.462]             }
[08:25:47.462]             base::options(...future.oldOptions)
[08:25:47.462]             if (.Platform$OS.type == "windows") {
[08:25:47.462]                 old_names <- names(...future.oldEnvVars)
[08:25:47.462]                 envs <- base::Sys.getenv()
[08:25:47.462]                 names <- names(envs)
[08:25:47.462]                 common <- intersect(names, old_names)
[08:25:47.462]                 added <- setdiff(names, old_names)
[08:25:47.462]                 removed <- setdiff(old_names, names)
[08:25:47.462]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.462]                   envs[common]]
[08:25:47.462]                 NAMES <- toupper(changed)
[08:25:47.462]                 args <- list()
[08:25:47.462]                 for (kk in seq_along(NAMES)) {
[08:25:47.462]                   name <- changed[[kk]]
[08:25:47.462]                   NAME <- NAMES[[kk]]
[08:25:47.462]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.462]                     next
[08:25:47.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.462]                 }
[08:25:47.462]                 NAMES <- toupper(added)
[08:25:47.462]                 for (kk in seq_along(NAMES)) {
[08:25:47.462]                   name <- added[[kk]]
[08:25:47.462]                   NAME <- NAMES[[kk]]
[08:25:47.462]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.462]                     next
[08:25:47.462]                   args[[name]] <- ""
[08:25:47.462]                 }
[08:25:47.462]                 NAMES <- toupper(removed)
[08:25:47.462]                 for (kk in seq_along(NAMES)) {
[08:25:47.462]                   name <- removed[[kk]]
[08:25:47.462]                   NAME <- NAMES[[kk]]
[08:25:47.462]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.462]                     next
[08:25:47.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.462]                 }
[08:25:47.462]                 if (length(args) > 0) 
[08:25:47.462]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.462]             }
[08:25:47.462]             else {
[08:25:47.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.462]             }
[08:25:47.462]             {
[08:25:47.462]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.462]                   0L) {
[08:25:47.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.462]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.462]                   base::options(opts)
[08:25:47.462]                 }
[08:25:47.462]                 {
[08:25:47.462]                   {
[08:25:47.462]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.462]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.462]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.462]                       inherits = FALSE)
[08:25:47.462]                     NULL
[08:25:47.462]                   }
[08:25:47.462]                   options(future.plan = NULL)
[08:25:47.462]                   if (is.na(NA_character_)) 
[08:25:47.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.462]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.462]                     .init = FALSE)
[08:25:47.462]                 }
[08:25:47.462]             }
[08:25:47.462]         }
[08:25:47.462]     })
[08:25:47.462]     if (TRUE) {
[08:25:47.462]         base::sink(type = "output", split = FALSE)
[08:25:47.462]         if (TRUE) {
[08:25:47.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.462]         }
[08:25:47.462]         else {
[08:25:47.462]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.462]         }
[08:25:47.462]         base::close(...future.stdout)
[08:25:47.462]         ...future.stdout <- NULL
[08:25:47.462]     }
[08:25:47.462]     ...future.result$conditions <- ...future.conditions
[08:25:47.462]     ...future.result$finished <- base::Sys.time()
[08:25:47.462]     ...future.result
[08:25:47.462] }
[08:25:47.464] assign_globals() ...
[08:25:47.464] List of 5
[08:25:47.464]  $ ...future.FUN            :function (C, k)  
[08:25:47.464]  $ MoreArgs                 : NULL
[08:25:47.464]  $ ...future.elements_ii    :List of 2
[08:25:47.464]   ..$ :List of 1
[08:25:47.464]   .. ..$ : chr "D"
[08:25:47.464]   ..$ :List of 1
[08:25:47.464]   .. ..$ : int 2
[08:25:47.464]  $ ...future.seeds_ii       : NULL
[08:25:47.464]  $ ...future.globals.maxSize: NULL
[08:25:47.464]  - attr(*, "where")=List of 5
[08:25:47.464]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.464]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.464]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.464]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.464]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.464]  - attr(*, "resolved")= logi FALSE
[08:25:47.464]  - attr(*, "total_size")= num 847
[08:25:47.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.464]  - attr(*, "already-done")= logi TRUE
[08:25:47.469] - reassign environment for ‘...future.FUN’
[08:25:47.469] - copied ‘...future.FUN’ to environment
[08:25:47.469] - copied ‘MoreArgs’ to environment
[08:25:47.469] - copied ‘...future.elements_ii’ to environment
[08:25:47.469] - copied ‘...future.seeds_ii’ to environment
[08:25:47.469] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.470] assign_globals() ... done
[08:25:47.470] plan(): Setting new future strategy stack:
[08:25:47.470] List of future strategies:
[08:25:47.470] 1. sequential:
[08:25:47.470]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.470]    - tweaked: FALSE
[08:25:47.470]    - call: NULL
[08:25:47.470] plan(): nbrOfWorkers() = 1
[08:25:47.471] plan(): Setting new future strategy stack:
[08:25:47.471] List of future strategies:
[08:25:47.471] 1. sequential:
[08:25:47.471]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.471]    - tweaked: FALSE
[08:25:47.471]    - call: plan(strategy)
[08:25:47.472] plan(): nbrOfWorkers() = 1
[08:25:47.472] SequentialFuture started (and completed)
[08:25:47.472] - Launch lazy future ... done
[08:25:47.472] run() for ‘SequentialFuture’ ... done
[08:25:47.472] Created future:
[08:25:47.472] SequentialFuture:
[08:25:47.472] Label: ‘future_mapply-4’
[08:25:47.472] Expression:
[08:25:47.472] {
[08:25:47.472]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.472]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.472]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.472]         on.exit(options(oopts), add = TRUE)
[08:25:47.472]     }
[08:25:47.472]     {
[08:25:47.472]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.472]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.472]         do.call(mapply, args = args)
[08:25:47.472]     }
[08:25:47.472] }
[08:25:47.472] Lazy evaluation: FALSE
[08:25:47.472] Asynchronous evaluation: FALSE
[08:25:47.472] Local evaluation: TRUE
[08:25:47.472] Environment: R_GlobalEnv
[08:25:47.472] Capture standard output: TRUE
[08:25:47.472] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.472] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.472] Packages: <none>
[08:25:47.472] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.472] Resolved: TRUE
[08:25:47.472] Value: 49 bytes of class ‘list’
[08:25:47.472] Early signaling: FALSE
[08:25:47.472] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.472] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.473] Chunk #4 of 5 ... DONE
[08:25:47.473] Chunk #5 of 5 ...
[08:25:47.473]  - Finding globals in '...' for chunk #5 ...
[08:25:47.474] getGlobalsAndPackages() ...
[08:25:47.474] Searching for globals...
[08:25:47.474] 
[08:25:47.474] Searching for globals ... DONE
[08:25:47.474] - globals: [0] <none>
[08:25:47.474] getGlobalsAndPackages() ... DONE
[08:25:47.474]    + additional globals found: [n=0] 
[08:25:47.474]    + additional namespaces needed: [n=0] 
[08:25:47.475]  - Finding globals in '...' for chunk #5 ... DONE
[08:25:47.475]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:47.475]  - seeds: <none>
[08:25:47.475]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.475] getGlobalsAndPackages() ...
[08:25:47.475] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.475] Resolving globals: FALSE
[08:25:47.476] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:47.476] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.476] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.476] 
[08:25:47.476] getGlobalsAndPackages() ... DONE
[08:25:47.477] run() for ‘Future’ ...
[08:25:47.477] - state: ‘created’
[08:25:47.477] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.477] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.477] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.477]   - Field: ‘label’
[08:25:47.478]   - Field: ‘local’
[08:25:47.478]   - Field: ‘owner’
[08:25:47.478]   - Field: ‘envir’
[08:25:47.478]   - Field: ‘packages’
[08:25:47.478]   - Field: ‘gc’
[08:25:47.478]   - Field: ‘conditions’
[08:25:47.478]   - Field: ‘expr’
[08:25:47.478]   - Field: ‘uuid’
[08:25:47.478]   - Field: ‘seed’
[08:25:47.478]   - Field: ‘version’
[08:25:47.478]   - Field: ‘result’
[08:25:47.479]   - Field: ‘asynchronous’
[08:25:47.479]   - Field: ‘calls’
[08:25:47.479]   - Field: ‘globals’
[08:25:47.479]   - Field: ‘stdout’
[08:25:47.479]   - Field: ‘earlySignal’
[08:25:47.479]   - Field: ‘lazy’
[08:25:47.479]   - Field: ‘state’
[08:25:47.479] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.479] - Launch lazy future ...
[08:25:47.479] Packages needed by the future expression (n = 0): <none>
[08:25:47.480] Packages needed by future strategies (n = 0): <none>
[08:25:47.482] {
[08:25:47.482]     {
[08:25:47.482]         {
[08:25:47.482]             ...future.startTime <- base::Sys.time()
[08:25:47.482]             {
[08:25:47.482]                 {
[08:25:47.482]                   {
[08:25:47.482]                     base::local({
[08:25:47.482]                       has_future <- base::requireNamespace("future", 
[08:25:47.482]                         quietly = TRUE)
[08:25:47.482]                       if (has_future) {
[08:25:47.482]                         ns <- base::getNamespace("future")
[08:25:47.482]                         version <- ns[[".package"]][["version"]]
[08:25:47.482]                         if (is.null(version)) 
[08:25:47.482]                           version <- utils::packageVersion("future")
[08:25:47.482]                       }
[08:25:47.482]                       else {
[08:25:47.482]                         version <- NULL
[08:25:47.482]                       }
[08:25:47.482]                       if (!has_future || version < "1.8.0") {
[08:25:47.482]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.482]                           "", base::R.version$version.string), 
[08:25:47.482]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.482]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.482]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.482]                             "release", "version")], collapse = " "), 
[08:25:47.482]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.482]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.482]                           info)
[08:25:47.482]                         info <- base::paste(info, collapse = "; ")
[08:25:47.482]                         if (!has_future) {
[08:25:47.482]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.482]                             info)
[08:25:47.482]                         }
[08:25:47.482]                         else {
[08:25:47.482]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.482]                             info, version)
[08:25:47.482]                         }
[08:25:47.482]                         base::stop(msg)
[08:25:47.482]                       }
[08:25:47.482]                     })
[08:25:47.482]                   }
[08:25:47.482]                   ...future.strategy.old <- future::plan("list")
[08:25:47.482]                   options(future.plan = NULL)
[08:25:47.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.482]                 }
[08:25:47.482]                 ...future.workdir <- getwd()
[08:25:47.482]             }
[08:25:47.482]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.482]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.482]         }
[08:25:47.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.482]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:47.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.482]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.482]             base::names(...future.oldOptions))
[08:25:47.482]     }
[08:25:47.482]     if (FALSE) {
[08:25:47.482]     }
[08:25:47.482]     else {
[08:25:47.482]         if (TRUE) {
[08:25:47.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.482]                 open = "w")
[08:25:47.482]         }
[08:25:47.482]         else {
[08:25:47.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.482]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.482]         }
[08:25:47.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.482]             base::sink(type = "output", split = FALSE)
[08:25:47.482]             base::close(...future.stdout)
[08:25:47.482]         }, add = TRUE)
[08:25:47.482]     }
[08:25:47.482]     ...future.frame <- base::sys.nframe()
[08:25:47.482]     ...future.conditions <- base::list()
[08:25:47.482]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.482]     if (FALSE) {
[08:25:47.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.482]     }
[08:25:47.482]     ...future.result <- base::tryCatch({
[08:25:47.482]         base::withCallingHandlers({
[08:25:47.482]             ...future.value <- base::withVisible(base::local({
[08:25:47.482]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.482]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.482]                   ...future.globals.maxSize)) {
[08:25:47.482]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.482]                   on.exit(options(oopts), add = TRUE)
[08:25:47.482]                 }
[08:25:47.482]                 {
[08:25:47.482]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.482]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.482]                     USE.NAMES = FALSE)
[08:25:47.482]                   do.call(mapply, args = args)
[08:25:47.482]                 }
[08:25:47.482]             }))
[08:25:47.482]             future::FutureResult(value = ...future.value$value, 
[08:25:47.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.482]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.482]                     ...future.globalenv.names))
[08:25:47.482]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.482]         }, condition = base::local({
[08:25:47.482]             c <- base::c
[08:25:47.482]             inherits <- base::inherits
[08:25:47.482]             invokeRestart <- base::invokeRestart
[08:25:47.482]             length <- base::length
[08:25:47.482]             list <- base::list
[08:25:47.482]             seq.int <- base::seq.int
[08:25:47.482]             signalCondition <- base::signalCondition
[08:25:47.482]             sys.calls <- base::sys.calls
[08:25:47.482]             `[[` <- base::`[[`
[08:25:47.482]             `+` <- base::`+`
[08:25:47.482]             `<<-` <- base::`<<-`
[08:25:47.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.482]                   3L)]
[08:25:47.482]             }
[08:25:47.482]             function(cond) {
[08:25:47.482]                 is_error <- inherits(cond, "error")
[08:25:47.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.482]                   NULL)
[08:25:47.482]                 if (is_error) {
[08:25:47.482]                   sessionInformation <- function() {
[08:25:47.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.482]                       search = base::search(), system = base::Sys.info())
[08:25:47.482]                   }
[08:25:47.482]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.482]                     cond$call), session = sessionInformation(), 
[08:25:47.482]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.482]                   signalCondition(cond)
[08:25:47.482]                 }
[08:25:47.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.482]                 "immediateCondition"))) {
[08:25:47.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.482]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.482]                   if (TRUE && !signal) {
[08:25:47.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.482]                     {
[08:25:47.482]                       inherits <- base::inherits
[08:25:47.482]                       invokeRestart <- base::invokeRestart
[08:25:47.482]                       is.null <- base::is.null
[08:25:47.482]                       muffled <- FALSE
[08:25:47.482]                       if (inherits(cond, "message")) {
[08:25:47.482]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.482]                         if (muffled) 
[08:25:47.482]                           invokeRestart("muffleMessage")
[08:25:47.482]                       }
[08:25:47.482]                       else if (inherits(cond, "warning")) {
[08:25:47.482]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.482]                         if (muffled) 
[08:25:47.482]                           invokeRestart("muffleWarning")
[08:25:47.482]                       }
[08:25:47.482]                       else if (inherits(cond, "condition")) {
[08:25:47.482]                         if (!is.null(pattern)) {
[08:25:47.482]                           computeRestarts <- base::computeRestarts
[08:25:47.482]                           grepl <- base::grepl
[08:25:47.482]                           restarts <- computeRestarts(cond)
[08:25:47.482]                           for (restart in restarts) {
[08:25:47.482]                             name <- restart$name
[08:25:47.482]                             if (is.null(name)) 
[08:25:47.482]                               next
[08:25:47.482]                             if (!grepl(pattern, name)) 
[08:25:47.482]                               next
[08:25:47.482]                             invokeRestart(restart)
[08:25:47.482]                             muffled <- TRUE
[08:25:47.482]                             break
[08:25:47.482]                           }
[08:25:47.482]                         }
[08:25:47.482]                       }
[08:25:47.482]                       invisible(muffled)
[08:25:47.482]                     }
[08:25:47.482]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.482]                   }
[08:25:47.482]                 }
[08:25:47.482]                 else {
[08:25:47.482]                   if (TRUE) {
[08:25:47.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.482]                     {
[08:25:47.482]                       inherits <- base::inherits
[08:25:47.482]                       invokeRestart <- base::invokeRestart
[08:25:47.482]                       is.null <- base::is.null
[08:25:47.482]                       muffled <- FALSE
[08:25:47.482]                       if (inherits(cond, "message")) {
[08:25:47.482]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.482]                         if (muffled) 
[08:25:47.482]                           invokeRestart("muffleMessage")
[08:25:47.482]                       }
[08:25:47.482]                       else if (inherits(cond, "warning")) {
[08:25:47.482]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.482]                         if (muffled) 
[08:25:47.482]                           invokeRestart("muffleWarning")
[08:25:47.482]                       }
[08:25:47.482]                       else if (inherits(cond, "condition")) {
[08:25:47.482]                         if (!is.null(pattern)) {
[08:25:47.482]                           computeRestarts <- base::computeRestarts
[08:25:47.482]                           grepl <- base::grepl
[08:25:47.482]                           restarts <- computeRestarts(cond)
[08:25:47.482]                           for (restart in restarts) {
[08:25:47.482]                             name <- restart$name
[08:25:47.482]                             if (is.null(name)) 
[08:25:47.482]                               next
[08:25:47.482]                             if (!grepl(pattern, name)) 
[08:25:47.482]                               next
[08:25:47.482]                             invokeRestart(restart)
[08:25:47.482]                             muffled <- TRUE
[08:25:47.482]                             break
[08:25:47.482]                           }
[08:25:47.482]                         }
[08:25:47.482]                       }
[08:25:47.482]                       invisible(muffled)
[08:25:47.482]                     }
[08:25:47.482]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.482]                   }
[08:25:47.482]                 }
[08:25:47.482]             }
[08:25:47.482]         }))
[08:25:47.482]     }, error = function(ex) {
[08:25:47.482]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.482]                 ...future.rng), started = ...future.startTime, 
[08:25:47.482]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.482]             version = "1.8"), class = "FutureResult")
[08:25:47.482]     }, finally = {
[08:25:47.482]         if (!identical(...future.workdir, getwd())) 
[08:25:47.482]             setwd(...future.workdir)
[08:25:47.482]         {
[08:25:47.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.482]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.482]             }
[08:25:47.482]             base::options(...future.oldOptions)
[08:25:47.482]             if (.Platform$OS.type == "windows") {
[08:25:47.482]                 old_names <- names(...future.oldEnvVars)
[08:25:47.482]                 envs <- base::Sys.getenv()
[08:25:47.482]                 names <- names(envs)
[08:25:47.482]                 common <- intersect(names, old_names)
[08:25:47.482]                 added <- setdiff(names, old_names)
[08:25:47.482]                 removed <- setdiff(old_names, names)
[08:25:47.482]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.482]                   envs[common]]
[08:25:47.482]                 NAMES <- toupper(changed)
[08:25:47.482]                 args <- list()
[08:25:47.482]                 for (kk in seq_along(NAMES)) {
[08:25:47.482]                   name <- changed[[kk]]
[08:25:47.482]                   NAME <- NAMES[[kk]]
[08:25:47.482]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.482]                     next
[08:25:47.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.482]                 }
[08:25:47.482]                 NAMES <- toupper(added)
[08:25:47.482]                 for (kk in seq_along(NAMES)) {
[08:25:47.482]                   name <- added[[kk]]
[08:25:47.482]                   NAME <- NAMES[[kk]]
[08:25:47.482]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.482]                     next
[08:25:47.482]                   args[[name]] <- ""
[08:25:47.482]                 }
[08:25:47.482]                 NAMES <- toupper(removed)
[08:25:47.482]                 for (kk in seq_along(NAMES)) {
[08:25:47.482]                   name <- removed[[kk]]
[08:25:47.482]                   NAME <- NAMES[[kk]]
[08:25:47.482]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.482]                     next
[08:25:47.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.482]                 }
[08:25:47.482]                 if (length(args) > 0) 
[08:25:47.482]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.482]             }
[08:25:47.482]             else {
[08:25:47.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.482]             }
[08:25:47.482]             {
[08:25:47.482]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.482]                   0L) {
[08:25:47.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.482]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.482]                   base::options(opts)
[08:25:47.482]                 }
[08:25:47.482]                 {
[08:25:47.482]                   {
[08:25:47.482]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.482]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.482]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.482]                       inherits = FALSE)
[08:25:47.482]                     NULL
[08:25:47.482]                   }
[08:25:47.482]                   options(future.plan = NULL)
[08:25:47.482]                   if (is.na(NA_character_)) 
[08:25:47.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.482]                     .init = FALSE)
[08:25:47.482]                 }
[08:25:47.482]             }
[08:25:47.482]         }
[08:25:47.482]     })
[08:25:47.482]     if (TRUE) {
[08:25:47.482]         base::sink(type = "output", split = FALSE)
[08:25:47.482]         if (TRUE) {
[08:25:47.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.482]         }
[08:25:47.482]         else {
[08:25:47.482]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.482]         }
[08:25:47.482]         base::close(...future.stdout)
[08:25:47.482]         ...future.stdout <- NULL
[08:25:47.482]     }
[08:25:47.482]     ...future.result$conditions <- ...future.conditions
[08:25:47.482]     ...future.result$finished <- base::Sys.time()
[08:25:47.482]     ...future.result
[08:25:47.482] }
[08:25:47.484] assign_globals() ...
[08:25:47.484] List of 5
[08:25:47.484]  $ ...future.FUN            :function (C, k)  
[08:25:47.484]  $ MoreArgs                 : NULL
[08:25:47.484]  $ ...future.elements_ii    :List of 2
[08:25:47.484]   ..$ :List of 1
[08:25:47.484]   .. ..$ : chr "E"
[08:25:47.484]   ..$ :List of 1
[08:25:47.484]   .. ..$ : int 1
[08:25:47.484]  $ ...future.seeds_ii       : NULL
[08:25:47.484]  $ ...future.globals.maxSize: NULL
[08:25:47.484]  - attr(*, "where")=List of 5
[08:25:47.484]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.484]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.484]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.484]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.484]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.484]  - attr(*, "resolved")= logi FALSE
[08:25:47.484]  - attr(*, "total_size")= num 847
[08:25:47.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.484]  - attr(*, "already-done")= logi TRUE
[08:25:47.489] - reassign environment for ‘...future.FUN’
[08:25:47.490] - copied ‘...future.FUN’ to environment
[08:25:47.490] - copied ‘MoreArgs’ to environment
[08:25:47.490] - copied ‘...future.elements_ii’ to environment
[08:25:47.490] - copied ‘...future.seeds_ii’ to environment
[08:25:47.490] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.490] assign_globals() ... done
[08:25:47.490] plan(): Setting new future strategy stack:
[08:25:47.490] List of future strategies:
[08:25:47.490] 1. sequential:
[08:25:47.490]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.490]    - tweaked: FALSE
[08:25:47.490]    - call: NULL
[08:25:47.491] plan(): nbrOfWorkers() = 1
[08:25:47.492] plan(): Setting new future strategy stack:
[08:25:47.492] List of future strategies:
[08:25:47.492] 1. sequential:
[08:25:47.492]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.492]    - tweaked: FALSE
[08:25:47.492]    - call: plan(strategy)
[08:25:47.492] plan(): nbrOfWorkers() = 1
[08:25:47.492] SequentialFuture started (and completed)
[08:25:47.493] - Launch lazy future ... done
[08:25:47.493] run() for ‘SequentialFuture’ ... done
[08:25:47.493] Created future:
[08:25:47.493] SequentialFuture:
[08:25:47.493] Label: ‘future_mapply-5’
[08:25:47.493] Expression:
[08:25:47.493] {
[08:25:47.493]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.493]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.493]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.493]         on.exit(options(oopts), add = TRUE)
[08:25:47.493]     }
[08:25:47.493]     {
[08:25:47.493]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.493]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.493]         do.call(mapply, args = args)
[08:25:47.493]     }
[08:25:47.493] }
[08:25:47.493] Lazy evaluation: FALSE
[08:25:47.493] Asynchronous evaluation: FALSE
[08:25:47.493] Local evaluation: TRUE
[08:25:47.493] Environment: R_GlobalEnv
[08:25:47.493] Capture standard output: TRUE
[08:25:47.493] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.493] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.493] Packages: <none>
[08:25:47.493] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.493] Resolved: TRUE
[08:25:47.493] Value: 48 bytes of class ‘list’
[08:25:47.493] Early signaling: FALSE
[08:25:47.493] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.493] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.494] Chunk #5 of 5 ... DONE
[08:25:47.494] Launching 5 futures (chunks) ... DONE
[08:25:47.494] Resolving 5 futures (chunks) ...
[08:25:47.494] resolve() on list ...
[08:25:47.494]  recursive: 0
[08:25:47.494]  length: 5
[08:25:47.494] 
[08:25:47.494] resolved() for ‘SequentialFuture’ ...
[08:25:47.494] - state: ‘finished’
[08:25:47.494] - run: TRUE
[08:25:47.495] - result: ‘FutureResult’
[08:25:47.495] resolved() for ‘SequentialFuture’ ... done
[08:25:47.495] Future #1
[08:25:47.495] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.495] - nx: 5
[08:25:47.495] - relay: TRUE
[08:25:47.495] - stdout: TRUE
[08:25:47.495] - signal: TRUE
[08:25:47.495] - resignal: FALSE
[08:25:47.495] - force: TRUE
[08:25:47.495] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[08:25:47.496] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[08:25:47.496]  - until=1
[08:25:47.496]  - relaying element #1
[08:25:47.496] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:47.496] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:47.496] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.496]  length: 4 (resolved future 1)
[08:25:47.496] resolved() for ‘SequentialFuture’ ...
[08:25:47.496] - state: ‘finished’
[08:25:47.497] - run: TRUE
[08:25:47.497] - result: ‘FutureResult’
[08:25:47.497] resolved() for ‘SequentialFuture’ ... done
[08:25:47.497] Future #2
[08:25:47.497] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:25:47.497] - nx: 5
[08:25:47.497] - relay: TRUE
[08:25:47.497] - stdout: TRUE
[08:25:47.497] - signal: TRUE
[08:25:47.497] - resignal: FALSE
[08:25:47.497] - force: TRUE
[08:25:47.498] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:47.498] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:47.498]  - until=2
[08:25:47.498]  - relaying element #2
[08:25:47.498] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:47.498] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:47.498] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:25:47.498]  length: 3 (resolved future 2)
[08:25:47.498] resolved() for ‘SequentialFuture’ ...
[08:25:47.498] - state: ‘finished’
[08:25:47.499] - run: TRUE
[08:25:47.499] - result: ‘FutureResult’
[08:25:47.499] resolved() for ‘SequentialFuture’ ... done
[08:25:47.499] Future #3
[08:25:47.499] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:25:47.499] - nx: 5
[08:25:47.499] - relay: TRUE
[08:25:47.499] - stdout: TRUE
[08:25:47.499] - signal: TRUE
[08:25:47.499] - resignal: FALSE
[08:25:47.499] - force: TRUE
[08:25:47.500] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:47.500] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:47.500]  - until=3
[08:25:47.500]  - relaying element #3
[08:25:47.500] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:47.500] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:47.500] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:25:47.500]  length: 2 (resolved future 3)
[08:25:47.500] resolved() for ‘SequentialFuture’ ...
[08:25:47.500] - state: ‘finished’
[08:25:47.501] - run: TRUE
[08:25:47.501] - result: ‘FutureResult’
[08:25:47.501] resolved() for ‘SequentialFuture’ ... done
[08:25:47.501] Future #4
[08:25:47.501] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:25:47.501] - nx: 5
[08:25:47.501] - relay: TRUE
[08:25:47.501] - stdout: TRUE
[08:25:47.501] - signal: TRUE
[08:25:47.501] - resignal: FALSE
[08:25:47.501] - force: TRUE
[08:25:47.502] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:47.502] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:47.502]  - until=4
[08:25:47.502]  - relaying element #4
[08:25:47.502] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:47.502] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:47.502] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:25:47.502]  length: 1 (resolved future 4)
[08:25:47.502] resolved() for ‘SequentialFuture’ ...
[08:25:47.502] - state: ‘finished’
[08:25:47.503] - run: TRUE
[08:25:47.503] - result: ‘FutureResult’
[08:25:47.503] resolved() for ‘SequentialFuture’ ... done
[08:25:47.503] Future #5
[08:25:47.503] signalConditionsASAP(SequentialFuture, pos=5) ...
[08:25:47.503] - nx: 5
[08:25:47.503] - relay: TRUE
[08:25:47.503] - stdout: TRUE
[08:25:47.503] - signal: TRUE
[08:25:47.503] - resignal: FALSE
[08:25:47.504] - force: TRUE
[08:25:47.504] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:47.504] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:47.504]  - until=5
[08:25:47.504]  - relaying element #5
[08:25:47.504] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:47.504] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:47.504] signalConditionsASAP(SequentialFuture, pos=5) ... done
[08:25:47.504]  length: 0 (resolved future 5)
[08:25:47.505] Relaying remaining futures
[08:25:47.505] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.505] - nx: 5
[08:25:47.505] - relay: TRUE
[08:25:47.505] - stdout: TRUE
[08:25:47.505] - signal: TRUE
[08:25:47.505] - resignal: FALSE
[08:25:47.505] - force: TRUE
[08:25:47.505] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:47.505] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[08:25:47.505] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:47.506] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:47.506] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.506] resolve() on list ... DONE
[08:25:47.506]  - Number of value chunks collected: 5
[08:25:47.506] Resolving 5 futures (chunks) ... DONE
[08:25:47.506] Reducing values from 5 chunks ...
[08:25:47.506]  - Number of values collected after concatenation: 5
[08:25:47.506]  - Number of values expected: 5
[08:25:47.506] Reducing values from 5 chunks ... DONE
[08:25:47.507] future_mapply() ... DONE
[08:25:47.509] future_mapply() ...
[08:25:47.509] Number of chunks: 1
[08:25:47.509] getGlobalsAndPackagesXApply() ...
[08:25:47.509]  - future.globals: TRUE
[08:25:47.509] getGlobalsAndPackages() ...
[08:25:47.509] Searching for globals...
[08:25:47.511] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:47.511] Searching for globals ... DONE
[08:25:47.511] Resolving globals: FALSE
[08:25:47.512] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:47.512] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:47.512] - globals: [1] ‘FUN’
[08:25:47.512] 
[08:25:47.512] getGlobalsAndPackages() ... DONE
[08:25:47.512]  - globals found/used: [n=1] ‘FUN’
[08:25:47.512]  - needed namespaces: [n=0] 
[08:25:47.513] Finding globals ... DONE
[08:25:47.513] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.513] List of 2
[08:25:47.513]  $ ...future.FUN:function (C, k)  
[08:25:47.513]  $ MoreArgs     : list()
[08:25:47.513]  - attr(*, "where")=List of 2
[08:25:47.513]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.513]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.513]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.513]  - attr(*, "resolved")= logi FALSE
[08:25:47.513]  - attr(*, "total_size")= num NA
[08:25:47.515] Packages to be attached in all futures: [n=0] 
[08:25:47.516] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.516] Number of futures (= number of chunks): 1
[08:25:47.516] Launching 1 futures (chunks) ...
[08:25:47.516] Chunk #1 of 1 ...
[08:25:47.516]  - Finding globals in '...' for chunk #1 ...
[08:25:47.516] getGlobalsAndPackages() ...
[08:25:47.516] Searching for globals...
[08:25:47.517] 
[08:25:47.517] Searching for globals ... DONE
[08:25:47.517] - globals: [0] <none>
[08:25:47.517] getGlobalsAndPackages() ... DONE
[08:25:47.517]    + additional globals found: [n=0] 
[08:25:47.517]    + additional namespaces needed: [n=0] 
[08:25:47.517]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.517]  - seeds: <none>
[08:25:47.517]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.517] getGlobalsAndPackages() ...
[08:25:47.518] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.518] Resolving globals: FALSE
[08:25:47.518] The total size of the 5 globals is 967 bytes (967 bytes)
[08:25:47.518] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 967 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (192 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:47.519] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.519] 
[08:25:47.519] getGlobalsAndPackages() ... DONE
[08:25:47.519] run() for ‘Future’ ...
[08:25:47.519] - state: ‘created’
[08:25:47.519] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.520] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.520]   - Field: ‘label’
[08:25:47.520]   - Field: ‘local’
[08:25:47.520]   - Field: ‘owner’
[08:25:47.520]   - Field: ‘envir’
[08:25:47.520]   - Field: ‘packages’
[08:25:47.520]   - Field: ‘gc’
[08:25:47.520]   - Field: ‘conditions’
[08:25:47.520]   - Field: ‘expr’
[08:25:47.521]   - Field: ‘uuid’
[08:25:47.521]   - Field: ‘seed’
[08:25:47.521]   - Field: ‘version’
[08:25:47.521]   - Field: ‘result’
[08:25:47.521]   - Field: ‘asynchronous’
[08:25:47.521]   - Field: ‘calls’
[08:25:47.521]   - Field: ‘globals’
[08:25:47.521]   - Field: ‘stdout’
[08:25:47.521]   - Field: ‘earlySignal’
[08:25:47.521]   - Field: ‘lazy’
[08:25:47.521]   - Field: ‘state’
[08:25:47.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.522] - Launch lazy future ...
[08:25:47.522] Packages needed by the future expression (n = 0): <none>
[08:25:47.522] Packages needed by future strategies (n = 0): <none>
[08:25:47.522] {
[08:25:47.522]     {
[08:25:47.522]         {
[08:25:47.522]             ...future.startTime <- base::Sys.time()
[08:25:47.522]             {
[08:25:47.522]                 {
[08:25:47.522]                   {
[08:25:47.522]                     base::local({
[08:25:47.522]                       has_future <- base::requireNamespace("future", 
[08:25:47.522]                         quietly = TRUE)
[08:25:47.522]                       if (has_future) {
[08:25:47.522]                         ns <- base::getNamespace("future")
[08:25:47.522]                         version <- ns[[".package"]][["version"]]
[08:25:47.522]                         if (is.null(version)) 
[08:25:47.522]                           version <- utils::packageVersion("future")
[08:25:47.522]                       }
[08:25:47.522]                       else {
[08:25:47.522]                         version <- NULL
[08:25:47.522]                       }
[08:25:47.522]                       if (!has_future || version < "1.8.0") {
[08:25:47.522]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.522]                           "", base::R.version$version.string), 
[08:25:47.522]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.522]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.522]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.522]                             "release", "version")], collapse = " "), 
[08:25:47.522]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.522]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.522]                           info)
[08:25:47.522]                         info <- base::paste(info, collapse = "; ")
[08:25:47.522]                         if (!has_future) {
[08:25:47.522]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.522]                             info)
[08:25:47.522]                         }
[08:25:47.522]                         else {
[08:25:47.522]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.522]                             info, version)
[08:25:47.522]                         }
[08:25:47.522]                         base::stop(msg)
[08:25:47.522]                       }
[08:25:47.522]                     })
[08:25:47.522]                   }
[08:25:47.522]                   ...future.strategy.old <- future::plan("list")
[08:25:47.522]                   options(future.plan = NULL)
[08:25:47.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.522]                 }
[08:25:47.522]                 ...future.workdir <- getwd()
[08:25:47.522]             }
[08:25:47.522]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.522]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.522]         }
[08:25:47.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.522]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.522]             base::names(...future.oldOptions))
[08:25:47.522]     }
[08:25:47.522]     if (FALSE) {
[08:25:47.522]     }
[08:25:47.522]     else {
[08:25:47.522]         if (TRUE) {
[08:25:47.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.522]                 open = "w")
[08:25:47.522]         }
[08:25:47.522]         else {
[08:25:47.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.522]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.522]         }
[08:25:47.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.522]             base::sink(type = "output", split = FALSE)
[08:25:47.522]             base::close(...future.stdout)
[08:25:47.522]         }, add = TRUE)
[08:25:47.522]     }
[08:25:47.522]     ...future.frame <- base::sys.nframe()
[08:25:47.522]     ...future.conditions <- base::list()
[08:25:47.522]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.522]     if (FALSE) {
[08:25:47.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.522]     }
[08:25:47.522]     ...future.result <- base::tryCatch({
[08:25:47.522]         base::withCallingHandlers({
[08:25:47.522]             ...future.value <- base::withVisible(base::local({
[08:25:47.522]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.522]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.522]                   ...future.globals.maxSize)) {
[08:25:47.522]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.522]                   on.exit(options(oopts), add = TRUE)
[08:25:47.522]                 }
[08:25:47.522]                 {
[08:25:47.522]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.522]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.522]                     USE.NAMES = FALSE)
[08:25:47.522]                   do.call(mapply, args = args)
[08:25:47.522]                 }
[08:25:47.522]             }))
[08:25:47.522]             future::FutureResult(value = ...future.value$value, 
[08:25:47.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.522]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.522]                     ...future.globalenv.names))
[08:25:47.522]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.522]         }, condition = base::local({
[08:25:47.522]             c <- base::c
[08:25:47.522]             inherits <- base::inherits
[08:25:47.522]             invokeRestart <- base::invokeRestart
[08:25:47.522]             length <- base::length
[08:25:47.522]             list <- base::list
[08:25:47.522]             seq.int <- base::seq.int
[08:25:47.522]             signalCondition <- base::signalCondition
[08:25:47.522]             sys.calls <- base::sys.calls
[08:25:47.522]             `[[` <- base::`[[`
[08:25:47.522]             `+` <- base::`+`
[08:25:47.522]             `<<-` <- base::`<<-`
[08:25:47.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.522]                   3L)]
[08:25:47.522]             }
[08:25:47.522]             function(cond) {
[08:25:47.522]                 is_error <- inherits(cond, "error")
[08:25:47.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.522]                   NULL)
[08:25:47.522]                 if (is_error) {
[08:25:47.522]                   sessionInformation <- function() {
[08:25:47.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.522]                       search = base::search(), system = base::Sys.info())
[08:25:47.522]                   }
[08:25:47.522]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.522]                     cond$call), session = sessionInformation(), 
[08:25:47.522]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.522]                   signalCondition(cond)
[08:25:47.522]                 }
[08:25:47.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.522]                 "immediateCondition"))) {
[08:25:47.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.522]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.522]                   if (TRUE && !signal) {
[08:25:47.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.522]                     {
[08:25:47.522]                       inherits <- base::inherits
[08:25:47.522]                       invokeRestart <- base::invokeRestart
[08:25:47.522]                       is.null <- base::is.null
[08:25:47.522]                       muffled <- FALSE
[08:25:47.522]                       if (inherits(cond, "message")) {
[08:25:47.522]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.522]                         if (muffled) 
[08:25:47.522]                           invokeRestart("muffleMessage")
[08:25:47.522]                       }
[08:25:47.522]                       else if (inherits(cond, "warning")) {
[08:25:47.522]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.522]                         if (muffled) 
[08:25:47.522]                           invokeRestart("muffleWarning")
[08:25:47.522]                       }
[08:25:47.522]                       else if (inherits(cond, "condition")) {
[08:25:47.522]                         if (!is.null(pattern)) {
[08:25:47.522]                           computeRestarts <- base::computeRestarts
[08:25:47.522]                           grepl <- base::grepl
[08:25:47.522]                           restarts <- computeRestarts(cond)
[08:25:47.522]                           for (restart in restarts) {
[08:25:47.522]                             name <- restart$name
[08:25:47.522]                             if (is.null(name)) 
[08:25:47.522]                               next
[08:25:47.522]                             if (!grepl(pattern, name)) 
[08:25:47.522]                               next
[08:25:47.522]                             invokeRestart(restart)
[08:25:47.522]                             muffled <- TRUE
[08:25:47.522]                             break
[08:25:47.522]                           }
[08:25:47.522]                         }
[08:25:47.522]                       }
[08:25:47.522]                       invisible(muffled)
[08:25:47.522]                     }
[08:25:47.522]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.522]                   }
[08:25:47.522]                 }
[08:25:47.522]                 else {
[08:25:47.522]                   if (TRUE) {
[08:25:47.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.522]                     {
[08:25:47.522]                       inherits <- base::inherits
[08:25:47.522]                       invokeRestart <- base::invokeRestart
[08:25:47.522]                       is.null <- base::is.null
[08:25:47.522]                       muffled <- FALSE
[08:25:47.522]                       if (inherits(cond, "message")) {
[08:25:47.522]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.522]                         if (muffled) 
[08:25:47.522]                           invokeRestart("muffleMessage")
[08:25:47.522]                       }
[08:25:47.522]                       else if (inherits(cond, "warning")) {
[08:25:47.522]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.522]                         if (muffled) 
[08:25:47.522]                           invokeRestart("muffleWarning")
[08:25:47.522]                       }
[08:25:47.522]                       else if (inherits(cond, "condition")) {
[08:25:47.522]                         if (!is.null(pattern)) {
[08:25:47.522]                           computeRestarts <- base::computeRestarts
[08:25:47.522]                           grepl <- base::grepl
[08:25:47.522]                           restarts <- computeRestarts(cond)
[08:25:47.522]                           for (restart in restarts) {
[08:25:47.522]                             name <- restart$name
[08:25:47.522]                             if (is.null(name)) 
[08:25:47.522]                               next
[08:25:47.522]                             if (!grepl(pattern, name)) 
[08:25:47.522]                               next
[08:25:47.522]                             invokeRestart(restart)
[08:25:47.522]                             muffled <- TRUE
[08:25:47.522]                             break
[08:25:47.522]                           }
[08:25:47.522]                         }
[08:25:47.522]                       }
[08:25:47.522]                       invisible(muffled)
[08:25:47.522]                     }
[08:25:47.522]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.522]                   }
[08:25:47.522]                 }
[08:25:47.522]             }
[08:25:47.522]         }))
[08:25:47.522]     }, error = function(ex) {
[08:25:47.522]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.522]                 ...future.rng), started = ...future.startTime, 
[08:25:47.522]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.522]             version = "1.8"), class = "FutureResult")
[08:25:47.522]     }, finally = {
[08:25:47.522]         if (!identical(...future.workdir, getwd())) 
[08:25:47.522]             setwd(...future.workdir)
[08:25:47.522]         {
[08:25:47.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.522]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.522]             }
[08:25:47.522]             base::options(...future.oldOptions)
[08:25:47.522]             if (.Platform$OS.type == "windows") {
[08:25:47.522]                 old_names <- names(...future.oldEnvVars)
[08:25:47.522]                 envs <- base::Sys.getenv()
[08:25:47.522]                 names <- names(envs)
[08:25:47.522]                 common <- intersect(names, old_names)
[08:25:47.522]                 added <- setdiff(names, old_names)
[08:25:47.522]                 removed <- setdiff(old_names, names)
[08:25:47.522]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.522]                   envs[common]]
[08:25:47.522]                 NAMES <- toupper(changed)
[08:25:47.522]                 args <- list()
[08:25:47.522]                 for (kk in seq_along(NAMES)) {
[08:25:47.522]                   name <- changed[[kk]]
[08:25:47.522]                   NAME <- NAMES[[kk]]
[08:25:47.522]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.522]                     next
[08:25:47.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.522]                 }
[08:25:47.522]                 NAMES <- toupper(added)
[08:25:47.522]                 for (kk in seq_along(NAMES)) {
[08:25:47.522]                   name <- added[[kk]]
[08:25:47.522]                   NAME <- NAMES[[kk]]
[08:25:47.522]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.522]                     next
[08:25:47.522]                   args[[name]] <- ""
[08:25:47.522]                 }
[08:25:47.522]                 NAMES <- toupper(removed)
[08:25:47.522]                 for (kk in seq_along(NAMES)) {
[08:25:47.522]                   name <- removed[[kk]]
[08:25:47.522]                   NAME <- NAMES[[kk]]
[08:25:47.522]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.522]                     next
[08:25:47.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.522]                 }
[08:25:47.522]                 if (length(args) > 0) 
[08:25:47.522]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.522]             }
[08:25:47.522]             else {
[08:25:47.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.522]             }
[08:25:47.522]             {
[08:25:47.522]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.522]                   0L) {
[08:25:47.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.522]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.522]                   base::options(opts)
[08:25:47.522]                 }
[08:25:47.522]                 {
[08:25:47.522]                   {
[08:25:47.522]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.522]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.522]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.522]                       inherits = FALSE)
[08:25:47.522]                     NULL
[08:25:47.522]                   }
[08:25:47.522]                   options(future.plan = NULL)
[08:25:47.522]                   if (is.na(NA_character_)) 
[08:25:47.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.522]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.522]                     .init = FALSE)
[08:25:47.522]                 }
[08:25:47.522]             }
[08:25:47.522]         }
[08:25:47.522]     })
[08:25:47.522]     if (TRUE) {
[08:25:47.522]         base::sink(type = "output", split = FALSE)
[08:25:47.522]         if (TRUE) {
[08:25:47.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.522]         }
[08:25:47.522]         else {
[08:25:47.522]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.522]         }
[08:25:47.522]         base::close(...future.stdout)
[08:25:47.522]         ...future.stdout <- NULL
[08:25:47.522]     }
[08:25:47.522]     ...future.result$conditions <- ...future.conditions
[08:25:47.522]     ...future.result$finished <- base::Sys.time()
[08:25:47.522]     ...future.result
[08:25:47.522] }
[08:25:47.524] assign_globals() ...
[08:25:47.524] List of 5
[08:25:47.524]  $ ...future.FUN            :function (C, k)  
[08:25:47.524]  $ MoreArgs                 : list()
[08:25:47.524]  $ ...future.elements_ii    :List of 2
[08:25:47.524]   ..$ :List of 5
[08:25:47.524]   .. ..$ : chr "A"
[08:25:47.524]   .. ..$ : chr "B"
[08:25:47.524]   .. ..$ : chr "C"
[08:25:47.524]   .. ..$ : chr "D"
[08:25:47.524]   .. ..$ : chr "E"
[08:25:47.524]   ..$ :List of 5
[08:25:47.524]   .. ..$ : int 5
[08:25:47.524]   .. ..$ : int 4
[08:25:47.524]   .. ..$ : int 3
[08:25:47.524]   .. ..$ : int 2
[08:25:47.524]   .. ..$ : int 1
[08:25:47.524]  $ ...future.seeds_ii       : NULL
[08:25:47.524]  $ ...future.globals.maxSize: NULL
[08:25:47.524]  - attr(*, "where")=List of 5
[08:25:47.524]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.524]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.524]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.524]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.524]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.524]  - attr(*, "resolved")= logi FALSE
[08:25:47.524]  - attr(*, "total_size")= num 967
[08:25:47.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.524]  - attr(*, "already-done")= logi TRUE
[08:25:47.531] - reassign environment for ‘...future.FUN’
[08:25:47.531] - copied ‘...future.FUN’ to environment
[08:25:47.532] - copied ‘MoreArgs’ to environment
[08:25:47.532] - copied ‘...future.elements_ii’ to environment
[08:25:47.532] - copied ‘...future.seeds_ii’ to environment
[08:25:47.532] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.532] assign_globals() ... done
[08:25:47.532] plan(): Setting new future strategy stack:
[08:25:47.532] List of future strategies:
[08:25:47.532] 1. sequential:
[08:25:47.532]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.532]    - tweaked: FALSE
[08:25:47.532]    - call: NULL
[08:25:47.533] plan(): nbrOfWorkers() = 1
[08:25:47.535] plan(): Setting new future strategy stack:
[08:25:47.535] List of future strategies:
[08:25:47.535] 1. sequential:
[08:25:47.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.535]    - tweaked: FALSE
[08:25:47.535]    - call: plan(strategy)
[08:25:47.536] plan(): nbrOfWorkers() = 1
[08:25:47.536] SequentialFuture started (and completed)
[08:25:47.536] - Launch lazy future ... done
[08:25:47.536] run() for ‘SequentialFuture’ ... done
[08:25:47.537] Created future:
[08:25:47.537] SequentialFuture:
[08:25:47.537] Label: ‘future_.mapply-1’
[08:25:47.537] Expression:
[08:25:47.537] {
[08:25:47.537]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.537]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.537]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.537]         on.exit(options(oopts), add = TRUE)
[08:25:47.537]     }
[08:25:47.537]     {
[08:25:47.537]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.537]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.537]         do.call(mapply, args = args)
[08:25:47.537]     }
[08:25:47.537] }
[08:25:47.537] Lazy evaluation: FALSE
[08:25:47.537] Asynchronous evaluation: FALSE
[08:25:47.537] Local evaluation: TRUE
[08:25:47.537] Environment: R_GlobalEnv
[08:25:47.537] Capture standard output: TRUE
[08:25:47.537] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.537] Globals: 5 objects totaling 967 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.537] Packages: <none>
[08:25:47.537] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.537] Resolved: TRUE
[08:25:47.537] Value: 126 bytes of class ‘list’
[08:25:47.537] Early signaling: FALSE
[08:25:47.537] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.537] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.538] Chunk #1 of 1 ... DONE
[08:25:47.538] Launching 1 futures (chunks) ... DONE
[08:25:47.538] Resolving 1 futures (chunks) ...
[08:25:47.538] resolve() on list ...
[08:25:47.538]  recursive: 0
[08:25:47.538]  length: 1
[08:25:47.538] 
[08:25:47.538] resolved() for ‘SequentialFuture’ ...
[08:25:47.538] - state: ‘finished’
[08:25:47.539] - run: TRUE
[08:25:47.539] - result: ‘FutureResult’
[08:25:47.539] resolved() for ‘SequentialFuture’ ... done
[08:25:47.539] Future #1
[08:25:47.539] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.539] - nx: 1
[08:25:47.539] - relay: TRUE
[08:25:47.539] - stdout: TRUE
[08:25:47.539] - signal: TRUE
[08:25:47.539] - resignal: FALSE
[08:25:47.540] - force: TRUE
[08:25:47.540] - relayed: [n=1] FALSE
[08:25:47.540] - queued futures: [n=1] FALSE
[08:25:47.540]  - until=1
[08:25:47.540]  - relaying element #1
[08:25:47.540] - relayed: [n=1] TRUE
[08:25:47.540] - queued futures: [n=1] TRUE
[08:25:47.540] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.540]  length: 0 (resolved future 1)
[08:25:47.540] Relaying remaining futures
[08:25:47.541] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.541] - nx: 1
[08:25:47.541] - relay: TRUE
[08:25:47.541] - stdout: TRUE
[08:25:47.541] - signal: TRUE
[08:25:47.541] - resignal: FALSE
[08:25:47.541] - force: TRUE
[08:25:47.541] - relayed: [n=1] TRUE
[08:25:47.541] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.541] - relayed: [n=1] TRUE
[08:25:47.541] - queued futures: [n=1] TRUE
[08:25:47.542] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.542] resolve() on list ... DONE
[08:25:47.542]  - Number of value chunks collected: 1
[08:25:47.542] Resolving 1 futures (chunks) ... DONE
[08:25:47.542] Reducing values from 1 chunks ...
[08:25:47.542]  - Number of values collected after concatenation: 5
[08:25:47.542]  - Number of values expected: 5
[08:25:47.542] Reducing values from 1 chunks ... DONE
[08:25:47.542] future_mapply() ... DONE
[08:25:47.543] future_mapply() ...
[08:25:47.543] Number of chunks: 3
[08:25:47.543] Index remapping (attribute 'ordering'): [n = 5] 4, 2, 1, 5, 3
[08:25:47.543] getGlobalsAndPackagesXApply() ...
[08:25:47.543]  - future.globals: TRUE
[08:25:47.543] getGlobalsAndPackages() ...
[08:25:47.544] Searching for globals...
[08:25:47.545] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:47.545] Searching for globals ... DONE
[08:25:47.545] Resolving globals: FALSE
[08:25:47.545] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:47.546] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:47.546] - globals: [1] ‘FUN’
[08:25:47.546] 
[08:25:47.546] getGlobalsAndPackages() ... DONE
[08:25:47.546]  - globals found/used: [n=1] ‘FUN’
[08:25:47.546]  - needed namespaces: [n=0] 
[08:25:47.546] Finding globals ... DONE
[08:25:47.547] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.547] List of 2
[08:25:47.547]  $ ...future.FUN:function (C, k)  
[08:25:47.547]  $ MoreArgs     : NULL
[08:25:47.547]  - attr(*, "where")=List of 2
[08:25:47.547]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.547]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.547]  - attr(*, "resolved")= logi FALSE
[08:25:47.547]  - attr(*, "total_size")= num NA
[08:25:47.549] Packages to be attached in all futures: [n=0] 
[08:25:47.549] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.550] Number of futures (= number of chunks): 3
[08:25:47.550] Launching 3 futures (chunks) ...
[08:25:47.550] Chunk #1 of 3 ...
[08:25:47.550]  - Finding globals in '...' for chunk #1 ...
[08:25:47.550] getGlobalsAndPackages() ...
[08:25:47.550] Searching for globals...
[08:25:47.551] 
[08:25:47.551] Searching for globals ... DONE
[08:25:47.551] - globals: [0] <none>
[08:25:47.551] getGlobalsAndPackages() ... DONE
[08:25:47.551]    + additional globals found: [n=0] 
[08:25:47.551]    + additional namespaces needed: [n=0] 
[08:25:47.551]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.551]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[08:25:47.551]  - seeds: <none>
[08:25:47.551]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.552] getGlobalsAndPackages() ...
[08:25:47.552] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.552] Resolving globals: FALSE
[08:25:47.552] The total size of the 5 globals is 876 bytes (876 bytes)
[08:25:47.553] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.553] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.553] 
[08:25:47.553] getGlobalsAndPackages() ... DONE
[08:25:47.553] run() for ‘Future’ ...
[08:25:47.553] - state: ‘created’
[08:25:47.554] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.554] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.554] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.554]   - Field: ‘label’
[08:25:47.554]   - Field: ‘local’
[08:25:47.554]   - Field: ‘owner’
[08:25:47.554]   - Field: ‘envir’
[08:25:47.554]   - Field: ‘packages’
[08:25:47.555]   - Field: ‘gc’
[08:25:47.555]   - Field: ‘conditions’
[08:25:47.555]   - Field: ‘expr’
[08:25:47.555]   - Field: ‘uuid’
[08:25:47.555]   - Field: ‘seed’
[08:25:47.555]   - Field: ‘version’
[08:25:47.555]   - Field: ‘result’
[08:25:47.555]   - Field: ‘asynchronous’
[08:25:47.555]   - Field: ‘calls’
[08:25:47.555]   - Field: ‘globals’
[08:25:47.555]   - Field: ‘stdout’
[08:25:47.556]   - Field: ‘earlySignal’
[08:25:47.556]   - Field: ‘lazy’
[08:25:47.556]   - Field: ‘state’
[08:25:47.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.556] - Launch lazy future ...
[08:25:47.556] Packages needed by the future expression (n = 0): <none>
[08:25:47.556] Packages needed by future strategies (n = 0): <none>
[08:25:47.557] {
[08:25:47.557]     {
[08:25:47.557]         {
[08:25:47.557]             ...future.startTime <- base::Sys.time()
[08:25:47.557]             {
[08:25:47.557]                 {
[08:25:47.557]                   {
[08:25:47.557]                     base::local({
[08:25:47.557]                       has_future <- base::requireNamespace("future", 
[08:25:47.557]                         quietly = TRUE)
[08:25:47.557]                       if (has_future) {
[08:25:47.557]                         ns <- base::getNamespace("future")
[08:25:47.557]                         version <- ns[[".package"]][["version"]]
[08:25:47.557]                         if (is.null(version)) 
[08:25:47.557]                           version <- utils::packageVersion("future")
[08:25:47.557]                       }
[08:25:47.557]                       else {
[08:25:47.557]                         version <- NULL
[08:25:47.557]                       }
[08:25:47.557]                       if (!has_future || version < "1.8.0") {
[08:25:47.557]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.557]                           "", base::R.version$version.string), 
[08:25:47.557]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.557]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.557]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.557]                             "release", "version")], collapse = " "), 
[08:25:47.557]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.557]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.557]                           info)
[08:25:47.557]                         info <- base::paste(info, collapse = "; ")
[08:25:47.557]                         if (!has_future) {
[08:25:47.557]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.557]                             info)
[08:25:47.557]                         }
[08:25:47.557]                         else {
[08:25:47.557]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.557]                             info, version)
[08:25:47.557]                         }
[08:25:47.557]                         base::stop(msg)
[08:25:47.557]                       }
[08:25:47.557]                     })
[08:25:47.557]                   }
[08:25:47.557]                   ...future.strategy.old <- future::plan("list")
[08:25:47.557]                   options(future.plan = NULL)
[08:25:47.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.557]                 }
[08:25:47.557]                 ...future.workdir <- getwd()
[08:25:47.557]             }
[08:25:47.557]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.557]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.557]         }
[08:25:47.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.557]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[08:25:47.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.557]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.557]             base::names(...future.oldOptions))
[08:25:47.557]     }
[08:25:47.557]     if (FALSE) {
[08:25:47.557]     }
[08:25:47.557]     else {
[08:25:47.557]         if (TRUE) {
[08:25:47.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.557]                 open = "w")
[08:25:47.557]         }
[08:25:47.557]         else {
[08:25:47.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.557]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.557]         }
[08:25:47.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.557]             base::sink(type = "output", split = FALSE)
[08:25:47.557]             base::close(...future.stdout)
[08:25:47.557]         }, add = TRUE)
[08:25:47.557]     }
[08:25:47.557]     ...future.frame <- base::sys.nframe()
[08:25:47.557]     ...future.conditions <- base::list()
[08:25:47.557]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.557]     if (FALSE) {
[08:25:47.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.557]     }
[08:25:47.557]     ...future.result <- base::tryCatch({
[08:25:47.557]         base::withCallingHandlers({
[08:25:47.557]             ...future.value <- base::withVisible(base::local({
[08:25:47.557]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.557]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.557]                   ...future.globals.maxSize)) {
[08:25:47.557]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.557]                   on.exit(options(oopts), add = TRUE)
[08:25:47.557]                 }
[08:25:47.557]                 {
[08:25:47.557]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.557]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.557]                     USE.NAMES = FALSE)
[08:25:47.557]                   do.call(mapply, args = args)
[08:25:47.557]                 }
[08:25:47.557]             }))
[08:25:47.557]             future::FutureResult(value = ...future.value$value, 
[08:25:47.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.557]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.557]                     ...future.globalenv.names))
[08:25:47.557]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.557]         }, condition = base::local({
[08:25:47.557]             c <- base::c
[08:25:47.557]             inherits <- base::inherits
[08:25:47.557]             invokeRestart <- base::invokeRestart
[08:25:47.557]             length <- base::length
[08:25:47.557]             list <- base::list
[08:25:47.557]             seq.int <- base::seq.int
[08:25:47.557]             signalCondition <- base::signalCondition
[08:25:47.557]             sys.calls <- base::sys.calls
[08:25:47.557]             `[[` <- base::`[[`
[08:25:47.557]             `+` <- base::`+`
[08:25:47.557]             `<<-` <- base::`<<-`
[08:25:47.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.557]                   3L)]
[08:25:47.557]             }
[08:25:47.557]             function(cond) {
[08:25:47.557]                 is_error <- inherits(cond, "error")
[08:25:47.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.557]                   NULL)
[08:25:47.557]                 if (is_error) {
[08:25:47.557]                   sessionInformation <- function() {
[08:25:47.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.557]                       search = base::search(), system = base::Sys.info())
[08:25:47.557]                   }
[08:25:47.557]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.557]                     cond$call), session = sessionInformation(), 
[08:25:47.557]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.557]                   signalCondition(cond)
[08:25:47.557]                 }
[08:25:47.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.557]                 "immediateCondition"))) {
[08:25:47.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.557]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.557]                   if (TRUE && !signal) {
[08:25:47.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.557]                     {
[08:25:47.557]                       inherits <- base::inherits
[08:25:47.557]                       invokeRestart <- base::invokeRestart
[08:25:47.557]                       is.null <- base::is.null
[08:25:47.557]                       muffled <- FALSE
[08:25:47.557]                       if (inherits(cond, "message")) {
[08:25:47.557]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.557]                         if (muffled) 
[08:25:47.557]                           invokeRestart("muffleMessage")
[08:25:47.557]                       }
[08:25:47.557]                       else if (inherits(cond, "warning")) {
[08:25:47.557]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.557]                         if (muffled) 
[08:25:47.557]                           invokeRestart("muffleWarning")
[08:25:47.557]                       }
[08:25:47.557]                       else if (inherits(cond, "condition")) {
[08:25:47.557]                         if (!is.null(pattern)) {
[08:25:47.557]                           computeRestarts <- base::computeRestarts
[08:25:47.557]                           grepl <- base::grepl
[08:25:47.557]                           restarts <- computeRestarts(cond)
[08:25:47.557]                           for (restart in restarts) {
[08:25:47.557]                             name <- restart$name
[08:25:47.557]                             if (is.null(name)) 
[08:25:47.557]                               next
[08:25:47.557]                             if (!grepl(pattern, name)) 
[08:25:47.557]                               next
[08:25:47.557]                             invokeRestart(restart)
[08:25:47.557]                             muffled <- TRUE
[08:25:47.557]                             break
[08:25:47.557]                           }
[08:25:47.557]                         }
[08:25:47.557]                       }
[08:25:47.557]                       invisible(muffled)
[08:25:47.557]                     }
[08:25:47.557]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.557]                   }
[08:25:47.557]                 }
[08:25:47.557]                 else {
[08:25:47.557]                   if (TRUE) {
[08:25:47.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.557]                     {
[08:25:47.557]                       inherits <- base::inherits
[08:25:47.557]                       invokeRestart <- base::invokeRestart
[08:25:47.557]                       is.null <- base::is.null
[08:25:47.557]                       muffled <- FALSE
[08:25:47.557]                       if (inherits(cond, "message")) {
[08:25:47.557]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.557]                         if (muffled) 
[08:25:47.557]                           invokeRestart("muffleMessage")
[08:25:47.557]                       }
[08:25:47.557]                       else if (inherits(cond, "warning")) {
[08:25:47.557]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.557]                         if (muffled) 
[08:25:47.557]                           invokeRestart("muffleWarning")
[08:25:47.557]                       }
[08:25:47.557]                       else if (inherits(cond, "condition")) {
[08:25:47.557]                         if (!is.null(pattern)) {
[08:25:47.557]                           computeRestarts <- base::computeRestarts
[08:25:47.557]                           grepl <- base::grepl
[08:25:47.557]                           restarts <- computeRestarts(cond)
[08:25:47.557]                           for (restart in restarts) {
[08:25:47.557]                             name <- restart$name
[08:25:47.557]                             if (is.null(name)) 
[08:25:47.557]                               next
[08:25:47.557]                             if (!grepl(pattern, name)) 
[08:25:47.557]                               next
[08:25:47.557]                             invokeRestart(restart)
[08:25:47.557]                             muffled <- TRUE
[08:25:47.557]                             break
[08:25:47.557]                           }
[08:25:47.557]                         }
[08:25:47.557]                       }
[08:25:47.557]                       invisible(muffled)
[08:25:47.557]                     }
[08:25:47.557]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.557]                   }
[08:25:47.557]                 }
[08:25:47.557]             }
[08:25:47.557]         }))
[08:25:47.557]     }, error = function(ex) {
[08:25:47.557]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.557]                 ...future.rng), started = ...future.startTime, 
[08:25:47.557]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.557]             version = "1.8"), class = "FutureResult")
[08:25:47.557]     }, finally = {
[08:25:47.557]         if (!identical(...future.workdir, getwd())) 
[08:25:47.557]             setwd(...future.workdir)
[08:25:47.557]         {
[08:25:47.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.557]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.557]             }
[08:25:47.557]             base::options(...future.oldOptions)
[08:25:47.557]             if (.Platform$OS.type == "windows") {
[08:25:47.557]                 old_names <- names(...future.oldEnvVars)
[08:25:47.557]                 envs <- base::Sys.getenv()
[08:25:47.557]                 names <- names(envs)
[08:25:47.557]                 common <- intersect(names, old_names)
[08:25:47.557]                 added <- setdiff(names, old_names)
[08:25:47.557]                 removed <- setdiff(old_names, names)
[08:25:47.557]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.557]                   envs[common]]
[08:25:47.557]                 NAMES <- toupper(changed)
[08:25:47.557]                 args <- list()
[08:25:47.557]                 for (kk in seq_along(NAMES)) {
[08:25:47.557]                   name <- changed[[kk]]
[08:25:47.557]                   NAME <- NAMES[[kk]]
[08:25:47.557]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.557]                     next
[08:25:47.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.557]                 }
[08:25:47.557]                 NAMES <- toupper(added)
[08:25:47.557]                 for (kk in seq_along(NAMES)) {
[08:25:47.557]                   name <- added[[kk]]
[08:25:47.557]                   NAME <- NAMES[[kk]]
[08:25:47.557]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.557]                     next
[08:25:47.557]                   args[[name]] <- ""
[08:25:47.557]                 }
[08:25:47.557]                 NAMES <- toupper(removed)
[08:25:47.557]                 for (kk in seq_along(NAMES)) {
[08:25:47.557]                   name <- removed[[kk]]
[08:25:47.557]                   NAME <- NAMES[[kk]]
[08:25:47.557]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.557]                     next
[08:25:47.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.557]                 }
[08:25:47.557]                 if (length(args) > 0) 
[08:25:47.557]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.557]             }
[08:25:47.557]             else {
[08:25:47.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.557]             }
[08:25:47.557]             {
[08:25:47.557]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.557]                   0L) {
[08:25:47.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.557]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.557]                   base::options(opts)
[08:25:47.557]                 }
[08:25:47.557]                 {
[08:25:47.557]                   {
[08:25:47.557]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.557]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.557]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.557]                       inherits = FALSE)
[08:25:47.557]                     NULL
[08:25:47.557]                   }
[08:25:47.557]                   options(future.plan = NULL)
[08:25:47.557]                   if (is.na(NA_character_)) 
[08:25:47.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.557]                     .init = FALSE)
[08:25:47.557]                 }
[08:25:47.557]             }
[08:25:47.557]         }
[08:25:47.557]     })
[08:25:47.557]     if (TRUE) {
[08:25:47.557]         base::sink(type = "output", split = FALSE)
[08:25:47.557]         if (TRUE) {
[08:25:47.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.557]         }
[08:25:47.557]         else {
[08:25:47.557]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.557]         }
[08:25:47.557]         base::close(...future.stdout)
[08:25:47.557]         ...future.stdout <- NULL
[08:25:47.557]     }
[08:25:47.557]     ...future.result$conditions <- ...future.conditions
[08:25:47.557]     ...future.result$finished <- base::Sys.time()
[08:25:47.557]     ...future.result
[08:25:47.557] }
[08:25:47.559] assign_globals() ...
[08:25:47.559] List of 5
[08:25:47.559]  $ ...future.FUN            :function (C, k)  
[08:25:47.559]  $ MoreArgs                 : NULL
[08:25:47.559]  $ ...future.elements_ii    :List of 2
[08:25:47.559]   ..$ :List of 2
[08:25:47.559]   .. ..$ : chr "D"
[08:25:47.559]   .. ..$ : chr "B"
[08:25:47.559]   ..$ :List of 2
[08:25:47.559]   .. ..$ : int 2
[08:25:47.559]   .. ..$ : int 4
[08:25:47.559]  $ ...future.seeds_ii       : NULL
[08:25:47.559]  $ ...future.globals.maxSize: NULL
[08:25:47.559]  - attr(*, "where")=List of 5
[08:25:47.559]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.559]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.559]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.559]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.559]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.559]  - attr(*, "resolved")= logi FALSE
[08:25:47.559]  - attr(*, "total_size")= num 876
[08:25:47.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.559]  - attr(*, "already-done")= logi TRUE
[08:25:47.567] - reassign environment for ‘...future.FUN’
[08:25:47.568] - copied ‘...future.FUN’ to environment
[08:25:47.568] - copied ‘MoreArgs’ to environment
[08:25:47.568] - copied ‘...future.elements_ii’ to environment
[08:25:47.568] - copied ‘...future.seeds_ii’ to environment
[08:25:47.568] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.568] assign_globals() ... done
[08:25:47.568] plan(): Setting new future strategy stack:
[08:25:47.569] List of future strategies:
[08:25:47.569] 1. sequential:
[08:25:47.569]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.569]    - tweaked: FALSE
[08:25:47.569]    - call: NULL
[08:25:47.569] plan(): nbrOfWorkers() = 1
[08:25:47.570] plan(): Setting new future strategy stack:
[08:25:47.570] List of future strategies:
[08:25:47.570] 1. sequential:
[08:25:47.570]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.570]    - tweaked: FALSE
[08:25:47.570]    - call: plan(strategy)
[08:25:47.571] plan(): nbrOfWorkers() = 1
[08:25:47.571] SequentialFuture started (and completed)
[08:25:47.571] - Launch lazy future ... done
[08:25:47.571] run() for ‘SequentialFuture’ ... done
[08:25:47.571] Created future:
[08:25:47.571] SequentialFuture:
[08:25:47.571] Label: ‘future_mapply-1’
[08:25:47.571] Expression:
[08:25:47.571] {
[08:25:47.571]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.571]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.571]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.571]         on.exit(options(oopts), add = TRUE)
[08:25:47.571]     }
[08:25:47.571]     {
[08:25:47.571]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.571]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.571]         do.call(mapply, args = args)
[08:25:47.571]     }
[08:25:47.571] }
[08:25:47.571] Lazy evaluation: FALSE
[08:25:47.571] Asynchronous evaluation: FALSE
[08:25:47.571] Local evaluation: TRUE
[08:25:47.571] Environment: R_GlobalEnv
[08:25:47.571] Capture standard output: TRUE
[08:25:47.571] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.571] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.571] Packages: <none>
[08:25:47.571] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.571] Resolved: TRUE
[08:25:47.571] Value: 69 bytes of class ‘list’
[08:25:47.571] Early signaling: FALSE
[08:25:47.571] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.571] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.572] Chunk #1 of 3 ... DONE
[08:25:47.572] Chunk #2 of 3 ...
[08:25:47.572]  - Finding globals in '...' for chunk #2 ...
[08:25:47.572] getGlobalsAndPackages() ...
[08:25:47.573] Searching for globals...
[08:25:47.573] 
[08:25:47.573] Searching for globals ... DONE
[08:25:47.573] - globals: [0] <none>
[08:25:47.573] getGlobalsAndPackages() ... DONE
[08:25:47.573]    + additional globals found: [n=0] 
[08:25:47.573]    + additional namespaces needed: [n=0] 
[08:25:47.573]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:47.574]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[08:25:47.574]  - seeds: <none>
[08:25:47.574]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.574] getGlobalsAndPackages() ...
[08:25:47.574] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.574] Resolving globals: FALSE
[08:25:47.575] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:47.575] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.575] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.575] 
[08:25:47.575] getGlobalsAndPackages() ... DONE
[08:25:47.576] run() for ‘Future’ ...
[08:25:47.576] - state: ‘created’
[08:25:47.576] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.576] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.577]   - Field: ‘label’
[08:25:47.577]   - Field: ‘local’
[08:25:47.577]   - Field: ‘owner’
[08:25:47.577]   - Field: ‘envir’
[08:25:47.577]   - Field: ‘packages’
[08:25:47.577]   - Field: ‘gc’
[08:25:47.577]   - Field: ‘conditions’
[08:25:47.577]   - Field: ‘expr’
[08:25:47.577]   - Field: ‘uuid’
[08:25:47.577]   - Field: ‘seed’
[08:25:47.578]   - Field: ‘version’
[08:25:47.578]   - Field: ‘result’
[08:25:47.578]   - Field: ‘asynchronous’
[08:25:47.578]   - Field: ‘calls’
[08:25:47.578]   - Field: ‘globals’
[08:25:47.578]   - Field: ‘stdout’
[08:25:47.578]   - Field: ‘earlySignal’
[08:25:47.578]   - Field: ‘lazy’
[08:25:47.578]   - Field: ‘state’
[08:25:47.578] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.578] - Launch lazy future ...
[08:25:47.579] Packages needed by the future expression (n = 0): <none>
[08:25:47.579] Packages needed by future strategies (n = 0): <none>
[08:25:47.579] {
[08:25:47.579]     {
[08:25:47.579]         {
[08:25:47.579]             ...future.startTime <- base::Sys.time()
[08:25:47.579]             {
[08:25:47.579]                 {
[08:25:47.579]                   {
[08:25:47.579]                     base::local({
[08:25:47.579]                       has_future <- base::requireNamespace("future", 
[08:25:47.579]                         quietly = TRUE)
[08:25:47.579]                       if (has_future) {
[08:25:47.579]                         ns <- base::getNamespace("future")
[08:25:47.579]                         version <- ns[[".package"]][["version"]]
[08:25:47.579]                         if (is.null(version)) 
[08:25:47.579]                           version <- utils::packageVersion("future")
[08:25:47.579]                       }
[08:25:47.579]                       else {
[08:25:47.579]                         version <- NULL
[08:25:47.579]                       }
[08:25:47.579]                       if (!has_future || version < "1.8.0") {
[08:25:47.579]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.579]                           "", base::R.version$version.string), 
[08:25:47.579]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.579]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.579]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.579]                             "release", "version")], collapse = " "), 
[08:25:47.579]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.579]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.579]                           info)
[08:25:47.579]                         info <- base::paste(info, collapse = "; ")
[08:25:47.579]                         if (!has_future) {
[08:25:47.579]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.579]                             info)
[08:25:47.579]                         }
[08:25:47.579]                         else {
[08:25:47.579]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.579]                             info, version)
[08:25:47.579]                         }
[08:25:47.579]                         base::stop(msg)
[08:25:47.579]                       }
[08:25:47.579]                     })
[08:25:47.579]                   }
[08:25:47.579]                   ...future.strategy.old <- future::plan("list")
[08:25:47.579]                   options(future.plan = NULL)
[08:25:47.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.579]                 }
[08:25:47.579]                 ...future.workdir <- getwd()
[08:25:47.579]             }
[08:25:47.579]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.579]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.579]         }
[08:25:47.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.579]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[08:25:47.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.579]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.579]             base::names(...future.oldOptions))
[08:25:47.579]     }
[08:25:47.579]     if (FALSE) {
[08:25:47.579]     }
[08:25:47.579]     else {
[08:25:47.579]         if (TRUE) {
[08:25:47.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.579]                 open = "w")
[08:25:47.579]         }
[08:25:47.579]         else {
[08:25:47.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.579]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.579]         }
[08:25:47.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.579]             base::sink(type = "output", split = FALSE)
[08:25:47.579]             base::close(...future.stdout)
[08:25:47.579]         }, add = TRUE)
[08:25:47.579]     }
[08:25:47.579]     ...future.frame <- base::sys.nframe()
[08:25:47.579]     ...future.conditions <- base::list()
[08:25:47.579]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.579]     if (FALSE) {
[08:25:47.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.579]     }
[08:25:47.579]     ...future.result <- base::tryCatch({
[08:25:47.579]         base::withCallingHandlers({
[08:25:47.579]             ...future.value <- base::withVisible(base::local({
[08:25:47.579]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.579]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.579]                   ...future.globals.maxSize)) {
[08:25:47.579]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.579]                   on.exit(options(oopts), add = TRUE)
[08:25:47.579]                 }
[08:25:47.579]                 {
[08:25:47.579]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.579]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.579]                     USE.NAMES = FALSE)
[08:25:47.579]                   do.call(mapply, args = args)
[08:25:47.579]                 }
[08:25:47.579]             }))
[08:25:47.579]             future::FutureResult(value = ...future.value$value, 
[08:25:47.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.579]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.579]                     ...future.globalenv.names))
[08:25:47.579]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.579]         }, condition = base::local({
[08:25:47.579]             c <- base::c
[08:25:47.579]             inherits <- base::inherits
[08:25:47.579]             invokeRestart <- base::invokeRestart
[08:25:47.579]             length <- base::length
[08:25:47.579]             list <- base::list
[08:25:47.579]             seq.int <- base::seq.int
[08:25:47.579]             signalCondition <- base::signalCondition
[08:25:47.579]             sys.calls <- base::sys.calls
[08:25:47.579]             `[[` <- base::`[[`
[08:25:47.579]             `+` <- base::`+`
[08:25:47.579]             `<<-` <- base::`<<-`
[08:25:47.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.579]                   3L)]
[08:25:47.579]             }
[08:25:47.579]             function(cond) {
[08:25:47.579]                 is_error <- inherits(cond, "error")
[08:25:47.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.579]                   NULL)
[08:25:47.579]                 if (is_error) {
[08:25:47.579]                   sessionInformation <- function() {
[08:25:47.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.579]                       search = base::search(), system = base::Sys.info())
[08:25:47.579]                   }
[08:25:47.579]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.579]                     cond$call), session = sessionInformation(), 
[08:25:47.579]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.579]                   signalCondition(cond)
[08:25:47.579]                 }
[08:25:47.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.579]                 "immediateCondition"))) {
[08:25:47.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.579]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.579]                   if (TRUE && !signal) {
[08:25:47.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.579]                     {
[08:25:47.579]                       inherits <- base::inherits
[08:25:47.579]                       invokeRestart <- base::invokeRestart
[08:25:47.579]                       is.null <- base::is.null
[08:25:47.579]                       muffled <- FALSE
[08:25:47.579]                       if (inherits(cond, "message")) {
[08:25:47.579]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.579]                         if (muffled) 
[08:25:47.579]                           invokeRestart("muffleMessage")
[08:25:47.579]                       }
[08:25:47.579]                       else if (inherits(cond, "warning")) {
[08:25:47.579]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.579]                         if (muffled) 
[08:25:47.579]                           invokeRestart("muffleWarning")
[08:25:47.579]                       }
[08:25:47.579]                       else if (inherits(cond, "condition")) {
[08:25:47.579]                         if (!is.null(pattern)) {
[08:25:47.579]                           computeRestarts <- base::computeRestarts
[08:25:47.579]                           grepl <- base::grepl
[08:25:47.579]                           restarts <- computeRestarts(cond)
[08:25:47.579]                           for (restart in restarts) {
[08:25:47.579]                             name <- restart$name
[08:25:47.579]                             if (is.null(name)) 
[08:25:47.579]                               next
[08:25:47.579]                             if (!grepl(pattern, name)) 
[08:25:47.579]                               next
[08:25:47.579]                             invokeRestart(restart)
[08:25:47.579]                             muffled <- TRUE
[08:25:47.579]                             break
[08:25:47.579]                           }
[08:25:47.579]                         }
[08:25:47.579]                       }
[08:25:47.579]                       invisible(muffled)
[08:25:47.579]                     }
[08:25:47.579]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.579]                   }
[08:25:47.579]                 }
[08:25:47.579]                 else {
[08:25:47.579]                   if (TRUE) {
[08:25:47.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.579]                     {
[08:25:47.579]                       inherits <- base::inherits
[08:25:47.579]                       invokeRestart <- base::invokeRestart
[08:25:47.579]                       is.null <- base::is.null
[08:25:47.579]                       muffled <- FALSE
[08:25:47.579]                       if (inherits(cond, "message")) {
[08:25:47.579]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.579]                         if (muffled) 
[08:25:47.579]                           invokeRestart("muffleMessage")
[08:25:47.579]                       }
[08:25:47.579]                       else if (inherits(cond, "warning")) {
[08:25:47.579]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.579]                         if (muffled) 
[08:25:47.579]                           invokeRestart("muffleWarning")
[08:25:47.579]                       }
[08:25:47.579]                       else if (inherits(cond, "condition")) {
[08:25:47.579]                         if (!is.null(pattern)) {
[08:25:47.579]                           computeRestarts <- base::computeRestarts
[08:25:47.579]                           grepl <- base::grepl
[08:25:47.579]                           restarts <- computeRestarts(cond)
[08:25:47.579]                           for (restart in restarts) {
[08:25:47.579]                             name <- restart$name
[08:25:47.579]                             if (is.null(name)) 
[08:25:47.579]                               next
[08:25:47.579]                             if (!grepl(pattern, name)) 
[08:25:47.579]                               next
[08:25:47.579]                             invokeRestart(restart)
[08:25:47.579]                             muffled <- TRUE
[08:25:47.579]                             break
[08:25:47.579]                           }
[08:25:47.579]                         }
[08:25:47.579]                       }
[08:25:47.579]                       invisible(muffled)
[08:25:47.579]                     }
[08:25:47.579]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.579]                   }
[08:25:47.579]                 }
[08:25:47.579]             }
[08:25:47.579]         }))
[08:25:47.579]     }, error = function(ex) {
[08:25:47.579]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.579]                 ...future.rng), started = ...future.startTime, 
[08:25:47.579]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.579]             version = "1.8"), class = "FutureResult")
[08:25:47.579]     }, finally = {
[08:25:47.579]         if (!identical(...future.workdir, getwd())) 
[08:25:47.579]             setwd(...future.workdir)
[08:25:47.579]         {
[08:25:47.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.579]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.579]             }
[08:25:47.579]             base::options(...future.oldOptions)
[08:25:47.579]             if (.Platform$OS.type == "windows") {
[08:25:47.579]                 old_names <- names(...future.oldEnvVars)
[08:25:47.579]                 envs <- base::Sys.getenv()
[08:25:47.579]                 names <- names(envs)
[08:25:47.579]                 common <- intersect(names, old_names)
[08:25:47.579]                 added <- setdiff(names, old_names)
[08:25:47.579]                 removed <- setdiff(old_names, names)
[08:25:47.579]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.579]                   envs[common]]
[08:25:47.579]                 NAMES <- toupper(changed)
[08:25:47.579]                 args <- list()
[08:25:47.579]                 for (kk in seq_along(NAMES)) {
[08:25:47.579]                   name <- changed[[kk]]
[08:25:47.579]                   NAME <- NAMES[[kk]]
[08:25:47.579]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.579]                     next
[08:25:47.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.579]                 }
[08:25:47.579]                 NAMES <- toupper(added)
[08:25:47.579]                 for (kk in seq_along(NAMES)) {
[08:25:47.579]                   name <- added[[kk]]
[08:25:47.579]                   NAME <- NAMES[[kk]]
[08:25:47.579]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.579]                     next
[08:25:47.579]                   args[[name]] <- ""
[08:25:47.579]                 }
[08:25:47.579]                 NAMES <- toupper(removed)
[08:25:47.579]                 for (kk in seq_along(NAMES)) {
[08:25:47.579]                   name <- removed[[kk]]
[08:25:47.579]                   NAME <- NAMES[[kk]]
[08:25:47.579]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.579]                     next
[08:25:47.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.579]                 }
[08:25:47.579]                 if (length(args) > 0) 
[08:25:47.579]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.579]             }
[08:25:47.579]             else {
[08:25:47.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.579]             }
[08:25:47.579]             {
[08:25:47.579]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.579]                   0L) {
[08:25:47.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.579]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.579]                   base::options(opts)
[08:25:47.579]                 }
[08:25:47.579]                 {
[08:25:47.579]                   {
[08:25:47.579]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.579]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.579]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.579]                       inherits = FALSE)
[08:25:47.579]                     NULL
[08:25:47.579]                   }
[08:25:47.579]                   options(future.plan = NULL)
[08:25:47.579]                   if (is.na(NA_character_)) 
[08:25:47.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.579]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.579]                     .init = FALSE)
[08:25:47.579]                 }
[08:25:47.579]             }
[08:25:47.579]         }
[08:25:47.579]     })
[08:25:47.579]     if (TRUE) {
[08:25:47.579]         base::sink(type = "output", split = FALSE)
[08:25:47.579]         if (TRUE) {
[08:25:47.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.579]         }
[08:25:47.579]         else {
[08:25:47.579]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.579]         }
[08:25:47.579]         base::close(...future.stdout)
[08:25:47.579]         ...future.stdout <- NULL
[08:25:47.579]     }
[08:25:47.579]     ...future.result$conditions <- ...future.conditions
[08:25:47.579]     ...future.result$finished <- base::Sys.time()
[08:25:47.579]     ...future.result
[08:25:47.579] }
[08:25:47.581] assign_globals() ...
[08:25:47.581] List of 5
[08:25:47.581]  $ ...future.FUN            :function (C, k)  
[08:25:47.581]  $ MoreArgs                 : NULL
[08:25:47.581]  $ ...future.elements_ii    :List of 2
[08:25:47.581]   ..$ :List of 1
[08:25:47.581]   .. ..$ : chr "A"
[08:25:47.581]   ..$ :List of 1
[08:25:47.581]   .. ..$ : int 5
[08:25:47.581]  $ ...future.seeds_ii       : NULL
[08:25:47.581]  $ ...future.globals.maxSize: NULL
[08:25:47.581]  - attr(*, "where")=List of 5
[08:25:47.581]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.581]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.581]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.581]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.581]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.581]  - attr(*, "resolved")= logi FALSE
[08:25:47.581]  - attr(*, "total_size")= num 847
[08:25:47.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.581]  - attr(*, "already-done")= logi TRUE
[08:25:47.587] - reassign environment for ‘...future.FUN’
[08:25:47.587] - copied ‘...future.FUN’ to environment
[08:25:47.587] - copied ‘MoreArgs’ to environment
[08:25:47.587] - copied ‘...future.elements_ii’ to environment
[08:25:47.587] - copied ‘...future.seeds_ii’ to environment
[08:25:47.587] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.587] assign_globals() ... done
[08:25:47.587] plan(): Setting new future strategy stack:
[08:25:47.588] List of future strategies:
[08:25:47.588] 1. sequential:
[08:25:47.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.588]    - tweaked: FALSE
[08:25:47.588]    - call: NULL
[08:25:47.588] plan(): nbrOfWorkers() = 1
[08:25:47.589] plan(): Setting new future strategy stack:
[08:25:47.589] List of future strategies:
[08:25:47.589] 1. sequential:
[08:25:47.589]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.589]    - tweaked: FALSE
[08:25:47.589]    - call: plan(strategy)
[08:25:47.589] plan(): nbrOfWorkers() = 1
[08:25:47.590] SequentialFuture started (and completed)
[08:25:47.590] - Launch lazy future ... done
[08:25:47.590] run() for ‘SequentialFuture’ ... done
[08:25:47.590] Created future:
[08:25:47.590] SequentialFuture:
[08:25:47.590] Label: ‘future_mapply-2’
[08:25:47.590] Expression:
[08:25:47.590] {
[08:25:47.590]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.590]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.590]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.590]         on.exit(options(oopts), add = TRUE)
[08:25:47.590]     }
[08:25:47.590]     {
[08:25:47.590]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.590]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.590]         do.call(mapply, args = args)
[08:25:47.590]     }
[08:25:47.590] }
[08:25:47.590] Lazy evaluation: FALSE
[08:25:47.590] Asynchronous evaluation: FALSE
[08:25:47.590] Local evaluation: TRUE
[08:25:47.590] Environment: R_GlobalEnv
[08:25:47.590] Capture standard output: TRUE
[08:25:47.590] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.590] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.590] Packages: <none>
[08:25:47.590] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.590] Resolved: TRUE
[08:25:47.590] Value: 52 bytes of class ‘list’
[08:25:47.590] Early signaling: FALSE
[08:25:47.590] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.590] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.593] Chunk #2 of 3 ... DONE
[08:25:47.593] Chunk #3 of 3 ...
[08:25:47.593]  - Finding globals in '...' for chunk #3 ...
[08:25:47.593] getGlobalsAndPackages() ...
[08:25:47.594] Searching for globals...
[08:25:47.594] 
[08:25:47.594] Searching for globals ... DONE
[08:25:47.594] - globals: [0] <none>
[08:25:47.594] getGlobalsAndPackages() ... DONE
[08:25:47.595]    + additional globals found: [n=0] 
[08:25:47.595]    + additional namespaces needed: [n=0] 
[08:25:47.595]  - Finding globals in '...' for chunk #3 ... DONE
[08:25:47.595]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[08:25:47.595]  - seeds: <none>
[08:25:47.595]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.595] getGlobalsAndPackages() ...
[08:25:47.595] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.596] Resolving globals: FALSE
[08:25:47.596] The total size of the 5 globals is 876 bytes (876 bytes)
[08:25:47.597] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.597] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.597] 
[08:25:47.597] getGlobalsAndPackages() ... DONE
[08:25:47.597] run() for ‘Future’ ...
[08:25:47.597] - state: ‘created’
[08:25:47.597] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.598] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.598] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.598]   - Field: ‘label’
[08:25:47.598]   - Field: ‘local’
[08:25:47.598]   - Field: ‘owner’
[08:25:47.598]   - Field: ‘envir’
[08:25:47.598]   - Field: ‘packages’
[08:25:47.599]   - Field: ‘gc’
[08:25:47.599]   - Field: ‘conditions’
[08:25:47.599]   - Field: ‘expr’
[08:25:47.599]   - Field: ‘uuid’
[08:25:47.599]   - Field: ‘seed’
[08:25:47.599]   - Field: ‘version’
[08:25:47.599]   - Field: ‘result’
[08:25:47.599]   - Field: ‘asynchronous’
[08:25:47.599]   - Field: ‘calls’
[08:25:47.599]   - Field: ‘globals’
[08:25:47.599]   - Field: ‘stdout’
[08:25:47.600]   - Field: ‘earlySignal’
[08:25:47.600]   - Field: ‘lazy’
[08:25:47.600]   - Field: ‘state’
[08:25:47.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.600] - Launch lazy future ...
[08:25:47.600] Packages needed by the future expression (n = 0): <none>
[08:25:47.600] Packages needed by future strategies (n = 0): <none>
[08:25:47.601] {
[08:25:47.601]     {
[08:25:47.601]         {
[08:25:47.601]             ...future.startTime <- base::Sys.time()
[08:25:47.601]             {
[08:25:47.601]                 {
[08:25:47.601]                   {
[08:25:47.601]                     base::local({
[08:25:47.601]                       has_future <- base::requireNamespace("future", 
[08:25:47.601]                         quietly = TRUE)
[08:25:47.601]                       if (has_future) {
[08:25:47.601]                         ns <- base::getNamespace("future")
[08:25:47.601]                         version <- ns[[".package"]][["version"]]
[08:25:47.601]                         if (is.null(version)) 
[08:25:47.601]                           version <- utils::packageVersion("future")
[08:25:47.601]                       }
[08:25:47.601]                       else {
[08:25:47.601]                         version <- NULL
[08:25:47.601]                       }
[08:25:47.601]                       if (!has_future || version < "1.8.0") {
[08:25:47.601]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.601]                           "", base::R.version$version.string), 
[08:25:47.601]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.601]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.601]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.601]                             "release", "version")], collapse = " "), 
[08:25:47.601]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.601]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.601]                           info)
[08:25:47.601]                         info <- base::paste(info, collapse = "; ")
[08:25:47.601]                         if (!has_future) {
[08:25:47.601]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.601]                             info)
[08:25:47.601]                         }
[08:25:47.601]                         else {
[08:25:47.601]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.601]                             info, version)
[08:25:47.601]                         }
[08:25:47.601]                         base::stop(msg)
[08:25:47.601]                       }
[08:25:47.601]                     })
[08:25:47.601]                   }
[08:25:47.601]                   ...future.strategy.old <- future::plan("list")
[08:25:47.601]                   options(future.plan = NULL)
[08:25:47.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.601]                 }
[08:25:47.601]                 ...future.workdir <- getwd()
[08:25:47.601]             }
[08:25:47.601]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.601]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.601]         }
[08:25:47.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.601]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[08:25:47.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.601]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.601]             base::names(...future.oldOptions))
[08:25:47.601]     }
[08:25:47.601]     if (FALSE) {
[08:25:47.601]     }
[08:25:47.601]     else {
[08:25:47.601]         if (TRUE) {
[08:25:47.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.601]                 open = "w")
[08:25:47.601]         }
[08:25:47.601]         else {
[08:25:47.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.601]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.601]         }
[08:25:47.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.601]             base::sink(type = "output", split = FALSE)
[08:25:47.601]             base::close(...future.stdout)
[08:25:47.601]         }, add = TRUE)
[08:25:47.601]     }
[08:25:47.601]     ...future.frame <- base::sys.nframe()
[08:25:47.601]     ...future.conditions <- base::list()
[08:25:47.601]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.601]     if (FALSE) {
[08:25:47.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.601]     }
[08:25:47.601]     ...future.result <- base::tryCatch({
[08:25:47.601]         base::withCallingHandlers({
[08:25:47.601]             ...future.value <- base::withVisible(base::local({
[08:25:47.601]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.601]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.601]                   ...future.globals.maxSize)) {
[08:25:47.601]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.601]                   on.exit(options(oopts), add = TRUE)
[08:25:47.601]                 }
[08:25:47.601]                 {
[08:25:47.601]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.601]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.601]                     USE.NAMES = FALSE)
[08:25:47.601]                   do.call(mapply, args = args)
[08:25:47.601]                 }
[08:25:47.601]             }))
[08:25:47.601]             future::FutureResult(value = ...future.value$value, 
[08:25:47.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.601]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.601]                     ...future.globalenv.names))
[08:25:47.601]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.601]         }, condition = base::local({
[08:25:47.601]             c <- base::c
[08:25:47.601]             inherits <- base::inherits
[08:25:47.601]             invokeRestart <- base::invokeRestart
[08:25:47.601]             length <- base::length
[08:25:47.601]             list <- base::list
[08:25:47.601]             seq.int <- base::seq.int
[08:25:47.601]             signalCondition <- base::signalCondition
[08:25:47.601]             sys.calls <- base::sys.calls
[08:25:47.601]             `[[` <- base::`[[`
[08:25:47.601]             `+` <- base::`+`
[08:25:47.601]             `<<-` <- base::`<<-`
[08:25:47.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.601]                   3L)]
[08:25:47.601]             }
[08:25:47.601]             function(cond) {
[08:25:47.601]                 is_error <- inherits(cond, "error")
[08:25:47.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.601]                   NULL)
[08:25:47.601]                 if (is_error) {
[08:25:47.601]                   sessionInformation <- function() {
[08:25:47.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.601]                       search = base::search(), system = base::Sys.info())
[08:25:47.601]                   }
[08:25:47.601]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.601]                     cond$call), session = sessionInformation(), 
[08:25:47.601]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.601]                   signalCondition(cond)
[08:25:47.601]                 }
[08:25:47.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.601]                 "immediateCondition"))) {
[08:25:47.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.601]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.601]                   if (TRUE && !signal) {
[08:25:47.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.601]                     {
[08:25:47.601]                       inherits <- base::inherits
[08:25:47.601]                       invokeRestart <- base::invokeRestart
[08:25:47.601]                       is.null <- base::is.null
[08:25:47.601]                       muffled <- FALSE
[08:25:47.601]                       if (inherits(cond, "message")) {
[08:25:47.601]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.601]                         if (muffled) 
[08:25:47.601]                           invokeRestart("muffleMessage")
[08:25:47.601]                       }
[08:25:47.601]                       else if (inherits(cond, "warning")) {
[08:25:47.601]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.601]                         if (muffled) 
[08:25:47.601]                           invokeRestart("muffleWarning")
[08:25:47.601]                       }
[08:25:47.601]                       else if (inherits(cond, "condition")) {
[08:25:47.601]                         if (!is.null(pattern)) {
[08:25:47.601]                           computeRestarts <- base::computeRestarts
[08:25:47.601]                           grepl <- base::grepl
[08:25:47.601]                           restarts <- computeRestarts(cond)
[08:25:47.601]                           for (restart in restarts) {
[08:25:47.601]                             name <- restart$name
[08:25:47.601]                             if (is.null(name)) 
[08:25:47.601]                               next
[08:25:47.601]                             if (!grepl(pattern, name)) 
[08:25:47.601]                               next
[08:25:47.601]                             invokeRestart(restart)
[08:25:47.601]                             muffled <- TRUE
[08:25:47.601]                             break
[08:25:47.601]                           }
[08:25:47.601]                         }
[08:25:47.601]                       }
[08:25:47.601]                       invisible(muffled)
[08:25:47.601]                     }
[08:25:47.601]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.601]                   }
[08:25:47.601]                 }
[08:25:47.601]                 else {
[08:25:47.601]                   if (TRUE) {
[08:25:47.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.601]                     {
[08:25:47.601]                       inherits <- base::inherits
[08:25:47.601]                       invokeRestart <- base::invokeRestart
[08:25:47.601]                       is.null <- base::is.null
[08:25:47.601]                       muffled <- FALSE
[08:25:47.601]                       if (inherits(cond, "message")) {
[08:25:47.601]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.601]                         if (muffled) 
[08:25:47.601]                           invokeRestart("muffleMessage")
[08:25:47.601]                       }
[08:25:47.601]                       else if (inherits(cond, "warning")) {
[08:25:47.601]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.601]                         if (muffled) 
[08:25:47.601]                           invokeRestart("muffleWarning")
[08:25:47.601]                       }
[08:25:47.601]                       else if (inherits(cond, "condition")) {
[08:25:47.601]                         if (!is.null(pattern)) {
[08:25:47.601]                           computeRestarts <- base::computeRestarts
[08:25:47.601]                           grepl <- base::grepl
[08:25:47.601]                           restarts <- computeRestarts(cond)
[08:25:47.601]                           for (restart in restarts) {
[08:25:47.601]                             name <- restart$name
[08:25:47.601]                             if (is.null(name)) 
[08:25:47.601]                               next
[08:25:47.601]                             if (!grepl(pattern, name)) 
[08:25:47.601]                               next
[08:25:47.601]                             invokeRestart(restart)
[08:25:47.601]                             muffled <- TRUE
[08:25:47.601]                             break
[08:25:47.601]                           }
[08:25:47.601]                         }
[08:25:47.601]                       }
[08:25:47.601]                       invisible(muffled)
[08:25:47.601]                     }
[08:25:47.601]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.601]                   }
[08:25:47.601]                 }
[08:25:47.601]             }
[08:25:47.601]         }))
[08:25:47.601]     }, error = function(ex) {
[08:25:47.601]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.601]                 ...future.rng), started = ...future.startTime, 
[08:25:47.601]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.601]             version = "1.8"), class = "FutureResult")
[08:25:47.601]     }, finally = {
[08:25:47.601]         if (!identical(...future.workdir, getwd())) 
[08:25:47.601]             setwd(...future.workdir)
[08:25:47.601]         {
[08:25:47.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.601]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.601]             }
[08:25:47.601]             base::options(...future.oldOptions)
[08:25:47.601]             if (.Platform$OS.type == "windows") {
[08:25:47.601]                 old_names <- names(...future.oldEnvVars)
[08:25:47.601]                 envs <- base::Sys.getenv()
[08:25:47.601]                 names <- names(envs)
[08:25:47.601]                 common <- intersect(names, old_names)
[08:25:47.601]                 added <- setdiff(names, old_names)
[08:25:47.601]                 removed <- setdiff(old_names, names)
[08:25:47.601]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.601]                   envs[common]]
[08:25:47.601]                 NAMES <- toupper(changed)
[08:25:47.601]                 args <- list()
[08:25:47.601]                 for (kk in seq_along(NAMES)) {
[08:25:47.601]                   name <- changed[[kk]]
[08:25:47.601]                   NAME <- NAMES[[kk]]
[08:25:47.601]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.601]                     next
[08:25:47.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.601]                 }
[08:25:47.601]                 NAMES <- toupper(added)
[08:25:47.601]                 for (kk in seq_along(NAMES)) {
[08:25:47.601]                   name <- added[[kk]]
[08:25:47.601]                   NAME <- NAMES[[kk]]
[08:25:47.601]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.601]                     next
[08:25:47.601]                   args[[name]] <- ""
[08:25:47.601]                 }
[08:25:47.601]                 NAMES <- toupper(removed)
[08:25:47.601]                 for (kk in seq_along(NAMES)) {
[08:25:47.601]                   name <- removed[[kk]]
[08:25:47.601]                   NAME <- NAMES[[kk]]
[08:25:47.601]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.601]                     next
[08:25:47.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.601]                 }
[08:25:47.601]                 if (length(args) > 0) 
[08:25:47.601]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.601]             }
[08:25:47.601]             else {
[08:25:47.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.601]             }
[08:25:47.601]             {
[08:25:47.601]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.601]                   0L) {
[08:25:47.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.601]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.601]                   base::options(opts)
[08:25:47.601]                 }
[08:25:47.601]                 {
[08:25:47.601]                   {
[08:25:47.601]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.601]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.601]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.601]                       inherits = FALSE)
[08:25:47.601]                     NULL
[08:25:47.601]                   }
[08:25:47.601]                   options(future.plan = NULL)
[08:25:47.601]                   if (is.na(NA_character_)) 
[08:25:47.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.601]                     .init = FALSE)
[08:25:47.601]                 }
[08:25:47.601]             }
[08:25:47.601]         }
[08:25:47.601]     })
[08:25:47.601]     if (TRUE) {
[08:25:47.601]         base::sink(type = "output", split = FALSE)
[08:25:47.601]         if (TRUE) {
[08:25:47.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.601]         }
[08:25:47.601]         else {
[08:25:47.601]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.601]         }
[08:25:47.601]         base::close(...future.stdout)
[08:25:47.601]         ...future.stdout <- NULL
[08:25:47.601]     }
[08:25:47.601]     ...future.result$conditions <- ...future.conditions
[08:25:47.601]     ...future.result$finished <- base::Sys.time()
[08:25:47.601]     ...future.result
[08:25:47.601] }
[08:25:47.603] assign_globals() ...
[08:25:47.603] List of 5
[08:25:47.603]  $ ...future.FUN            :function (C, k)  
[08:25:47.603]  $ MoreArgs                 : NULL
[08:25:47.603]  $ ...future.elements_ii    :List of 2
[08:25:47.603]   ..$ :List of 2
[08:25:47.603]   .. ..$ : chr "E"
[08:25:47.603]   .. ..$ : chr "C"
[08:25:47.603]   ..$ :List of 2
[08:25:47.603]   .. ..$ : int 1
[08:25:47.603]   .. ..$ : int 3
[08:25:47.603]  $ ...future.seeds_ii       : NULL
[08:25:47.603]  $ ...future.globals.maxSize: NULL
[08:25:47.603]  - attr(*, "where")=List of 5
[08:25:47.603]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.603]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.603]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.603]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.603]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.603]  - attr(*, "resolved")= logi FALSE
[08:25:47.603]  - attr(*, "total_size")= num 876
[08:25:47.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.603]  - attr(*, "already-done")= logi TRUE
[08:25:47.608] - reassign environment for ‘...future.FUN’
[08:25:47.609] - copied ‘...future.FUN’ to environment
[08:25:47.609] - copied ‘MoreArgs’ to environment
[08:25:47.609] - copied ‘...future.elements_ii’ to environment
[08:25:47.609] - copied ‘...future.seeds_ii’ to environment
[08:25:47.609] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.609] assign_globals() ... done
[08:25:47.609] plan(): Setting new future strategy stack:
[08:25:47.609] List of future strategies:
[08:25:47.609] 1. sequential:
[08:25:47.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.609]    - tweaked: FALSE
[08:25:47.609]    - call: NULL
[08:25:47.610] plan(): nbrOfWorkers() = 1
[08:25:47.611] plan(): Setting new future strategy stack:
[08:25:47.611] List of future strategies:
[08:25:47.611] 1. sequential:
[08:25:47.611]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.611]    - tweaked: FALSE
[08:25:47.611]    - call: plan(strategy)
[08:25:47.611] plan(): nbrOfWorkers() = 1
[08:25:47.612] SequentialFuture started (and completed)
[08:25:47.612] - Launch lazy future ... done
[08:25:47.612] run() for ‘SequentialFuture’ ... done
[08:25:47.612] Created future:
[08:25:47.612] SequentialFuture:
[08:25:47.612] Label: ‘future_mapply-3’
[08:25:47.612] Expression:
[08:25:47.612] {
[08:25:47.612]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.612]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.612]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.612]         on.exit(options(oopts), add = TRUE)
[08:25:47.612]     }
[08:25:47.612]     {
[08:25:47.612]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.612]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.612]         do.call(mapply, args = args)
[08:25:47.612]     }
[08:25:47.612] }
[08:25:47.612] Lazy evaluation: FALSE
[08:25:47.612] Asynchronous evaluation: FALSE
[08:25:47.612] Local evaluation: TRUE
[08:25:47.612] Environment: R_GlobalEnv
[08:25:47.612] Capture standard output: TRUE
[08:25:47.612] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.612] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.612] Packages: <none>
[08:25:47.612] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.612] Resolved: TRUE
[08:25:47.612] Value: 67 bytes of class ‘list’
[08:25:47.612] Early signaling: FALSE
[08:25:47.612] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.612] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.613] Chunk #3 of 3 ... DONE
[08:25:47.613] Launching 3 futures (chunks) ... DONE
[08:25:47.613] Resolving 3 futures (chunks) ...
[08:25:47.613] resolve() on list ...
[08:25:47.613]  recursive: 0
[08:25:47.613]  length: 3
[08:25:47.613] 
[08:25:47.614] resolved() for ‘SequentialFuture’ ...
[08:25:47.614] - state: ‘finished’
[08:25:47.614] - run: TRUE
[08:25:47.614] - result: ‘FutureResult’
[08:25:47.614] resolved() for ‘SequentialFuture’ ... done
[08:25:47.614] Future #1
[08:25:47.614] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.614] - nx: 3
[08:25:47.614] - relay: TRUE
[08:25:47.614] - stdout: TRUE
[08:25:47.615] - signal: TRUE
[08:25:47.615] - resignal: FALSE
[08:25:47.615] - force: TRUE
[08:25:47.615] - relayed: [n=3] FALSE, FALSE, FALSE
[08:25:47.615] - queued futures: [n=3] FALSE, FALSE, FALSE
[08:25:47.615]  - until=1
[08:25:47.615]  - relaying element #1
[08:25:47.615] - relayed: [n=3] TRUE, FALSE, FALSE
[08:25:47.615] - queued futures: [n=3] TRUE, FALSE, FALSE
[08:25:47.615] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.616]  length: 2 (resolved future 1)
[08:25:47.616] resolved() for ‘SequentialFuture’ ...
[08:25:47.616] - state: ‘finished’
[08:25:47.616] - run: TRUE
[08:25:47.616] - result: ‘FutureResult’
[08:25:47.616] resolved() for ‘SequentialFuture’ ... done
[08:25:47.616] Future #2
[08:25:47.616] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:25:47.616] - nx: 3
[08:25:47.616] - relay: TRUE
[08:25:47.617] - stdout: TRUE
[08:25:47.617] - signal: TRUE
[08:25:47.617] - resignal: FALSE
[08:25:47.617] - force: TRUE
[08:25:47.617] - relayed: [n=3] TRUE, FALSE, FALSE
[08:25:47.617] - queued futures: [n=3] TRUE, FALSE, FALSE
[08:25:47.617]  - until=2
[08:25:47.617]  - relaying element #2
[08:25:47.617] - relayed: [n=3] TRUE, TRUE, FALSE
[08:25:47.617] - queued futures: [n=3] TRUE, TRUE, FALSE
[08:25:47.617] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:25:47.618]  length: 1 (resolved future 2)
[08:25:47.618] resolved() for ‘SequentialFuture’ ...
[08:25:47.618] - state: ‘finished’
[08:25:47.618] - run: TRUE
[08:25:47.618] - result: ‘FutureResult’
[08:25:47.618] resolved() for ‘SequentialFuture’ ... done
[08:25:47.618] Future #3
[08:25:47.618] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:25:47.618] - nx: 3
[08:25:47.618] - relay: TRUE
[08:25:47.620] - stdout: TRUE
[08:25:47.620] - signal: TRUE
[08:25:47.621] - resignal: FALSE
[08:25:47.621] - force: TRUE
[08:25:47.621] - relayed: [n=3] TRUE, TRUE, FALSE
[08:25:47.621] - queued futures: [n=3] TRUE, TRUE, FALSE
[08:25:47.621]  - until=3
[08:25:47.621]  - relaying element #3
[08:25:47.621] - relayed: [n=3] TRUE, TRUE, TRUE
[08:25:47.622] - queued futures: [n=3] TRUE, TRUE, TRUE
[08:25:47.622] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:25:47.622]  length: 0 (resolved future 3)
[08:25:47.622] Relaying remaining futures
[08:25:47.622] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.622] - nx: 3
[08:25:47.622] - relay: TRUE
[08:25:47.622] - stdout: TRUE
[08:25:47.622] - signal: TRUE
[08:25:47.622] - resignal: FALSE
[08:25:47.623] - force: TRUE
[08:25:47.623] - relayed: [n=3] TRUE, TRUE, TRUE
[08:25:47.623] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[08:25:47.623] - relayed: [n=3] TRUE, TRUE, TRUE
[08:25:47.623] - queued futures: [n=3] TRUE, TRUE, TRUE
[08:25:47.623] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.623] resolve() on list ... DONE
[08:25:47.623]  - Number of value chunks collected: 3
[08:25:47.624] Resolving 3 futures (chunks) ... DONE
[08:25:47.624] Reducing values from 3 chunks ...
[08:25:47.624]  - Number of values collected after concatenation: 5
[08:25:47.624]  - Number of values expected: 5
[08:25:47.624] Reverse index remapping (attribute 'ordering'): [n = 5] 3, 2, 5, 1, 4
[08:25:47.624] Reducing values from 3 chunks ... DONE
[08:25:47.624] future_mapply() ... DONE
[08:25:47.624] future_mapply() ...
[08:25:47.625] Number of chunks: 1
[08:25:47.625] getGlobalsAndPackagesXApply() ...
[08:25:47.625]  - future.globals: TRUE
[08:25:47.625] getGlobalsAndPackages() ...
[08:25:47.625] Searching for globals...
[08:25:47.626] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:47.626] Searching for globals ... DONE
[08:25:47.627] Resolving globals: FALSE
[08:25:47.627] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:47.627] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:47.627] - globals: [1] ‘FUN’
[08:25:47.627] 
[08:25:47.628] getGlobalsAndPackages() ... DONE
[08:25:47.628]  - globals found/used: [n=1] ‘FUN’
[08:25:47.628]  - needed namespaces: [n=0] 
[08:25:47.628] Finding globals ... DONE
[08:25:47.628] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.628] List of 2
[08:25:47.628]  $ ...future.FUN:function (C, k)  
[08:25:47.628]  $ MoreArgs     : list()
[08:25:47.628]  - attr(*, "where")=List of 2
[08:25:47.628]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.628]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.628]  - attr(*, "resolved")= logi FALSE
[08:25:47.628]  - attr(*, "total_size")= num NA
[08:25:47.631] Packages to be attached in all futures: [n=0] 
[08:25:47.631] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.631] Number of futures (= number of chunks): 1
[08:25:47.631] Launching 1 futures (chunks) ...
[08:25:47.631] Chunk #1 of 1 ...
[08:25:47.631]  - Finding globals in '...' for chunk #1 ...
[08:25:47.631] getGlobalsAndPackages() ...
[08:25:47.632] Searching for globals...
[08:25:47.632] 
[08:25:47.632] Searching for globals ... DONE
[08:25:47.632] - globals: [0] <none>
[08:25:47.632] getGlobalsAndPackages() ... DONE
[08:25:47.632]    + additional globals found: [n=0] 
[08:25:47.632]    + additional namespaces needed: [n=0] 
[08:25:47.632]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.633]  - seeds: <none>
[08:25:47.633]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.633] getGlobalsAndPackages() ...
[08:25:47.633] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.633] Resolving globals: FALSE
[08:25:47.633] The total size of the 5 globals is 967 bytes (967 bytes)
[08:25:47.634] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 967 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (192 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:47.634] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.634] 
[08:25:47.634] getGlobalsAndPackages() ... DONE
[08:25:47.634] run() for ‘Future’ ...
[08:25:47.635] - state: ‘created’
[08:25:47.635] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.635] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.635] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.635]   - Field: ‘label’
[08:25:47.635]   - Field: ‘local’
[08:25:47.635]   - Field: ‘owner’
[08:25:47.636]   - Field: ‘envir’
[08:25:47.636]   - Field: ‘packages’
[08:25:47.636]   - Field: ‘gc’
[08:25:47.636]   - Field: ‘conditions’
[08:25:47.636]   - Field: ‘expr’
[08:25:47.636]   - Field: ‘uuid’
[08:25:47.636]   - Field: ‘seed’
[08:25:47.636]   - Field: ‘version’
[08:25:47.636]   - Field: ‘result’
[08:25:47.636]   - Field: ‘asynchronous’
[08:25:47.636]   - Field: ‘calls’
[08:25:47.637]   - Field: ‘globals’
[08:25:47.637]   - Field: ‘stdout’
[08:25:47.637]   - Field: ‘earlySignal’
[08:25:47.637]   - Field: ‘lazy’
[08:25:47.637]   - Field: ‘state’
[08:25:47.637] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.637] - Launch lazy future ...
[08:25:47.637] Packages needed by the future expression (n = 0): <none>
[08:25:47.637] Packages needed by future strategies (n = 0): <none>
[08:25:47.638] {
[08:25:47.638]     {
[08:25:47.638]         {
[08:25:47.638]             ...future.startTime <- base::Sys.time()
[08:25:47.638]             {
[08:25:47.638]                 {
[08:25:47.638]                   {
[08:25:47.638]                     base::local({
[08:25:47.638]                       has_future <- base::requireNamespace("future", 
[08:25:47.638]                         quietly = TRUE)
[08:25:47.638]                       if (has_future) {
[08:25:47.638]                         ns <- base::getNamespace("future")
[08:25:47.638]                         version <- ns[[".package"]][["version"]]
[08:25:47.638]                         if (is.null(version)) 
[08:25:47.638]                           version <- utils::packageVersion("future")
[08:25:47.638]                       }
[08:25:47.638]                       else {
[08:25:47.638]                         version <- NULL
[08:25:47.638]                       }
[08:25:47.638]                       if (!has_future || version < "1.8.0") {
[08:25:47.638]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.638]                           "", base::R.version$version.string), 
[08:25:47.638]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.638]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.638]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.638]                             "release", "version")], collapse = " "), 
[08:25:47.638]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.638]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.638]                           info)
[08:25:47.638]                         info <- base::paste(info, collapse = "; ")
[08:25:47.638]                         if (!has_future) {
[08:25:47.638]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.638]                             info)
[08:25:47.638]                         }
[08:25:47.638]                         else {
[08:25:47.638]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.638]                             info, version)
[08:25:47.638]                         }
[08:25:47.638]                         base::stop(msg)
[08:25:47.638]                       }
[08:25:47.638]                     })
[08:25:47.638]                   }
[08:25:47.638]                   ...future.strategy.old <- future::plan("list")
[08:25:47.638]                   options(future.plan = NULL)
[08:25:47.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.638]                 }
[08:25:47.638]                 ...future.workdir <- getwd()
[08:25:47.638]             }
[08:25:47.638]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.638]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.638]         }
[08:25:47.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.638]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.638]             base::names(...future.oldOptions))
[08:25:47.638]     }
[08:25:47.638]     if (FALSE) {
[08:25:47.638]     }
[08:25:47.638]     else {
[08:25:47.638]         if (TRUE) {
[08:25:47.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.638]                 open = "w")
[08:25:47.638]         }
[08:25:47.638]         else {
[08:25:47.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.638]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.638]         }
[08:25:47.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.638]             base::sink(type = "output", split = FALSE)
[08:25:47.638]             base::close(...future.stdout)
[08:25:47.638]         }, add = TRUE)
[08:25:47.638]     }
[08:25:47.638]     ...future.frame <- base::sys.nframe()
[08:25:47.638]     ...future.conditions <- base::list()
[08:25:47.638]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.638]     if (FALSE) {
[08:25:47.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.638]     }
[08:25:47.638]     ...future.result <- base::tryCatch({
[08:25:47.638]         base::withCallingHandlers({
[08:25:47.638]             ...future.value <- base::withVisible(base::local({
[08:25:47.638]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.638]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.638]                   ...future.globals.maxSize)) {
[08:25:47.638]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.638]                   on.exit(options(oopts), add = TRUE)
[08:25:47.638]                 }
[08:25:47.638]                 {
[08:25:47.638]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.638]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.638]                     USE.NAMES = FALSE)
[08:25:47.638]                   do.call(mapply, args = args)
[08:25:47.638]                 }
[08:25:47.638]             }))
[08:25:47.638]             future::FutureResult(value = ...future.value$value, 
[08:25:47.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.638]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.638]                     ...future.globalenv.names))
[08:25:47.638]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.638]         }, condition = base::local({
[08:25:47.638]             c <- base::c
[08:25:47.638]             inherits <- base::inherits
[08:25:47.638]             invokeRestart <- base::invokeRestart
[08:25:47.638]             length <- base::length
[08:25:47.638]             list <- base::list
[08:25:47.638]             seq.int <- base::seq.int
[08:25:47.638]             signalCondition <- base::signalCondition
[08:25:47.638]             sys.calls <- base::sys.calls
[08:25:47.638]             `[[` <- base::`[[`
[08:25:47.638]             `+` <- base::`+`
[08:25:47.638]             `<<-` <- base::`<<-`
[08:25:47.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.638]                   3L)]
[08:25:47.638]             }
[08:25:47.638]             function(cond) {
[08:25:47.638]                 is_error <- inherits(cond, "error")
[08:25:47.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.638]                   NULL)
[08:25:47.638]                 if (is_error) {
[08:25:47.638]                   sessionInformation <- function() {
[08:25:47.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.638]                       search = base::search(), system = base::Sys.info())
[08:25:47.638]                   }
[08:25:47.638]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.638]                     cond$call), session = sessionInformation(), 
[08:25:47.638]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.638]                   signalCondition(cond)
[08:25:47.638]                 }
[08:25:47.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.638]                 "immediateCondition"))) {
[08:25:47.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.638]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.638]                   if (TRUE && !signal) {
[08:25:47.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.638]                     {
[08:25:47.638]                       inherits <- base::inherits
[08:25:47.638]                       invokeRestart <- base::invokeRestart
[08:25:47.638]                       is.null <- base::is.null
[08:25:47.638]                       muffled <- FALSE
[08:25:47.638]                       if (inherits(cond, "message")) {
[08:25:47.638]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.638]                         if (muffled) 
[08:25:47.638]                           invokeRestart("muffleMessage")
[08:25:47.638]                       }
[08:25:47.638]                       else if (inherits(cond, "warning")) {
[08:25:47.638]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.638]                         if (muffled) 
[08:25:47.638]                           invokeRestart("muffleWarning")
[08:25:47.638]                       }
[08:25:47.638]                       else if (inherits(cond, "condition")) {
[08:25:47.638]                         if (!is.null(pattern)) {
[08:25:47.638]                           computeRestarts <- base::computeRestarts
[08:25:47.638]                           grepl <- base::grepl
[08:25:47.638]                           restarts <- computeRestarts(cond)
[08:25:47.638]                           for (restart in restarts) {
[08:25:47.638]                             name <- restart$name
[08:25:47.638]                             if (is.null(name)) 
[08:25:47.638]                               next
[08:25:47.638]                             if (!grepl(pattern, name)) 
[08:25:47.638]                               next
[08:25:47.638]                             invokeRestart(restart)
[08:25:47.638]                             muffled <- TRUE
[08:25:47.638]                             break
[08:25:47.638]                           }
[08:25:47.638]                         }
[08:25:47.638]                       }
[08:25:47.638]                       invisible(muffled)
[08:25:47.638]                     }
[08:25:47.638]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.638]                   }
[08:25:47.638]                 }
[08:25:47.638]                 else {
[08:25:47.638]                   if (TRUE) {
[08:25:47.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.638]                     {
[08:25:47.638]                       inherits <- base::inherits
[08:25:47.638]                       invokeRestart <- base::invokeRestart
[08:25:47.638]                       is.null <- base::is.null
[08:25:47.638]                       muffled <- FALSE
[08:25:47.638]                       if (inherits(cond, "message")) {
[08:25:47.638]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.638]                         if (muffled) 
[08:25:47.638]                           invokeRestart("muffleMessage")
[08:25:47.638]                       }
[08:25:47.638]                       else if (inherits(cond, "warning")) {
[08:25:47.638]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.638]                         if (muffled) 
[08:25:47.638]                           invokeRestart("muffleWarning")
[08:25:47.638]                       }
[08:25:47.638]                       else if (inherits(cond, "condition")) {
[08:25:47.638]                         if (!is.null(pattern)) {
[08:25:47.638]                           computeRestarts <- base::computeRestarts
[08:25:47.638]                           grepl <- base::grepl
[08:25:47.638]                           restarts <- computeRestarts(cond)
[08:25:47.638]                           for (restart in restarts) {
[08:25:47.638]                             name <- restart$name
[08:25:47.638]                             if (is.null(name)) 
[08:25:47.638]                               next
[08:25:47.638]                             if (!grepl(pattern, name)) 
[08:25:47.638]                               next
[08:25:47.638]                             invokeRestart(restart)
[08:25:47.638]                             muffled <- TRUE
[08:25:47.638]                             break
[08:25:47.638]                           }
[08:25:47.638]                         }
[08:25:47.638]                       }
[08:25:47.638]                       invisible(muffled)
[08:25:47.638]                     }
[08:25:47.638]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.638]                   }
[08:25:47.638]                 }
[08:25:47.638]             }
[08:25:47.638]         }))
[08:25:47.638]     }, error = function(ex) {
[08:25:47.638]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.638]                 ...future.rng), started = ...future.startTime, 
[08:25:47.638]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.638]             version = "1.8"), class = "FutureResult")
[08:25:47.638]     }, finally = {
[08:25:47.638]         if (!identical(...future.workdir, getwd())) 
[08:25:47.638]             setwd(...future.workdir)
[08:25:47.638]         {
[08:25:47.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.638]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.638]             }
[08:25:47.638]             base::options(...future.oldOptions)
[08:25:47.638]             if (.Platform$OS.type == "windows") {
[08:25:47.638]                 old_names <- names(...future.oldEnvVars)
[08:25:47.638]                 envs <- base::Sys.getenv()
[08:25:47.638]                 names <- names(envs)
[08:25:47.638]                 common <- intersect(names, old_names)
[08:25:47.638]                 added <- setdiff(names, old_names)
[08:25:47.638]                 removed <- setdiff(old_names, names)
[08:25:47.638]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.638]                   envs[common]]
[08:25:47.638]                 NAMES <- toupper(changed)
[08:25:47.638]                 args <- list()
[08:25:47.638]                 for (kk in seq_along(NAMES)) {
[08:25:47.638]                   name <- changed[[kk]]
[08:25:47.638]                   NAME <- NAMES[[kk]]
[08:25:47.638]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.638]                     next
[08:25:47.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.638]                 }
[08:25:47.638]                 NAMES <- toupper(added)
[08:25:47.638]                 for (kk in seq_along(NAMES)) {
[08:25:47.638]                   name <- added[[kk]]
[08:25:47.638]                   NAME <- NAMES[[kk]]
[08:25:47.638]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.638]                     next
[08:25:47.638]                   args[[name]] <- ""
[08:25:47.638]                 }
[08:25:47.638]                 NAMES <- toupper(removed)
[08:25:47.638]                 for (kk in seq_along(NAMES)) {
[08:25:47.638]                   name <- removed[[kk]]
[08:25:47.638]                   NAME <- NAMES[[kk]]
[08:25:47.638]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.638]                     next
[08:25:47.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.638]                 }
[08:25:47.638]                 if (length(args) > 0) 
[08:25:47.638]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.638]             }
[08:25:47.638]             else {
[08:25:47.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.638]             }
[08:25:47.638]             {
[08:25:47.638]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.638]                   0L) {
[08:25:47.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.638]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.638]                   base::options(opts)
[08:25:47.638]                 }
[08:25:47.638]                 {
[08:25:47.638]                   {
[08:25:47.638]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.638]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.638]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.638]                       inherits = FALSE)
[08:25:47.638]                     NULL
[08:25:47.638]                   }
[08:25:47.638]                   options(future.plan = NULL)
[08:25:47.638]                   if (is.na(NA_character_)) 
[08:25:47.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.638]                     .init = FALSE)
[08:25:47.638]                 }
[08:25:47.638]             }
[08:25:47.638]         }
[08:25:47.638]     })
[08:25:47.638]     if (TRUE) {
[08:25:47.638]         base::sink(type = "output", split = FALSE)
[08:25:47.638]         if (TRUE) {
[08:25:47.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.638]         }
[08:25:47.638]         else {
[08:25:47.638]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.638]         }
[08:25:47.638]         base::close(...future.stdout)
[08:25:47.638]         ...future.stdout <- NULL
[08:25:47.638]     }
[08:25:47.638]     ...future.result$conditions <- ...future.conditions
[08:25:47.638]     ...future.result$finished <- base::Sys.time()
[08:25:47.638]     ...future.result
[08:25:47.638] }
[08:25:47.640] assign_globals() ...
[08:25:47.640] List of 5
[08:25:47.640]  $ ...future.FUN            :function (C, k)  
[08:25:47.640]  $ MoreArgs                 : list()
[08:25:47.640]  $ ...future.elements_ii    :List of 2
[08:25:47.640]   ..$ :List of 5
[08:25:47.640]   .. ..$ : chr "A"
[08:25:47.640]   .. ..$ : chr "B"
[08:25:47.640]   .. ..$ : chr "C"
[08:25:47.640]   .. ..$ : chr "D"
[08:25:47.640]   .. ..$ : chr "E"
[08:25:47.640]   ..$ :List of 5
[08:25:47.640]   .. ..$ : int 5
[08:25:47.640]   .. ..$ : int 4
[08:25:47.640]   .. ..$ : int 3
[08:25:47.640]   .. ..$ : int 2
[08:25:47.640]   .. ..$ : int 1
[08:25:47.640]  $ ...future.seeds_ii       : NULL
[08:25:47.640]  $ ...future.globals.maxSize: NULL
[08:25:47.640]  - attr(*, "where")=List of 5
[08:25:47.640]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.640]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.640]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.640]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.640]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.640]  - attr(*, "resolved")= logi FALSE
[08:25:47.640]  - attr(*, "total_size")= num 967
[08:25:47.640]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.640]  - attr(*, "already-done")= logi TRUE
[08:25:47.649] - reassign environment for ‘...future.FUN’
[08:25:47.649] - copied ‘...future.FUN’ to environment
[08:25:47.649] - copied ‘MoreArgs’ to environment
[08:25:47.650] - copied ‘...future.elements_ii’ to environment
[08:25:47.650] - copied ‘...future.seeds_ii’ to environment
[08:25:47.650] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.650] assign_globals() ... done
[08:25:47.650] plan(): Setting new future strategy stack:
[08:25:47.650] List of future strategies:
[08:25:47.650] 1. sequential:
[08:25:47.650]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.650]    - tweaked: FALSE
[08:25:47.650]    - call: NULL
[08:25:47.651] plan(): nbrOfWorkers() = 1
[08:25:47.652] plan(): Setting new future strategy stack:
[08:25:47.652] List of future strategies:
[08:25:47.652] 1. sequential:
[08:25:47.652]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.652]    - tweaked: FALSE
[08:25:47.652]    - call: plan(strategy)
[08:25:47.652] plan(): nbrOfWorkers() = 1
[08:25:47.652] SequentialFuture started (and completed)
[08:25:47.652] - Launch lazy future ... done
[08:25:47.653] run() for ‘SequentialFuture’ ... done
[08:25:47.653] Created future:
[08:25:47.653] SequentialFuture:
[08:25:47.653] Label: ‘future_.mapply-1’
[08:25:47.653] Expression:
[08:25:47.653] {
[08:25:47.653]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.653]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.653]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.653]         on.exit(options(oopts), add = TRUE)
[08:25:47.653]     }
[08:25:47.653]     {
[08:25:47.653]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.653]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.653]         do.call(mapply, args = args)
[08:25:47.653]     }
[08:25:47.653] }
[08:25:47.653] Lazy evaluation: FALSE
[08:25:47.653] Asynchronous evaluation: FALSE
[08:25:47.653] Local evaluation: TRUE
[08:25:47.653] Environment: R_GlobalEnv
[08:25:47.653] Capture standard output: TRUE
[08:25:47.653] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.653] Globals: 5 objects totaling 967 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.653] Packages: <none>
[08:25:47.653] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.653] Resolved: TRUE
[08:25:47.653] Value: 126 bytes of class ‘list’
[08:25:47.653] Early signaling: FALSE
[08:25:47.653] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.653] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.654] Chunk #1 of 1 ... DONE
[08:25:47.654] Launching 1 futures (chunks) ... DONE
[08:25:47.654] Resolving 1 futures (chunks) ...
[08:25:47.654] resolve() on list ...
[08:25:47.654]  recursive: 0
[08:25:47.654]  length: 1
[08:25:47.654] 
[08:25:47.654] resolved() for ‘SequentialFuture’ ...
[08:25:47.654] - state: ‘finished’
[08:25:47.655] - run: TRUE
[08:25:47.655] - result: ‘FutureResult’
[08:25:47.655] resolved() for ‘SequentialFuture’ ... done
[08:25:47.655] Future #1
[08:25:47.655] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.655] - nx: 1
[08:25:47.655] - relay: TRUE
[08:25:47.655] - stdout: TRUE
[08:25:47.655] - signal: TRUE
[08:25:47.655] - resignal: FALSE
[08:25:47.655] - force: TRUE
[08:25:47.656] - relayed: [n=1] FALSE
[08:25:47.656] - queued futures: [n=1] FALSE
[08:25:47.656]  - until=1
[08:25:47.656]  - relaying element #1
[08:25:47.656] - relayed: [n=1] TRUE
[08:25:47.656] - queued futures: [n=1] TRUE
[08:25:47.656] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.656]  length: 0 (resolved future 1)
[08:25:47.656] Relaying remaining futures
[08:25:47.656] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.657] - nx: 1
[08:25:47.657] - relay: TRUE
[08:25:47.657] - stdout: TRUE
[08:25:47.657] - signal: TRUE
[08:25:47.657] - resignal: FALSE
[08:25:47.657] - force: TRUE
[08:25:47.657] - relayed: [n=1] TRUE
[08:25:47.657] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.657] - relayed: [n=1] TRUE
[08:25:47.657] - queued futures: [n=1] TRUE
[08:25:47.657] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.657] resolve() on list ... DONE
[08:25:47.658]  - Number of value chunks collected: 1
[08:25:47.658] Resolving 1 futures (chunks) ... DONE
[08:25:47.658] Reducing values from 1 chunks ...
[08:25:47.658]  - Number of values collected after concatenation: 5
[08:25:47.658]  - Number of values expected: 5
[08:25:47.658] Reducing values from 1 chunks ... DONE
[08:25:47.658] future_mapply() ... DONE
[08:25:47.658] future_mapply() ...
[08:25:47.659] Number of chunks: 2
[08:25:47.659] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[08:25:47.659] getGlobalsAndPackagesXApply() ...
[08:25:47.659]  - future.globals: TRUE
[08:25:47.659] getGlobalsAndPackages() ...
[08:25:47.659] Searching for globals...
[08:25:47.661] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:47.661] Searching for globals ... DONE
[08:25:47.661] Resolving globals: FALSE
[08:25:47.661] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:47.662] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:47.662] - globals: [1] ‘FUN’
[08:25:47.662] 
[08:25:47.662] getGlobalsAndPackages() ... DONE
[08:25:47.662]  - globals found/used: [n=1] ‘FUN’
[08:25:47.662]  - needed namespaces: [n=0] 
[08:25:47.662] Finding globals ... DONE
[08:25:47.662] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.662] List of 2
[08:25:47.662]  $ ...future.FUN:function (C, k)  
[08:25:47.662]  $ MoreArgs     : NULL
[08:25:47.662]  - attr(*, "where")=List of 2
[08:25:47.662]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.662]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.662]  - attr(*, "resolved")= logi FALSE
[08:25:47.662]  - attr(*, "total_size")= num NA
[08:25:47.665] Packages to be attached in all futures: [n=0] 
[08:25:47.665] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.665] Number of futures (= number of chunks): 2
[08:25:47.665] Launching 2 futures (chunks) ...
[08:25:47.665] Chunk #1 of 2 ...
[08:25:47.666]  - Finding globals in '...' for chunk #1 ...
[08:25:47.666] getGlobalsAndPackages() ...
[08:25:47.666] Searching for globals...
[08:25:47.666] 
[08:25:47.666] Searching for globals ... DONE
[08:25:47.666] - globals: [0] <none>
[08:25:47.666] getGlobalsAndPackages() ... DONE
[08:25:47.666]    + additional globals found: [n=0] 
[08:25:47.667]    + additional namespaces needed: [n=0] 
[08:25:47.667]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.667]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:47.667]  - seeds: <none>
[08:25:47.667]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.667] getGlobalsAndPackages() ...
[08:25:47.667] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.667] Resolving globals: FALSE
[08:25:47.668] The total size of the 5 globals is 876 bytes (876 bytes)
[08:25:47.668] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.668] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.668] 
[08:25:47.668] getGlobalsAndPackages() ... DONE
[08:25:47.669] run() for ‘Future’ ...
[08:25:47.669] - state: ‘created’
[08:25:47.669] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.669] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.670] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.670]   - Field: ‘label’
[08:25:47.670]   - Field: ‘local’
[08:25:47.670]   - Field: ‘owner’
[08:25:47.670]   - Field: ‘envir’
[08:25:47.670]   - Field: ‘packages’
[08:25:47.670]   - Field: ‘gc’
[08:25:47.672]   - Field: ‘conditions’
[08:25:47.672]   - Field: ‘expr’
[08:25:47.672]   - Field: ‘uuid’
[08:25:47.672]   - Field: ‘seed’
[08:25:47.673]   - Field: ‘version’
[08:25:47.673]   - Field: ‘result’
[08:25:47.673]   - Field: ‘asynchronous’
[08:25:47.673]   - Field: ‘calls’
[08:25:47.673]   - Field: ‘globals’
[08:25:47.673]   - Field: ‘stdout’
[08:25:47.673]   - Field: ‘earlySignal’
[08:25:47.673]   - Field: ‘lazy’
[08:25:47.673]   - Field: ‘state’
[08:25:47.674] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.674] - Launch lazy future ...
[08:25:47.674] Packages needed by the future expression (n = 0): <none>
[08:25:47.674] Packages needed by future strategies (n = 0): <none>
[08:25:47.674] {
[08:25:47.674]     {
[08:25:47.674]         {
[08:25:47.674]             ...future.startTime <- base::Sys.time()
[08:25:47.674]             {
[08:25:47.674]                 {
[08:25:47.674]                   {
[08:25:47.674]                     base::local({
[08:25:47.674]                       has_future <- base::requireNamespace("future", 
[08:25:47.674]                         quietly = TRUE)
[08:25:47.674]                       if (has_future) {
[08:25:47.674]                         ns <- base::getNamespace("future")
[08:25:47.674]                         version <- ns[[".package"]][["version"]]
[08:25:47.674]                         if (is.null(version)) 
[08:25:47.674]                           version <- utils::packageVersion("future")
[08:25:47.674]                       }
[08:25:47.674]                       else {
[08:25:47.674]                         version <- NULL
[08:25:47.674]                       }
[08:25:47.674]                       if (!has_future || version < "1.8.0") {
[08:25:47.674]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.674]                           "", base::R.version$version.string), 
[08:25:47.674]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.674]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.674]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.674]                             "release", "version")], collapse = " "), 
[08:25:47.674]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.674]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.674]                           info)
[08:25:47.674]                         info <- base::paste(info, collapse = "; ")
[08:25:47.674]                         if (!has_future) {
[08:25:47.674]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.674]                             info)
[08:25:47.674]                         }
[08:25:47.674]                         else {
[08:25:47.674]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.674]                             info, version)
[08:25:47.674]                         }
[08:25:47.674]                         base::stop(msg)
[08:25:47.674]                       }
[08:25:47.674]                     })
[08:25:47.674]                   }
[08:25:47.674]                   ...future.strategy.old <- future::plan("list")
[08:25:47.674]                   options(future.plan = NULL)
[08:25:47.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.674]                 }
[08:25:47.674]                 ...future.workdir <- getwd()
[08:25:47.674]             }
[08:25:47.674]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.674]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.674]         }
[08:25:47.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.674]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:47.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.674]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.674]             base::names(...future.oldOptions))
[08:25:47.674]     }
[08:25:47.674]     if (FALSE) {
[08:25:47.674]     }
[08:25:47.674]     else {
[08:25:47.674]         if (TRUE) {
[08:25:47.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.674]                 open = "w")
[08:25:47.674]         }
[08:25:47.674]         else {
[08:25:47.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.674]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.674]         }
[08:25:47.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.674]             base::sink(type = "output", split = FALSE)
[08:25:47.674]             base::close(...future.stdout)
[08:25:47.674]         }, add = TRUE)
[08:25:47.674]     }
[08:25:47.674]     ...future.frame <- base::sys.nframe()
[08:25:47.674]     ...future.conditions <- base::list()
[08:25:47.674]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.674]     if (FALSE) {
[08:25:47.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.674]     }
[08:25:47.674]     ...future.result <- base::tryCatch({
[08:25:47.674]         base::withCallingHandlers({
[08:25:47.674]             ...future.value <- base::withVisible(base::local({
[08:25:47.674]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.674]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.674]                   ...future.globals.maxSize)) {
[08:25:47.674]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.674]                   on.exit(options(oopts), add = TRUE)
[08:25:47.674]                 }
[08:25:47.674]                 {
[08:25:47.674]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.674]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.674]                     USE.NAMES = FALSE)
[08:25:47.674]                   do.call(mapply, args = args)
[08:25:47.674]                 }
[08:25:47.674]             }))
[08:25:47.674]             future::FutureResult(value = ...future.value$value, 
[08:25:47.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.674]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.674]                     ...future.globalenv.names))
[08:25:47.674]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.674]         }, condition = base::local({
[08:25:47.674]             c <- base::c
[08:25:47.674]             inherits <- base::inherits
[08:25:47.674]             invokeRestart <- base::invokeRestart
[08:25:47.674]             length <- base::length
[08:25:47.674]             list <- base::list
[08:25:47.674]             seq.int <- base::seq.int
[08:25:47.674]             signalCondition <- base::signalCondition
[08:25:47.674]             sys.calls <- base::sys.calls
[08:25:47.674]             `[[` <- base::`[[`
[08:25:47.674]             `+` <- base::`+`
[08:25:47.674]             `<<-` <- base::`<<-`
[08:25:47.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.674]                   3L)]
[08:25:47.674]             }
[08:25:47.674]             function(cond) {
[08:25:47.674]                 is_error <- inherits(cond, "error")
[08:25:47.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.674]                   NULL)
[08:25:47.674]                 if (is_error) {
[08:25:47.674]                   sessionInformation <- function() {
[08:25:47.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.674]                       search = base::search(), system = base::Sys.info())
[08:25:47.674]                   }
[08:25:47.674]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.674]                     cond$call), session = sessionInformation(), 
[08:25:47.674]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.674]                   signalCondition(cond)
[08:25:47.674]                 }
[08:25:47.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.674]                 "immediateCondition"))) {
[08:25:47.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.674]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.674]                   if (TRUE && !signal) {
[08:25:47.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.674]                     {
[08:25:47.674]                       inherits <- base::inherits
[08:25:47.674]                       invokeRestart <- base::invokeRestart
[08:25:47.674]                       is.null <- base::is.null
[08:25:47.674]                       muffled <- FALSE
[08:25:47.674]                       if (inherits(cond, "message")) {
[08:25:47.674]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.674]                         if (muffled) 
[08:25:47.674]                           invokeRestart("muffleMessage")
[08:25:47.674]                       }
[08:25:47.674]                       else if (inherits(cond, "warning")) {
[08:25:47.674]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.674]                         if (muffled) 
[08:25:47.674]                           invokeRestart("muffleWarning")
[08:25:47.674]                       }
[08:25:47.674]                       else if (inherits(cond, "condition")) {
[08:25:47.674]                         if (!is.null(pattern)) {
[08:25:47.674]                           computeRestarts <- base::computeRestarts
[08:25:47.674]                           grepl <- base::grepl
[08:25:47.674]                           restarts <- computeRestarts(cond)
[08:25:47.674]                           for (restart in restarts) {
[08:25:47.674]                             name <- restart$name
[08:25:47.674]                             if (is.null(name)) 
[08:25:47.674]                               next
[08:25:47.674]                             if (!grepl(pattern, name)) 
[08:25:47.674]                               next
[08:25:47.674]                             invokeRestart(restart)
[08:25:47.674]                             muffled <- TRUE
[08:25:47.674]                             break
[08:25:47.674]                           }
[08:25:47.674]                         }
[08:25:47.674]                       }
[08:25:47.674]                       invisible(muffled)
[08:25:47.674]                     }
[08:25:47.674]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.674]                   }
[08:25:47.674]                 }
[08:25:47.674]                 else {
[08:25:47.674]                   if (TRUE) {
[08:25:47.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.674]                     {
[08:25:47.674]                       inherits <- base::inherits
[08:25:47.674]                       invokeRestart <- base::invokeRestart
[08:25:47.674]                       is.null <- base::is.null
[08:25:47.674]                       muffled <- FALSE
[08:25:47.674]                       if (inherits(cond, "message")) {
[08:25:47.674]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.674]                         if (muffled) 
[08:25:47.674]                           invokeRestart("muffleMessage")
[08:25:47.674]                       }
[08:25:47.674]                       else if (inherits(cond, "warning")) {
[08:25:47.674]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.674]                         if (muffled) 
[08:25:47.674]                           invokeRestart("muffleWarning")
[08:25:47.674]                       }
[08:25:47.674]                       else if (inherits(cond, "condition")) {
[08:25:47.674]                         if (!is.null(pattern)) {
[08:25:47.674]                           computeRestarts <- base::computeRestarts
[08:25:47.674]                           grepl <- base::grepl
[08:25:47.674]                           restarts <- computeRestarts(cond)
[08:25:47.674]                           for (restart in restarts) {
[08:25:47.674]                             name <- restart$name
[08:25:47.674]                             if (is.null(name)) 
[08:25:47.674]                               next
[08:25:47.674]                             if (!grepl(pattern, name)) 
[08:25:47.674]                               next
[08:25:47.674]                             invokeRestart(restart)
[08:25:47.674]                             muffled <- TRUE
[08:25:47.674]                             break
[08:25:47.674]                           }
[08:25:47.674]                         }
[08:25:47.674]                       }
[08:25:47.674]                       invisible(muffled)
[08:25:47.674]                     }
[08:25:47.674]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.674]                   }
[08:25:47.674]                 }
[08:25:47.674]             }
[08:25:47.674]         }))
[08:25:47.674]     }, error = function(ex) {
[08:25:47.674]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.674]                 ...future.rng), started = ...future.startTime, 
[08:25:47.674]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.674]             version = "1.8"), class = "FutureResult")
[08:25:47.674]     }, finally = {
[08:25:47.674]         if (!identical(...future.workdir, getwd())) 
[08:25:47.674]             setwd(...future.workdir)
[08:25:47.674]         {
[08:25:47.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.674]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.674]             }
[08:25:47.674]             base::options(...future.oldOptions)
[08:25:47.674]             if (.Platform$OS.type == "windows") {
[08:25:47.674]                 old_names <- names(...future.oldEnvVars)
[08:25:47.674]                 envs <- base::Sys.getenv()
[08:25:47.674]                 names <- names(envs)
[08:25:47.674]                 common <- intersect(names, old_names)
[08:25:47.674]                 added <- setdiff(names, old_names)
[08:25:47.674]                 removed <- setdiff(old_names, names)
[08:25:47.674]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.674]                   envs[common]]
[08:25:47.674]                 NAMES <- toupper(changed)
[08:25:47.674]                 args <- list()
[08:25:47.674]                 for (kk in seq_along(NAMES)) {
[08:25:47.674]                   name <- changed[[kk]]
[08:25:47.674]                   NAME <- NAMES[[kk]]
[08:25:47.674]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.674]                     next
[08:25:47.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.674]                 }
[08:25:47.674]                 NAMES <- toupper(added)
[08:25:47.674]                 for (kk in seq_along(NAMES)) {
[08:25:47.674]                   name <- added[[kk]]
[08:25:47.674]                   NAME <- NAMES[[kk]]
[08:25:47.674]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.674]                     next
[08:25:47.674]                   args[[name]] <- ""
[08:25:47.674]                 }
[08:25:47.674]                 NAMES <- toupper(removed)
[08:25:47.674]                 for (kk in seq_along(NAMES)) {
[08:25:47.674]                   name <- removed[[kk]]
[08:25:47.674]                   NAME <- NAMES[[kk]]
[08:25:47.674]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.674]                     next
[08:25:47.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.674]                 }
[08:25:47.674]                 if (length(args) > 0) 
[08:25:47.674]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.674]             }
[08:25:47.674]             else {
[08:25:47.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.674]             }
[08:25:47.674]             {
[08:25:47.674]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.674]                   0L) {
[08:25:47.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.674]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.674]                   base::options(opts)
[08:25:47.674]                 }
[08:25:47.674]                 {
[08:25:47.674]                   {
[08:25:47.674]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.674]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.674]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.674]                       inherits = FALSE)
[08:25:47.674]                     NULL
[08:25:47.674]                   }
[08:25:47.674]                   options(future.plan = NULL)
[08:25:47.674]                   if (is.na(NA_character_)) 
[08:25:47.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.674]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.674]                     .init = FALSE)
[08:25:47.674]                 }
[08:25:47.674]             }
[08:25:47.674]         }
[08:25:47.674]     })
[08:25:47.674]     if (TRUE) {
[08:25:47.674]         base::sink(type = "output", split = FALSE)
[08:25:47.674]         if (TRUE) {
[08:25:47.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.674]         }
[08:25:47.674]         else {
[08:25:47.674]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.674]         }
[08:25:47.674]         base::close(...future.stdout)
[08:25:47.674]         ...future.stdout <- NULL
[08:25:47.674]     }
[08:25:47.674]     ...future.result$conditions <- ...future.conditions
[08:25:47.674]     ...future.result$finished <- base::Sys.time()
[08:25:47.674]     ...future.result
[08:25:47.674] }
[08:25:47.676] assign_globals() ...
[08:25:47.676] List of 5
[08:25:47.676]  $ ...future.FUN            :function (C, k)  
[08:25:47.676]  $ MoreArgs                 : NULL
[08:25:47.676]  $ ...future.elements_ii    :List of 2
[08:25:47.676]   ..$ :List of 2
[08:25:47.676]   .. ..$ : chr "E"
[08:25:47.676]   .. ..$ : chr "D"
[08:25:47.676]   ..$ :List of 2
[08:25:47.676]   .. ..$ : int 1
[08:25:47.676]   .. ..$ : int 2
[08:25:47.676]  $ ...future.seeds_ii       : NULL
[08:25:47.676]  $ ...future.globals.maxSize: NULL
[08:25:47.676]  - attr(*, "where")=List of 5
[08:25:47.676]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.676]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.676]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.676]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.676]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.676]  - attr(*, "resolved")= logi FALSE
[08:25:47.676]  - attr(*, "total_size")= num 876
[08:25:47.676]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.676]  - attr(*, "already-done")= logi TRUE
[08:25:47.682] - reassign environment for ‘...future.FUN’
[08:25:47.682] - copied ‘...future.FUN’ to environment
[08:25:47.682] - copied ‘MoreArgs’ to environment
[08:25:47.682] - copied ‘...future.elements_ii’ to environment
[08:25:47.683] - copied ‘...future.seeds_ii’ to environment
[08:25:47.683] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.683] assign_globals() ... done
[08:25:47.683] plan(): Setting new future strategy stack:
[08:25:47.683] List of future strategies:
[08:25:47.683] 1. sequential:
[08:25:47.683]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.683]    - tweaked: FALSE
[08:25:47.683]    - call: NULL
[08:25:47.684] plan(): nbrOfWorkers() = 1
[08:25:47.684] plan(): Setting new future strategy stack:
[08:25:47.684] List of future strategies:
[08:25:47.684] 1. sequential:
[08:25:47.684]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.684]    - tweaked: FALSE
[08:25:47.684]    - call: plan(strategy)
[08:25:47.685] plan(): nbrOfWorkers() = 1
[08:25:47.685] SequentialFuture started (and completed)
[08:25:47.685] - Launch lazy future ... done
[08:25:47.685] run() for ‘SequentialFuture’ ... done
[08:25:47.685] Created future:
[08:25:47.686] SequentialFuture:
[08:25:47.686] Label: ‘future_mapply-1’
[08:25:47.686] Expression:
[08:25:47.686] {
[08:25:47.686]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.686]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.686]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.686]         on.exit(options(oopts), add = TRUE)
[08:25:47.686]     }
[08:25:47.686]     {
[08:25:47.686]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.686]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.686]         do.call(mapply, args = args)
[08:25:47.686]     }
[08:25:47.686] }
[08:25:47.686] Lazy evaluation: FALSE
[08:25:47.686] Asynchronous evaluation: FALSE
[08:25:47.686] Local evaluation: TRUE
[08:25:47.686] Environment: R_GlobalEnv
[08:25:47.686] Capture standard output: TRUE
[08:25:47.686] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.686] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.686] Packages: <none>
[08:25:47.686] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.686] Resolved: TRUE
[08:25:47.686] Value: 66 bytes of class ‘list’
[08:25:47.686] Early signaling: FALSE
[08:25:47.686] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.686] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.686] Chunk #1 of 2 ... DONE
[08:25:47.687] Chunk #2 of 2 ...
[08:25:47.687]  - Finding globals in '...' for chunk #2 ...
[08:25:47.687] getGlobalsAndPackages() ...
[08:25:47.687] Searching for globals...
[08:25:47.687] 
[08:25:47.687] Searching for globals ... DONE
[08:25:47.687] - globals: [0] <none>
[08:25:47.687] getGlobalsAndPackages() ... DONE
[08:25:47.688]    + additional globals found: [n=0] 
[08:25:47.688]    + additional namespaces needed: [n=0] 
[08:25:47.688]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:47.688]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:47.688]  - seeds: <none>
[08:25:47.688]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.688] getGlobalsAndPackages() ...
[08:25:47.688] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.688] Resolving globals: FALSE
[08:25:47.689] The total size of the 5 globals is 905 bytes (905 bytes)
[08:25:47.689] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 905 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.689] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.689] 
[08:25:47.690] getGlobalsAndPackages() ... DONE
[08:25:47.690] run() for ‘Future’ ...
[08:25:47.690] - state: ‘created’
[08:25:47.690] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.690] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.691]   - Field: ‘label’
[08:25:47.691]   - Field: ‘local’
[08:25:47.691]   - Field: ‘owner’
[08:25:47.691]   - Field: ‘envir’
[08:25:47.691]   - Field: ‘packages’
[08:25:47.691]   - Field: ‘gc’
[08:25:47.691]   - Field: ‘conditions’
[08:25:47.691]   - Field: ‘expr’
[08:25:47.691]   - Field: ‘uuid’
[08:25:47.691]   - Field: ‘seed’
[08:25:47.692]   - Field: ‘version’
[08:25:47.692]   - Field: ‘result’
[08:25:47.692]   - Field: ‘asynchronous’
[08:25:47.692]   - Field: ‘calls’
[08:25:47.692]   - Field: ‘globals’
[08:25:47.692]   - Field: ‘stdout’
[08:25:47.692]   - Field: ‘earlySignal’
[08:25:47.692]   - Field: ‘lazy’
[08:25:47.692]   - Field: ‘state’
[08:25:47.692] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.692] - Launch lazy future ...
[08:25:47.693] Packages needed by the future expression (n = 0): <none>
[08:25:47.693] Packages needed by future strategies (n = 0): <none>
[08:25:47.693] {
[08:25:47.693]     {
[08:25:47.693]         {
[08:25:47.693]             ...future.startTime <- base::Sys.time()
[08:25:47.693]             {
[08:25:47.693]                 {
[08:25:47.693]                   {
[08:25:47.693]                     base::local({
[08:25:47.693]                       has_future <- base::requireNamespace("future", 
[08:25:47.693]                         quietly = TRUE)
[08:25:47.693]                       if (has_future) {
[08:25:47.693]                         ns <- base::getNamespace("future")
[08:25:47.693]                         version <- ns[[".package"]][["version"]]
[08:25:47.693]                         if (is.null(version)) 
[08:25:47.693]                           version <- utils::packageVersion("future")
[08:25:47.693]                       }
[08:25:47.693]                       else {
[08:25:47.693]                         version <- NULL
[08:25:47.693]                       }
[08:25:47.693]                       if (!has_future || version < "1.8.0") {
[08:25:47.693]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.693]                           "", base::R.version$version.string), 
[08:25:47.693]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.693]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.693]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.693]                             "release", "version")], collapse = " "), 
[08:25:47.693]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.693]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.693]                           info)
[08:25:47.693]                         info <- base::paste(info, collapse = "; ")
[08:25:47.693]                         if (!has_future) {
[08:25:47.693]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.693]                             info)
[08:25:47.693]                         }
[08:25:47.693]                         else {
[08:25:47.693]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.693]                             info, version)
[08:25:47.693]                         }
[08:25:47.693]                         base::stop(msg)
[08:25:47.693]                       }
[08:25:47.693]                     })
[08:25:47.693]                   }
[08:25:47.693]                   ...future.strategy.old <- future::plan("list")
[08:25:47.693]                   options(future.plan = NULL)
[08:25:47.693]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.693]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.693]                 }
[08:25:47.693]                 ...future.workdir <- getwd()
[08:25:47.693]             }
[08:25:47.693]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.693]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.693]         }
[08:25:47.693]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.693]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:47.693]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.693]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.693]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.693]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.693]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.693]             base::names(...future.oldOptions))
[08:25:47.693]     }
[08:25:47.693]     if (FALSE) {
[08:25:47.693]     }
[08:25:47.693]     else {
[08:25:47.693]         if (TRUE) {
[08:25:47.693]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.693]                 open = "w")
[08:25:47.693]         }
[08:25:47.693]         else {
[08:25:47.693]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.693]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.693]         }
[08:25:47.693]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.693]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.693]             base::sink(type = "output", split = FALSE)
[08:25:47.693]             base::close(...future.stdout)
[08:25:47.693]         }, add = TRUE)
[08:25:47.693]     }
[08:25:47.693]     ...future.frame <- base::sys.nframe()
[08:25:47.693]     ...future.conditions <- base::list()
[08:25:47.693]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.693]     if (FALSE) {
[08:25:47.693]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.693]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.693]     }
[08:25:47.693]     ...future.result <- base::tryCatch({
[08:25:47.693]         base::withCallingHandlers({
[08:25:47.693]             ...future.value <- base::withVisible(base::local({
[08:25:47.693]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.693]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.693]                   ...future.globals.maxSize)) {
[08:25:47.693]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.693]                   on.exit(options(oopts), add = TRUE)
[08:25:47.693]                 }
[08:25:47.693]                 {
[08:25:47.693]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.693]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.693]                     USE.NAMES = FALSE)
[08:25:47.693]                   do.call(mapply, args = args)
[08:25:47.693]                 }
[08:25:47.693]             }))
[08:25:47.693]             future::FutureResult(value = ...future.value$value, 
[08:25:47.693]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.693]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.693]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.693]                     ...future.globalenv.names))
[08:25:47.693]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.693]         }, condition = base::local({
[08:25:47.693]             c <- base::c
[08:25:47.693]             inherits <- base::inherits
[08:25:47.693]             invokeRestart <- base::invokeRestart
[08:25:47.693]             length <- base::length
[08:25:47.693]             list <- base::list
[08:25:47.693]             seq.int <- base::seq.int
[08:25:47.693]             signalCondition <- base::signalCondition
[08:25:47.693]             sys.calls <- base::sys.calls
[08:25:47.693]             `[[` <- base::`[[`
[08:25:47.693]             `+` <- base::`+`
[08:25:47.693]             `<<-` <- base::`<<-`
[08:25:47.693]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.693]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.693]                   3L)]
[08:25:47.693]             }
[08:25:47.693]             function(cond) {
[08:25:47.693]                 is_error <- inherits(cond, "error")
[08:25:47.693]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.693]                   NULL)
[08:25:47.693]                 if (is_error) {
[08:25:47.693]                   sessionInformation <- function() {
[08:25:47.693]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.693]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.693]                       search = base::search(), system = base::Sys.info())
[08:25:47.693]                   }
[08:25:47.693]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.693]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.693]                     cond$call), session = sessionInformation(), 
[08:25:47.693]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.693]                   signalCondition(cond)
[08:25:47.693]                 }
[08:25:47.693]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.693]                 "immediateCondition"))) {
[08:25:47.693]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.693]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.693]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.693]                   if (TRUE && !signal) {
[08:25:47.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.693]                     {
[08:25:47.693]                       inherits <- base::inherits
[08:25:47.693]                       invokeRestart <- base::invokeRestart
[08:25:47.693]                       is.null <- base::is.null
[08:25:47.693]                       muffled <- FALSE
[08:25:47.693]                       if (inherits(cond, "message")) {
[08:25:47.693]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.693]                         if (muffled) 
[08:25:47.693]                           invokeRestart("muffleMessage")
[08:25:47.693]                       }
[08:25:47.693]                       else if (inherits(cond, "warning")) {
[08:25:47.693]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.693]                         if (muffled) 
[08:25:47.693]                           invokeRestart("muffleWarning")
[08:25:47.693]                       }
[08:25:47.693]                       else if (inherits(cond, "condition")) {
[08:25:47.693]                         if (!is.null(pattern)) {
[08:25:47.693]                           computeRestarts <- base::computeRestarts
[08:25:47.693]                           grepl <- base::grepl
[08:25:47.693]                           restarts <- computeRestarts(cond)
[08:25:47.693]                           for (restart in restarts) {
[08:25:47.693]                             name <- restart$name
[08:25:47.693]                             if (is.null(name)) 
[08:25:47.693]                               next
[08:25:47.693]                             if (!grepl(pattern, name)) 
[08:25:47.693]                               next
[08:25:47.693]                             invokeRestart(restart)
[08:25:47.693]                             muffled <- TRUE
[08:25:47.693]                             break
[08:25:47.693]                           }
[08:25:47.693]                         }
[08:25:47.693]                       }
[08:25:47.693]                       invisible(muffled)
[08:25:47.693]                     }
[08:25:47.693]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.693]                   }
[08:25:47.693]                 }
[08:25:47.693]                 else {
[08:25:47.693]                   if (TRUE) {
[08:25:47.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.693]                     {
[08:25:47.693]                       inherits <- base::inherits
[08:25:47.693]                       invokeRestart <- base::invokeRestart
[08:25:47.693]                       is.null <- base::is.null
[08:25:47.693]                       muffled <- FALSE
[08:25:47.693]                       if (inherits(cond, "message")) {
[08:25:47.693]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.693]                         if (muffled) 
[08:25:47.693]                           invokeRestart("muffleMessage")
[08:25:47.693]                       }
[08:25:47.693]                       else if (inherits(cond, "warning")) {
[08:25:47.693]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.693]                         if (muffled) 
[08:25:47.693]                           invokeRestart("muffleWarning")
[08:25:47.693]                       }
[08:25:47.693]                       else if (inherits(cond, "condition")) {
[08:25:47.693]                         if (!is.null(pattern)) {
[08:25:47.693]                           computeRestarts <- base::computeRestarts
[08:25:47.693]                           grepl <- base::grepl
[08:25:47.693]                           restarts <- computeRestarts(cond)
[08:25:47.693]                           for (restart in restarts) {
[08:25:47.693]                             name <- restart$name
[08:25:47.693]                             if (is.null(name)) 
[08:25:47.693]                               next
[08:25:47.693]                             if (!grepl(pattern, name)) 
[08:25:47.693]                               next
[08:25:47.693]                             invokeRestart(restart)
[08:25:47.693]                             muffled <- TRUE
[08:25:47.693]                             break
[08:25:47.693]                           }
[08:25:47.693]                         }
[08:25:47.693]                       }
[08:25:47.693]                       invisible(muffled)
[08:25:47.693]                     }
[08:25:47.693]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.693]                   }
[08:25:47.693]                 }
[08:25:47.693]             }
[08:25:47.693]         }))
[08:25:47.693]     }, error = function(ex) {
[08:25:47.693]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.693]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.693]                 ...future.rng), started = ...future.startTime, 
[08:25:47.693]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.693]             version = "1.8"), class = "FutureResult")
[08:25:47.693]     }, finally = {
[08:25:47.693]         if (!identical(...future.workdir, getwd())) 
[08:25:47.693]             setwd(...future.workdir)
[08:25:47.693]         {
[08:25:47.693]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.693]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.693]             }
[08:25:47.693]             base::options(...future.oldOptions)
[08:25:47.693]             if (.Platform$OS.type == "windows") {
[08:25:47.693]                 old_names <- names(...future.oldEnvVars)
[08:25:47.693]                 envs <- base::Sys.getenv()
[08:25:47.693]                 names <- names(envs)
[08:25:47.693]                 common <- intersect(names, old_names)
[08:25:47.693]                 added <- setdiff(names, old_names)
[08:25:47.693]                 removed <- setdiff(old_names, names)
[08:25:47.693]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.693]                   envs[common]]
[08:25:47.693]                 NAMES <- toupper(changed)
[08:25:47.693]                 args <- list()
[08:25:47.693]                 for (kk in seq_along(NAMES)) {
[08:25:47.693]                   name <- changed[[kk]]
[08:25:47.693]                   NAME <- NAMES[[kk]]
[08:25:47.693]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.693]                     next
[08:25:47.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.693]                 }
[08:25:47.693]                 NAMES <- toupper(added)
[08:25:47.693]                 for (kk in seq_along(NAMES)) {
[08:25:47.693]                   name <- added[[kk]]
[08:25:47.693]                   NAME <- NAMES[[kk]]
[08:25:47.693]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.693]                     next
[08:25:47.693]                   args[[name]] <- ""
[08:25:47.693]                 }
[08:25:47.693]                 NAMES <- toupper(removed)
[08:25:47.693]                 for (kk in seq_along(NAMES)) {
[08:25:47.693]                   name <- removed[[kk]]
[08:25:47.693]                   NAME <- NAMES[[kk]]
[08:25:47.693]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.693]                     next
[08:25:47.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.693]                 }
[08:25:47.693]                 if (length(args) > 0) 
[08:25:47.693]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.693]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.693]             }
[08:25:47.693]             else {
[08:25:47.693]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.693]             }
[08:25:47.693]             {
[08:25:47.693]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.693]                   0L) {
[08:25:47.693]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.693]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.693]                   base::options(opts)
[08:25:47.693]                 }
[08:25:47.693]                 {
[08:25:47.693]                   {
[08:25:47.693]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.693]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.693]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.693]                       inherits = FALSE)
[08:25:47.693]                     NULL
[08:25:47.693]                   }
[08:25:47.693]                   options(future.plan = NULL)
[08:25:47.693]                   if (is.na(NA_character_)) 
[08:25:47.693]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.693]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.693]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.693]                     .init = FALSE)
[08:25:47.693]                 }
[08:25:47.693]             }
[08:25:47.693]         }
[08:25:47.693]     })
[08:25:47.693]     if (TRUE) {
[08:25:47.693]         base::sink(type = "output", split = FALSE)
[08:25:47.693]         if (TRUE) {
[08:25:47.693]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.693]         }
[08:25:47.693]         else {
[08:25:47.693]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.693]         }
[08:25:47.693]         base::close(...future.stdout)
[08:25:47.693]         ...future.stdout <- NULL
[08:25:47.693]     }
[08:25:47.693]     ...future.result$conditions <- ...future.conditions
[08:25:47.693]     ...future.result$finished <- base::Sys.time()
[08:25:47.693]     ...future.result
[08:25:47.693] }
[08:25:47.695] assign_globals() ...
[08:25:47.695] List of 5
[08:25:47.695]  $ ...future.FUN            :function (C, k)  
[08:25:47.695]  $ MoreArgs                 : NULL
[08:25:47.695]  $ ...future.elements_ii    :List of 2
[08:25:47.695]   ..$ :List of 3
[08:25:47.695]   .. ..$ : chr "C"
[08:25:47.695]   .. ..$ : chr "B"
[08:25:47.695]   .. ..$ : chr "A"
[08:25:47.695]   ..$ :List of 3
[08:25:47.695]   .. ..$ : int 3
[08:25:47.695]   .. ..$ : int 4
[08:25:47.695]   .. ..$ : int 5
[08:25:47.695]  $ ...future.seeds_ii       : NULL
[08:25:47.695]  $ ...future.globals.maxSize: NULL
[08:25:47.695]  - attr(*, "where")=List of 5
[08:25:47.695]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.695]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.695]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.695]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.695]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.695]  - attr(*, "resolved")= logi FALSE
[08:25:47.695]  - attr(*, "total_size")= num 905
[08:25:47.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.695]  - attr(*, "already-done")= logi TRUE
[08:25:47.704] - reassign environment for ‘...future.FUN’
[08:25:47.704] - copied ‘...future.FUN’ to environment
[08:25:47.704] - copied ‘MoreArgs’ to environment
[08:25:47.704] - copied ‘...future.elements_ii’ to environment
[08:25:47.704] - copied ‘...future.seeds_ii’ to environment
[08:25:47.704] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.704] assign_globals() ... done
[08:25:47.705] plan(): Setting new future strategy stack:
[08:25:47.705] List of future strategies:
[08:25:47.705] 1. sequential:
[08:25:47.705]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.705]    - tweaked: FALSE
[08:25:47.705]    - call: NULL
[08:25:47.705] plan(): nbrOfWorkers() = 1
[08:25:47.706] plan(): Setting new future strategy stack:
[08:25:47.706] List of future strategies:
[08:25:47.706] 1. sequential:
[08:25:47.706]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.706]    - tweaked: FALSE
[08:25:47.706]    - call: plan(strategy)
[08:25:47.707] plan(): nbrOfWorkers() = 1
[08:25:47.707] SequentialFuture started (and completed)
[08:25:47.707] - Launch lazy future ... done
[08:25:47.707] run() for ‘SequentialFuture’ ... done
[08:25:47.707] Created future:
[08:25:47.707] SequentialFuture:
[08:25:47.707] Label: ‘future_mapply-2’
[08:25:47.707] Expression:
[08:25:47.707] {
[08:25:47.707]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.707]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.707]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.707]         on.exit(options(oopts), add = TRUE)
[08:25:47.707]     }
[08:25:47.707]     {
[08:25:47.707]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.707]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.707]         do.call(mapply, args = args)
[08:25:47.707]     }
[08:25:47.707] }
[08:25:47.707] Lazy evaluation: FALSE
[08:25:47.707] Asynchronous evaluation: FALSE
[08:25:47.707] Local evaluation: TRUE
[08:25:47.707] Environment: R_GlobalEnv
[08:25:47.707] Capture standard output: TRUE
[08:25:47.707] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.707] Globals: 5 objects totaling 905 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.707] Packages: <none>
[08:25:47.707] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.707] Resolved: TRUE
[08:25:47.707] Value: 91 bytes of class ‘list’
[08:25:47.707] Early signaling: FALSE
[08:25:47.707] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.707] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.708] Chunk #2 of 2 ... DONE
[08:25:47.708] Launching 2 futures (chunks) ... DONE
[08:25:47.708] Resolving 2 futures (chunks) ...
[08:25:47.708] resolve() on list ...
[08:25:47.709]  recursive: 0
[08:25:47.709]  length: 2
[08:25:47.709] 
[08:25:47.709] resolved() for ‘SequentialFuture’ ...
[08:25:47.709] - state: ‘finished’
[08:25:47.709] - run: TRUE
[08:25:47.709] - result: ‘FutureResult’
[08:25:47.709] resolved() for ‘SequentialFuture’ ... done
[08:25:47.709] Future #1
[08:25:47.709] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.710] - nx: 2
[08:25:47.710] - relay: TRUE
[08:25:47.710] - stdout: TRUE
[08:25:47.710] - signal: TRUE
[08:25:47.710] - resignal: FALSE
[08:25:47.710] - force: TRUE
[08:25:47.710] - relayed: [n=2] FALSE, FALSE
[08:25:47.710] - queued futures: [n=2] FALSE, FALSE
[08:25:47.710]  - until=1
[08:25:47.710]  - relaying element #1
[08:25:47.711] - relayed: [n=2] TRUE, FALSE
[08:25:47.711] - queued futures: [n=2] TRUE, FALSE
[08:25:47.711] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.711]  length: 1 (resolved future 1)
[08:25:47.711] resolved() for ‘SequentialFuture’ ...
[08:25:47.711] - state: ‘finished’
[08:25:47.711] - run: TRUE
[08:25:47.711] - result: ‘FutureResult’
[08:25:47.711] resolved() for ‘SequentialFuture’ ... done
[08:25:47.711] Future #2
[08:25:47.712] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:25:47.712] - nx: 2
[08:25:47.712] - relay: TRUE
[08:25:47.712] - stdout: TRUE
[08:25:47.712] - signal: TRUE
[08:25:47.712] - resignal: FALSE
[08:25:47.712] - force: TRUE
[08:25:47.712] - relayed: [n=2] TRUE, FALSE
[08:25:47.712] - queued futures: [n=2] TRUE, FALSE
[08:25:47.712]  - until=2
[08:25:47.712]  - relaying element #2
[08:25:47.713] - relayed: [n=2] TRUE, TRUE
[08:25:47.713] - queued futures: [n=2] TRUE, TRUE
[08:25:47.713] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:25:47.713]  length: 0 (resolved future 2)
[08:25:47.713] Relaying remaining futures
[08:25:47.713] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.713] - nx: 2
[08:25:47.713] - relay: TRUE
[08:25:47.713] - stdout: TRUE
[08:25:47.713] - signal: TRUE
[08:25:47.713] - resignal: FALSE
[08:25:47.714] - force: TRUE
[08:25:47.714] - relayed: [n=2] TRUE, TRUE
[08:25:47.714] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:47.714] - relayed: [n=2] TRUE, TRUE
[08:25:47.714] - queued futures: [n=2] TRUE, TRUE
[08:25:47.714] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.714] resolve() on list ... DONE
[08:25:47.714]  - Number of value chunks collected: 2
[08:25:47.714] Resolving 2 futures (chunks) ... DONE
[08:25:47.714] Reducing values from 2 chunks ...
[08:25:47.715]  - Number of values collected after concatenation: 5
[08:25:47.715]  - Number of values expected: 5
[08:25:47.715] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[08:25:47.715] Reducing values from 2 chunks ... DONE
[08:25:47.715] future_mapply() ... DONE
[08:25:47.715] future_mapply() ...
[08:25:47.715] Number of chunks: 1
[08:25:47.716] getGlobalsAndPackagesXApply() ...
[08:25:47.716]  - future.globals: TRUE
[08:25:47.716] getGlobalsAndPackages() ...
[08:25:47.716] Searching for globals...
[08:25:47.717] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:47.717] Searching for globals ... DONE
[08:25:47.717] Resolving globals: FALSE
[08:25:47.718] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:47.718] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:47.718] - globals: [1] ‘FUN’
[08:25:47.718] 
[08:25:47.718] getGlobalsAndPackages() ... DONE
[08:25:47.718]  - globals found/used: [n=1] ‘FUN’
[08:25:47.719]  - needed namespaces: [n=0] 
[08:25:47.719] Finding globals ... DONE
[08:25:47.719] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.719] List of 2
[08:25:47.719]  $ ...future.FUN:function (C, k)  
[08:25:47.719]  $ MoreArgs     : list()
[08:25:47.719]  - attr(*, "where")=List of 2
[08:25:47.719]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.719]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.719]  - attr(*, "resolved")= logi FALSE
[08:25:47.719]  - attr(*, "total_size")= num NA
[08:25:47.721] Packages to be attached in all futures: [n=0] 
[08:25:47.722] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.722] Number of futures (= number of chunks): 1
[08:25:47.722] Launching 1 futures (chunks) ...
[08:25:47.722] Chunk #1 of 1 ...
[08:25:47.722]  - Finding globals in '...' for chunk #1 ...
[08:25:47.722] getGlobalsAndPackages() ...
[08:25:47.722] Searching for globals...
[08:25:47.724] 
[08:25:47.725] Searching for globals ... DONE
[08:25:47.725] - globals: [0] <none>
[08:25:47.725] getGlobalsAndPackages() ... DONE
[08:25:47.725]    + additional globals found: [n=0] 
[08:25:47.725]    + additional namespaces needed: [n=0] 
[08:25:47.725]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.725]  - seeds: <none>
[08:25:47.725]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.726] getGlobalsAndPackages() ...
[08:25:47.726] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.726] Resolving globals: FALSE
[08:25:47.726] The total size of the 5 globals is 967 bytes (967 bytes)
[08:25:47.727] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 967 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (192 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:47.727] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.727] 
[08:25:47.727] getGlobalsAndPackages() ... DONE
[08:25:47.727] run() for ‘Future’ ...
[08:25:47.728] - state: ‘created’
[08:25:47.728] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.728] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.728] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.728]   - Field: ‘label’
[08:25:47.728]   - Field: ‘local’
[08:25:47.728]   - Field: ‘owner’
[08:25:47.729]   - Field: ‘envir’
[08:25:47.729]   - Field: ‘packages’
[08:25:47.729]   - Field: ‘gc’
[08:25:47.729]   - Field: ‘conditions’
[08:25:47.729]   - Field: ‘expr’
[08:25:47.729]   - Field: ‘uuid’
[08:25:47.729]   - Field: ‘seed’
[08:25:47.729]   - Field: ‘version’
[08:25:47.729]   - Field: ‘result’
[08:25:47.729]   - Field: ‘asynchronous’
[08:25:47.729]   - Field: ‘calls’
[08:25:47.730]   - Field: ‘globals’
[08:25:47.730]   - Field: ‘stdout’
[08:25:47.730]   - Field: ‘earlySignal’
[08:25:47.730]   - Field: ‘lazy’
[08:25:47.730]   - Field: ‘state’
[08:25:47.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.730] - Launch lazy future ...
[08:25:47.730] Packages needed by the future expression (n = 0): <none>
[08:25:47.730] Packages needed by future strategies (n = 0): <none>
[08:25:47.731] {
[08:25:47.731]     {
[08:25:47.731]         {
[08:25:47.731]             ...future.startTime <- base::Sys.time()
[08:25:47.731]             {
[08:25:47.731]                 {
[08:25:47.731]                   {
[08:25:47.731]                     base::local({
[08:25:47.731]                       has_future <- base::requireNamespace("future", 
[08:25:47.731]                         quietly = TRUE)
[08:25:47.731]                       if (has_future) {
[08:25:47.731]                         ns <- base::getNamespace("future")
[08:25:47.731]                         version <- ns[[".package"]][["version"]]
[08:25:47.731]                         if (is.null(version)) 
[08:25:47.731]                           version <- utils::packageVersion("future")
[08:25:47.731]                       }
[08:25:47.731]                       else {
[08:25:47.731]                         version <- NULL
[08:25:47.731]                       }
[08:25:47.731]                       if (!has_future || version < "1.8.0") {
[08:25:47.731]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.731]                           "", base::R.version$version.string), 
[08:25:47.731]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.731]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.731]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.731]                             "release", "version")], collapse = " "), 
[08:25:47.731]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.731]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.731]                           info)
[08:25:47.731]                         info <- base::paste(info, collapse = "; ")
[08:25:47.731]                         if (!has_future) {
[08:25:47.731]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.731]                             info)
[08:25:47.731]                         }
[08:25:47.731]                         else {
[08:25:47.731]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.731]                             info, version)
[08:25:47.731]                         }
[08:25:47.731]                         base::stop(msg)
[08:25:47.731]                       }
[08:25:47.731]                     })
[08:25:47.731]                   }
[08:25:47.731]                   ...future.strategy.old <- future::plan("list")
[08:25:47.731]                   options(future.plan = NULL)
[08:25:47.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.731]                 }
[08:25:47.731]                 ...future.workdir <- getwd()
[08:25:47.731]             }
[08:25:47.731]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.731]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.731]         }
[08:25:47.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.731]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.731]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.731]             base::names(...future.oldOptions))
[08:25:47.731]     }
[08:25:47.731]     if (FALSE) {
[08:25:47.731]     }
[08:25:47.731]     else {
[08:25:47.731]         if (TRUE) {
[08:25:47.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.731]                 open = "w")
[08:25:47.731]         }
[08:25:47.731]         else {
[08:25:47.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.731]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.731]         }
[08:25:47.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.731]             base::sink(type = "output", split = FALSE)
[08:25:47.731]             base::close(...future.stdout)
[08:25:47.731]         }, add = TRUE)
[08:25:47.731]     }
[08:25:47.731]     ...future.frame <- base::sys.nframe()
[08:25:47.731]     ...future.conditions <- base::list()
[08:25:47.731]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.731]     if (FALSE) {
[08:25:47.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.731]     }
[08:25:47.731]     ...future.result <- base::tryCatch({
[08:25:47.731]         base::withCallingHandlers({
[08:25:47.731]             ...future.value <- base::withVisible(base::local({
[08:25:47.731]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.731]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.731]                   ...future.globals.maxSize)) {
[08:25:47.731]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.731]                   on.exit(options(oopts), add = TRUE)
[08:25:47.731]                 }
[08:25:47.731]                 {
[08:25:47.731]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.731]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.731]                     USE.NAMES = FALSE)
[08:25:47.731]                   do.call(mapply, args = args)
[08:25:47.731]                 }
[08:25:47.731]             }))
[08:25:47.731]             future::FutureResult(value = ...future.value$value, 
[08:25:47.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.731]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.731]                     ...future.globalenv.names))
[08:25:47.731]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.731]         }, condition = base::local({
[08:25:47.731]             c <- base::c
[08:25:47.731]             inherits <- base::inherits
[08:25:47.731]             invokeRestart <- base::invokeRestart
[08:25:47.731]             length <- base::length
[08:25:47.731]             list <- base::list
[08:25:47.731]             seq.int <- base::seq.int
[08:25:47.731]             signalCondition <- base::signalCondition
[08:25:47.731]             sys.calls <- base::sys.calls
[08:25:47.731]             `[[` <- base::`[[`
[08:25:47.731]             `+` <- base::`+`
[08:25:47.731]             `<<-` <- base::`<<-`
[08:25:47.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.731]                   3L)]
[08:25:47.731]             }
[08:25:47.731]             function(cond) {
[08:25:47.731]                 is_error <- inherits(cond, "error")
[08:25:47.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.731]                   NULL)
[08:25:47.731]                 if (is_error) {
[08:25:47.731]                   sessionInformation <- function() {
[08:25:47.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.731]                       search = base::search(), system = base::Sys.info())
[08:25:47.731]                   }
[08:25:47.731]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.731]                     cond$call), session = sessionInformation(), 
[08:25:47.731]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.731]                   signalCondition(cond)
[08:25:47.731]                 }
[08:25:47.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.731]                 "immediateCondition"))) {
[08:25:47.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.731]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.731]                   if (TRUE && !signal) {
[08:25:47.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.731]                     {
[08:25:47.731]                       inherits <- base::inherits
[08:25:47.731]                       invokeRestart <- base::invokeRestart
[08:25:47.731]                       is.null <- base::is.null
[08:25:47.731]                       muffled <- FALSE
[08:25:47.731]                       if (inherits(cond, "message")) {
[08:25:47.731]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.731]                         if (muffled) 
[08:25:47.731]                           invokeRestart("muffleMessage")
[08:25:47.731]                       }
[08:25:47.731]                       else if (inherits(cond, "warning")) {
[08:25:47.731]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.731]                         if (muffled) 
[08:25:47.731]                           invokeRestart("muffleWarning")
[08:25:47.731]                       }
[08:25:47.731]                       else if (inherits(cond, "condition")) {
[08:25:47.731]                         if (!is.null(pattern)) {
[08:25:47.731]                           computeRestarts <- base::computeRestarts
[08:25:47.731]                           grepl <- base::grepl
[08:25:47.731]                           restarts <- computeRestarts(cond)
[08:25:47.731]                           for (restart in restarts) {
[08:25:47.731]                             name <- restart$name
[08:25:47.731]                             if (is.null(name)) 
[08:25:47.731]                               next
[08:25:47.731]                             if (!grepl(pattern, name)) 
[08:25:47.731]                               next
[08:25:47.731]                             invokeRestart(restart)
[08:25:47.731]                             muffled <- TRUE
[08:25:47.731]                             break
[08:25:47.731]                           }
[08:25:47.731]                         }
[08:25:47.731]                       }
[08:25:47.731]                       invisible(muffled)
[08:25:47.731]                     }
[08:25:47.731]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.731]                   }
[08:25:47.731]                 }
[08:25:47.731]                 else {
[08:25:47.731]                   if (TRUE) {
[08:25:47.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.731]                     {
[08:25:47.731]                       inherits <- base::inherits
[08:25:47.731]                       invokeRestart <- base::invokeRestart
[08:25:47.731]                       is.null <- base::is.null
[08:25:47.731]                       muffled <- FALSE
[08:25:47.731]                       if (inherits(cond, "message")) {
[08:25:47.731]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.731]                         if (muffled) 
[08:25:47.731]                           invokeRestart("muffleMessage")
[08:25:47.731]                       }
[08:25:47.731]                       else if (inherits(cond, "warning")) {
[08:25:47.731]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.731]                         if (muffled) 
[08:25:47.731]                           invokeRestart("muffleWarning")
[08:25:47.731]                       }
[08:25:47.731]                       else if (inherits(cond, "condition")) {
[08:25:47.731]                         if (!is.null(pattern)) {
[08:25:47.731]                           computeRestarts <- base::computeRestarts
[08:25:47.731]                           grepl <- base::grepl
[08:25:47.731]                           restarts <- computeRestarts(cond)
[08:25:47.731]                           for (restart in restarts) {
[08:25:47.731]                             name <- restart$name
[08:25:47.731]                             if (is.null(name)) 
[08:25:47.731]                               next
[08:25:47.731]                             if (!grepl(pattern, name)) 
[08:25:47.731]                               next
[08:25:47.731]                             invokeRestart(restart)
[08:25:47.731]                             muffled <- TRUE
[08:25:47.731]                             break
[08:25:47.731]                           }
[08:25:47.731]                         }
[08:25:47.731]                       }
[08:25:47.731]                       invisible(muffled)
[08:25:47.731]                     }
[08:25:47.731]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.731]                   }
[08:25:47.731]                 }
[08:25:47.731]             }
[08:25:47.731]         }))
[08:25:47.731]     }, error = function(ex) {
[08:25:47.731]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.731]                 ...future.rng), started = ...future.startTime, 
[08:25:47.731]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.731]             version = "1.8"), class = "FutureResult")
[08:25:47.731]     }, finally = {
[08:25:47.731]         if (!identical(...future.workdir, getwd())) 
[08:25:47.731]             setwd(...future.workdir)
[08:25:47.731]         {
[08:25:47.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.731]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.731]             }
[08:25:47.731]             base::options(...future.oldOptions)
[08:25:47.731]             if (.Platform$OS.type == "windows") {
[08:25:47.731]                 old_names <- names(...future.oldEnvVars)
[08:25:47.731]                 envs <- base::Sys.getenv()
[08:25:47.731]                 names <- names(envs)
[08:25:47.731]                 common <- intersect(names, old_names)
[08:25:47.731]                 added <- setdiff(names, old_names)
[08:25:47.731]                 removed <- setdiff(old_names, names)
[08:25:47.731]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.731]                   envs[common]]
[08:25:47.731]                 NAMES <- toupper(changed)
[08:25:47.731]                 args <- list()
[08:25:47.731]                 for (kk in seq_along(NAMES)) {
[08:25:47.731]                   name <- changed[[kk]]
[08:25:47.731]                   NAME <- NAMES[[kk]]
[08:25:47.731]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.731]                     next
[08:25:47.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.731]                 }
[08:25:47.731]                 NAMES <- toupper(added)
[08:25:47.731]                 for (kk in seq_along(NAMES)) {
[08:25:47.731]                   name <- added[[kk]]
[08:25:47.731]                   NAME <- NAMES[[kk]]
[08:25:47.731]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.731]                     next
[08:25:47.731]                   args[[name]] <- ""
[08:25:47.731]                 }
[08:25:47.731]                 NAMES <- toupper(removed)
[08:25:47.731]                 for (kk in seq_along(NAMES)) {
[08:25:47.731]                   name <- removed[[kk]]
[08:25:47.731]                   NAME <- NAMES[[kk]]
[08:25:47.731]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.731]                     next
[08:25:47.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.731]                 }
[08:25:47.731]                 if (length(args) > 0) 
[08:25:47.731]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.731]             }
[08:25:47.731]             else {
[08:25:47.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.731]             }
[08:25:47.731]             {
[08:25:47.731]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.731]                   0L) {
[08:25:47.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.731]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.731]                   base::options(opts)
[08:25:47.731]                 }
[08:25:47.731]                 {
[08:25:47.731]                   {
[08:25:47.731]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.731]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.731]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.731]                       inherits = FALSE)
[08:25:47.731]                     NULL
[08:25:47.731]                   }
[08:25:47.731]                   options(future.plan = NULL)
[08:25:47.731]                   if (is.na(NA_character_)) 
[08:25:47.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.731]                     .init = FALSE)
[08:25:47.731]                 }
[08:25:47.731]             }
[08:25:47.731]         }
[08:25:47.731]     })
[08:25:47.731]     if (TRUE) {
[08:25:47.731]         base::sink(type = "output", split = FALSE)
[08:25:47.731]         if (TRUE) {
[08:25:47.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.731]         }
[08:25:47.731]         else {
[08:25:47.731]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.731]         }
[08:25:47.731]         base::close(...future.stdout)
[08:25:47.731]         ...future.stdout <- NULL
[08:25:47.731]     }
[08:25:47.731]     ...future.result$conditions <- ...future.conditions
[08:25:47.731]     ...future.result$finished <- base::Sys.time()
[08:25:47.731]     ...future.result
[08:25:47.731] }
[08:25:47.733] assign_globals() ...
[08:25:47.733] List of 5
[08:25:47.733]  $ ...future.FUN            :function (C, k)  
[08:25:47.733]  $ MoreArgs                 : list()
[08:25:47.733]  $ ...future.elements_ii    :List of 2
[08:25:47.733]   ..$ :List of 5
[08:25:47.733]   .. ..$ : chr "A"
[08:25:47.733]   .. ..$ : chr "B"
[08:25:47.733]   .. ..$ : chr "C"
[08:25:47.733]   .. ..$ : chr "D"
[08:25:47.733]   .. ..$ : chr "E"
[08:25:47.733]   ..$ :List of 5
[08:25:47.733]   .. ..$ : int 5
[08:25:47.733]   .. ..$ : int 4
[08:25:47.733]   .. ..$ : int 3
[08:25:47.733]   .. ..$ : int 2
[08:25:47.733]   .. ..$ : int 1
[08:25:47.733]  $ ...future.seeds_ii       : NULL
[08:25:47.733]  $ ...future.globals.maxSize: NULL
[08:25:47.733]  - attr(*, "where")=List of 5
[08:25:47.733]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.733]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.733]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.733]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.733]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.733]  - attr(*, "resolved")= logi FALSE
[08:25:47.733]  - attr(*, "total_size")= num 967
[08:25:47.733]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.733]  - attr(*, "already-done")= logi TRUE
[08:25:47.740] - reassign environment for ‘...future.FUN’
[08:25:47.740] - copied ‘...future.FUN’ to environment
[08:25:47.740] - copied ‘MoreArgs’ to environment
[08:25:47.740] - copied ‘...future.elements_ii’ to environment
[08:25:47.740] - copied ‘...future.seeds_ii’ to environment
[08:25:47.740] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.741] assign_globals() ... done
[08:25:47.741] plan(): Setting new future strategy stack:
[08:25:47.741] List of future strategies:
[08:25:47.741] 1. sequential:
[08:25:47.741]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.741]    - tweaked: FALSE
[08:25:47.741]    - call: NULL
[08:25:47.741] plan(): nbrOfWorkers() = 1
[08:25:47.742] plan(): Setting new future strategy stack:
[08:25:47.742] List of future strategies:
[08:25:47.742] 1. sequential:
[08:25:47.742]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.742]    - tweaked: FALSE
[08:25:47.742]    - call: plan(strategy)
[08:25:47.743] plan(): nbrOfWorkers() = 1
[08:25:47.743] SequentialFuture started (and completed)
[08:25:47.743] - Launch lazy future ... done
[08:25:47.743] run() for ‘SequentialFuture’ ... done
[08:25:47.743] Created future:
[08:25:47.743] SequentialFuture:
[08:25:47.743] Label: ‘future_.mapply-1’
[08:25:47.743] Expression:
[08:25:47.743] {
[08:25:47.743]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.743]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.743]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.743]         on.exit(options(oopts), add = TRUE)
[08:25:47.743]     }
[08:25:47.743]     {
[08:25:47.743]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.743]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.743]         do.call(mapply, args = args)
[08:25:47.743]     }
[08:25:47.743] }
[08:25:47.743] Lazy evaluation: FALSE
[08:25:47.743] Asynchronous evaluation: FALSE
[08:25:47.743] Local evaluation: TRUE
[08:25:47.743] Environment: R_GlobalEnv
[08:25:47.743] Capture standard output: TRUE
[08:25:47.743] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.743] Globals: 5 objects totaling 967 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.743] Packages: <none>
[08:25:47.743] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.743] Resolved: TRUE
[08:25:47.743] Value: 126 bytes of class ‘list’
[08:25:47.743] Early signaling: FALSE
[08:25:47.743] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.743] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.744] Chunk #1 of 1 ... DONE
[08:25:47.744] Launching 1 futures (chunks) ... DONE
[08:25:47.744] Resolving 1 futures (chunks) ...
[08:25:47.744] resolve() on list ...
[08:25:47.745]  recursive: 0
[08:25:47.745]  length: 1
[08:25:47.745] 
[08:25:47.745] resolved() for ‘SequentialFuture’ ...
[08:25:47.745] - state: ‘finished’
[08:25:47.745] - run: TRUE
[08:25:47.745] - result: ‘FutureResult’
[08:25:47.745] resolved() for ‘SequentialFuture’ ... done
[08:25:47.745] Future #1
[08:25:47.745] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.745] - nx: 1
[08:25:47.746] - relay: TRUE
[08:25:47.746] - stdout: TRUE
[08:25:47.746] - signal: TRUE
[08:25:47.746] - resignal: FALSE
[08:25:47.746] - force: TRUE
[08:25:47.746] - relayed: [n=1] FALSE
[08:25:47.746] - queued futures: [n=1] FALSE
[08:25:47.746]  - until=1
[08:25:47.746]  - relaying element #1
[08:25:47.746] - relayed: [n=1] TRUE
[08:25:47.747] - queued futures: [n=1] TRUE
[08:25:47.747] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.747]  length: 0 (resolved future 1)
[08:25:47.747] Relaying remaining futures
[08:25:47.747] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.747] - nx: 1
[08:25:47.747] - relay: TRUE
[08:25:47.747] - stdout: TRUE
[08:25:47.747] - signal: TRUE
[08:25:47.747] - resignal: FALSE
[08:25:47.747] - force: TRUE
[08:25:47.747] - relayed: [n=1] TRUE
[08:25:47.748] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.748] - relayed: [n=1] TRUE
[08:25:47.748] - queued futures: [n=1] TRUE
[08:25:47.748] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.748] resolve() on list ... DONE
[08:25:47.750]  - Number of value chunks collected: 1
[08:25:47.750] Resolving 1 futures (chunks) ... DONE
[08:25:47.750] Reducing values from 1 chunks ...
[08:25:47.750]  - Number of values collected after concatenation: 5
[08:25:47.750]  - Number of values expected: 5
[08:25:47.750] Reducing values from 1 chunks ... DONE
[08:25:47.751] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[08:25:47.751] future_mapply() ...
[08:25:47.752] Number of chunks: 1
[08:25:47.752] getGlobalsAndPackagesXApply() ...
[08:25:47.752]  - future.globals: TRUE
[08:25:47.752] getGlobalsAndPackages() ...
[08:25:47.752] Searching for globals...
[08:25:47.753] - globals found: [1] ‘FUN’
[08:25:47.753] Searching for globals ... DONE
[08:25:47.753] Resolving globals: FALSE
[08:25:47.754] The total size of the 1 globals is 185 bytes (185 bytes)
[08:25:47.754] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:25:47.754] - globals: [1] ‘FUN’
[08:25:47.754] 
[08:25:47.754] getGlobalsAndPackages() ... DONE
[08:25:47.754]  - globals found/used: [n=1] ‘FUN’
[08:25:47.754]  - needed namespaces: [n=0] 
[08:25:47.754] Finding globals ... DONE
[08:25:47.755] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.755] List of 2
[08:25:47.755]  $ ...future.FUN:function (x)  
[08:25:47.755]  $ MoreArgs     : NULL
[08:25:47.755]  - attr(*, "where")=List of 2
[08:25:47.755]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.755]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.755]  - attr(*, "resolved")= logi FALSE
[08:25:47.755]  - attr(*, "total_size")= num NA
[08:25:47.757] Packages to be attached in all futures: [n=0] 
[08:25:47.757] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.758] Number of futures (= number of chunks): 1
[08:25:47.758] Launching 1 futures (chunks) ...
[08:25:47.758] Chunk #1 of 1 ...
[08:25:47.758]  - Finding globals in '...' for chunk #1 ...
[08:25:47.758] getGlobalsAndPackages() ...
[08:25:47.758] Searching for globals...
[08:25:47.758] 
[08:25:47.758] Searching for globals ... DONE
[08:25:47.759] - globals: [0] <none>
[08:25:47.759] getGlobalsAndPackages() ... DONE
[08:25:47.759]    + additional globals found: [n=0] 
[08:25:47.759]    + additional namespaces needed: [n=0] 
[08:25:47.759]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.759]  - seeds: <none>
[08:25:47.759]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.759] getGlobalsAndPackages() ...
[08:25:47.759] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.759] Resolving globals: FALSE
[08:25:47.760] The total size of the 5 globals is 366 bytes (366 bytes)
[08:25:47.760] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 366 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.760] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.760] 
[08:25:47.761] getGlobalsAndPackages() ... DONE
[08:25:47.761] run() for ‘Future’ ...
[08:25:47.761] - state: ‘created’
[08:25:47.761] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.761] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.761] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.762]   - Field: ‘label’
[08:25:47.762]   - Field: ‘local’
[08:25:47.762]   - Field: ‘owner’
[08:25:47.762]   - Field: ‘envir’
[08:25:47.762]   - Field: ‘packages’
[08:25:47.762]   - Field: ‘gc’
[08:25:47.762]   - Field: ‘conditions’
[08:25:47.762]   - Field: ‘expr’
[08:25:47.762]   - Field: ‘uuid’
[08:25:47.762]   - Field: ‘seed’
[08:25:47.762]   - Field: ‘version’
[08:25:47.763]   - Field: ‘result’
[08:25:47.763]   - Field: ‘asynchronous’
[08:25:47.763]   - Field: ‘calls’
[08:25:47.763]   - Field: ‘globals’
[08:25:47.763]   - Field: ‘stdout’
[08:25:47.763]   - Field: ‘earlySignal’
[08:25:47.763]   - Field: ‘lazy’
[08:25:47.763]   - Field: ‘state’
[08:25:47.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.763] - Launch lazy future ...
[08:25:47.764] Packages needed by the future expression (n = 0): <none>
[08:25:47.764] Packages needed by future strategies (n = 0): <none>
[08:25:47.764] {
[08:25:47.764]     {
[08:25:47.764]         {
[08:25:47.764]             ...future.startTime <- base::Sys.time()
[08:25:47.764]             {
[08:25:47.764]                 {
[08:25:47.764]                   {
[08:25:47.764]                     base::local({
[08:25:47.764]                       has_future <- base::requireNamespace("future", 
[08:25:47.764]                         quietly = TRUE)
[08:25:47.764]                       if (has_future) {
[08:25:47.764]                         ns <- base::getNamespace("future")
[08:25:47.764]                         version <- ns[[".package"]][["version"]]
[08:25:47.764]                         if (is.null(version)) 
[08:25:47.764]                           version <- utils::packageVersion("future")
[08:25:47.764]                       }
[08:25:47.764]                       else {
[08:25:47.764]                         version <- NULL
[08:25:47.764]                       }
[08:25:47.764]                       if (!has_future || version < "1.8.0") {
[08:25:47.764]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.764]                           "", base::R.version$version.string), 
[08:25:47.764]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.764]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.764]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.764]                             "release", "version")], collapse = " "), 
[08:25:47.764]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.764]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.764]                           info)
[08:25:47.764]                         info <- base::paste(info, collapse = "; ")
[08:25:47.764]                         if (!has_future) {
[08:25:47.764]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.764]                             info)
[08:25:47.764]                         }
[08:25:47.764]                         else {
[08:25:47.764]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.764]                             info, version)
[08:25:47.764]                         }
[08:25:47.764]                         base::stop(msg)
[08:25:47.764]                       }
[08:25:47.764]                     })
[08:25:47.764]                   }
[08:25:47.764]                   ...future.strategy.old <- future::plan("list")
[08:25:47.764]                   options(future.plan = NULL)
[08:25:47.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.764]                 }
[08:25:47.764]                 ...future.workdir <- getwd()
[08:25:47.764]             }
[08:25:47.764]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.764]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.764]         }
[08:25:47.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.764]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.764]             base::names(...future.oldOptions))
[08:25:47.764]     }
[08:25:47.764]     if (FALSE) {
[08:25:47.764]     }
[08:25:47.764]     else {
[08:25:47.764]         if (TRUE) {
[08:25:47.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.764]                 open = "w")
[08:25:47.764]         }
[08:25:47.764]         else {
[08:25:47.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.764]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.764]         }
[08:25:47.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.764]             base::sink(type = "output", split = FALSE)
[08:25:47.764]             base::close(...future.stdout)
[08:25:47.764]         }, add = TRUE)
[08:25:47.764]     }
[08:25:47.764]     ...future.frame <- base::sys.nframe()
[08:25:47.764]     ...future.conditions <- base::list()
[08:25:47.764]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.764]     if (FALSE) {
[08:25:47.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.764]     }
[08:25:47.764]     ...future.result <- base::tryCatch({
[08:25:47.764]         base::withCallingHandlers({
[08:25:47.764]             ...future.value <- base::withVisible(base::local({
[08:25:47.764]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.764]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.764]                   ...future.globals.maxSize)) {
[08:25:47.764]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.764]                   on.exit(options(oopts), add = TRUE)
[08:25:47.764]                 }
[08:25:47.764]                 {
[08:25:47.764]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.764]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.764]                     USE.NAMES = FALSE)
[08:25:47.764]                   do.call(mapply, args = args)
[08:25:47.764]                 }
[08:25:47.764]             }))
[08:25:47.764]             future::FutureResult(value = ...future.value$value, 
[08:25:47.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.764]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.764]                     ...future.globalenv.names))
[08:25:47.764]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.764]         }, condition = base::local({
[08:25:47.764]             c <- base::c
[08:25:47.764]             inherits <- base::inherits
[08:25:47.764]             invokeRestart <- base::invokeRestart
[08:25:47.764]             length <- base::length
[08:25:47.764]             list <- base::list
[08:25:47.764]             seq.int <- base::seq.int
[08:25:47.764]             signalCondition <- base::signalCondition
[08:25:47.764]             sys.calls <- base::sys.calls
[08:25:47.764]             `[[` <- base::`[[`
[08:25:47.764]             `+` <- base::`+`
[08:25:47.764]             `<<-` <- base::`<<-`
[08:25:47.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.764]                   3L)]
[08:25:47.764]             }
[08:25:47.764]             function(cond) {
[08:25:47.764]                 is_error <- inherits(cond, "error")
[08:25:47.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.764]                   NULL)
[08:25:47.764]                 if (is_error) {
[08:25:47.764]                   sessionInformation <- function() {
[08:25:47.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.764]                       search = base::search(), system = base::Sys.info())
[08:25:47.764]                   }
[08:25:47.764]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.764]                     cond$call), session = sessionInformation(), 
[08:25:47.764]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.764]                   signalCondition(cond)
[08:25:47.764]                 }
[08:25:47.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.764]                 "immediateCondition"))) {
[08:25:47.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.764]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.764]                   if (TRUE && !signal) {
[08:25:47.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.764]                     {
[08:25:47.764]                       inherits <- base::inherits
[08:25:47.764]                       invokeRestart <- base::invokeRestart
[08:25:47.764]                       is.null <- base::is.null
[08:25:47.764]                       muffled <- FALSE
[08:25:47.764]                       if (inherits(cond, "message")) {
[08:25:47.764]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.764]                         if (muffled) 
[08:25:47.764]                           invokeRestart("muffleMessage")
[08:25:47.764]                       }
[08:25:47.764]                       else if (inherits(cond, "warning")) {
[08:25:47.764]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.764]                         if (muffled) 
[08:25:47.764]                           invokeRestart("muffleWarning")
[08:25:47.764]                       }
[08:25:47.764]                       else if (inherits(cond, "condition")) {
[08:25:47.764]                         if (!is.null(pattern)) {
[08:25:47.764]                           computeRestarts <- base::computeRestarts
[08:25:47.764]                           grepl <- base::grepl
[08:25:47.764]                           restarts <- computeRestarts(cond)
[08:25:47.764]                           for (restart in restarts) {
[08:25:47.764]                             name <- restart$name
[08:25:47.764]                             if (is.null(name)) 
[08:25:47.764]                               next
[08:25:47.764]                             if (!grepl(pattern, name)) 
[08:25:47.764]                               next
[08:25:47.764]                             invokeRestart(restart)
[08:25:47.764]                             muffled <- TRUE
[08:25:47.764]                             break
[08:25:47.764]                           }
[08:25:47.764]                         }
[08:25:47.764]                       }
[08:25:47.764]                       invisible(muffled)
[08:25:47.764]                     }
[08:25:47.764]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.764]                   }
[08:25:47.764]                 }
[08:25:47.764]                 else {
[08:25:47.764]                   if (TRUE) {
[08:25:47.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.764]                     {
[08:25:47.764]                       inherits <- base::inherits
[08:25:47.764]                       invokeRestart <- base::invokeRestart
[08:25:47.764]                       is.null <- base::is.null
[08:25:47.764]                       muffled <- FALSE
[08:25:47.764]                       if (inherits(cond, "message")) {
[08:25:47.764]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.764]                         if (muffled) 
[08:25:47.764]                           invokeRestart("muffleMessage")
[08:25:47.764]                       }
[08:25:47.764]                       else if (inherits(cond, "warning")) {
[08:25:47.764]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.764]                         if (muffled) 
[08:25:47.764]                           invokeRestart("muffleWarning")
[08:25:47.764]                       }
[08:25:47.764]                       else if (inherits(cond, "condition")) {
[08:25:47.764]                         if (!is.null(pattern)) {
[08:25:47.764]                           computeRestarts <- base::computeRestarts
[08:25:47.764]                           grepl <- base::grepl
[08:25:47.764]                           restarts <- computeRestarts(cond)
[08:25:47.764]                           for (restart in restarts) {
[08:25:47.764]                             name <- restart$name
[08:25:47.764]                             if (is.null(name)) 
[08:25:47.764]                               next
[08:25:47.764]                             if (!grepl(pattern, name)) 
[08:25:47.764]                               next
[08:25:47.764]                             invokeRestart(restart)
[08:25:47.764]                             muffled <- TRUE
[08:25:47.764]                             break
[08:25:47.764]                           }
[08:25:47.764]                         }
[08:25:47.764]                       }
[08:25:47.764]                       invisible(muffled)
[08:25:47.764]                     }
[08:25:47.764]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.764]                   }
[08:25:47.764]                 }
[08:25:47.764]             }
[08:25:47.764]         }))
[08:25:47.764]     }, error = function(ex) {
[08:25:47.764]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.764]                 ...future.rng), started = ...future.startTime, 
[08:25:47.764]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.764]             version = "1.8"), class = "FutureResult")
[08:25:47.764]     }, finally = {
[08:25:47.764]         if (!identical(...future.workdir, getwd())) 
[08:25:47.764]             setwd(...future.workdir)
[08:25:47.764]         {
[08:25:47.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.764]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.764]             }
[08:25:47.764]             base::options(...future.oldOptions)
[08:25:47.764]             if (.Platform$OS.type == "windows") {
[08:25:47.764]                 old_names <- names(...future.oldEnvVars)
[08:25:47.764]                 envs <- base::Sys.getenv()
[08:25:47.764]                 names <- names(envs)
[08:25:47.764]                 common <- intersect(names, old_names)
[08:25:47.764]                 added <- setdiff(names, old_names)
[08:25:47.764]                 removed <- setdiff(old_names, names)
[08:25:47.764]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.764]                   envs[common]]
[08:25:47.764]                 NAMES <- toupper(changed)
[08:25:47.764]                 args <- list()
[08:25:47.764]                 for (kk in seq_along(NAMES)) {
[08:25:47.764]                   name <- changed[[kk]]
[08:25:47.764]                   NAME <- NAMES[[kk]]
[08:25:47.764]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.764]                     next
[08:25:47.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.764]                 }
[08:25:47.764]                 NAMES <- toupper(added)
[08:25:47.764]                 for (kk in seq_along(NAMES)) {
[08:25:47.764]                   name <- added[[kk]]
[08:25:47.764]                   NAME <- NAMES[[kk]]
[08:25:47.764]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.764]                     next
[08:25:47.764]                   args[[name]] <- ""
[08:25:47.764]                 }
[08:25:47.764]                 NAMES <- toupper(removed)
[08:25:47.764]                 for (kk in seq_along(NAMES)) {
[08:25:47.764]                   name <- removed[[kk]]
[08:25:47.764]                   NAME <- NAMES[[kk]]
[08:25:47.764]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.764]                     next
[08:25:47.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.764]                 }
[08:25:47.764]                 if (length(args) > 0) 
[08:25:47.764]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.764]             }
[08:25:47.764]             else {
[08:25:47.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.764]             }
[08:25:47.764]             {
[08:25:47.764]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.764]                   0L) {
[08:25:47.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.764]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.764]                   base::options(opts)
[08:25:47.764]                 }
[08:25:47.764]                 {
[08:25:47.764]                   {
[08:25:47.764]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.764]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.764]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.764]                       inherits = FALSE)
[08:25:47.764]                     NULL
[08:25:47.764]                   }
[08:25:47.764]                   options(future.plan = NULL)
[08:25:47.764]                   if (is.na(NA_character_)) 
[08:25:47.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.764]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.764]                     .init = FALSE)
[08:25:47.764]                 }
[08:25:47.764]             }
[08:25:47.764]         }
[08:25:47.764]     })
[08:25:47.764]     if (TRUE) {
[08:25:47.764]         base::sink(type = "output", split = FALSE)
[08:25:47.764]         if (TRUE) {
[08:25:47.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.764]         }
[08:25:47.764]         else {
[08:25:47.764]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.764]         }
[08:25:47.764]         base::close(...future.stdout)
[08:25:47.764]         ...future.stdout <- NULL
[08:25:47.764]     }
[08:25:47.764]     ...future.result$conditions <- ...future.conditions
[08:25:47.764]     ...future.result$finished <- base::Sys.time()
[08:25:47.764]     ...future.result
[08:25:47.764] }
[08:25:47.766] assign_globals() ...
[08:25:47.766] List of 5
[08:25:47.766]  $ ...future.FUN            :function (x)  
[08:25:47.766]  $ MoreArgs                 : NULL
[08:25:47.766]  $ ...future.elements_ii    :List of 1
[08:25:47.766]   ..$ :List of 1
[08:25:47.766]   .. ..$ : Date[1:1], format: "2018-06-01"
[08:25:47.766]  $ ...future.seeds_ii       : NULL
[08:25:47.766]  $ ...future.globals.maxSize: NULL
[08:25:47.766]  - attr(*, "where")=List of 5
[08:25:47.766]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.766]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.766]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.766]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.766]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.766]  - attr(*, "resolved")= logi FALSE
[08:25:47.766]  - attr(*, "total_size")= num 366
[08:25:47.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.766]  - attr(*, "already-done")= logi TRUE
[08:25:47.771] - copied ‘...future.FUN’ to environment
[08:25:47.771] - copied ‘MoreArgs’ to environment
[08:25:47.771] - copied ‘...future.elements_ii’ to environment
[08:25:47.771] - copied ‘...future.seeds_ii’ to environment
[08:25:47.771] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.771] assign_globals() ... done
[08:25:47.772] plan(): Setting new future strategy stack:
[08:25:47.772] List of future strategies:
[08:25:47.772] 1. sequential:
[08:25:47.772]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.772]    - tweaked: FALSE
[08:25:47.772]    - call: NULL
[08:25:47.772] plan(): nbrOfWorkers() = 1
[08:25:47.773] plan(): Setting new future strategy stack:
[08:25:47.773] List of future strategies:
[08:25:47.773] 1. sequential:
[08:25:47.773]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.773]    - tweaked: FALSE
[08:25:47.773]    - call: plan(strategy)
[08:25:47.773] plan(): nbrOfWorkers() = 1
[08:25:47.774] SequentialFuture started (and completed)
[08:25:47.774] - Launch lazy future ... done
[08:25:47.776] run() for ‘SequentialFuture’ ... done
[08:25:47.776] Created future:
[08:25:47.776] SequentialFuture:
[08:25:47.776] Label: ‘future_mapply-1’
[08:25:47.776] Expression:
[08:25:47.776] {
[08:25:47.776]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.776]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.776]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.776]         on.exit(options(oopts), add = TRUE)
[08:25:47.776]     }
[08:25:47.776]     {
[08:25:47.776]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.776]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.776]         do.call(mapply, args = args)
[08:25:47.776]     }
[08:25:47.776] }
[08:25:47.776] Lazy evaluation: FALSE
[08:25:47.776] Asynchronous evaluation: FALSE
[08:25:47.776] Local evaluation: TRUE
[08:25:47.776] Environment: R_GlobalEnv
[08:25:47.776] Capture standard output: TRUE
[08:25:47.776] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.776] Globals: 5 objects totaling 366 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.776] Packages: <none>
[08:25:47.776] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.776] Resolved: TRUE
[08:25:47.776] Value: 92 bytes of class ‘list’
[08:25:47.776] Early signaling: FALSE
[08:25:47.776] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.776] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.777] Chunk #1 of 1 ... DONE
[08:25:47.777] Launching 1 futures (chunks) ... DONE
[08:25:47.777] Resolving 1 futures (chunks) ...
[08:25:47.777] resolve() on list ...
[08:25:47.777]  recursive: 0
[08:25:47.777]  length: 1
[08:25:47.777] 
[08:25:47.778] resolved() for ‘SequentialFuture’ ...
[08:25:47.778] - state: ‘finished’
[08:25:47.778] - run: TRUE
[08:25:47.778] - result: ‘FutureResult’
[08:25:47.778] resolved() for ‘SequentialFuture’ ... done
[08:25:47.778] Future #1
[08:25:47.778] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.778] - nx: 1
[08:25:47.778] - relay: TRUE
[08:25:47.779] - stdout: TRUE
[08:25:47.779] - signal: TRUE
[08:25:47.779] - resignal: FALSE
[08:25:47.779] - force: TRUE
[08:25:47.779] - relayed: [n=1] FALSE
[08:25:47.779] - queued futures: [n=1] FALSE
[08:25:47.779]  - until=1
[08:25:47.779]  - relaying element #1
[08:25:47.779] - relayed: [n=1] TRUE
[08:25:47.779] - queued futures: [n=1] TRUE
[08:25:47.779] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.780]  length: 0 (resolved future 1)
[08:25:47.780] Relaying remaining futures
[08:25:47.780] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.780] - nx: 1
[08:25:47.780] - relay: TRUE
[08:25:47.780] - stdout: TRUE
[08:25:47.780] - signal: TRUE
[08:25:47.780] - resignal: FALSE
[08:25:47.780] - force: TRUE
[08:25:47.780] - relayed: [n=1] TRUE
[08:25:47.780] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.781] - relayed: [n=1] TRUE
[08:25:47.781] - queued futures: [n=1] TRUE
[08:25:47.781] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.781] resolve() on list ... DONE
[08:25:47.781]  - Number of value chunks collected: 1
[08:25:47.781] Resolving 1 futures (chunks) ... DONE
[08:25:47.781] Reducing values from 1 chunks ...
[08:25:47.781]  - Number of values collected after concatenation: 1
[08:25:47.781]  - Number of values expected: 1
[08:25:47.781] Reducing values from 1 chunks ... DONE
[08:25:47.781] future_mapply() ... DONE
[08:25:47.782] future_mapply() ...
[08:25:47.782] Number of chunks: 1
[08:25:47.782] getGlobalsAndPackagesXApply() ...
[08:25:47.782]  - future.globals: TRUE
[08:25:47.782] getGlobalsAndPackages() ...
[08:25:47.782] Searching for globals...
[08:25:47.783] - globals found: [1] ‘FUN’
[08:25:47.783] Searching for globals ... DONE
[08:25:47.783] Resolving globals: FALSE
[08:25:47.784] The total size of the 1 globals is 185 bytes (185 bytes)
[08:25:47.784] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:25:47.784] - globals: [1] ‘FUN’
[08:25:47.784] 
[08:25:47.784] getGlobalsAndPackages() ... DONE
[08:25:47.784]  - globals found/used: [n=1] ‘FUN’
[08:25:47.785]  - needed namespaces: [n=0] 
[08:25:47.785] Finding globals ... DONE
[08:25:47.785] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.785] List of 2
[08:25:47.785]  $ ...future.FUN:function (x)  
[08:25:47.785]  $ MoreArgs     : list()
[08:25:47.785]  - attr(*, "where")=List of 2
[08:25:47.785]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.785]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.785]  - attr(*, "resolved")= logi FALSE
[08:25:47.785]  - attr(*, "total_size")= num NA
[08:25:47.787] Packages to be attached in all futures: [n=0] 
[08:25:47.787] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.788] Number of futures (= number of chunks): 1
[08:25:47.788] Launching 1 futures (chunks) ...
[08:25:47.788] Chunk #1 of 1 ...
[08:25:47.788]  - Finding globals in '...' for chunk #1 ...
[08:25:47.788] getGlobalsAndPackages() ...
[08:25:47.788] Searching for globals...
[08:25:47.788] 
[08:25:47.789] Searching for globals ... DONE
[08:25:47.789] - globals: [0] <none>
[08:25:47.789] getGlobalsAndPackages() ... DONE
[08:25:47.789]    + additional globals found: [n=0] 
[08:25:47.789]    + additional namespaces needed: [n=0] 
[08:25:47.789]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.789]  - seeds: <none>
[08:25:47.789]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.789] getGlobalsAndPackages() ...
[08:25:47.789] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.790] Resolving globals: FALSE
[08:25:47.790] The total size of the 5 globals is 370 bytes (370 bytes)
[08:25:47.790] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 370 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:47.790] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.791] 
[08:25:47.791] getGlobalsAndPackages() ... DONE
[08:25:47.791] run() for ‘Future’ ...
[08:25:47.791] - state: ‘created’
[08:25:47.791] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.792] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.792] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.792]   - Field: ‘label’
[08:25:47.792]   - Field: ‘local’
[08:25:47.792]   - Field: ‘owner’
[08:25:47.792]   - Field: ‘envir’
[08:25:47.792]   - Field: ‘packages’
[08:25:47.792]   - Field: ‘gc’
[08:25:47.792]   - Field: ‘conditions’
[08:25:47.792]   - Field: ‘expr’
[08:25:47.792]   - Field: ‘uuid’
[08:25:47.793]   - Field: ‘seed’
[08:25:47.793]   - Field: ‘version’
[08:25:47.793]   - Field: ‘result’
[08:25:47.793]   - Field: ‘asynchronous’
[08:25:47.793]   - Field: ‘calls’
[08:25:47.793]   - Field: ‘globals’
[08:25:47.793]   - Field: ‘stdout’
[08:25:47.793]   - Field: ‘earlySignal’
[08:25:47.793]   - Field: ‘lazy’
[08:25:47.793]   - Field: ‘state’
[08:25:47.793] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.794] - Launch lazy future ...
[08:25:47.794] Packages needed by the future expression (n = 0): <none>
[08:25:47.794] Packages needed by future strategies (n = 0): <none>
[08:25:47.794] {
[08:25:47.794]     {
[08:25:47.794]         {
[08:25:47.794]             ...future.startTime <- base::Sys.time()
[08:25:47.794]             {
[08:25:47.794]                 {
[08:25:47.794]                   {
[08:25:47.794]                     base::local({
[08:25:47.794]                       has_future <- base::requireNamespace("future", 
[08:25:47.794]                         quietly = TRUE)
[08:25:47.794]                       if (has_future) {
[08:25:47.794]                         ns <- base::getNamespace("future")
[08:25:47.794]                         version <- ns[[".package"]][["version"]]
[08:25:47.794]                         if (is.null(version)) 
[08:25:47.794]                           version <- utils::packageVersion("future")
[08:25:47.794]                       }
[08:25:47.794]                       else {
[08:25:47.794]                         version <- NULL
[08:25:47.794]                       }
[08:25:47.794]                       if (!has_future || version < "1.8.0") {
[08:25:47.794]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.794]                           "", base::R.version$version.string), 
[08:25:47.794]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.794]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.794]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.794]                             "release", "version")], collapse = " "), 
[08:25:47.794]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.794]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.794]                           info)
[08:25:47.794]                         info <- base::paste(info, collapse = "; ")
[08:25:47.794]                         if (!has_future) {
[08:25:47.794]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.794]                             info)
[08:25:47.794]                         }
[08:25:47.794]                         else {
[08:25:47.794]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.794]                             info, version)
[08:25:47.794]                         }
[08:25:47.794]                         base::stop(msg)
[08:25:47.794]                       }
[08:25:47.794]                     })
[08:25:47.794]                   }
[08:25:47.794]                   ...future.strategy.old <- future::plan("list")
[08:25:47.794]                   options(future.plan = NULL)
[08:25:47.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.794]                 }
[08:25:47.794]                 ...future.workdir <- getwd()
[08:25:47.794]             }
[08:25:47.794]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.794]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.794]         }
[08:25:47.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.794]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.794]             base::names(...future.oldOptions))
[08:25:47.794]     }
[08:25:47.794]     if (FALSE) {
[08:25:47.794]     }
[08:25:47.794]     else {
[08:25:47.794]         if (TRUE) {
[08:25:47.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.794]                 open = "w")
[08:25:47.794]         }
[08:25:47.794]         else {
[08:25:47.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.794]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.794]         }
[08:25:47.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.794]             base::sink(type = "output", split = FALSE)
[08:25:47.794]             base::close(...future.stdout)
[08:25:47.794]         }, add = TRUE)
[08:25:47.794]     }
[08:25:47.794]     ...future.frame <- base::sys.nframe()
[08:25:47.794]     ...future.conditions <- base::list()
[08:25:47.794]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.794]     if (FALSE) {
[08:25:47.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.794]     }
[08:25:47.794]     ...future.result <- base::tryCatch({
[08:25:47.794]         base::withCallingHandlers({
[08:25:47.794]             ...future.value <- base::withVisible(base::local({
[08:25:47.794]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.794]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.794]                   ...future.globals.maxSize)) {
[08:25:47.794]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.794]                   on.exit(options(oopts), add = TRUE)
[08:25:47.794]                 }
[08:25:47.794]                 {
[08:25:47.794]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.794]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.794]                     USE.NAMES = FALSE)
[08:25:47.794]                   do.call(mapply, args = args)
[08:25:47.794]                 }
[08:25:47.794]             }))
[08:25:47.794]             future::FutureResult(value = ...future.value$value, 
[08:25:47.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.794]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.794]                     ...future.globalenv.names))
[08:25:47.794]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.794]         }, condition = base::local({
[08:25:47.794]             c <- base::c
[08:25:47.794]             inherits <- base::inherits
[08:25:47.794]             invokeRestart <- base::invokeRestart
[08:25:47.794]             length <- base::length
[08:25:47.794]             list <- base::list
[08:25:47.794]             seq.int <- base::seq.int
[08:25:47.794]             signalCondition <- base::signalCondition
[08:25:47.794]             sys.calls <- base::sys.calls
[08:25:47.794]             `[[` <- base::`[[`
[08:25:47.794]             `+` <- base::`+`
[08:25:47.794]             `<<-` <- base::`<<-`
[08:25:47.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.794]                   3L)]
[08:25:47.794]             }
[08:25:47.794]             function(cond) {
[08:25:47.794]                 is_error <- inherits(cond, "error")
[08:25:47.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.794]                   NULL)
[08:25:47.794]                 if (is_error) {
[08:25:47.794]                   sessionInformation <- function() {
[08:25:47.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.794]                       search = base::search(), system = base::Sys.info())
[08:25:47.794]                   }
[08:25:47.794]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.794]                     cond$call), session = sessionInformation(), 
[08:25:47.794]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.794]                   signalCondition(cond)
[08:25:47.794]                 }
[08:25:47.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.794]                 "immediateCondition"))) {
[08:25:47.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.794]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.794]                   if (TRUE && !signal) {
[08:25:47.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.794]                     {
[08:25:47.794]                       inherits <- base::inherits
[08:25:47.794]                       invokeRestart <- base::invokeRestart
[08:25:47.794]                       is.null <- base::is.null
[08:25:47.794]                       muffled <- FALSE
[08:25:47.794]                       if (inherits(cond, "message")) {
[08:25:47.794]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.794]                         if (muffled) 
[08:25:47.794]                           invokeRestart("muffleMessage")
[08:25:47.794]                       }
[08:25:47.794]                       else if (inherits(cond, "warning")) {
[08:25:47.794]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.794]                         if (muffled) 
[08:25:47.794]                           invokeRestart("muffleWarning")
[08:25:47.794]                       }
[08:25:47.794]                       else if (inherits(cond, "condition")) {
[08:25:47.794]                         if (!is.null(pattern)) {
[08:25:47.794]                           computeRestarts <- base::computeRestarts
[08:25:47.794]                           grepl <- base::grepl
[08:25:47.794]                           restarts <- computeRestarts(cond)
[08:25:47.794]                           for (restart in restarts) {
[08:25:47.794]                             name <- restart$name
[08:25:47.794]                             if (is.null(name)) 
[08:25:47.794]                               next
[08:25:47.794]                             if (!grepl(pattern, name)) 
[08:25:47.794]                               next
[08:25:47.794]                             invokeRestart(restart)
[08:25:47.794]                             muffled <- TRUE
[08:25:47.794]                             break
[08:25:47.794]                           }
[08:25:47.794]                         }
[08:25:47.794]                       }
[08:25:47.794]                       invisible(muffled)
[08:25:47.794]                     }
[08:25:47.794]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.794]                   }
[08:25:47.794]                 }
[08:25:47.794]                 else {
[08:25:47.794]                   if (TRUE) {
[08:25:47.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.794]                     {
[08:25:47.794]                       inherits <- base::inherits
[08:25:47.794]                       invokeRestart <- base::invokeRestart
[08:25:47.794]                       is.null <- base::is.null
[08:25:47.794]                       muffled <- FALSE
[08:25:47.794]                       if (inherits(cond, "message")) {
[08:25:47.794]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.794]                         if (muffled) 
[08:25:47.794]                           invokeRestart("muffleMessage")
[08:25:47.794]                       }
[08:25:47.794]                       else if (inherits(cond, "warning")) {
[08:25:47.794]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.794]                         if (muffled) 
[08:25:47.794]                           invokeRestart("muffleWarning")
[08:25:47.794]                       }
[08:25:47.794]                       else if (inherits(cond, "condition")) {
[08:25:47.794]                         if (!is.null(pattern)) {
[08:25:47.794]                           computeRestarts <- base::computeRestarts
[08:25:47.794]                           grepl <- base::grepl
[08:25:47.794]                           restarts <- computeRestarts(cond)
[08:25:47.794]                           for (restart in restarts) {
[08:25:47.794]                             name <- restart$name
[08:25:47.794]                             if (is.null(name)) 
[08:25:47.794]                               next
[08:25:47.794]                             if (!grepl(pattern, name)) 
[08:25:47.794]                               next
[08:25:47.794]                             invokeRestart(restart)
[08:25:47.794]                             muffled <- TRUE
[08:25:47.794]                             break
[08:25:47.794]                           }
[08:25:47.794]                         }
[08:25:47.794]                       }
[08:25:47.794]                       invisible(muffled)
[08:25:47.794]                     }
[08:25:47.794]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.794]                   }
[08:25:47.794]                 }
[08:25:47.794]             }
[08:25:47.794]         }))
[08:25:47.794]     }, error = function(ex) {
[08:25:47.794]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.794]                 ...future.rng), started = ...future.startTime, 
[08:25:47.794]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.794]             version = "1.8"), class = "FutureResult")
[08:25:47.794]     }, finally = {
[08:25:47.794]         if (!identical(...future.workdir, getwd())) 
[08:25:47.794]             setwd(...future.workdir)
[08:25:47.794]         {
[08:25:47.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.794]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.794]             }
[08:25:47.794]             base::options(...future.oldOptions)
[08:25:47.794]             if (.Platform$OS.type == "windows") {
[08:25:47.794]                 old_names <- names(...future.oldEnvVars)
[08:25:47.794]                 envs <- base::Sys.getenv()
[08:25:47.794]                 names <- names(envs)
[08:25:47.794]                 common <- intersect(names, old_names)
[08:25:47.794]                 added <- setdiff(names, old_names)
[08:25:47.794]                 removed <- setdiff(old_names, names)
[08:25:47.794]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.794]                   envs[common]]
[08:25:47.794]                 NAMES <- toupper(changed)
[08:25:47.794]                 args <- list()
[08:25:47.794]                 for (kk in seq_along(NAMES)) {
[08:25:47.794]                   name <- changed[[kk]]
[08:25:47.794]                   NAME <- NAMES[[kk]]
[08:25:47.794]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.794]                     next
[08:25:47.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.794]                 }
[08:25:47.794]                 NAMES <- toupper(added)
[08:25:47.794]                 for (kk in seq_along(NAMES)) {
[08:25:47.794]                   name <- added[[kk]]
[08:25:47.794]                   NAME <- NAMES[[kk]]
[08:25:47.794]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.794]                     next
[08:25:47.794]                   args[[name]] <- ""
[08:25:47.794]                 }
[08:25:47.794]                 NAMES <- toupper(removed)
[08:25:47.794]                 for (kk in seq_along(NAMES)) {
[08:25:47.794]                   name <- removed[[kk]]
[08:25:47.794]                   NAME <- NAMES[[kk]]
[08:25:47.794]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.794]                     next
[08:25:47.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.794]                 }
[08:25:47.794]                 if (length(args) > 0) 
[08:25:47.794]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.794]             }
[08:25:47.794]             else {
[08:25:47.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.794]             }
[08:25:47.794]             {
[08:25:47.794]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.794]                   0L) {
[08:25:47.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.794]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.794]                   base::options(opts)
[08:25:47.794]                 }
[08:25:47.794]                 {
[08:25:47.794]                   {
[08:25:47.794]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.794]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.794]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.794]                       inherits = FALSE)
[08:25:47.794]                     NULL
[08:25:47.794]                   }
[08:25:47.794]                   options(future.plan = NULL)
[08:25:47.794]                   if (is.na(NA_character_)) 
[08:25:47.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.794]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.794]                     .init = FALSE)
[08:25:47.794]                 }
[08:25:47.794]             }
[08:25:47.794]         }
[08:25:47.794]     })
[08:25:47.794]     if (TRUE) {
[08:25:47.794]         base::sink(type = "output", split = FALSE)
[08:25:47.794]         if (TRUE) {
[08:25:47.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.794]         }
[08:25:47.794]         else {
[08:25:47.794]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.794]         }
[08:25:47.794]         base::close(...future.stdout)
[08:25:47.794]         ...future.stdout <- NULL
[08:25:47.794]     }
[08:25:47.794]     ...future.result$conditions <- ...future.conditions
[08:25:47.794]     ...future.result$finished <- base::Sys.time()
[08:25:47.794]     ...future.result
[08:25:47.794] }
[08:25:47.796] assign_globals() ...
[08:25:47.796] List of 5
[08:25:47.796]  $ ...future.FUN            :function (x)  
[08:25:47.796]  $ MoreArgs                 : list()
[08:25:47.796]  $ ...future.elements_ii    :List of 1
[08:25:47.796]   ..$ :List of 1
[08:25:47.796]   .. ..$ : Date[1:1], format: "2018-06-01"
[08:25:47.796]  $ ...future.seeds_ii       : NULL
[08:25:47.796]  $ ...future.globals.maxSize: NULL
[08:25:47.796]  - attr(*, "where")=List of 5
[08:25:47.796]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.796]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.796]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.796]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.796]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.796]  - attr(*, "resolved")= logi FALSE
[08:25:47.796]  - attr(*, "total_size")= num 370
[08:25:47.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.796]  - attr(*, "already-done")= logi TRUE
[08:25:47.803] - copied ‘...future.FUN’ to environment
[08:25:47.803] - copied ‘MoreArgs’ to environment
[08:25:47.803] - copied ‘...future.elements_ii’ to environment
[08:25:47.804] - copied ‘...future.seeds_ii’ to environment
[08:25:47.804] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.804] assign_globals() ... done
[08:25:47.804] plan(): Setting new future strategy stack:
[08:25:47.804] List of future strategies:
[08:25:47.804] 1. sequential:
[08:25:47.804]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.804]    - tweaked: FALSE
[08:25:47.804]    - call: NULL
[08:25:47.805] plan(): nbrOfWorkers() = 1
[08:25:47.805] plan(): Setting new future strategy stack:
[08:25:47.805] List of future strategies:
[08:25:47.805] 1. sequential:
[08:25:47.805]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.805]    - tweaked: FALSE
[08:25:47.805]    - call: plan(strategy)
[08:25:47.806] plan(): nbrOfWorkers() = 1
[08:25:47.806] SequentialFuture started (and completed)
[08:25:47.806] - Launch lazy future ... done
[08:25:47.806] run() for ‘SequentialFuture’ ... done
[08:25:47.806] Created future:
[08:25:47.807] SequentialFuture:
[08:25:47.807] Label: ‘future_.mapply-1’
[08:25:47.807] Expression:
[08:25:47.807] {
[08:25:47.807]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.807]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.807]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.807]         on.exit(options(oopts), add = TRUE)
[08:25:47.807]     }
[08:25:47.807]     {
[08:25:47.807]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.807]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.807]         do.call(mapply, args = args)
[08:25:47.807]     }
[08:25:47.807] }
[08:25:47.807] Lazy evaluation: FALSE
[08:25:47.807] Asynchronous evaluation: FALSE
[08:25:47.807] Local evaluation: TRUE
[08:25:47.807] Environment: R_GlobalEnv
[08:25:47.807] Capture standard output: TRUE
[08:25:47.807] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.807] Globals: 5 objects totaling 370 bytes (function ‘...future.FUN’ of 185 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.807] Packages: <none>
[08:25:47.807] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.807] Resolved: TRUE
[08:25:47.807] Value: 92 bytes of class ‘list’
[08:25:47.807] Early signaling: FALSE
[08:25:47.807] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.807] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.807] Chunk #1 of 1 ... DONE
[08:25:47.808] Launching 1 futures (chunks) ... DONE
[08:25:47.808] Resolving 1 futures (chunks) ...
[08:25:47.808] resolve() on list ...
[08:25:47.808]  recursive: 0
[08:25:47.808]  length: 1
[08:25:47.808] 
[08:25:47.808] resolved() for ‘SequentialFuture’ ...
[08:25:47.808] - state: ‘finished’
[08:25:47.808] - run: TRUE
[08:25:47.808] - result: ‘FutureResult’
[08:25:47.808] resolved() for ‘SequentialFuture’ ... done
[08:25:47.809] Future #1
[08:25:47.809] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.809] - nx: 1
[08:25:47.809] - relay: TRUE
[08:25:47.809] - stdout: TRUE
[08:25:47.809] - signal: TRUE
[08:25:47.809] - resignal: FALSE
[08:25:47.809] - force: TRUE
[08:25:47.809] - relayed: [n=1] FALSE
[08:25:47.809] - queued futures: [n=1] FALSE
[08:25:47.809]  - until=1
[08:25:47.810]  - relaying element #1
[08:25:47.810] - relayed: [n=1] TRUE
[08:25:47.810] - queued futures: [n=1] TRUE
[08:25:47.810] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.810]  length: 0 (resolved future 1)
[08:25:47.810] Relaying remaining futures
[08:25:47.810] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.810] - nx: 1
[08:25:47.810] - relay: TRUE
[08:25:47.810] - stdout: TRUE
[08:25:47.811] - signal: TRUE
[08:25:47.811] - resignal: FALSE
[08:25:47.811] - force: TRUE
[08:25:47.811] - relayed: [n=1] TRUE
[08:25:47.811] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.811] - relayed: [n=1] TRUE
[08:25:47.811] - queued futures: [n=1] TRUE
[08:25:47.811] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.811] resolve() on list ... DONE
[08:25:47.811]  - Number of value chunks collected: 1
[08:25:47.811] Resolving 1 futures (chunks) ... DONE
[08:25:47.812] Reducing values from 1 chunks ...
[08:25:47.812]  - Number of values collected after concatenation: 1
[08:25:47.812]  - Number of values expected: 1
[08:25:47.812] Reducing values from 1 chunks ... DONE
[08:25:47.812] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[08:25:47.812] future_mapply() ...
[08:25:47.812] Number of chunks: 1
[08:25:47.812] getGlobalsAndPackagesXApply() ...
[08:25:47.813]  - future.globals: TRUE
[08:25:47.813] getGlobalsAndPackages() ...
[08:25:47.813] Searching for globals...
[08:25:47.814] - globals found: [1] ‘FUN’
[08:25:47.814] Searching for globals ... DONE
[08:25:47.814] Resolving globals: FALSE
[08:25:47.814] The total size of the 1 globals is 326 bytes (326 bytes)
[08:25:47.815] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[08:25:47.815] - globals: [1] ‘FUN’
[08:25:47.815] 
[08:25:47.815] getGlobalsAndPackages() ... DONE
[08:25:47.815]  - globals found/used: [n=1] ‘FUN’
[08:25:47.815]  - needed namespaces: [n=0] 
[08:25:47.815] Finding globals ... DONE
[08:25:47.815] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.816] List of 2
[08:25:47.816]  $ ...future.FUN:function (x, y)  
[08:25:47.816]  $ MoreArgs     :List of 1
[08:25:47.816]   ..$ y: int [1:2] 3 4
[08:25:47.816]  - attr(*, "where")=List of 2
[08:25:47.816]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.816]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.816]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.816]  - attr(*, "resolved")= logi FALSE
[08:25:47.816]  - attr(*, "total_size")= num NA
[08:25:47.818] Packages to be attached in all futures: [n=0] 
[08:25:47.819] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.819] Number of futures (= number of chunks): 1
[08:25:47.819] Launching 1 futures (chunks) ...
[08:25:47.819] Chunk #1 of 1 ...
[08:25:47.819]  - Finding globals in '...' for chunk #1 ...
[08:25:47.819] getGlobalsAndPackages() ...
[08:25:47.819] Searching for globals...
[08:25:47.820] 
[08:25:47.820] Searching for globals ... DONE
[08:25:47.820] - globals: [0] <none>
[08:25:47.820] getGlobalsAndPackages() ... DONE
[08:25:47.820]    + additional globals found: [n=0] 
[08:25:47.820]    + additional namespaces needed: [n=0] 
[08:25:47.820]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.820]  - seeds: <none>
[08:25:47.820]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.820] getGlobalsAndPackages() ...
[08:25:47.820] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.821] Resolving globals: FALSE
[08:25:47.821] The total size of the 5 globals is 668 bytes (668 bytes)
[08:25:47.821] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 668 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (105 bytes of class ‘list’)
[08:25:47.822] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.822] 
[08:25:47.822] getGlobalsAndPackages() ... DONE
[08:25:47.822] run() for ‘Future’ ...
[08:25:47.822] - state: ‘created’
[08:25:47.822] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.823] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.823] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.823]   - Field: ‘label’
[08:25:47.823]   - Field: ‘local’
[08:25:47.825]   - Field: ‘owner’
[08:25:47.825]   - Field: ‘envir’
[08:25:47.825]   - Field: ‘packages’
[08:25:47.825]   - Field: ‘gc’
[08:25:47.825]   - Field: ‘conditions’
[08:25:47.826]   - Field: ‘expr’
[08:25:47.826]   - Field: ‘uuid’
[08:25:47.826]   - Field: ‘seed’
[08:25:47.826]   - Field: ‘version’
[08:25:47.826]   - Field: ‘result’
[08:25:47.826]   - Field: ‘asynchronous’
[08:25:47.826]   - Field: ‘calls’
[08:25:47.826]   - Field: ‘globals’
[08:25:47.826]   - Field: ‘stdout’
[08:25:47.827]   - Field: ‘earlySignal’
[08:25:47.827]   - Field: ‘lazy’
[08:25:47.827]   - Field: ‘state’
[08:25:47.827] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.827] - Launch lazy future ...
[08:25:47.827] Packages needed by the future expression (n = 0): <none>
[08:25:47.827] Packages needed by future strategies (n = 0): <none>
[08:25:47.828] {
[08:25:47.828]     {
[08:25:47.828]         {
[08:25:47.828]             ...future.startTime <- base::Sys.time()
[08:25:47.828]             {
[08:25:47.828]                 {
[08:25:47.828]                   {
[08:25:47.828]                     base::local({
[08:25:47.828]                       has_future <- base::requireNamespace("future", 
[08:25:47.828]                         quietly = TRUE)
[08:25:47.828]                       if (has_future) {
[08:25:47.828]                         ns <- base::getNamespace("future")
[08:25:47.828]                         version <- ns[[".package"]][["version"]]
[08:25:47.828]                         if (is.null(version)) 
[08:25:47.828]                           version <- utils::packageVersion("future")
[08:25:47.828]                       }
[08:25:47.828]                       else {
[08:25:47.828]                         version <- NULL
[08:25:47.828]                       }
[08:25:47.828]                       if (!has_future || version < "1.8.0") {
[08:25:47.828]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.828]                           "", base::R.version$version.string), 
[08:25:47.828]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.828]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.828]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.828]                             "release", "version")], collapse = " "), 
[08:25:47.828]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.828]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.828]                           info)
[08:25:47.828]                         info <- base::paste(info, collapse = "; ")
[08:25:47.828]                         if (!has_future) {
[08:25:47.828]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.828]                             info)
[08:25:47.828]                         }
[08:25:47.828]                         else {
[08:25:47.828]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.828]                             info, version)
[08:25:47.828]                         }
[08:25:47.828]                         base::stop(msg)
[08:25:47.828]                       }
[08:25:47.828]                     })
[08:25:47.828]                   }
[08:25:47.828]                   ...future.strategy.old <- future::plan("list")
[08:25:47.828]                   options(future.plan = NULL)
[08:25:47.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.828]                 }
[08:25:47.828]                 ...future.workdir <- getwd()
[08:25:47.828]             }
[08:25:47.828]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.828]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.828]         }
[08:25:47.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.828]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.828]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.828]             base::names(...future.oldOptions))
[08:25:47.828]     }
[08:25:47.828]     if (FALSE) {
[08:25:47.828]     }
[08:25:47.828]     else {
[08:25:47.828]         if (TRUE) {
[08:25:47.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.828]                 open = "w")
[08:25:47.828]         }
[08:25:47.828]         else {
[08:25:47.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.828]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.828]         }
[08:25:47.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.828]             base::sink(type = "output", split = FALSE)
[08:25:47.828]             base::close(...future.stdout)
[08:25:47.828]         }, add = TRUE)
[08:25:47.828]     }
[08:25:47.828]     ...future.frame <- base::sys.nframe()
[08:25:47.828]     ...future.conditions <- base::list()
[08:25:47.828]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.828]     if (FALSE) {
[08:25:47.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.828]     }
[08:25:47.828]     ...future.result <- base::tryCatch({
[08:25:47.828]         base::withCallingHandlers({
[08:25:47.828]             ...future.value <- base::withVisible(base::local({
[08:25:47.828]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.828]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.828]                   ...future.globals.maxSize)) {
[08:25:47.828]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.828]                   on.exit(options(oopts), add = TRUE)
[08:25:47.828]                 }
[08:25:47.828]                 {
[08:25:47.828]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.828]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.828]                     USE.NAMES = FALSE)
[08:25:47.828]                   do.call(mapply, args = args)
[08:25:47.828]                 }
[08:25:47.828]             }))
[08:25:47.828]             future::FutureResult(value = ...future.value$value, 
[08:25:47.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.828]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.828]                     ...future.globalenv.names))
[08:25:47.828]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.828]         }, condition = base::local({
[08:25:47.828]             c <- base::c
[08:25:47.828]             inherits <- base::inherits
[08:25:47.828]             invokeRestart <- base::invokeRestart
[08:25:47.828]             length <- base::length
[08:25:47.828]             list <- base::list
[08:25:47.828]             seq.int <- base::seq.int
[08:25:47.828]             signalCondition <- base::signalCondition
[08:25:47.828]             sys.calls <- base::sys.calls
[08:25:47.828]             `[[` <- base::`[[`
[08:25:47.828]             `+` <- base::`+`
[08:25:47.828]             `<<-` <- base::`<<-`
[08:25:47.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.828]                   3L)]
[08:25:47.828]             }
[08:25:47.828]             function(cond) {
[08:25:47.828]                 is_error <- inherits(cond, "error")
[08:25:47.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.828]                   NULL)
[08:25:47.828]                 if (is_error) {
[08:25:47.828]                   sessionInformation <- function() {
[08:25:47.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.828]                       search = base::search(), system = base::Sys.info())
[08:25:47.828]                   }
[08:25:47.828]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.828]                     cond$call), session = sessionInformation(), 
[08:25:47.828]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.828]                   signalCondition(cond)
[08:25:47.828]                 }
[08:25:47.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.828]                 "immediateCondition"))) {
[08:25:47.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.828]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.828]                   if (TRUE && !signal) {
[08:25:47.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.828]                     {
[08:25:47.828]                       inherits <- base::inherits
[08:25:47.828]                       invokeRestart <- base::invokeRestart
[08:25:47.828]                       is.null <- base::is.null
[08:25:47.828]                       muffled <- FALSE
[08:25:47.828]                       if (inherits(cond, "message")) {
[08:25:47.828]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.828]                         if (muffled) 
[08:25:47.828]                           invokeRestart("muffleMessage")
[08:25:47.828]                       }
[08:25:47.828]                       else if (inherits(cond, "warning")) {
[08:25:47.828]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.828]                         if (muffled) 
[08:25:47.828]                           invokeRestart("muffleWarning")
[08:25:47.828]                       }
[08:25:47.828]                       else if (inherits(cond, "condition")) {
[08:25:47.828]                         if (!is.null(pattern)) {
[08:25:47.828]                           computeRestarts <- base::computeRestarts
[08:25:47.828]                           grepl <- base::grepl
[08:25:47.828]                           restarts <- computeRestarts(cond)
[08:25:47.828]                           for (restart in restarts) {
[08:25:47.828]                             name <- restart$name
[08:25:47.828]                             if (is.null(name)) 
[08:25:47.828]                               next
[08:25:47.828]                             if (!grepl(pattern, name)) 
[08:25:47.828]                               next
[08:25:47.828]                             invokeRestart(restart)
[08:25:47.828]                             muffled <- TRUE
[08:25:47.828]                             break
[08:25:47.828]                           }
[08:25:47.828]                         }
[08:25:47.828]                       }
[08:25:47.828]                       invisible(muffled)
[08:25:47.828]                     }
[08:25:47.828]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.828]                   }
[08:25:47.828]                 }
[08:25:47.828]                 else {
[08:25:47.828]                   if (TRUE) {
[08:25:47.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.828]                     {
[08:25:47.828]                       inherits <- base::inherits
[08:25:47.828]                       invokeRestart <- base::invokeRestart
[08:25:47.828]                       is.null <- base::is.null
[08:25:47.828]                       muffled <- FALSE
[08:25:47.828]                       if (inherits(cond, "message")) {
[08:25:47.828]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.828]                         if (muffled) 
[08:25:47.828]                           invokeRestart("muffleMessage")
[08:25:47.828]                       }
[08:25:47.828]                       else if (inherits(cond, "warning")) {
[08:25:47.828]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.828]                         if (muffled) 
[08:25:47.828]                           invokeRestart("muffleWarning")
[08:25:47.828]                       }
[08:25:47.828]                       else if (inherits(cond, "condition")) {
[08:25:47.828]                         if (!is.null(pattern)) {
[08:25:47.828]                           computeRestarts <- base::computeRestarts
[08:25:47.828]                           grepl <- base::grepl
[08:25:47.828]                           restarts <- computeRestarts(cond)
[08:25:47.828]                           for (restart in restarts) {
[08:25:47.828]                             name <- restart$name
[08:25:47.828]                             if (is.null(name)) 
[08:25:47.828]                               next
[08:25:47.828]                             if (!grepl(pattern, name)) 
[08:25:47.828]                               next
[08:25:47.828]                             invokeRestart(restart)
[08:25:47.828]                             muffled <- TRUE
[08:25:47.828]                             break
[08:25:47.828]                           }
[08:25:47.828]                         }
[08:25:47.828]                       }
[08:25:47.828]                       invisible(muffled)
[08:25:47.828]                     }
[08:25:47.828]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.828]                   }
[08:25:47.828]                 }
[08:25:47.828]             }
[08:25:47.828]         }))
[08:25:47.828]     }, error = function(ex) {
[08:25:47.828]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.828]                 ...future.rng), started = ...future.startTime, 
[08:25:47.828]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.828]             version = "1.8"), class = "FutureResult")
[08:25:47.828]     }, finally = {
[08:25:47.828]         if (!identical(...future.workdir, getwd())) 
[08:25:47.828]             setwd(...future.workdir)
[08:25:47.828]         {
[08:25:47.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.828]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.828]             }
[08:25:47.828]             base::options(...future.oldOptions)
[08:25:47.828]             if (.Platform$OS.type == "windows") {
[08:25:47.828]                 old_names <- names(...future.oldEnvVars)
[08:25:47.828]                 envs <- base::Sys.getenv()
[08:25:47.828]                 names <- names(envs)
[08:25:47.828]                 common <- intersect(names, old_names)
[08:25:47.828]                 added <- setdiff(names, old_names)
[08:25:47.828]                 removed <- setdiff(old_names, names)
[08:25:47.828]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.828]                   envs[common]]
[08:25:47.828]                 NAMES <- toupper(changed)
[08:25:47.828]                 args <- list()
[08:25:47.828]                 for (kk in seq_along(NAMES)) {
[08:25:47.828]                   name <- changed[[kk]]
[08:25:47.828]                   NAME <- NAMES[[kk]]
[08:25:47.828]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.828]                     next
[08:25:47.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.828]                 }
[08:25:47.828]                 NAMES <- toupper(added)
[08:25:47.828]                 for (kk in seq_along(NAMES)) {
[08:25:47.828]                   name <- added[[kk]]
[08:25:47.828]                   NAME <- NAMES[[kk]]
[08:25:47.828]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.828]                     next
[08:25:47.828]                   args[[name]] <- ""
[08:25:47.828]                 }
[08:25:47.828]                 NAMES <- toupper(removed)
[08:25:47.828]                 for (kk in seq_along(NAMES)) {
[08:25:47.828]                   name <- removed[[kk]]
[08:25:47.828]                   NAME <- NAMES[[kk]]
[08:25:47.828]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.828]                     next
[08:25:47.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.828]                 }
[08:25:47.828]                 if (length(args) > 0) 
[08:25:47.828]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.828]             }
[08:25:47.828]             else {
[08:25:47.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.828]             }
[08:25:47.828]             {
[08:25:47.828]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.828]                   0L) {
[08:25:47.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.828]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.828]                   base::options(opts)
[08:25:47.828]                 }
[08:25:47.828]                 {
[08:25:47.828]                   {
[08:25:47.828]                     base::assign(".Random.seed", c(10407L, -1254127537L, 
[08:25:47.828]                     -1740134832L, -1939992472L, 1463167666L, 
[08:25:47.828]                     1935667987L, -1219978863L), envir = base::globalenv(), 
[08:25:47.828]                       inherits = FALSE)
[08:25:47.828]                     NULL
[08:25:47.828]                   }
[08:25:47.828]                   options(future.plan = NULL)
[08:25:47.828]                   if (is.na(NA_character_)) 
[08:25:47.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.828]                     .init = FALSE)
[08:25:47.828]                 }
[08:25:47.828]             }
[08:25:47.828]         }
[08:25:47.828]     })
[08:25:47.828]     if (TRUE) {
[08:25:47.828]         base::sink(type = "output", split = FALSE)
[08:25:47.828]         if (TRUE) {
[08:25:47.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.828]         }
[08:25:47.828]         else {
[08:25:47.828]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.828]         }
[08:25:47.828]         base::close(...future.stdout)
[08:25:47.828]         ...future.stdout <- NULL
[08:25:47.828]     }
[08:25:47.828]     ...future.result$conditions <- ...future.conditions
[08:25:47.828]     ...future.result$finished <- base::Sys.time()
[08:25:47.828]     ...future.result
[08:25:47.828] }
[08:25:47.830] assign_globals() ...
[08:25:47.830] List of 5
[08:25:47.830]  $ ...future.FUN            :function (x, y)  
[08:25:47.830]  $ MoreArgs                 :List of 1
[08:25:47.830]   ..$ y: int [1:2] 3 4
[08:25:47.830]  $ ...future.elements_ii    :List of 1
[08:25:47.830]   ..$ x:List of 2
[08:25:47.830]   .. ..$ : int 1
[08:25:47.830]   .. ..$ : int 2
[08:25:47.830]  $ ...future.seeds_ii       : NULL
[08:25:47.830]  $ ...future.globals.maxSize: NULL
[08:25:47.830]  - attr(*, "where")=List of 5
[08:25:47.830]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.830]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.830]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.830]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.830]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.830]  - attr(*, "resolved")= logi FALSE
[08:25:47.830]  - attr(*, "total_size")= num 668
[08:25:47.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.830]  - attr(*, "already-done")= logi TRUE
[08:25:47.835] - reassign environment for ‘...future.FUN’
[08:25:47.835] - copied ‘...future.FUN’ to environment
[08:25:47.835] - copied ‘MoreArgs’ to environment
[08:25:47.835] - copied ‘...future.elements_ii’ to environment
[08:25:47.836] - copied ‘...future.seeds_ii’ to environment
[08:25:47.836] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.836] assign_globals() ... done
[08:25:47.836] plan(): Setting new future strategy stack:
[08:25:47.836] List of future strategies:
[08:25:47.836] 1. sequential:
[08:25:47.836]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.836]    - tweaked: FALSE
[08:25:47.836]    - call: NULL
[08:25:47.837] plan(): nbrOfWorkers() = 1
[08:25:47.837] plan(): Setting new future strategy stack:
[08:25:47.837] List of future strategies:
[08:25:47.837] 1. sequential:
[08:25:47.837]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.837]    - tweaked: FALSE
[08:25:47.837]    - call: plan(strategy)
[08:25:47.838] plan(): nbrOfWorkers() = 1
[08:25:47.838] SequentialFuture started (and completed)
[08:25:47.838] - Launch lazy future ... done
[08:25:47.838] run() for ‘SequentialFuture’ ... done
[08:25:47.838] Created future:
[08:25:47.839] SequentialFuture:
[08:25:47.839] Label: ‘future_mapply-1’
[08:25:47.839] Expression:
[08:25:47.839] {
[08:25:47.839]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.839]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.839]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.839]         on.exit(options(oopts), add = TRUE)
[08:25:47.839]     }
[08:25:47.839]     {
[08:25:47.839]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.839]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.839]         do.call(mapply, args = args)
[08:25:47.839]     }
[08:25:47.839] }
[08:25:47.839] Lazy evaluation: FALSE
[08:25:47.839] Asynchronous evaluation: FALSE
[08:25:47.839] Local evaluation: TRUE
[08:25:47.839] Environment: R_GlobalEnv
[08:25:47.839] Capture standard output: TRUE
[08:25:47.839] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.839] Globals: 5 objects totaling 668 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.839] Packages: <none>
[08:25:47.839] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.839] Resolved: TRUE
[08:25:47.839] Value: 217 bytes of class ‘list’
[08:25:47.839] Early signaling: FALSE
[08:25:47.839] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.839] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.839] Chunk #1 of 1 ... DONE
[08:25:47.840] Launching 1 futures (chunks) ... DONE
[08:25:47.840] Resolving 1 futures (chunks) ...
[08:25:47.840] resolve() on list ...
[08:25:47.840]  recursive: 0
[08:25:47.840]  length: 1
[08:25:47.840] 
[08:25:47.840] resolved() for ‘SequentialFuture’ ...
[08:25:47.840] - state: ‘finished’
[08:25:47.840] - run: TRUE
[08:25:47.840] - result: ‘FutureResult’
[08:25:47.840] resolved() for ‘SequentialFuture’ ... done
[08:25:47.841] Future #1
[08:25:47.841] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.841] - nx: 1
[08:25:47.841] - relay: TRUE
[08:25:47.841] - stdout: TRUE
[08:25:47.841] - signal: TRUE
[08:25:47.841] - resignal: FALSE
[08:25:47.841] - force: TRUE
[08:25:47.841] - relayed: [n=1] FALSE
[08:25:47.841] - queued futures: [n=1] FALSE
[08:25:47.841]  - until=1
[08:25:47.842]  - relaying element #1
[08:25:47.842] - relayed: [n=1] TRUE
[08:25:47.842] - queued futures: [n=1] TRUE
[08:25:47.842] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.842]  length: 0 (resolved future 1)
[08:25:47.842] Relaying remaining futures
[08:25:47.842] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.842] - nx: 1
[08:25:47.842] - relay: TRUE
[08:25:47.842] - stdout: TRUE
[08:25:47.843] - signal: TRUE
[08:25:47.843] - resignal: FALSE
[08:25:47.843] - force: TRUE
[08:25:47.843] - relayed: [n=1] TRUE
[08:25:47.843] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.843] - relayed: [n=1] TRUE
[08:25:47.843] - queued futures: [n=1] TRUE
[08:25:47.843] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.843] resolve() on list ... DONE
[08:25:47.843]  - Number of value chunks collected: 1
[08:25:47.844] Resolving 1 futures (chunks) ... DONE
[08:25:47.844] Reducing values from 1 chunks ...
[08:25:47.844]  - Number of values collected after concatenation: 2
[08:25:47.844]  - Number of values expected: 2
[08:25:47.844] Reducing values from 1 chunks ... DONE
[08:25:47.844] future_mapply() ... DONE
[08:25:47.844] future_mapply() ...
[08:25:47.844] Generating random seeds ...
[08:25:47.844] Generating random seed streams for 2 elements ...
[08:25:47.844] Generating random seed streams for 2 elements ... DONE
[08:25:47.845] Generating random seeds ... DONE
[08:25:47.845] Will set RNG state on exit: 10407, -1939992472, 771149050, 1211850461, -1219978863, 959641247, -766378101
[08:25:47.845] Number of chunks: 1
[08:25:47.845] getGlobalsAndPackagesXApply() ...
[08:25:47.845]  - future.globals: TRUE
[08:25:47.845] getGlobalsAndPackages() ...
[08:25:47.845] Searching for globals...
[08:25:47.846] - globals found: [1] ‘FUN’
[08:25:47.846] Searching for globals ... DONE
[08:25:47.846] Resolving globals: FALSE
[08:25:47.847] The total size of the 1 globals is 326 bytes (326 bytes)
[08:25:47.847] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[08:25:47.847] - globals: [1] ‘FUN’
[08:25:47.847] 
[08:25:47.847] getGlobalsAndPackages() ... DONE
[08:25:47.848]  - globals found/used: [n=1] ‘FUN’
[08:25:47.848]  - needed namespaces: [n=0] 
[08:25:47.848] Finding globals ... DONE
[08:25:47.848] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.848] List of 2
[08:25:47.848]  $ ...future.FUN:function (x, y)  
[08:25:47.848]  $ MoreArgs     :List of 1
[08:25:47.848]   ..$ y: int [1:2] 3 4
[08:25:47.848]  - attr(*, "where")=List of 2
[08:25:47.848]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.848]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.848]  - attr(*, "resolved")= logi FALSE
[08:25:47.848]  - attr(*, "total_size")= num NA
[08:25:47.854] Packages to be attached in all futures: [n=0] 
[08:25:47.854] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.854] Number of futures (= number of chunks): 1
[08:25:47.854] Launching 1 futures (chunks) ...
[08:25:47.854] Chunk #1 of 1 ...
[08:25:47.854]  - Finding globals in '...' for chunk #1 ...
[08:25:47.854] getGlobalsAndPackages() ...
[08:25:47.854] Searching for globals...
[08:25:47.855] 
[08:25:47.855] Searching for globals ... DONE
[08:25:47.855] - globals: [0] <none>
[08:25:47.855] getGlobalsAndPackages() ... DONE
[08:25:47.855]    + additional globals found: [n=0] 
[08:25:47.855]    + additional namespaces needed: [n=0] 
[08:25:47.855]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.855]  - seeds: [2] <seeds>
[08:25:47.856]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.856] getGlobalsAndPackages() ...
[08:25:47.856] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.856] Resolving globals: FALSE
[08:25:47.856] The total size of the 5 globals is 744 bytes (744 bytes)
[08:25:47.857] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 744 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (105 bytes of class ‘list’)
[08:25:47.857] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.857] 
[08:25:47.857] getGlobalsAndPackages() ... DONE
[08:25:47.857] run() for ‘Future’ ...
[08:25:47.858] - state: ‘created’
[08:25:47.858] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.858] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.858] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.858]   - Field: ‘label’
[08:25:47.858]   - Field: ‘local’
[08:25:47.858]   - Field: ‘owner’
[08:25:47.858]   - Field: ‘envir’
[08:25:47.859]   - Field: ‘packages’
[08:25:47.859]   - Field: ‘gc’
[08:25:47.859]   - Field: ‘conditions’
[08:25:47.859]   - Field: ‘expr’
[08:25:47.859]   - Field: ‘uuid’
[08:25:47.859]   - Field: ‘seed’
[08:25:47.859]   - Field: ‘version’
[08:25:47.859]   - Field: ‘result’
[08:25:47.859]   - Field: ‘asynchronous’
[08:25:47.859]   - Field: ‘calls’
[08:25:47.859]   - Field: ‘globals’
[08:25:47.860]   - Field: ‘stdout’
[08:25:47.860]   - Field: ‘earlySignal’
[08:25:47.860]   - Field: ‘lazy’
[08:25:47.860]   - Field: ‘state’
[08:25:47.860] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.860] - Launch lazy future ...
[08:25:47.860] Packages needed by the future expression (n = 0): <none>
[08:25:47.860] Packages needed by future strategies (n = 0): <none>
[08:25:47.861] {
[08:25:47.861]     {
[08:25:47.861]         {
[08:25:47.861]             ...future.startTime <- base::Sys.time()
[08:25:47.861]             {
[08:25:47.861]                 {
[08:25:47.861]                   {
[08:25:47.861]                     base::local({
[08:25:47.861]                       has_future <- base::requireNamespace("future", 
[08:25:47.861]                         quietly = TRUE)
[08:25:47.861]                       if (has_future) {
[08:25:47.861]                         ns <- base::getNamespace("future")
[08:25:47.861]                         version <- ns[[".package"]][["version"]]
[08:25:47.861]                         if (is.null(version)) 
[08:25:47.861]                           version <- utils::packageVersion("future")
[08:25:47.861]                       }
[08:25:47.861]                       else {
[08:25:47.861]                         version <- NULL
[08:25:47.861]                       }
[08:25:47.861]                       if (!has_future || version < "1.8.0") {
[08:25:47.861]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.861]                           "", base::R.version$version.string), 
[08:25:47.861]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.861]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.861]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.861]                             "release", "version")], collapse = " "), 
[08:25:47.861]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.861]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.861]                           info)
[08:25:47.861]                         info <- base::paste(info, collapse = "; ")
[08:25:47.861]                         if (!has_future) {
[08:25:47.861]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.861]                             info)
[08:25:47.861]                         }
[08:25:47.861]                         else {
[08:25:47.861]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.861]                             info, version)
[08:25:47.861]                         }
[08:25:47.861]                         base::stop(msg)
[08:25:47.861]                       }
[08:25:47.861]                     })
[08:25:47.861]                   }
[08:25:47.861]                   ...future.strategy.old <- future::plan("list")
[08:25:47.861]                   options(future.plan = NULL)
[08:25:47.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.861]                 }
[08:25:47.861]                 ...future.workdir <- getwd()
[08:25:47.861]             }
[08:25:47.861]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.861]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.861]         }
[08:25:47.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.861]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.861]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.861]             base::names(...future.oldOptions))
[08:25:47.861]     }
[08:25:47.861]     if (FALSE) {
[08:25:47.861]     }
[08:25:47.861]     else {
[08:25:47.861]         if (TRUE) {
[08:25:47.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.861]                 open = "w")
[08:25:47.861]         }
[08:25:47.861]         else {
[08:25:47.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.861]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.861]         }
[08:25:47.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.861]             base::sink(type = "output", split = FALSE)
[08:25:47.861]             base::close(...future.stdout)
[08:25:47.861]         }, add = TRUE)
[08:25:47.861]     }
[08:25:47.861]     ...future.frame <- base::sys.nframe()
[08:25:47.861]     ...future.conditions <- base::list()
[08:25:47.861]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.861]     if (FALSE) {
[08:25:47.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.861]     }
[08:25:47.861]     ...future.result <- base::tryCatch({
[08:25:47.861]         base::withCallingHandlers({
[08:25:47.861]             ...future.value <- base::withVisible(base::local({
[08:25:47.861]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.861]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.861]                   ...future.globals.maxSize)) {
[08:25:47.861]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.861]                   on.exit(options(oopts), add = TRUE)
[08:25:47.861]                 }
[08:25:47.861]                 {
[08:25:47.861]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:47.861]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:47.861]                       envir = globalenv(), inherits = FALSE)
[08:25:47.861]                     ...future.FUN(...)
[08:25:47.861]                   }
[08:25:47.861]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:47.861]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:47.861]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.861]                     USE.NAMES = FALSE)
[08:25:47.861]                   do.call(mapply, args = args)
[08:25:47.861]                 }
[08:25:47.861]             }))
[08:25:47.861]             future::FutureResult(value = ...future.value$value, 
[08:25:47.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.861]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.861]                     ...future.globalenv.names))
[08:25:47.861]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.861]         }, condition = base::local({
[08:25:47.861]             c <- base::c
[08:25:47.861]             inherits <- base::inherits
[08:25:47.861]             invokeRestart <- base::invokeRestart
[08:25:47.861]             length <- base::length
[08:25:47.861]             list <- base::list
[08:25:47.861]             seq.int <- base::seq.int
[08:25:47.861]             signalCondition <- base::signalCondition
[08:25:47.861]             sys.calls <- base::sys.calls
[08:25:47.861]             `[[` <- base::`[[`
[08:25:47.861]             `+` <- base::`+`
[08:25:47.861]             `<<-` <- base::`<<-`
[08:25:47.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.861]                   3L)]
[08:25:47.861]             }
[08:25:47.861]             function(cond) {
[08:25:47.861]                 is_error <- inherits(cond, "error")
[08:25:47.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.861]                   NULL)
[08:25:47.861]                 if (is_error) {
[08:25:47.861]                   sessionInformation <- function() {
[08:25:47.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.861]                       search = base::search(), system = base::Sys.info())
[08:25:47.861]                   }
[08:25:47.861]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.861]                     cond$call), session = sessionInformation(), 
[08:25:47.861]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.861]                   signalCondition(cond)
[08:25:47.861]                 }
[08:25:47.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.861]                 "immediateCondition"))) {
[08:25:47.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.861]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.861]                   if (TRUE && !signal) {
[08:25:47.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.861]                     {
[08:25:47.861]                       inherits <- base::inherits
[08:25:47.861]                       invokeRestart <- base::invokeRestart
[08:25:47.861]                       is.null <- base::is.null
[08:25:47.861]                       muffled <- FALSE
[08:25:47.861]                       if (inherits(cond, "message")) {
[08:25:47.861]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.861]                         if (muffled) 
[08:25:47.861]                           invokeRestart("muffleMessage")
[08:25:47.861]                       }
[08:25:47.861]                       else if (inherits(cond, "warning")) {
[08:25:47.861]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.861]                         if (muffled) 
[08:25:47.861]                           invokeRestart("muffleWarning")
[08:25:47.861]                       }
[08:25:47.861]                       else if (inherits(cond, "condition")) {
[08:25:47.861]                         if (!is.null(pattern)) {
[08:25:47.861]                           computeRestarts <- base::computeRestarts
[08:25:47.861]                           grepl <- base::grepl
[08:25:47.861]                           restarts <- computeRestarts(cond)
[08:25:47.861]                           for (restart in restarts) {
[08:25:47.861]                             name <- restart$name
[08:25:47.861]                             if (is.null(name)) 
[08:25:47.861]                               next
[08:25:47.861]                             if (!grepl(pattern, name)) 
[08:25:47.861]                               next
[08:25:47.861]                             invokeRestart(restart)
[08:25:47.861]                             muffled <- TRUE
[08:25:47.861]                             break
[08:25:47.861]                           }
[08:25:47.861]                         }
[08:25:47.861]                       }
[08:25:47.861]                       invisible(muffled)
[08:25:47.861]                     }
[08:25:47.861]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.861]                   }
[08:25:47.861]                 }
[08:25:47.861]                 else {
[08:25:47.861]                   if (TRUE) {
[08:25:47.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.861]                     {
[08:25:47.861]                       inherits <- base::inherits
[08:25:47.861]                       invokeRestart <- base::invokeRestart
[08:25:47.861]                       is.null <- base::is.null
[08:25:47.861]                       muffled <- FALSE
[08:25:47.861]                       if (inherits(cond, "message")) {
[08:25:47.861]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.861]                         if (muffled) 
[08:25:47.861]                           invokeRestart("muffleMessage")
[08:25:47.861]                       }
[08:25:47.861]                       else if (inherits(cond, "warning")) {
[08:25:47.861]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.861]                         if (muffled) 
[08:25:47.861]                           invokeRestart("muffleWarning")
[08:25:47.861]                       }
[08:25:47.861]                       else if (inherits(cond, "condition")) {
[08:25:47.861]                         if (!is.null(pattern)) {
[08:25:47.861]                           computeRestarts <- base::computeRestarts
[08:25:47.861]                           grepl <- base::grepl
[08:25:47.861]                           restarts <- computeRestarts(cond)
[08:25:47.861]                           for (restart in restarts) {
[08:25:47.861]                             name <- restart$name
[08:25:47.861]                             if (is.null(name)) 
[08:25:47.861]                               next
[08:25:47.861]                             if (!grepl(pattern, name)) 
[08:25:47.861]                               next
[08:25:47.861]                             invokeRestart(restart)
[08:25:47.861]                             muffled <- TRUE
[08:25:47.861]                             break
[08:25:47.861]                           }
[08:25:47.861]                         }
[08:25:47.861]                       }
[08:25:47.861]                       invisible(muffled)
[08:25:47.861]                     }
[08:25:47.861]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.861]                   }
[08:25:47.861]                 }
[08:25:47.861]             }
[08:25:47.861]         }))
[08:25:47.861]     }, error = function(ex) {
[08:25:47.861]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.861]                 ...future.rng), started = ...future.startTime, 
[08:25:47.861]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.861]             version = "1.8"), class = "FutureResult")
[08:25:47.861]     }, finally = {
[08:25:47.861]         if (!identical(...future.workdir, getwd())) 
[08:25:47.861]             setwd(...future.workdir)
[08:25:47.861]         {
[08:25:47.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.861]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.861]             }
[08:25:47.861]             base::options(...future.oldOptions)
[08:25:47.861]             if (.Platform$OS.type == "windows") {
[08:25:47.861]                 old_names <- names(...future.oldEnvVars)
[08:25:47.861]                 envs <- base::Sys.getenv()
[08:25:47.861]                 names <- names(envs)
[08:25:47.861]                 common <- intersect(names, old_names)
[08:25:47.861]                 added <- setdiff(names, old_names)
[08:25:47.861]                 removed <- setdiff(old_names, names)
[08:25:47.861]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.861]                   envs[common]]
[08:25:47.861]                 NAMES <- toupper(changed)
[08:25:47.861]                 args <- list()
[08:25:47.861]                 for (kk in seq_along(NAMES)) {
[08:25:47.861]                   name <- changed[[kk]]
[08:25:47.861]                   NAME <- NAMES[[kk]]
[08:25:47.861]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.861]                     next
[08:25:47.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.861]                 }
[08:25:47.861]                 NAMES <- toupper(added)
[08:25:47.861]                 for (kk in seq_along(NAMES)) {
[08:25:47.861]                   name <- added[[kk]]
[08:25:47.861]                   NAME <- NAMES[[kk]]
[08:25:47.861]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.861]                     next
[08:25:47.861]                   args[[name]] <- ""
[08:25:47.861]                 }
[08:25:47.861]                 NAMES <- toupper(removed)
[08:25:47.861]                 for (kk in seq_along(NAMES)) {
[08:25:47.861]                   name <- removed[[kk]]
[08:25:47.861]                   NAME <- NAMES[[kk]]
[08:25:47.861]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.861]                     next
[08:25:47.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.861]                 }
[08:25:47.861]                 if (length(args) > 0) 
[08:25:47.861]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.861]             }
[08:25:47.861]             else {
[08:25:47.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.861]             }
[08:25:47.861]             {
[08:25:47.861]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.861]                   0L) {
[08:25:47.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.861]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.861]                   base::options(opts)
[08:25:47.861]                 }
[08:25:47.861]                 {
[08:25:47.861]                   {
[08:25:47.861]                     base::assign(".Random.seed", c(10407L, -1939992472L, 
[08:25:47.861]                     771149050L, 1211850461L, -1219978863L, 959641247L, 
[08:25:47.861]                     -766378101L), envir = base::globalenv(), 
[08:25:47.861]                       inherits = FALSE)
[08:25:47.861]                     NULL
[08:25:47.861]                   }
[08:25:47.861]                   options(future.plan = NULL)
[08:25:47.861]                   if (is.na(NA_character_)) 
[08:25:47.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.861]                     .init = FALSE)
[08:25:47.861]                 }
[08:25:47.861]             }
[08:25:47.861]         }
[08:25:47.861]     })
[08:25:47.861]     if (TRUE) {
[08:25:47.861]         base::sink(type = "output", split = FALSE)
[08:25:47.861]         if (TRUE) {
[08:25:47.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.861]         }
[08:25:47.861]         else {
[08:25:47.861]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.861]         }
[08:25:47.861]         base::close(...future.stdout)
[08:25:47.861]         ...future.stdout <- NULL
[08:25:47.861]     }
[08:25:47.861]     ...future.result$conditions <- ...future.conditions
[08:25:47.861]     ...future.result$finished <- base::Sys.time()
[08:25:47.861]     ...future.result
[08:25:47.861] }
[08:25:47.863] assign_globals() ...
[08:25:47.863] List of 5
[08:25:47.863]  $ ...future.FUN            :function (x, y)  
[08:25:47.863]  $ MoreArgs                 :List of 1
[08:25:47.863]   ..$ y: int [1:2] 3 4
[08:25:47.863]  $ ...future.elements_ii    :List of 1
[08:25:47.863]   ..$ x:List of 2
[08:25:47.863]   .. ..$ : int 1
[08:25:47.863]   .. ..$ : int 2
[08:25:47.863]  $ ...future.seeds_ii       :List of 2
[08:25:47.863]   ..$ : int [1:7] 10407 -409872185 -680982565 439009811 1634135244 -762698253 71439493
[08:25:47.863]   ..$ : int [1:7] 10407 1486027195 -237661262 395504704 -1753669495 -2017786179 368737972
[08:25:47.863]  $ ...future.globals.maxSize: NULL
[08:25:47.863]  - attr(*, "where")=List of 5
[08:25:47.863]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.863]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.863]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.863]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.863]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.863]  - attr(*, "resolved")= logi FALSE
[08:25:47.863]  - attr(*, "total_size")= num 744
[08:25:47.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.863]  - attr(*, "already-done")= logi TRUE
[08:25:47.869] - reassign environment for ‘...future.FUN’
[08:25:47.869] - copied ‘...future.FUN’ to environment
[08:25:47.869] - copied ‘MoreArgs’ to environment
[08:25:47.869] - copied ‘...future.elements_ii’ to environment
[08:25:47.869] - copied ‘...future.seeds_ii’ to environment
[08:25:47.869] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.869] assign_globals() ... done
[08:25:47.870] plan(): Setting new future strategy stack:
[08:25:47.870] List of future strategies:
[08:25:47.870] 1. sequential:
[08:25:47.870]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.870]    - tweaked: FALSE
[08:25:47.870]    - call: NULL
[08:25:47.870] plan(): nbrOfWorkers() = 1
[08:25:47.871] plan(): Setting new future strategy stack:
[08:25:47.871] List of future strategies:
[08:25:47.871] 1. sequential:
[08:25:47.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.871]    - tweaked: FALSE
[08:25:47.871]    - call: plan(strategy)
[08:25:47.872] plan(): nbrOfWorkers() = 1
[08:25:47.872] SequentialFuture started (and completed)
[08:25:47.872] - Launch lazy future ... done
[08:25:47.872] run() for ‘SequentialFuture’ ... done
[08:25:47.872] Created future:
[08:25:47.872] SequentialFuture:
[08:25:47.872] Label: ‘future_mapply-1’
[08:25:47.872] Expression:
[08:25:47.872] {
[08:25:47.872]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.872]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.872]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.872]         on.exit(options(oopts), add = TRUE)
[08:25:47.872]     }
[08:25:47.872]     {
[08:25:47.872]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:47.872]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:47.872]                 inherits = FALSE)
[08:25:47.872]             ...future.FUN(...)
[08:25:47.872]         }
[08:25:47.872]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:47.872]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:47.872]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.872]         do.call(mapply, args = args)
[08:25:47.872]     }
[08:25:47.872] }
[08:25:47.872] Lazy evaluation: FALSE
[08:25:47.872] Asynchronous evaluation: FALSE
[08:25:47.872] Local evaluation: TRUE
[08:25:47.872] Environment: R_GlobalEnv
[08:25:47.872] Capture standard output: TRUE
[08:25:47.872] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.872] Globals: 5 objects totaling 744 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 105 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.872] Packages: <none>
[08:25:47.872] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:47.872] Resolved: TRUE
[08:25:47.872] Value: 217 bytes of class ‘list’
[08:25:47.872] Early signaling: FALSE
[08:25:47.872] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.872] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.873] Chunk #1 of 1 ... DONE
[08:25:47.873] Launching 1 futures (chunks) ... DONE
[08:25:47.873] Resolving 1 futures (chunks) ...
[08:25:47.873] resolve() on list ...
[08:25:47.873]  recursive: 0
[08:25:47.874]  length: 1
[08:25:47.874] 
[08:25:47.874] resolved() for ‘SequentialFuture’ ...
[08:25:47.874] - state: ‘finished’
[08:25:47.876] - run: TRUE
[08:25:47.876] - result: ‘FutureResult’
[08:25:47.876] resolved() for ‘SequentialFuture’ ... done
[08:25:47.876] Future #1
[08:25:47.877] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.877] - nx: 1
[08:25:47.877] - relay: TRUE
[08:25:47.877] - stdout: TRUE
[08:25:47.877] - signal: TRUE
[08:25:47.877] - resignal: FALSE
[08:25:47.877] - force: TRUE
[08:25:47.877] - relayed: [n=1] FALSE
[08:25:47.877] - queued futures: [n=1] FALSE
[08:25:47.878]  - until=1
[08:25:47.878]  - relaying element #1
[08:25:47.878] - relayed: [n=1] TRUE
[08:25:47.878] - queued futures: [n=1] TRUE
[08:25:47.878] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.878]  length: 0 (resolved future 1)
[08:25:47.878] Relaying remaining futures
[08:25:47.878] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.878] - nx: 1
[08:25:47.879] - relay: TRUE
[08:25:47.879] - stdout: TRUE
[08:25:47.879] - signal: TRUE
[08:25:47.879] - resignal: FALSE
[08:25:47.879] - force: TRUE
[08:25:47.879] - relayed: [n=1] TRUE
[08:25:47.879] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.879] - relayed: [n=1] TRUE
[08:25:47.879] - queued futures: [n=1] TRUE
[08:25:47.879] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.879] resolve() on list ... DONE
[08:25:47.880]  - Number of value chunks collected: 1
[08:25:47.880] Resolving 1 futures (chunks) ... DONE
[08:25:47.880] Reducing values from 1 chunks ...
[08:25:47.880]  - Number of values collected after concatenation: 2
[08:25:47.880]  - Number of values expected: 2
[08:25:47.880] Reducing values from 1 chunks ... DONE
[08:25:47.880] future_mapply() ... DONE
[08:25:47.880] future_mapply() ...
[08:25:47.881] Number of chunks: 1
[08:25:47.881] getGlobalsAndPackagesXApply() ...
[08:25:47.881]  - future.globals: TRUE
[08:25:47.881] getGlobalsAndPackages() ...
[08:25:47.881] Searching for globals...
[08:25:47.882] - globals found: [1] ‘FUN’
[08:25:47.882] Searching for globals ... DONE
[08:25:47.882] Resolving globals: FALSE
[08:25:47.883] The total size of the 1 globals is 326 bytes (326 bytes)
[08:25:47.883] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[08:25:47.883] - globals: [1] ‘FUN’
[08:25:47.883] 
[08:25:47.883] getGlobalsAndPackages() ... DONE
[08:25:47.883]  - globals found/used: [n=1] ‘FUN’
[08:25:47.884]  - needed namespaces: [n=0] 
[08:25:47.884] Finding globals ... DONE
[08:25:47.884] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.884] List of 2
[08:25:47.884]  $ ...future.FUN:function (x, y)  
[08:25:47.884]  $ MoreArgs     :List of 1
[08:25:47.884]   ..$ y: int [1:2] 3 4
[08:25:47.884]  - attr(*, "where")=List of 2
[08:25:47.884]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.884]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.884]  - attr(*, "resolved")= logi FALSE
[08:25:47.884]  - attr(*, "total_size")= num NA
[08:25:47.887] Packages to be attached in all futures: [n=0] 
[08:25:47.887] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.887] Number of futures (= number of chunks): 1
[08:25:47.887] Launching 1 futures (chunks) ...
[08:25:47.887] Chunk #1 of 1 ...
[08:25:47.887]  - Finding globals in '...' for chunk #1 ...
[08:25:47.888] getGlobalsAndPackages() ...
[08:25:47.888] Searching for globals...
[08:25:47.888] 
[08:25:47.888] Searching for globals ... DONE
[08:25:47.888] - globals: [0] <none>
[08:25:47.888] getGlobalsAndPackages() ... DONE
[08:25:47.888]    + additional globals found: [n=0] 
[08:25:47.888]    + additional namespaces needed: [n=0] 
[08:25:47.888]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.889]  - seeds: <none>
[08:25:47.889]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.889] getGlobalsAndPackages() ...
[08:25:47.889] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.889] Resolving globals: FALSE
[08:25:47.889] The total size of the 5 globals is 668 bytes (668 bytes)
[08:25:47.890] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 668 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (105 bytes of class ‘list’)
[08:25:47.890] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.890] 
[08:25:47.890] getGlobalsAndPackages() ... DONE
[08:25:47.890] run() for ‘Future’ ...
[08:25:47.891] - state: ‘created’
[08:25:47.891] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.891] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.891]   - Field: ‘label’
[08:25:47.891]   - Field: ‘local’
[08:25:47.891]   - Field: ‘owner’
[08:25:47.892]   - Field: ‘envir’
[08:25:47.892]   - Field: ‘packages’
[08:25:47.892]   - Field: ‘gc’
[08:25:47.892]   - Field: ‘conditions’
[08:25:47.892]   - Field: ‘expr’
[08:25:47.892]   - Field: ‘uuid’
[08:25:47.892]   - Field: ‘seed’
[08:25:47.892]   - Field: ‘version’
[08:25:47.892]   - Field: ‘result’
[08:25:47.892]   - Field: ‘asynchronous’
[08:25:47.892]   - Field: ‘calls’
[08:25:47.893]   - Field: ‘globals’
[08:25:47.893]   - Field: ‘stdout’
[08:25:47.893]   - Field: ‘earlySignal’
[08:25:47.893]   - Field: ‘lazy’
[08:25:47.893]   - Field: ‘state’
[08:25:47.893] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.893] - Launch lazy future ...
[08:25:47.893] Packages needed by the future expression (n = 0): <none>
[08:25:47.893] Packages needed by future strategies (n = 0): <none>
[08:25:47.894] {
[08:25:47.894]     {
[08:25:47.894]         {
[08:25:47.894]             ...future.startTime <- base::Sys.time()
[08:25:47.894]             {
[08:25:47.894]                 {
[08:25:47.894]                   {
[08:25:47.894]                     base::local({
[08:25:47.894]                       has_future <- base::requireNamespace("future", 
[08:25:47.894]                         quietly = TRUE)
[08:25:47.894]                       if (has_future) {
[08:25:47.894]                         ns <- base::getNamespace("future")
[08:25:47.894]                         version <- ns[[".package"]][["version"]]
[08:25:47.894]                         if (is.null(version)) 
[08:25:47.894]                           version <- utils::packageVersion("future")
[08:25:47.894]                       }
[08:25:47.894]                       else {
[08:25:47.894]                         version <- NULL
[08:25:47.894]                       }
[08:25:47.894]                       if (!has_future || version < "1.8.0") {
[08:25:47.894]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.894]                           "", base::R.version$version.string), 
[08:25:47.894]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.894]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.894]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.894]                             "release", "version")], collapse = " "), 
[08:25:47.894]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.894]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.894]                           info)
[08:25:47.894]                         info <- base::paste(info, collapse = "; ")
[08:25:47.894]                         if (!has_future) {
[08:25:47.894]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.894]                             info)
[08:25:47.894]                         }
[08:25:47.894]                         else {
[08:25:47.894]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.894]                             info, version)
[08:25:47.894]                         }
[08:25:47.894]                         base::stop(msg)
[08:25:47.894]                       }
[08:25:47.894]                     })
[08:25:47.894]                   }
[08:25:47.894]                   ...future.strategy.old <- future::plan("list")
[08:25:47.894]                   options(future.plan = NULL)
[08:25:47.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.894]                 }
[08:25:47.894]                 ...future.workdir <- getwd()
[08:25:47.894]             }
[08:25:47.894]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.894]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.894]         }
[08:25:47.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.894]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.894]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.894]             base::names(...future.oldOptions))
[08:25:47.894]     }
[08:25:47.894]     if (FALSE) {
[08:25:47.894]     }
[08:25:47.894]     else {
[08:25:47.894]         if (TRUE) {
[08:25:47.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.894]                 open = "w")
[08:25:47.894]         }
[08:25:47.894]         else {
[08:25:47.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.894]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.894]         }
[08:25:47.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.894]             base::sink(type = "output", split = FALSE)
[08:25:47.894]             base::close(...future.stdout)
[08:25:47.894]         }, add = TRUE)
[08:25:47.894]     }
[08:25:47.894]     ...future.frame <- base::sys.nframe()
[08:25:47.894]     ...future.conditions <- base::list()
[08:25:47.894]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.894]     if (FALSE) {
[08:25:47.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.894]     }
[08:25:47.894]     ...future.result <- base::tryCatch({
[08:25:47.894]         base::withCallingHandlers({
[08:25:47.894]             ...future.value <- base::withVisible(base::local({
[08:25:47.894]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.894]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.894]                   ...future.globals.maxSize)) {
[08:25:47.894]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.894]                   on.exit(options(oopts), add = TRUE)
[08:25:47.894]                 }
[08:25:47.894]                 {
[08:25:47.894]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.894]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.894]                     USE.NAMES = FALSE)
[08:25:47.894]                   do.call(mapply, args = args)
[08:25:47.894]                 }
[08:25:47.894]             }))
[08:25:47.894]             future::FutureResult(value = ...future.value$value, 
[08:25:47.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.894]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.894]                     ...future.globalenv.names))
[08:25:47.894]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.894]         }, condition = base::local({
[08:25:47.894]             c <- base::c
[08:25:47.894]             inherits <- base::inherits
[08:25:47.894]             invokeRestart <- base::invokeRestart
[08:25:47.894]             length <- base::length
[08:25:47.894]             list <- base::list
[08:25:47.894]             seq.int <- base::seq.int
[08:25:47.894]             signalCondition <- base::signalCondition
[08:25:47.894]             sys.calls <- base::sys.calls
[08:25:47.894]             `[[` <- base::`[[`
[08:25:47.894]             `+` <- base::`+`
[08:25:47.894]             `<<-` <- base::`<<-`
[08:25:47.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.894]                   3L)]
[08:25:47.894]             }
[08:25:47.894]             function(cond) {
[08:25:47.894]                 is_error <- inherits(cond, "error")
[08:25:47.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.894]                   NULL)
[08:25:47.894]                 if (is_error) {
[08:25:47.894]                   sessionInformation <- function() {
[08:25:47.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.894]                       search = base::search(), system = base::Sys.info())
[08:25:47.894]                   }
[08:25:47.894]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.894]                     cond$call), session = sessionInformation(), 
[08:25:47.894]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.894]                   signalCondition(cond)
[08:25:47.894]                 }
[08:25:47.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.894]                 "immediateCondition"))) {
[08:25:47.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.894]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.894]                   if (TRUE && !signal) {
[08:25:47.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.894]                     {
[08:25:47.894]                       inherits <- base::inherits
[08:25:47.894]                       invokeRestart <- base::invokeRestart
[08:25:47.894]                       is.null <- base::is.null
[08:25:47.894]                       muffled <- FALSE
[08:25:47.894]                       if (inherits(cond, "message")) {
[08:25:47.894]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.894]                         if (muffled) 
[08:25:47.894]                           invokeRestart("muffleMessage")
[08:25:47.894]                       }
[08:25:47.894]                       else if (inherits(cond, "warning")) {
[08:25:47.894]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.894]                         if (muffled) 
[08:25:47.894]                           invokeRestart("muffleWarning")
[08:25:47.894]                       }
[08:25:47.894]                       else if (inherits(cond, "condition")) {
[08:25:47.894]                         if (!is.null(pattern)) {
[08:25:47.894]                           computeRestarts <- base::computeRestarts
[08:25:47.894]                           grepl <- base::grepl
[08:25:47.894]                           restarts <- computeRestarts(cond)
[08:25:47.894]                           for (restart in restarts) {
[08:25:47.894]                             name <- restart$name
[08:25:47.894]                             if (is.null(name)) 
[08:25:47.894]                               next
[08:25:47.894]                             if (!grepl(pattern, name)) 
[08:25:47.894]                               next
[08:25:47.894]                             invokeRestart(restart)
[08:25:47.894]                             muffled <- TRUE
[08:25:47.894]                             break
[08:25:47.894]                           }
[08:25:47.894]                         }
[08:25:47.894]                       }
[08:25:47.894]                       invisible(muffled)
[08:25:47.894]                     }
[08:25:47.894]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.894]                   }
[08:25:47.894]                 }
[08:25:47.894]                 else {
[08:25:47.894]                   if (TRUE) {
[08:25:47.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.894]                     {
[08:25:47.894]                       inherits <- base::inherits
[08:25:47.894]                       invokeRestart <- base::invokeRestart
[08:25:47.894]                       is.null <- base::is.null
[08:25:47.894]                       muffled <- FALSE
[08:25:47.894]                       if (inherits(cond, "message")) {
[08:25:47.894]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.894]                         if (muffled) 
[08:25:47.894]                           invokeRestart("muffleMessage")
[08:25:47.894]                       }
[08:25:47.894]                       else if (inherits(cond, "warning")) {
[08:25:47.894]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.894]                         if (muffled) 
[08:25:47.894]                           invokeRestart("muffleWarning")
[08:25:47.894]                       }
[08:25:47.894]                       else if (inherits(cond, "condition")) {
[08:25:47.894]                         if (!is.null(pattern)) {
[08:25:47.894]                           computeRestarts <- base::computeRestarts
[08:25:47.894]                           grepl <- base::grepl
[08:25:47.894]                           restarts <- computeRestarts(cond)
[08:25:47.894]                           for (restart in restarts) {
[08:25:47.894]                             name <- restart$name
[08:25:47.894]                             if (is.null(name)) 
[08:25:47.894]                               next
[08:25:47.894]                             if (!grepl(pattern, name)) 
[08:25:47.894]                               next
[08:25:47.894]                             invokeRestart(restart)
[08:25:47.894]                             muffled <- TRUE
[08:25:47.894]                             break
[08:25:47.894]                           }
[08:25:47.894]                         }
[08:25:47.894]                       }
[08:25:47.894]                       invisible(muffled)
[08:25:47.894]                     }
[08:25:47.894]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.894]                   }
[08:25:47.894]                 }
[08:25:47.894]             }
[08:25:47.894]         }))
[08:25:47.894]     }, error = function(ex) {
[08:25:47.894]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.894]                 ...future.rng), started = ...future.startTime, 
[08:25:47.894]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.894]             version = "1.8"), class = "FutureResult")
[08:25:47.894]     }, finally = {
[08:25:47.894]         if (!identical(...future.workdir, getwd())) 
[08:25:47.894]             setwd(...future.workdir)
[08:25:47.894]         {
[08:25:47.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.894]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.894]             }
[08:25:47.894]             base::options(...future.oldOptions)
[08:25:47.894]             if (.Platform$OS.type == "windows") {
[08:25:47.894]                 old_names <- names(...future.oldEnvVars)
[08:25:47.894]                 envs <- base::Sys.getenv()
[08:25:47.894]                 names <- names(envs)
[08:25:47.894]                 common <- intersect(names, old_names)
[08:25:47.894]                 added <- setdiff(names, old_names)
[08:25:47.894]                 removed <- setdiff(old_names, names)
[08:25:47.894]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.894]                   envs[common]]
[08:25:47.894]                 NAMES <- toupper(changed)
[08:25:47.894]                 args <- list()
[08:25:47.894]                 for (kk in seq_along(NAMES)) {
[08:25:47.894]                   name <- changed[[kk]]
[08:25:47.894]                   NAME <- NAMES[[kk]]
[08:25:47.894]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.894]                     next
[08:25:47.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.894]                 }
[08:25:47.894]                 NAMES <- toupper(added)
[08:25:47.894]                 for (kk in seq_along(NAMES)) {
[08:25:47.894]                   name <- added[[kk]]
[08:25:47.894]                   NAME <- NAMES[[kk]]
[08:25:47.894]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.894]                     next
[08:25:47.894]                   args[[name]] <- ""
[08:25:47.894]                 }
[08:25:47.894]                 NAMES <- toupper(removed)
[08:25:47.894]                 for (kk in seq_along(NAMES)) {
[08:25:47.894]                   name <- removed[[kk]]
[08:25:47.894]                   NAME <- NAMES[[kk]]
[08:25:47.894]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.894]                     next
[08:25:47.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.894]                 }
[08:25:47.894]                 if (length(args) > 0) 
[08:25:47.894]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.894]             }
[08:25:47.894]             else {
[08:25:47.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.894]             }
[08:25:47.894]             {
[08:25:47.894]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.894]                   0L) {
[08:25:47.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.894]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.894]                   base::options(opts)
[08:25:47.894]                 }
[08:25:47.894]                 {
[08:25:47.894]                   {
[08:25:47.894]                     base::assign(".Random.seed", c(10407L, -1939992472L, 
[08:25:47.894]                     771149050L, 1211850461L, -1219978863L, 959641247L, 
[08:25:47.894]                     -766378101L), envir = base::globalenv(), 
[08:25:47.894]                       inherits = FALSE)
[08:25:47.894]                     NULL
[08:25:47.894]                   }
[08:25:47.894]                   options(future.plan = NULL)
[08:25:47.894]                   if (is.na(NA_character_)) 
[08:25:47.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.894]                     .init = FALSE)
[08:25:47.894]                 }
[08:25:47.894]             }
[08:25:47.894]         }
[08:25:47.894]     })
[08:25:47.894]     if (TRUE) {
[08:25:47.894]         base::sink(type = "output", split = FALSE)
[08:25:47.894]         if (TRUE) {
[08:25:47.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.894]         }
[08:25:47.894]         else {
[08:25:47.894]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.894]         }
[08:25:47.894]         base::close(...future.stdout)
[08:25:47.894]         ...future.stdout <- NULL
[08:25:47.894]     }
[08:25:47.894]     ...future.result$conditions <- ...future.conditions
[08:25:47.894]     ...future.result$finished <- base::Sys.time()
[08:25:47.894]     ...future.result
[08:25:47.894] }
[08:25:47.896] assign_globals() ...
[08:25:47.896] List of 5
[08:25:47.896]  $ ...future.FUN            :function (x, y)  
[08:25:47.896]  $ MoreArgs                 :List of 1
[08:25:47.896]   ..$ y: int [1:2] 3 4
[08:25:47.896]  $ ...future.elements_ii    :List of 1
[08:25:47.896]   ..$ x:List of 2
[08:25:47.896]   .. ..$ : int 1
[08:25:47.896]   .. ..$ : int 2
[08:25:47.896]  $ ...future.seeds_ii       : NULL
[08:25:47.896]  $ ...future.globals.maxSize: NULL
[08:25:47.896]  - attr(*, "where")=List of 5
[08:25:47.896]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.896]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.896]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.896]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.896]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.896]  - attr(*, "resolved")= logi FALSE
[08:25:47.896]  - attr(*, "total_size")= num 668
[08:25:47.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.896]  - attr(*, "already-done")= logi TRUE
[08:25:47.904] - reassign environment for ‘...future.FUN’
[08:25:47.904] - copied ‘...future.FUN’ to environment
[08:25:47.904] - copied ‘MoreArgs’ to environment
[08:25:47.904] - copied ‘...future.elements_ii’ to environment
[08:25:47.904] - copied ‘...future.seeds_ii’ to environment
[08:25:47.904] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.904] assign_globals() ... done
[08:25:47.905] plan(): Setting new future strategy stack:
[08:25:47.905] List of future strategies:
[08:25:47.905] 1. sequential:
[08:25:47.905]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.905]    - tweaked: FALSE
[08:25:47.905]    - call: NULL
[08:25:47.905] plan(): nbrOfWorkers() = 1
[08:25:47.906] plan(): Setting new future strategy stack:
[08:25:47.906] List of future strategies:
[08:25:47.906] 1. sequential:
[08:25:47.906]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.906]    - tweaked: FALSE
[08:25:47.906]    - call: plan(strategy)
[08:25:47.907] plan(): nbrOfWorkers() = 1
[08:25:47.907] SequentialFuture started (and completed)
[08:25:47.907] - Launch lazy future ... done
[08:25:47.907] run() for ‘SequentialFuture’ ... done
[08:25:47.907] Created future:
[08:25:47.907] SequentialFuture:
[08:25:47.907] Label: ‘future_.mapply-1’
[08:25:47.907] Expression:
[08:25:47.907] {
[08:25:47.907]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.907]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.907]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.907]         on.exit(options(oopts), add = TRUE)
[08:25:47.907]     }
[08:25:47.907]     {
[08:25:47.907]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.907]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.907]         do.call(mapply, args = args)
[08:25:47.907]     }
[08:25:47.907] }
[08:25:47.907] Lazy evaluation: FALSE
[08:25:47.907] Asynchronous evaluation: FALSE
[08:25:47.907] Local evaluation: TRUE
[08:25:47.907] Environment: R_GlobalEnv
[08:25:47.907] Capture standard output: TRUE
[08:25:47.907] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.907] Globals: 5 objects totaling 668 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.907] Packages: <none>
[08:25:47.907] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.907] Resolved: TRUE
[08:25:47.907] Value: 217 bytes of class ‘list’
[08:25:47.907] Early signaling: FALSE
[08:25:47.907] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.907] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.908] Chunk #1 of 1 ... DONE
[08:25:47.908] Launching 1 futures (chunks) ... DONE
[08:25:47.908] Resolving 1 futures (chunks) ...
[08:25:47.908] resolve() on list ...
[08:25:47.908]  recursive: 0
[08:25:47.909]  length: 1
[08:25:47.909] 
[08:25:47.909] resolved() for ‘SequentialFuture’ ...
[08:25:47.909] - state: ‘finished’
[08:25:47.909] - run: TRUE
[08:25:47.909] - result: ‘FutureResult’
[08:25:47.909] resolved() for ‘SequentialFuture’ ... done
[08:25:47.909] Future #1
[08:25:47.909] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.909] - nx: 1
[08:25:47.910] - relay: TRUE
[08:25:47.910] - stdout: TRUE
[08:25:47.910] - signal: TRUE
[08:25:47.910] - resignal: FALSE
[08:25:47.910] - force: TRUE
[08:25:47.910] - relayed: [n=1] FALSE
[08:25:47.910] - queued futures: [n=1] FALSE
[08:25:47.910]  - until=1
[08:25:47.910]  - relaying element #1
[08:25:47.911] - relayed: [n=1] TRUE
[08:25:47.911] - queued futures: [n=1] TRUE
[08:25:47.911] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.911]  length: 0 (resolved future 1)
[08:25:47.911] Relaying remaining futures
[08:25:47.911] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.911] - nx: 1
[08:25:47.911] - relay: TRUE
[08:25:47.911] - stdout: TRUE
[08:25:47.911] - signal: TRUE
[08:25:47.911] - resignal: FALSE
[08:25:47.911] - force: TRUE
[08:25:47.912] - relayed: [n=1] TRUE
[08:25:47.912] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.912] - relayed: [n=1] TRUE
[08:25:47.912] - queued futures: [n=1] TRUE
[08:25:47.912] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.912] resolve() on list ... DONE
[08:25:47.912]  - Number of value chunks collected: 1
[08:25:47.912] Resolving 1 futures (chunks) ... DONE
[08:25:47.912] Reducing values from 1 chunks ...
[08:25:47.912]  - Number of values collected after concatenation: 2
[08:25:47.913]  - Number of values expected: 2
[08:25:47.913] Reducing values from 1 chunks ... DONE
[08:25:47.913] future_mapply() ... DONE
- Recycle arguments to same length ...
[08:25:47.913] future_mapply() ...
[08:25:47.913] Number of chunks: 1
[08:25:47.913] getGlobalsAndPackagesXApply() ...
[08:25:47.913]  - future.globals: TRUE
[08:25:47.913] getGlobalsAndPackages() ...
[08:25:47.913] Searching for globals...
[08:25:47.914] - globals found: [1] ‘FUN’
[08:25:47.914] Searching for globals ... DONE
[08:25:47.914] Resolving globals: FALSE
[08:25:47.915] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:47.915] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:47.915] - globals: [1] ‘FUN’
[08:25:47.915] 
[08:25:47.915] getGlobalsAndPackages() ... DONE
[08:25:47.915]  - globals found/used: [n=1] ‘FUN’
[08:25:47.916]  - needed namespaces: [n=0] 
[08:25:47.916] Finding globals ... DONE
[08:25:47.916] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.916] List of 2
[08:25:47.916]  $ ...future.FUN:function (x, ...)  
[08:25:47.916]  $ MoreArgs     : NULL
[08:25:47.916]  - attr(*, "where")=List of 2
[08:25:47.916]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.916]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.916]  - attr(*, "resolved")= logi FALSE
[08:25:47.916]  - attr(*, "total_size")= num NA
[08:25:47.918] Packages to be attached in all futures: [n=0] 
[08:25:47.919] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.919] Number of futures (= number of chunks): 1
[08:25:47.919] Launching 1 futures (chunks) ...
[08:25:47.919] Chunk #1 of 1 ...
[08:25:47.919]  - Finding globals in '...' for chunk #1 ...
[08:25:47.919] getGlobalsAndPackages() ...
[08:25:47.919] Searching for globals...
[08:25:47.920] 
[08:25:47.920] Searching for globals ... DONE
[08:25:47.920] - globals: [0] <none>
[08:25:47.920] getGlobalsAndPackages() ... DONE
[08:25:47.920]    + additional globals found: [n=0] 
[08:25:47.920]    + additional namespaces needed: [n=0] 
[08:25:47.920]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.920]  - seeds: <none>
[08:25:47.920]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.920] getGlobalsAndPackages() ...
[08:25:47.921] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.921] Resolving globals: FALSE
[08:25:47.921] The total size of the 5 globals is 258 bytes (258 bytes)
[08:25:47.922] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 258 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (143 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:47.922] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.922] 
[08:25:47.922] getGlobalsAndPackages() ... DONE
[08:25:47.922] run() for ‘Future’ ...
[08:25:47.922] - state: ‘created’
[08:25:47.922] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.923] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.923] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.923]   - Field: ‘label’
[08:25:47.923]   - Field: ‘local’
[08:25:47.925]   - Field: ‘owner’
[08:25:47.925]   - Field: ‘envir’
[08:25:47.925]   - Field: ‘packages’
[08:25:47.926]   - Field: ‘gc’
[08:25:47.926]   - Field: ‘conditions’
[08:25:47.926]   - Field: ‘expr’
[08:25:47.926]   - Field: ‘uuid’
[08:25:47.926]   - Field: ‘seed’
[08:25:47.926]   - Field: ‘version’
[08:25:47.926]   - Field: ‘result’
[08:25:47.926]   - Field: ‘asynchronous’
[08:25:47.927]   - Field: ‘calls’
[08:25:47.927]   - Field: ‘globals’
[08:25:47.927]   - Field: ‘stdout’
[08:25:47.927]   - Field: ‘earlySignal’
[08:25:47.927]   - Field: ‘lazy’
[08:25:47.927]   - Field: ‘state’
[08:25:47.927] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.927] - Launch lazy future ...
[08:25:47.928] Packages needed by the future expression (n = 0): <none>
[08:25:47.928] Packages needed by future strategies (n = 0): <none>
[08:25:47.928] {
[08:25:47.928]     {
[08:25:47.928]         {
[08:25:47.928]             ...future.startTime <- base::Sys.time()
[08:25:47.928]             {
[08:25:47.928]                 {
[08:25:47.928]                   {
[08:25:47.928]                     base::local({
[08:25:47.928]                       has_future <- base::requireNamespace("future", 
[08:25:47.928]                         quietly = TRUE)
[08:25:47.928]                       if (has_future) {
[08:25:47.928]                         ns <- base::getNamespace("future")
[08:25:47.928]                         version <- ns[[".package"]][["version"]]
[08:25:47.928]                         if (is.null(version)) 
[08:25:47.928]                           version <- utils::packageVersion("future")
[08:25:47.928]                       }
[08:25:47.928]                       else {
[08:25:47.928]                         version <- NULL
[08:25:47.928]                       }
[08:25:47.928]                       if (!has_future || version < "1.8.0") {
[08:25:47.928]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.928]                           "", base::R.version$version.string), 
[08:25:47.928]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:47.928]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.928]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.928]                             "release", "version")], collapse = " "), 
[08:25:47.928]                           hostname = base::Sys.info()[["nodename"]])
[08:25:47.928]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.928]                           info)
[08:25:47.928]                         info <- base::paste(info, collapse = "; ")
[08:25:47.928]                         if (!has_future) {
[08:25:47.928]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.928]                             info)
[08:25:47.928]                         }
[08:25:47.928]                         else {
[08:25:47.928]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.928]                             info, version)
[08:25:47.928]                         }
[08:25:47.928]                         base::stop(msg)
[08:25:47.928]                       }
[08:25:47.928]                     })
[08:25:47.928]                   }
[08:25:47.928]                   ...future.strategy.old <- future::plan("list")
[08:25:47.928]                   options(future.plan = NULL)
[08:25:47.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.928]                 }
[08:25:47.928]                 ...future.workdir <- getwd()
[08:25:47.928]             }
[08:25:47.928]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.928]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.928]         }
[08:25:47.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.928]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.928]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.928]             base::names(...future.oldOptions))
[08:25:47.928]     }
[08:25:47.928]     if (FALSE) {
[08:25:47.928]     }
[08:25:47.928]     else {
[08:25:47.928]         if (TRUE) {
[08:25:47.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.928]                 open = "w")
[08:25:47.928]         }
[08:25:47.928]         else {
[08:25:47.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.928]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.928]         }
[08:25:47.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.928]             base::sink(type = "output", split = FALSE)
[08:25:47.928]             base::close(...future.stdout)
[08:25:47.928]         }, add = TRUE)
[08:25:47.928]     }
[08:25:47.928]     ...future.frame <- base::sys.nframe()
[08:25:47.928]     ...future.conditions <- base::list()
[08:25:47.928]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.928]     if (FALSE) {
[08:25:47.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.928]     }
[08:25:47.928]     ...future.result <- base::tryCatch({
[08:25:47.928]         base::withCallingHandlers({
[08:25:47.928]             ...future.value <- base::withVisible(base::local({
[08:25:47.928]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.928]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.928]                   ...future.globals.maxSize)) {
[08:25:47.928]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.928]                   on.exit(options(oopts), add = TRUE)
[08:25:47.928]                 }
[08:25:47.928]                 {
[08:25:47.928]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.928]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.928]                     USE.NAMES = FALSE)
[08:25:47.928]                   do.call(mapply, args = args)
[08:25:47.928]                 }
[08:25:47.928]             }))
[08:25:47.928]             future::FutureResult(value = ...future.value$value, 
[08:25:47.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.928]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.928]                     ...future.globalenv.names))
[08:25:47.928]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.928]         }, condition = base::local({
[08:25:47.928]             c <- base::c
[08:25:47.928]             inherits <- base::inherits
[08:25:47.928]             invokeRestart <- base::invokeRestart
[08:25:47.928]             length <- base::length
[08:25:47.928]             list <- base::list
[08:25:47.928]             seq.int <- base::seq.int
[08:25:47.928]             signalCondition <- base::signalCondition
[08:25:47.928]             sys.calls <- base::sys.calls
[08:25:47.928]             `[[` <- base::`[[`
[08:25:47.928]             `+` <- base::`+`
[08:25:47.928]             `<<-` <- base::`<<-`
[08:25:47.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.928]                   3L)]
[08:25:47.928]             }
[08:25:47.928]             function(cond) {
[08:25:47.928]                 is_error <- inherits(cond, "error")
[08:25:47.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.928]                   NULL)
[08:25:47.928]                 if (is_error) {
[08:25:47.928]                   sessionInformation <- function() {
[08:25:47.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.928]                       search = base::search(), system = base::Sys.info())
[08:25:47.928]                   }
[08:25:47.928]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.928]                     cond$call), session = sessionInformation(), 
[08:25:47.928]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.928]                   signalCondition(cond)
[08:25:47.928]                 }
[08:25:47.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.928]                 "immediateCondition"))) {
[08:25:47.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.928]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.928]                   if (TRUE && !signal) {
[08:25:47.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.928]                     {
[08:25:47.928]                       inherits <- base::inherits
[08:25:47.928]                       invokeRestart <- base::invokeRestart
[08:25:47.928]                       is.null <- base::is.null
[08:25:47.928]                       muffled <- FALSE
[08:25:47.928]                       if (inherits(cond, "message")) {
[08:25:47.928]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.928]                         if (muffled) 
[08:25:47.928]                           invokeRestart("muffleMessage")
[08:25:47.928]                       }
[08:25:47.928]                       else if (inherits(cond, "warning")) {
[08:25:47.928]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.928]                         if (muffled) 
[08:25:47.928]                           invokeRestart("muffleWarning")
[08:25:47.928]                       }
[08:25:47.928]                       else if (inherits(cond, "condition")) {
[08:25:47.928]                         if (!is.null(pattern)) {
[08:25:47.928]                           computeRestarts <- base::computeRestarts
[08:25:47.928]                           grepl <- base::grepl
[08:25:47.928]                           restarts <- computeRestarts(cond)
[08:25:47.928]                           for (restart in restarts) {
[08:25:47.928]                             name <- restart$name
[08:25:47.928]                             if (is.null(name)) 
[08:25:47.928]                               next
[08:25:47.928]                             if (!grepl(pattern, name)) 
[08:25:47.928]                               next
[08:25:47.928]                             invokeRestart(restart)
[08:25:47.928]                             muffled <- TRUE
[08:25:47.928]                             break
[08:25:47.928]                           }
[08:25:47.928]                         }
[08:25:47.928]                       }
[08:25:47.928]                       invisible(muffled)
[08:25:47.928]                     }
[08:25:47.928]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.928]                   }
[08:25:47.928]                 }
[08:25:47.928]                 else {
[08:25:47.928]                   if (TRUE) {
[08:25:47.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.928]                     {
[08:25:47.928]                       inherits <- base::inherits
[08:25:47.928]                       invokeRestart <- base::invokeRestart
[08:25:47.928]                       is.null <- base::is.null
[08:25:47.928]                       muffled <- FALSE
[08:25:47.928]                       if (inherits(cond, "message")) {
[08:25:47.928]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.928]                         if (muffled) 
[08:25:47.928]                           invokeRestart("muffleMessage")
[08:25:47.928]                       }
[08:25:47.928]                       else if (inherits(cond, "warning")) {
[08:25:47.928]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.928]                         if (muffled) 
[08:25:47.928]                           invokeRestart("muffleWarning")
[08:25:47.928]                       }
[08:25:47.928]                       else if (inherits(cond, "condition")) {
[08:25:47.928]                         if (!is.null(pattern)) {
[08:25:47.928]                           computeRestarts <- base::computeRestarts
[08:25:47.928]                           grepl <- base::grepl
[08:25:47.928]                           restarts <- computeRestarts(cond)
[08:25:47.928]                           for (restart in restarts) {
[08:25:47.928]                             name <- restart$name
[08:25:47.928]                             if (is.null(name)) 
[08:25:47.928]                               next
[08:25:47.928]                             if (!grepl(pattern, name)) 
[08:25:47.928]                               next
[08:25:47.928]                             invokeRestart(restart)
[08:25:47.928]                             muffled <- TRUE
[08:25:47.928]                             break
[08:25:47.928]                           }
[08:25:47.928]                         }
[08:25:47.928]                       }
[08:25:47.928]                       invisible(muffled)
[08:25:47.928]                     }
[08:25:47.928]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.928]                   }
[08:25:47.928]                 }
[08:25:47.928]             }
[08:25:47.928]         }))
[08:25:47.928]     }, error = function(ex) {
[08:25:47.928]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.928]                 ...future.rng), started = ...future.startTime, 
[08:25:47.928]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.928]             version = "1.8"), class = "FutureResult")
[08:25:47.928]     }, finally = {
[08:25:47.928]         if (!identical(...future.workdir, getwd())) 
[08:25:47.928]             setwd(...future.workdir)
[08:25:47.928]         {
[08:25:47.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.928]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.928]             }
[08:25:47.928]             base::options(...future.oldOptions)
[08:25:47.928]             if (.Platform$OS.type == "windows") {
[08:25:47.928]                 old_names <- names(...future.oldEnvVars)
[08:25:47.928]                 envs <- base::Sys.getenv()
[08:25:47.928]                 names <- names(envs)
[08:25:47.928]                 common <- intersect(names, old_names)
[08:25:47.928]                 added <- setdiff(names, old_names)
[08:25:47.928]                 removed <- setdiff(old_names, names)
[08:25:47.928]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.928]                   envs[common]]
[08:25:47.928]                 NAMES <- toupper(changed)
[08:25:47.928]                 args <- list()
[08:25:47.928]                 for (kk in seq_along(NAMES)) {
[08:25:47.928]                   name <- changed[[kk]]
[08:25:47.928]                   NAME <- NAMES[[kk]]
[08:25:47.928]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.928]                     next
[08:25:47.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.928]                 }
[08:25:47.928]                 NAMES <- toupper(added)
[08:25:47.928]                 for (kk in seq_along(NAMES)) {
[08:25:47.928]                   name <- added[[kk]]
[08:25:47.928]                   NAME <- NAMES[[kk]]
[08:25:47.928]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.928]                     next
[08:25:47.928]                   args[[name]] <- ""
[08:25:47.928]                 }
[08:25:47.928]                 NAMES <- toupper(removed)
[08:25:47.928]                 for (kk in seq_along(NAMES)) {
[08:25:47.928]                   name <- removed[[kk]]
[08:25:47.928]                   NAME <- NAMES[[kk]]
[08:25:47.928]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.928]                     next
[08:25:47.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.928]                 }
[08:25:47.928]                 if (length(args) > 0) 
[08:25:47.928]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.928]             }
[08:25:47.928]             else {
[08:25:47.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.928]             }
[08:25:47.928]             {
[08:25:47.928]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.928]                   0L) {
[08:25:47.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.928]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.928]                   base::options(opts)
[08:25:47.928]                 }
[08:25:47.928]                 {
[08:25:47.928]                   {
[08:25:47.928]                     base::assign(".Random.seed", c(10407L, -1939992472L, 
[08:25:47.928]                     771149050L, 1211850461L, -1219978863L, 959641247L, 
[08:25:47.928]                     -766378101L), envir = base::globalenv(), 
[08:25:47.928]                       inherits = FALSE)
[08:25:47.928]                     NULL
[08:25:47.928]                   }
[08:25:47.928]                   options(future.plan = NULL)
[08:25:47.928]                   if (is.na(NA_character_)) 
[08:25:47.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.928]                     .init = FALSE)
[08:25:47.928]                 }
[08:25:47.928]             }
[08:25:47.928]         }
[08:25:47.928]     })
[08:25:47.928]     if (TRUE) {
[08:25:47.928]         base::sink(type = "output", split = FALSE)
[08:25:47.928]         if (TRUE) {
[08:25:47.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.928]         }
[08:25:47.928]         else {
[08:25:47.928]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.928]         }
[08:25:47.928]         base::close(...future.stdout)
[08:25:47.928]         ...future.stdout <- NULL
[08:25:47.928]     }
[08:25:47.928]     ...future.result$conditions <- ...future.conditions
[08:25:47.928]     ...future.result$finished <- base::Sys.time()
[08:25:47.928]     ...future.result
[08:25:47.928] }
[08:25:47.930] assign_globals() ...
[08:25:47.930] List of 5
[08:25:47.930]  $ ...future.FUN            :function (x, ...)  
[08:25:47.930]  $ MoreArgs                 : NULL
[08:25:47.930]  $ ...future.elements_ii    :List of 2
[08:25:47.930]   ..$ :List of 4
[08:25:47.930]   .. ..$ : int 1
[08:25:47.930]   .. ..$ : int 2
[08:25:47.930]   .. ..$ : int 3
[08:25:47.930]   .. ..$ : int 4
[08:25:47.930]   ..$ :List of 4
[08:25:47.930]   .. ..$ : int 2
[08:25:47.930]   .. ..$ : int 1
[08:25:47.930]   .. ..$ : int 2
[08:25:47.930]   .. ..$ : int 1
[08:25:47.930]  $ ...future.seeds_ii       : NULL
[08:25:47.930]  $ ...future.globals.maxSize: NULL
[08:25:47.930]  - attr(*, "where")=List of 5
[08:25:47.930]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.930]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.930]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.930]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.930]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.930]  - attr(*, "resolved")= logi FALSE
[08:25:47.930]  - attr(*, "total_size")= num 258
[08:25:47.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.930]  - attr(*, "already-done")= logi TRUE
[08:25:47.937] - copied ‘...future.FUN’ to environment
[08:25:47.937] - copied ‘MoreArgs’ to environment
[08:25:47.937] - copied ‘...future.elements_ii’ to environment
[08:25:47.938] - copied ‘...future.seeds_ii’ to environment
[08:25:47.938] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.938] assign_globals() ... done
[08:25:47.938] plan(): Setting new future strategy stack:
[08:25:47.938] List of future strategies:
[08:25:47.938] 1. sequential:
[08:25:47.938]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.938]    - tweaked: FALSE
[08:25:47.938]    - call: NULL
[08:25:47.939] plan(): nbrOfWorkers() = 1
[08:25:47.939] plan(): Setting new future strategy stack:
[08:25:47.940] List of future strategies:
[08:25:47.940] 1. sequential:
[08:25:47.940]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.940]    - tweaked: FALSE
[08:25:47.940]    - call: plan(strategy)
[08:25:47.940] plan(): nbrOfWorkers() = 1
[08:25:47.940] SequentialFuture started (and completed)
[08:25:47.940] - Launch lazy future ... done
[08:25:47.940] run() for ‘SequentialFuture’ ... done
[08:25:47.941] Created future:
[08:25:47.941] SequentialFuture:
[08:25:47.941] Label: ‘future_mapply-1’
[08:25:47.941] Expression:
[08:25:47.941] {
[08:25:47.941]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.941]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.941]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.941]         on.exit(options(oopts), add = TRUE)
[08:25:47.941]     }
[08:25:47.941]     {
[08:25:47.941]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:47.941]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.941]         do.call(mapply, args = args)
[08:25:47.941]     }
[08:25:47.941] }
[08:25:47.941] Lazy evaluation: FALSE
[08:25:47.941] Asynchronous evaluation: FALSE
[08:25:47.941] Local evaluation: TRUE
[08:25:47.941] Environment: R_GlobalEnv
[08:25:47.941] Capture standard output: TRUE
[08:25:47.941] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.941] Globals: 5 objects totaling 258 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 143 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.941] Packages: <none>
[08:25:47.941] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:47.941] Resolved: TRUE
[08:25:47.941] Value: 87 bytes of class ‘list’
[08:25:47.941] Early signaling: FALSE
[08:25:47.941] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.941] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.941] Chunk #1 of 1 ... DONE
[08:25:47.942] Launching 1 futures (chunks) ... DONE
[08:25:47.942] Resolving 1 futures (chunks) ...
[08:25:47.942] resolve() on list ...
[08:25:47.942]  recursive: 0
[08:25:47.942]  length: 1
[08:25:47.942] 
[08:25:47.942] resolved() for ‘SequentialFuture’ ...
[08:25:47.942] - state: ‘finished’
[08:25:47.942] - run: TRUE
[08:25:47.942] - result: ‘FutureResult’
[08:25:47.942] resolved() for ‘SequentialFuture’ ... done
[08:25:47.943] Future #1
[08:25:47.943] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.943] - nx: 1
[08:25:47.943] - relay: TRUE
[08:25:47.943] - stdout: TRUE
[08:25:47.943] - signal: TRUE
[08:25:47.943] - resignal: FALSE
[08:25:47.943] - force: TRUE
[08:25:47.943] - relayed: [n=1] FALSE
[08:25:47.943] - queued futures: [n=1] FALSE
[08:25:47.944]  - until=1
[08:25:47.944]  - relaying element #1
[08:25:47.944] - relayed: [n=1] TRUE
[08:25:47.944] - queued futures: [n=1] TRUE
[08:25:47.944] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.944]  length: 0 (resolved future 1)
[08:25:47.944] Relaying remaining futures
[08:25:47.944] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.944] - nx: 1
[08:25:47.944] - relay: TRUE
[08:25:47.944] - stdout: TRUE
[08:25:47.945] - signal: TRUE
[08:25:47.945] - resignal: FALSE
[08:25:47.945] - force: TRUE
[08:25:47.945] - relayed: [n=1] TRUE
[08:25:47.945] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.945] - relayed: [n=1] TRUE
[08:25:47.945] - queued futures: [n=1] TRUE
[08:25:47.945] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.945] resolve() on list ... DONE
[08:25:47.945]  - Number of value chunks collected: 1
[08:25:47.946] Resolving 1 futures (chunks) ... DONE
[08:25:47.946] Reducing values from 1 chunks ...
[08:25:47.946]  - Number of values collected after concatenation: 4
[08:25:47.946]  - Number of values expected: 4
[08:25:47.946] Reducing values from 1 chunks ... DONE
[08:25:47.946] future_mapply() ... DONE
- Parallel RNG ...
[08:25:47.946] future_mapply() ...
[08:25:47.946] Generating random seeds ...
[08:25:47.946] Generating random seed streams for 4 elements ...
[08:25:47.947] Generating random seed streams for 4 elements ... DONE
[08:25:47.947] Generating random seeds ... DONE
[08:25:47.947] Will set RNG state on exit: 10407, 1211850461, 1008010542, -1988403684, -766378101, -1508803277, 1574915741
[08:25:47.947] Number of chunks: 1
[08:25:47.947] getGlobalsAndPackagesXApply() ...
[08:25:47.947]  - future.globals: TRUE
[08:25:47.947] getGlobalsAndPackages() ...
[08:25:47.947] Searching for globals...
[08:25:47.951] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[08:25:47.951] Searching for globals ... DONE
[08:25:47.951] Resolving globals: FALSE
[08:25:47.952] The total size of the 1 globals is 501 bytes (501 bytes)
[08:25:47.952] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[08:25:47.952] - globals: [1] ‘FUN’
[08:25:47.952] - packages: [1] ‘stats’
[08:25:47.952] getGlobalsAndPackages() ... DONE
[08:25:47.953]  - globals found/used: [n=1] ‘FUN’
[08:25:47.953]  - needed namespaces: [n=1] ‘stats’
[08:25:47.953] Finding globals ... DONE
[08:25:47.953] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.953] List of 2
[08:25:47.953]  $ ...future.FUN:function (n, min = 0, max = 1)  
[08:25:47.953]  $ MoreArgs     :List of 1
[08:25:47.953]   ..$ min: num 1
[08:25:47.953]  - attr(*, "where")=List of 2
[08:25:47.953]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.953]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.953]  - attr(*, "resolved")= logi FALSE
[08:25:47.953]  - attr(*, "total_size")= num NA
[08:25:47.956] Packages to be attached in all futures: [n=1] ‘stats’
[08:25:47.956] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.956] Number of futures (= number of chunks): 1
[08:25:47.956] Launching 1 futures (chunks) ...
[08:25:47.957] Chunk #1 of 1 ...
[08:25:47.957]  - Finding globals in '...' for chunk #1 ...
[08:25:47.957] getGlobalsAndPackages() ...
[08:25:47.957] Searching for globals...
[08:25:47.957] 
[08:25:47.957] Searching for globals ... DONE
[08:25:47.957] - globals: [0] <none>
[08:25:47.957] getGlobalsAndPackages() ... DONE
[08:25:47.958]    + additional globals found: [n=0] 
[08:25:47.958]    + additional namespaces needed: [n=0] 
[08:25:47.958]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:47.958]  - seeds: [4] <seeds>
[08:25:47.958]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.958] getGlobalsAndPackages() ...
[08:25:47.958] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.958] Resolving globals: FALSE
[08:25:47.959] The total size of the 5 globals is 990 bytes (990 bytes)
[08:25:47.959] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 990 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (196 bytes of class ‘list’) and ‘...future.seeds_ii’ (175 bytes of class ‘list’)
[08:25:47.959] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:47.959] - packages: [1] ‘stats’
[08:25:47.960] getGlobalsAndPackages() ... DONE
[08:25:47.960] run() for ‘Future’ ...
[08:25:47.960] - state: ‘created’
[08:25:47.960] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:47.960] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.961] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:47.961]   - Field: ‘label’
[08:25:47.961]   - Field: ‘local’
[08:25:47.961]   - Field: ‘owner’
[08:25:47.961]   - Field: ‘envir’
[08:25:47.961]   - Field: ‘packages’
[08:25:47.961]   - Field: ‘gc’
[08:25:47.961]   - Field: ‘conditions’
[08:25:47.961]   - Field: ‘expr’
[08:25:47.961]   - Field: ‘uuid’
[08:25:47.962]   - Field: ‘seed’
[08:25:47.962]   - Field: ‘version’
[08:25:47.962]   - Field: ‘result’
[08:25:47.962]   - Field: ‘asynchronous’
[08:25:47.962]   - Field: ‘calls’
[08:25:47.962]   - Field: ‘globals’
[08:25:47.962]   - Field: ‘stdout’
[08:25:47.962]   - Field: ‘earlySignal’
[08:25:47.962]   - Field: ‘lazy’
[08:25:47.962]   - Field: ‘state’
[08:25:47.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:47.963] - Launch lazy future ...
[08:25:47.963] Packages needed by the future expression (n = 1): ‘stats’
[08:25:47.963] Packages needed by future strategies (n = 0): <none>
[08:25:47.963] {
[08:25:47.963]     {
[08:25:47.963]         {
[08:25:47.963]             ...future.startTime <- base::Sys.time()
[08:25:47.963]             {
[08:25:47.963]                 {
[08:25:47.963]                   {
[08:25:47.963]                     {
[08:25:47.963]                       base::local({
[08:25:47.963]                         has_future <- base::requireNamespace("future", 
[08:25:47.963]                           quietly = TRUE)
[08:25:47.963]                         if (has_future) {
[08:25:47.963]                           ns <- base::getNamespace("future")
[08:25:47.963]                           version <- ns[[".package"]][["version"]]
[08:25:47.963]                           if (is.null(version)) 
[08:25:47.963]                             version <- utils::packageVersion("future")
[08:25:47.963]                         }
[08:25:47.963]                         else {
[08:25:47.963]                           version <- NULL
[08:25:47.963]                         }
[08:25:47.963]                         if (!has_future || version < "1.8.0") {
[08:25:47.963]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:47.963]                             "", base::R.version$version.string), 
[08:25:47.963]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:47.963]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:47.963]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:47.963]                               "release", "version")], collapse = " "), 
[08:25:47.963]                             hostname = base::Sys.info()[["nodename"]])
[08:25:47.963]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:47.963]                             info)
[08:25:47.963]                           info <- base::paste(info, collapse = "; ")
[08:25:47.963]                           if (!has_future) {
[08:25:47.963]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:47.963]                               info)
[08:25:47.963]                           }
[08:25:47.963]                           else {
[08:25:47.963]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:47.963]                               info, version)
[08:25:47.963]                           }
[08:25:47.963]                           base::stop(msg)
[08:25:47.963]                         }
[08:25:47.963]                       })
[08:25:47.963]                     }
[08:25:47.963]                     base::local({
[08:25:47.963]                       for (pkg in "stats") {
[08:25:47.963]                         base::loadNamespace(pkg)
[08:25:47.963]                         base::library(pkg, character.only = TRUE)
[08:25:47.963]                       }
[08:25:47.963]                     })
[08:25:47.963]                   }
[08:25:47.963]                   ...future.strategy.old <- future::plan("list")
[08:25:47.963]                   options(future.plan = NULL)
[08:25:47.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:47.963]                 }
[08:25:47.963]                 ...future.workdir <- getwd()
[08:25:47.963]             }
[08:25:47.963]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:47.963]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:47.963]         }
[08:25:47.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:47.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:47.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:47.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:47.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:47.963]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:47.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:47.963]             base::names(...future.oldOptions))
[08:25:47.963]     }
[08:25:47.963]     if (FALSE) {
[08:25:47.963]     }
[08:25:47.963]     else {
[08:25:47.963]         if (TRUE) {
[08:25:47.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:47.963]                 open = "w")
[08:25:47.963]         }
[08:25:47.963]         else {
[08:25:47.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:47.963]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:47.963]         }
[08:25:47.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:47.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:47.963]             base::sink(type = "output", split = FALSE)
[08:25:47.963]             base::close(...future.stdout)
[08:25:47.963]         }, add = TRUE)
[08:25:47.963]     }
[08:25:47.963]     ...future.frame <- base::sys.nframe()
[08:25:47.963]     ...future.conditions <- base::list()
[08:25:47.963]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:47.963]     if (FALSE) {
[08:25:47.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:47.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:47.963]     }
[08:25:47.963]     ...future.result <- base::tryCatch({
[08:25:47.963]         base::withCallingHandlers({
[08:25:47.963]             ...future.value <- base::withVisible(base::local({
[08:25:47.963]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.963]                 if (!identical(...future.globals.maxSize.org, 
[08:25:47.963]                   ...future.globals.maxSize)) {
[08:25:47.963]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.963]                   on.exit(options(oopts), add = TRUE)
[08:25:47.963]                 }
[08:25:47.963]                 {
[08:25:47.963]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:47.963]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:47.963]                       envir = globalenv(), inherits = FALSE)
[08:25:47.963]                     ...future.FUN(...)
[08:25:47.963]                   }
[08:25:47.963]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:47.963]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:47.963]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:47.963]                     USE.NAMES = FALSE)
[08:25:47.963]                   do.call(mapply, args = args)
[08:25:47.963]                 }
[08:25:47.963]             }))
[08:25:47.963]             future::FutureResult(value = ...future.value$value, 
[08:25:47.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.963]                   ...future.rng), globalenv = if (FALSE) 
[08:25:47.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:47.963]                     ...future.globalenv.names))
[08:25:47.963]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:47.963]         }, condition = base::local({
[08:25:47.963]             c <- base::c
[08:25:47.963]             inherits <- base::inherits
[08:25:47.963]             invokeRestart <- base::invokeRestart
[08:25:47.963]             length <- base::length
[08:25:47.963]             list <- base::list
[08:25:47.963]             seq.int <- base::seq.int
[08:25:47.963]             signalCondition <- base::signalCondition
[08:25:47.963]             sys.calls <- base::sys.calls
[08:25:47.963]             `[[` <- base::`[[`
[08:25:47.963]             `+` <- base::`+`
[08:25:47.963]             `<<-` <- base::`<<-`
[08:25:47.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:47.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:47.963]                   3L)]
[08:25:47.963]             }
[08:25:47.963]             function(cond) {
[08:25:47.963]                 is_error <- inherits(cond, "error")
[08:25:47.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:47.963]                   NULL)
[08:25:47.963]                 if (is_error) {
[08:25:47.963]                   sessionInformation <- function() {
[08:25:47.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:47.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:47.963]                       search = base::search(), system = base::Sys.info())
[08:25:47.963]                   }
[08:25:47.963]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:47.963]                     cond$call), session = sessionInformation(), 
[08:25:47.963]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:47.963]                   signalCondition(cond)
[08:25:47.963]                 }
[08:25:47.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:47.963]                 "immediateCondition"))) {
[08:25:47.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:47.963]                   ...future.conditions[[length(...future.conditions) + 
[08:25:47.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:47.963]                   if (TRUE && !signal) {
[08:25:47.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.963]                     {
[08:25:47.963]                       inherits <- base::inherits
[08:25:47.963]                       invokeRestart <- base::invokeRestart
[08:25:47.963]                       is.null <- base::is.null
[08:25:47.963]                       muffled <- FALSE
[08:25:47.963]                       if (inherits(cond, "message")) {
[08:25:47.963]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.963]                         if (muffled) 
[08:25:47.963]                           invokeRestart("muffleMessage")
[08:25:47.963]                       }
[08:25:47.963]                       else if (inherits(cond, "warning")) {
[08:25:47.963]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.963]                         if (muffled) 
[08:25:47.963]                           invokeRestart("muffleWarning")
[08:25:47.963]                       }
[08:25:47.963]                       else if (inherits(cond, "condition")) {
[08:25:47.963]                         if (!is.null(pattern)) {
[08:25:47.963]                           computeRestarts <- base::computeRestarts
[08:25:47.963]                           grepl <- base::grepl
[08:25:47.963]                           restarts <- computeRestarts(cond)
[08:25:47.963]                           for (restart in restarts) {
[08:25:47.963]                             name <- restart$name
[08:25:47.963]                             if (is.null(name)) 
[08:25:47.963]                               next
[08:25:47.963]                             if (!grepl(pattern, name)) 
[08:25:47.963]                               next
[08:25:47.963]                             invokeRestart(restart)
[08:25:47.963]                             muffled <- TRUE
[08:25:47.963]                             break
[08:25:47.963]                           }
[08:25:47.963]                         }
[08:25:47.963]                       }
[08:25:47.963]                       invisible(muffled)
[08:25:47.963]                     }
[08:25:47.963]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.963]                   }
[08:25:47.963]                 }
[08:25:47.963]                 else {
[08:25:47.963]                   if (TRUE) {
[08:25:47.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:47.963]                     {
[08:25:47.963]                       inherits <- base::inherits
[08:25:47.963]                       invokeRestart <- base::invokeRestart
[08:25:47.963]                       is.null <- base::is.null
[08:25:47.963]                       muffled <- FALSE
[08:25:47.963]                       if (inherits(cond, "message")) {
[08:25:47.963]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:47.963]                         if (muffled) 
[08:25:47.963]                           invokeRestart("muffleMessage")
[08:25:47.963]                       }
[08:25:47.963]                       else if (inherits(cond, "warning")) {
[08:25:47.963]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:47.963]                         if (muffled) 
[08:25:47.963]                           invokeRestart("muffleWarning")
[08:25:47.963]                       }
[08:25:47.963]                       else if (inherits(cond, "condition")) {
[08:25:47.963]                         if (!is.null(pattern)) {
[08:25:47.963]                           computeRestarts <- base::computeRestarts
[08:25:47.963]                           grepl <- base::grepl
[08:25:47.963]                           restarts <- computeRestarts(cond)
[08:25:47.963]                           for (restart in restarts) {
[08:25:47.963]                             name <- restart$name
[08:25:47.963]                             if (is.null(name)) 
[08:25:47.963]                               next
[08:25:47.963]                             if (!grepl(pattern, name)) 
[08:25:47.963]                               next
[08:25:47.963]                             invokeRestart(restart)
[08:25:47.963]                             muffled <- TRUE
[08:25:47.963]                             break
[08:25:47.963]                           }
[08:25:47.963]                         }
[08:25:47.963]                       }
[08:25:47.963]                       invisible(muffled)
[08:25:47.963]                     }
[08:25:47.963]                     muffleCondition(cond, pattern = "^muffle")
[08:25:47.963]                   }
[08:25:47.963]                 }
[08:25:47.963]             }
[08:25:47.963]         }))
[08:25:47.963]     }, error = function(ex) {
[08:25:47.963]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:47.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:47.963]                 ...future.rng), started = ...future.startTime, 
[08:25:47.963]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:47.963]             version = "1.8"), class = "FutureResult")
[08:25:47.963]     }, finally = {
[08:25:47.963]         if (!identical(...future.workdir, getwd())) 
[08:25:47.963]             setwd(...future.workdir)
[08:25:47.963]         {
[08:25:47.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:47.963]                 ...future.oldOptions$nwarnings <- NULL
[08:25:47.963]             }
[08:25:47.963]             base::options(...future.oldOptions)
[08:25:47.963]             if (.Platform$OS.type == "windows") {
[08:25:47.963]                 old_names <- names(...future.oldEnvVars)
[08:25:47.963]                 envs <- base::Sys.getenv()
[08:25:47.963]                 names <- names(envs)
[08:25:47.963]                 common <- intersect(names, old_names)
[08:25:47.963]                 added <- setdiff(names, old_names)
[08:25:47.963]                 removed <- setdiff(old_names, names)
[08:25:47.963]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:47.963]                   envs[common]]
[08:25:47.963]                 NAMES <- toupper(changed)
[08:25:47.963]                 args <- list()
[08:25:47.963]                 for (kk in seq_along(NAMES)) {
[08:25:47.963]                   name <- changed[[kk]]
[08:25:47.963]                   NAME <- NAMES[[kk]]
[08:25:47.963]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.963]                     next
[08:25:47.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.963]                 }
[08:25:47.963]                 NAMES <- toupper(added)
[08:25:47.963]                 for (kk in seq_along(NAMES)) {
[08:25:47.963]                   name <- added[[kk]]
[08:25:47.963]                   NAME <- NAMES[[kk]]
[08:25:47.963]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.963]                     next
[08:25:47.963]                   args[[name]] <- ""
[08:25:47.963]                 }
[08:25:47.963]                 NAMES <- toupper(removed)
[08:25:47.963]                 for (kk in seq_along(NAMES)) {
[08:25:47.963]                   name <- removed[[kk]]
[08:25:47.963]                   NAME <- NAMES[[kk]]
[08:25:47.963]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:47.963]                     next
[08:25:47.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:47.963]                 }
[08:25:47.963]                 if (length(args) > 0) 
[08:25:47.963]                   base::do.call(base::Sys.setenv, args = args)
[08:25:47.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:47.963]             }
[08:25:47.963]             else {
[08:25:47.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:47.963]             }
[08:25:47.963]             {
[08:25:47.963]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:47.963]                   0L) {
[08:25:47.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:47.963]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:47.963]                   base::options(opts)
[08:25:47.963]                 }
[08:25:47.963]                 {
[08:25:47.963]                   {
[08:25:47.963]                     base::assign(".Random.seed", c(10407L, 1211850461L, 
[08:25:47.963]                     1008010542L, -1988403684L, -766378101L, -1508803277L, 
[08:25:47.963]                     1574915741L), envir = base::globalenv(), 
[08:25:47.963]                       inherits = FALSE)
[08:25:47.963]                     NULL
[08:25:47.963]                   }
[08:25:47.963]                   options(future.plan = NULL)
[08:25:47.963]                   if (is.na(NA_character_)) 
[08:25:47.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:47.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:47.963]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:47.963]                     .init = FALSE)
[08:25:47.963]                 }
[08:25:47.963]             }
[08:25:47.963]         }
[08:25:47.963]     })
[08:25:47.963]     if (TRUE) {
[08:25:47.963]         base::sink(type = "output", split = FALSE)
[08:25:47.963]         if (TRUE) {
[08:25:47.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:47.963]         }
[08:25:47.963]         else {
[08:25:47.963]             ...future.result["stdout"] <- base::list(NULL)
[08:25:47.963]         }
[08:25:47.963]         base::close(...future.stdout)
[08:25:47.963]         ...future.stdout <- NULL
[08:25:47.963]     }
[08:25:47.963]     ...future.result$conditions <- ...future.conditions
[08:25:47.963]     ...future.result$finished <- base::Sys.time()
[08:25:47.963]     ...future.result
[08:25:47.963] }
[08:25:47.965] assign_globals() ...
[08:25:47.965] List of 5
[08:25:47.965]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[08:25:47.965]  $ MoreArgs                 :List of 1
[08:25:47.965]   ..$ min: num 1
[08:25:47.965]  $ ...future.elements_ii    :List of 2
[08:25:47.965]   ..$ n  :List of 4
[08:25:47.965]   .. ..$ : int 1
[08:25:47.965]   .. ..$ : int 2
[08:25:47.965]   .. ..$ : int 3
[08:25:47.965]   .. ..$ : int 4
[08:25:47.965]   ..$ max:List of 4
[08:25:47.965]   .. ..$ : int 2
[08:25:47.965]   .. ..$ : int 3
[08:25:47.965]   .. ..$ : int 4
[08:25:47.965]   .. ..$ : int 5
[08:25:47.965]  $ ...future.seeds_ii       :List of 4
[08:25:47.965]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[08:25:47.965]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[08:25:47.965]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[08:25:47.965]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[08:25:47.965]  $ ...future.globals.maxSize: NULL
[08:25:47.965]  - attr(*, "where")=List of 5
[08:25:47.965]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:47.965]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:47.965]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:47.965]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:47.965]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:47.965]  - attr(*, "resolved")= logi FALSE
[08:25:47.965]  - attr(*, "total_size")= num 990
[08:25:47.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.965]  - attr(*, "already-done")= logi TRUE
[08:25:47.977] - copied ‘...future.FUN’ to environment
[08:25:47.977] - copied ‘MoreArgs’ to environment
[08:25:47.977] - copied ‘...future.elements_ii’ to environment
[08:25:47.977] - copied ‘...future.seeds_ii’ to environment
[08:25:47.977] - copied ‘...future.globals.maxSize’ to environment
[08:25:47.977] assign_globals() ... done
[08:25:47.978] plan(): Setting new future strategy stack:
[08:25:47.978] List of future strategies:
[08:25:47.978] 1. sequential:
[08:25:47.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.978]    - tweaked: FALSE
[08:25:47.978]    - call: NULL
[08:25:47.978] plan(): nbrOfWorkers() = 1
[08:25:47.979] plan(): Setting new future strategy stack:
[08:25:47.979] List of future strategies:
[08:25:47.979] 1. sequential:
[08:25:47.979]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:47.979]    - tweaked: FALSE
[08:25:47.979]    - call: plan(strategy)
[08:25:47.980] plan(): nbrOfWorkers() = 1
[08:25:47.980] SequentialFuture started (and completed)
[08:25:47.980] - Launch lazy future ... done
[08:25:47.980] run() for ‘SequentialFuture’ ... done
[08:25:47.980] Created future:
[08:25:47.980] SequentialFuture:
[08:25:47.980] Label: ‘future_mapply-1’
[08:25:47.980] Expression:
[08:25:47.980] {
[08:25:47.980]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:47.980]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:47.980]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:47.980]         on.exit(options(oopts), add = TRUE)
[08:25:47.980]     }
[08:25:47.980]     {
[08:25:47.980]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:47.980]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:47.980]                 inherits = FALSE)
[08:25:47.980]             ...future.FUN(...)
[08:25:47.980]         }
[08:25:47.980]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:47.980]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:47.980]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:47.980]         do.call(mapply, args = args)
[08:25:47.980]     }
[08:25:47.980] }
[08:25:47.980] Lazy evaluation: FALSE
[08:25:47.980] Asynchronous evaluation: FALSE
[08:25:47.980] Local evaluation: TRUE
[08:25:47.980] Environment: R_GlobalEnv
[08:25:47.980] Capture standard output: TRUE
[08:25:47.980] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:47.980] Globals: 5 objects totaling 990 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 196 bytes, list ‘...future.seeds_ii’ of 175 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:47.980] Packages: 1 packages (‘stats’)
[08:25:47.980] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:47.980] Resolved: TRUE
[08:25:47.980] Value: 143 bytes of class ‘list’
[08:25:47.980] Early signaling: FALSE
[08:25:47.980] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:47.980] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:47.981] Chunk #1 of 1 ... DONE
[08:25:47.981] Launching 1 futures (chunks) ... DONE
[08:25:47.981] Resolving 1 futures (chunks) ...
[08:25:47.981] resolve() on list ...
[08:25:47.982]  recursive: 0
[08:25:47.982]  length: 1
[08:25:47.982] 
[08:25:47.982] resolved() for ‘SequentialFuture’ ...
[08:25:47.982] - state: ‘finished’
[08:25:47.982] - run: TRUE
[08:25:47.982] - result: ‘FutureResult’
[08:25:47.982] resolved() for ‘SequentialFuture’ ... done
[08:25:47.982] Future #1
[08:25:47.982] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:47.983] - nx: 1
[08:25:47.983] - relay: TRUE
[08:25:47.983] - stdout: TRUE
[08:25:47.983] - signal: TRUE
[08:25:47.983] - resignal: FALSE
[08:25:47.983] - force: TRUE
[08:25:47.983] - relayed: [n=1] FALSE
[08:25:47.983] - queued futures: [n=1] FALSE
[08:25:47.983]  - until=1
[08:25:47.983]  - relaying element #1
[08:25:47.983] - relayed: [n=1] TRUE
[08:25:47.984] - queued futures: [n=1] TRUE
[08:25:47.984] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:47.984]  length: 0 (resolved future 1)
[08:25:47.984] Relaying remaining futures
[08:25:47.984] signalConditionsASAP(NULL, pos=0) ...
[08:25:47.984] - nx: 1
[08:25:47.984] - relay: TRUE
[08:25:47.984] - stdout: TRUE
[08:25:47.984] - signal: TRUE
[08:25:47.984] - resignal: FALSE
[08:25:47.984] - force: TRUE
[08:25:47.984] - relayed: [n=1] TRUE
[08:25:47.985] - queued futures: [n=1] TRUE
 - flush all
[08:25:47.985] - relayed: [n=1] TRUE
[08:25:47.985] - queued futures: [n=1] TRUE
[08:25:47.985] signalConditionsASAP(NULL, pos=0) ... done
[08:25:47.985] resolve() on list ... DONE
[08:25:47.985]  - Number of value chunks collected: 1
[08:25:47.985] Resolving 1 futures (chunks) ... DONE
[08:25:47.985] Reducing values from 1 chunks ...
[08:25:47.985]  - Number of values collected after concatenation: 4
[08:25:47.986]  - Number of values expected: 4
[08:25:47.986] Reducing values from 1 chunks ... DONE
[08:25:47.986] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[08:25:47.988] future_mapply() ...
[08:25:47.988] Number of chunks: 1
[08:25:47.988] getGlobalsAndPackagesXApply() ...
[08:25:47.989]  - future.globals: TRUE
[08:25:47.989] getGlobalsAndPackages() ...
[08:25:47.989] Searching for globals...
[08:25:47.990] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:25:47.990] Searching for globals ... DONE
[08:25:47.990] Resolving globals: FALSE
[08:25:47.990] The total size of the 1 globals is 337 bytes (337 bytes)
[08:25:47.991] The total size of the 1 globals exported for future expression (‘FUN()’) is 337 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (337 bytes of class ‘function’)
[08:25:47.991] - globals: [1] ‘FUN’
[08:25:47.991] - packages: [1] ‘stats’
[08:25:47.991] getGlobalsAndPackages() ... DONE
[08:25:47.991]  - globals found/used: [n=1] ‘FUN’
[08:25:47.991]  - needed namespaces: [n=1] ‘stats’
[08:25:47.992] Finding globals ... DONE
[08:25:47.992] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:47.992] List of 2
[08:25:47.992]  $ ...future.FUN:function (x, w, ...)  
[08:25:47.992]  $ MoreArgs     : NULL
[08:25:47.992]  - attr(*, "where")=List of 2
[08:25:47.992]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:47.992]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:47.992]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:47.992]  - attr(*, "resolved")= logi FALSE
[08:25:47.992]  - attr(*, "total_size")= num NA
[08:25:47.994] Packages to be attached in all futures: [n=1] ‘stats’
[08:25:47.995] getGlobalsAndPackagesXApply() ... DONE
[08:25:47.995] Number of futures (= number of chunks): 1
[08:25:47.995] Launching 1 futures (chunks) ...
[08:25:47.995] Chunk #1 of 1 ...
[08:25:47.995]  - Finding globals in '...' for chunk #1 ...
[08:25:47.995] getGlobalsAndPackages() ...
[08:25:47.995] Searching for globals...
[08:25:48.001] 
[08:25:48.001] Searching for globals ... DONE
[08:25:48.001] - globals: [0] <none>
[08:25:48.001] getGlobalsAndPackages() ... DONE
[08:25:48.001]    + additional globals found: [n=0] 
[08:25:48.001]    + additional namespaces needed: [n=0] 
[08:25:48.001]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:48.001]  - seeds: <none>
[08:25:48.002]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.002] getGlobalsAndPackages() ...
[08:25:48.002] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.002] Resolving globals: FALSE
[08:25:48.002] The total size of the 5 globals is 1.31 KiB (1345 bytes)
[08:25:48.003] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.31 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (927 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.003] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.003] - packages: [1] ‘stats’
[08:25:48.003] getGlobalsAndPackages() ... DONE
[08:25:48.004] run() for ‘Future’ ...
[08:25:48.004] - state: ‘created’
[08:25:48.004] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:48.004] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:48.005] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:48.005]   - Field: ‘label’
[08:25:48.005]   - Field: ‘local’
[08:25:48.005]   - Field: ‘owner’
[08:25:48.005]   - Field: ‘envir’
[08:25:48.005]   - Field: ‘packages’
[08:25:48.005]   - Field: ‘gc’
[08:25:48.005]   - Field: ‘conditions’
[08:25:48.005]   - Field: ‘expr’
[08:25:48.005]   - Field: ‘uuid’
[08:25:48.006]   - Field: ‘seed’
[08:25:48.006]   - Field: ‘version’
[08:25:48.006]   - Field: ‘result’
[08:25:48.006]   - Field: ‘asynchronous’
[08:25:48.006]   - Field: ‘calls’
[08:25:48.006]   - Field: ‘globals’
[08:25:48.006]   - Field: ‘stdout’
[08:25:48.006]   - Field: ‘earlySignal’
[08:25:48.007]   - Field: ‘lazy’
[08:25:48.007]   - Field: ‘state’
[08:25:48.007] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:48.007] - Launch lazy future ...
[08:25:48.007] Packages needed by the future expression (n = 1): ‘stats’
[08:25:48.007] Packages needed by future strategies (n = 0): <none>
[08:25:48.008] {
[08:25:48.008]     {
[08:25:48.008]         {
[08:25:48.008]             ...future.startTime <- base::Sys.time()
[08:25:48.008]             {
[08:25:48.008]                 {
[08:25:48.008]                   {
[08:25:48.008]                     {
[08:25:48.008]                       base::local({
[08:25:48.008]                         has_future <- base::requireNamespace("future", 
[08:25:48.008]                           quietly = TRUE)
[08:25:48.008]                         if (has_future) {
[08:25:48.008]                           ns <- base::getNamespace("future")
[08:25:48.008]                           version <- ns[[".package"]][["version"]]
[08:25:48.008]                           if (is.null(version)) 
[08:25:48.008]                             version <- utils::packageVersion("future")
[08:25:48.008]                         }
[08:25:48.008]                         else {
[08:25:48.008]                           version <- NULL
[08:25:48.008]                         }
[08:25:48.008]                         if (!has_future || version < "1.8.0") {
[08:25:48.008]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.008]                             "", base::R.version$version.string), 
[08:25:48.008]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.008]                               "release", "version")], collapse = " "), 
[08:25:48.008]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.008]                             info)
[08:25:48.008]                           info <- base::paste(info, collapse = "; ")
[08:25:48.008]                           if (!has_future) {
[08:25:48.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.008]                               info)
[08:25:48.008]                           }
[08:25:48.008]                           else {
[08:25:48.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.008]                               info, version)
[08:25:48.008]                           }
[08:25:48.008]                           base::stop(msg)
[08:25:48.008]                         }
[08:25:48.008]                       })
[08:25:48.008]                     }
[08:25:48.008]                     base::local({
[08:25:48.008]                       for (pkg in "stats") {
[08:25:48.008]                         base::loadNamespace(pkg)
[08:25:48.008]                         base::library(pkg, character.only = TRUE)
[08:25:48.008]                       }
[08:25:48.008]                     })
[08:25:48.008]                   }
[08:25:48.008]                   ...future.strategy.old <- future::plan("list")
[08:25:48.008]                   options(future.plan = NULL)
[08:25:48.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.008]                 }
[08:25:48.008]                 ...future.workdir <- getwd()
[08:25:48.008]             }
[08:25:48.008]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.008]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.008]         }
[08:25:48.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.008]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:48.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.008]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.008]             base::names(...future.oldOptions))
[08:25:48.008]     }
[08:25:48.008]     if (FALSE) {
[08:25:48.008]     }
[08:25:48.008]     else {
[08:25:48.008]         if (TRUE) {
[08:25:48.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.008]                 open = "w")
[08:25:48.008]         }
[08:25:48.008]         else {
[08:25:48.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.008]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.008]         }
[08:25:48.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.008]             base::sink(type = "output", split = FALSE)
[08:25:48.008]             base::close(...future.stdout)
[08:25:48.008]         }, add = TRUE)
[08:25:48.008]     }
[08:25:48.008]     ...future.frame <- base::sys.nframe()
[08:25:48.008]     ...future.conditions <- base::list()
[08:25:48.008]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.008]     if (FALSE) {
[08:25:48.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.008]     }
[08:25:48.008]     ...future.result <- base::tryCatch({
[08:25:48.008]         base::withCallingHandlers({
[08:25:48.008]             ...future.value <- base::withVisible(base::local({
[08:25:48.008]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.008]                 if (!identical(...future.globals.maxSize.org, 
[08:25:48.008]                   ...future.globals.maxSize)) {
[08:25:48.008]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.008]                   on.exit(options(oopts), add = TRUE)
[08:25:48.008]                 }
[08:25:48.008]                 {
[08:25:48.008]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.008]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.008]                     USE.NAMES = FALSE)
[08:25:48.008]                   do.call(mapply, args = args)
[08:25:48.008]                 }
[08:25:48.008]             }))
[08:25:48.008]             future::FutureResult(value = ...future.value$value, 
[08:25:48.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.008]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.008]                     ...future.globalenv.names))
[08:25:48.008]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.008]         }, condition = base::local({
[08:25:48.008]             c <- base::c
[08:25:48.008]             inherits <- base::inherits
[08:25:48.008]             invokeRestart <- base::invokeRestart
[08:25:48.008]             length <- base::length
[08:25:48.008]             list <- base::list
[08:25:48.008]             seq.int <- base::seq.int
[08:25:48.008]             signalCondition <- base::signalCondition
[08:25:48.008]             sys.calls <- base::sys.calls
[08:25:48.008]             `[[` <- base::`[[`
[08:25:48.008]             `+` <- base::`+`
[08:25:48.008]             `<<-` <- base::`<<-`
[08:25:48.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.008]                   3L)]
[08:25:48.008]             }
[08:25:48.008]             function(cond) {
[08:25:48.008]                 is_error <- inherits(cond, "error")
[08:25:48.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.008]                   NULL)
[08:25:48.008]                 if (is_error) {
[08:25:48.008]                   sessionInformation <- function() {
[08:25:48.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.008]                       search = base::search(), system = base::Sys.info())
[08:25:48.008]                   }
[08:25:48.008]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.008]                     cond$call), session = sessionInformation(), 
[08:25:48.008]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.008]                   signalCondition(cond)
[08:25:48.008]                 }
[08:25:48.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.008]                 "immediateCondition"))) {
[08:25:48.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.008]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.008]                   if (TRUE && !signal) {
[08:25:48.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.008]                     {
[08:25:48.008]                       inherits <- base::inherits
[08:25:48.008]                       invokeRestart <- base::invokeRestart
[08:25:48.008]                       is.null <- base::is.null
[08:25:48.008]                       muffled <- FALSE
[08:25:48.008]                       if (inherits(cond, "message")) {
[08:25:48.008]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.008]                         if (muffled) 
[08:25:48.008]                           invokeRestart("muffleMessage")
[08:25:48.008]                       }
[08:25:48.008]                       else if (inherits(cond, "warning")) {
[08:25:48.008]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.008]                         if (muffled) 
[08:25:48.008]                           invokeRestart("muffleWarning")
[08:25:48.008]                       }
[08:25:48.008]                       else if (inherits(cond, "condition")) {
[08:25:48.008]                         if (!is.null(pattern)) {
[08:25:48.008]                           computeRestarts <- base::computeRestarts
[08:25:48.008]                           grepl <- base::grepl
[08:25:48.008]                           restarts <- computeRestarts(cond)
[08:25:48.008]                           for (restart in restarts) {
[08:25:48.008]                             name <- restart$name
[08:25:48.008]                             if (is.null(name)) 
[08:25:48.008]                               next
[08:25:48.008]                             if (!grepl(pattern, name)) 
[08:25:48.008]                               next
[08:25:48.008]                             invokeRestart(restart)
[08:25:48.008]                             muffled <- TRUE
[08:25:48.008]                             break
[08:25:48.008]                           }
[08:25:48.008]                         }
[08:25:48.008]                       }
[08:25:48.008]                       invisible(muffled)
[08:25:48.008]                     }
[08:25:48.008]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.008]                   }
[08:25:48.008]                 }
[08:25:48.008]                 else {
[08:25:48.008]                   if (TRUE) {
[08:25:48.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.008]                     {
[08:25:48.008]                       inherits <- base::inherits
[08:25:48.008]                       invokeRestart <- base::invokeRestart
[08:25:48.008]                       is.null <- base::is.null
[08:25:48.008]                       muffled <- FALSE
[08:25:48.008]                       if (inherits(cond, "message")) {
[08:25:48.008]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.008]                         if (muffled) 
[08:25:48.008]                           invokeRestart("muffleMessage")
[08:25:48.008]                       }
[08:25:48.008]                       else if (inherits(cond, "warning")) {
[08:25:48.008]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.008]                         if (muffled) 
[08:25:48.008]                           invokeRestart("muffleWarning")
[08:25:48.008]                       }
[08:25:48.008]                       else if (inherits(cond, "condition")) {
[08:25:48.008]                         if (!is.null(pattern)) {
[08:25:48.008]                           computeRestarts <- base::computeRestarts
[08:25:48.008]                           grepl <- base::grepl
[08:25:48.008]                           restarts <- computeRestarts(cond)
[08:25:48.008]                           for (restart in restarts) {
[08:25:48.008]                             name <- restart$name
[08:25:48.008]                             if (is.null(name)) 
[08:25:48.008]                               next
[08:25:48.008]                             if (!grepl(pattern, name)) 
[08:25:48.008]                               next
[08:25:48.008]                             invokeRestart(restart)
[08:25:48.008]                             muffled <- TRUE
[08:25:48.008]                             break
[08:25:48.008]                           }
[08:25:48.008]                         }
[08:25:48.008]                       }
[08:25:48.008]                       invisible(muffled)
[08:25:48.008]                     }
[08:25:48.008]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.008]                   }
[08:25:48.008]                 }
[08:25:48.008]             }
[08:25:48.008]         }))
[08:25:48.008]     }, error = function(ex) {
[08:25:48.008]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.008]                 ...future.rng), started = ...future.startTime, 
[08:25:48.008]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.008]             version = "1.8"), class = "FutureResult")
[08:25:48.008]     }, finally = {
[08:25:48.008]         if (!identical(...future.workdir, getwd())) 
[08:25:48.008]             setwd(...future.workdir)
[08:25:48.008]         {
[08:25:48.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.008]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.008]             }
[08:25:48.008]             base::options(...future.oldOptions)
[08:25:48.008]             if (.Platform$OS.type == "windows") {
[08:25:48.008]                 old_names <- names(...future.oldEnvVars)
[08:25:48.008]                 envs <- base::Sys.getenv()
[08:25:48.008]                 names <- names(envs)
[08:25:48.008]                 common <- intersect(names, old_names)
[08:25:48.008]                 added <- setdiff(names, old_names)
[08:25:48.008]                 removed <- setdiff(old_names, names)
[08:25:48.008]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.008]                   envs[common]]
[08:25:48.008]                 NAMES <- toupper(changed)
[08:25:48.008]                 args <- list()
[08:25:48.008]                 for (kk in seq_along(NAMES)) {
[08:25:48.008]                   name <- changed[[kk]]
[08:25:48.008]                   NAME <- NAMES[[kk]]
[08:25:48.008]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.008]                     next
[08:25:48.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.008]                 }
[08:25:48.008]                 NAMES <- toupper(added)
[08:25:48.008]                 for (kk in seq_along(NAMES)) {
[08:25:48.008]                   name <- added[[kk]]
[08:25:48.008]                   NAME <- NAMES[[kk]]
[08:25:48.008]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.008]                     next
[08:25:48.008]                   args[[name]] <- ""
[08:25:48.008]                 }
[08:25:48.008]                 NAMES <- toupper(removed)
[08:25:48.008]                 for (kk in seq_along(NAMES)) {
[08:25:48.008]                   name <- removed[[kk]]
[08:25:48.008]                   NAME <- NAMES[[kk]]
[08:25:48.008]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.008]                     next
[08:25:48.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.008]                 }
[08:25:48.008]                 if (length(args) > 0) 
[08:25:48.008]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.008]             }
[08:25:48.008]             else {
[08:25:48.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.008]             }
[08:25:48.008]             {
[08:25:48.008]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.008]                   0L) {
[08:25:48.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.008]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.008]                   base::options(opts)
[08:25:48.008]                 }
[08:25:48.008]                 {
[08:25:48.008]                   {
[08:25:48.008]                     base::assign(".Random.seed", c(10407L, 1205823218L, 
[08:25:48.008]                     -1779069823L, 2029980239L, 971250804L, -262443150L, 
[08:25:48.008]                     -2128337370L), envir = base::globalenv(), 
[08:25:48.008]                       inherits = FALSE)
[08:25:48.008]                     NULL
[08:25:48.008]                   }
[08:25:48.008]                   options(future.plan = NULL)
[08:25:48.008]                   if (is.na(NA_character_)) 
[08:25:48.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.008]                     .init = FALSE)
[08:25:48.008]                 }
[08:25:48.008]             }
[08:25:48.008]         }
[08:25:48.008]     })
[08:25:48.008]     if (TRUE) {
[08:25:48.008]         base::sink(type = "output", split = FALSE)
[08:25:48.008]         if (TRUE) {
[08:25:48.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.008]         }
[08:25:48.008]         else {
[08:25:48.008]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.008]         }
[08:25:48.008]         base::close(...future.stdout)
[08:25:48.008]         ...future.stdout <- NULL
[08:25:48.008]     }
[08:25:48.008]     ...future.result$conditions <- ...future.conditions
[08:25:48.008]     ...future.result$finished <- base::Sys.time()
[08:25:48.008]     ...future.result
[08:25:48.008] }
[08:25:48.010] assign_globals() ...
[08:25:48.010] List of 5
[08:25:48.010]  $ ...future.FUN            :function (x, w, ...)  
[08:25:48.010]  $ MoreArgs                 : NULL
[08:25:48.010]  $ ...future.elements_ii    :List of 2
[08:25:48.010]   ..$ :List of 5
[08:25:48.010]   .. ..$ : num [1:10] 0.343 0.681 0.116 0.649 0.53 ...
[08:25:48.010]   .. ..$ : num [1:10] 0.105 0.149 0.317 0.149 0.517 ...
[08:25:48.010]   .. ..$ : num [1:10] 0.699 0.974 0.778 0.463 0.857 ...
[08:25:48.010]   .. ..$ : num [1:10] 0.1074 0.0348 0.3893 0.4042 0.1165 ...
[08:25:48.010]   .. ..$ : num [1:10] 0.3286 0.0407 0.6893 0.6024 0.4265 ...
[08:25:48.010]   ..$ :List of 5
[08:25:48.010]   .. ..$ : num [1:10] 4 4 6 6 6 7 7 5 5 9
[08:25:48.010]   .. ..$ : num [1:10] 2 8 7 5 4 9 9 6 8 6
[08:25:48.010]   .. ..$ : num [1:10] 10 7 2 5 1 6 5 8 8 8
[08:25:48.010]   .. ..$ : num [1:10] 4 5 4 10 4 5 4 3 8 8
[08:25:48.010]   .. ..$ : num [1:10] 10 6 4 5 8 7 6 3 7 11
[08:25:48.010]  $ ...future.seeds_ii       : NULL
[08:25:48.010]  $ ...future.globals.maxSize: NULL
[08:25:48.010]  - attr(*, "where")=List of 5
[08:25:48.010]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.010]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.010]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.010]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.010]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.010]  - attr(*, "resolved")= logi FALSE
[08:25:48.010]  - attr(*, "total_size")= num 1345
[08:25:48.010]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.010]  - attr(*, "already-done")= logi TRUE
[08:25:48.018] - copied ‘...future.FUN’ to environment
[08:25:48.018] - copied ‘MoreArgs’ to environment
[08:25:48.018] - copied ‘...future.elements_ii’ to environment
[08:25:48.018] - copied ‘...future.seeds_ii’ to environment
[08:25:48.018] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.018] assign_globals() ... done
[08:25:48.018] plan(): Setting new future strategy stack:
[08:25:48.019] List of future strategies:
[08:25:48.019] 1. sequential:
[08:25:48.019]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.019]    - tweaked: FALSE
[08:25:48.019]    - call: NULL
[08:25:48.019] plan(): nbrOfWorkers() = 1
[08:25:48.020] plan(): Setting new future strategy stack:
[08:25:48.020] List of future strategies:
[08:25:48.020] 1. sequential:
[08:25:48.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.020]    - tweaked: FALSE
[08:25:48.020]    - call: plan(strategy)
[08:25:48.020] plan(): nbrOfWorkers() = 1
[08:25:48.021] SequentialFuture started (and completed)
[08:25:48.021] - Launch lazy future ... done
[08:25:48.021] run() for ‘SequentialFuture’ ... done
[08:25:48.021] Created future:
[08:25:48.021] SequentialFuture:
[08:25:48.021] Label: ‘future_Map-1’
[08:25:48.021] Expression:
[08:25:48.021] {
[08:25:48.021]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.021]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.021]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.021]         on.exit(options(oopts), add = TRUE)
[08:25:48.021]     }
[08:25:48.021]     {
[08:25:48.021]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.021]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.021]         do.call(mapply, args = args)
[08:25:48.021]     }
[08:25:48.021] }
[08:25:48.021] Lazy evaluation: FALSE
[08:25:48.021] Asynchronous evaluation: FALSE
[08:25:48.021] Local evaluation: TRUE
[08:25:48.021] Environment: R_GlobalEnv
[08:25:48.021] Capture standard output: TRUE
[08:25:48.021] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.021] Globals: 5 objects totaling 1.31 KiB (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 927 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.021] Packages: 1 packages (‘stats’)
[08:25:48.021] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.021] Resolved: TRUE
[08:25:48.021] Value: 111 bytes of class ‘list’
[08:25:48.021] Early signaling: FALSE
[08:25:48.021] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.021] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:48.022] Chunk #1 of 1 ... DONE
[08:25:48.022] Launching 1 futures (chunks) ... DONE
[08:25:48.022] Resolving 1 futures (chunks) ...
[08:25:48.022] resolve() on list ...
[08:25:48.022]  recursive: 0
[08:25:48.022]  length: 1
[08:25:48.023] 
[08:25:48.023] resolved() for ‘SequentialFuture’ ...
[08:25:48.023] - state: ‘finished’
[08:25:48.023] - run: TRUE
[08:25:48.023] - result: ‘FutureResult’
[08:25:48.023] resolved() for ‘SequentialFuture’ ... done
[08:25:48.023] Future #1
[08:25:48.023] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:48.023] - nx: 1
[08:25:48.023] - relay: TRUE
[08:25:48.024] - stdout: TRUE
[08:25:48.024] - signal: TRUE
[08:25:48.024] - resignal: FALSE
[08:25:48.024] - force: TRUE
[08:25:48.024] - relayed: [n=1] FALSE
[08:25:48.024] - queued futures: [n=1] FALSE
[08:25:48.024]  - until=1
[08:25:48.024]  - relaying element #1
[08:25:48.024] - relayed: [n=1] TRUE
[08:25:48.024] - queued futures: [n=1] TRUE
[08:25:48.024] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:48.025]  length: 0 (resolved future 1)
[08:25:48.025] Relaying remaining futures
[08:25:48.025] signalConditionsASAP(NULL, pos=0) ...
[08:25:48.025] - nx: 1
[08:25:48.025] - relay: TRUE
[08:25:48.025] - stdout: TRUE
[08:25:48.025] - signal: TRUE
[08:25:48.025] - resignal: FALSE
[08:25:48.025] - force: TRUE
[08:25:48.025] - relayed: [n=1] TRUE
[08:25:48.025] - queued futures: [n=1] TRUE
 - flush all
[08:25:48.026] - relayed: [n=1] TRUE
[08:25:48.028] - queued futures: [n=1] TRUE
[08:25:48.028] signalConditionsASAP(NULL, pos=0) ... done
[08:25:48.028] resolve() on list ... DONE
[08:25:48.028]  - Number of value chunks collected: 1
[08:25:48.028] Resolving 1 futures (chunks) ... DONE
[08:25:48.028] Reducing values from 1 chunks ...
[08:25:48.029]  - Number of values collected after concatenation: 5
[08:25:48.029]  - Number of values expected: 5
[08:25:48.029] Reducing values from 1 chunks ... DONE
[08:25:48.029] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[08:25:48.031] future_mapply() ...
[08:25:48.031] Number of chunks: 1
[08:25:48.031] getGlobalsAndPackagesXApply() ...
[08:25:48.032]  - future.globals: TRUE
[08:25:48.032] getGlobalsAndPackages() ...
[08:25:48.032] Searching for globals...
[08:25:48.032] - globals found: [1] ‘FUN’
[08:25:48.033] Searching for globals ... DONE
[08:25:48.033] Resolving globals: FALSE
[08:25:48.033] The total size of the 1 globals is 32 bytes (32 bytes)
[08:25:48.033] The total size of the 1 globals exported for future expression (‘FUN()’) is 32 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (32 bytes of class ‘function’)
[08:25:48.033] - globals: [1] ‘FUN’
[08:25:48.034] 
[08:25:48.034] getGlobalsAndPackages() ... DONE
[08:25:48.034]  - globals found/used: [n=1] ‘FUN’
[08:25:48.034]  - needed namespaces: [n=0] 
[08:25:48.034] Finding globals ... DONE
[08:25:48.034] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:48.034] List of 2
[08:25:48.034]  $ ...future.FUN:function (e1, e2)  
[08:25:48.034]  $ MoreArgs     : NULL
[08:25:48.034]  - attr(*, "where")=List of 2
[08:25:48.034]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:48.034]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:48.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.034]  - attr(*, "resolved")= logi FALSE
[08:25:48.034]  - attr(*, "total_size")= num NA
[08:25:48.037] Packages to be attached in all futures: [n=0] 
[08:25:48.037] getGlobalsAndPackagesXApply() ... DONE
[08:25:48.037] Number of futures (= number of chunks): 1
[08:25:48.037] Launching 1 futures (chunks) ...
[08:25:48.037] Chunk #1 of 1 ...
[08:25:48.038]  - Finding globals in '...' for chunk #1 ...
[08:25:48.038] getGlobalsAndPackages() ...
[08:25:48.038] Searching for globals...
[08:25:48.038] 
[08:25:48.038] Searching for globals ... DONE
[08:25:48.038] - globals: [0] <none>
[08:25:48.038] getGlobalsAndPackages() ... DONE
[08:25:48.038]    + additional globals found: [n=0] 
[08:25:48.039]    + additional namespaces needed: [n=0] 
[08:25:48.039]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:48.039]  - seeds: <none>
[08:25:48.039]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.039] getGlobalsAndPackages() ...
[08:25:48.039] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.039] Resolving globals: FALSE
[08:25:48.040] The total size of the 5 globals is 244 bytes (244 bytes)
[08:25:48.040] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 244 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (131 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.040] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.040] 
[08:25:48.040] getGlobalsAndPackages() ... DONE
[08:25:48.041] run() for ‘Future’ ...
[08:25:48.041] - state: ‘created’
[08:25:48.041] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:48.041] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:48.041] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:48.041]   - Field: ‘label’
[08:25:48.042]   - Field: ‘local’
[08:25:48.042]   - Field: ‘owner’
[08:25:48.042]   - Field: ‘envir’
[08:25:48.042]   - Field: ‘packages’
[08:25:48.042]   - Field: ‘gc’
[08:25:48.042]   - Field: ‘conditions’
[08:25:48.042]   - Field: ‘expr’
[08:25:48.042]   - Field: ‘uuid’
[08:25:48.042]   - Field: ‘seed’
[08:25:48.042]   - Field: ‘version’
[08:25:48.042]   - Field: ‘result’
[08:25:48.043]   - Field: ‘asynchronous’
[08:25:48.043]   - Field: ‘calls’
[08:25:48.043]   - Field: ‘globals’
[08:25:48.043]   - Field: ‘stdout’
[08:25:48.043]   - Field: ‘earlySignal’
[08:25:48.043]   - Field: ‘lazy’
[08:25:48.043]   - Field: ‘state’
[08:25:48.043] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:48.043] - Launch lazy future ...
[08:25:48.043] Packages needed by the future expression (n = 0): <none>
[08:25:48.044] Packages needed by future strategies (n = 0): <none>
[08:25:48.044] {
[08:25:48.044]     {
[08:25:48.044]         {
[08:25:48.044]             ...future.startTime <- base::Sys.time()
[08:25:48.044]             {
[08:25:48.044]                 {
[08:25:48.044]                   {
[08:25:48.044]                     base::local({
[08:25:48.044]                       has_future <- base::requireNamespace("future", 
[08:25:48.044]                         quietly = TRUE)
[08:25:48.044]                       if (has_future) {
[08:25:48.044]                         ns <- base::getNamespace("future")
[08:25:48.044]                         version <- ns[[".package"]][["version"]]
[08:25:48.044]                         if (is.null(version)) 
[08:25:48.044]                           version <- utils::packageVersion("future")
[08:25:48.044]                       }
[08:25:48.044]                       else {
[08:25:48.044]                         version <- NULL
[08:25:48.044]                       }
[08:25:48.044]                       if (!has_future || version < "1.8.0") {
[08:25:48.044]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.044]                           "", base::R.version$version.string), 
[08:25:48.044]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:48.044]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.044]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.044]                             "release", "version")], collapse = " "), 
[08:25:48.044]                           hostname = base::Sys.info()[["nodename"]])
[08:25:48.044]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.044]                           info)
[08:25:48.044]                         info <- base::paste(info, collapse = "; ")
[08:25:48.044]                         if (!has_future) {
[08:25:48.044]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.044]                             info)
[08:25:48.044]                         }
[08:25:48.044]                         else {
[08:25:48.044]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.044]                             info, version)
[08:25:48.044]                         }
[08:25:48.044]                         base::stop(msg)
[08:25:48.044]                       }
[08:25:48.044]                     })
[08:25:48.044]                   }
[08:25:48.044]                   ...future.strategy.old <- future::plan("list")
[08:25:48.044]                   options(future.plan = NULL)
[08:25:48.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.044]                 }
[08:25:48.044]                 ...future.workdir <- getwd()
[08:25:48.044]             }
[08:25:48.044]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.044]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.044]         }
[08:25:48.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.044]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:48.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.044]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.044]             base::names(...future.oldOptions))
[08:25:48.044]     }
[08:25:48.044]     if (FALSE) {
[08:25:48.044]     }
[08:25:48.044]     else {
[08:25:48.044]         if (TRUE) {
[08:25:48.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.044]                 open = "w")
[08:25:48.044]         }
[08:25:48.044]         else {
[08:25:48.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.044]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.044]         }
[08:25:48.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.044]             base::sink(type = "output", split = FALSE)
[08:25:48.044]             base::close(...future.stdout)
[08:25:48.044]         }, add = TRUE)
[08:25:48.044]     }
[08:25:48.044]     ...future.frame <- base::sys.nframe()
[08:25:48.044]     ...future.conditions <- base::list()
[08:25:48.044]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.044]     if (FALSE) {
[08:25:48.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.044]     }
[08:25:48.044]     ...future.result <- base::tryCatch({
[08:25:48.044]         base::withCallingHandlers({
[08:25:48.044]             ...future.value <- base::withVisible(base::local({
[08:25:48.044]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.044]                 if (!identical(...future.globals.maxSize.org, 
[08:25:48.044]                   ...future.globals.maxSize)) {
[08:25:48.044]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.044]                   on.exit(options(oopts), add = TRUE)
[08:25:48.044]                 }
[08:25:48.044]                 {
[08:25:48.044]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.044]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.044]                     USE.NAMES = FALSE)
[08:25:48.044]                   do.call(mapply, args = args)
[08:25:48.044]                 }
[08:25:48.044]             }))
[08:25:48.044]             future::FutureResult(value = ...future.value$value, 
[08:25:48.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.044]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.044]                     ...future.globalenv.names))
[08:25:48.044]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.044]         }, condition = base::local({
[08:25:48.044]             c <- base::c
[08:25:48.044]             inherits <- base::inherits
[08:25:48.044]             invokeRestart <- base::invokeRestart
[08:25:48.044]             length <- base::length
[08:25:48.044]             list <- base::list
[08:25:48.044]             seq.int <- base::seq.int
[08:25:48.044]             signalCondition <- base::signalCondition
[08:25:48.044]             sys.calls <- base::sys.calls
[08:25:48.044]             `[[` <- base::`[[`
[08:25:48.044]             `+` <- base::`+`
[08:25:48.044]             `<<-` <- base::`<<-`
[08:25:48.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.044]                   3L)]
[08:25:48.044]             }
[08:25:48.044]             function(cond) {
[08:25:48.044]                 is_error <- inherits(cond, "error")
[08:25:48.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.044]                   NULL)
[08:25:48.044]                 if (is_error) {
[08:25:48.044]                   sessionInformation <- function() {
[08:25:48.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.044]                       search = base::search(), system = base::Sys.info())
[08:25:48.044]                   }
[08:25:48.044]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.044]                     cond$call), session = sessionInformation(), 
[08:25:48.044]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.044]                   signalCondition(cond)
[08:25:48.044]                 }
[08:25:48.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.044]                 "immediateCondition"))) {
[08:25:48.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.044]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.044]                   if (TRUE && !signal) {
[08:25:48.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.044]                     {
[08:25:48.044]                       inherits <- base::inherits
[08:25:48.044]                       invokeRestart <- base::invokeRestart
[08:25:48.044]                       is.null <- base::is.null
[08:25:48.044]                       muffled <- FALSE
[08:25:48.044]                       if (inherits(cond, "message")) {
[08:25:48.044]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.044]                         if (muffled) 
[08:25:48.044]                           invokeRestart("muffleMessage")
[08:25:48.044]                       }
[08:25:48.044]                       else if (inherits(cond, "warning")) {
[08:25:48.044]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.044]                         if (muffled) 
[08:25:48.044]                           invokeRestart("muffleWarning")
[08:25:48.044]                       }
[08:25:48.044]                       else if (inherits(cond, "condition")) {
[08:25:48.044]                         if (!is.null(pattern)) {
[08:25:48.044]                           computeRestarts <- base::computeRestarts
[08:25:48.044]                           grepl <- base::grepl
[08:25:48.044]                           restarts <- computeRestarts(cond)
[08:25:48.044]                           for (restart in restarts) {
[08:25:48.044]                             name <- restart$name
[08:25:48.044]                             if (is.null(name)) 
[08:25:48.044]                               next
[08:25:48.044]                             if (!grepl(pattern, name)) 
[08:25:48.044]                               next
[08:25:48.044]                             invokeRestart(restart)
[08:25:48.044]                             muffled <- TRUE
[08:25:48.044]                             break
[08:25:48.044]                           }
[08:25:48.044]                         }
[08:25:48.044]                       }
[08:25:48.044]                       invisible(muffled)
[08:25:48.044]                     }
[08:25:48.044]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.044]                   }
[08:25:48.044]                 }
[08:25:48.044]                 else {
[08:25:48.044]                   if (TRUE) {
[08:25:48.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.044]                     {
[08:25:48.044]                       inherits <- base::inherits
[08:25:48.044]                       invokeRestart <- base::invokeRestart
[08:25:48.044]                       is.null <- base::is.null
[08:25:48.044]                       muffled <- FALSE
[08:25:48.044]                       if (inherits(cond, "message")) {
[08:25:48.044]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.044]                         if (muffled) 
[08:25:48.044]                           invokeRestart("muffleMessage")
[08:25:48.044]                       }
[08:25:48.044]                       else if (inherits(cond, "warning")) {
[08:25:48.044]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.044]                         if (muffled) 
[08:25:48.044]                           invokeRestart("muffleWarning")
[08:25:48.044]                       }
[08:25:48.044]                       else if (inherits(cond, "condition")) {
[08:25:48.044]                         if (!is.null(pattern)) {
[08:25:48.044]                           computeRestarts <- base::computeRestarts
[08:25:48.044]                           grepl <- base::grepl
[08:25:48.044]                           restarts <- computeRestarts(cond)
[08:25:48.044]                           for (restart in restarts) {
[08:25:48.044]                             name <- restart$name
[08:25:48.044]                             if (is.null(name)) 
[08:25:48.044]                               next
[08:25:48.044]                             if (!grepl(pattern, name)) 
[08:25:48.044]                               next
[08:25:48.044]                             invokeRestart(restart)
[08:25:48.044]                             muffled <- TRUE
[08:25:48.044]                             break
[08:25:48.044]                           }
[08:25:48.044]                         }
[08:25:48.044]                       }
[08:25:48.044]                       invisible(muffled)
[08:25:48.044]                     }
[08:25:48.044]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.044]                   }
[08:25:48.044]                 }
[08:25:48.044]             }
[08:25:48.044]         }))
[08:25:48.044]     }, error = function(ex) {
[08:25:48.044]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.044]                 ...future.rng), started = ...future.startTime, 
[08:25:48.044]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.044]             version = "1.8"), class = "FutureResult")
[08:25:48.044]     }, finally = {
[08:25:48.044]         if (!identical(...future.workdir, getwd())) 
[08:25:48.044]             setwd(...future.workdir)
[08:25:48.044]         {
[08:25:48.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.044]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.044]             }
[08:25:48.044]             base::options(...future.oldOptions)
[08:25:48.044]             if (.Platform$OS.type == "windows") {
[08:25:48.044]                 old_names <- names(...future.oldEnvVars)
[08:25:48.044]                 envs <- base::Sys.getenv()
[08:25:48.044]                 names <- names(envs)
[08:25:48.044]                 common <- intersect(names, old_names)
[08:25:48.044]                 added <- setdiff(names, old_names)
[08:25:48.044]                 removed <- setdiff(old_names, names)
[08:25:48.044]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.044]                   envs[common]]
[08:25:48.044]                 NAMES <- toupper(changed)
[08:25:48.044]                 args <- list()
[08:25:48.044]                 for (kk in seq_along(NAMES)) {
[08:25:48.044]                   name <- changed[[kk]]
[08:25:48.044]                   NAME <- NAMES[[kk]]
[08:25:48.044]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.044]                     next
[08:25:48.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.044]                 }
[08:25:48.044]                 NAMES <- toupper(added)
[08:25:48.044]                 for (kk in seq_along(NAMES)) {
[08:25:48.044]                   name <- added[[kk]]
[08:25:48.044]                   NAME <- NAMES[[kk]]
[08:25:48.044]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.044]                     next
[08:25:48.044]                   args[[name]] <- ""
[08:25:48.044]                 }
[08:25:48.044]                 NAMES <- toupper(removed)
[08:25:48.044]                 for (kk in seq_along(NAMES)) {
[08:25:48.044]                   name <- removed[[kk]]
[08:25:48.044]                   NAME <- NAMES[[kk]]
[08:25:48.044]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.044]                     next
[08:25:48.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.044]                 }
[08:25:48.044]                 if (length(args) > 0) 
[08:25:48.044]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.044]             }
[08:25:48.044]             else {
[08:25:48.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.044]             }
[08:25:48.044]             {
[08:25:48.044]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.044]                   0L) {
[08:25:48.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.044]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.044]                   base::options(opts)
[08:25:48.044]                 }
[08:25:48.044]                 {
[08:25:48.044]                   {
[08:25:48.044]                     base::assign(".Random.seed", c(10407L, 1205823218L, 
[08:25:48.044]                     -1779069823L, 2029980239L, 971250804L, -262443150L, 
[08:25:48.044]                     -2128337370L), envir = base::globalenv(), 
[08:25:48.044]                       inherits = FALSE)
[08:25:48.044]                     NULL
[08:25:48.044]                   }
[08:25:48.044]                   options(future.plan = NULL)
[08:25:48.044]                   if (is.na(NA_character_)) 
[08:25:48.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.044]                     .init = FALSE)
[08:25:48.044]                 }
[08:25:48.044]             }
[08:25:48.044]         }
[08:25:48.044]     })
[08:25:48.044]     if (TRUE) {
[08:25:48.044]         base::sink(type = "output", split = FALSE)
[08:25:48.044]         if (TRUE) {
[08:25:48.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.044]         }
[08:25:48.044]         else {
[08:25:48.044]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.044]         }
[08:25:48.044]         base::close(...future.stdout)
[08:25:48.044]         ...future.stdout <- NULL
[08:25:48.044]     }
[08:25:48.044]     ...future.result$conditions <- ...future.conditions
[08:25:48.044]     ...future.result$finished <- base::Sys.time()
[08:25:48.044]     ...future.result
[08:25:48.044] }
[08:25:48.046] assign_globals() ...
[08:25:48.046] List of 5
[08:25:48.046]  $ ...future.FUN            :function (e1, e2)  
[08:25:48.046]  $ MoreArgs                 : NULL
[08:25:48.046]  $ ...future.elements_ii    :List of 2
[08:25:48.046]   ..$ :List of 3
[08:25:48.046]   .. ..$ : num 1
[08:25:48.046]   .. ..$ : num 1
[08:25:48.046]   .. ..$ : num 1
[08:25:48.046]   ..$ :List of 3
[08:25:48.046]   .. ..$ : int 1
[08:25:48.046]   .. ..$ : int 2
[08:25:48.046]   .. ..$ : int 3
[08:25:48.046]  $ ...future.seeds_ii       : NULL
[08:25:48.046]  $ ...future.globals.maxSize: NULL
[08:25:48.046]  - attr(*, "where")=List of 5
[08:25:48.046]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.046]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.046]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.046]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.046]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.046]  - attr(*, "resolved")= logi FALSE
[08:25:48.046]  - attr(*, "total_size")= num 244
[08:25:48.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.046]  - attr(*, "already-done")= logi TRUE
[08:25:48.053] - copied ‘...future.FUN’ to environment
[08:25:48.055] - copied ‘MoreArgs’ to environment
[08:25:48.055] - copied ‘...future.elements_ii’ to environment
[08:25:48.055] - copied ‘...future.seeds_ii’ to environment
[08:25:48.055] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.055] assign_globals() ... done
[08:25:48.056] plan(): Setting new future strategy stack:
[08:25:48.056] List of future strategies:
[08:25:48.056] 1. sequential:
[08:25:48.056]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.056]    - tweaked: FALSE
[08:25:48.056]    - call: NULL
[08:25:48.056] plan(): nbrOfWorkers() = 1
[08:25:48.057] plan(): Setting new future strategy stack:
[08:25:48.058] List of future strategies:
[08:25:48.058] 1. sequential:
[08:25:48.058]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.058]    - tweaked: FALSE
[08:25:48.058]    - call: plan(strategy)
[08:25:48.058] plan(): nbrOfWorkers() = 1
[08:25:48.058] SequentialFuture started (and completed)
[08:25:48.059] - Launch lazy future ... done
[08:25:48.059] run() for ‘SequentialFuture’ ... done
[08:25:48.059] Created future:
[08:25:48.059] SequentialFuture:
[08:25:48.059] Label: ‘future_Map-1’
[08:25:48.059] Expression:
[08:25:48.059] {
[08:25:48.059]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.059]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.059]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.059]         on.exit(options(oopts), add = TRUE)
[08:25:48.059]     }
[08:25:48.059]     {
[08:25:48.059]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.059]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.059]         do.call(mapply, args = args)
[08:25:48.059]     }
[08:25:48.059] }
[08:25:48.059] Lazy evaluation: FALSE
[08:25:48.059] Asynchronous evaluation: FALSE
[08:25:48.059] Local evaluation: TRUE
[08:25:48.059] Environment: R_GlobalEnv
[08:25:48.059] Capture standard output: TRUE
[08:25:48.059] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.059] Globals: 5 objects totaling 244 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 131 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.059] Packages: <none>
[08:25:48.059] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.059] Resolved: TRUE
[08:25:48.059] Value: 79 bytes of class ‘list’
[08:25:48.059] Early signaling: FALSE
[08:25:48.059] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.059] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:48.060] Chunk #1 of 1 ... DONE
[08:25:48.060] Launching 1 futures (chunks) ... DONE
[08:25:48.060] Resolving 1 futures (chunks) ...
[08:25:48.060] resolve() on list ...
[08:25:48.060]  recursive: 0
[08:25:48.060]  length: 1
[08:25:48.061] 
[08:25:48.061] resolved() for ‘SequentialFuture’ ...
[08:25:48.061] - state: ‘finished’
[08:25:48.061] - run: TRUE
[08:25:48.061] - result: ‘FutureResult’
[08:25:48.061] resolved() for ‘SequentialFuture’ ... done
[08:25:48.061] Future #1
[08:25:48.061] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:48.061] - nx: 1
[08:25:48.062] - relay: TRUE
[08:25:48.062] - stdout: TRUE
[08:25:48.062] - signal: TRUE
[08:25:48.062] - resignal: FALSE
[08:25:48.062] - force: TRUE
[08:25:48.062] - relayed: [n=1] FALSE
[08:25:48.062] - queued futures: [n=1] FALSE
[08:25:48.062]  - until=1
[08:25:48.062]  - relaying element #1
[08:25:48.062] - relayed: [n=1] TRUE
[08:25:48.063] - queued futures: [n=1] TRUE
[08:25:48.063] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:48.063]  length: 0 (resolved future 1)
[08:25:48.063] Relaying remaining futures
[08:25:48.063] signalConditionsASAP(NULL, pos=0) ...
[08:25:48.063] - nx: 1
[08:25:48.063] - relay: TRUE
[08:25:48.063] - stdout: TRUE
[08:25:48.063] - signal: TRUE
[08:25:48.063] - resignal: FALSE
[08:25:48.063] - force: TRUE
[08:25:48.063] - relayed: [n=1] TRUE
[08:25:48.064] - queued futures: [n=1] TRUE
 - flush all
[08:25:48.064] - relayed: [n=1] TRUE
[08:25:48.064] - queued futures: [n=1] TRUE
[08:25:48.064] signalConditionsASAP(NULL, pos=0) ... done
[08:25:48.064] resolve() on list ... DONE
[08:25:48.064]  - Number of value chunks collected: 1
[08:25:48.064] Resolving 1 futures (chunks) ... DONE
[08:25:48.064] Reducing values from 1 chunks ...
[08:25:48.064]  - Number of values collected after concatenation: 3
[08:25:48.065]  - Number of values expected: 3
[08:25:48.065] Reducing values from 1 chunks ... DONE
[08:25:48.065] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[08:25:48.065] future_mapply() ...
[08:25:48.065] Number of chunks: 1
[08:25:48.065] getGlobalsAndPackagesXApply() ...
[08:25:48.066]  - future.globals: TRUE
[08:25:48.066] getGlobalsAndPackages() ...
[08:25:48.066] Searching for globals...
[08:25:48.067] - globals found: [1] ‘FUN’
[08:25:48.067] Searching for globals ... DONE
[08:25:48.067] Resolving globals: FALSE
[08:25:48.067] The total size of the 1 globals is 185 bytes (185 bytes)
[08:25:48.068] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:25:48.068] - globals: [1] ‘FUN’
[08:25:48.068] 
[08:25:48.068] getGlobalsAndPackages() ... DONE
[08:25:48.068]  - globals found/used: [n=1] ‘FUN’
[08:25:48.068]  - needed namespaces: [n=0] 
[08:25:48.068] Finding globals ... DONE
[08:25:48.068] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:48.069] List of 2
[08:25:48.069]  $ ...future.FUN:function (x)  
[08:25:48.069]  $ MoreArgs     : NULL
[08:25:48.069]  - attr(*, "where")=List of 2
[08:25:48.069]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:48.069]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:48.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.069]  - attr(*, "resolved")= logi FALSE
[08:25:48.069]  - attr(*, "total_size")= num NA
[08:25:48.071] Packages to be attached in all futures: [n=0] 
[08:25:48.071] getGlobalsAndPackagesXApply() ... DONE
[08:25:48.072] Number of futures (= number of chunks): 1
[08:25:48.072] Launching 1 futures (chunks) ...
[08:25:48.072] Chunk #1 of 1 ...
[08:25:48.072]  - Finding globals in '...' for chunk #1 ...
[08:25:48.072] getGlobalsAndPackages() ...
[08:25:48.072] Searching for globals...
[08:25:48.073] 
[08:25:48.073] Searching for globals ... DONE
[08:25:48.073] - globals: [0] <none>
[08:25:48.073] getGlobalsAndPackages() ... DONE
[08:25:48.073]    + additional globals found: [n=0] 
[08:25:48.073]    + additional namespaces needed: [n=0] 
[08:25:48.073]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:48.073]  - seeds: <none>
[08:25:48.073]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.073] getGlobalsAndPackages() ...
[08:25:48.073] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.074] Resolving globals: FALSE
[08:25:48.074] The total size of the 5 globals is 388 bytes (388 bytes)
[08:25:48.074] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 388 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (122 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.075] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.075] 
[08:25:48.075] getGlobalsAndPackages() ... DONE
[08:25:48.075] run() for ‘Future’ ...
[08:25:48.075] - state: ‘created’
[08:25:48.075] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:25:48.076] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:48.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:25:48.076]   - Field: ‘label’
[08:25:48.076]   - Field: ‘local’
[08:25:48.076]   - Field: ‘owner’
[08:25:48.076]   - Field: ‘envir’
[08:25:48.076]   - Field: ‘packages’
[08:25:48.076]   - Field: ‘gc’
[08:25:48.076]   - Field: ‘conditions’
[08:25:48.077]   - Field: ‘expr’
[08:25:48.077]   - Field: ‘uuid’
[08:25:48.077]   - Field: ‘seed’
[08:25:48.077]   - Field: ‘version’
[08:25:48.077]   - Field: ‘result’
[08:25:48.077]   - Field: ‘asynchronous’
[08:25:48.077]   - Field: ‘calls’
[08:25:48.077]   - Field: ‘globals’
[08:25:48.077]   - Field: ‘stdout’
[08:25:48.077]   - Field: ‘earlySignal’
[08:25:48.077]   - Field: ‘lazy’
[08:25:48.078]   - Field: ‘state’
[08:25:48.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:25:48.078] - Launch lazy future ...
[08:25:48.078] Packages needed by the future expression (n = 0): <none>
[08:25:48.078] Packages needed by future strategies (n = 0): <none>
[08:25:48.079] {
[08:25:48.079]     {
[08:25:48.079]         {
[08:25:48.079]             ...future.startTime <- base::Sys.time()
[08:25:48.079]             {
[08:25:48.079]                 {
[08:25:48.079]                   {
[08:25:48.079]                     base::local({
[08:25:48.079]                       has_future <- base::requireNamespace("future", 
[08:25:48.079]                         quietly = TRUE)
[08:25:48.079]                       if (has_future) {
[08:25:48.079]                         ns <- base::getNamespace("future")
[08:25:48.079]                         version <- ns[[".package"]][["version"]]
[08:25:48.079]                         if (is.null(version)) 
[08:25:48.079]                           version <- utils::packageVersion("future")
[08:25:48.079]                       }
[08:25:48.079]                       else {
[08:25:48.079]                         version <- NULL
[08:25:48.079]                       }
[08:25:48.079]                       if (!has_future || version < "1.8.0") {
[08:25:48.079]                         info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.079]                           "", base::R.version$version.string), 
[08:25:48.079]                           platform = base::sprintf("%s (%s-bit)", 
[08:25:48.079]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.079]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.079]                             "release", "version")], collapse = " "), 
[08:25:48.079]                           hostname = base::Sys.info()[["nodename"]])
[08:25:48.079]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.079]                           info)
[08:25:48.079]                         info <- base::paste(info, collapse = "; ")
[08:25:48.079]                         if (!has_future) {
[08:25:48.079]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.079]                             info)
[08:25:48.079]                         }
[08:25:48.079]                         else {
[08:25:48.079]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.079]                             info, version)
[08:25:48.079]                         }
[08:25:48.079]                         base::stop(msg)
[08:25:48.079]                       }
[08:25:48.079]                     })
[08:25:48.079]                   }
[08:25:48.079]                   ...future.strategy.old <- future::plan("list")
[08:25:48.079]                   options(future.plan = NULL)
[08:25:48.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.079]                 }
[08:25:48.079]                 ...future.workdir <- getwd()
[08:25:48.079]             }
[08:25:48.079]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.079]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.079]         }
[08:25:48.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.079]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:48.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.079]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.079]             base::names(...future.oldOptions))
[08:25:48.079]     }
[08:25:48.079]     if (FALSE) {
[08:25:48.079]     }
[08:25:48.079]     else {
[08:25:48.079]         if (TRUE) {
[08:25:48.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.079]                 open = "w")
[08:25:48.079]         }
[08:25:48.079]         else {
[08:25:48.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.079]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.079]         }
[08:25:48.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.079]             base::sink(type = "output", split = FALSE)
[08:25:48.079]             base::close(...future.stdout)
[08:25:48.079]         }, add = TRUE)
[08:25:48.079]     }
[08:25:48.079]     ...future.frame <- base::sys.nframe()
[08:25:48.079]     ...future.conditions <- base::list()
[08:25:48.079]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.079]     if (FALSE) {
[08:25:48.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.079]     }
[08:25:48.079]     ...future.result <- base::tryCatch({
[08:25:48.079]         base::withCallingHandlers({
[08:25:48.079]             ...future.value <- base::withVisible(base::local({
[08:25:48.079]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.079]                 if (!identical(...future.globals.maxSize.org, 
[08:25:48.079]                   ...future.globals.maxSize)) {
[08:25:48.079]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.079]                   on.exit(options(oopts), add = TRUE)
[08:25:48.079]                 }
[08:25:48.079]                 {
[08:25:48.079]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.079]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.079]                     USE.NAMES = FALSE)
[08:25:48.079]                   do.call(mapply, args = args)
[08:25:48.079]                 }
[08:25:48.079]             }))
[08:25:48.079]             future::FutureResult(value = ...future.value$value, 
[08:25:48.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.079]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.079]                     ...future.globalenv.names))
[08:25:48.079]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.079]         }, condition = base::local({
[08:25:48.079]             c <- base::c
[08:25:48.079]             inherits <- base::inherits
[08:25:48.079]             invokeRestart <- base::invokeRestart
[08:25:48.079]             length <- base::length
[08:25:48.079]             list <- base::list
[08:25:48.079]             seq.int <- base::seq.int
[08:25:48.079]             signalCondition <- base::signalCondition
[08:25:48.079]             sys.calls <- base::sys.calls
[08:25:48.079]             `[[` <- base::`[[`
[08:25:48.079]             `+` <- base::`+`
[08:25:48.079]             `<<-` <- base::`<<-`
[08:25:48.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.079]                   3L)]
[08:25:48.079]             }
[08:25:48.079]             function(cond) {
[08:25:48.079]                 is_error <- inherits(cond, "error")
[08:25:48.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.079]                   NULL)
[08:25:48.079]                 if (is_error) {
[08:25:48.079]                   sessionInformation <- function() {
[08:25:48.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.079]                       search = base::search(), system = base::Sys.info())
[08:25:48.079]                   }
[08:25:48.079]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.079]                     cond$call), session = sessionInformation(), 
[08:25:48.079]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.079]                   signalCondition(cond)
[08:25:48.079]                 }
[08:25:48.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.079]                 "immediateCondition"))) {
[08:25:48.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.079]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.079]                   if (TRUE && !signal) {
[08:25:48.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.079]                     {
[08:25:48.079]                       inherits <- base::inherits
[08:25:48.079]                       invokeRestart <- base::invokeRestart
[08:25:48.079]                       is.null <- base::is.null
[08:25:48.079]                       muffled <- FALSE
[08:25:48.079]                       if (inherits(cond, "message")) {
[08:25:48.079]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.079]                         if (muffled) 
[08:25:48.079]                           invokeRestart("muffleMessage")
[08:25:48.079]                       }
[08:25:48.079]                       else if (inherits(cond, "warning")) {
[08:25:48.079]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.079]                         if (muffled) 
[08:25:48.079]                           invokeRestart("muffleWarning")
[08:25:48.079]                       }
[08:25:48.079]                       else if (inherits(cond, "condition")) {
[08:25:48.079]                         if (!is.null(pattern)) {
[08:25:48.079]                           computeRestarts <- base::computeRestarts
[08:25:48.079]                           grepl <- base::grepl
[08:25:48.079]                           restarts <- computeRestarts(cond)
[08:25:48.079]                           for (restart in restarts) {
[08:25:48.079]                             name <- restart$name
[08:25:48.079]                             if (is.null(name)) 
[08:25:48.079]                               next
[08:25:48.079]                             if (!grepl(pattern, name)) 
[08:25:48.079]                               next
[08:25:48.079]                             invokeRestart(restart)
[08:25:48.079]                             muffled <- TRUE
[08:25:48.079]                             break
[08:25:48.079]                           }
[08:25:48.079]                         }
[08:25:48.079]                       }
[08:25:48.079]                       invisible(muffled)
[08:25:48.079]                     }
[08:25:48.079]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.079]                   }
[08:25:48.079]                 }
[08:25:48.079]                 else {
[08:25:48.079]                   if (TRUE) {
[08:25:48.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.079]                     {
[08:25:48.079]                       inherits <- base::inherits
[08:25:48.079]                       invokeRestart <- base::invokeRestart
[08:25:48.079]                       is.null <- base::is.null
[08:25:48.079]                       muffled <- FALSE
[08:25:48.079]                       if (inherits(cond, "message")) {
[08:25:48.079]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.079]                         if (muffled) 
[08:25:48.079]                           invokeRestart("muffleMessage")
[08:25:48.079]                       }
[08:25:48.079]                       else if (inherits(cond, "warning")) {
[08:25:48.079]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.079]                         if (muffled) 
[08:25:48.079]                           invokeRestart("muffleWarning")
[08:25:48.079]                       }
[08:25:48.079]                       else if (inherits(cond, "condition")) {
[08:25:48.079]                         if (!is.null(pattern)) {
[08:25:48.079]                           computeRestarts <- base::computeRestarts
[08:25:48.079]                           grepl <- base::grepl
[08:25:48.079]                           restarts <- computeRestarts(cond)
[08:25:48.079]                           for (restart in restarts) {
[08:25:48.079]                             name <- restart$name
[08:25:48.079]                             if (is.null(name)) 
[08:25:48.079]                               next
[08:25:48.079]                             if (!grepl(pattern, name)) 
[08:25:48.079]                               next
[08:25:48.079]                             invokeRestart(restart)
[08:25:48.079]                             muffled <- TRUE
[08:25:48.079]                             break
[08:25:48.079]                           }
[08:25:48.079]                         }
[08:25:48.079]                       }
[08:25:48.079]                       invisible(muffled)
[08:25:48.079]                     }
[08:25:48.079]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.079]                   }
[08:25:48.079]                 }
[08:25:48.079]             }
[08:25:48.079]         }))
[08:25:48.079]     }, error = function(ex) {
[08:25:48.079]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.079]                 ...future.rng), started = ...future.startTime, 
[08:25:48.079]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.079]             version = "1.8"), class = "FutureResult")
[08:25:48.079]     }, finally = {
[08:25:48.079]         if (!identical(...future.workdir, getwd())) 
[08:25:48.079]             setwd(...future.workdir)
[08:25:48.079]         {
[08:25:48.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.079]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.079]             }
[08:25:48.079]             base::options(...future.oldOptions)
[08:25:48.079]             if (.Platform$OS.type == "windows") {
[08:25:48.079]                 old_names <- names(...future.oldEnvVars)
[08:25:48.079]                 envs <- base::Sys.getenv()
[08:25:48.079]                 names <- names(envs)
[08:25:48.079]                 common <- intersect(names, old_names)
[08:25:48.079]                 added <- setdiff(names, old_names)
[08:25:48.079]                 removed <- setdiff(old_names, names)
[08:25:48.079]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.079]                   envs[common]]
[08:25:48.079]                 NAMES <- toupper(changed)
[08:25:48.079]                 args <- list()
[08:25:48.079]                 for (kk in seq_along(NAMES)) {
[08:25:48.079]                   name <- changed[[kk]]
[08:25:48.079]                   NAME <- NAMES[[kk]]
[08:25:48.079]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.079]                     next
[08:25:48.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.079]                 }
[08:25:48.079]                 NAMES <- toupper(added)
[08:25:48.079]                 for (kk in seq_along(NAMES)) {
[08:25:48.079]                   name <- added[[kk]]
[08:25:48.079]                   NAME <- NAMES[[kk]]
[08:25:48.079]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.079]                     next
[08:25:48.079]                   args[[name]] <- ""
[08:25:48.079]                 }
[08:25:48.079]                 NAMES <- toupper(removed)
[08:25:48.079]                 for (kk in seq_along(NAMES)) {
[08:25:48.079]                   name <- removed[[kk]]
[08:25:48.079]                   NAME <- NAMES[[kk]]
[08:25:48.079]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.079]                     next
[08:25:48.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.079]                 }
[08:25:48.079]                 if (length(args) > 0) 
[08:25:48.079]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.079]             }
[08:25:48.079]             else {
[08:25:48.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.079]             }
[08:25:48.079]             {
[08:25:48.079]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.079]                   0L) {
[08:25:48.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.079]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.079]                   base::options(opts)
[08:25:48.079]                 }
[08:25:48.079]                 {
[08:25:48.079]                   {
[08:25:48.079]                     base::assign(".Random.seed", c(10407L, 1205823218L, 
[08:25:48.079]                     -1779069823L, 2029980239L, 971250804L, -262443150L, 
[08:25:48.079]                     -2128337370L), envir = base::globalenv(), 
[08:25:48.079]                       inherits = FALSE)
[08:25:48.079]                     NULL
[08:25:48.079]                   }
[08:25:48.079]                   options(future.plan = NULL)
[08:25:48.079]                   if (is.na(NA_character_)) 
[08:25:48.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.079]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.079]                     .init = FALSE)
[08:25:48.079]                 }
[08:25:48.079]             }
[08:25:48.079]         }
[08:25:48.079]     })
[08:25:48.079]     if (TRUE) {
[08:25:48.079]         base::sink(type = "output", split = FALSE)
[08:25:48.079]         if (TRUE) {
[08:25:48.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.079]         }
[08:25:48.079]         else {
[08:25:48.079]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.079]         }
[08:25:48.079]         base::close(...future.stdout)
[08:25:48.079]         ...future.stdout <- NULL
[08:25:48.079]     }
[08:25:48.079]     ...future.result$conditions <- ...future.conditions
[08:25:48.079]     ...future.result$finished <- base::Sys.time()
[08:25:48.079]     ...future.result
[08:25:48.079] }
[08:25:48.080] assign_globals() ...
[08:25:48.081] List of 5
[08:25:48.081]  $ ...future.FUN            :function (x)  
[08:25:48.081]  $ MoreArgs                 : NULL
[08:25:48.081]  $ ...future.elements_ii    :List of 1
[08:25:48.081]   ..$ :List of 2
[08:25:48.081]   .. ..$ a: num 0
[08:25:48.081]   .. ..$ b: num 0
[08:25:48.081]  $ ...future.seeds_ii       : NULL
[08:25:48.081]  $ ...future.globals.maxSize: NULL
[08:25:48.081]  - attr(*, "where")=List of 5
[08:25:48.081]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.081]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.081]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.081]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.081]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.081]  - attr(*, "resolved")= logi FALSE
[08:25:48.081]  - attr(*, "total_size")= num 388
[08:25:48.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.081]  - attr(*, "already-done")= logi TRUE
[08:25:48.089] - copied ‘...future.FUN’ to environment
[08:25:48.089] - copied ‘MoreArgs’ to environment
[08:25:48.089] - copied ‘...future.elements_ii’ to environment
[08:25:48.089] - copied ‘...future.seeds_ii’ to environment
[08:25:48.089] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.089] assign_globals() ... done
[08:25:48.089] plan(): Setting new future strategy stack:
[08:25:48.090] List of future strategies:
[08:25:48.090] 1. sequential:
[08:25:48.090]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.090]    - tweaked: FALSE
[08:25:48.090]    - call: NULL
[08:25:48.090] plan(): nbrOfWorkers() = 1
[08:25:48.091] plan(): Setting new future strategy stack:
[08:25:48.091] List of future strategies:
[08:25:48.091] 1. sequential:
[08:25:48.091]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.091]    - tweaked: FALSE
[08:25:48.091]    - call: plan(strategy)
[08:25:48.091] plan(): nbrOfWorkers() = 1
[08:25:48.092] SequentialFuture started (and completed)
[08:25:48.092] - Launch lazy future ... done
[08:25:48.092] run() for ‘SequentialFuture’ ... done
[08:25:48.092] Created future:
[08:25:48.092] SequentialFuture:
[08:25:48.092] Label: ‘future_mapply-1’
[08:25:48.092] Expression:
[08:25:48.092] {
[08:25:48.092]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.092]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.092]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.092]         on.exit(options(oopts), add = TRUE)
[08:25:48.092]     }
[08:25:48.092]     {
[08:25:48.092]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.092]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.092]         do.call(mapply, args = args)
[08:25:48.092]     }
[08:25:48.092] }
[08:25:48.092] Lazy evaluation: FALSE
[08:25:48.092] Asynchronous evaluation: FALSE
[08:25:48.092] Local evaluation: TRUE
[08:25:48.092] Environment: R_GlobalEnv
[08:25:48.092] Capture standard output: TRUE
[08:25:48.092] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.092] Globals: 5 objects totaling 388 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 122 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.092] Packages: <none>
[08:25:48.092] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.092] Resolved: TRUE
[08:25:48.092] Value: 63 bytes of class ‘list’
[08:25:48.092] Early signaling: FALSE
[08:25:48.092] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.092] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:25:48.093] Chunk #1 of 1 ... DONE
[08:25:48.093] Launching 1 futures (chunks) ... DONE
[08:25:48.093] Resolving 1 futures (chunks) ...
[08:25:48.093] resolve() on list ...
[08:25:48.093]  recursive: 0
[08:25:48.093]  length: 1
[08:25:48.093] 
[08:25:48.094] resolved() for ‘SequentialFuture’ ...
[08:25:48.094] - state: ‘finished’
[08:25:48.094] - run: TRUE
[08:25:48.094] - result: ‘FutureResult’
[08:25:48.094] resolved() for ‘SequentialFuture’ ... done
[08:25:48.094] Future #1
[08:25:48.094] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:25:48.094] - nx: 1
[08:25:48.094] - relay: TRUE
[08:25:48.094] - stdout: TRUE
[08:25:48.095] - signal: TRUE
[08:25:48.095] - resignal: FALSE
[08:25:48.095] - force: TRUE
[08:25:48.095] - relayed: [n=1] FALSE
[08:25:48.095] - queued futures: [n=1] FALSE
[08:25:48.095]  - until=1
[08:25:48.095]  - relaying element #1
[08:25:48.095] - relayed: [n=1] TRUE
[08:25:48.095] - queued futures: [n=1] TRUE
[08:25:48.095] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:25:48.096]  length: 0 (resolved future 1)
[08:25:48.096] Relaying remaining futures
[08:25:48.096] signalConditionsASAP(NULL, pos=0) ...
[08:25:48.096] - nx: 1
[08:25:48.096] - relay: TRUE
[08:25:48.096] - stdout: TRUE
[08:25:48.096] - signal: TRUE
[08:25:48.096] - resignal: FALSE
[08:25:48.096] - force: TRUE
[08:25:48.096] - relayed: [n=1] TRUE
[08:25:48.096] - queued futures: [n=1] TRUE
 - flush all
[08:25:48.097] - relayed: [n=1] TRUE
[08:25:48.097] - queued futures: [n=1] TRUE
[08:25:48.097] signalConditionsASAP(NULL, pos=0) ... done
[08:25:48.097] resolve() on list ... DONE
[08:25:48.097]  - Number of value chunks collected: 1
[08:25:48.097] Resolving 1 futures (chunks) ... DONE
[08:25:48.097] Reducing values from 1 chunks ...
[08:25:48.097]  - Number of values collected after concatenation: 2
[08:25:48.097]  - Number of values expected: 2
[08:25:48.097] Reducing values from 1 chunks ... DONE
[08:25:48.097] future_mapply() ... DONE
[08:25:48.098] plan(): Setting new future strategy stack:
[08:25:48.098] List of future strategies:
[08:25:48.098] 1. sequential:
[08:25:48.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.098]    - tweaked: FALSE
[08:25:48.098]    - call: plan(sequential)
[08:25:48.098] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[08:25:48.099] plan(): Setting new future strategy stack:
[08:25:48.099] List of future strategies:
[08:25:48.099] 1. multicore:
[08:25:48.099]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.099]    - tweaked: FALSE
[08:25:48.099]    - call: plan(strategy)
[08:25:48.101] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[08:25:48.101] future_mapply() ...
[08:25:48.102] Number of chunks: 2
[08:25:48.103] getGlobalsAndPackagesXApply() ...
[08:25:48.103]  - future.globals: TRUE
[08:25:48.103] getGlobalsAndPackages() ...
[08:25:48.103] Searching for globals...
[08:25:48.103] - globals found: [1] ‘FUN’
[08:25:48.104] Searching for globals ... DONE
[08:25:48.104] Resolving globals: FALSE
[08:25:48.104] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:48.104] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:48.104] - globals: [1] ‘FUN’
[08:25:48.105] 
[08:25:48.105] getGlobalsAndPackages() ... DONE
[08:25:48.105]  - globals found/used: [n=1] ‘FUN’
[08:25:48.105]  - needed namespaces: [n=0] 
[08:25:48.105] Finding globals ... DONE
[08:25:48.105] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:48.105] List of 2
[08:25:48.105]  $ ...future.FUN:function (x, ...)  
[08:25:48.105]  $ MoreArgs     : NULL
[08:25:48.105]  - attr(*, "where")=List of 2
[08:25:48.105]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:48.105]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:48.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.105]  - attr(*, "resolved")= logi FALSE
[08:25:48.105]  - attr(*, "total_size")= num NA
[08:25:48.110] Packages to be attached in all futures: [n=0] 
[08:25:48.110] getGlobalsAndPackagesXApply() ... DONE
[08:25:48.110] Number of futures (= number of chunks): 2
[08:25:48.110] Launching 2 futures (chunks) ...
[08:25:48.110] Chunk #1 of 2 ...
[08:25:48.111]  - Finding globals in '...' for chunk #1 ...
[08:25:48.111] getGlobalsAndPackages() ...
[08:25:48.111] Searching for globals...
[08:25:48.111] 
[08:25:48.111] Searching for globals ... DONE
[08:25:48.111] - globals: [0] <none>
[08:25:48.112] getGlobalsAndPackages() ... DONE
[08:25:48.112]    + additional globals found: [n=0] 
[08:25:48.112]    + additional namespaces needed: [n=0] 
[08:25:48.112]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:48.112]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.112]  - seeds: <none>
[08:25:48.112]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.112] getGlobalsAndPackages() ...
[08:25:48.112] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.113] Resolving globals: FALSE
[08:25:48.113] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:48.113] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.114] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.114] 
[08:25:48.114] getGlobalsAndPackages() ... DONE
[08:25:48.114] run() for ‘Future’ ...
[08:25:48.114] - state: ‘created’
[08:25:48.114] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.116] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.116]   - Field: ‘label’
[08:25:48.117]   - Field: ‘local’
[08:25:48.117]   - Field: ‘owner’
[08:25:48.117]   - Field: ‘envir’
[08:25:48.117]   - Field: ‘workers’
[08:25:48.117]   - Field: ‘packages’
[08:25:48.117]   - Field: ‘gc’
[08:25:48.117]   - Field: ‘job’
[08:25:48.117]   - Field: ‘conditions’
[08:25:48.117]   - Field: ‘expr’
[08:25:48.117]   - Field: ‘uuid’
[08:25:48.117]   - Field: ‘seed’
[08:25:48.118]   - Field: ‘version’
[08:25:48.118]   - Field: ‘result’
[08:25:48.118]   - Field: ‘asynchronous’
[08:25:48.118]   - Field: ‘calls’
[08:25:48.118]   - Field: ‘globals’
[08:25:48.118]   - Field: ‘stdout’
[08:25:48.118]   - Field: ‘earlySignal’
[08:25:48.118]   - Field: ‘lazy’
[08:25:48.118]   - Field: ‘state’
[08:25:48.118] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.118] - Launch lazy future ...
[08:25:48.120] Packages needed by the future expression (n = 0): <none>
[08:25:48.120] Packages needed by future strategies (n = 0): <none>
[08:25:48.120] {
[08:25:48.120]     {
[08:25:48.120]         {
[08:25:48.120]             ...future.startTime <- base::Sys.time()
[08:25:48.120]             {
[08:25:48.120]                 {
[08:25:48.120]                   {
[08:25:48.120]                     {
[08:25:48.120]                       base::local({
[08:25:48.120]                         has_future <- base::requireNamespace("future", 
[08:25:48.120]                           quietly = TRUE)
[08:25:48.120]                         if (has_future) {
[08:25:48.120]                           ns <- base::getNamespace("future")
[08:25:48.120]                           version <- ns[[".package"]][["version"]]
[08:25:48.120]                           if (is.null(version)) 
[08:25:48.120]                             version <- utils::packageVersion("future")
[08:25:48.120]                         }
[08:25:48.120]                         else {
[08:25:48.120]                           version <- NULL
[08:25:48.120]                         }
[08:25:48.120]                         if (!has_future || version < "1.8.0") {
[08:25:48.120]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.120]                             "", base::R.version$version.string), 
[08:25:48.120]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.120]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.120]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.120]                               "release", "version")], collapse = " "), 
[08:25:48.120]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.120]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.120]                             info)
[08:25:48.120]                           info <- base::paste(info, collapse = "; ")
[08:25:48.120]                           if (!has_future) {
[08:25:48.120]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.120]                               info)
[08:25:48.120]                           }
[08:25:48.120]                           else {
[08:25:48.120]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.120]                               info, version)
[08:25:48.120]                           }
[08:25:48.120]                           base::stop(msg)
[08:25:48.120]                         }
[08:25:48.120]                       })
[08:25:48.120]                     }
[08:25:48.120]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.120]                     base::options(mc.cores = 1L)
[08:25:48.120]                   }
[08:25:48.120]                   ...future.strategy.old <- future::plan("list")
[08:25:48.120]                   options(future.plan = NULL)
[08:25:48.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.120]                 }
[08:25:48.120]                 ...future.workdir <- getwd()
[08:25:48.120]             }
[08:25:48.120]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.120]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.120]         }
[08:25:48.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.120]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.120]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.120]             base::names(...future.oldOptions))
[08:25:48.120]     }
[08:25:48.120]     if (FALSE) {
[08:25:48.120]     }
[08:25:48.120]     else {
[08:25:48.120]         if (TRUE) {
[08:25:48.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.120]                 open = "w")
[08:25:48.120]         }
[08:25:48.120]         else {
[08:25:48.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.120]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.120]         }
[08:25:48.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.120]             base::sink(type = "output", split = FALSE)
[08:25:48.120]             base::close(...future.stdout)
[08:25:48.120]         }, add = TRUE)
[08:25:48.120]     }
[08:25:48.120]     ...future.frame <- base::sys.nframe()
[08:25:48.120]     ...future.conditions <- base::list()
[08:25:48.120]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.120]     if (FALSE) {
[08:25:48.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.120]     }
[08:25:48.120]     ...future.result <- base::tryCatch({
[08:25:48.120]         base::withCallingHandlers({
[08:25:48.120]             ...future.value <- base::withVisible(base::local({
[08:25:48.120]                 withCallingHandlers({
[08:25:48.120]                   {
[08:25:48.120]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.120]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.120]                       ...future.globals.maxSize)) {
[08:25:48.120]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.120]                       on.exit(options(oopts), add = TRUE)
[08:25:48.120]                     }
[08:25:48.120]                     {
[08:25:48.120]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.120]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.120]                         USE.NAMES = FALSE)
[08:25:48.120]                       do.call(mapply, args = args)
[08:25:48.120]                     }
[08:25:48.120]                   }
[08:25:48.120]                 }, immediateCondition = function(cond) {
[08:25:48.120]                   save_rds <- function (object, pathname, ...) 
[08:25:48.120]                   {
[08:25:48.120]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.120]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.120]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.120]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.120]                         fi_tmp[["mtime"]])
[08:25:48.120]                     }
[08:25:48.120]                     tryCatch({
[08:25:48.120]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.120]                     }, error = function(ex) {
[08:25:48.120]                       msg <- conditionMessage(ex)
[08:25:48.120]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.120]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.120]                         fi_tmp[["mtime"]], msg)
[08:25:48.120]                       ex$message <- msg
[08:25:48.120]                       stop(ex)
[08:25:48.120]                     })
[08:25:48.120]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.120]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.120]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.120]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.120]                       fi <- file.info(pathname)
[08:25:48.120]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.120]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.120]                         fi[["size"]], fi[["mtime"]])
[08:25:48.120]                       stop(msg)
[08:25:48.120]                     }
[08:25:48.120]                     invisible(pathname)
[08:25:48.120]                   }
[08:25:48.120]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.120]                     rootPath = tempdir()) 
[08:25:48.120]                   {
[08:25:48.120]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.120]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.120]                       tmpdir = path, fileext = ".rds")
[08:25:48.120]                     save_rds(obj, file)
[08:25:48.120]                   }
[08:25:48.120]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.120]                   {
[08:25:48.120]                     inherits <- base::inherits
[08:25:48.120]                     invokeRestart <- base::invokeRestart
[08:25:48.120]                     is.null <- base::is.null
[08:25:48.120]                     muffled <- FALSE
[08:25:48.120]                     if (inherits(cond, "message")) {
[08:25:48.120]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.120]                       if (muffled) 
[08:25:48.120]                         invokeRestart("muffleMessage")
[08:25:48.120]                     }
[08:25:48.120]                     else if (inherits(cond, "warning")) {
[08:25:48.120]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.120]                       if (muffled) 
[08:25:48.120]                         invokeRestart("muffleWarning")
[08:25:48.120]                     }
[08:25:48.120]                     else if (inherits(cond, "condition")) {
[08:25:48.120]                       if (!is.null(pattern)) {
[08:25:48.120]                         computeRestarts <- base::computeRestarts
[08:25:48.120]                         grepl <- base::grepl
[08:25:48.120]                         restarts <- computeRestarts(cond)
[08:25:48.120]                         for (restart in restarts) {
[08:25:48.120]                           name <- restart$name
[08:25:48.120]                           if (is.null(name)) 
[08:25:48.120]                             next
[08:25:48.120]                           if (!grepl(pattern, name)) 
[08:25:48.120]                             next
[08:25:48.120]                           invokeRestart(restart)
[08:25:48.120]                           muffled <- TRUE
[08:25:48.120]                           break
[08:25:48.120]                         }
[08:25:48.120]                       }
[08:25:48.120]                     }
[08:25:48.120]                     invisible(muffled)
[08:25:48.120]                   }
[08:25:48.120]                   muffleCondition(cond)
[08:25:48.120]                 })
[08:25:48.120]             }))
[08:25:48.120]             future::FutureResult(value = ...future.value$value, 
[08:25:48.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.120]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.120]                     ...future.globalenv.names))
[08:25:48.120]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.120]         }, condition = base::local({
[08:25:48.120]             c <- base::c
[08:25:48.120]             inherits <- base::inherits
[08:25:48.120]             invokeRestart <- base::invokeRestart
[08:25:48.120]             length <- base::length
[08:25:48.120]             list <- base::list
[08:25:48.120]             seq.int <- base::seq.int
[08:25:48.120]             signalCondition <- base::signalCondition
[08:25:48.120]             sys.calls <- base::sys.calls
[08:25:48.120]             `[[` <- base::`[[`
[08:25:48.120]             `+` <- base::`+`
[08:25:48.120]             `<<-` <- base::`<<-`
[08:25:48.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.120]                   3L)]
[08:25:48.120]             }
[08:25:48.120]             function(cond) {
[08:25:48.120]                 is_error <- inherits(cond, "error")
[08:25:48.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.120]                   NULL)
[08:25:48.120]                 if (is_error) {
[08:25:48.120]                   sessionInformation <- function() {
[08:25:48.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.120]                       search = base::search(), system = base::Sys.info())
[08:25:48.120]                   }
[08:25:48.120]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.120]                     cond$call), session = sessionInformation(), 
[08:25:48.120]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.120]                   signalCondition(cond)
[08:25:48.120]                 }
[08:25:48.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.120]                 "immediateCondition"))) {
[08:25:48.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.120]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.120]                   if (TRUE && !signal) {
[08:25:48.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.120]                     {
[08:25:48.120]                       inherits <- base::inherits
[08:25:48.120]                       invokeRestart <- base::invokeRestart
[08:25:48.120]                       is.null <- base::is.null
[08:25:48.120]                       muffled <- FALSE
[08:25:48.120]                       if (inherits(cond, "message")) {
[08:25:48.120]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.120]                         if (muffled) 
[08:25:48.120]                           invokeRestart("muffleMessage")
[08:25:48.120]                       }
[08:25:48.120]                       else if (inherits(cond, "warning")) {
[08:25:48.120]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.120]                         if (muffled) 
[08:25:48.120]                           invokeRestart("muffleWarning")
[08:25:48.120]                       }
[08:25:48.120]                       else if (inherits(cond, "condition")) {
[08:25:48.120]                         if (!is.null(pattern)) {
[08:25:48.120]                           computeRestarts <- base::computeRestarts
[08:25:48.120]                           grepl <- base::grepl
[08:25:48.120]                           restarts <- computeRestarts(cond)
[08:25:48.120]                           for (restart in restarts) {
[08:25:48.120]                             name <- restart$name
[08:25:48.120]                             if (is.null(name)) 
[08:25:48.120]                               next
[08:25:48.120]                             if (!grepl(pattern, name)) 
[08:25:48.120]                               next
[08:25:48.120]                             invokeRestart(restart)
[08:25:48.120]                             muffled <- TRUE
[08:25:48.120]                             break
[08:25:48.120]                           }
[08:25:48.120]                         }
[08:25:48.120]                       }
[08:25:48.120]                       invisible(muffled)
[08:25:48.120]                     }
[08:25:48.120]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.120]                   }
[08:25:48.120]                 }
[08:25:48.120]                 else {
[08:25:48.120]                   if (TRUE) {
[08:25:48.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.120]                     {
[08:25:48.120]                       inherits <- base::inherits
[08:25:48.120]                       invokeRestart <- base::invokeRestart
[08:25:48.120]                       is.null <- base::is.null
[08:25:48.120]                       muffled <- FALSE
[08:25:48.120]                       if (inherits(cond, "message")) {
[08:25:48.120]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.120]                         if (muffled) 
[08:25:48.120]                           invokeRestart("muffleMessage")
[08:25:48.120]                       }
[08:25:48.120]                       else if (inherits(cond, "warning")) {
[08:25:48.120]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.120]                         if (muffled) 
[08:25:48.120]                           invokeRestart("muffleWarning")
[08:25:48.120]                       }
[08:25:48.120]                       else if (inherits(cond, "condition")) {
[08:25:48.120]                         if (!is.null(pattern)) {
[08:25:48.120]                           computeRestarts <- base::computeRestarts
[08:25:48.120]                           grepl <- base::grepl
[08:25:48.120]                           restarts <- computeRestarts(cond)
[08:25:48.120]                           for (restart in restarts) {
[08:25:48.120]                             name <- restart$name
[08:25:48.120]                             if (is.null(name)) 
[08:25:48.120]                               next
[08:25:48.120]                             if (!grepl(pattern, name)) 
[08:25:48.120]                               next
[08:25:48.120]                             invokeRestart(restart)
[08:25:48.120]                             muffled <- TRUE
[08:25:48.120]                             break
[08:25:48.120]                           }
[08:25:48.120]                         }
[08:25:48.120]                       }
[08:25:48.120]                       invisible(muffled)
[08:25:48.120]                     }
[08:25:48.120]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.120]                   }
[08:25:48.120]                 }
[08:25:48.120]             }
[08:25:48.120]         }))
[08:25:48.120]     }, error = function(ex) {
[08:25:48.120]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.120]                 ...future.rng), started = ...future.startTime, 
[08:25:48.120]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.120]             version = "1.8"), class = "FutureResult")
[08:25:48.120]     }, finally = {
[08:25:48.120]         if (!identical(...future.workdir, getwd())) 
[08:25:48.120]             setwd(...future.workdir)
[08:25:48.120]         {
[08:25:48.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.120]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.120]             }
[08:25:48.120]             base::options(...future.oldOptions)
[08:25:48.120]             if (.Platform$OS.type == "windows") {
[08:25:48.120]                 old_names <- names(...future.oldEnvVars)
[08:25:48.120]                 envs <- base::Sys.getenv()
[08:25:48.120]                 names <- names(envs)
[08:25:48.120]                 common <- intersect(names, old_names)
[08:25:48.120]                 added <- setdiff(names, old_names)
[08:25:48.120]                 removed <- setdiff(old_names, names)
[08:25:48.120]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.120]                   envs[common]]
[08:25:48.120]                 NAMES <- toupper(changed)
[08:25:48.120]                 args <- list()
[08:25:48.120]                 for (kk in seq_along(NAMES)) {
[08:25:48.120]                   name <- changed[[kk]]
[08:25:48.120]                   NAME <- NAMES[[kk]]
[08:25:48.120]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.120]                     next
[08:25:48.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.120]                 }
[08:25:48.120]                 NAMES <- toupper(added)
[08:25:48.120]                 for (kk in seq_along(NAMES)) {
[08:25:48.120]                   name <- added[[kk]]
[08:25:48.120]                   NAME <- NAMES[[kk]]
[08:25:48.120]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.120]                     next
[08:25:48.120]                   args[[name]] <- ""
[08:25:48.120]                 }
[08:25:48.120]                 NAMES <- toupper(removed)
[08:25:48.120]                 for (kk in seq_along(NAMES)) {
[08:25:48.120]                   name <- removed[[kk]]
[08:25:48.120]                   NAME <- NAMES[[kk]]
[08:25:48.120]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.120]                     next
[08:25:48.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.120]                 }
[08:25:48.120]                 if (length(args) > 0) 
[08:25:48.120]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.120]             }
[08:25:48.120]             else {
[08:25:48.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.120]             }
[08:25:48.120]             {
[08:25:48.120]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.120]                   0L) {
[08:25:48.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.120]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.120]                   base::options(opts)
[08:25:48.120]                 }
[08:25:48.120]                 {
[08:25:48.120]                   {
[08:25:48.120]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.120]                     NULL
[08:25:48.120]                   }
[08:25:48.120]                   options(future.plan = NULL)
[08:25:48.120]                   if (is.na(NA_character_)) 
[08:25:48.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.120]                     .init = FALSE)
[08:25:48.120]                 }
[08:25:48.120]             }
[08:25:48.120]         }
[08:25:48.120]     })
[08:25:48.120]     if (TRUE) {
[08:25:48.120]         base::sink(type = "output", split = FALSE)
[08:25:48.120]         if (TRUE) {
[08:25:48.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.120]         }
[08:25:48.120]         else {
[08:25:48.120]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.120]         }
[08:25:48.120]         base::close(...future.stdout)
[08:25:48.120]         ...future.stdout <- NULL
[08:25:48.120]     }
[08:25:48.120]     ...future.result$conditions <- ...future.conditions
[08:25:48.120]     ...future.result$finished <- base::Sys.time()
[08:25:48.120]     ...future.result
[08:25:48.120] }
[08:25:48.123] assign_globals() ...
[08:25:48.123] List of 5
[08:25:48.123]  $ ...future.FUN            :function (x, ...)  
[08:25:48.123]  $ MoreArgs                 : NULL
[08:25:48.123]  $ ...future.elements_ii    :List of 2
[08:25:48.123]   ..$ :List of 2
[08:25:48.123]   .. ..$ : int 1
[08:25:48.123]   .. ..$ : int 2
[08:25:48.123]   ..$ :List of 2
[08:25:48.123]   .. ..$ : int 4
[08:25:48.123]   .. ..$ : int 3
[08:25:48.123]  $ ...future.seeds_ii       : NULL
[08:25:48.123]  $ ...future.globals.maxSize: NULL
[08:25:48.123]  - attr(*, "where")=List of 5
[08:25:48.123]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.123]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.123]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.123]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.123]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.123]  - attr(*, "resolved")= logi FALSE
[08:25:48.123]  - attr(*, "total_size")= num 210
[08:25:48.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.123]  - attr(*, "already-done")= logi TRUE
[08:25:48.128] - copied ‘...future.FUN’ to environment
[08:25:48.128] - copied ‘MoreArgs’ to environment
[08:25:48.128] - copied ‘...future.elements_ii’ to environment
[08:25:48.129] - copied ‘...future.seeds_ii’ to environment
[08:25:48.129] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.129] assign_globals() ... done
[08:25:48.129] requestCore(): workers = 2
[08:25:48.132] MulticoreFuture started
[08:25:48.133] - Launch lazy future ... done
[08:25:48.133] plan(): Setting new future strategy stack:
[08:25:48.133] run() for ‘MulticoreFuture’ ... done
[08:25:48.133] Created future:
[08:25:48.133] List of future strategies:
[08:25:48.133] 1. sequential:
[08:25:48.133]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.133]    - tweaked: FALSE
[08:25:48.133]    - call: NULL
[08:25:48.134] plan(): nbrOfWorkers() = 1
[08:25:48.137] plan(): Setting new future strategy stack:
[08:25:48.137] List of future strategies:
[08:25:48.137] 1. multicore:
[08:25:48.137]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.137]    - tweaked: FALSE
[08:25:48.137]    - call: plan(strategy)
[08:25:48.140] plan(): nbrOfWorkers() = 2
[08:25:48.134] MulticoreFuture:
[08:25:48.134] Label: ‘future_mapply-1’
[08:25:48.134] Expression:
[08:25:48.134] {
[08:25:48.134]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.134]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.134]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.134]         on.exit(options(oopts), add = TRUE)
[08:25:48.134]     }
[08:25:48.134]     {
[08:25:48.134]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.134]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.134]         do.call(mapply, args = args)
[08:25:48.134]     }
[08:25:48.134] }
[08:25:48.134] Lazy evaluation: FALSE
[08:25:48.134] Asynchronous evaluation: TRUE
[08:25:48.134] Local evaluation: TRUE
[08:25:48.134] Environment: R_GlobalEnv
[08:25:48.134] Capture standard output: TRUE
[08:25:48.134] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.134] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.134] Packages: <none>
[08:25:48.134] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.134] Resolved: TRUE
[08:25:48.134] Value: <not collected>
[08:25:48.134] Conditions captured: <none>
[08:25:48.134] Early signaling: FALSE
[08:25:48.134] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.134] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.142] Chunk #1 of 2 ... DONE
[08:25:48.142] Chunk #2 of 2 ...
[08:25:48.142]  - Finding globals in '...' for chunk #2 ...
[08:25:48.142] getGlobalsAndPackages() ...
[08:25:48.142] Searching for globals...
[08:25:48.143] 
[08:25:48.143] Searching for globals ... DONE
[08:25:48.143] - globals: [0] <none>
[08:25:48.143] getGlobalsAndPackages() ... DONE
[08:25:48.144]    + additional globals found: [n=0] 
[08:25:48.144]    + additional namespaces needed: [n=0] 
[08:25:48.144]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:48.144]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.144]  - seeds: <none>
[08:25:48.144]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.145] getGlobalsAndPackages() ...
[08:25:48.145] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.145] Resolving globals: FALSE
[08:25:48.146] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:48.147] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.147] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.148] 
[08:25:48.148] getGlobalsAndPackages() ... DONE
[08:25:48.148] run() for ‘Future’ ...
[08:25:48.149] - state: ‘created’
[08:25:48.149] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.160] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.161]   - Field: ‘label’
[08:25:48.161]   - Field: ‘local’
[08:25:48.162]   - Field: ‘owner’
[08:25:48.162]   - Field: ‘envir’
[08:25:48.162]   - Field: ‘workers’
[08:25:48.163]   - Field: ‘packages’
[08:25:48.163]   - Field: ‘gc’
[08:25:48.163]   - Field: ‘job’
[08:25:48.164]   - Field: ‘conditions’
[08:25:48.164]   - Field: ‘expr’
[08:25:48.164]   - Field: ‘uuid’
[08:25:48.165]   - Field: ‘seed’
[08:25:48.165]   - Field: ‘version’
[08:25:48.165]   - Field: ‘result’
[08:25:48.166]   - Field: ‘asynchronous’
[08:25:48.166]   - Field: ‘calls’
[08:25:48.166]   - Field: ‘globals’
[08:25:48.167]   - Field: ‘stdout’
[08:25:48.167]   - Field: ‘earlySignal’
[08:25:48.167]   - Field: ‘lazy’
[08:25:48.168]   - Field: ‘state’
[08:25:48.168] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.168] - Launch lazy future ...
[08:25:48.169] Packages needed by the future expression (n = 0): <none>
[08:25:48.169] Packages needed by future strategies (n = 0): <none>
[08:25:48.170] {
[08:25:48.170]     {
[08:25:48.170]         {
[08:25:48.170]             ...future.startTime <- base::Sys.time()
[08:25:48.170]             {
[08:25:48.170]                 {
[08:25:48.170]                   {
[08:25:48.170]                     {
[08:25:48.170]                       base::local({
[08:25:48.170]                         has_future <- base::requireNamespace("future", 
[08:25:48.170]                           quietly = TRUE)
[08:25:48.170]                         if (has_future) {
[08:25:48.170]                           ns <- base::getNamespace("future")
[08:25:48.170]                           version <- ns[[".package"]][["version"]]
[08:25:48.170]                           if (is.null(version)) 
[08:25:48.170]                             version <- utils::packageVersion("future")
[08:25:48.170]                         }
[08:25:48.170]                         else {
[08:25:48.170]                           version <- NULL
[08:25:48.170]                         }
[08:25:48.170]                         if (!has_future || version < "1.8.0") {
[08:25:48.170]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.170]                             "", base::R.version$version.string), 
[08:25:48.170]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.170]                               "release", "version")], collapse = " "), 
[08:25:48.170]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.170]                             info)
[08:25:48.170]                           info <- base::paste(info, collapse = "; ")
[08:25:48.170]                           if (!has_future) {
[08:25:48.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.170]                               info)
[08:25:48.170]                           }
[08:25:48.170]                           else {
[08:25:48.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.170]                               info, version)
[08:25:48.170]                           }
[08:25:48.170]                           base::stop(msg)
[08:25:48.170]                         }
[08:25:48.170]                       })
[08:25:48.170]                     }
[08:25:48.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.170]                     base::options(mc.cores = 1L)
[08:25:48.170]                   }
[08:25:48.170]                   ...future.strategy.old <- future::plan("list")
[08:25:48.170]                   options(future.plan = NULL)
[08:25:48.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.170]                 }
[08:25:48.170]                 ...future.workdir <- getwd()
[08:25:48.170]             }
[08:25:48.170]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.170]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.170]         }
[08:25:48.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.170]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.170]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.170]             base::names(...future.oldOptions))
[08:25:48.170]     }
[08:25:48.170]     if (FALSE) {
[08:25:48.170]     }
[08:25:48.170]     else {
[08:25:48.170]         if (TRUE) {
[08:25:48.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.170]                 open = "w")
[08:25:48.170]         }
[08:25:48.170]         else {
[08:25:48.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.170]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.170]         }
[08:25:48.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.170]             base::sink(type = "output", split = FALSE)
[08:25:48.170]             base::close(...future.stdout)
[08:25:48.170]         }, add = TRUE)
[08:25:48.170]     }
[08:25:48.170]     ...future.frame <- base::sys.nframe()
[08:25:48.170]     ...future.conditions <- base::list()
[08:25:48.170]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.170]     if (FALSE) {
[08:25:48.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.170]     }
[08:25:48.170]     ...future.result <- base::tryCatch({
[08:25:48.170]         base::withCallingHandlers({
[08:25:48.170]             ...future.value <- base::withVisible(base::local({
[08:25:48.170]                 withCallingHandlers({
[08:25:48.170]                   {
[08:25:48.170]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.170]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.170]                       ...future.globals.maxSize)) {
[08:25:48.170]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.170]                       on.exit(options(oopts), add = TRUE)
[08:25:48.170]                     }
[08:25:48.170]                     {
[08:25:48.170]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.170]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.170]                         USE.NAMES = FALSE)
[08:25:48.170]                       do.call(mapply, args = args)
[08:25:48.170]                     }
[08:25:48.170]                   }
[08:25:48.170]                 }, immediateCondition = function(cond) {
[08:25:48.170]                   save_rds <- function (object, pathname, ...) 
[08:25:48.170]                   {
[08:25:48.170]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.170]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.170]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.170]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.170]                         fi_tmp[["mtime"]])
[08:25:48.170]                     }
[08:25:48.170]                     tryCatch({
[08:25:48.170]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.170]                     }, error = function(ex) {
[08:25:48.170]                       msg <- conditionMessage(ex)
[08:25:48.170]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.170]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.170]                         fi_tmp[["mtime"]], msg)
[08:25:48.170]                       ex$message <- msg
[08:25:48.170]                       stop(ex)
[08:25:48.170]                     })
[08:25:48.170]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.170]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.170]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.170]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.170]                       fi <- file.info(pathname)
[08:25:48.170]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.170]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.170]                         fi[["size"]], fi[["mtime"]])
[08:25:48.170]                       stop(msg)
[08:25:48.170]                     }
[08:25:48.170]                     invisible(pathname)
[08:25:48.170]                   }
[08:25:48.170]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.170]                     rootPath = tempdir()) 
[08:25:48.170]                   {
[08:25:48.170]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.170]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.170]                       tmpdir = path, fileext = ".rds")
[08:25:48.170]                     save_rds(obj, file)
[08:25:48.170]                   }
[08:25:48.170]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.170]                   {
[08:25:48.170]                     inherits <- base::inherits
[08:25:48.170]                     invokeRestart <- base::invokeRestart
[08:25:48.170]                     is.null <- base::is.null
[08:25:48.170]                     muffled <- FALSE
[08:25:48.170]                     if (inherits(cond, "message")) {
[08:25:48.170]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.170]                       if (muffled) 
[08:25:48.170]                         invokeRestart("muffleMessage")
[08:25:48.170]                     }
[08:25:48.170]                     else if (inherits(cond, "warning")) {
[08:25:48.170]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.170]                       if (muffled) 
[08:25:48.170]                         invokeRestart("muffleWarning")
[08:25:48.170]                     }
[08:25:48.170]                     else if (inherits(cond, "condition")) {
[08:25:48.170]                       if (!is.null(pattern)) {
[08:25:48.170]                         computeRestarts <- base::computeRestarts
[08:25:48.170]                         grepl <- base::grepl
[08:25:48.170]                         restarts <- computeRestarts(cond)
[08:25:48.170]                         for (restart in restarts) {
[08:25:48.170]                           name <- restart$name
[08:25:48.170]                           if (is.null(name)) 
[08:25:48.170]                             next
[08:25:48.170]                           if (!grepl(pattern, name)) 
[08:25:48.170]                             next
[08:25:48.170]                           invokeRestart(restart)
[08:25:48.170]                           muffled <- TRUE
[08:25:48.170]                           break
[08:25:48.170]                         }
[08:25:48.170]                       }
[08:25:48.170]                     }
[08:25:48.170]                     invisible(muffled)
[08:25:48.170]                   }
[08:25:48.170]                   muffleCondition(cond)
[08:25:48.170]                 })
[08:25:48.170]             }))
[08:25:48.170]             future::FutureResult(value = ...future.value$value, 
[08:25:48.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.170]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.170]                     ...future.globalenv.names))
[08:25:48.170]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.170]         }, condition = base::local({
[08:25:48.170]             c <- base::c
[08:25:48.170]             inherits <- base::inherits
[08:25:48.170]             invokeRestart <- base::invokeRestart
[08:25:48.170]             length <- base::length
[08:25:48.170]             list <- base::list
[08:25:48.170]             seq.int <- base::seq.int
[08:25:48.170]             signalCondition <- base::signalCondition
[08:25:48.170]             sys.calls <- base::sys.calls
[08:25:48.170]             `[[` <- base::`[[`
[08:25:48.170]             `+` <- base::`+`
[08:25:48.170]             `<<-` <- base::`<<-`
[08:25:48.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.170]                   3L)]
[08:25:48.170]             }
[08:25:48.170]             function(cond) {
[08:25:48.170]                 is_error <- inherits(cond, "error")
[08:25:48.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.170]                   NULL)
[08:25:48.170]                 if (is_error) {
[08:25:48.170]                   sessionInformation <- function() {
[08:25:48.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.170]                       search = base::search(), system = base::Sys.info())
[08:25:48.170]                   }
[08:25:48.170]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.170]                     cond$call), session = sessionInformation(), 
[08:25:48.170]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.170]                   signalCondition(cond)
[08:25:48.170]                 }
[08:25:48.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.170]                 "immediateCondition"))) {
[08:25:48.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.170]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.170]                   if (TRUE && !signal) {
[08:25:48.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.170]                     {
[08:25:48.170]                       inherits <- base::inherits
[08:25:48.170]                       invokeRestart <- base::invokeRestart
[08:25:48.170]                       is.null <- base::is.null
[08:25:48.170]                       muffled <- FALSE
[08:25:48.170]                       if (inherits(cond, "message")) {
[08:25:48.170]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.170]                         if (muffled) 
[08:25:48.170]                           invokeRestart("muffleMessage")
[08:25:48.170]                       }
[08:25:48.170]                       else if (inherits(cond, "warning")) {
[08:25:48.170]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.170]                         if (muffled) 
[08:25:48.170]                           invokeRestart("muffleWarning")
[08:25:48.170]                       }
[08:25:48.170]                       else if (inherits(cond, "condition")) {
[08:25:48.170]                         if (!is.null(pattern)) {
[08:25:48.170]                           computeRestarts <- base::computeRestarts
[08:25:48.170]                           grepl <- base::grepl
[08:25:48.170]                           restarts <- computeRestarts(cond)
[08:25:48.170]                           for (restart in restarts) {
[08:25:48.170]                             name <- restart$name
[08:25:48.170]                             if (is.null(name)) 
[08:25:48.170]                               next
[08:25:48.170]                             if (!grepl(pattern, name)) 
[08:25:48.170]                               next
[08:25:48.170]                             invokeRestart(restart)
[08:25:48.170]                             muffled <- TRUE
[08:25:48.170]                             break
[08:25:48.170]                           }
[08:25:48.170]                         }
[08:25:48.170]                       }
[08:25:48.170]                       invisible(muffled)
[08:25:48.170]                     }
[08:25:48.170]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.170]                   }
[08:25:48.170]                 }
[08:25:48.170]                 else {
[08:25:48.170]                   if (TRUE) {
[08:25:48.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.170]                     {
[08:25:48.170]                       inherits <- base::inherits
[08:25:48.170]                       invokeRestart <- base::invokeRestart
[08:25:48.170]                       is.null <- base::is.null
[08:25:48.170]                       muffled <- FALSE
[08:25:48.170]                       if (inherits(cond, "message")) {
[08:25:48.170]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.170]                         if (muffled) 
[08:25:48.170]                           invokeRestart("muffleMessage")
[08:25:48.170]                       }
[08:25:48.170]                       else if (inherits(cond, "warning")) {
[08:25:48.170]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.170]                         if (muffled) 
[08:25:48.170]                           invokeRestart("muffleWarning")
[08:25:48.170]                       }
[08:25:48.170]                       else if (inherits(cond, "condition")) {
[08:25:48.170]                         if (!is.null(pattern)) {
[08:25:48.170]                           computeRestarts <- base::computeRestarts
[08:25:48.170]                           grepl <- base::grepl
[08:25:48.170]                           restarts <- computeRestarts(cond)
[08:25:48.170]                           for (restart in restarts) {
[08:25:48.170]                             name <- restart$name
[08:25:48.170]                             if (is.null(name)) 
[08:25:48.170]                               next
[08:25:48.170]                             if (!grepl(pattern, name)) 
[08:25:48.170]                               next
[08:25:48.170]                             invokeRestart(restart)
[08:25:48.170]                             muffled <- TRUE
[08:25:48.170]                             break
[08:25:48.170]                           }
[08:25:48.170]                         }
[08:25:48.170]                       }
[08:25:48.170]                       invisible(muffled)
[08:25:48.170]                     }
[08:25:48.170]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.170]                   }
[08:25:48.170]                 }
[08:25:48.170]             }
[08:25:48.170]         }))
[08:25:48.170]     }, error = function(ex) {
[08:25:48.170]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.170]                 ...future.rng), started = ...future.startTime, 
[08:25:48.170]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.170]             version = "1.8"), class = "FutureResult")
[08:25:48.170]     }, finally = {
[08:25:48.170]         if (!identical(...future.workdir, getwd())) 
[08:25:48.170]             setwd(...future.workdir)
[08:25:48.170]         {
[08:25:48.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.170]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.170]             }
[08:25:48.170]             base::options(...future.oldOptions)
[08:25:48.170]             if (.Platform$OS.type == "windows") {
[08:25:48.170]                 old_names <- names(...future.oldEnvVars)
[08:25:48.170]                 envs <- base::Sys.getenv()
[08:25:48.170]                 names <- names(envs)
[08:25:48.170]                 common <- intersect(names, old_names)
[08:25:48.170]                 added <- setdiff(names, old_names)
[08:25:48.170]                 removed <- setdiff(old_names, names)
[08:25:48.170]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.170]                   envs[common]]
[08:25:48.170]                 NAMES <- toupper(changed)
[08:25:48.170]                 args <- list()
[08:25:48.170]                 for (kk in seq_along(NAMES)) {
[08:25:48.170]                   name <- changed[[kk]]
[08:25:48.170]                   NAME <- NAMES[[kk]]
[08:25:48.170]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.170]                     next
[08:25:48.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.170]                 }
[08:25:48.170]                 NAMES <- toupper(added)
[08:25:48.170]                 for (kk in seq_along(NAMES)) {
[08:25:48.170]                   name <- added[[kk]]
[08:25:48.170]                   NAME <- NAMES[[kk]]
[08:25:48.170]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.170]                     next
[08:25:48.170]                   args[[name]] <- ""
[08:25:48.170]                 }
[08:25:48.170]                 NAMES <- toupper(removed)
[08:25:48.170]                 for (kk in seq_along(NAMES)) {
[08:25:48.170]                   name <- removed[[kk]]
[08:25:48.170]                   NAME <- NAMES[[kk]]
[08:25:48.170]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.170]                     next
[08:25:48.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.170]                 }
[08:25:48.170]                 if (length(args) > 0) 
[08:25:48.170]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.170]             }
[08:25:48.170]             else {
[08:25:48.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.170]             }
[08:25:48.170]             {
[08:25:48.170]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.170]                   0L) {
[08:25:48.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.170]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.170]                   base::options(opts)
[08:25:48.170]                 }
[08:25:48.170]                 {
[08:25:48.170]                   {
[08:25:48.170]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.170]                     NULL
[08:25:48.170]                   }
[08:25:48.170]                   options(future.plan = NULL)
[08:25:48.170]                   if (is.na(NA_character_)) 
[08:25:48.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.170]                     .init = FALSE)
[08:25:48.170]                 }
[08:25:48.170]             }
[08:25:48.170]         }
[08:25:48.170]     })
[08:25:48.170]     if (TRUE) {
[08:25:48.170]         base::sink(type = "output", split = FALSE)
[08:25:48.170]         if (TRUE) {
[08:25:48.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.170]         }
[08:25:48.170]         else {
[08:25:48.170]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.170]         }
[08:25:48.170]         base::close(...future.stdout)
[08:25:48.170]         ...future.stdout <- NULL
[08:25:48.170]     }
[08:25:48.170]     ...future.result$conditions <- ...future.conditions
[08:25:48.170]     ...future.result$finished <- base::Sys.time()
[08:25:48.170]     ...future.result
[08:25:48.170] }
[08:25:48.173] assign_globals() ...
[08:25:48.173] List of 5
[08:25:48.173]  $ ...future.FUN            :function (x, ...)  
[08:25:48.173]  $ MoreArgs                 : NULL
[08:25:48.173]  $ ...future.elements_ii    :List of 2
[08:25:48.173]   ..$ :List of 2
[08:25:48.173]   .. ..$ : int 3
[08:25:48.173]   .. ..$ : int 4
[08:25:48.173]   ..$ :List of 2
[08:25:48.173]   .. ..$ : int 2
[08:25:48.173]   .. ..$ : int 1
[08:25:48.173]  $ ...future.seeds_ii       : NULL
[08:25:48.173]  $ ...future.globals.maxSize: NULL
[08:25:48.173]  - attr(*, "where")=List of 5
[08:25:48.173]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.173]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.173]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.173]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.173]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.173]  - attr(*, "resolved")= logi FALSE
[08:25:48.173]  - attr(*, "total_size")= num 210
[08:25:48.173]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.173]  - attr(*, "already-done")= logi TRUE
[08:25:48.182] - copied ‘...future.FUN’ to environment
[08:25:48.182] - copied ‘MoreArgs’ to environment
[08:25:48.183] - copied ‘...future.elements_ii’ to environment
[08:25:48.183] - copied ‘...future.seeds_ii’ to environment
[08:25:48.183] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.183] assign_globals() ... done
[08:25:48.183] requestCore(): workers = 2
[08:25:48.190] MulticoreFuture started
[08:25:48.190] - Launch lazy future ... done
[08:25:48.190] run() for ‘MulticoreFuture’ ... done
[08:25:48.191] plan(): Setting new future strategy stack:
[08:25:48.191] Created future:
[08:25:48.191] List of future strategies:
[08:25:48.191] 1. sequential:
[08:25:48.191]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.191]    - tweaked: FALSE
[08:25:48.191]    - call: NULL
[08:25:48.192] plan(): nbrOfWorkers() = 1
[08:25:48.194] plan(): Setting new future strategy stack:
[08:25:48.194] List of future strategies:
[08:25:48.194] 1. multicore:
[08:25:48.194]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.194]    - tweaked: FALSE
[08:25:48.194]    - call: plan(strategy)
[08:25:48.198] plan(): nbrOfWorkers() = 2
[08:25:48.191] MulticoreFuture:
[08:25:48.191] Label: ‘future_mapply-2’
[08:25:48.191] Expression:
[08:25:48.191] {
[08:25:48.191]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.191]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.191]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.191]         on.exit(options(oopts), add = TRUE)
[08:25:48.191]     }
[08:25:48.191]     {
[08:25:48.191]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.191]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.191]         do.call(mapply, args = args)
[08:25:48.191]     }
[08:25:48.191] }
[08:25:48.191] Lazy evaluation: FALSE
[08:25:48.191] Asynchronous evaluation: TRUE
[08:25:48.191] Local evaluation: TRUE
[08:25:48.191] Environment: R_GlobalEnv
[08:25:48.191] Capture standard output: TRUE
[08:25:48.191] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.191] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.191] Packages: <none>
[08:25:48.191] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.191] Resolved: TRUE
[08:25:48.191] Value: <not collected>
[08:25:48.191] Conditions captured: <none>
[08:25:48.191] Early signaling: FALSE
[08:25:48.191] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.191] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.199] Chunk #2 of 2 ... DONE
[08:25:48.199] Launching 2 futures (chunks) ... DONE
[08:25:48.199] Resolving 2 futures (chunks) ...
[08:25:48.200] resolve() on list ...
[08:25:48.200]  recursive: 0
[08:25:48.200]  length: 2
[08:25:48.200] 
[08:25:48.200] Future #1
[08:25:48.201] result() for MulticoreFuture ...
[08:25:48.203] result() for MulticoreFuture ...
[08:25:48.204] result() for MulticoreFuture ... done
[08:25:48.204] result() for MulticoreFuture ... done
[08:25:48.204] result() for MulticoreFuture ...
[08:25:48.204] result() for MulticoreFuture ... done
[08:25:48.204] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:48.205] - nx: 2
[08:25:48.205] - relay: TRUE
[08:25:48.205] - stdout: TRUE
[08:25:48.205] - signal: TRUE
[08:25:48.205] - resignal: FALSE
[08:25:48.206] - force: TRUE
[08:25:48.206] - relayed: [n=2] FALSE, FALSE
[08:25:48.206] - queued futures: [n=2] FALSE, FALSE
[08:25:48.206]  - until=1
[08:25:48.206]  - relaying element #1
[08:25:48.206] result() for MulticoreFuture ...
[08:25:48.207] result() for MulticoreFuture ... done
[08:25:48.207] result() for MulticoreFuture ...
[08:25:48.207] result() for MulticoreFuture ... done
[08:25:48.207] result() for MulticoreFuture ...
[08:25:48.207] result() for MulticoreFuture ... done
[08:25:48.208] result() for MulticoreFuture ...
[08:25:48.208] result() for MulticoreFuture ... done
[08:25:48.208] - relayed: [n=2] TRUE, FALSE
[08:25:48.208] - queued futures: [n=2] TRUE, FALSE
[08:25:48.208] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:48.208]  length: 1 (resolved future 1)
[08:25:48.209] Future #2
[08:25:48.209] result() for MulticoreFuture ...
[08:25:48.210] result() for MulticoreFuture ...
[08:25:48.210] result() for MulticoreFuture ... done
[08:25:48.210] result() for MulticoreFuture ... done
[08:25:48.211] result() for MulticoreFuture ...
[08:25:48.211] result() for MulticoreFuture ... done
[08:25:48.211] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:48.211] - nx: 2
[08:25:48.215] - relay: TRUE
[08:25:48.215] - stdout: TRUE
[08:25:48.215] - signal: TRUE
[08:25:48.215] - resignal: FALSE
[08:25:48.215] - force: TRUE
[08:25:48.215] - relayed: [n=2] TRUE, FALSE
[08:25:48.216] - queued futures: [n=2] TRUE, FALSE
[08:25:48.216]  - until=2
[08:25:48.216]  - relaying element #2
[08:25:48.216] result() for MulticoreFuture ...
[08:25:48.216] result() for MulticoreFuture ... done
[08:25:48.216] result() for MulticoreFuture ...
[08:25:48.217] result() for MulticoreFuture ... done
[08:25:48.217] result() for MulticoreFuture ...
[08:25:48.217] result() for MulticoreFuture ... done
[08:25:48.217] result() for MulticoreFuture ...
[08:25:48.217] result() for MulticoreFuture ... done
[08:25:48.217] - relayed: [n=2] TRUE, TRUE
[08:25:48.218] - queued futures: [n=2] TRUE, TRUE
[08:25:48.218] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:48.218]  length: 0 (resolved future 2)
[08:25:48.218] Relaying remaining futures
[08:25:48.218] signalConditionsASAP(NULL, pos=0) ...
[08:25:48.218] - nx: 2
[08:25:48.219] - relay: TRUE
[08:25:48.219] - stdout: TRUE
[08:25:48.219] - signal: TRUE
[08:25:48.219] - resignal: FALSE
[08:25:48.219] - force: TRUE
[08:25:48.219] - relayed: [n=2] TRUE, TRUE
[08:25:48.219] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:48.220] - relayed: [n=2] TRUE, TRUE
[08:25:48.220] - queued futures: [n=2] TRUE, TRUE
[08:25:48.220] signalConditionsASAP(NULL, pos=0) ... done
[08:25:48.220] resolve() on list ... DONE
[08:25:48.220] result() for MulticoreFuture ...
[08:25:48.220] result() for MulticoreFuture ... done
[08:25:48.221] result() for MulticoreFuture ...
[08:25:48.221] result() for MulticoreFuture ... done
[08:25:48.221] result() for MulticoreFuture ...
[08:25:48.221] result() for MulticoreFuture ... done
[08:25:48.221] result() for MulticoreFuture ...
[08:25:48.221] result() for MulticoreFuture ... done
[08:25:48.221]  - Number of value chunks collected: 2
[08:25:48.221] Resolving 2 futures (chunks) ... DONE
[08:25:48.222] Reducing values from 2 chunks ...
[08:25:48.222]  - Number of values collected after concatenation: 4
[08:25:48.222]  - Number of values expected: 4
[08:25:48.222] Reducing values from 2 chunks ... DONE
[08:25:48.222] future_mapply() ... DONE
[08:25:48.222] future_mapply() ...
[08:25:48.224] Number of chunks: 2
[08:25:48.225] getGlobalsAndPackagesXApply() ...
[08:25:48.225]  - future.globals: TRUE
[08:25:48.225] getGlobalsAndPackages() ...
[08:25:48.225] Searching for globals...
[08:25:48.226] - globals found: [1] ‘FUN’
[08:25:48.226] Searching for globals ... DONE
[08:25:48.226] Resolving globals: FALSE
[08:25:48.226] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:48.227] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:48.227] - globals: [1] ‘FUN’
[08:25:48.227] 
[08:25:48.227] getGlobalsAndPackages() ... DONE
[08:25:48.227]  - globals found/used: [n=1] ‘FUN’
[08:25:48.227]  - needed namespaces: [n=0] 
[08:25:48.227] Finding globals ... DONE
[08:25:48.228] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:48.228] List of 2
[08:25:48.228]  $ ...future.FUN:function (x, ...)  
[08:25:48.228]  $ MoreArgs     : NULL
[08:25:48.228]  - attr(*, "where")=List of 2
[08:25:48.228]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:48.228]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:48.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.228]  - attr(*, "resolved")= logi FALSE
[08:25:48.228]  - attr(*, "total_size")= num NA
[08:25:48.231] Packages to be attached in all futures: [n=0] 
[08:25:48.231] getGlobalsAndPackagesXApply() ... DONE
[08:25:48.231] Number of futures (= number of chunks): 2
[08:25:48.231] Launching 2 futures (chunks) ...
[08:25:48.231] Chunk #1 of 2 ...
[08:25:48.231]  - Finding globals in '...' for chunk #1 ...
[08:25:48.232] getGlobalsAndPackages() ...
[08:25:48.232] Searching for globals...
[08:25:48.232] 
[08:25:48.232] Searching for globals ... DONE
[08:25:48.232] - globals: [0] <none>
[08:25:48.232] getGlobalsAndPackages() ... DONE
[08:25:48.232]    + additional globals found: [n=0] 
[08:25:48.232]    + additional namespaces needed: [n=0] 
[08:25:48.233]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:48.233]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.233]  - seeds: <none>
[08:25:48.233]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.233] getGlobalsAndPackages() ...
[08:25:48.233] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.233] Resolving globals: FALSE
[08:25:48.234] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:48.234] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.234] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.234] 
[08:25:48.235] getGlobalsAndPackages() ... DONE
[08:25:48.235] run() for ‘Future’ ...
[08:25:48.235] - state: ‘created’
[08:25:48.235] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.237] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.237] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.237]   - Field: ‘label’
[08:25:48.237]   - Field: ‘local’
[08:25:48.237]   - Field: ‘owner’
[08:25:48.237]   - Field: ‘envir’
[08:25:48.238]   - Field: ‘workers’
[08:25:48.238]   - Field: ‘packages’
[08:25:48.238]   - Field: ‘gc’
[08:25:48.238]   - Field: ‘job’
[08:25:48.238]   - Field: ‘conditions’
[08:25:48.238]   - Field: ‘expr’
[08:25:48.238]   - Field: ‘uuid’
[08:25:48.238]   - Field: ‘seed’
[08:25:48.238]   - Field: ‘version’
[08:25:48.238]   - Field: ‘result’
[08:25:48.238]   - Field: ‘asynchronous’
[08:25:48.239]   - Field: ‘calls’
[08:25:48.239]   - Field: ‘globals’
[08:25:48.239]   - Field: ‘stdout’
[08:25:48.239]   - Field: ‘earlySignal’
[08:25:48.239]   - Field: ‘lazy’
[08:25:48.239]   - Field: ‘state’
[08:25:48.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.239] - Launch lazy future ...
[08:25:48.239] Packages needed by the future expression (n = 0): <none>
[08:25:48.240] Packages needed by future strategies (n = 0): <none>
[08:25:48.240] {
[08:25:48.240]     {
[08:25:48.240]         {
[08:25:48.240]             ...future.startTime <- base::Sys.time()
[08:25:48.240]             {
[08:25:48.240]                 {
[08:25:48.240]                   {
[08:25:48.240]                     {
[08:25:48.240]                       base::local({
[08:25:48.240]                         has_future <- base::requireNamespace("future", 
[08:25:48.240]                           quietly = TRUE)
[08:25:48.240]                         if (has_future) {
[08:25:48.240]                           ns <- base::getNamespace("future")
[08:25:48.240]                           version <- ns[[".package"]][["version"]]
[08:25:48.240]                           if (is.null(version)) 
[08:25:48.240]                             version <- utils::packageVersion("future")
[08:25:48.240]                         }
[08:25:48.240]                         else {
[08:25:48.240]                           version <- NULL
[08:25:48.240]                         }
[08:25:48.240]                         if (!has_future || version < "1.8.0") {
[08:25:48.240]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.240]                             "", base::R.version$version.string), 
[08:25:48.240]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.240]                               "release", "version")], collapse = " "), 
[08:25:48.240]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.240]                             info)
[08:25:48.240]                           info <- base::paste(info, collapse = "; ")
[08:25:48.240]                           if (!has_future) {
[08:25:48.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.240]                               info)
[08:25:48.240]                           }
[08:25:48.240]                           else {
[08:25:48.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.240]                               info, version)
[08:25:48.240]                           }
[08:25:48.240]                           base::stop(msg)
[08:25:48.240]                         }
[08:25:48.240]                       })
[08:25:48.240]                     }
[08:25:48.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.240]                     base::options(mc.cores = 1L)
[08:25:48.240]                   }
[08:25:48.240]                   ...future.strategy.old <- future::plan("list")
[08:25:48.240]                   options(future.plan = NULL)
[08:25:48.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.240]                 }
[08:25:48.240]                 ...future.workdir <- getwd()
[08:25:48.240]             }
[08:25:48.240]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.240]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.240]         }
[08:25:48.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.240]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.240]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.240]             base::names(...future.oldOptions))
[08:25:48.240]     }
[08:25:48.240]     if (FALSE) {
[08:25:48.240]     }
[08:25:48.240]     else {
[08:25:48.240]         if (TRUE) {
[08:25:48.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.240]                 open = "w")
[08:25:48.240]         }
[08:25:48.240]         else {
[08:25:48.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.240]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.240]         }
[08:25:48.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.240]             base::sink(type = "output", split = FALSE)
[08:25:48.240]             base::close(...future.stdout)
[08:25:48.240]         }, add = TRUE)
[08:25:48.240]     }
[08:25:48.240]     ...future.frame <- base::sys.nframe()
[08:25:48.240]     ...future.conditions <- base::list()
[08:25:48.240]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.240]     if (FALSE) {
[08:25:48.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.240]     }
[08:25:48.240]     ...future.result <- base::tryCatch({
[08:25:48.240]         base::withCallingHandlers({
[08:25:48.240]             ...future.value <- base::withVisible(base::local({
[08:25:48.240]                 withCallingHandlers({
[08:25:48.240]                   {
[08:25:48.240]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.240]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.240]                       ...future.globals.maxSize)) {
[08:25:48.240]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.240]                       on.exit(options(oopts), add = TRUE)
[08:25:48.240]                     }
[08:25:48.240]                     {
[08:25:48.240]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.240]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.240]                         USE.NAMES = FALSE)
[08:25:48.240]                       do.call(mapply, args = args)
[08:25:48.240]                     }
[08:25:48.240]                   }
[08:25:48.240]                 }, immediateCondition = function(cond) {
[08:25:48.240]                   save_rds <- function (object, pathname, ...) 
[08:25:48.240]                   {
[08:25:48.240]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.240]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.240]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.240]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.240]                         fi_tmp[["mtime"]])
[08:25:48.240]                     }
[08:25:48.240]                     tryCatch({
[08:25:48.240]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.240]                     }, error = function(ex) {
[08:25:48.240]                       msg <- conditionMessage(ex)
[08:25:48.240]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.240]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.240]                         fi_tmp[["mtime"]], msg)
[08:25:48.240]                       ex$message <- msg
[08:25:48.240]                       stop(ex)
[08:25:48.240]                     })
[08:25:48.240]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.240]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.240]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.240]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.240]                       fi <- file.info(pathname)
[08:25:48.240]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.240]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.240]                         fi[["size"]], fi[["mtime"]])
[08:25:48.240]                       stop(msg)
[08:25:48.240]                     }
[08:25:48.240]                     invisible(pathname)
[08:25:48.240]                   }
[08:25:48.240]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.240]                     rootPath = tempdir()) 
[08:25:48.240]                   {
[08:25:48.240]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.240]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.240]                       tmpdir = path, fileext = ".rds")
[08:25:48.240]                     save_rds(obj, file)
[08:25:48.240]                   }
[08:25:48.240]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.240]                   {
[08:25:48.240]                     inherits <- base::inherits
[08:25:48.240]                     invokeRestart <- base::invokeRestart
[08:25:48.240]                     is.null <- base::is.null
[08:25:48.240]                     muffled <- FALSE
[08:25:48.240]                     if (inherits(cond, "message")) {
[08:25:48.240]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.240]                       if (muffled) 
[08:25:48.240]                         invokeRestart("muffleMessage")
[08:25:48.240]                     }
[08:25:48.240]                     else if (inherits(cond, "warning")) {
[08:25:48.240]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.240]                       if (muffled) 
[08:25:48.240]                         invokeRestart("muffleWarning")
[08:25:48.240]                     }
[08:25:48.240]                     else if (inherits(cond, "condition")) {
[08:25:48.240]                       if (!is.null(pattern)) {
[08:25:48.240]                         computeRestarts <- base::computeRestarts
[08:25:48.240]                         grepl <- base::grepl
[08:25:48.240]                         restarts <- computeRestarts(cond)
[08:25:48.240]                         for (restart in restarts) {
[08:25:48.240]                           name <- restart$name
[08:25:48.240]                           if (is.null(name)) 
[08:25:48.240]                             next
[08:25:48.240]                           if (!grepl(pattern, name)) 
[08:25:48.240]                             next
[08:25:48.240]                           invokeRestart(restart)
[08:25:48.240]                           muffled <- TRUE
[08:25:48.240]                           break
[08:25:48.240]                         }
[08:25:48.240]                       }
[08:25:48.240]                     }
[08:25:48.240]                     invisible(muffled)
[08:25:48.240]                   }
[08:25:48.240]                   muffleCondition(cond)
[08:25:48.240]                 })
[08:25:48.240]             }))
[08:25:48.240]             future::FutureResult(value = ...future.value$value, 
[08:25:48.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.240]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.240]                     ...future.globalenv.names))
[08:25:48.240]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.240]         }, condition = base::local({
[08:25:48.240]             c <- base::c
[08:25:48.240]             inherits <- base::inherits
[08:25:48.240]             invokeRestart <- base::invokeRestart
[08:25:48.240]             length <- base::length
[08:25:48.240]             list <- base::list
[08:25:48.240]             seq.int <- base::seq.int
[08:25:48.240]             signalCondition <- base::signalCondition
[08:25:48.240]             sys.calls <- base::sys.calls
[08:25:48.240]             `[[` <- base::`[[`
[08:25:48.240]             `+` <- base::`+`
[08:25:48.240]             `<<-` <- base::`<<-`
[08:25:48.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.240]                   3L)]
[08:25:48.240]             }
[08:25:48.240]             function(cond) {
[08:25:48.240]                 is_error <- inherits(cond, "error")
[08:25:48.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.240]                   NULL)
[08:25:48.240]                 if (is_error) {
[08:25:48.240]                   sessionInformation <- function() {
[08:25:48.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.240]                       search = base::search(), system = base::Sys.info())
[08:25:48.240]                   }
[08:25:48.240]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.240]                     cond$call), session = sessionInformation(), 
[08:25:48.240]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.240]                   signalCondition(cond)
[08:25:48.240]                 }
[08:25:48.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.240]                 "immediateCondition"))) {
[08:25:48.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.240]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.240]                   if (TRUE && !signal) {
[08:25:48.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.240]                     {
[08:25:48.240]                       inherits <- base::inherits
[08:25:48.240]                       invokeRestart <- base::invokeRestart
[08:25:48.240]                       is.null <- base::is.null
[08:25:48.240]                       muffled <- FALSE
[08:25:48.240]                       if (inherits(cond, "message")) {
[08:25:48.240]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.240]                         if (muffled) 
[08:25:48.240]                           invokeRestart("muffleMessage")
[08:25:48.240]                       }
[08:25:48.240]                       else if (inherits(cond, "warning")) {
[08:25:48.240]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.240]                         if (muffled) 
[08:25:48.240]                           invokeRestart("muffleWarning")
[08:25:48.240]                       }
[08:25:48.240]                       else if (inherits(cond, "condition")) {
[08:25:48.240]                         if (!is.null(pattern)) {
[08:25:48.240]                           computeRestarts <- base::computeRestarts
[08:25:48.240]                           grepl <- base::grepl
[08:25:48.240]                           restarts <- computeRestarts(cond)
[08:25:48.240]                           for (restart in restarts) {
[08:25:48.240]                             name <- restart$name
[08:25:48.240]                             if (is.null(name)) 
[08:25:48.240]                               next
[08:25:48.240]                             if (!grepl(pattern, name)) 
[08:25:48.240]                               next
[08:25:48.240]                             invokeRestart(restart)
[08:25:48.240]                             muffled <- TRUE
[08:25:48.240]                             break
[08:25:48.240]                           }
[08:25:48.240]                         }
[08:25:48.240]                       }
[08:25:48.240]                       invisible(muffled)
[08:25:48.240]                     }
[08:25:48.240]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.240]                   }
[08:25:48.240]                 }
[08:25:48.240]                 else {
[08:25:48.240]                   if (TRUE) {
[08:25:48.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.240]                     {
[08:25:48.240]                       inherits <- base::inherits
[08:25:48.240]                       invokeRestart <- base::invokeRestart
[08:25:48.240]                       is.null <- base::is.null
[08:25:48.240]                       muffled <- FALSE
[08:25:48.240]                       if (inherits(cond, "message")) {
[08:25:48.240]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.240]                         if (muffled) 
[08:25:48.240]                           invokeRestart("muffleMessage")
[08:25:48.240]                       }
[08:25:48.240]                       else if (inherits(cond, "warning")) {
[08:25:48.240]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.240]                         if (muffled) 
[08:25:48.240]                           invokeRestart("muffleWarning")
[08:25:48.240]                       }
[08:25:48.240]                       else if (inherits(cond, "condition")) {
[08:25:48.240]                         if (!is.null(pattern)) {
[08:25:48.240]                           computeRestarts <- base::computeRestarts
[08:25:48.240]                           grepl <- base::grepl
[08:25:48.240]                           restarts <- computeRestarts(cond)
[08:25:48.240]                           for (restart in restarts) {
[08:25:48.240]                             name <- restart$name
[08:25:48.240]                             if (is.null(name)) 
[08:25:48.240]                               next
[08:25:48.240]                             if (!grepl(pattern, name)) 
[08:25:48.240]                               next
[08:25:48.240]                             invokeRestart(restart)
[08:25:48.240]                             muffled <- TRUE
[08:25:48.240]                             break
[08:25:48.240]                           }
[08:25:48.240]                         }
[08:25:48.240]                       }
[08:25:48.240]                       invisible(muffled)
[08:25:48.240]                     }
[08:25:48.240]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.240]                   }
[08:25:48.240]                 }
[08:25:48.240]             }
[08:25:48.240]         }))
[08:25:48.240]     }, error = function(ex) {
[08:25:48.240]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.240]                 ...future.rng), started = ...future.startTime, 
[08:25:48.240]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.240]             version = "1.8"), class = "FutureResult")
[08:25:48.240]     }, finally = {
[08:25:48.240]         if (!identical(...future.workdir, getwd())) 
[08:25:48.240]             setwd(...future.workdir)
[08:25:48.240]         {
[08:25:48.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.240]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.240]             }
[08:25:48.240]             base::options(...future.oldOptions)
[08:25:48.240]             if (.Platform$OS.type == "windows") {
[08:25:48.240]                 old_names <- names(...future.oldEnvVars)
[08:25:48.240]                 envs <- base::Sys.getenv()
[08:25:48.240]                 names <- names(envs)
[08:25:48.240]                 common <- intersect(names, old_names)
[08:25:48.240]                 added <- setdiff(names, old_names)
[08:25:48.240]                 removed <- setdiff(old_names, names)
[08:25:48.240]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.240]                   envs[common]]
[08:25:48.240]                 NAMES <- toupper(changed)
[08:25:48.240]                 args <- list()
[08:25:48.240]                 for (kk in seq_along(NAMES)) {
[08:25:48.240]                   name <- changed[[kk]]
[08:25:48.240]                   NAME <- NAMES[[kk]]
[08:25:48.240]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.240]                     next
[08:25:48.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.240]                 }
[08:25:48.240]                 NAMES <- toupper(added)
[08:25:48.240]                 for (kk in seq_along(NAMES)) {
[08:25:48.240]                   name <- added[[kk]]
[08:25:48.240]                   NAME <- NAMES[[kk]]
[08:25:48.240]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.240]                     next
[08:25:48.240]                   args[[name]] <- ""
[08:25:48.240]                 }
[08:25:48.240]                 NAMES <- toupper(removed)
[08:25:48.240]                 for (kk in seq_along(NAMES)) {
[08:25:48.240]                   name <- removed[[kk]]
[08:25:48.240]                   NAME <- NAMES[[kk]]
[08:25:48.240]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.240]                     next
[08:25:48.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.240]                 }
[08:25:48.240]                 if (length(args) > 0) 
[08:25:48.240]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.240]             }
[08:25:48.240]             else {
[08:25:48.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.240]             }
[08:25:48.240]             {
[08:25:48.240]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.240]                   0L) {
[08:25:48.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.240]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.240]                   base::options(opts)
[08:25:48.240]                 }
[08:25:48.240]                 {
[08:25:48.240]                   {
[08:25:48.240]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.240]                     NULL
[08:25:48.240]                   }
[08:25:48.240]                   options(future.plan = NULL)
[08:25:48.240]                   if (is.na(NA_character_)) 
[08:25:48.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.240]                     .init = FALSE)
[08:25:48.240]                 }
[08:25:48.240]             }
[08:25:48.240]         }
[08:25:48.240]     })
[08:25:48.240]     if (TRUE) {
[08:25:48.240]         base::sink(type = "output", split = FALSE)
[08:25:48.240]         if (TRUE) {
[08:25:48.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.240]         }
[08:25:48.240]         else {
[08:25:48.240]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.240]         }
[08:25:48.240]         base::close(...future.stdout)
[08:25:48.240]         ...future.stdout <- NULL
[08:25:48.240]     }
[08:25:48.240]     ...future.result$conditions <- ...future.conditions
[08:25:48.240]     ...future.result$finished <- base::Sys.time()
[08:25:48.240]     ...future.result
[08:25:48.240] }
[08:25:48.242] assign_globals() ...
[08:25:48.243] List of 5
[08:25:48.243]  $ ...future.FUN            :function (x, ...)  
[08:25:48.243]  $ MoreArgs                 : NULL
[08:25:48.243]  $ ...future.elements_ii    :List of 2
[08:25:48.243]   ..$ :List of 2
[08:25:48.243]   .. ..$ : int 1
[08:25:48.243]   .. ..$ : int 2
[08:25:48.243]   ..$ :List of 2
[08:25:48.243]   .. ..$ : int 4
[08:25:48.243]   .. ..$ : int 3
[08:25:48.243]  $ ...future.seeds_ii       : NULL
[08:25:48.243]  $ ...future.globals.maxSize: NULL
[08:25:48.243]  - attr(*, "where")=List of 5
[08:25:48.243]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.243]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.243]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.243]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.243]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.243]  - attr(*, "resolved")= logi FALSE
[08:25:48.243]  - attr(*, "total_size")= num 210
[08:25:48.243]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.243]  - attr(*, "already-done")= logi TRUE
[08:25:48.251] - copied ‘...future.FUN’ to environment
[08:25:48.251] - copied ‘MoreArgs’ to environment
[08:25:48.251] - copied ‘...future.elements_ii’ to environment
[08:25:48.252] - copied ‘...future.seeds_ii’ to environment
[08:25:48.252] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.252] assign_globals() ... done
[08:25:48.252] requestCore(): workers = 2
[08:25:48.255] MulticoreFuture started
[08:25:48.255] - Launch lazy future ... done
[08:25:48.256] plan(): Setting new future strategy stack:
[08:25:48.256] run() for ‘MulticoreFuture’ ... done
[08:25:48.256] Created future:
[08:25:48.256] List of future strategies:
[08:25:48.256] 1. sequential:
[08:25:48.256]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.256]    - tweaked: FALSE
[08:25:48.256]    - call: NULL
[08:25:48.257] plan(): nbrOfWorkers() = 1
[08:25:48.260] plan(): Setting new future strategy stack:
[08:25:48.260] List of future strategies:
[08:25:48.260] 1. multicore:
[08:25:48.260]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.260]    - tweaked: FALSE
[08:25:48.260]    - call: plan(strategy)
[08:25:48.263] plan(): nbrOfWorkers() = 2
[08:25:48.257] MulticoreFuture:
[08:25:48.257] Label: ‘future_mapply-1’
[08:25:48.257] Expression:
[08:25:48.257] {
[08:25:48.257]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.257]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.257]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.257]         on.exit(options(oopts), add = TRUE)
[08:25:48.257]     }
[08:25:48.257]     {
[08:25:48.257]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.257]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.257]         do.call(mapply, args = args)
[08:25:48.257]     }
[08:25:48.257] }
[08:25:48.257] Lazy evaluation: FALSE
[08:25:48.257] Asynchronous evaluation: TRUE
[08:25:48.257] Local evaluation: TRUE
[08:25:48.257] Environment: R_GlobalEnv
[08:25:48.257] Capture standard output: TRUE
[08:25:48.257] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.257] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.257] Packages: <none>
[08:25:48.257] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.257] Resolved: TRUE
[08:25:48.257] Value: <not collected>
[08:25:48.257] Conditions captured: <none>
[08:25:48.257] Early signaling: FALSE
[08:25:48.257] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.257] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.265] Chunk #1 of 2 ... DONE
[08:25:48.265] Chunk #2 of 2 ...
[08:25:48.265]  - Finding globals in '...' for chunk #2 ...
[08:25:48.266] getGlobalsAndPackages() ...
[08:25:48.266] Searching for globals...
[08:25:48.267] 
[08:25:48.267] Searching for globals ... DONE
[08:25:48.267] - globals: [0] <none>
[08:25:48.267] getGlobalsAndPackages() ... DONE
[08:25:48.267]    + additional globals found: [n=0] 
[08:25:48.267]    + additional namespaces needed: [n=0] 
[08:25:48.268]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:48.268]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.268]  - seeds: <none>
[08:25:48.268]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.268] getGlobalsAndPackages() ...
[08:25:48.268] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.269] Resolving globals: FALSE
[08:25:48.269] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:48.270] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.271] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.271] 
[08:25:48.271] getGlobalsAndPackages() ... DONE
[08:25:48.271] run() for ‘Future’ ...
[08:25:48.272] - state: ‘created’
[08:25:48.272] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.275] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.275]   - Field: ‘label’
[08:25:48.275]   - Field: ‘local’
[08:25:48.276]   - Field: ‘owner’
[08:25:48.276]   - Field: ‘envir’
[08:25:48.276]   - Field: ‘workers’
[08:25:48.276]   - Field: ‘packages’
[08:25:48.276]   - Field: ‘gc’
[08:25:48.276]   - Field: ‘job’
[08:25:48.276]   - Field: ‘conditions’
[08:25:48.277]   - Field: ‘expr’
[08:25:48.277]   - Field: ‘uuid’
[08:25:48.277]   - Field: ‘seed’
[08:25:48.277]   - Field: ‘version’
[08:25:48.277]   - Field: ‘result’
[08:25:48.277]   - Field: ‘asynchronous’
[08:25:48.277]   - Field: ‘calls’
[08:25:48.278]   - Field: ‘globals’
[08:25:48.278]   - Field: ‘stdout’
[08:25:48.278]   - Field: ‘earlySignal’
[08:25:48.278]   - Field: ‘lazy’
[08:25:48.278]   - Field: ‘state’
[08:25:48.278] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.278] - Launch lazy future ...
[08:25:48.279] Packages needed by the future expression (n = 0): <none>
[08:25:48.279] Packages needed by future strategies (n = 0): <none>
[08:25:48.280] {
[08:25:48.280]     {
[08:25:48.280]         {
[08:25:48.280]             ...future.startTime <- base::Sys.time()
[08:25:48.280]             {
[08:25:48.280]                 {
[08:25:48.280]                   {
[08:25:48.280]                     {
[08:25:48.280]                       base::local({
[08:25:48.280]                         has_future <- base::requireNamespace("future", 
[08:25:48.280]                           quietly = TRUE)
[08:25:48.280]                         if (has_future) {
[08:25:48.280]                           ns <- base::getNamespace("future")
[08:25:48.280]                           version <- ns[[".package"]][["version"]]
[08:25:48.280]                           if (is.null(version)) 
[08:25:48.280]                             version <- utils::packageVersion("future")
[08:25:48.280]                         }
[08:25:48.280]                         else {
[08:25:48.280]                           version <- NULL
[08:25:48.280]                         }
[08:25:48.280]                         if (!has_future || version < "1.8.0") {
[08:25:48.280]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.280]                             "", base::R.version$version.string), 
[08:25:48.280]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.280]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.280]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.280]                               "release", "version")], collapse = " "), 
[08:25:48.280]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.280]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.280]                             info)
[08:25:48.280]                           info <- base::paste(info, collapse = "; ")
[08:25:48.280]                           if (!has_future) {
[08:25:48.280]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.280]                               info)
[08:25:48.280]                           }
[08:25:48.280]                           else {
[08:25:48.280]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.280]                               info, version)
[08:25:48.280]                           }
[08:25:48.280]                           base::stop(msg)
[08:25:48.280]                         }
[08:25:48.280]                       })
[08:25:48.280]                     }
[08:25:48.280]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.280]                     base::options(mc.cores = 1L)
[08:25:48.280]                   }
[08:25:48.280]                   ...future.strategy.old <- future::plan("list")
[08:25:48.280]                   options(future.plan = NULL)
[08:25:48.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.280]                 }
[08:25:48.280]                 ...future.workdir <- getwd()
[08:25:48.280]             }
[08:25:48.280]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.280]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.280]         }
[08:25:48.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.280]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.280]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.280]             base::names(...future.oldOptions))
[08:25:48.280]     }
[08:25:48.280]     if (FALSE) {
[08:25:48.280]     }
[08:25:48.280]     else {
[08:25:48.280]         if (TRUE) {
[08:25:48.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.280]                 open = "w")
[08:25:48.280]         }
[08:25:48.280]         else {
[08:25:48.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.280]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.280]         }
[08:25:48.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.280]             base::sink(type = "output", split = FALSE)
[08:25:48.280]             base::close(...future.stdout)
[08:25:48.280]         }, add = TRUE)
[08:25:48.280]     }
[08:25:48.280]     ...future.frame <- base::sys.nframe()
[08:25:48.280]     ...future.conditions <- base::list()
[08:25:48.280]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.280]     if (FALSE) {
[08:25:48.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.280]     }
[08:25:48.280]     ...future.result <- base::tryCatch({
[08:25:48.280]         base::withCallingHandlers({
[08:25:48.280]             ...future.value <- base::withVisible(base::local({
[08:25:48.280]                 withCallingHandlers({
[08:25:48.280]                   {
[08:25:48.280]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.280]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.280]                       ...future.globals.maxSize)) {
[08:25:48.280]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.280]                       on.exit(options(oopts), add = TRUE)
[08:25:48.280]                     }
[08:25:48.280]                     {
[08:25:48.280]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.280]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.280]                         USE.NAMES = FALSE)
[08:25:48.280]                       do.call(mapply, args = args)
[08:25:48.280]                     }
[08:25:48.280]                   }
[08:25:48.280]                 }, immediateCondition = function(cond) {
[08:25:48.280]                   save_rds <- function (object, pathname, ...) 
[08:25:48.280]                   {
[08:25:48.280]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.280]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.280]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.280]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.280]                         fi_tmp[["mtime"]])
[08:25:48.280]                     }
[08:25:48.280]                     tryCatch({
[08:25:48.280]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.280]                     }, error = function(ex) {
[08:25:48.280]                       msg <- conditionMessage(ex)
[08:25:48.280]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.280]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.280]                         fi_tmp[["mtime"]], msg)
[08:25:48.280]                       ex$message <- msg
[08:25:48.280]                       stop(ex)
[08:25:48.280]                     })
[08:25:48.280]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.280]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.280]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.280]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.280]                       fi <- file.info(pathname)
[08:25:48.280]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.280]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.280]                         fi[["size"]], fi[["mtime"]])
[08:25:48.280]                       stop(msg)
[08:25:48.280]                     }
[08:25:48.280]                     invisible(pathname)
[08:25:48.280]                   }
[08:25:48.280]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.280]                     rootPath = tempdir()) 
[08:25:48.280]                   {
[08:25:48.280]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.280]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.280]                       tmpdir = path, fileext = ".rds")
[08:25:48.280]                     save_rds(obj, file)
[08:25:48.280]                   }
[08:25:48.280]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.280]                   {
[08:25:48.280]                     inherits <- base::inherits
[08:25:48.280]                     invokeRestart <- base::invokeRestart
[08:25:48.280]                     is.null <- base::is.null
[08:25:48.280]                     muffled <- FALSE
[08:25:48.280]                     if (inherits(cond, "message")) {
[08:25:48.280]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.280]                       if (muffled) 
[08:25:48.280]                         invokeRestart("muffleMessage")
[08:25:48.280]                     }
[08:25:48.280]                     else if (inherits(cond, "warning")) {
[08:25:48.280]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.280]                       if (muffled) 
[08:25:48.280]                         invokeRestart("muffleWarning")
[08:25:48.280]                     }
[08:25:48.280]                     else if (inherits(cond, "condition")) {
[08:25:48.280]                       if (!is.null(pattern)) {
[08:25:48.280]                         computeRestarts <- base::computeRestarts
[08:25:48.280]                         grepl <- base::grepl
[08:25:48.280]                         restarts <- computeRestarts(cond)
[08:25:48.280]                         for (restart in restarts) {
[08:25:48.280]                           name <- restart$name
[08:25:48.280]                           if (is.null(name)) 
[08:25:48.280]                             next
[08:25:48.280]                           if (!grepl(pattern, name)) 
[08:25:48.280]                             next
[08:25:48.280]                           invokeRestart(restart)
[08:25:48.280]                           muffled <- TRUE
[08:25:48.280]                           break
[08:25:48.280]                         }
[08:25:48.280]                       }
[08:25:48.280]                     }
[08:25:48.280]                     invisible(muffled)
[08:25:48.280]                   }
[08:25:48.280]                   muffleCondition(cond)
[08:25:48.280]                 })
[08:25:48.280]             }))
[08:25:48.280]             future::FutureResult(value = ...future.value$value, 
[08:25:48.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.280]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.280]                     ...future.globalenv.names))
[08:25:48.280]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.280]         }, condition = base::local({
[08:25:48.280]             c <- base::c
[08:25:48.280]             inherits <- base::inherits
[08:25:48.280]             invokeRestart <- base::invokeRestart
[08:25:48.280]             length <- base::length
[08:25:48.280]             list <- base::list
[08:25:48.280]             seq.int <- base::seq.int
[08:25:48.280]             signalCondition <- base::signalCondition
[08:25:48.280]             sys.calls <- base::sys.calls
[08:25:48.280]             `[[` <- base::`[[`
[08:25:48.280]             `+` <- base::`+`
[08:25:48.280]             `<<-` <- base::`<<-`
[08:25:48.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.280]                   3L)]
[08:25:48.280]             }
[08:25:48.280]             function(cond) {
[08:25:48.280]                 is_error <- inherits(cond, "error")
[08:25:48.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.280]                   NULL)
[08:25:48.280]                 if (is_error) {
[08:25:48.280]                   sessionInformation <- function() {
[08:25:48.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.280]                       search = base::search(), system = base::Sys.info())
[08:25:48.280]                   }
[08:25:48.280]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.280]                     cond$call), session = sessionInformation(), 
[08:25:48.280]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.280]                   signalCondition(cond)
[08:25:48.280]                 }
[08:25:48.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.280]                 "immediateCondition"))) {
[08:25:48.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.280]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.280]                   if (TRUE && !signal) {
[08:25:48.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.280]                     {
[08:25:48.280]                       inherits <- base::inherits
[08:25:48.280]                       invokeRestart <- base::invokeRestart
[08:25:48.280]                       is.null <- base::is.null
[08:25:48.280]                       muffled <- FALSE
[08:25:48.280]                       if (inherits(cond, "message")) {
[08:25:48.280]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.280]                         if (muffled) 
[08:25:48.280]                           invokeRestart("muffleMessage")
[08:25:48.280]                       }
[08:25:48.280]                       else if (inherits(cond, "warning")) {
[08:25:48.280]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.280]                         if (muffled) 
[08:25:48.280]                           invokeRestart("muffleWarning")
[08:25:48.280]                       }
[08:25:48.280]                       else if (inherits(cond, "condition")) {
[08:25:48.280]                         if (!is.null(pattern)) {
[08:25:48.280]                           computeRestarts <- base::computeRestarts
[08:25:48.280]                           grepl <- base::grepl
[08:25:48.280]                           restarts <- computeRestarts(cond)
[08:25:48.280]                           for (restart in restarts) {
[08:25:48.280]                             name <- restart$name
[08:25:48.280]                             if (is.null(name)) 
[08:25:48.280]                               next
[08:25:48.280]                             if (!grepl(pattern, name)) 
[08:25:48.280]                               next
[08:25:48.280]                             invokeRestart(restart)
[08:25:48.280]                             muffled <- TRUE
[08:25:48.280]                             break
[08:25:48.280]                           }
[08:25:48.280]                         }
[08:25:48.280]                       }
[08:25:48.280]                       invisible(muffled)
[08:25:48.280]                     }
[08:25:48.280]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.280]                   }
[08:25:48.280]                 }
[08:25:48.280]                 else {
[08:25:48.280]                   if (TRUE) {
[08:25:48.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.280]                     {
[08:25:48.280]                       inherits <- base::inherits
[08:25:48.280]                       invokeRestart <- base::invokeRestart
[08:25:48.280]                       is.null <- base::is.null
[08:25:48.280]                       muffled <- FALSE
[08:25:48.280]                       if (inherits(cond, "message")) {
[08:25:48.280]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.280]                         if (muffled) 
[08:25:48.280]                           invokeRestart("muffleMessage")
[08:25:48.280]                       }
[08:25:48.280]                       else if (inherits(cond, "warning")) {
[08:25:48.280]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.280]                         if (muffled) 
[08:25:48.280]                           invokeRestart("muffleWarning")
[08:25:48.280]                       }
[08:25:48.280]                       else if (inherits(cond, "condition")) {
[08:25:48.280]                         if (!is.null(pattern)) {
[08:25:48.280]                           computeRestarts <- base::computeRestarts
[08:25:48.280]                           grepl <- base::grepl
[08:25:48.280]                           restarts <- computeRestarts(cond)
[08:25:48.280]                           for (restart in restarts) {
[08:25:48.280]                             name <- restart$name
[08:25:48.280]                             if (is.null(name)) 
[08:25:48.280]                               next
[08:25:48.280]                             if (!grepl(pattern, name)) 
[08:25:48.280]                               next
[08:25:48.280]                             invokeRestart(restart)
[08:25:48.280]                             muffled <- TRUE
[08:25:48.280]                             break
[08:25:48.280]                           }
[08:25:48.280]                         }
[08:25:48.280]                       }
[08:25:48.280]                       invisible(muffled)
[08:25:48.280]                     }
[08:25:48.280]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.280]                   }
[08:25:48.280]                 }
[08:25:48.280]             }
[08:25:48.280]         }))
[08:25:48.280]     }, error = function(ex) {
[08:25:48.280]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.280]                 ...future.rng), started = ...future.startTime, 
[08:25:48.280]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.280]             version = "1.8"), class = "FutureResult")
[08:25:48.280]     }, finally = {
[08:25:48.280]         if (!identical(...future.workdir, getwd())) 
[08:25:48.280]             setwd(...future.workdir)
[08:25:48.280]         {
[08:25:48.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.280]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.280]             }
[08:25:48.280]             base::options(...future.oldOptions)
[08:25:48.280]             if (.Platform$OS.type == "windows") {
[08:25:48.280]                 old_names <- names(...future.oldEnvVars)
[08:25:48.280]                 envs <- base::Sys.getenv()
[08:25:48.280]                 names <- names(envs)
[08:25:48.280]                 common <- intersect(names, old_names)
[08:25:48.280]                 added <- setdiff(names, old_names)
[08:25:48.280]                 removed <- setdiff(old_names, names)
[08:25:48.280]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.280]                   envs[common]]
[08:25:48.280]                 NAMES <- toupper(changed)
[08:25:48.280]                 args <- list()
[08:25:48.280]                 for (kk in seq_along(NAMES)) {
[08:25:48.280]                   name <- changed[[kk]]
[08:25:48.280]                   NAME <- NAMES[[kk]]
[08:25:48.280]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.280]                     next
[08:25:48.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.280]                 }
[08:25:48.280]                 NAMES <- toupper(added)
[08:25:48.280]                 for (kk in seq_along(NAMES)) {
[08:25:48.280]                   name <- added[[kk]]
[08:25:48.280]                   NAME <- NAMES[[kk]]
[08:25:48.280]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.280]                     next
[08:25:48.280]                   args[[name]] <- ""
[08:25:48.280]                 }
[08:25:48.280]                 NAMES <- toupper(removed)
[08:25:48.280]                 for (kk in seq_along(NAMES)) {
[08:25:48.280]                   name <- removed[[kk]]
[08:25:48.280]                   NAME <- NAMES[[kk]]
[08:25:48.280]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.280]                     next
[08:25:48.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.280]                 }
[08:25:48.280]                 if (length(args) > 0) 
[08:25:48.280]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.280]             }
[08:25:48.280]             else {
[08:25:48.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.280]             }
[08:25:48.280]             {
[08:25:48.280]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.280]                   0L) {
[08:25:48.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.280]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.280]                   base::options(opts)
[08:25:48.280]                 }
[08:25:48.280]                 {
[08:25:48.280]                   {
[08:25:48.280]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.280]                     NULL
[08:25:48.280]                   }
[08:25:48.280]                   options(future.plan = NULL)
[08:25:48.280]                   if (is.na(NA_character_)) 
[08:25:48.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.280]                     .init = FALSE)
[08:25:48.280]                 }
[08:25:48.280]             }
[08:25:48.280]         }
[08:25:48.280]     })
[08:25:48.280]     if (TRUE) {
[08:25:48.280]         base::sink(type = "output", split = FALSE)
[08:25:48.280]         if (TRUE) {
[08:25:48.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.280]         }
[08:25:48.280]         else {
[08:25:48.280]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.280]         }
[08:25:48.280]         base::close(...future.stdout)
[08:25:48.280]         ...future.stdout <- NULL
[08:25:48.280]     }
[08:25:48.280]     ...future.result$conditions <- ...future.conditions
[08:25:48.280]     ...future.result$finished <- base::Sys.time()
[08:25:48.280]     ...future.result
[08:25:48.280] }
[08:25:48.284] assign_globals() ...
[08:25:48.284] List of 5
[08:25:48.284]  $ ...future.FUN            :function (x, ...)  
[08:25:48.284]  $ MoreArgs                 : NULL
[08:25:48.284]  $ ...future.elements_ii    :List of 2
[08:25:48.284]   ..$ :List of 2
[08:25:48.284]   .. ..$ : int 3
[08:25:48.284]   .. ..$ : int 4
[08:25:48.284]   ..$ :List of 2
[08:25:48.284]   .. ..$ : int 2
[08:25:48.284]   .. ..$ : int 1
[08:25:48.284]  $ ...future.seeds_ii       : NULL
[08:25:48.284]  $ ...future.globals.maxSize: NULL
[08:25:48.284]  - attr(*, "where")=List of 5
[08:25:48.284]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.284]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.284]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.284]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.284]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.284]  - attr(*, "resolved")= logi FALSE
[08:25:48.284]  - attr(*, "total_size")= num 210
[08:25:48.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.284]  - attr(*, "already-done")= logi TRUE
[08:25:48.297] - copied ‘...future.FUN’ to environment
[08:25:48.298] - copied ‘MoreArgs’ to environment
[08:25:48.298] - copied ‘...future.elements_ii’ to environment
[08:25:48.298] - copied ‘...future.seeds_ii’ to environment
[08:25:48.298] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.299] assign_globals() ... done
[08:25:48.299] requestCore(): workers = 2
[08:25:48.302] MulticoreFuture started
[08:25:48.303] - Launch lazy future ... done
[08:25:48.303] plan(): Setting new future strategy stack:
[08:25:48.303] run() for ‘MulticoreFuture’ ... done
[08:25:48.304] Created future:
[08:25:48.304] List of future strategies:
[08:25:48.304] 1. sequential:
[08:25:48.304]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.304]    - tweaked: FALSE
[08:25:48.304]    - call: NULL
[08:25:48.306] plan(): nbrOfWorkers() = 1
[08:25:48.311] plan(): Setting new future strategy stack:
[08:25:48.311] List of future strategies:
[08:25:48.311] 1. multicore:
[08:25:48.311]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.311]    - tweaked: FALSE
[08:25:48.311]    - call: plan(strategy)
[08:25:48.317] plan(): nbrOfWorkers() = 2
[08:25:48.304] MulticoreFuture:
[08:25:48.304] Label: ‘future_mapply-2’
[08:25:48.304] Expression:
[08:25:48.304] {
[08:25:48.304]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.304]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.304]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.304]         on.exit(options(oopts), add = TRUE)
[08:25:48.304]     }
[08:25:48.304]     {
[08:25:48.304]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.304]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.304]         do.call(mapply, args = args)
[08:25:48.304]     }
[08:25:48.304] }
[08:25:48.304] Lazy evaluation: FALSE
[08:25:48.304] Asynchronous evaluation: TRUE
[08:25:48.304] Local evaluation: TRUE
[08:25:48.304] Environment: R_GlobalEnv
[08:25:48.304] Capture standard output: TRUE
[08:25:48.304] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.304] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.304] Packages: <none>
[08:25:48.304] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.304] Resolved: FALSE
[08:25:48.304] Value: <not collected>
[08:25:48.304] Conditions captured: <none>
[08:25:48.304] Early signaling: FALSE
[08:25:48.304] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.304] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.319] Chunk #2 of 2 ... DONE
[08:25:48.319] Launching 2 futures (chunks) ... DONE
[08:25:48.319] Resolving 2 futures (chunks) ...
[08:25:48.320] resolve() on list ...
[08:25:48.320]  recursive: 0
[08:25:48.320]  length: 2
[08:25:48.320] 
[08:25:48.321] Future #1
[08:25:48.321] result() for MulticoreFuture ...
[08:25:48.323] result() for MulticoreFuture ...
[08:25:48.323] result() for MulticoreFuture ... done
[08:25:48.324] result() for MulticoreFuture ... done
[08:25:48.324] result() for MulticoreFuture ...
[08:25:48.324] result() for MulticoreFuture ... done
[08:25:48.325] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:48.325] - nx: 2
[08:25:48.325] - relay: TRUE
[08:25:48.325] - stdout: TRUE
[08:25:48.326] - signal: TRUE
[08:25:48.326] - resignal: FALSE
[08:25:48.326] - force: TRUE
[08:25:48.327] - relayed: [n=2] FALSE, FALSE
[08:25:48.327] - queued futures: [n=2] FALSE, FALSE
[08:25:48.327]  - until=1
[08:25:48.327]  - relaying element #1
[08:25:48.328] result() for MulticoreFuture ...
[08:25:48.328] result() for MulticoreFuture ... done
[08:25:48.328] result() for MulticoreFuture ...
[08:25:48.329] result() for MulticoreFuture ... done
[08:25:48.329] result() for MulticoreFuture ...
[08:25:48.329] result() for MulticoreFuture ... done
[08:25:48.329] result() for MulticoreFuture ...
[08:25:48.330] result() for MulticoreFuture ... done
[08:25:48.330] - relayed: [n=2] TRUE, FALSE
[08:25:48.330] - queued futures: [n=2] TRUE, FALSE
[08:25:48.330] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:48.331]  length: 1 (resolved future 1)
[08:25:48.331] Future #2
[08:25:48.332] result() for MulticoreFuture ...
[08:25:48.333] result() for MulticoreFuture ...
[08:25:48.333] result() for MulticoreFuture ... done
[08:25:48.333] result() for MulticoreFuture ... done
[08:25:48.333] result() for MulticoreFuture ...
[08:25:48.334] result() for MulticoreFuture ... done
[08:25:48.334] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:48.334] - nx: 2
[08:25:48.334] - relay: TRUE
[08:25:48.334] - stdout: TRUE
[08:25:48.335] - signal: TRUE
[08:25:48.335] - resignal: FALSE
[08:25:48.335] - force: TRUE
[08:25:48.335] - relayed: [n=2] TRUE, FALSE
[08:25:48.335] - queued futures: [n=2] TRUE, FALSE
[08:25:48.336]  - until=2
[08:25:48.336]  - relaying element #2
[08:25:48.336] result() for MulticoreFuture ...
[08:25:48.336] result() for MulticoreFuture ... done
[08:25:48.336] result() for MulticoreFuture ...
[08:25:48.336] result() for MulticoreFuture ... done
[08:25:48.337] result() for MulticoreFuture ...
[08:25:48.337] result() for MulticoreFuture ... done
[08:25:48.337] result() for MulticoreFuture ...
[08:25:48.337] result() for MulticoreFuture ... done
[08:25:48.337] - relayed: [n=2] TRUE, TRUE
[08:25:48.337] - queued futures: [n=2] TRUE, TRUE
[08:25:48.338] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:48.338]  length: 0 (resolved future 2)
[08:25:48.338] Relaying remaining futures
[08:25:48.338] signalConditionsASAP(NULL, pos=0) ...
[08:25:48.338] - nx: 2
[08:25:48.338] - relay: TRUE
[08:25:48.339] - stdout: TRUE
[08:25:48.339] - signal: TRUE
[08:25:48.339] - resignal: FALSE
[08:25:48.339] - force: TRUE
[08:25:48.339] - relayed: [n=2] TRUE, TRUE
[08:25:48.339] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:48.339] - relayed: [n=2] TRUE, TRUE
[08:25:48.340] - queued futures: [n=2] TRUE, TRUE
[08:25:48.340] signalConditionsASAP(NULL, pos=0) ... done
[08:25:48.340] resolve() on list ... DONE
[08:25:48.340] result() for MulticoreFuture ...
[08:25:48.340] result() for MulticoreFuture ... done
[08:25:48.340] result() for MulticoreFuture ...
[08:25:48.341] result() for MulticoreFuture ... done
[08:25:48.341] result() for MulticoreFuture ...
[08:25:48.341] result() for MulticoreFuture ... done
[08:25:48.341] result() for MulticoreFuture ...
[08:25:48.341] result() for MulticoreFuture ... done
[08:25:48.341]  - Number of value chunks collected: 2
[08:25:48.341] Resolving 2 futures (chunks) ... DONE
[08:25:48.341] Reducing values from 2 chunks ...
[08:25:48.342]  - Number of values collected after concatenation: 4
[08:25:48.342]  - Number of values expected: 4
[08:25:48.342] Reducing values from 2 chunks ... DONE
[08:25:48.342] future_mapply() ... DONE
[08:25:48.342] future_mapply() ...
[08:25:48.345] Number of chunks: 2
[08:25:48.345] getGlobalsAndPackagesXApply() ...
[08:25:48.345]  - future.globals: TRUE
[08:25:48.346] getGlobalsAndPackages() ...
[08:25:48.346] Searching for globals...
[08:25:48.347] - globals found: [1] ‘FUN’
[08:25:48.347] Searching for globals ... DONE
[08:25:48.347] Resolving globals: FALSE
[08:25:48.348] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:48.348] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:48.349] - globals: [1] ‘FUN’
[08:25:48.349] 
[08:25:48.349] getGlobalsAndPackages() ... DONE
[08:25:48.349]  - globals found/used: [n=1] ‘FUN’
[08:25:48.349]  - needed namespaces: [n=0] 
[08:25:48.349] Finding globals ... DONE
[08:25:48.350] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:48.350] List of 2
[08:25:48.350]  $ ...future.FUN:function (x, ...)  
[08:25:48.350]  $ MoreArgs     : NULL
[08:25:48.350]  - attr(*, "where")=List of 2
[08:25:48.350]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:48.350]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:48.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.350]  - attr(*, "resolved")= logi FALSE
[08:25:48.350]  - attr(*, "total_size")= num NA
[08:25:48.357] Packages to be attached in all futures: [n=0] 
[08:25:48.357] getGlobalsAndPackagesXApply() ... DONE
[08:25:48.357] Number of futures (= number of chunks): 2
[08:25:48.357] Launching 2 futures (chunks) ...
[08:25:48.358] Chunk #1 of 2 ...
[08:25:48.358]  - Finding globals in '...' for chunk #1 ...
[08:25:48.358] getGlobalsAndPackages() ...
[08:25:48.358] Searching for globals...
[08:25:48.359] 
[08:25:48.359] Searching for globals ... DONE
[08:25:48.359] - globals: [0] <none>
[08:25:48.359] getGlobalsAndPackages() ... DONE
[08:25:48.359]    + additional globals found: [n=0] 
[08:25:48.359]    + additional namespaces needed: [n=0] 
[08:25:48.359]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:48.360]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.360]  - seeds: <none>
[08:25:48.360]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.360] getGlobalsAndPackages() ...
[08:25:48.360] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.360] Resolving globals: FALSE
[08:25:48.361] The total size of the 5 globals is 265 bytes (265 bytes)
[08:25:48.362] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.362] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.362] 
[08:25:48.362] getGlobalsAndPackages() ... DONE
[08:25:48.362] run() for ‘Future’ ...
[08:25:48.363] - state: ‘created’
[08:25:48.363] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.365] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.365] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.365]   - Field: ‘label’
[08:25:48.365]   - Field: ‘local’
[08:25:48.365]   - Field: ‘owner’
[08:25:48.365]   - Field: ‘envir’
[08:25:48.365]   - Field: ‘workers’
[08:25:48.365]   - Field: ‘packages’
[08:25:48.365]   - Field: ‘gc’
[08:25:48.366]   - Field: ‘job’
[08:25:48.366]   - Field: ‘conditions’
[08:25:48.366]   - Field: ‘expr’
[08:25:48.366]   - Field: ‘uuid’
[08:25:48.366]   - Field: ‘seed’
[08:25:48.366]   - Field: ‘version’
[08:25:48.366]   - Field: ‘result’
[08:25:48.366]   - Field: ‘asynchronous’
[08:25:48.366]   - Field: ‘calls’
[08:25:48.366]   - Field: ‘globals’
[08:25:48.366]   - Field: ‘stdout’
[08:25:48.367]   - Field: ‘earlySignal’
[08:25:48.367]   - Field: ‘lazy’
[08:25:48.367]   - Field: ‘state’
[08:25:48.367] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.367] - Launch lazy future ...
[08:25:48.367] Packages needed by the future expression (n = 0): <none>
[08:25:48.367] Packages needed by future strategies (n = 0): <none>
[08:25:48.368] {
[08:25:48.368]     {
[08:25:48.368]         {
[08:25:48.368]             ...future.startTime <- base::Sys.time()
[08:25:48.368]             {
[08:25:48.368]                 {
[08:25:48.368]                   {
[08:25:48.368]                     {
[08:25:48.368]                       base::local({
[08:25:48.368]                         has_future <- base::requireNamespace("future", 
[08:25:48.368]                           quietly = TRUE)
[08:25:48.368]                         if (has_future) {
[08:25:48.368]                           ns <- base::getNamespace("future")
[08:25:48.368]                           version <- ns[[".package"]][["version"]]
[08:25:48.368]                           if (is.null(version)) 
[08:25:48.368]                             version <- utils::packageVersion("future")
[08:25:48.368]                         }
[08:25:48.368]                         else {
[08:25:48.368]                           version <- NULL
[08:25:48.368]                         }
[08:25:48.368]                         if (!has_future || version < "1.8.0") {
[08:25:48.368]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.368]                             "", base::R.version$version.string), 
[08:25:48.368]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.368]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.368]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.368]                               "release", "version")], collapse = " "), 
[08:25:48.368]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.368]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.368]                             info)
[08:25:48.368]                           info <- base::paste(info, collapse = "; ")
[08:25:48.368]                           if (!has_future) {
[08:25:48.368]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.368]                               info)
[08:25:48.368]                           }
[08:25:48.368]                           else {
[08:25:48.368]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.368]                               info, version)
[08:25:48.368]                           }
[08:25:48.368]                           base::stop(msg)
[08:25:48.368]                         }
[08:25:48.368]                       })
[08:25:48.368]                     }
[08:25:48.368]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.368]                     base::options(mc.cores = 1L)
[08:25:48.368]                   }
[08:25:48.368]                   ...future.strategy.old <- future::plan("list")
[08:25:48.368]                   options(future.plan = NULL)
[08:25:48.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.368]                 }
[08:25:48.368]                 ...future.workdir <- getwd()
[08:25:48.368]             }
[08:25:48.368]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.368]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.368]         }
[08:25:48.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.368]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.368]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.368]             base::names(...future.oldOptions))
[08:25:48.368]     }
[08:25:48.368]     if (FALSE) {
[08:25:48.368]     }
[08:25:48.368]     else {
[08:25:48.368]         if (TRUE) {
[08:25:48.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.368]                 open = "w")
[08:25:48.368]         }
[08:25:48.368]         else {
[08:25:48.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.368]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.368]         }
[08:25:48.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.368]             base::sink(type = "output", split = FALSE)
[08:25:48.368]             base::close(...future.stdout)
[08:25:48.368]         }, add = TRUE)
[08:25:48.368]     }
[08:25:48.368]     ...future.frame <- base::sys.nframe()
[08:25:48.368]     ...future.conditions <- base::list()
[08:25:48.368]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.368]     if (FALSE) {
[08:25:48.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.368]     }
[08:25:48.368]     ...future.result <- base::tryCatch({
[08:25:48.368]         base::withCallingHandlers({
[08:25:48.368]             ...future.value <- base::withVisible(base::local({
[08:25:48.368]                 withCallingHandlers({
[08:25:48.368]                   {
[08:25:48.368]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.368]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.368]                       ...future.globals.maxSize)) {
[08:25:48.368]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.368]                       on.exit(options(oopts), add = TRUE)
[08:25:48.368]                     }
[08:25:48.368]                     {
[08:25:48.368]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.368]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.368]                         USE.NAMES = FALSE)
[08:25:48.368]                       do.call(mapply, args = args)
[08:25:48.368]                     }
[08:25:48.368]                   }
[08:25:48.368]                 }, immediateCondition = function(cond) {
[08:25:48.368]                   save_rds <- function (object, pathname, ...) 
[08:25:48.368]                   {
[08:25:48.368]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.368]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.368]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.368]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.368]                         fi_tmp[["mtime"]])
[08:25:48.368]                     }
[08:25:48.368]                     tryCatch({
[08:25:48.368]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.368]                     }, error = function(ex) {
[08:25:48.368]                       msg <- conditionMessage(ex)
[08:25:48.368]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.368]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.368]                         fi_tmp[["mtime"]], msg)
[08:25:48.368]                       ex$message <- msg
[08:25:48.368]                       stop(ex)
[08:25:48.368]                     })
[08:25:48.368]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.368]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.368]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.368]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.368]                       fi <- file.info(pathname)
[08:25:48.368]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.368]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.368]                         fi[["size"]], fi[["mtime"]])
[08:25:48.368]                       stop(msg)
[08:25:48.368]                     }
[08:25:48.368]                     invisible(pathname)
[08:25:48.368]                   }
[08:25:48.368]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.368]                     rootPath = tempdir()) 
[08:25:48.368]                   {
[08:25:48.368]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.368]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.368]                       tmpdir = path, fileext = ".rds")
[08:25:48.368]                     save_rds(obj, file)
[08:25:48.368]                   }
[08:25:48.368]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.368]                   {
[08:25:48.368]                     inherits <- base::inherits
[08:25:48.368]                     invokeRestart <- base::invokeRestart
[08:25:48.368]                     is.null <- base::is.null
[08:25:48.368]                     muffled <- FALSE
[08:25:48.368]                     if (inherits(cond, "message")) {
[08:25:48.368]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.368]                       if (muffled) 
[08:25:48.368]                         invokeRestart("muffleMessage")
[08:25:48.368]                     }
[08:25:48.368]                     else if (inherits(cond, "warning")) {
[08:25:48.368]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.368]                       if (muffled) 
[08:25:48.368]                         invokeRestart("muffleWarning")
[08:25:48.368]                     }
[08:25:48.368]                     else if (inherits(cond, "condition")) {
[08:25:48.368]                       if (!is.null(pattern)) {
[08:25:48.368]                         computeRestarts <- base::computeRestarts
[08:25:48.368]                         grepl <- base::grepl
[08:25:48.368]                         restarts <- computeRestarts(cond)
[08:25:48.368]                         for (restart in restarts) {
[08:25:48.368]                           name <- restart$name
[08:25:48.368]                           if (is.null(name)) 
[08:25:48.368]                             next
[08:25:48.368]                           if (!grepl(pattern, name)) 
[08:25:48.368]                             next
[08:25:48.368]                           invokeRestart(restart)
[08:25:48.368]                           muffled <- TRUE
[08:25:48.368]                           break
[08:25:48.368]                         }
[08:25:48.368]                       }
[08:25:48.368]                     }
[08:25:48.368]                     invisible(muffled)
[08:25:48.368]                   }
[08:25:48.368]                   muffleCondition(cond)
[08:25:48.368]                 })
[08:25:48.368]             }))
[08:25:48.368]             future::FutureResult(value = ...future.value$value, 
[08:25:48.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.368]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.368]                     ...future.globalenv.names))
[08:25:48.368]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.368]         }, condition = base::local({
[08:25:48.368]             c <- base::c
[08:25:48.368]             inherits <- base::inherits
[08:25:48.368]             invokeRestart <- base::invokeRestart
[08:25:48.368]             length <- base::length
[08:25:48.368]             list <- base::list
[08:25:48.368]             seq.int <- base::seq.int
[08:25:48.368]             signalCondition <- base::signalCondition
[08:25:48.368]             sys.calls <- base::sys.calls
[08:25:48.368]             `[[` <- base::`[[`
[08:25:48.368]             `+` <- base::`+`
[08:25:48.368]             `<<-` <- base::`<<-`
[08:25:48.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.368]                   3L)]
[08:25:48.368]             }
[08:25:48.368]             function(cond) {
[08:25:48.368]                 is_error <- inherits(cond, "error")
[08:25:48.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.368]                   NULL)
[08:25:48.368]                 if (is_error) {
[08:25:48.368]                   sessionInformation <- function() {
[08:25:48.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.368]                       search = base::search(), system = base::Sys.info())
[08:25:48.368]                   }
[08:25:48.368]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.368]                     cond$call), session = sessionInformation(), 
[08:25:48.368]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.368]                   signalCondition(cond)
[08:25:48.368]                 }
[08:25:48.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.368]                 "immediateCondition"))) {
[08:25:48.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.368]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.368]                   if (TRUE && !signal) {
[08:25:48.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.368]                     {
[08:25:48.368]                       inherits <- base::inherits
[08:25:48.368]                       invokeRestart <- base::invokeRestart
[08:25:48.368]                       is.null <- base::is.null
[08:25:48.368]                       muffled <- FALSE
[08:25:48.368]                       if (inherits(cond, "message")) {
[08:25:48.368]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.368]                         if (muffled) 
[08:25:48.368]                           invokeRestart("muffleMessage")
[08:25:48.368]                       }
[08:25:48.368]                       else if (inherits(cond, "warning")) {
[08:25:48.368]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.368]                         if (muffled) 
[08:25:48.368]                           invokeRestart("muffleWarning")
[08:25:48.368]                       }
[08:25:48.368]                       else if (inherits(cond, "condition")) {
[08:25:48.368]                         if (!is.null(pattern)) {
[08:25:48.368]                           computeRestarts <- base::computeRestarts
[08:25:48.368]                           grepl <- base::grepl
[08:25:48.368]                           restarts <- computeRestarts(cond)
[08:25:48.368]                           for (restart in restarts) {
[08:25:48.368]                             name <- restart$name
[08:25:48.368]                             if (is.null(name)) 
[08:25:48.368]                               next
[08:25:48.368]                             if (!grepl(pattern, name)) 
[08:25:48.368]                               next
[08:25:48.368]                             invokeRestart(restart)
[08:25:48.368]                             muffled <- TRUE
[08:25:48.368]                             break
[08:25:48.368]                           }
[08:25:48.368]                         }
[08:25:48.368]                       }
[08:25:48.368]                       invisible(muffled)
[08:25:48.368]                     }
[08:25:48.368]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.368]                   }
[08:25:48.368]                 }
[08:25:48.368]                 else {
[08:25:48.368]                   if (TRUE) {
[08:25:48.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.368]                     {
[08:25:48.368]                       inherits <- base::inherits
[08:25:48.368]                       invokeRestart <- base::invokeRestart
[08:25:48.368]                       is.null <- base::is.null
[08:25:48.368]                       muffled <- FALSE
[08:25:48.368]                       if (inherits(cond, "message")) {
[08:25:48.368]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.368]                         if (muffled) 
[08:25:48.368]                           invokeRestart("muffleMessage")
[08:25:48.368]                       }
[08:25:48.368]                       else if (inherits(cond, "warning")) {
[08:25:48.368]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.368]                         if (muffled) 
[08:25:48.368]                           invokeRestart("muffleWarning")
[08:25:48.368]                       }
[08:25:48.368]                       else if (inherits(cond, "condition")) {
[08:25:48.368]                         if (!is.null(pattern)) {
[08:25:48.368]                           computeRestarts <- base::computeRestarts
[08:25:48.368]                           grepl <- base::grepl
[08:25:48.368]                           restarts <- computeRestarts(cond)
[08:25:48.368]                           for (restart in restarts) {
[08:25:48.368]                             name <- restart$name
[08:25:48.368]                             if (is.null(name)) 
[08:25:48.368]                               next
[08:25:48.368]                             if (!grepl(pattern, name)) 
[08:25:48.368]                               next
[08:25:48.368]                             invokeRestart(restart)
[08:25:48.368]                             muffled <- TRUE
[08:25:48.368]                             break
[08:25:48.368]                           }
[08:25:48.368]                         }
[08:25:48.368]                       }
[08:25:48.368]                       invisible(muffled)
[08:25:48.368]                     }
[08:25:48.368]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.368]                   }
[08:25:48.368]                 }
[08:25:48.368]             }
[08:25:48.368]         }))
[08:25:48.368]     }, error = function(ex) {
[08:25:48.368]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.368]                 ...future.rng), started = ...future.startTime, 
[08:25:48.368]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.368]             version = "1.8"), class = "FutureResult")
[08:25:48.368]     }, finally = {
[08:25:48.368]         if (!identical(...future.workdir, getwd())) 
[08:25:48.368]             setwd(...future.workdir)
[08:25:48.368]         {
[08:25:48.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.368]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.368]             }
[08:25:48.368]             base::options(...future.oldOptions)
[08:25:48.368]             if (.Platform$OS.type == "windows") {
[08:25:48.368]                 old_names <- names(...future.oldEnvVars)
[08:25:48.368]                 envs <- base::Sys.getenv()
[08:25:48.368]                 names <- names(envs)
[08:25:48.368]                 common <- intersect(names, old_names)
[08:25:48.368]                 added <- setdiff(names, old_names)
[08:25:48.368]                 removed <- setdiff(old_names, names)
[08:25:48.368]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.368]                   envs[common]]
[08:25:48.368]                 NAMES <- toupper(changed)
[08:25:48.368]                 args <- list()
[08:25:48.368]                 for (kk in seq_along(NAMES)) {
[08:25:48.368]                   name <- changed[[kk]]
[08:25:48.368]                   NAME <- NAMES[[kk]]
[08:25:48.368]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.368]                     next
[08:25:48.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.368]                 }
[08:25:48.368]                 NAMES <- toupper(added)
[08:25:48.368]                 for (kk in seq_along(NAMES)) {
[08:25:48.368]                   name <- added[[kk]]
[08:25:48.368]                   NAME <- NAMES[[kk]]
[08:25:48.368]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.368]                     next
[08:25:48.368]                   args[[name]] <- ""
[08:25:48.368]                 }
[08:25:48.368]                 NAMES <- toupper(removed)
[08:25:48.368]                 for (kk in seq_along(NAMES)) {
[08:25:48.368]                   name <- removed[[kk]]
[08:25:48.368]                   NAME <- NAMES[[kk]]
[08:25:48.368]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.368]                     next
[08:25:48.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.368]                 }
[08:25:48.368]                 if (length(args) > 0) 
[08:25:48.368]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.368]             }
[08:25:48.368]             else {
[08:25:48.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.368]             }
[08:25:48.368]             {
[08:25:48.368]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.368]                   0L) {
[08:25:48.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.368]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.368]                   base::options(opts)
[08:25:48.368]                 }
[08:25:48.368]                 {
[08:25:48.368]                   {
[08:25:48.368]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.368]                     NULL
[08:25:48.368]                   }
[08:25:48.368]                   options(future.plan = NULL)
[08:25:48.368]                   if (is.na(NA_character_)) 
[08:25:48.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.368]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.368]                     .init = FALSE)
[08:25:48.368]                 }
[08:25:48.368]             }
[08:25:48.368]         }
[08:25:48.368]     })
[08:25:48.368]     if (TRUE) {
[08:25:48.368]         base::sink(type = "output", split = FALSE)
[08:25:48.368]         if (TRUE) {
[08:25:48.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.368]         }
[08:25:48.368]         else {
[08:25:48.368]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.368]         }
[08:25:48.368]         base::close(...future.stdout)
[08:25:48.368]         ...future.stdout <- NULL
[08:25:48.368]     }
[08:25:48.368]     ...future.result$conditions <- ...future.conditions
[08:25:48.368]     ...future.result$finished <- base::Sys.time()
[08:25:48.368]     ...future.result
[08:25:48.368] }
[08:25:48.371] assign_globals() ...
[08:25:48.372] List of 5
[08:25:48.372]  $ ...future.FUN            :function (x, ...)  
[08:25:48.372]  $ MoreArgs                 : NULL
[08:25:48.372]  $ ...future.elements_ii    :List of 2
[08:25:48.372]   ..$ times:List of 2
[08:25:48.372]   .. ..$ : int 1
[08:25:48.372]   .. ..$ : int 2
[08:25:48.372]   ..$ x    :List of 2
[08:25:48.372]   .. ..$ : int 4
[08:25:48.372]   .. ..$ : int 3
[08:25:48.372]  $ ...future.seeds_ii       : NULL
[08:25:48.372]  $ ...future.globals.maxSize: NULL
[08:25:48.372]  - attr(*, "where")=List of 5
[08:25:48.372]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.372]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.372]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.372]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.372]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.372]  - attr(*, "resolved")= logi FALSE
[08:25:48.372]  - attr(*, "total_size")= num 265
[08:25:48.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.372]  - attr(*, "already-done")= logi TRUE
[08:25:48.377] - copied ‘...future.FUN’ to environment
[08:25:48.378] - copied ‘MoreArgs’ to environment
[08:25:48.378] - copied ‘...future.elements_ii’ to environment
[08:25:48.378] - copied ‘...future.seeds_ii’ to environment
[08:25:48.378] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.378] assign_globals() ... done
[08:25:48.378] requestCore(): workers = 2
[08:25:48.381] MulticoreFuture started
[08:25:48.381] - Launch lazy future ... done
[08:25:48.381] run() for ‘MulticoreFuture’ ... done
[08:25:48.382] Created future:
[08:25:48.382] plan(): Setting new future strategy stack:
[08:25:48.382] List of future strategies:
[08:25:48.382] 1. sequential:
[08:25:48.382]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.382]    - tweaked: FALSE
[08:25:48.382]    - call: NULL
[08:25:48.383] plan(): nbrOfWorkers() = 1
[08:25:48.385] plan(): Setting new future strategy stack:
[08:25:48.385] List of future strategies:
[08:25:48.385] 1. multicore:
[08:25:48.385]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.385]    - tweaked: FALSE
[08:25:48.385]    - call: plan(strategy)
[08:25:48.389] plan(): nbrOfWorkers() = 2
[08:25:48.382] MulticoreFuture:
[08:25:48.382] Label: ‘future_mapply-1’
[08:25:48.382] Expression:
[08:25:48.382] {
[08:25:48.382]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.382]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.382]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.382]         on.exit(options(oopts), add = TRUE)
[08:25:48.382]     }
[08:25:48.382]     {
[08:25:48.382]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.382]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.382]         do.call(mapply, args = args)
[08:25:48.382]     }
[08:25:48.382] }
[08:25:48.382] Lazy evaluation: FALSE
[08:25:48.382] Asynchronous evaluation: TRUE
[08:25:48.382] Local evaluation: TRUE
[08:25:48.382] Environment: R_GlobalEnv
[08:25:48.382] Capture standard output: TRUE
[08:25:48.382] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.382] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.382] Packages: <none>
[08:25:48.382] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.382] Resolved: TRUE
[08:25:48.382] Value: <not collected>
[08:25:48.382] Conditions captured: <none>
[08:25:48.382] Early signaling: FALSE
[08:25:48.382] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.382] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.390] Chunk #1 of 2 ... DONE
[08:25:48.390] Chunk #2 of 2 ...
[08:25:48.390]  - Finding globals in '...' for chunk #2 ...
[08:25:48.390] getGlobalsAndPackages() ...
[08:25:48.390] Searching for globals...
[08:25:48.391] 
[08:25:48.391] Searching for globals ... DONE
[08:25:48.391] - globals: [0] <none>
[08:25:48.391] getGlobalsAndPackages() ... DONE
[08:25:48.391]    + additional globals found: [n=0] 
[08:25:48.392]    + additional namespaces needed: [n=0] 
[08:25:48.392]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:48.392]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.392]  - seeds: <none>
[08:25:48.392]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.392] getGlobalsAndPackages() ...
[08:25:48.392] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.393] Resolving globals: FALSE
[08:25:48.393] The total size of the 5 globals is 265 bytes (265 bytes)
[08:25:48.394] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.394] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.395] 
[08:25:48.395] getGlobalsAndPackages() ... DONE
[08:25:48.399] run() for ‘Future’ ...
[08:25:48.399] - state: ‘created’
[08:25:48.400] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.404] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.404] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.404]   - Field: ‘label’
[08:25:48.405]   - Field: ‘local’
[08:25:48.405]   - Field: ‘owner’
[08:25:48.405]   - Field: ‘envir’
[08:25:48.405]   - Field: ‘workers’
[08:25:48.405]   - Field: ‘packages’
[08:25:48.406]   - Field: ‘gc’
[08:25:48.406]   - Field: ‘job’
[08:25:48.406]   - Field: ‘conditions’
[08:25:48.406]   - Field: ‘expr’
[08:25:48.407]   - Field: ‘uuid’
[08:25:48.407]   - Field: ‘seed’
[08:25:48.407]   - Field: ‘version’
[08:25:48.407]   - Field: ‘result’
[08:25:48.408]   - Field: ‘asynchronous’
[08:25:48.408]   - Field: ‘calls’
[08:25:48.408]   - Field: ‘globals’
[08:25:48.408]   - Field: ‘stdout’
[08:25:48.408]   - Field: ‘earlySignal’
[08:25:48.408]   - Field: ‘lazy’
[08:25:48.409]   - Field: ‘state’
[08:25:48.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.409] - Launch lazy future ...
[08:25:48.409] Packages needed by the future expression (n = 0): <none>
[08:25:48.410] Packages needed by future strategies (n = 0): <none>
[08:25:48.410] {
[08:25:48.410]     {
[08:25:48.410]         {
[08:25:48.410]             ...future.startTime <- base::Sys.time()
[08:25:48.410]             {
[08:25:48.410]                 {
[08:25:48.410]                   {
[08:25:48.410]                     {
[08:25:48.410]                       base::local({
[08:25:48.410]                         has_future <- base::requireNamespace("future", 
[08:25:48.410]                           quietly = TRUE)
[08:25:48.410]                         if (has_future) {
[08:25:48.410]                           ns <- base::getNamespace("future")
[08:25:48.410]                           version <- ns[[".package"]][["version"]]
[08:25:48.410]                           if (is.null(version)) 
[08:25:48.410]                             version <- utils::packageVersion("future")
[08:25:48.410]                         }
[08:25:48.410]                         else {
[08:25:48.410]                           version <- NULL
[08:25:48.410]                         }
[08:25:48.410]                         if (!has_future || version < "1.8.0") {
[08:25:48.410]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.410]                             "", base::R.version$version.string), 
[08:25:48.410]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.410]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.410]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.410]                               "release", "version")], collapse = " "), 
[08:25:48.410]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.410]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.410]                             info)
[08:25:48.410]                           info <- base::paste(info, collapse = "; ")
[08:25:48.410]                           if (!has_future) {
[08:25:48.410]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.410]                               info)
[08:25:48.410]                           }
[08:25:48.410]                           else {
[08:25:48.410]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.410]                               info, version)
[08:25:48.410]                           }
[08:25:48.410]                           base::stop(msg)
[08:25:48.410]                         }
[08:25:48.410]                       })
[08:25:48.410]                     }
[08:25:48.410]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.410]                     base::options(mc.cores = 1L)
[08:25:48.410]                   }
[08:25:48.410]                   ...future.strategy.old <- future::plan("list")
[08:25:48.410]                   options(future.plan = NULL)
[08:25:48.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.410]                 }
[08:25:48.410]                 ...future.workdir <- getwd()
[08:25:48.410]             }
[08:25:48.410]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.410]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.410]         }
[08:25:48.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.410]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.410]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.410]             base::names(...future.oldOptions))
[08:25:48.410]     }
[08:25:48.410]     if (FALSE) {
[08:25:48.410]     }
[08:25:48.410]     else {
[08:25:48.410]         if (TRUE) {
[08:25:48.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.410]                 open = "w")
[08:25:48.410]         }
[08:25:48.410]         else {
[08:25:48.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.410]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.410]         }
[08:25:48.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.410]             base::sink(type = "output", split = FALSE)
[08:25:48.410]             base::close(...future.stdout)
[08:25:48.410]         }, add = TRUE)
[08:25:48.410]     }
[08:25:48.410]     ...future.frame <- base::sys.nframe()
[08:25:48.410]     ...future.conditions <- base::list()
[08:25:48.410]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.410]     if (FALSE) {
[08:25:48.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.410]     }
[08:25:48.410]     ...future.result <- base::tryCatch({
[08:25:48.410]         base::withCallingHandlers({
[08:25:48.410]             ...future.value <- base::withVisible(base::local({
[08:25:48.410]                 withCallingHandlers({
[08:25:48.410]                   {
[08:25:48.410]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.410]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.410]                       ...future.globals.maxSize)) {
[08:25:48.410]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.410]                       on.exit(options(oopts), add = TRUE)
[08:25:48.410]                     }
[08:25:48.410]                     {
[08:25:48.410]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.410]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.410]                         USE.NAMES = FALSE)
[08:25:48.410]                       do.call(mapply, args = args)
[08:25:48.410]                     }
[08:25:48.410]                   }
[08:25:48.410]                 }, immediateCondition = function(cond) {
[08:25:48.410]                   save_rds <- function (object, pathname, ...) 
[08:25:48.410]                   {
[08:25:48.410]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.410]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.410]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.410]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.410]                         fi_tmp[["mtime"]])
[08:25:48.410]                     }
[08:25:48.410]                     tryCatch({
[08:25:48.410]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.410]                     }, error = function(ex) {
[08:25:48.410]                       msg <- conditionMessage(ex)
[08:25:48.410]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.410]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.410]                         fi_tmp[["mtime"]], msg)
[08:25:48.410]                       ex$message <- msg
[08:25:48.410]                       stop(ex)
[08:25:48.410]                     })
[08:25:48.410]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.410]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.410]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.410]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.410]                       fi <- file.info(pathname)
[08:25:48.410]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.410]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.410]                         fi[["size"]], fi[["mtime"]])
[08:25:48.410]                       stop(msg)
[08:25:48.410]                     }
[08:25:48.410]                     invisible(pathname)
[08:25:48.410]                   }
[08:25:48.410]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.410]                     rootPath = tempdir()) 
[08:25:48.410]                   {
[08:25:48.410]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.410]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.410]                       tmpdir = path, fileext = ".rds")
[08:25:48.410]                     save_rds(obj, file)
[08:25:48.410]                   }
[08:25:48.410]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.410]                   {
[08:25:48.410]                     inherits <- base::inherits
[08:25:48.410]                     invokeRestart <- base::invokeRestart
[08:25:48.410]                     is.null <- base::is.null
[08:25:48.410]                     muffled <- FALSE
[08:25:48.410]                     if (inherits(cond, "message")) {
[08:25:48.410]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.410]                       if (muffled) 
[08:25:48.410]                         invokeRestart("muffleMessage")
[08:25:48.410]                     }
[08:25:48.410]                     else if (inherits(cond, "warning")) {
[08:25:48.410]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.410]                       if (muffled) 
[08:25:48.410]                         invokeRestart("muffleWarning")
[08:25:48.410]                     }
[08:25:48.410]                     else if (inherits(cond, "condition")) {
[08:25:48.410]                       if (!is.null(pattern)) {
[08:25:48.410]                         computeRestarts <- base::computeRestarts
[08:25:48.410]                         grepl <- base::grepl
[08:25:48.410]                         restarts <- computeRestarts(cond)
[08:25:48.410]                         for (restart in restarts) {
[08:25:48.410]                           name <- restart$name
[08:25:48.410]                           if (is.null(name)) 
[08:25:48.410]                             next
[08:25:48.410]                           if (!grepl(pattern, name)) 
[08:25:48.410]                             next
[08:25:48.410]                           invokeRestart(restart)
[08:25:48.410]                           muffled <- TRUE
[08:25:48.410]                           break
[08:25:48.410]                         }
[08:25:48.410]                       }
[08:25:48.410]                     }
[08:25:48.410]                     invisible(muffled)
[08:25:48.410]                   }
[08:25:48.410]                   muffleCondition(cond)
[08:25:48.410]                 })
[08:25:48.410]             }))
[08:25:48.410]             future::FutureResult(value = ...future.value$value, 
[08:25:48.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.410]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.410]                     ...future.globalenv.names))
[08:25:48.410]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.410]         }, condition = base::local({
[08:25:48.410]             c <- base::c
[08:25:48.410]             inherits <- base::inherits
[08:25:48.410]             invokeRestart <- base::invokeRestart
[08:25:48.410]             length <- base::length
[08:25:48.410]             list <- base::list
[08:25:48.410]             seq.int <- base::seq.int
[08:25:48.410]             signalCondition <- base::signalCondition
[08:25:48.410]             sys.calls <- base::sys.calls
[08:25:48.410]             `[[` <- base::`[[`
[08:25:48.410]             `+` <- base::`+`
[08:25:48.410]             `<<-` <- base::`<<-`
[08:25:48.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.410]                   3L)]
[08:25:48.410]             }
[08:25:48.410]             function(cond) {
[08:25:48.410]                 is_error <- inherits(cond, "error")
[08:25:48.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.410]                   NULL)
[08:25:48.410]                 if (is_error) {
[08:25:48.410]                   sessionInformation <- function() {
[08:25:48.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.410]                       search = base::search(), system = base::Sys.info())
[08:25:48.410]                   }
[08:25:48.410]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.410]                     cond$call), session = sessionInformation(), 
[08:25:48.410]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.410]                   signalCondition(cond)
[08:25:48.410]                 }
[08:25:48.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.410]                 "immediateCondition"))) {
[08:25:48.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.410]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.410]                   if (TRUE && !signal) {
[08:25:48.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.410]                     {
[08:25:48.410]                       inherits <- base::inherits
[08:25:48.410]                       invokeRestart <- base::invokeRestart
[08:25:48.410]                       is.null <- base::is.null
[08:25:48.410]                       muffled <- FALSE
[08:25:48.410]                       if (inherits(cond, "message")) {
[08:25:48.410]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.410]                         if (muffled) 
[08:25:48.410]                           invokeRestart("muffleMessage")
[08:25:48.410]                       }
[08:25:48.410]                       else if (inherits(cond, "warning")) {
[08:25:48.410]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.410]                         if (muffled) 
[08:25:48.410]                           invokeRestart("muffleWarning")
[08:25:48.410]                       }
[08:25:48.410]                       else if (inherits(cond, "condition")) {
[08:25:48.410]                         if (!is.null(pattern)) {
[08:25:48.410]                           computeRestarts <- base::computeRestarts
[08:25:48.410]                           grepl <- base::grepl
[08:25:48.410]                           restarts <- computeRestarts(cond)
[08:25:48.410]                           for (restart in restarts) {
[08:25:48.410]                             name <- restart$name
[08:25:48.410]                             if (is.null(name)) 
[08:25:48.410]                               next
[08:25:48.410]                             if (!grepl(pattern, name)) 
[08:25:48.410]                               next
[08:25:48.410]                             invokeRestart(restart)
[08:25:48.410]                             muffled <- TRUE
[08:25:48.410]                             break
[08:25:48.410]                           }
[08:25:48.410]                         }
[08:25:48.410]                       }
[08:25:48.410]                       invisible(muffled)
[08:25:48.410]                     }
[08:25:48.410]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.410]                   }
[08:25:48.410]                 }
[08:25:48.410]                 else {
[08:25:48.410]                   if (TRUE) {
[08:25:48.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.410]                     {
[08:25:48.410]                       inherits <- base::inherits
[08:25:48.410]                       invokeRestart <- base::invokeRestart
[08:25:48.410]                       is.null <- base::is.null
[08:25:48.410]                       muffled <- FALSE
[08:25:48.410]                       if (inherits(cond, "message")) {
[08:25:48.410]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.410]                         if (muffled) 
[08:25:48.410]                           invokeRestart("muffleMessage")
[08:25:48.410]                       }
[08:25:48.410]                       else if (inherits(cond, "warning")) {
[08:25:48.410]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.410]                         if (muffled) 
[08:25:48.410]                           invokeRestart("muffleWarning")
[08:25:48.410]                       }
[08:25:48.410]                       else if (inherits(cond, "condition")) {
[08:25:48.410]                         if (!is.null(pattern)) {
[08:25:48.410]                           computeRestarts <- base::computeRestarts
[08:25:48.410]                           grepl <- base::grepl
[08:25:48.410]                           restarts <- computeRestarts(cond)
[08:25:48.410]                           for (restart in restarts) {
[08:25:48.410]                             name <- restart$name
[08:25:48.410]                             if (is.null(name)) 
[08:25:48.410]                               next
[08:25:48.410]                             if (!grepl(pattern, name)) 
[08:25:48.410]                               next
[08:25:48.410]                             invokeRestart(restart)
[08:25:48.410]                             muffled <- TRUE
[08:25:48.410]                             break
[08:25:48.410]                           }
[08:25:48.410]                         }
[08:25:48.410]                       }
[08:25:48.410]                       invisible(muffled)
[08:25:48.410]                     }
[08:25:48.410]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.410]                   }
[08:25:48.410]                 }
[08:25:48.410]             }
[08:25:48.410]         }))
[08:25:48.410]     }, error = function(ex) {
[08:25:48.410]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.410]                 ...future.rng), started = ...future.startTime, 
[08:25:48.410]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.410]             version = "1.8"), class = "FutureResult")
[08:25:48.410]     }, finally = {
[08:25:48.410]         if (!identical(...future.workdir, getwd())) 
[08:25:48.410]             setwd(...future.workdir)
[08:25:48.410]         {
[08:25:48.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.410]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.410]             }
[08:25:48.410]             base::options(...future.oldOptions)
[08:25:48.410]             if (.Platform$OS.type == "windows") {
[08:25:48.410]                 old_names <- names(...future.oldEnvVars)
[08:25:48.410]                 envs <- base::Sys.getenv()
[08:25:48.410]                 names <- names(envs)
[08:25:48.410]                 common <- intersect(names, old_names)
[08:25:48.410]                 added <- setdiff(names, old_names)
[08:25:48.410]                 removed <- setdiff(old_names, names)
[08:25:48.410]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.410]                   envs[common]]
[08:25:48.410]                 NAMES <- toupper(changed)
[08:25:48.410]                 args <- list()
[08:25:48.410]                 for (kk in seq_along(NAMES)) {
[08:25:48.410]                   name <- changed[[kk]]
[08:25:48.410]                   NAME <- NAMES[[kk]]
[08:25:48.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.410]                     next
[08:25:48.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.410]                 }
[08:25:48.410]                 NAMES <- toupper(added)
[08:25:48.410]                 for (kk in seq_along(NAMES)) {
[08:25:48.410]                   name <- added[[kk]]
[08:25:48.410]                   NAME <- NAMES[[kk]]
[08:25:48.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.410]                     next
[08:25:48.410]                   args[[name]] <- ""
[08:25:48.410]                 }
[08:25:48.410]                 NAMES <- toupper(removed)
[08:25:48.410]                 for (kk in seq_along(NAMES)) {
[08:25:48.410]                   name <- removed[[kk]]
[08:25:48.410]                   NAME <- NAMES[[kk]]
[08:25:48.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.410]                     next
[08:25:48.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.410]                 }
[08:25:48.410]                 if (length(args) > 0) 
[08:25:48.410]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.410]             }
[08:25:48.410]             else {
[08:25:48.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.410]             }
[08:25:48.410]             {
[08:25:48.410]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.410]                   0L) {
[08:25:48.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.410]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.410]                   base::options(opts)
[08:25:48.410]                 }
[08:25:48.410]                 {
[08:25:48.410]                   {
[08:25:48.410]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.410]                     NULL
[08:25:48.410]                   }
[08:25:48.410]                   options(future.plan = NULL)
[08:25:48.410]                   if (is.na(NA_character_)) 
[08:25:48.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.410]                     .init = FALSE)
[08:25:48.410]                 }
[08:25:48.410]             }
[08:25:48.410]         }
[08:25:48.410]     })
[08:25:48.410]     if (TRUE) {
[08:25:48.410]         base::sink(type = "output", split = FALSE)
[08:25:48.410]         if (TRUE) {
[08:25:48.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.410]         }
[08:25:48.410]         else {
[08:25:48.410]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.410]         }
[08:25:48.410]         base::close(...future.stdout)
[08:25:48.410]         ...future.stdout <- NULL
[08:25:48.410]     }
[08:25:48.410]     ...future.result$conditions <- ...future.conditions
[08:25:48.410]     ...future.result$finished <- base::Sys.time()
[08:25:48.410]     ...future.result
[08:25:48.410] }
[08:25:48.413] assign_globals() ...
[08:25:48.413] List of 5
[08:25:48.413]  $ ...future.FUN            :function (x, ...)  
[08:25:48.413]  $ MoreArgs                 : NULL
[08:25:48.413]  $ ...future.elements_ii    :List of 2
[08:25:48.413]   ..$ times:List of 2
[08:25:48.413]   .. ..$ : int 3
[08:25:48.413]   .. ..$ : int 4
[08:25:48.413]   ..$ x    :List of 2
[08:25:48.413]   .. ..$ : int 2
[08:25:48.413]   .. ..$ : int 1
[08:25:48.413]  $ ...future.seeds_ii       : NULL
[08:25:48.413]  $ ...future.globals.maxSize: NULL
[08:25:48.413]  - attr(*, "where")=List of 5
[08:25:48.413]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.413]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.413]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.413]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.413]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.413]  - attr(*, "resolved")= logi FALSE
[08:25:48.413]  - attr(*, "total_size")= num 265
[08:25:48.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.413]  - attr(*, "already-done")= logi TRUE
[08:25:48.421] - copied ‘...future.FUN’ to environment
[08:25:48.421] - copied ‘MoreArgs’ to environment
[08:25:48.421] - copied ‘...future.elements_ii’ to environment
[08:25:48.421] - copied ‘...future.seeds_ii’ to environment
[08:25:48.421] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.421] assign_globals() ... done
[08:25:48.422] requestCore(): workers = 2
[08:25:48.424] MulticoreFuture started
[08:25:48.424] - Launch lazy future ... done
[08:25:48.425] run() for ‘MulticoreFuture’ ... done
[08:25:48.425] Created future:
[08:25:48.425] plan(): Setting new future strategy stack:
[08:25:48.425] List of future strategies:
[08:25:48.425] 1. sequential:
[08:25:48.425]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.425]    - tweaked: FALSE
[08:25:48.425]    - call: NULL
[08:25:48.426] plan(): nbrOfWorkers() = 1
[08:25:48.428] plan(): Setting new future strategy stack:
[08:25:48.429] List of future strategies:
[08:25:48.429] 1. multicore:
[08:25:48.429]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.429]    - tweaked: FALSE
[08:25:48.429]    - call: plan(strategy)
[08:25:48.432] plan(): nbrOfWorkers() = 2
[08:25:48.425] MulticoreFuture:
[08:25:48.425] Label: ‘future_mapply-2’
[08:25:48.425] Expression:
[08:25:48.425] {
[08:25:48.425]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.425]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.425]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.425]         on.exit(options(oopts), add = TRUE)
[08:25:48.425]     }
[08:25:48.425]     {
[08:25:48.425]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.425]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.425]         do.call(mapply, args = args)
[08:25:48.425]     }
[08:25:48.425] }
[08:25:48.425] Lazy evaluation: FALSE
[08:25:48.425] Asynchronous evaluation: TRUE
[08:25:48.425] Local evaluation: TRUE
[08:25:48.425] Environment: R_GlobalEnv
[08:25:48.425] Capture standard output: TRUE
[08:25:48.425] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.425] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.425] Packages: <none>
[08:25:48.425] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.425] Resolved: TRUE
[08:25:48.425] Value: <not collected>
[08:25:48.425] Conditions captured: <none>
[08:25:48.425] Early signaling: FALSE
[08:25:48.425] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.425] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.433] Chunk #2 of 2 ... DONE
[08:25:48.433] Launching 2 futures (chunks) ... DONE
[08:25:48.433] Resolving 2 futures (chunks) ...
[08:25:48.434] resolve() on list ...
[08:25:48.434]  recursive: 0
[08:25:48.434]  length: 2
[08:25:48.434] 
[08:25:48.434] Future #1
[08:25:48.434] result() for MulticoreFuture ...
[08:25:48.435] result() for MulticoreFuture ...
[08:25:48.435] result() for MulticoreFuture ... done
[08:25:48.436] result() for MulticoreFuture ... done
[08:25:48.436] result() for MulticoreFuture ...
[08:25:48.436] result() for MulticoreFuture ... done
[08:25:48.436] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:48.436] - nx: 2
[08:25:48.436] - relay: TRUE
[08:25:48.437] - stdout: TRUE
[08:25:48.437] - signal: TRUE
[08:25:48.437] - resignal: FALSE
[08:25:48.437] - force: TRUE
[08:25:48.437] - relayed: [n=2] FALSE, FALSE
[08:25:48.437] - queued futures: [n=2] FALSE, FALSE
[08:25:48.437]  - until=1
[08:25:48.438]  - relaying element #1
[08:25:48.438] result() for MulticoreFuture ...
[08:25:48.438] result() for MulticoreFuture ... done
[08:25:48.438] result() for MulticoreFuture ...
[08:25:48.438] result() for MulticoreFuture ... done
[08:25:48.438] result() for MulticoreFuture ...
[08:25:48.439] result() for MulticoreFuture ... done
[08:25:48.439] result() for MulticoreFuture ...
[08:25:48.439] result() for MulticoreFuture ... done
[08:25:48.439] - relayed: [n=2] TRUE, FALSE
[08:25:48.439] - queued futures: [n=2] TRUE, FALSE
[08:25:48.439] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:48.439]  length: 1 (resolved future 1)
[08:25:48.440] Future #2
[08:25:48.440] result() for MulticoreFuture ...
[08:25:48.441] result() for MulticoreFuture ...
[08:25:48.441] result() for MulticoreFuture ... done
[08:25:48.441] result() for MulticoreFuture ... done
[08:25:48.441] result() for MulticoreFuture ...
[08:25:48.441] result() for MulticoreFuture ... done
[08:25:48.441] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:48.441] - nx: 2
[08:25:48.442] - relay: TRUE
[08:25:48.442] - stdout: TRUE
[08:25:48.442] - signal: TRUE
[08:25:48.442] - resignal: FALSE
[08:25:48.442] - force: TRUE
[08:25:48.442] - relayed: [n=2] TRUE, FALSE
[08:25:48.442] - queued futures: [n=2] TRUE, FALSE
[08:25:48.443]  - until=2
[08:25:48.443]  - relaying element #2
[08:25:48.443] result() for MulticoreFuture ...
[08:25:48.443] result() for MulticoreFuture ... done
[08:25:48.443] result() for MulticoreFuture ...
[08:25:48.443] result() for MulticoreFuture ... done
[08:25:48.443] result() for MulticoreFuture ...
[08:25:48.446] result() for MulticoreFuture ... done
[08:25:48.446] result() for MulticoreFuture ...
[08:25:48.447] result() for MulticoreFuture ... done
[08:25:48.447] - relayed: [n=2] TRUE, TRUE
[08:25:48.447] - queued futures: [n=2] TRUE, TRUE
[08:25:48.447] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:48.447]  length: 0 (resolved future 2)
[08:25:48.448] Relaying remaining futures
[08:25:48.448] signalConditionsASAP(NULL, pos=0) ...
[08:25:48.448] - nx: 2
[08:25:48.448] - relay: TRUE
[08:25:48.448] - stdout: TRUE
[08:25:48.448] - signal: TRUE
[08:25:48.449] - resignal: FALSE
[08:25:48.449] - force: TRUE
[08:25:48.449] - relayed: [n=2] TRUE, TRUE
[08:25:48.449] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:48.449] - relayed: [n=2] TRUE, TRUE
[08:25:48.449] - queued futures: [n=2] TRUE, TRUE
[08:25:48.450] signalConditionsASAP(NULL, pos=0) ... done
[08:25:48.450] resolve() on list ... DONE
[08:25:48.450] result() for MulticoreFuture ...
[08:25:48.450] result() for MulticoreFuture ... done
[08:25:48.450] result() for MulticoreFuture ...
[08:25:48.450] result() for MulticoreFuture ... done
[08:25:48.451] result() for MulticoreFuture ...
[08:25:48.451] result() for MulticoreFuture ... done
[08:25:48.451] result() for MulticoreFuture ...
[08:25:48.451] result() for MulticoreFuture ... done
[08:25:48.451]  - Number of value chunks collected: 2
[08:25:48.452] Resolving 2 futures (chunks) ... DONE
[08:25:48.452] Reducing values from 2 chunks ...
[08:25:48.452]  - Number of values collected after concatenation: 4
[08:25:48.452]  - Number of values expected: 4
[08:25:48.452] Reducing values from 2 chunks ... DONE
[08:25:48.452] future_mapply() ... DONE
[08:25:48.452] future_mapply() ...
[08:25:48.455] Number of chunks: 2
[08:25:48.455] getGlobalsAndPackagesXApply() ...
[08:25:48.455]  - future.globals: TRUE
[08:25:48.455] getGlobalsAndPackages() ...
[08:25:48.456] Searching for globals...
[08:25:48.456] - globals found: [1] ‘FUN’
[08:25:48.457] Searching for globals ... DONE
[08:25:48.457] Resolving globals: FALSE
[08:25:48.457] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:48.457] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:48.458] - globals: [1] ‘FUN’
[08:25:48.458] 
[08:25:48.458] getGlobalsAndPackages() ... DONE
[08:25:48.458]  - globals found/used: [n=1] ‘FUN’
[08:25:48.458]  - needed namespaces: [n=0] 
[08:25:48.458] Finding globals ... DONE
[08:25:48.458] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:48.458] List of 2
[08:25:48.458]  $ ...future.FUN:function (x, ...)  
[08:25:48.458]  $ MoreArgs     :List of 1
[08:25:48.458]   ..$ x: num 42
[08:25:48.458]  - attr(*, "where")=List of 2
[08:25:48.458]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:48.458]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:48.458]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.458]  - attr(*, "resolved")= logi FALSE
[08:25:48.458]  - attr(*, "total_size")= num NA
[08:25:48.462] Packages to be attached in all futures: [n=0] 
[08:25:48.462] getGlobalsAndPackagesXApply() ... DONE
[08:25:48.462] Number of futures (= number of chunks): 2
[08:25:48.462] Launching 2 futures (chunks) ...
[08:25:48.462] Chunk #1 of 2 ...
[08:25:48.463]  - Finding globals in '...' for chunk #1 ...
[08:25:48.463] getGlobalsAndPackages() ...
[08:25:48.463] Searching for globals...
[08:25:48.463] 
[08:25:48.463] Searching for globals ... DONE
[08:25:48.463] - globals: [0] <none>
[08:25:48.463] getGlobalsAndPackages() ... DONE
[08:25:48.464]    + additional globals found: [n=0] 
[08:25:48.464]    + additional namespaces needed: [n=0] 
[08:25:48.464]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:48.464]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.464]  - seeds: <none>
[08:25:48.464]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.464] getGlobalsAndPackages() ...
[08:25:48.464] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.464] Resolving globals: FALSE
[08:25:48.465] The total size of the 5 globals is 286 bytes (286 bytes)
[08:25:48.465] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[08:25:48.465] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.466] 
[08:25:48.466] getGlobalsAndPackages() ... DONE
[08:25:48.466] run() for ‘Future’ ...
[08:25:48.466] - state: ‘created’
[08:25:48.466] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.468] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.468] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.468]   - Field: ‘label’
[08:25:48.468]   - Field: ‘local’
[08:25:48.468]   - Field: ‘owner’
[08:25:48.469]   - Field: ‘envir’
[08:25:48.469]   - Field: ‘workers’
[08:25:48.469]   - Field: ‘packages’
[08:25:48.469]   - Field: ‘gc’
[08:25:48.469]   - Field: ‘job’
[08:25:48.469]   - Field: ‘conditions’
[08:25:48.469]   - Field: ‘expr’
[08:25:48.469]   - Field: ‘uuid’
[08:25:48.469]   - Field: ‘seed’
[08:25:48.469]   - Field: ‘version’
[08:25:48.469]   - Field: ‘result’
[08:25:48.470]   - Field: ‘asynchronous’
[08:25:48.470]   - Field: ‘calls’
[08:25:48.470]   - Field: ‘globals’
[08:25:48.470]   - Field: ‘stdout’
[08:25:48.470]   - Field: ‘earlySignal’
[08:25:48.470]   - Field: ‘lazy’
[08:25:48.470]   - Field: ‘state’
[08:25:48.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.470] - Launch lazy future ...
[08:25:48.471] Packages needed by the future expression (n = 0): <none>
[08:25:48.471] Packages needed by future strategies (n = 0): <none>
[08:25:48.471] {
[08:25:48.471]     {
[08:25:48.471]         {
[08:25:48.471]             ...future.startTime <- base::Sys.time()
[08:25:48.471]             {
[08:25:48.471]                 {
[08:25:48.471]                   {
[08:25:48.471]                     {
[08:25:48.471]                       base::local({
[08:25:48.471]                         has_future <- base::requireNamespace("future", 
[08:25:48.471]                           quietly = TRUE)
[08:25:48.471]                         if (has_future) {
[08:25:48.471]                           ns <- base::getNamespace("future")
[08:25:48.471]                           version <- ns[[".package"]][["version"]]
[08:25:48.471]                           if (is.null(version)) 
[08:25:48.471]                             version <- utils::packageVersion("future")
[08:25:48.471]                         }
[08:25:48.471]                         else {
[08:25:48.471]                           version <- NULL
[08:25:48.471]                         }
[08:25:48.471]                         if (!has_future || version < "1.8.0") {
[08:25:48.471]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.471]                             "", base::R.version$version.string), 
[08:25:48.471]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.471]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.471]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.471]                               "release", "version")], collapse = " "), 
[08:25:48.471]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.471]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.471]                             info)
[08:25:48.471]                           info <- base::paste(info, collapse = "; ")
[08:25:48.471]                           if (!has_future) {
[08:25:48.471]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.471]                               info)
[08:25:48.471]                           }
[08:25:48.471]                           else {
[08:25:48.471]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.471]                               info, version)
[08:25:48.471]                           }
[08:25:48.471]                           base::stop(msg)
[08:25:48.471]                         }
[08:25:48.471]                       })
[08:25:48.471]                     }
[08:25:48.471]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.471]                     base::options(mc.cores = 1L)
[08:25:48.471]                   }
[08:25:48.471]                   ...future.strategy.old <- future::plan("list")
[08:25:48.471]                   options(future.plan = NULL)
[08:25:48.471]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.471]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.471]                 }
[08:25:48.471]                 ...future.workdir <- getwd()
[08:25:48.471]             }
[08:25:48.471]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.471]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.471]         }
[08:25:48.471]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.471]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.471]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.471]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.471]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.471]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.471]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.471]             base::names(...future.oldOptions))
[08:25:48.471]     }
[08:25:48.471]     if (FALSE) {
[08:25:48.471]     }
[08:25:48.471]     else {
[08:25:48.471]         if (TRUE) {
[08:25:48.471]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.471]                 open = "w")
[08:25:48.471]         }
[08:25:48.471]         else {
[08:25:48.471]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.471]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.471]         }
[08:25:48.471]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.471]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.471]             base::sink(type = "output", split = FALSE)
[08:25:48.471]             base::close(...future.stdout)
[08:25:48.471]         }, add = TRUE)
[08:25:48.471]     }
[08:25:48.471]     ...future.frame <- base::sys.nframe()
[08:25:48.471]     ...future.conditions <- base::list()
[08:25:48.471]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.471]     if (FALSE) {
[08:25:48.471]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.471]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.471]     }
[08:25:48.471]     ...future.result <- base::tryCatch({
[08:25:48.471]         base::withCallingHandlers({
[08:25:48.471]             ...future.value <- base::withVisible(base::local({
[08:25:48.471]                 withCallingHandlers({
[08:25:48.471]                   {
[08:25:48.471]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.471]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.471]                       ...future.globals.maxSize)) {
[08:25:48.471]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.471]                       on.exit(options(oopts), add = TRUE)
[08:25:48.471]                     }
[08:25:48.471]                     {
[08:25:48.471]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.471]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.471]                         USE.NAMES = FALSE)
[08:25:48.471]                       do.call(mapply, args = args)
[08:25:48.471]                     }
[08:25:48.471]                   }
[08:25:48.471]                 }, immediateCondition = function(cond) {
[08:25:48.471]                   save_rds <- function (object, pathname, ...) 
[08:25:48.471]                   {
[08:25:48.471]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.471]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.471]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.471]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.471]                         fi_tmp[["mtime"]])
[08:25:48.471]                     }
[08:25:48.471]                     tryCatch({
[08:25:48.471]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.471]                     }, error = function(ex) {
[08:25:48.471]                       msg <- conditionMessage(ex)
[08:25:48.471]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.471]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.471]                         fi_tmp[["mtime"]], msg)
[08:25:48.471]                       ex$message <- msg
[08:25:48.471]                       stop(ex)
[08:25:48.471]                     })
[08:25:48.471]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.471]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.471]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.471]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.471]                       fi <- file.info(pathname)
[08:25:48.471]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.471]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.471]                         fi[["size"]], fi[["mtime"]])
[08:25:48.471]                       stop(msg)
[08:25:48.471]                     }
[08:25:48.471]                     invisible(pathname)
[08:25:48.471]                   }
[08:25:48.471]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.471]                     rootPath = tempdir()) 
[08:25:48.471]                   {
[08:25:48.471]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.471]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.471]                       tmpdir = path, fileext = ".rds")
[08:25:48.471]                     save_rds(obj, file)
[08:25:48.471]                   }
[08:25:48.471]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.471]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.471]                   {
[08:25:48.471]                     inherits <- base::inherits
[08:25:48.471]                     invokeRestart <- base::invokeRestart
[08:25:48.471]                     is.null <- base::is.null
[08:25:48.471]                     muffled <- FALSE
[08:25:48.471]                     if (inherits(cond, "message")) {
[08:25:48.471]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.471]                       if (muffled) 
[08:25:48.471]                         invokeRestart("muffleMessage")
[08:25:48.471]                     }
[08:25:48.471]                     else if (inherits(cond, "warning")) {
[08:25:48.471]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.471]                       if (muffled) 
[08:25:48.471]                         invokeRestart("muffleWarning")
[08:25:48.471]                     }
[08:25:48.471]                     else if (inherits(cond, "condition")) {
[08:25:48.471]                       if (!is.null(pattern)) {
[08:25:48.471]                         computeRestarts <- base::computeRestarts
[08:25:48.471]                         grepl <- base::grepl
[08:25:48.471]                         restarts <- computeRestarts(cond)
[08:25:48.471]                         for (restart in restarts) {
[08:25:48.471]                           name <- restart$name
[08:25:48.471]                           if (is.null(name)) 
[08:25:48.471]                             next
[08:25:48.471]                           if (!grepl(pattern, name)) 
[08:25:48.471]                             next
[08:25:48.471]                           invokeRestart(restart)
[08:25:48.471]                           muffled <- TRUE
[08:25:48.471]                           break
[08:25:48.471]                         }
[08:25:48.471]                       }
[08:25:48.471]                     }
[08:25:48.471]                     invisible(muffled)
[08:25:48.471]                   }
[08:25:48.471]                   muffleCondition(cond)
[08:25:48.471]                 })
[08:25:48.471]             }))
[08:25:48.471]             future::FutureResult(value = ...future.value$value, 
[08:25:48.471]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.471]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.471]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.471]                     ...future.globalenv.names))
[08:25:48.471]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.471]         }, condition = base::local({
[08:25:48.471]             c <- base::c
[08:25:48.471]             inherits <- base::inherits
[08:25:48.471]             invokeRestart <- base::invokeRestart
[08:25:48.471]             length <- base::length
[08:25:48.471]             list <- base::list
[08:25:48.471]             seq.int <- base::seq.int
[08:25:48.471]             signalCondition <- base::signalCondition
[08:25:48.471]             sys.calls <- base::sys.calls
[08:25:48.471]             `[[` <- base::`[[`
[08:25:48.471]             `+` <- base::`+`
[08:25:48.471]             `<<-` <- base::`<<-`
[08:25:48.471]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.471]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.471]                   3L)]
[08:25:48.471]             }
[08:25:48.471]             function(cond) {
[08:25:48.471]                 is_error <- inherits(cond, "error")
[08:25:48.471]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.471]                   NULL)
[08:25:48.471]                 if (is_error) {
[08:25:48.471]                   sessionInformation <- function() {
[08:25:48.471]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.471]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.471]                       search = base::search(), system = base::Sys.info())
[08:25:48.471]                   }
[08:25:48.471]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.471]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.471]                     cond$call), session = sessionInformation(), 
[08:25:48.471]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.471]                   signalCondition(cond)
[08:25:48.471]                 }
[08:25:48.471]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.471]                 "immediateCondition"))) {
[08:25:48.471]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.471]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.471]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.471]                   if (TRUE && !signal) {
[08:25:48.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.471]                     {
[08:25:48.471]                       inherits <- base::inherits
[08:25:48.471]                       invokeRestart <- base::invokeRestart
[08:25:48.471]                       is.null <- base::is.null
[08:25:48.471]                       muffled <- FALSE
[08:25:48.471]                       if (inherits(cond, "message")) {
[08:25:48.471]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.471]                         if (muffled) 
[08:25:48.471]                           invokeRestart("muffleMessage")
[08:25:48.471]                       }
[08:25:48.471]                       else if (inherits(cond, "warning")) {
[08:25:48.471]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.471]                         if (muffled) 
[08:25:48.471]                           invokeRestart("muffleWarning")
[08:25:48.471]                       }
[08:25:48.471]                       else if (inherits(cond, "condition")) {
[08:25:48.471]                         if (!is.null(pattern)) {
[08:25:48.471]                           computeRestarts <- base::computeRestarts
[08:25:48.471]                           grepl <- base::grepl
[08:25:48.471]                           restarts <- computeRestarts(cond)
[08:25:48.471]                           for (restart in restarts) {
[08:25:48.471]                             name <- restart$name
[08:25:48.471]                             if (is.null(name)) 
[08:25:48.471]                               next
[08:25:48.471]                             if (!grepl(pattern, name)) 
[08:25:48.471]                               next
[08:25:48.471]                             invokeRestart(restart)
[08:25:48.471]                             muffled <- TRUE
[08:25:48.471]                             break
[08:25:48.471]                           }
[08:25:48.471]                         }
[08:25:48.471]                       }
[08:25:48.471]                       invisible(muffled)
[08:25:48.471]                     }
[08:25:48.471]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.471]                   }
[08:25:48.471]                 }
[08:25:48.471]                 else {
[08:25:48.471]                   if (TRUE) {
[08:25:48.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.471]                     {
[08:25:48.471]                       inherits <- base::inherits
[08:25:48.471]                       invokeRestart <- base::invokeRestart
[08:25:48.471]                       is.null <- base::is.null
[08:25:48.471]                       muffled <- FALSE
[08:25:48.471]                       if (inherits(cond, "message")) {
[08:25:48.471]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.471]                         if (muffled) 
[08:25:48.471]                           invokeRestart("muffleMessage")
[08:25:48.471]                       }
[08:25:48.471]                       else if (inherits(cond, "warning")) {
[08:25:48.471]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.471]                         if (muffled) 
[08:25:48.471]                           invokeRestart("muffleWarning")
[08:25:48.471]                       }
[08:25:48.471]                       else if (inherits(cond, "condition")) {
[08:25:48.471]                         if (!is.null(pattern)) {
[08:25:48.471]                           computeRestarts <- base::computeRestarts
[08:25:48.471]                           grepl <- base::grepl
[08:25:48.471]                           restarts <- computeRestarts(cond)
[08:25:48.471]                           for (restart in restarts) {
[08:25:48.471]                             name <- restart$name
[08:25:48.471]                             if (is.null(name)) 
[08:25:48.471]                               next
[08:25:48.471]                             if (!grepl(pattern, name)) 
[08:25:48.471]                               next
[08:25:48.471]                             invokeRestart(restart)
[08:25:48.471]                             muffled <- TRUE
[08:25:48.471]                             break
[08:25:48.471]                           }
[08:25:48.471]                         }
[08:25:48.471]                       }
[08:25:48.471]                       invisible(muffled)
[08:25:48.471]                     }
[08:25:48.471]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.471]                   }
[08:25:48.471]                 }
[08:25:48.471]             }
[08:25:48.471]         }))
[08:25:48.471]     }, error = function(ex) {
[08:25:48.471]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.471]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.471]                 ...future.rng), started = ...future.startTime, 
[08:25:48.471]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.471]             version = "1.8"), class = "FutureResult")
[08:25:48.471]     }, finally = {
[08:25:48.471]         if (!identical(...future.workdir, getwd())) 
[08:25:48.471]             setwd(...future.workdir)
[08:25:48.471]         {
[08:25:48.471]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.471]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.471]             }
[08:25:48.471]             base::options(...future.oldOptions)
[08:25:48.471]             if (.Platform$OS.type == "windows") {
[08:25:48.471]                 old_names <- names(...future.oldEnvVars)
[08:25:48.471]                 envs <- base::Sys.getenv()
[08:25:48.471]                 names <- names(envs)
[08:25:48.471]                 common <- intersect(names, old_names)
[08:25:48.471]                 added <- setdiff(names, old_names)
[08:25:48.471]                 removed <- setdiff(old_names, names)
[08:25:48.471]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.471]                   envs[common]]
[08:25:48.471]                 NAMES <- toupper(changed)
[08:25:48.471]                 args <- list()
[08:25:48.471]                 for (kk in seq_along(NAMES)) {
[08:25:48.471]                   name <- changed[[kk]]
[08:25:48.471]                   NAME <- NAMES[[kk]]
[08:25:48.471]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.471]                     next
[08:25:48.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.471]                 }
[08:25:48.471]                 NAMES <- toupper(added)
[08:25:48.471]                 for (kk in seq_along(NAMES)) {
[08:25:48.471]                   name <- added[[kk]]
[08:25:48.471]                   NAME <- NAMES[[kk]]
[08:25:48.471]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.471]                     next
[08:25:48.471]                   args[[name]] <- ""
[08:25:48.471]                 }
[08:25:48.471]                 NAMES <- toupper(removed)
[08:25:48.471]                 for (kk in seq_along(NAMES)) {
[08:25:48.471]                   name <- removed[[kk]]
[08:25:48.471]                   NAME <- NAMES[[kk]]
[08:25:48.471]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.471]                     next
[08:25:48.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.471]                 }
[08:25:48.471]                 if (length(args) > 0) 
[08:25:48.471]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.471]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.471]             }
[08:25:48.471]             else {
[08:25:48.471]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.471]             }
[08:25:48.471]             {
[08:25:48.471]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.471]                   0L) {
[08:25:48.471]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.471]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.471]                   base::options(opts)
[08:25:48.471]                 }
[08:25:48.471]                 {
[08:25:48.471]                   {
[08:25:48.471]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.471]                     NULL
[08:25:48.471]                   }
[08:25:48.471]                   options(future.plan = NULL)
[08:25:48.471]                   if (is.na(NA_character_)) 
[08:25:48.471]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.471]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.471]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.471]                     .init = FALSE)
[08:25:48.471]                 }
[08:25:48.471]             }
[08:25:48.471]         }
[08:25:48.471]     })
[08:25:48.471]     if (TRUE) {
[08:25:48.471]         base::sink(type = "output", split = FALSE)
[08:25:48.471]         if (TRUE) {
[08:25:48.471]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.471]         }
[08:25:48.471]         else {
[08:25:48.471]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.471]         }
[08:25:48.471]         base::close(...future.stdout)
[08:25:48.471]         ...future.stdout <- NULL
[08:25:48.471]     }
[08:25:48.471]     ...future.result$conditions <- ...future.conditions
[08:25:48.471]     ...future.result$finished <- base::Sys.time()
[08:25:48.471]     ...future.result
[08:25:48.471] }
[08:25:48.474] assign_globals() ...
[08:25:48.474] List of 5
[08:25:48.474]  $ ...future.FUN            :function (x, ...)  
[08:25:48.474]  $ MoreArgs                 :List of 1
[08:25:48.474]   ..$ x: num 42
[08:25:48.474]  $ ...future.elements_ii    :List of 1
[08:25:48.474]   ..$ times:List of 2
[08:25:48.474]   .. ..$ : int 1
[08:25:48.474]   .. ..$ : int 2
[08:25:48.474]  $ ...future.seeds_ii       : NULL
[08:25:48.474]  $ ...future.globals.maxSize: NULL
[08:25:48.474]  - attr(*, "where")=List of 5
[08:25:48.474]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.474]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.474]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.474]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.474]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.474]  - attr(*, "resolved")= logi FALSE
[08:25:48.474]  - attr(*, "total_size")= num 286
[08:25:48.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.474]  - attr(*, "already-done")= logi TRUE
[08:25:48.482] - copied ‘...future.FUN’ to environment
[08:25:48.483] - copied ‘MoreArgs’ to environment
[08:25:48.483] - copied ‘...future.elements_ii’ to environment
[08:25:48.483] - copied ‘...future.seeds_ii’ to environment
[08:25:48.483] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.483] assign_globals() ... done
[08:25:48.483] requestCore(): workers = 2
[08:25:48.486] MulticoreFuture started
[08:25:48.486] - Launch lazy future ... done
[08:25:48.486] run() for ‘MulticoreFuture’ ... done
[08:25:48.487] plan(): Setting new future strategy stack:
[08:25:48.487] Created future:
[08:25:48.487] List of future strategies:
[08:25:48.487] 1. sequential:
[08:25:48.487]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.487]    - tweaked: FALSE
[08:25:48.487]    - call: NULL
[08:25:48.488] plan(): nbrOfWorkers() = 1
[08:25:48.491] plan(): Setting new future strategy stack:
[08:25:48.491] List of future strategies:
[08:25:48.491] 1. multicore:
[08:25:48.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.491]    - tweaked: FALSE
[08:25:48.491]    - call: plan(strategy)
[08:25:48.494] plan(): nbrOfWorkers() = 2
[08:25:48.487] MulticoreFuture:
[08:25:48.487] Label: ‘future_mapply-1’
[08:25:48.487] Expression:
[08:25:48.487] {
[08:25:48.487]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.487]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.487]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.487]         on.exit(options(oopts), add = TRUE)
[08:25:48.487]     }
[08:25:48.487]     {
[08:25:48.487]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.487]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.487]         do.call(mapply, args = args)
[08:25:48.487]     }
[08:25:48.487] }
[08:25:48.487] Lazy evaluation: FALSE
[08:25:48.487] Asynchronous evaluation: TRUE
[08:25:48.487] Local evaluation: TRUE
[08:25:48.487] Environment: R_GlobalEnv
[08:25:48.487] Capture standard output: TRUE
[08:25:48.487] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.487] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.487] Packages: <none>
[08:25:48.487] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.487] Resolved: TRUE
[08:25:48.487] Value: <not collected>
[08:25:48.487] Conditions captured: <none>
[08:25:48.487] Early signaling: FALSE
[08:25:48.487] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.487] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.495] Chunk #1 of 2 ... DONE
[08:25:48.495] Chunk #2 of 2 ...
[08:25:48.496]  - Finding globals in '...' for chunk #2 ...
[08:25:48.496] getGlobalsAndPackages() ...
[08:25:48.496] Searching for globals...
[08:25:48.497] 
[08:25:48.497] Searching for globals ... DONE
[08:25:48.497] - globals: [0] <none>
[08:25:48.497] getGlobalsAndPackages() ... DONE
[08:25:48.497]    + additional globals found: [n=0] 
[08:25:48.497]    + additional namespaces needed: [n=0] 
[08:25:48.497]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:48.497]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.498]  - seeds: <none>
[08:25:48.498]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.498] getGlobalsAndPackages() ...
[08:25:48.498] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.498] Resolving globals: FALSE
[08:25:48.499] The total size of the 5 globals is 286 bytes (286 bytes)
[08:25:48.500] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[08:25:48.500] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.500] 
[08:25:48.500] getGlobalsAndPackages() ... DONE
[08:25:48.501] run() for ‘Future’ ...
[08:25:48.501] - state: ‘created’
[08:25:48.501] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.503] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.504]   - Field: ‘label’
[08:25:48.504]   - Field: ‘local’
[08:25:48.504]   - Field: ‘owner’
[08:25:48.504]   - Field: ‘envir’
[08:25:48.504]   - Field: ‘workers’
[08:25:48.505]   - Field: ‘packages’
[08:25:48.505]   - Field: ‘gc’
[08:25:48.505]   - Field: ‘job’
[08:25:48.505]   - Field: ‘conditions’
[08:25:48.505]   - Field: ‘expr’
[08:25:48.505]   - Field: ‘uuid’
[08:25:48.505]   - Field: ‘seed’
[08:25:48.506]   - Field: ‘version’
[08:25:48.506]   - Field: ‘result’
[08:25:48.506]   - Field: ‘asynchronous’
[08:25:48.506]   - Field: ‘calls’
[08:25:48.506]   - Field: ‘globals’
[08:25:48.506]   - Field: ‘stdout’
[08:25:48.506]   - Field: ‘earlySignal’
[08:25:48.507]   - Field: ‘lazy’
[08:25:48.507]   - Field: ‘state’
[08:25:48.507] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.507] - Launch lazy future ...
[08:25:48.507] Packages needed by the future expression (n = 0): <none>
[08:25:48.508] Packages needed by future strategies (n = 0): <none>
[08:25:48.508] {
[08:25:48.508]     {
[08:25:48.508]         {
[08:25:48.508]             ...future.startTime <- base::Sys.time()
[08:25:48.508]             {
[08:25:48.508]                 {
[08:25:48.508]                   {
[08:25:48.508]                     {
[08:25:48.508]                       base::local({
[08:25:48.508]                         has_future <- base::requireNamespace("future", 
[08:25:48.508]                           quietly = TRUE)
[08:25:48.508]                         if (has_future) {
[08:25:48.508]                           ns <- base::getNamespace("future")
[08:25:48.508]                           version <- ns[[".package"]][["version"]]
[08:25:48.508]                           if (is.null(version)) 
[08:25:48.508]                             version <- utils::packageVersion("future")
[08:25:48.508]                         }
[08:25:48.508]                         else {
[08:25:48.508]                           version <- NULL
[08:25:48.508]                         }
[08:25:48.508]                         if (!has_future || version < "1.8.0") {
[08:25:48.508]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.508]                             "", base::R.version$version.string), 
[08:25:48.508]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.508]                               "release", "version")], collapse = " "), 
[08:25:48.508]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.508]                             info)
[08:25:48.508]                           info <- base::paste(info, collapse = "; ")
[08:25:48.508]                           if (!has_future) {
[08:25:48.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.508]                               info)
[08:25:48.508]                           }
[08:25:48.508]                           else {
[08:25:48.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.508]                               info, version)
[08:25:48.508]                           }
[08:25:48.508]                           base::stop(msg)
[08:25:48.508]                         }
[08:25:48.508]                       })
[08:25:48.508]                     }
[08:25:48.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.508]                     base::options(mc.cores = 1L)
[08:25:48.508]                   }
[08:25:48.508]                   ...future.strategy.old <- future::plan("list")
[08:25:48.508]                   options(future.plan = NULL)
[08:25:48.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.508]                 }
[08:25:48.508]                 ...future.workdir <- getwd()
[08:25:48.508]             }
[08:25:48.508]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.508]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.508]         }
[08:25:48.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.508]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.508]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.508]             base::names(...future.oldOptions))
[08:25:48.508]     }
[08:25:48.508]     if (FALSE) {
[08:25:48.508]     }
[08:25:48.508]     else {
[08:25:48.508]         if (TRUE) {
[08:25:48.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.508]                 open = "w")
[08:25:48.508]         }
[08:25:48.508]         else {
[08:25:48.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.508]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.508]         }
[08:25:48.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.508]             base::sink(type = "output", split = FALSE)
[08:25:48.508]             base::close(...future.stdout)
[08:25:48.508]         }, add = TRUE)
[08:25:48.508]     }
[08:25:48.508]     ...future.frame <- base::sys.nframe()
[08:25:48.508]     ...future.conditions <- base::list()
[08:25:48.508]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.508]     if (FALSE) {
[08:25:48.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.508]     }
[08:25:48.508]     ...future.result <- base::tryCatch({
[08:25:48.508]         base::withCallingHandlers({
[08:25:48.508]             ...future.value <- base::withVisible(base::local({
[08:25:48.508]                 withCallingHandlers({
[08:25:48.508]                   {
[08:25:48.508]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.508]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.508]                       ...future.globals.maxSize)) {
[08:25:48.508]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.508]                       on.exit(options(oopts), add = TRUE)
[08:25:48.508]                     }
[08:25:48.508]                     {
[08:25:48.508]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.508]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.508]                         USE.NAMES = FALSE)
[08:25:48.508]                       do.call(mapply, args = args)
[08:25:48.508]                     }
[08:25:48.508]                   }
[08:25:48.508]                 }, immediateCondition = function(cond) {
[08:25:48.508]                   save_rds <- function (object, pathname, ...) 
[08:25:48.508]                   {
[08:25:48.508]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.508]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.508]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.508]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.508]                         fi_tmp[["mtime"]])
[08:25:48.508]                     }
[08:25:48.508]                     tryCatch({
[08:25:48.508]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.508]                     }, error = function(ex) {
[08:25:48.508]                       msg <- conditionMessage(ex)
[08:25:48.508]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.508]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.508]                         fi_tmp[["mtime"]], msg)
[08:25:48.508]                       ex$message <- msg
[08:25:48.508]                       stop(ex)
[08:25:48.508]                     })
[08:25:48.508]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.508]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.508]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.508]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.508]                       fi <- file.info(pathname)
[08:25:48.508]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.508]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.508]                         fi[["size"]], fi[["mtime"]])
[08:25:48.508]                       stop(msg)
[08:25:48.508]                     }
[08:25:48.508]                     invisible(pathname)
[08:25:48.508]                   }
[08:25:48.508]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.508]                     rootPath = tempdir()) 
[08:25:48.508]                   {
[08:25:48.508]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.508]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.508]                       tmpdir = path, fileext = ".rds")
[08:25:48.508]                     save_rds(obj, file)
[08:25:48.508]                   }
[08:25:48.508]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.508]                   {
[08:25:48.508]                     inherits <- base::inherits
[08:25:48.508]                     invokeRestart <- base::invokeRestart
[08:25:48.508]                     is.null <- base::is.null
[08:25:48.508]                     muffled <- FALSE
[08:25:48.508]                     if (inherits(cond, "message")) {
[08:25:48.508]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.508]                       if (muffled) 
[08:25:48.508]                         invokeRestart("muffleMessage")
[08:25:48.508]                     }
[08:25:48.508]                     else if (inherits(cond, "warning")) {
[08:25:48.508]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.508]                       if (muffled) 
[08:25:48.508]                         invokeRestart("muffleWarning")
[08:25:48.508]                     }
[08:25:48.508]                     else if (inherits(cond, "condition")) {
[08:25:48.508]                       if (!is.null(pattern)) {
[08:25:48.508]                         computeRestarts <- base::computeRestarts
[08:25:48.508]                         grepl <- base::grepl
[08:25:48.508]                         restarts <- computeRestarts(cond)
[08:25:48.508]                         for (restart in restarts) {
[08:25:48.508]                           name <- restart$name
[08:25:48.508]                           if (is.null(name)) 
[08:25:48.508]                             next
[08:25:48.508]                           if (!grepl(pattern, name)) 
[08:25:48.508]                             next
[08:25:48.508]                           invokeRestart(restart)
[08:25:48.508]                           muffled <- TRUE
[08:25:48.508]                           break
[08:25:48.508]                         }
[08:25:48.508]                       }
[08:25:48.508]                     }
[08:25:48.508]                     invisible(muffled)
[08:25:48.508]                   }
[08:25:48.508]                   muffleCondition(cond)
[08:25:48.508]                 })
[08:25:48.508]             }))
[08:25:48.508]             future::FutureResult(value = ...future.value$value, 
[08:25:48.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.508]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.508]                     ...future.globalenv.names))
[08:25:48.508]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.508]         }, condition = base::local({
[08:25:48.508]             c <- base::c
[08:25:48.508]             inherits <- base::inherits
[08:25:48.508]             invokeRestart <- base::invokeRestart
[08:25:48.508]             length <- base::length
[08:25:48.508]             list <- base::list
[08:25:48.508]             seq.int <- base::seq.int
[08:25:48.508]             signalCondition <- base::signalCondition
[08:25:48.508]             sys.calls <- base::sys.calls
[08:25:48.508]             `[[` <- base::`[[`
[08:25:48.508]             `+` <- base::`+`
[08:25:48.508]             `<<-` <- base::`<<-`
[08:25:48.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.508]                   3L)]
[08:25:48.508]             }
[08:25:48.508]             function(cond) {
[08:25:48.508]                 is_error <- inherits(cond, "error")
[08:25:48.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.508]                   NULL)
[08:25:48.508]                 if (is_error) {
[08:25:48.508]                   sessionInformation <- function() {
[08:25:48.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.508]                       search = base::search(), system = base::Sys.info())
[08:25:48.508]                   }
[08:25:48.508]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.508]                     cond$call), session = sessionInformation(), 
[08:25:48.508]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.508]                   signalCondition(cond)
[08:25:48.508]                 }
[08:25:48.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.508]                 "immediateCondition"))) {
[08:25:48.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.508]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.508]                   if (TRUE && !signal) {
[08:25:48.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.508]                     {
[08:25:48.508]                       inherits <- base::inherits
[08:25:48.508]                       invokeRestart <- base::invokeRestart
[08:25:48.508]                       is.null <- base::is.null
[08:25:48.508]                       muffled <- FALSE
[08:25:48.508]                       if (inherits(cond, "message")) {
[08:25:48.508]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.508]                         if (muffled) 
[08:25:48.508]                           invokeRestart("muffleMessage")
[08:25:48.508]                       }
[08:25:48.508]                       else if (inherits(cond, "warning")) {
[08:25:48.508]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.508]                         if (muffled) 
[08:25:48.508]                           invokeRestart("muffleWarning")
[08:25:48.508]                       }
[08:25:48.508]                       else if (inherits(cond, "condition")) {
[08:25:48.508]                         if (!is.null(pattern)) {
[08:25:48.508]                           computeRestarts <- base::computeRestarts
[08:25:48.508]                           grepl <- base::grepl
[08:25:48.508]                           restarts <- computeRestarts(cond)
[08:25:48.508]                           for (restart in restarts) {
[08:25:48.508]                             name <- restart$name
[08:25:48.508]                             if (is.null(name)) 
[08:25:48.508]                               next
[08:25:48.508]                             if (!grepl(pattern, name)) 
[08:25:48.508]                               next
[08:25:48.508]                             invokeRestart(restart)
[08:25:48.508]                             muffled <- TRUE
[08:25:48.508]                             break
[08:25:48.508]                           }
[08:25:48.508]                         }
[08:25:48.508]                       }
[08:25:48.508]                       invisible(muffled)
[08:25:48.508]                     }
[08:25:48.508]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.508]                   }
[08:25:48.508]                 }
[08:25:48.508]                 else {
[08:25:48.508]                   if (TRUE) {
[08:25:48.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.508]                     {
[08:25:48.508]                       inherits <- base::inherits
[08:25:48.508]                       invokeRestart <- base::invokeRestart
[08:25:48.508]                       is.null <- base::is.null
[08:25:48.508]                       muffled <- FALSE
[08:25:48.508]                       if (inherits(cond, "message")) {
[08:25:48.508]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.508]                         if (muffled) 
[08:25:48.508]                           invokeRestart("muffleMessage")
[08:25:48.508]                       }
[08:25:48.508]                       else if (inherits(cond, "warning")) {
[08:25:48.508]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.508]                         if (muffled) 
[08:25:48.508]                           invokeRestart("muffleWarning")
[08:25:48.508]                       }
[08:25:48.508]                       else if (inherits(cond, "condition")) {
[08:25:48.508]                         if (!is.null(pattern)) {
[08:25:48.508]                           computeRestarts <- base::computeRestarts
[08:25:48.508]                           grepl <- base::grepl
[08:25:48.508]                           restarts <- computeRestarts(cond)
[08:25:48.508]                           for (restart in restarts) {
[08:25:48.508]                             name <- restart$name
[08:25:48.508]                             if (is.null(name)) 
[08:25:48.508]                               next
[08:25:48.508]                             if (!grepl(pattern, name)) 
[08:25:48.508]                               next
[08:25:48.508]                             invokeRestart(restart)
[08:25:48.508]                             muffled <- TRUE
[08:25:48.508]                             break
[08:25:48.508]                           }
[08:25:48.508]                         }
[08:25:48.508]                       }
[08:25:48.508]                       invisible(muffled)
[08:25:48.508]                     }
[08:25:48.508]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.508]                   }
[08:25:48.508]                 }
[08:25:48.508]             }
[08:25:48.508]         }))
[08:25:48.508]     }, error = function(ex) {
[08:25:48.508]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.508]                 ...future.rng), started = ...future.startTime, 
[08:25:48.508]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.508]             version = "1.8"), class = "FutureResult")
[08:25:48.508]     }, finally = {
[08:25:48.508]         if (!identical(...future.workdir, getwd())) 
[08:25:48.508]             setwd(...future.workdir)
[08:25:48.508]         {
[08:25:48.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.508]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.508]             }
[08:25:48.508]             base::options(...future.oldOptions)
[08:25:48.508]             if (.Platform$OS.type == "windows") {
[08:25:48.508]                 old_names <- names(...future.oldEnvVars)
[08:25:48.508]                 envs <- base::Sys.getenv()
[08:25:48.508]                 names <- names(envs)
[08:25:48.508]                 common <- intersect(names, old_names)
[08:25:48.508]                 added <- setdiff(names, old_names)
[08:25:48.508]                 removed <- setdiff(old_names, names)
[08:25:48.508]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.508]                   envs[common]]
[08:25:48.508]                 NAMES <- toupper(changed)
[08:25:48.508]                 args <- list()
[08:25:48.508]                 for (kk in seq_along(NAMES)) {
[08:25:48.508]                   name <- changed[[kk]]
[08:25:48.508]                   NAME <- NAMES[[kk]]
[08:25:48.508]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.508]                     next
[08:25:48.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.508]                 }
[08:25:48.508]                 NAMES <- toupper(added)
[08:25:48.508]                 for (kk in seq_along(NAMES)) {
[08:25:48.508]                   name <- added[[kk]]
[08:25:48.508]                   NAME <- NAMES[[kk]]
[08:25:48.508]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.508]                     next
[08:25:48.508]                   args[[name]] <- ""
[08:25:48.508]                 }
[08:25:48.508]                 NAMES <- toupper(removed)
[08:25:48.508]                 for (kk in seq_along(NAMES)) {
[08:25:48.508]                   name <- removed[[kk]]
[08:25:48.508]                   NAME <- NAMES[[kk]]
[08:25:48.508]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.508]                     next
[08:25:48.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.508]                 }
[08:25:48.508]                 if (length(args) > 0) 
[08:25:48.508]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.508]             }
[08:25:48.508]             else {
[08:25:48.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.508]             }
[08:25:48.508]             {
[08:25:48.508]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.508]                   0L) {
[08:25:48.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.508]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.508]                   base::options(opts)
[08:25:48.508]                 }
[08:25:48.508]                 {
[08:25:48.508]                   {
[08:25:48.508]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.508]                     NULL
[08:25:48.508]                   }
[08:25:48.508]                   options(future.plan = NULL)
[08:25:48.508]                   if (is.na(NA_character_)) 
[08:25:48.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.508]                     .init = FALSE)
[08:25:48.508]                 }
[08:25:48.508]             }
[08:25:48.508]         }
[08:25:48.508]     })
[08:25:48.508]     if (TRUE) {
[08:25:48.508]         base::sink(type = "output", split = FALSE)
[08:25:48.508]         if (TRUE) {
[08:25:48.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.508]         }
[08:25:48.508]         else {
[08:25:48.508]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.508]         }
[08:25:48.508]         base::close(...future.stdout)
[08:25:48.508]         ...future.stdout <- NULL
[08:25:48.508]     }
[08:25:48.508]     ...future.result$conditions <- ...future.conditions
[08:25:48.508]     ...future.result$finished <- base::Sys.time()
[08:25:48.508]     ...future.result
[08:25:48.508] }
[08:25:48.512] assign_globals() ...
[08:25:48.512] List of 5
[08:25:48.512]  $ ...future.FUN            :function (x, ...)  
[08:25:48.512]  $ MoreArgs                 :List of 1
[08:25:48.512]   ..$ x: num 42
[08:25:48.512]  $ ...future.elements_ii    :List of 1
[08:25:48.512]   ..$ times:List of 2
[08:25:48.512]   .. ..$ : int 3
[08:25:48.512]   .. ..$ : int 4
[08:25:48.512]  $ ...future.seeds_ii       : NULL
[08:25:48.512]  $ ...future.globals.maxSize: NULL
[08:25:48.512]  - attr(*, "where")=List of 5
[08:25:48.512]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.512]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.512]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.512]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.512]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.512]  - attr(*, "resolved")= logi FALSE
[08:25:48.512]  - attr(*, "total_size")= num 286
[08:25:48.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.512]  - attr(*, "already-done")= logi TRUE
[08:25:48.524] - copied ‘...future.FUN’ to environment
[08:25:48.524] - copied ‘MoreArgs’ to environment
[08:25:48.524] - copied ‘...future.elements_ii’ to environment
[08:25:48.524] - copied ‘...future.seeds_ii’ to environment
[08:25:48.524] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.524] assign_globals() ... done
[08:25:48.525] requestCore(): workers = 2
[08:25:48.528] MulticoreFuture started
[08:25:48.528] - Launch lazy future ... done
[08:25:48.529] run() for ‘MulticoreFuture’ ... done
[08:25:48.529] plan(): Setting new future strategy stack:
[08:25:48.529] Created future:
[08:25:48.529] List of future strategies:
[08:25:48.529] 1. sequential:
[08:25:48.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.529]    - tweaked: FALSE
[08:25:48.529]    - call: NULL
[08:25:48.531] plan(): nbrOfWorkers() = 1
[08:25:48.534] plan(): Setting new future strategy stack:
[08:25:48.534] List of future strategies:
[08:25:48.534] 1. multicore:
[08:25:48.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.534]    - tweaked: FALSE
[08:25:48.534]    - call: plan(strategy)
[08:25:48.538] plan(): nbrOfWorkers() = 2
[08:25:48.530] MulticoreFuture:
[08:25:48.530] Label: ‘future_mapply-2’
[08:25:48.530] Expression:
[08:25:48.530] {
[08:25:48.530]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.530]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.530]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.530]         on.exit(options(oopts), add = TRUE)
[08:25:48.530]     }
[08:25:48.530]     {
[08:25:48.530]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.530]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.530]         do.call(mapply, args = args)
[08:25:48.530]     }
[08:25:48.530] }
[08:25:48.530] Lazy evaluation: FALSE
[08:25:48.530] Asynchronous evaluation: TRUE
[08:25:48.530] Local evaluation: TRUE
[08:25:48.530] Environment: R_GlobalEnv
[08:25:48.530] Capture standard output: TRUE
[08:25:48.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.530] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.530] Packages: <none>
[08:25:48.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.530] Resolved: TRUE
[08:25:48.530] Value: <not collected>
[08:25:48.530] Conditions captured: <none>
[08:25:48.530] Early signaling: FALSE
[08:25:48.530] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.530] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.540] Chunk #2 of 2 ... DONE
[08:25:48.540] Launching 2 futures (chunks) ... DONE
[08:25:48.540] Resolving 2 futures (chunks) ...
[08:25:48.540] resolve() on list ...
[08:25:48.540]  recursive: 0
[08:25:48.541]  length: 2
[08:25:48.541] 
[08:25:48.541] Future #1
[08:25:48.541] result() for MulticoreFuture ...
[08:25:48.542] result() for MulticoreFuture ...
[08:25:48.543] result() for MulticoreFuture ... done
[08:25:48.543] result() for MulticoreFuture ... done
[08:25:48.543] result() for MulticoreFuture ...
[08:25:48.543] result() for MulticoreFuture ... done
[08:25:48.543] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:48.544] - nx: 2
[08:25:48.544] - relay: TRUE
[08:25:48.544] - stdout: TRUE
[08:25:48.544] - signal: TRUE
[08:25:48.544] - resignal: FALSE
[08:25:48.544] - force: TRUE
[08:25:48.545] - relayed: [n=2] FALSE, FALSE
[08:25:48.545] - queued futures: [n=2] FALSE, FALSE
[08:25:48.545]  - until=1
[08:25:48.545]  - relaying element #1
[08:25:48.545] result() for MulticoreFuture ...
[08:25:48.545] result() for MulticoreFuture ... done
[08:25:48.546] result() for MulticoreFuture ...
[08:25:48.546] result() for MulticoreFuture ... done
[08:25:48.546] result() for MulticoreFuture ...
[08:25:48.546] result() for MulticoreFuture ... done
[08:25:48.546] result() for MulticoreFuture ...
[08:25:48.547] result() for MulticoreFuture ... done
[08:25:48.547] - relayed: [n=2] TRUE, FALSE
[08:25:48.547] - queued futures: [n=2] TRUE, FALSE
[08:25:48.547] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:48.547]  length: 1 (resolved future 1)
[08:25:48.548] Future #2
[08:25:48.548] result() for MulticoreFuture ...
[08:25:48.549] result() for MulticoreFuture ...
[08:25:48.549] result() for MulticoreFuture ... done
[08:25:48.549] result() for MulticoreFuture ... done
[08:25:48.549] result() for MulticoreFuture ...
[08:25:48.549] result() for MulticoreFuture ... done
[08:25:48.549] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:48.549] - nx: 2
[08:25:48.550] - relay: TRUE
[08:25:48.550] - stdout: TRUE
[08:25:48.550] - signal: TRUE
[08:25:48.550] - resignal: FALSE
[08:25:48.550] - force: TRUE
[08:25:48.550] - relayed: [n=2] TRUE, FALSE
[08:25:48.550] - queued futures: [n=2] TRUE, FALSE
[08:25:48.550]  - until=2
[08:25:48.550]  - relaying element #2
[08:25:48.551] result() for MulticoreFuture ...
[08:25:48.551] result() for MulticoreFuture ... done
[08:25:48.551] result() for MulticoreFuture ...
[08:25:48.551] result() for MulticoreFuture ... done
[08:25:48.551] result() for MulticoreFuture ...
[08:25:48.551] result() for MulticoreFuture ... done
[08:25:48.551] result() for MulticoreFuture ...
[08:25:48.551] result() for MulticoreFuture ... done
[08:25:48.551] - relayed: [n=2] TRUE, TRUE
[08:25:48.552] - queued futures: [n=2] TRUE, TRUE
[08:25:48.552] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:48.552]  length: 0 (resolved future 2)
[08:25:48.552] Relaying remaining futures
[08:25:48.552] signalConditionsASAP(NULL, pos=0) ...
[08:25:48.552] - nx: 2
[08:25:48.552] - relay: TRUE
[08:25:48.552] - stdout: TRUE
[08:25:48.552] - signal: TRUE
[08:25:48.553] - resignal: FALSE
[08:25:48.553] - force: TRUE
[08:25:48.553] - relayed: [n=2] TRUE, TRUE
[08:25:48.553] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:48.553] - relayed: [n=2] TRUE, TRUE
[08:25:48.553] - queued futures: [n=2] TRUE, TRUE
[08:25:48.553] signalConditionsASAP(NULL, pos=0) ... done
[08:25:48.553] resolve() on list ... DONE
[08:25:48.553] result() for MulticoreFuture ...
[08:25:48.554] result() for MulticoreFuture ... done
[08:25:48.554] result() for MulticoreFuture ...
[08:25:48.554] result() for MulticoreFuture ... done
[08:25:48.554] result() for MulticoreFuture ...
[08:25:48.554] result() for MulticoreFuture ... done
[08:25:48.554] result() for MulticoreFuture ...
[08:25:48.554] result() for MulticoreFuture ... done
[08:25:48.554]  - Number of value chunks collected: 2
[08:25:48.554] Resolving 2 futures (chunks) ... DONE
[08:25:48.555] Reducing values from 2 chunks ...
[08:25:48.555]  - Number of values collected after concatenation: 4
[08:25:48.555]  - Number of values expected: 4
[08:25:48.555] Reducing values from 2 chunks ... DONE
[08:25:48.555] future_mapply() ... DONE
[08:25:48.555] future_mapply() ...
[08:25:48.558] Number of chunks: 2
[08:25:48.558] getGlobalsAndPackagesXApply() ...
[08:25:48.558]  - future.globals: TRUE
[08:25:48.558] getGlobalsAndPackages() ...
[08:25:48.558] Searching for globals...
[08:25:48.560] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[08:25:48.560] Searching for globals ... DONE
[08:25:48.560] Resolving globals: FALSE
[08:25:48.561] The total size of the 1 globals is 414 bytes (414 bytes)
[08:25:48.561] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[08:25:48.561] - globals: [1] ‘FUN’
[08:25:48.561] 
[08:25:48.561] getGlobalsAndPackages() ... DONE
[08:25:48.561]  - globals found/used: [n=1] ‘FUN’
[08:25:48.561]  - needed namespaces: [n=0] 
[08:25:48.562] Finding globals ... DONE
[08:25:48.562] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:48.562] List of 2
[08:25:48.562]  $ ...future.FUN:function (x, y)  
[08:25:48.562]  $ MoreArgs     : NULL
[08:25:48.562]  - attr(*, "where")=List of 2
[08:25:48.562]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:48.562]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:48.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.562]  - attr(*, "resolved")= logi FALSE
[08:25:48.562]  - attr(*, "total_size")= num NA
[08:25:48.568] Packages to be attached in all futures: [n=0] 
[08:25:48.568] getGlobalsAndPackagesXApply() ... DONE
[08:25:48.568] Number of futures (= number of chunks): 2
[08:25:48.568] Launching 2 futures (chunks) ...
[08:25:48.568] Chunk #1 of 2 ...
[08:25:48.568]  - Finding globals in '...' for chunk #1 ...
[08:25:48.569] getGlobalsAndPackages() ...
[08:25:48.569] Searching for globals...
[08:25:48.569] 
[08:25:48.569] Searching for globals ... DONE
[08:25:48.569] - globals: [0] <none>
[08:25:48.570] getGlobalsAndPackages() ... DONE
[08:25:48.570]    + additional globals found: [n=0] 
[08:25:48.570]    + additional namespaces needed: [n=0] 
[08:25:48.570]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:48.570]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.570]  - seeds: <none>
[08:25:48.570]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.570] getGlobalsAndPackages() ...
[08:25:48.570] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.571] Resolving globals: FALSE
[08:25:48.571] The total size of the 5 globals is 645 bytes (645 bytes)
[08:25:48.571] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 645 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.572] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.572] 
[08:25:48.572] getGlobalsAndPackages() ... DONE
[08:25:48.572] run() for ‘Future’ ...
[08:25:48.572] - state: ‘created’
[08:25:48.572] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.574] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.574] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.575]   - Field: ‘label’
[08:25:48.575]   - Field: ‘local’
[08:25:48.575]   - Field: ‘owner’
[08:25:48.575]   - Field: ‘envir’
[08:25:48.575]   - Field: ‘workers’
[08:25:48.575]   - Field: ‘packages’
[08:25:48.575]   - Field: ‘gc’
[08:25:48.575]   - Field: ‘job’
[08:25:48.575]   - Field: ‘conditions’
[08:25:48.575]   - Field: ‘expr’
[08:25:48.575]   - Field: ‘uuid’
[08:25:48.576]   - Field: ‘seed’
[08:25:48.576]   - Field: ‘version’
[08:25:48.576]   - Field: ‘result’
[08:25:48.576]   - Field: ‘asynchronous’
[08:25:48.576]   - Field: ‘calls’
[08:25:48.576]   - Field: ‘globals’
[08:25:48.576]   - Field: ‘stdout’
[08:25:48.576]   - Field: ‘earlySignal’
[08:25:48.576]   - Field: ‘lazy’
[08:25:48.576]   - Field: ‘state’
[08:25:48.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.577] - Launch lazy future ...
[08:25:48.577] Packages needed by the future expression (n = 0): <none>
[08:25:48.577] Packages needed by future strategies (n = 0): <none>
[08:25:48.577] {
[08:25:48.577]     {
[08:25:48.577]         {
[08:25:48.577]             ...future.startTime <- base::Sys.time()
[08:25:48.577]             {
[08:25:48.577]                 {
[08:25:48.577]                   {
[08:25:48.577]                     {
[08:25:48.577]                       base::local({
[08:25:48.577]                         has_future <- base::requireNamespace("future", 
[08:25:48.577]                           quietly = TRUE)
[08:25:48.577]                         if (has_future) {
[08:25:48.577]                           ns <- base::getNamespace("future")
[08:25:48.577]                           version <- ns[[".package"]][["version"]]
[08:25:48.577]                           if (is.null(version)) 
[08:25:48.577]                             version <- utils::packageVersion("future")
[08:25:48.577]                         }
[08:25:48.577]                         else {
[08:25:48.577]                           version <- NULL
[08:25:48.577]                         }
[08:25:48.577]                         if (!has_future || version < "1.8.0") {
[08:25:48.577]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.577]                             "", base::R.version$version.string), 
[08:25:48.577]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.577]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.577]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.577]                               "release", "version")], collapse = " "), 
[08:25:48.577]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.577]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.577]                             info)
[08:25:48.577]                           info <- base::paste(info, collapse = "; ")
[08:25:48.577]                           if (!has_future) {
[08:25:48.577]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.577]                               info)
[08:25:48.577]                           }
[08:25:48.577]                           else {
[08:25:48.577]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.577]                               info, version)
[08:25:48.577]                           }
[08:25:48.577]                           base::stop(msg)
[08:25:48.577]                         }
[08:25:48.577]                       })
[08:25:48.577]                     }
[08:25:48.577]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.577]                     base::options(mc.cores = 1L)
[08:25:48.577]                   }
[08:25:48.577]                   ...future.strategy.old <- future::plan("list")
[08:25:48.577]                   options(future.plan = NULL)
[08:25:48.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.577]                 }
[08:25:48.577]                 ...future.workdir <- getwd()
[08:25:48.577]             }
[08:25:48.577]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.577]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.577]         }
[08:25:48.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.577]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.577]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.577]             base::names(...future.oldOptions))
[08:25:48.577]     }
[08:25:48.577]     if (FALSE) {
[08:25:48.577]     }
[08:25:48.577]     else {
[08:25:48.577]         if (TRUE) {
[08:25:48.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.577]                 open = "w")
[08:25:48.577]         }
[08:25:48.577]         else {
[08:25:48.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.577]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.577]         }
[08:25:48.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.577]             base::sink(type = "output", split = FALSE)
[08:25:48.577]             base::close(...future.stdout)
[08:25:48.577]         }, add = TRUE)
[08:25:48.577]     }
[08:25:48.577]     ...future.frame <- base::sys.nframe()
[08:25:48.577]     ...future.conditions <- base::list()
[08:25:48.577]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.577]     if (FALSE) {
[08:25:48.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.577]     }
[08:25:48.577]     ...future.result <- base::tryCatch({
[08:25:48.577]         base::withCallingHandlers({
[08:25:48.577]             ...future.value <- base::withVisible(base::local({
[08:25:48.577]                 withCallingHandlers({
[08:25:48.577]                   {
[08:25:48.577]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.577]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.577]                       ...future.globals.maxSize)) {
[08:25:48.577]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.577]                       on.exit(options(oopts), add = TRUE)
[08:25:48.577]                     }
[08:25:48.577]                     {
[08:25:48.577]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.577]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.577]                         USE.NAMES = FALSE)
[08:25:48.577]                       do.call(mapply, args = args)
[08:25:48.577]                     }
[08:25:48.577]                   }
[08:25:48.577]                 }, immediateCondition = function(cond) {
[08:25:48.577]                   save_rds <- function (object, pathname, ...) 
[08:25:48.577]                   {
[08:25:48.577]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.577]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.577]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.577]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.577]                         fi_tmp[["mtime"]])
[08:25:48.577]                     }
[08:25:48.577]                     tryCatch({
[08:25:48.577]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.577]                     }, error = function(ex) {
[08:25:48.577]                       msg <- conditionMessage(ex)
[08:25:48.577]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.577]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.577]                         fi_tmp[["mtime"]], msg)
[08:25:48.577]                       ex$message <- msg
[08:25:48.577]                       stop(ex)
[08:25:48.577]                     })
[08:25:48.577]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.577]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.577]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.577]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.577]                       fi <- file.info(pathname)
[08:25:48.577]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.577]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.577]                         fi[["size"]], fi[["mtime"]])
[08:25:48.577]                       stop(msg)
[08:25:48.577]                     }
[08:25:48.577]                     invisible(pathname)
[08:25:48.577]                   }
[08:25:48.577]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.577]                     rootPath = tempdir()) 
[08:25:48.577]                   {
[08:25:48.577]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.577]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.577]                       tmpdir = path, fileext = ".rds")
[08:25:48.577]                     save_rds(obj, file)
[08:25:48.577]                   }
[08:25:48.577]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.577]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.577]                   {
[08:25:48.577]                     inherits <- base::inherits
[08:25:48.577]                     invokeRestart <- base::invokeRestart
[08:25:48.577]                     is.null <- base::is.null
[08:25:48.577]                     muffled <- FALSE
[08:25:48.577]                     if (inherits(cond, "message")) {
[08:25:48.577]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.577]                       if (muffled) 
[08:25:48.577]                         invokeRestart("muffleMessage")
[08:25:48.577]                     }
[08:25:48.577]                     else if (inherits(cond, "warning")) {
[08:25:48.577]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.577]                       if (muffled) 
[08:25:48.577]                         invokeRestart("muffleWarning")
[08:25:48.577]                     }
[08:25:48.577]                     else if (inherits(cond, "condition")) {
[08:25:48.577]                       if (!is.null(pattern)) {
[08:25:48.577]                         computeRestarts <- base::computeRestarts
[08:25:48.577]                         grepl <- base::grepl
[08:25:48.577]                         restarts <- computeRestarts(cond)
[08:25:48.577]                         for (restart in restarts) {
[08:25:48.577]                           name <- restart$name
[08:25:48.577]                           if (is.null(name)) 
[08:25:48.577]                             next
[08:25:48.577]                           if (!grepl(pattern, name)) 
[08:25:48.577]                             next
[08:25:48.577]                           invokeRestart(restart)
[08:25:48.577]                           muffled <- TRUE
[08:25:48.577]                           break
[08:25:48.577]                         }
[08:25:48.577]                       }
[08:25:48.577]                     }
[08:25:48.577]                     invisible(muffled)
[08:25:48.577]                   }
[08:25:48.577]                   muffleCondition(cond)
[08:25:48.577]                 })
[08:25:48.577]             }))
[08:25:48.577]             future::FutureResult(value = ...future.value$value, 
[08:25:48.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.577]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.577]                     ...future.globalenv.names))
[08:25:48.577]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.577]         }, condition = base::local({
[08:25:48.577]             c <- base::c
[08:25:48.577]             inherits <- base::inherits
[08:25:48.577]             invokeRestart <- base::invokeRestart
[08:25:48.577]             length <- base::length
[08:25:48.577]             list <- base::list
[08:25:48.577]             seq.int <- base::seq.int
[08:25:48.577]             signalCondition <- base::signalCondition
[08:25:48.577]             sys.calls <- base::sys.calls
[08:25:48.577]             `[[` <- base::`[[`
[08:25:48.577]             `+` <- base::`+`
[08:25:48.577]             `<<-` <- base::`<<-`
[08:25:48.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.577]                   3L)]
[08:25:48.577]             }
[08:25:48.577]             function(cond) {
[08:25:48.577]                 is_error <- inherits(cond, "error")
[08:25:48.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.577]                   NULL)
[08:25:48.577]                 if (is_error) {
[08:25:48.577]                   sessionInformation <- function() {
[08:25:48.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.577]                       search = base::search(), system = base::Sys.info())
[08:25:48.577]                   }
[08:25:48.577]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.577]                     cond$call), session = sessionInformation(), 
[08:25:48.577]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.577]                   signalCondition(cond)
[08:25:48.577]                 }
[08:25:48.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.577]                 "immediateCondition"))) {
[08:25:48.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.577]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.577]                   if (TRUE && !signal) {
[08:25:48.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.577]                     {
[08:25:48.577]                       inherits <- base::inherits
[08:25:48.577]                       invokeRestart <- base::invokeRestart
[08:25:48.577]                       is.null <- base::is.null
[08:25:48.577]                       muffled <- FALSE
[08:25:48.577]                       if (inherits(cond, "message")) {
[08:25:48.577]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.577]                         if (muffled) 
[08:25:48.577]                           invokeRestart("muffleMessage")
[08:25:48.577]                       }
[08:25:48.577]                       else if (inherits(cond, "warning")) {
[08:25:48.577]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.577]                         if (muffled) 
[08:25:48.577]                           invokeRestart("muffleWarning")
[08:25:48.577]                       }
[08:25:48.577]                       else if (inherits(cond, "condition")) {
[08:25:48.577]                         if (!is.null(pattern)) {
[08:25:48.577]                           computeRestarts <- base::computeRestarts
[08:25:48.577]                           grepl <- base::grepl
[08:25:48.577]                           restarts <- computeRestarts(cond)
[08:25:48.577]                           for (restart in restarts) {
[08:25:48.577]                             name <- restart$name
[08:25:48.577]                             if (is.null(name)) 
[08:25:48.577]                               next
[08:25:48.577]                             if (!grepl(pattern, name)) 
[08:25:48.577]                               next
[08:25:48.577]                             invokeRestart(restart)
[08:25:48.577]                             muffled <- TRUE
[08:25:48.577]                             break
[08:25:48.577]                           }
[08:25:48.577]                         }
[08:25:48.577]                       }
[08:25:48.577]                       invisible(muffled)
[08:25:48.577]                     }
[08:25:48.577]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.577]                   }
[08:25:48.577]                 }
[08:25:48.577]                 else {
[08:25:48.577]                   if (TRUE) {
[08:25:48.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.577]                     {
[08:25:48.577]                       inherits <- base::inherits
[08:25:48.577]                       invokeRestart <- base::invokeRestart
[08:25:48.577]                       is.null <- base::is.null
[08:25:48.577]                       muffled <- FALSE
[08:25:48.577]                       if (inherits(cond, "message")) {
[08:25:48.577]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.577]                         if (muffled) 
[08:25:48.577]                           invokeRestart("muffleMessage")
[08:25:48.577]                       }
[08:25:48.577]                       else if (inherits(cond, "warning")) {
[08:25:48.577]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.577]                         if (muffled) 
[08:25:48.577]                           invokeRestart("muffleWarning")
[08:25:48.577]                       }
[08:25:48.577]                       else if (inherits(cond, "condition")) {
[08:25:48.577]                         if (!is.null(pattern)) {
[08:25:48.577]                           computeRestarts <- base::computeRestarts
[08:25:48.577]                           grepl <- base::grepl
[08:25:48.577]                           restarts <- computeRestarts(cond)
[08:25:48.577]                           for (restart in restarts) {
[08:25:48.577]                             name <- restart$name
[08:25:48.577]                             if (is.null(name)) 
[08:25:48.577]                               next
[08:25:48.577]                             if (!grepl(pattern, name)) 
[08:25:48.577]                               next
[08:25:48.577]                             invokeRestart(restart)
[08:25:48.577]                             muffled <- TRUE
[08:25:48.577]                             break
[08:25:48.577]                           }
[08:25:48.577]                         }
[08:25:48.577]                       }
[08:25:48.577]                       invisible(muffled)
[08:25:48.577]                     }
[08:25:48.577]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.577]                   }
[08:25:48.577]                 }
[08:25:48.577]             }
[08:25:48.577]         }))
[08:25:48.577]     }, error = function(ex) {
[08:25:48.577]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.577]                 ...future.rng), started = ...future.startTime, 
[08:25:48.577]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.577]             version = "1.8"), class = "FutureResult")
[08:25:48.577]     }, finally = {
[08:25:48.577]         if (!identical(...future.workdir, getwd())) 
[08:25:48.577]             setwd(...future.workdir)
[08:25:48.577]         {
[08:25:48.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.577]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.577]             }
[08:25:48.577]             base::options(...future.oldOptions)
[08:25:48.577]             if (.Platform$OS.type == "windows") {
[08:25:48.577]                 old_names <- names(...future.oldEnvVars)
[08:25:48.577]                 envs <- base::Sys.getenv()
[08:25:48.577]                 names <- names(envs)
[08:25:48.577]                 common <- intersect(names, old_names)
[08:25:48.577]                 added <- setdiff(names, old_names)
[08:25:48.577]                 removed <- setdiff(old_names, names)
[08:25:48.577]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.577]                   envs[common]]
[08:25:48.577]                 NAMES <- toupper(changed)
[08:25:48.577]                 args <- list()
[08:25:48.577]                 for (kk in seq_along(NAMES)) {
[08:25:48.577]                   name <- changed[[kk]]
[08:25:48.577]                   NAME <- NAMES[[kk]]
[08:25:48.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.577]                     next
[08:25:48.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.577]                 }
[08:25:48.577]                 NAMES <- toupper(added)
[08:25:48.577]                 for (kk in seq_along(NAMES)) {
[08:25:48.577]                   name <- added[[kk]]
[08:25:48.577]                   NAME <- NAMES[[kk]]
[08:25:48.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.577]                     next
[08:25:48.577]                   args[[name]] <- ""
[08:25:48.577]                 }
[08:25:48.577]                 NAMES <- toupper(removed)
[08:25:48.577]                 for (kk in seq_along(NAMES)) {
[08:25:48.577]                   name <- removed[[kk]]
[08:25:48.577]                   NAME <- NAMES[[kk]]
[08:25:48.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.577]                     next
[08:25:48.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.577]                 }
[08:25:48.577]                 if (length(args) > 0) 
[08:25:48.577]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.577]             }
[08:25:48.577]             else {
[08:25:48.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.577]             }
[08:25:48.577]             {
[08:25:48.577]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.577]                   0L) {
[08:25:48.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.577]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.577]                   base::options(opts)
[08:25:48.577]                 }
[08:25:48.577]                 {
[08:25:48.577]                   {
[08:25:48.577]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.577]                     NULL
[08:25:48.577]                   }
[08:25:48.577]                   options(future.plan = NULL)
[08:25:48.577]                   if (is.na(NA_character_)) 
[08:25:48.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.577]                     .init = FALSE)
[08:25:48.577]                 }
[08:25:48.577]             }
[08:25:48.577]         }
[08:25:48.577]     })
[08:25:48.577]     if (TRUE) {
[08:25:48.577]         base::sink(type = "output", split = FALSE)
[08:25:48.577]         if (TRUE) {
[08:25:48.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.577]         }
[08:25:48.577]         else {
[08:25:48.577]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.577]         }
[08:25:48.577]         base::close(...future.stdout)
[08:25:48.577]         ...future.stdout <- NULL
[08:25:48.577]     }
[08:25:48.577]     ...future.result$conditions <- ...future.conditions
[08:25:48.577]     ...future.result$finished <- base::Sys.time()
[08:25:48.577]     ...future.result
[08:25:48.577] }
[08:25:48.580] assign_globals() ...
[08:25:48.580] List of 5
[08:25:48.580]  $ ...future.FUN            :function (x, y)  
[08:25:48.580]  $ MoreArgs                 : NULL
[08:25:48.580]  $ ...future.elements_ii    :List of 2
[08:25:48.580]   ..$ :List of 1
[08:25:48.580]   .. ..$ a: num 1
[08:25:48.580]   ..$ :List of 1
[08:25:48.580]   .. ..$ A: num 10
[08:25:48.580]  $ ...future.seeds_ii       : NULL
[08:25:48.580]  $ ...future.globals.maxSize: NULL
[08:25:48.580]  - attr(*, "where")=List of 5
[08:25:48.580]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.580]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.580]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.580]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.580]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.580]  - attr(*, "resolved")= logi FALSE
[08:25:48.580]  - attr(*, "total_size")= num 645
[08:25:48.580]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.580]  - attr(*, "already-done")= logi TRUE
[08:25:48.585] - reassign environment for ‘...future.FUN’
[08:25:48.586] - copied ‘...future.FUN’ to environment
[08:25:48.586] - copied ‘MoreArgs’ to environment
[08:25:48.586] - copied ‘...future.elements_ii’ to environment
[08:25:48.586] - copied ‘...future.seeds_ii’ to environment
[08:25:48.586] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.586] assign_globals() ... done
[08:25:48.586] requestCore(): workers = 2
[08:25:48.589] MulticoreFuture started
[08:25:48.589] - Launch lazy future ... done
[08:25:48.589] run() for ‘MulticoreFuture’ ... done
[08:25:48.589] Created future:
[08:25:48.590] plan(): Setting new future strategy stack:
[08:25:48.590] List of future strategies:
[08:25:48.590] 1. sequential:
[08:25:48.590]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.590]    - tweaked: FALSE
[08:25:48.590]    - call: NULL
[08:25:48.591] plan(): nbrOfWorkers() = 1
[08:25:48.593] plan(): Setting new future strategy stack:
[08:25:48.593] List of future strategies:
[08:25:48.593] 1. multicore:
[08:25:48.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.593]    - tweaked: FALSE
[08:25:48.593]    - call: plan(strategy)
[08:25:48.596] plan(): nbrOfWorkers() = 2
[08:25:48.590] MulticoreFuture:
[08:25:48.590] Label: ‘future_mapply-1’
[08:25:48.590] Expression:
[08:25:48.590] {
[08:25:48.590]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.590]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.590]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.590]         on.exit(options(oopts), add = TRUE)
[08:25:48.590]     }
[08:25:48.590]     {
[08:25:48.590]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.590]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.590]         do.call(mapply, args = args)
[08:25:48.590]     }
[08:25:48.590] }
[08:25:48.590] Lazy evaluation: FALSE
[08:25:48.590] Asynchronous evaluation: TRUE
[08:25:48.590] Local evaluation: TRUE
[08:25:48.590] Environment: R_GlobalEnv
[08:25:48.590] Capture standard output: TRUE
[08:25:48.590] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.590] Globals: 5 objects totaling 645 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.590] Packages: <none>
[08:25:48.590] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.590] Resolved: TRUE
[08:25:48.590] Value: <not collected>
[08:25:48.590] Conditions captured: <none>
[08:25:48.590] Early signaling: FALSE
[08:25:48.590] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.590] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.598] Chunk #1 of 2 ... DONE
[08:25:48.598] Chunk #2 of 2 ...
[08:25:48.598]  - Finding globals in '...' for chunk #2 ...
[08:25:48.598] getGlobalsAndPackages() ...
[08:25:48.598] Searching for globals...
[08:25:48.599] 
[08:25:48.599] Searching for globals ... DONE
[08:25:48.599] - globals: [0] <none>
[08:25:48.599] getGlobalsAndPackages() ... DONE
[08:25:48.599]    + additional globals found: [n=0] 
[08:25:48.599]    + additional namespaces needed: [n=0] 
[08:25:48.600]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:48.600]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.600]  - seeds: <none>
[08:25:48.600]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.604] getGlobalsAndPackages() ...
[08:25:48.605] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.605] Resolving globals: FALSE
[08:25:48.607] The total size of the 5 globals is 695 bytes (695 bytes)
[08:25:48.608] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 695 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.608] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.609] 
[08:25:48.609] getGlobalsAndPackages() ... DONE
[08:25:48.610] run() for ‘Future’ ...
[08:25:48.610] - state: ‘created’
[08:25:48.610] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.614] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.614]   - Field: ‘label’
[08:25:48.614]   - Field: ‘local’
[08:25:48.615]   - Field: ‘owner’
[08:25:48.615]   - Field: ‘envir’
[08:25:48.615]   - Field: ‘workers’
[08:25:48.615]   - Field: ‘packages’
[08:25:48.616]   - Field: ‘gc’
[08:25:48.616]   - Field: ‘job’
[08:25:48.616]   - Field: ‘conditions’
[08:25:48.616]   - Field: ‘expr’
[08:25:48.616]   - Field: ‘uuid’
[08:25:48.616]   - Field: ‘seed’
[08:25:48.616]   - Field: ‘version’
[08:25:48.617]   - Field: ‘result’
[08:25:48.617]   - Field: ‘asynchronous’
[08:25:48.617]   - Field: ‘calls’
[08:25:48.617]   - Field: ‘globals’
[08:25:48.617]   - Field: ‘stdout’
[08:25:48.617]   - Field: ‘earlySignal’
[08:25:48.617]   - Field: ‘lazy’
[08:25:48.618]   - Field: ‘state’
[08:25:48.618] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.618] - Launch lazy future ...
[08:25:48.618] Packages needed by the future expression (n = 0): <none>
[08:25:48.618] Packages needed by future strategies (n = 0): <none>
[08:25:48.619] {
[08:25:48.619]     {
[08:25:48.619]         {
[08:25:48.619]             ...future.startTime <- base::Sys.time()
[08:25:48.619]             {
[08:25:48.619]                 {
[08:25:48.619]                   {
[08:25:48.619]                     {
[08:25:48.619]                       base::local({
[08:25:48.619]                         has_future <- base::requireNamespace("future", 
[08:25:48.619]                           quietly = TRUE)
[08:25:48.619]                         if (has_future) {
[08:25:48.619]                           ns <- base::getNamespace("future")
[08:25:48.619]                           version <- ns[[".package"]][["version"]]
[08:25:48.619]                           if (is.null(version)) 
[08:25:48.619]                             version <- utils::packageVersion("future")
[08:25:48.619]                         }
[08:25:48.619]                         else {
[08:25:48.619]                           version <- NULL
[08:25:48.619]                         }
[08:25:48.619]                         if (!has_future || version < "1.8.0") {
[08:25:48.619]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.619]                             "", base::R.version$version.string), 
[08:25:48.619]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.619]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.619]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.619]                               "release", "version")], collapse = " "), 
[08:25:48.619]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.619]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.619]                             info)
[08:25:48.619]                           info <- base::paste(info, collapse = "; ")
[08:25:48.619]                           if (!has_future) {
[08:25:48.619]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.619]                               info)
[08:25:48.619]                           }
[08:25:48.619]                           else {
[08:25:48.619]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.619]                               info, version)
[08:25:48.619]                           }
[08:25:48.619]                           base::stop(msg)
[08:25:48.619]                         }
[08:25:48.619]                       })
[08:25:48.619]                     }
[08:25:48.619]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.619]                     base::options(mc.cores = 1L)
[08:25:48.619]                   }
[08:25:48.619]                   ...future.strategy.old <- future::plan("list")
[08:25:48.619]                   options(future.plan = NULL)
[08:25:48.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.619]                 }
[08:25:48.619]                 ...future.workdir <- getwd()
[08:25:48.619]             }
[08:25:48.619]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.619]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.619]         }
[08:25:48.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.619]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.619]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.619]             base::names(...future.oldOptions))
[08:25:48.619]     }
[08:25:48.619]     if (FALSE) {
[08:25:48.619]     }
[08:25:48.619]     else {
[08:25:48.619]         if (TRUE) {
[08:25:48.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.619]                 open = "w")
[08:25:48.619]         }
[08:25:48.619]         else {
[08:25:48.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.619]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.619]         }
[08:25:48.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.619]             base::sink(type = "output", split = FALSE)
[08:25:48.619]             base::close(...future.stdout)
[08:25:48.619]         }, add = TRUE)
[08:25:48.619]     }
[08:25:48.619]     ...future.frame <- base::sys.nframe()
[08:25:48.619]     ...future.conditions <- base::list()
[08:25:48.619]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.619]     if (FALSE) {
[08:25:48.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.619]     }
[08:25:48.619]     ...future.result <- base::tryCatch({
[08:25:48.619]         base::withCallingHandlers({
[08:25:48.619]             ...future.value <- base::withVisible(base::local({
[08:25:48.619]                 withCallingHandlers({
[08:25:48.619]                   {
[08:25:48.619]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.619]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.619]                       ...future.globals.maxSize)) {
[08:25:48.619]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.619]                       on.exit(options(oopts), add = TRUE)
[08:25:48.619]                     }
[08:25:48.619]                     {
[08:25:48.619]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.619]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.619]                         USE.NAMES = FALSE)
[08:25:48.619]                       do.call(mapply, args = args)
[08:25:48.619]                     }
[08:25:48.619]                   }
[08:25:48.619]                 }, immediateCondition = function(cond) {
[08:25:48.619]                   save_rds <- function (object, pathname, ...) 
[08:25:48.619]                   {
[08:25:48.619]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.619]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.619]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.619]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.619]                         fi_tmp[["mtime"]])
[08:25:48.619]                     }
[08:25:48.619]                     tryCatch({
[08:25:48.619]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.619]                     }, error = function(ex) {
[08:25:48.619]                       msg <- conditionMessage(ex)
[08:25:48.619]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.619]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.619]                         fi_tmp[["mtime"]], msg)
[08:25:48.619]                       ex$message <- msg
[08:25:48.619]                       stop(ex)
[08:25:48.619]                     })
[08:25:48.619]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.619]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.619]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.619]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.619]                       fi <- file.info(pathname)
[08:25:48.619]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.619]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.619]                         fi[["size"]], fi[["mtime"]])
[08:25:48.619]                       stop(msg)
[08:25:48.619]                     }
[08:25:48.619]                     invisible(pathname)
[08:25:48.619]                   }
[08:25:48.619]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.619]                     rootPath = tempdir()) 
[08:25:48.619]                   {
[08:25:48.619]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.619]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.619]                       tmpdir = path, fileext = ".rds")
[08:25:48.619]                     save_rds(obj, file)
[08:25:48.619]                   }
[08:25:48.619]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.619]                   {
[08:25:48.619]                     inherits <- base::inherits
[08:25:48.619]                     invokeRestart <- base::invokeRestart
[08:25:48.619]                     is.null <- base::is.null
[08:25:48.619]                     muffled <- FALSE
[08:25:48.619]                     if (inherits(cond, "message")) {
[08:25:48.619]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.619]                       if (muffled) 
[08:25:48.619]                         invokeRestart("muffleMessage")
[08:25:48.619]                     }
[08:25:48.619]                     else if (inherits(cond, "warning")) {
[08:25:48.619]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.619]                       if (muffled) 
[08:25:48.619]                         invokeRestart("muffleWarning")
[08:25:48.619]                     }
[08:25:48.619]                     else if (inherits(cond, "condition")) {
[08:25:48.619]                       if (!is.null(pattern)) {
[08:25:48.619]                         computeRestarts <- base::computeRestarts
[08:25:48.619]                         grepl <- base::grepl
[08:25:48.619]                         restarts <- computeRestarts(cond)
[08:25:48.619]                         for (restart in restarts) {
[08:25:48.619]                           name <- restart$name
[08:25:48.619]                           if (is.null(name)) 
[08:25:48.619]                             next
[08:25:48.619]                           if (!grepl(pattern, name)) 
[08:25:48.619]                             next
[08:25:48.619]                           invokeRestart(restart)
[08:25:48.619]                           muffled <- TRUE
[08:25:48.619]                           break
[08:25:48.619]                         }
[08:25:48.619]                       }
[08:25:48.619]                     }
[08:25:48.619]                     invisible(muffled)
[08:25:48.619]                   }
[08:25:48.619]                   muffleCondition(cond)
[08:25:48.619]                 })
[08:25:48.619]             }))
[08:25:48.619]             future::FutureResult(value = ...future.value$value, 
[08:25:48.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.619]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.619]                     ...future.globalenv.names))
[08:25:48.619]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.619]         }, condition = base::local({
[08:25:48.619]             c <- base::c
[08:25:48.619]             inherits <- base::inherits
[08:25:48.619]             invokeRestart <- base::invokeRestart
[08:25:48.619]             length <- base::length
[08:25:48.619]             list <- base::list
[08:25:48.619]             seq.int <- base::seq.int
[08:25:48.619]             signalCondition <- base::signalCondition
[08:25:48.619]             sys.calls <- base::sys.calls
[08:25:48.619]             `[[` <- base::`[[`
[08:25:48.619]             `+` <- base::`+`
[08:25:48.619]             `<<-` <- base::`<<-`
[08:25:48.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.619]                   3L)]
[08:25:48.619]             }
[08:25:48.619]             function(cond) {
[08:25:48.619]                 is_error <- inherits(cond, "error")
[08:25:48.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.619]                   NULL)
[08:25:48.619]                 if (is_error) {
[08:25:48.619]                   sessionInformation <- function() {
[08:25:48.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.619]                       search = base::search(), system = base::Sys.info())
[08:25:48.619]                   }
[08:25:48.619]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.619]                     cond$call), session = sessionInformation(), 
[08:25:48.619]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.619]                   signalCondition(cond)
[08:25:48.619]                 }
[08:25:48.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.619]                 "immediateCondition"))) {
[08:25:48.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.619]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.619]                   if (TRUE && !signal) {
[08:25:48.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.619]                     {
[08:25:48.619]                       inherits <- base::inherits
[08:25:48.619]                       invokeRestart <- base::invokeRestart
[08:25:48.619]                       is.null <- base::is.null
[08:25:48.619]                       muffled <- FALSE
[08:25:48.619]                       if (inherits(cond, "message")) {
[08:25:48.619]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.619]                         if (muffled) 
[08:25:48.619]                           invokeRestart("muffleMessage")
[08:25:48.619]                       }
[08:25:48.619]                       else if (inherits(cond, "warning")) {
[08:25:48.619]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.619]                         if (muffled) 
[08:25:48.619]                           invokeRestart("muffleWarning")
[08:25:48.619]                       }
[08:25:48.619]                       else if (inherits(cond, "condition")) {
[08:25:48.619]                         if (!is.null(pattern)) {
[08:25:48.619]                           computeRestarts <- base::computeRestarts
[08:25:48.619]                           grepl <- base::grepl
[08:25:48.619]                           restarts <- computeRestarts(cond)
[08:25:48.619]                           for (restart in restarts) {
[08:25:48.619]                             name <- restart$name
[08:25:48.619]                             if (is.null(name)) 
[08:25:48.619]                               next
[08:25:48.619]                             if (!grepl(pattern, name)) 
[08:25:48.619]                               next
[08:25:48.619]                             invokeRestart(restart)
[08:25:48.619]                             muffled <- TRUE
[08:25:48.619]                             break
[08:25:48.619]                           }
[08:25:48.619]                         }
[08:25:48.619]                       }
[08:25:48.619]                       invisible(muffled)
[08:25:48.619]                     }
[08:25:48.619]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.619]                   }
[08:25:48.619]                 }
[08:25:48.619]                 else {
[08:25:48.619]                   if (TRUE) {
[08:25:48.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.619]                     {
[08:25:48.619]                       inherits <- base::inherits
[08:25:48.619]                       invokeRestart <- base::invokeRestart
[08:25:48.619]                       is.null <- base::is.null
[08:25:48.619]                       muffled <- FALSE
[08:25:48.619]                       if (inherits(cond, "message")) {
[08:25:48.619]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.619]                         if (muffled) 
[08:25:48.619]                           invokeRestart("muffleMessage")
[08:25:48.619]                       }
[08:25:48.619]                       else if (inherits(cond, "warning")) {
[08:25:48.619]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.619]                         if (muffled) 
[08:25:48.619]                           invokeRestart("muffleWarning")
[08:25:48.619]                       }
[08:25:48.619]                       else if (inherits(cond, "condition")) {
[08:25:48.619]                         if (!is.null(pattern)) {
[08:25:48.619]                           computeRestarts <- base::computeRestarts
[08:25:48.619]                           grepl <- base::grepl
[08:25:48.619]                           restarts <- computeRestarts(cond)
[08:25:48.619]                           for (restart in restarts) {
[08:25:48.619]                             name <- restart$name
[08:25:48.619]                             if (is.null(name)) 
[08:25:48.619]                               next
[08:25:48.619]                             if (!grepl(pattern, name)) 
[08:25:48.619]                               next
[08:25:48.619]                             invokeRestart(restart)
[08:25:48.619]                             muffled <- TRUE
[08:25:48.619]                             break
[08:25:48.619]                           }
[08:25:48.619]                         }
[08:25:48.619]                       }
[08:25:48.619]                       invisible(muffled)
[08:25:48.619]                     }
[08:25:48.619]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.619]                   }
[08:25:48.619]                 }
[08:25:48.619]             }
[08:25:48.619]         }))
[08:25:48.619]     }, error = function(ex) {
[08:25:48.619]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.619]                 ...future.rng), started = ...future.startTime, 
[08:25:48.619]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.619]             version = "1.8"), class = "FutureResult")
[08:25:48.619]     }, finally = {
[08:25:48.619]         if (!identical(...future.workdir, getwd())) 
[08:25:48.619]             setwd(...future.workdir)
[08:25:48.619]         {
[08:25:48.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.619]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.619]             }
[08:25:48.619]             base::options(...future.oldOptions)
[08:25:48.619]             if (.Platform$OS.type == "windows") {
[08:25:48.619]                 old_names <- names(...future.oldEnvVars)
[08:25:48.619]                 envs <- base::Sys.getenv()
[08:25:48.619]                 names <- names(envs)
[08:25:48.619]                 common <- intersect(names, old_names)
[08:25:48.619]                 added <- setdiff(names, old_names)
[08:25:48.619]                 removed <- setdiff(old_names, names)
[08:25:48.619]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.619]                   envs[common]]
[08:25:48.619]                 NAMES <- toupper(changed)
[08:25:48.619]                 args <- list()
[08:25:48.619]                 for (kk in seq_along(NAMES)) {
[08:25:48.619]                   name <- changed[[kk]]
[08:25:48.619]                   NAME <- NAMES[[kk]]
[08:25:48.619]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.619]                     next
[08:25:48.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.619]                 }
[08:25:48.619]                 NAMES <- toupper(added)
[08:25:48.619]                 for (kk in seq_along(NAMES)) {
[08:25:48.619]                   name <- added[[kk]]
[08:25:48.619]                   NAME <- NAMES[[kk]]
[08:25:48.619]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.619]                     next
[08:25:48.619]                   args[[name]] <- ""
[08:25:48.619]                 }
[08:25:48.619]                 NAMES <- toupper(removed)
[08:25:48.619]                 for (kk in seq_along(NAMES)) {
[08:25:48.619]                   name <- removed[[kk]]
[08:25:48.619]                   NAME <- NAMES[[kk]]
[08:25:48.619]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.619]                     next
[08:25:48.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.619]                 }
[08:25:48.619]                 if (length(args) > 0) 
[08:25:48.619]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.619]             }
[08:25:48.619]             else {
[08:25:48.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.619]             }
[08:25:48.619]             {
[08:25:48.619]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.619]                   0L) {
[08:25:48.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.619]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.619]                   base::options(opts)
[08:25:48.619]                 }
[08:25:48.619]                 {
[08:25:48.619]                   {
[08:25:48.619]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.619]                     NULL
[08:25:48.619]                   }
[08:25:48.619]                   options(future.plan = NULL)
[08:25:48.619]                   if (is.na(NA_character_)) 
[08:25:48.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.619]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.619]                     .init = FALSE)
[08:25:48.619]                 }
[08:25:48.619]             }
[08:25:48.619]         }
[08:25:48.619]     })
[08:25:48.619]     if (TRUE) {
[08:25:48.619]         base::sink(type = "output", split = FALSE)
[08:25:48.619]         if (TRUE) {
[08:25:48.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.619]         }
[08:25:48.619]         else {
[08:25:48.619]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.619]         }
[08:25:48.619]         base::close(...future.stdout)
[08:25:48.619]         ...future.stdout <- NULL
[08:25:48.619]     }
[08:25:48.619]     ...future.result$conditions <- ...future.conditions
[08:25:48.619]     ...future.result$finished <- base::Sys.time()
[08:25:48.619]     ...future.result
[08:25:48.619] }
[08:25:48.622] assign_globals() ...
[08:25:48.622] List of 5
[08:25:48.622]  $ ...future.FUN            :function (x, y)  
[08:25:48.622]  $ MoreArgs                 : NULL
[08:25:48.622]  $ ...future.elements_ii    :List of 2
[08:25:48.622]   ..$ :List of 2
[08:25:48.622]   .. ..$ b: num 2
[08:25:48.622]   .. ..$ c: num 3
[08:25:48.622]   ..$ :List of 2
[08:25:48.622]   .. ..$ B: num 0
[08:25:48.622]   .. ..$ C: num -10
[08:25:48.622]  $ ...future.seeds_ii       : NULL
[08:25:48.622]  $ ...future.globals.maxSize: NULL
[08:25:48.622]  - attr(*, "where")=List of 5
[08:25:48.622]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.622]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.622]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.622]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.622]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.622]  - attr(*, "resolved")= logi FALSE
[08:25:48.622]  - attr(*, "total_size")= num 695
[08:25:48.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.622]  - attr(*, "already-done")= logi TRUE
[08:25:48.629] - reassign environment for ‘...future.FUN’
[08:25:48.630] - copied ‘...future.FUN’ to environment
[08:25:48.630] - copied ‘MoreArgs’ to environment
[08:25:48.630] - copied ‘...future.elements_ii’ to environment
[08:25:48.630] - copied ‘...future.seeds_ii’ to environment
[08:25:48.630] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.630] assign_globals() ... done
[08:25:48.630] requestCore(): workers = 2
[08:25:48.633] MulticoreFuture started
[08:25:48.633] - Launch lazy future ... done
[08:25:48.633] run() for ‘MulticoreFuture’ ... done
[08:25:48.634] Created future:
[08:25:48.634] plan(): Setting new future strategy stack:
[08:25:48.634] List of future strategies:
[08:25:48.634] 1. sequential:
[08:25:48.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.634]    - tweaked: FALSE
[08:25:48.634]    - call: NULL
[08:25:48.635] plan(): nbrOfWorkers() = 1
[08:25:48.637] plan(): Setting new future strategy stack:
[08:25:48.637] List of future strategies:
[08:25:48.637] 1. multicore:
[08:25:48.637]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.637]    - tweaked: FALSE
[08:25:48.637]    - call: plan(strategy)
[08:25:48.641] plan(): nbrOfWorkers() = 2
[08:25:48.634] MulticoreFuture:
[08:25:48.634] Label: ‘future_mapply-2’
[08:25:48.634] Expression:
[08:25:48.634] {
[08:25:48.634]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.634]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.634]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.634]         on.exit(options(oopts), add = TRUE)
[08:25:48.634]     }
[08:25:48.634]     {
[08:25:48.634]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.634]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.634]         do.call(mapply, args = args)
[08:25:48.634]     }
[08:25:48.634] }
[08:25:48.634] Lazy evaluation: FALSE
[08:25:48.634] Asynchronous evaluation: TRUE
[08:25:48.634] Local evaluation: TRUE
[08:25:48.634] Environment: R_GlobalEnv
[08:25:48.634] Capture standard output: TRUE
[08:25:48.634] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.634] Globals: 5 objects totaling 695 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.634] Packages: <none>
[08:25:48.634] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.634] Resolved: TRUE
[08:25:48.634] Value: <not collected>
[08:25:48.634] Conditions captured: <none>
[08:25:48.634] Early signaling: FALSE
[08:25:48.634] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.634] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.642] Chunk #2 of 2 ... DONE
[08:25:48.642] Launching 2 futures (chunks) ... DONE
[08:25:48.642] Resolving 2 futures (chunks) ...
[08:25:48.643] resolve() on list ...
[08:25:48.643]  recursive: 0
[08:25:48.643]  length: 2
[08:25:48.643] 
[08:25:48.643] Future #1
[08:25:48.644] result() for MulticoreFuture ...
[08:25:48.644] result() for MulticoreFuture ...
[08:25:48.645] result() for MulticoreFuture ... done
[08:25:48.645] result() for MulticoreFuture ... done
[08:25:48.645] result() for MulticoreFuture ...
[08:25:48.645] result() for MulticoreFuture ... done
[08:25:48.645] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:48.645] - nx: 2
[08:25:48.645] - relay: TRUE
[08:25:48.646] - stdout: TRUE
[08:25:48.646] - signal: TRUE
[08:25:48.646] - resignal: FALSE
[08:25:48.646] - force: TRUE
[08:25:48.646] - relayed: [n=2] FALSE, FALSE
[08:25:48.646] - queued futures: [n=2] FALSE, FALSE
[08:25:48.646]  - until=1
[08:25:48.647]  - relaying element #1
[08:25:48.647] result() for MulticoreFuture ...
[08:25:48.647] result() for MulticoreFuture ... done
[08:25:48.647] result() for MulticoreFuture ...
[08:25:48.647] result() for MulticoreFuture ... done
[08:25:48.647] result() for MulticoreFuture ...
[08:25:48.647] result() for MulticoreFuture ... done
[08:25:48.648] result() for MulticoreFuture ...
[08:25:48.648] result() for MulticoreFuture ... done
[08:25:48.648] - relayed: [n=2] TRUE, FALSE
[08:25:48.648] - queued futures: [n=2] TRUE, FALSE
[08:25:48.648] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:48.648]  length: 1 (resolved future 1)
[08:25:48.649] Future #2
[08:25:48.652] result() for MulticoreFuture ...
[08:25:48.654] result() for MulticoreFuture ...
[08:25:48.654] result() for MulticoreFuture ... done
[08:25:48.655] result() for MulticoreFuture ... done
[08:25:48.655] result() for MulticoreFuture ...
[08:25:48.655] result() for MulticoreFuture ... done
[08:25:48.655] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:48.656] - nx: 2
[08:25:48.656] - relay: TRUE
[08:25:48.656] - stdout: TRUE
[08:25:48.656] - signal: TRUE
[08:25:48.656] - resignal: FALSE
[08:25:48.656] - force: TRUE
[08:25:48.657] - relayed: [n=2] TRUE, FALSE
[08:25:48.657] - queued futures: [n=2] TRUE, FALSE
[08:25:48.657]  - until=2
[08:25:48.657]  - relaying element #2
[08:25:48.657] result() for MulticoreFuture ...
[08:25:48.657] result() for MulticoreFuture ... done
[08:25:48.658] result() for MulticoreFuture ...
[08:25:48.658] result() for MulticoreFuture ... done
[08:25:48.658] result() for MulticoreFuture ...
[08:25:48.658] result() for MulticoreFuture ... done
[08:25:48.658] result() for MulticoreFuture ...
[08:25:48.659] result() for MulticoreFuture ... done
[08:25:48.659] - relayed: [n=2] TRUE, TRUE
[08:25:48.659] - queued futures: [n=2] TRUE, TRUE
[08:25:48.659] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:48.659]  length: 0 (resolved future 2)
[08:25:48.659] Relaying remaining futures
[08:25:48.659] signalConditionsASAP(NULL, pos=0) ...
[08:25:48.660] - nx: 2
[08:25:48.660] - relay: TRUE
[08:25:48.660] - stdout: TRUE
[08:25:48.660] - signal: TRUE
[08:25:48.660] - resignal: FALSE
[08:25:48.660] - force: TRUE
[08:25:48.660] - relayed: [n=2] TRUE, TRUE
[08:25:48.660] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:48.660] - relayed: [n=2] TRUE, TRUE
[08:25:48.661] - queued futures: [n=2] TRUE, TRUE
[08:25:48.661] signalConditionsASAP(NULL, pos=0) ... done
[08:25:48.661] resolve() on list ... DONE
[08:25:48.661] result() for MulticoreFuture ...
[08:25:48.661] result() for MulticoreFuture ... done
[08:25:48.661] result() for MulticoreFuture ...
[08:25:48.661] result() for MulticoreFuture ... done
[08:25:48.661] result() for MulticoreFuture ...
[08:25:48.662] result() for MulticoreFuture ... done
[08:25:48.662] result() for MulticoreFuture ...
[08:25:48.662] result() for MulticoreFuture ... done
[08:25:48.662]  - Number of value chunks collected: 2
[08:25:48.662] Resolving 2 futures (chunks) ... DONE
[08:25:48.662] Reducing values from 2 chunks ...
[08:25:48.662]  - Number of values collected after concatenation: 3
[08:25:48.662]  - Number of values expected: 3
[08:25:48.662] Reducing values from 2 chunks ... DONE
[08:25:48.663] future_mapply() ... DONE
- future_.mapply()
[08:25:48.663] future_mapply() ...
[08:25:48.665] Number of chunks: 2
[08:25:48.665] getGlobalsAndPackagesXApply() ...
[08:25:48.665]  - future.globals: TRUE
[08:25:48.665] getGlobalsAndPackages() ...
[08:25:48.666] Searching for globals...
[08:25:48.667] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[08:25:48.667] Searching for globals ... DONE
[08:25:48.667] Resolving globals: FALSE
[08:25:48.668] The total size of the 1 globals is 414 bytes (414 bytes)
[08:25:48.668] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[08:25:48.668] - globals: [1] ‘FUN’
[08:25:48.668] 
[08:25:48.669] getGlobalsAndPackages() ... DONE
[08:25:48.669]  - globals found/used: [n=1] ‘FUN’
[08:25:48.669]  - needed namespaces: [n=0] 
[08:25:48.669] Finding globals ... DONE
[08:25:48.669] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:48.669] List of 2
[08:25:48.669]  $ ...future.FUN:function (x, y)  
[08:25:48.669]  $ MoreArgs     : list()
[08:25:48.669]  - attr(*, "where")=List of 2
[08:25:48.669]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:48.669]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:48.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.669]  - attr(*, "resolved")= logi FALSE
[08:25:48.669]  - attr(*, "total_size")= num NA
[08:25:48.672] Packages to be attached in all futures: [n=0] 
[08:25:48.672] getGlobalsAndPackagesXApply() ... DONE
[08:25:48.672] Number of futures (= number of chunks): 2
[08:25:48.673] Launching 2 futures (chunks) ...
[08:25:48.673] Chunk #1 of 2 ...
[08:25:48.673]  - Finding globals in '...' for chunk #1 ...
[08:25:48.673] getGlobalsAndPackages() ...
[08:25:48.673] Searching for globals...
[08:25:48.673] 
[08:25:48.673] Searching for globals ... DONE
[08:25:48.674] - globals: [0] <none>
[08:25:48.674] getGlobalsAndPackages() ... DONE
[08:25:48.674]    + additional globals found: [n=0] 
[08:25:48.674]    + additional namespaces needed: [n=0] 
[08:25:48.674]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:48.674]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.674]  - seeds: <none>
[08:25:48.674]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.674] getGlobalsAndPackages() ...
[08:25:48.674] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.675] Resolving globals: FALSE
[08:25:48.675] The total size of the 5 globals is 649 bytes (649 bytes)
[08:25:48.675] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 649 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:48.676] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.676] 
[08:25:48.676] getGlobalsAndPackages() ... DONE
[08:25:48.676] run() for ‘Future’ ...
[08:25:48.676] - state: ‘created’
[08:25:48.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.678] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.678]   - Field: ‘label’
[08:25:48.679]   - Field: ‘local’
[08:25:48.679]   - Field: ‘owner’
[08:25:48.679]   - Field: ‘envir’
[08:25:48.681]   - Field: ‘workers’
[08:25:48.681]   - Field: ‘packages’
[08:25:48.681]   - Field: ‘gc’
[08:25:48.681]   - Field: ‘job’
[08:25:48.682]   - Field: ‘conditions’
[08:25:48.682]   - Field: ‘expr’
[08:25:48.682]   - Field: ‘uuid’
[08:25:48.682]   - Field: ‘seed’
[08:25:48.682]   - Field: ‘version’
[08:25:48.682]   - Field: ‘result’
[08:25:48.682]   - Field: ‘asynchronous’
[08:25:48.682]   - Field: ‘calls’
[08:25:48.683]   - Field: ‘globals’
[08:25:48.683]   - Field: ‘stdout’
[08:25:48.683]   - Field: ‘earlySignal’
[08:25:48.683]   - Field: ‘lazy’
[08:25:48.683]   - Field: ‘state’
[08:25:48.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.683] - Launch lazy future ...
[08:25:48.684] Packages needed by the future expression (n = 0): <none>
[08:25:48.684] Packages needed by future strategies (n = 0): <none>
[08:25:48.684] {
[08:25:48.684]     {
[08:25:48.684]         {
[08:25:48.684]             ...future.startTime <- base::Sys.time()
[08:25:48.684]             {
[08:25:48.684]                 {
[08:25:48.684]                   {
[08:25:48.684]                     {
[08:25:48.684]                       base::local({
[08:25:48.684]                         has_future <- base::requireNamespace("future", 
[08:25:48.684]                           quietly = TRUE)
[08:25:48.684]                         if (has_future) {
[08:25:48.684]                           ns <- base::getNamespace("future")
[08:25:48.684]                           version <- ns[[".package"]][["version"]]
[08:25:48.684]                           if (is.null(version)) 
[08:25:48.684]                             version <- utils::packageVersion("future")
[08:25:48.684]                         }
[08:25:48.684]                         else {
[08:25:48.684]                           version <- NULL
[08:25:48.684]                         }
[08:25:48.684]                         if (!has_future || version < "1.8.0") {
[08:25:48.684]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.684]                             "", base::R.version$version.string), 
[08:25:48.684]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.684]                               "release", "version")], collapse = " "), 
[08:25:48.684]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.684]                             info)
[08:25:48.684]                           info <- base::paste(info, collapse = "; ")
[08:25:48.684]                           if (!has_future) {
[08:25:48.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.684]                               info)
[08:25:48.684]                           }
[08:25:48.684]                           else {
[08:25:48.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.684]                               info, version)
[08:25:48.684]                           }
[08:25:48.684]                           base::stop(msg)
[08:25:48.684]                         }
[08:25:48.684]                       })
[08:25:48.684]                     }
[08:25:48.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.684]                     base::options(mc.cores = 1L)
[08:25:48.684]                   }
[08:25:48.684]                   ...future.strategy.old <- future::plan("list")
[08:25:48.684]                   options(future.plan = NULL)
[08:25:48.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.684]                 }
[08:25:48.684]                 ...future.workdir <- getwd()
[08:25:48.684]             }
[08:25:48.684]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.684]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.684]         }
[08:25:48.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.684]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.684]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.684]             base::names(...future.oldOptions))
[08:25:48.684]     }
[08:25:48.684]     if (FALSE) {
[08:25:48.684]     }
[08:25:48.684]     else {
[08:25:48.684]         if (TRUE) {
[08:25:48.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.684]                 open = "w")
[08:25:48.684]         }
[08:25:48.684]         else {
[08:25:48.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.684]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.684]         }
[08:25:48.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.684]             base::sink(type = "output", split = FALSE)
[08:25:48.684]             base::close(...future.stdout)
[08:25:48.684]         }, add = TRUE)
[08:25:48.684]     }
[08:25:48.684]     ...future.frame <- base::sys.nframe()
[08:25:48.684]     ...future.conditions <- base::list()
[08:25:48.684]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.684]     if (FALSE) {
[08:25:48.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.684]     }
[08:25:48.684]     ...future.result <- base::tryCatch({
[08:25:48.684]         base::withCallingHandlers({
[08:25:48.684]             ...future.value <- base::withVisible(base::local({
[08:25:48.684]                 withCallingHandlers({
[08:25:48.684]                   {
[08:25:48.684]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.684]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.684]                       ...future.globals.maxSize)) {
[08:25:48.684]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.684]                       on.exit(options(oopts), add = TRUE)
[08:25:48.684]                     }
[08:25:48.684]                     {
[08:25:48.684]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.684]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.684]                         USE.NAMES = FALSE)
[08:25:48.684]                       do.call(mapply, args = args)
[08:25:48.684]                     }
[08:25:48.684]                   }
[08:25:48.684]                 }, immediateCondition = function(cond) {
[08:25:48.684]                   save_rds <- function (object, pathname, ...) 
[08:25:48.684]                   {
[08:25:48.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.684]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.684]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.684]                         fi_tmp[["mtime"]])
[08:25:48.684]                     }
[08:25:48.684]                     tryCatch({
[08:25:48.684]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.684]                     }, error = function(ex) {
[08:25:48.684]                       msg <- conditionMessage(ex)
[08:25:48.684]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.684]                         fi_tmp[["mtime"]], msg)
[08:25:48.684]                       ex$message <- msg
[08:25:48.684]                       stop(ex)
[08:25:48.684]                     })
[08:25:48.684]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.684]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.684]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.684]                       fi <- file.info(pathname)
[08:25:48.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.684]                         fi[["size"]], fi[["mtime"]])
[08:25:48.684]                       stop(msg)
[08:25:48.684]                     }
[08:25:48.684]                     invisible(pathname)
[08:25:48.684]                   }
[08:25:48.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.684]                     rootPath = tempdir()) 
[08:25:48.684]                   {
[08:25:48.684]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.684]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.684]                       tmpdir = path, fileext = ".rds")
[08:25:48.684]                     save_rds(obj, file)
[08:25:48.684]                   }
[08:25:48.684]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.684]                   {
[08:25:48.684]                     inherits <- base::inherits
[08:25:48.684]                     invokeRestart <- base::invokeRestart
[08:25:48.684]                     is.null <- base::is.null
[08:25:48.684]                     muffled <- FALSE
[08:25:48.684]                     if (inherits(cond, "message")) {
[08:25:48.684]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.684]                       if (muffled) 
[08:25:48.684]                         invokeRestart("muffleMessage")
[08:25:48.684]                     }
[08:25:48.684]                     else if (inherits(cond, "warning")) {
[08:25:48.684]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.684]                       if (muffled) 
[08:25:48.684]                         invokeRestart("muffleWarning")
[08:25:48.684]                     }
[08:25:48.684]                     else if (inherits(cond, "condition")) {
[08:25:48.684]                       if (!is.null(pattern)) {
[08:25:48.684]                         computeRestarts <- base::computeRestarts
[08:25:48.684]                         grepl <- base::grepl
[08:25:48.684]                         restarts <- computeRestarts(cond)
[08:25:48.684]                         for (restart in restarts) {
[08:25:48.684]                           name <- restart$name
[08:25:48.684]                           if (is.null(name)) 
[08:25:48.684]                             next
[08:25:48.684]                           if (!grepl(pattern, name)) 
[08:25:48.684]                             next
[08:25:48.684]                           invokeRestart(restart)
[08:25:48.684]                           muffled <- TRUE
[08:25:48.684]                           break
[08:25:48.684]                         }
[08:25:48.684]                       }
[08:25:48.684]                     }
[08:25:48.684]                     invisible(muffled)
[08:25:48.684]                   }
[08:25:48.684]                   muffleCondition(cond)
[08:25:48.684]                 })
[08:25:48.684]             }))
[08:25:48.684]             future::FutureResult(value = ...future.value$value, 
[08:25:48.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.684]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.684]                     ...future.globalenv.names))
[08:25:48.684]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.684]         }, condition = base::local({
[08:25:48.684]             c <- base::c
[08:25:48.684]             inherits <- base::inherits
[08:25:48.684]             invokeRestart <- base::invokeRestart
[08:25:48.684]             length <- base::length
[08:25:48.684]             list <- base::list
[08:25:48.684]             seq.int <- base::seq.int
[08:25:48.684]             signalCondition <- base::signalCondition
[08:25:48.684]             sys.calls <- base::sys.calls
[08:25:48.684]             `[[` <- base::`[[`
[08:25:48.684]             `+` <- base::`+`
[08:25:48.684]             `<<-` <- base::`<<-`
[08:25:48.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.684]                   3L)]
[08:25:48.684]             }
[08:25:48.684]             function(cond) {
[08:25:48.684]                 is_error <- inherits(cond, "error")
[08:25:48.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.684]                   NULL)
[08:25:48.684]                 if (is_error) {
[08:25:48.684]                   sessionInformation <- function() {
[08:25:48.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.684]                       search = base::search(), system = base::Sys.info())
[08:25:48.684]                   }
[08:25:48.684]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.684]                     cond$call), session = sessionInformation(), 
[08:25:48.684]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.684]                   signalCondition(cond)
[08:25:48.684]                 }
[08:25:48.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.684]                 "immediateCondition"))) {
[08:25:48.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.684]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.684]                   if (TRUE && !signal) {
[08:25:48.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.684]                     {
[08:25:48.684]                       inherits <- base::inherits
[08:25:48.684]                       invokeRestart <- base::invokeRestart
[08:25:48.684]                       is.null <- base::is.null
[08:25:48.684]                       muffled <- FALSE
[08:25:48.684]                       if (inherits(cond, "message")) {
[08:25:48.684]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.684]                         if (muffled) 
[08:25:48.684]                           invokeRestart("muffleMessage")
[08:25:48.684]                       }
[08:25:48.684]                       else if (inherits(cond, "warning")) {
[08:25:48.684]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.684]                         if (muffled) 
[08:25:48.684]                           invokeRestart("muffleWarning")
[08:25:48.684]                       }
[08:25:48.684]                       else if (inherits(cond, "condition")) {
[08:25:48.684]                         if (!is.null(pattern)) {
[08:25:48.684]                           computeRestarts <- base::computeRestarts
[08:25:48.684]                           grepl <- base::grepl
[08:25:48.684]                           restarts <- computeRestarts(cond)
[08:25:48.684]                           for (restart in restarts) {
[08:25:48.684]                             name <- restart$name
[08:25:48.684]                             if (is.null(name)) 
[08:25:48.684]                               next
[08:25:48.684]                             if (!grepl(pattern, name)) 
[08:25:48.684]                               next
[08:25:48.684]                             invokeRestart(restart)
[08:25:48.684]                             muffled <- TRUE
[08:25:48.684]                             break
[08:25:48.684]                           }
[08:25:48.684]                         }
[08:25:48.684]                       }
[08:25:48.684]                       invisible(muffled)
[08:25:48.684]                     }
[08:25:48.684]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.684]                   }
[08:25:48.684]                 }
[08:25:48.684]                 else {
[08:25:48.684]                   if (TRUE) {
[08:25:48.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.684]                     {
[08:25:48.684]                       inherits <- base::inherits
[08:25:48.684]                       invokeRestart <- base::invokeRestart
[08:25:48.684]                       is.null <- base::is.null
[08:25:48.684]                       muffled <- FALSE
[08:25:48.684]                       if (inherits(cond, "message")) {
[08:25:48.684]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.684]                         if (muffled) 
[08:25:48.684]                           invokeRestart("muffleMessage")
[08:25:48.684]                       }
[08:25:48.684]                       else if (inherits(cond, "warning")) {
[08:25:48.684]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.684]                         if (muffled) 
[08:25:48.684]                           invokeRestart("muffleWarning")
[08:25:48.684]                       }
[08:25:48.684]                       else if (inherits(cond, "condition")) {
[08:25:48.684]                         if (!is.null(pattern)) {
[08:25:48.684]                           computeRestarts <- base::computeRestarts
[08:25:48.684]                           grepl <- base::grepl
[08:25:48.684]                           restarts <- computeRestarts(cond)
[08:25:48.684]                           for (restart in restarts) {
[08:25:48.684]                             name <- restart$name
[08:25:48.684]                             if (is.null(name)) 
[08:25:48.684]                               next
[08:25:48.684]                             if (!grepl(pattern, name)) 
[08:25:48.684]                               next
[08:25:48.684]                             invokeRestart(restart)
[08:25:48.684]                             muffled <- TRUE
[08:25:48.684]                             break
[08:25:48.684]                           }
[08:25:48.684]                         }
[08:25:48.684]                       }
[08:25:48.684]                       invisible(muffled)
[08:25:48.684]                     }
[08:25:48.684]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.684]                   }
[08:25:48.684]                 }
[08:25:48.684]             }
[08:25:48.684]         }))
[08:25:48.684]     }, error = function(ex) {
[08:25:48.684]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.684]                 ...future.rng), started = ...future.startTime, 
[08:25:48.684]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.684]             version = "1.8"), class = "FutureResult")
[08:25:48.684]     }, finally = {
[08:25:48.684]         if (!identical(...future.workdir, getwd())) 
[08:25:48.684]             setwd(...future.workdir)
[08:25:48.684]         {
[08:25:48.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.684]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.684]             }
[08:25:48.684]             base::options(...future.oldOptions)
[08:25:48.684]             if (.Platform$OS.type == "windows") {
[08:25:48.684]                 old_names <- names(...future.oldEnvVars)
[08:25:48.684]                 envs <- base::Sys.getenv()
[08:25:48.684]                 names <- names(envs)
[08:25:48.684]                 common <- intersect(names, old_names)
[08:25:48.684]                 added <- setdiff(names, old_names)
[08:25:48.684]                 removed <- setdiff(old_names, names)
[08:25:48.684]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.684]                   envs[common]]
[08:25:48.684]                 NAMES <- toupper(changed)
[08:25:48.684]                 args <- list()
[08:25:48.684]                 for (kk in seq_along(NAMES)) {
[08:25:48.684]                   name <- changed[[kk]]
[08:25:48.684]                   NAME <- NAMES[[kk]]
[08:25:48.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.684]                     next
[08:25:48.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.684]                 }
[08:25:48.684]                 NAMES <- toupper(added)
[08:25:48.684]                 for (kk in seq_along(NAMES)) {
[08:25:48.684]                   name <- added[[kk]]
[08:25:48.684]                   NAME <- NAMES[[kk]]
[08:25:48.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.684]                     next
[08:25:48.684]                   args[[name]] <- ""
[08:25:48.684]                 }
[08:25:48.684]                 NAMES <- toupper(removed)
[08:25:48.684]                 for (kk in seq_along(NAMES)) {
[08:25:48.684]                   name <- removed[[kk]]
[08:25:48.684]                   NAME <- NAMES[[kk]]
[08:25:48.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.684]                     next
[08:25:48.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.684]                 }
[08:25:48.684]                 if (length(args) > 0) 
[08:25:48.684]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.684]             }
[08:25:48.684]             else {
[08:25:48.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.684]             }
[08:25:48.684]             {
[08:25:48.684]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.684]                   0L) {
[08:25:48.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.684]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.684]                   base::options(opts)
[08:25:48.684]                 }
[08:25:48.684]                 {
[08:25:48.684]                   {
[08:25:48.684]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.684]                     NULL
[08:25:48.684]                   }
[08:25:48.684]                   options(future.plan = NULL)
[08:25:48.684]                   if (is.na(NA_character_)) 
[08:25:48.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.684]                     .init = FALSE)
[08:25:48.684]                 }
[08:25:48.684]             }
[08:25:48.684]         }
[08:25:48.684]     })
[08:25:48.684]     if (TRUE) {
[08:25:48.684]         base::sink(type = "output", split = FALSE)
[08:25:48.684]         if (TRUE) {
[08:25:48.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.684]         }
[08:25:48.684]         else {
[08:25:48.684]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.684]         }
[08:25:48.684]         base::close(...future.stdout)
[08:25:48.684]         ...future.stdout <- NULL
[08:25:48.684]     }
[08:25:48.684]     ...future.result$conditions <- ...future.conditions
[08:25:48.684]     ...future.result$finished <- base::Sys.time()
[08:25:48.684]     ...future.result
[08:25:48.684] }
[08:25:48.687] assign_globals() ...
[08:25:48.687] List of 5
[08:25:48.687]  $ ...future.FUN            :function (x, y)  
[08:25:48.687]  $ MoreArgs                 : list()
[08:25:48.687]  $ ...future.elements_ii    :List of 2
[08:25:48.687]   ..$ :List of 1
[08:25:48.687]   .. ..$ a: num 1
[08:25:48.687]   ..$ :List of 1
[08:25:48.687]   .. ..$ A: num 10
[08:25:48.687]  $ ...future.seeds_ii       : NULL
[08:25:48.687]  $ ...future.globals.maxSize: NULL
[08:25:48.687]  - attr(*, "where")=List of 5
[08:25:48.687]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.687]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.687]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.687]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.687]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.687]  - attr(*, "resolved")= logi FALSE
[08:25:48.687]  - attr(*, "total_size")= num 649
[08:25:48.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.687]  - attr(*, "already-done")= logi TRUE
[08:25:48.692] - reassign environment for ‘...future.FUN’
[08:25:48.692] - copied ‘...future.FUN’ to environment
[08:25:48.692] - copied ‘MoreArgs’ to environment
[08:25:48.693] - copied ‘...future.elements_ii’ to environment
[08:25:48.693] - copied ‘...future.seeds_ii’ to environment
[08:25:48.693] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.693] assign_globals() ... done
[08:25:48.693] requestCore(): workers = 2
[08:25:48.695] MulticoreFuture started
[08:25:48.696] - Launch lazy future ... done
[08:25:48.696] run() for ‘MulticoreFuture’ ... done
[08:25:48.696] Created future:
[08:25:48.697] plan(): Setting new future strategy stack:
[08:25:48.697] List of future strategies:
[08:25:48.697] 1. sequential:
[08:25:48.697]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.697]    - tweaked: FALSE
[08:25:48.697]    - call: NULL
[08:25:48.698] plan(): nbrOfWorkers() = 1
[08:25:48.700] plan(): Setting new future strategy stack:
[08:25:48.700] List of future strategies:
[08:25:48.700] 1. multicore:
[08:25:48.700]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.700]    - tweaked: FALSE
[08:25:48.700]    - call: plan(strategy)
[08:25:48.704] plan(): nbrOfWorkers() = 2
[08:25:48.697] MulticoreFuture:
[08:25:48.697] Label: ‘future_.mapply-1’
[08:25:48.697] Expression:
[08:25:48.697] {
[08:25:48.697]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.697]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.697]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.697]         on.exit(options(oopts), add = TRUE)
[08:25:48.697]     }
[08:25:48.697]     {
[08:25:48.697]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.697]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.697]         do.call(mapply, args = args)
[08:25:48.697]     }
[08:25:48.697] }
[08:25:48.697] Lazy evaluation: FALSE
[08:25:48.697] Asynchronous evaluation: TRUE
[08:25:48.697] Local evaluation: TRUE
[08:25:48.697] Environment: R_GlobalEnv
[08:25:48.697] Capture standard output: TRUE
[08:25:48.697] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.697] Globals: 5 objects totaling 649 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.697] Packages: <none>
[08:25:48.697] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.697] Resolved: TRUE
[08:25:48.697] Value: <not collected>
[08:25:48.697] Conditions captured: <none>
[08:25:48.697] Early signaling: FALSE
[08:25:48.697] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.697] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.705] Chunk #1 of 2 ... DONE
[08:25:48.705] Chunk #2 of 2 ...
[08:25:48.705]  - Finding globals in '...' for chunk #2 ...
[08:25:48.705] getGlobalsAndPackages() ...
[08:25:48.706] Searching for globals...
[08:25:48.706] 
[08:25:48.706] Searching for globals ... DONE
[08:25:48.706] - globals: [0] <none>
[08:25:48.707] getGlobalsAndPackages() ... DONE
[08:25:48.707]    + additional globals found: [n=0] 
[08:25:48.707]    + additional namespaces needed: [n=0] 
[08:25:48.707]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:48.707]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:48.707]  - seeds: <none>
[08:25:48.707]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.708] getGlobalsAndPackages() ...
[08:25:48.708] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.708] Resolving globals: FALSE
[08:25:48.709] The total size of the 5 globals is 699 bytes (699 bytes)
[08:25:48.710] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 699 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:48.710] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.710] 
[08:25:48.710] getGlobalsAndPackages() ... DONE
[08:25:48.711] run() for ‘Future’ ...
[08:25:48.711] - state: ‘created’
[08:25:48.711] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.714] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.714]   - Field: ‘label’
[08:25:48.715]   - Field: ‘local’
[08:25:48.715]   - Field: ‘owner’
[08:25:48.715]   - Field: ‘envir’
[08:25:48.715]   - Field: ‘workers’
[08:25:48.715]   - Field: ‘packages’
[08:25:48.715]   - Field: ‘gc’
[08:25:48.715]   - Field: ‘job’
[08:25:48.716]   - Field: ‘conditions’
[08:25:48.716]   - Field: ‘expr’
[08:25:48.716]   - Field: ‘uuid’
[08:25:48.716]   - Field: ‘seed’
[08:25:48.716]   - Field: ‘version’
[08:25:48.716]   - Field: ‘result’
[08:25:48.716]   - Field: ‘asynchronous’
[08:25:48.717]   - Field: ‘calls’
[08:25:48.717]   - Field: ‘globals’
[08:25:48.717]   - Field: ‘stdout’
[08:25:48.717]   - Field: ‘earlySignal’
[08:25:48.717]   - Field: ‘lazy’
[08:25:48.717]   - Field: ‘state’
[08:25:48.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.718] - Launch lazy future ...
[08:25:48.718] Packages needed by the future expression (n = 0): <none>
[08:25:48.718] Packages needed by future strategies (n = 0): <none>
[08:25:48.719] {
[08:25:48.719]     {
[08:25:48.719]         {
[08:25:48.719]             ...future.startTime <- base::Sys.time()
[08:25:48.719]             {
[08:25:48.719]                 {
[08:25:48.719]                   {
[08:25:48.719]                     {
[08:25:48.719]                       base::local({
[08:25:48.719]                         has_future <- base::requireNamespace("future", 
[08:25:48.719]                           quietly = TRUE)
[08:25:48.719]                         if (has_future) {
[08:25:48.719]                           ns <- base::getNamespace("future")
[08:25:48.719]                           version <- ns[[".package"]][["version"]]
[08:25:48.719]                           if (is.null(version)) 
[08:25:48.719]                             version <- utils::packageVersion("future")
[08:25:48.719]                         }
[08:25:48.719]                         else {
[08:25:48.719]                           version <- NULL
[08:25:48.719]                         }
[08:25:48.719]                         if (!has_future || version < "1.8.0") {
[08:25:48.719]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.719]                             "", base::R.version$version.string), 
[08:25:48.719]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.719]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.719]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.719]                               "release", "version")], collapse = " "), 
[08:25:48.719]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.719]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.719]                             info)
[08:25:48.719]                           info <- base::paste(info, collapse = "; ")
[08:25:48.719]                           if (!has_future) {
[08:25:48.719]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.719]                               info)
[08:25:48.719]                           }
[08:25:48.719]                           else {
[08:25:48.719]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.719]                               info, version)
[08:25:48.719]                           }
[08:25:48.719]                           base::stop(msg)
[08:25:48.719]                         }
[08:25:48.719]                       })
[08:25:48.719]                     }
[08:25:48.719]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.719]                     base::options(mc.cores = 1L)
[08:25:48.719]                   }
[08:25:48.719]                   ...future.strategy.old <- future::plan("list")
[08:25:48.719]                   options(future.plan = NULL)
[08:25:48.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.719]                 }
[08:25:48.719]                 ...future.workdir <- getwd()
[08:25:48.719]             }
[08:25:48.719]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.719]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.719]         }
[08:25:48.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.719]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:48.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.719]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.719]             base::names(...future.oldOptions))
[08:25:48.719]     }
[08:25:48.719]     if (FALSE) {
[08:25:48.719]     }
[08:25:48.719]     else {
[08:25:48.719]         if (TRUE) {
[08:25:48.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.719]                 open = "w")
[08:25:48.719]         }
[08:25:48.719]         else {
[08:25:48.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.719]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.719]         }
[08:25:48.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.719]             base::sink(type = "output", split = FALSE)
[08:25:48.719]             base::close(...future.stdout)
[08:25:48.719]         }, add = TRUE)
[08:25:48.719]     }
[08:25:48.719]     ...future.frame <- base::sys.nframe()
[08:25:48.719]     ...future.conditions <- base::list()
[08:25:48.719]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.719]     if (FALSE) {
[08:25:48.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.719]     }
[08:25:48.719]     ...future.result <- base::tryCatch({
[08:25:48.719]         base::withCallingHandlers({
[08:25:48.719]             ...future.value <- base::withVisible(base::local({
[08:25:48.719]                 withCallingHandlers({
[08:25:48.719]                   {
[08:25:48.719]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.719]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.719]                       ...future.globals.maxSize)) {
[08:25:48.719]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.719]                       on.exit(options(oopts), add = TRUE)
[08:25:48.719]                     }
[08:25:48.719]                     {
[08:25:48.719]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.719]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.719]                         USE.NAMES = FALSE)
[08:25:48.719]                       do.call(mapply, args = args)
[08:25:48.719]                     }
[08:25:48.719]                   }
[08:25:48.719]                 }, immediateCondition = function(cond) {
[08:25:48.719]                   save_rds <- function (object, pathname, ...) 
[08:25:48.719]                   {
[08:25:48.719]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.719]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.719]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.719]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.719]                         fi_tmp[["mtime"]])
[08:25:48.719]                     }
[08:25:48.719]                     tryCatch({
[08:25:48.719]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.719]                     }, error = function(ex) {
[08:25:48.719]                       msg <- conditionMessage(ex)
[08:25:48.719]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.719]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.719]                         fi_tmp[["mtime"]], msg)
[08:25:48.719]                       ex$message <- msg
[08:25:48.719]                       stop(ex)
[08:25:48.719]                     })
[08:25:48.719]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.719]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.719]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.719]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.719]                       fi <- file.info(pathname)
[08:25:48.719]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.719]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.719]                         fi[["size"]], fi[["mtime"]])
[08:25:48.719]                       stop(msg)
[08:25:48.719]                     }
[08:25:48.719]                     invisible(pathname)
[08:25:48.719]                   }
[08:25:48.719]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.719]                     rootPath = tempdir()) 
[08:25:48.719]                   {
[08:25:48.719]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.719]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.719]                       tmpdir = path, fileext = ".rds")
[08:25:48.719]                     save_rds(obj, file)
[08:25:48.719]                   }
[08:25:48.719]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.719]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.719]                   {
[08:25:48.719]                     inherits <- base::inherits
[08:25:48.719]                     invokeRestart <- base::invokeRestart
[08:25:48.719]                     is.null <- base::is.null
[08:25:48.719]                     muffled <- FALSE
[08:25:48.719]                     if (inherits(cond, "message")) {
[08:25:48.719]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.719]                       if (muffled) 
[08:25:48.719]                         invokeRestart("muffleMessage")
[08:25:48.719]                     }
[08:25:48.719]                     else if (inherits(cond, "warning")) {
[08:25:48.719]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.719]                       if (muffled) 
[08:25:48.719]                         invokeRestart("muffleWarning")
[08:25:48.719]                     }
[08:25:48.719]                     else if (inherits(cond, "condition")) {
[08:25:48.719]                       if (!is.null(pattern)) {
[08:25:48.719]                         computeRestarts <- base::computeRestarts
[08:25:48.719]                         grepl <- base::grepl
[08:25:48.719]                         restarts <- computeRestarts(cond)
[08:25:48.719]                         for (restart in restarts) {
[08:25:48.719]                           name <- restart$name
[08:25:48.719]                           if (is.null(name)) 
[08:25:48.719]                             next
[08:25:48.719]                           if (!grepl(pattern, name)) 
[08:25:48.719]                             next
[08:25:48.719]                           invokeRestart(restart)
[08:25:48.719]                           muffled <- TRUE
[08:25:48.719]                           break
[08:25:48.719]                         }
[08:25:48.719]                       }
[08:25:48.719]                     }
[08:25:48.719]                     invisible(muffled)
[08:25:48.719]                   }
[08:25:48.719]                   muffleCondition(cond)
[08:25:48.719]                 })
[08:25:48.719]             }))
[08:25:48.719]             future::FutureResult(value = ...future.value$value, 
[08:25:48.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.719]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.719]                     ...future.globalenv.names))
[08:25:48.719]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.719]         }, condition = base::local({
[08:25:48.719]             c <- base::c
[08:25:48.719]             inherits <- base::inherits
[08:25:48.719]             invokeRestart <- base::invokeRestart
[08:25:48.719]             length <- base::length
[08:25:48.719]             list <- base::list
[08:25:48.719]             seq.int <- base::seq.int
[08:25:48.719]             signalCondition <- base::signalCondition
[08:25:48.719]             sys.calls <- base::sys.calls
[08:25:48.719]             `[[` <- base::`[[`
[08:25:48.719]             `+` <- base::`+`
[08:25:48.719]             `<<-` <- base::`<<-`
[08:25:48.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.719]                   3L)]
[08:25:48.719]             }
[08:25:48.719]             function(cond) {
[08:25:48.719]                 is_error <- inherits(cond, "error")
[08:25:48.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.719]                   NULL)
[08:25:48.719]                 if (is_error) {
[08:25:48.719]                   sessionInformation <- function() {
[08:25:48.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.719]                       search = base::search(), system = base::Sys.info())
[08:25:48.719]                   }
[08:25:48.719]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.719]                     cond$call), session = sessionInformation(), 
[08:25:48.719]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.719]                   signalCondition(cond)
[08:25:48.719]                 }
[08:25:48.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.719]                 "immediateCondition"))) {
[08:25:48.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.719]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.719]                   if (TRUE && !signal) {
[08:25:48.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.719]                     {
[08:25:48.719]                       inherits <- base::inherits
[08:25:48.719]                       invokeRestart <- base::invokeRestart
[08:25:48.719]                       is.null <- base::is.null
[08:25:48.719]                       muffled <- FALSE
[08:25:48.719]                       if (inherits(cond, "message")) {
[08:25:48.719]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.719]                         if (muffled) 
[08:25:48.719]                           invokeRestart("muffleMessage")
[08:25:48.719]                       }
[08:25:48.719]                       else if (inherits(cond, "warning")) {
[08:25:48.719]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.719]                         if (muffled) 
[08:25:48.719]                           invokeRestart("muffleWarning")
[08:25:48.719]                       }
[08:25:48.719]                       else if (inherits(cond, "condition")) {
[08:25:48.719]                         if (!is.null(pattern)) {
[08:25:48.719]                           computeRestarts <- base::computeRestarts
[08:25:48.719]                           grepl <- base::grepl
[08:25:48.719]                           restarts <- computeRestarts(cond)
[08:25:48.719]                           for (restart in restarts) {
[08:25:48.719]                             name <- restart$name
[08:25:48.719]                             if (is.null(name)) 
[08:25:48.719]                               next
[08:25:48.719]                             if (!grepl(pattern, name)) 
[08:25:48.719]                               next
[08:25:48.719]                             invokeRestart(restart)
[08:25:48.719]                             muffled <- TRUE
[08:25:48.719]                             break
[08:25:48.719]                           }
[08:25:48.719]                         }
[08:25:48.719]                       }
[08:25:48.719]                       invisible(muffled)
[08:25:48.719]                     }
[08:25:48.719]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.719]                   }
[08:25:48.719]                 }
[08:25:48.719]                 else {
[08:25:48.719]                   if (TRUE) {
[08:25:48.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.719]                     {
[08:25:48.719]                       inherits <- base::inherits
[08:25:48.719]                       invokeRestart <- base::invokeRestart
[08:25:48.719]                       is.null <- base::is.null
[08:25:48.719]                       muffled <- FALSE
[08:25:48.719]                       if (inherits(cond, "message")) {
[08:25:48.719]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.719]                         if (muffled) 
[08:25:48.719]                           invokeRestart("muffleMessage")
[08:25:48.719]                       }
[08:25:48.719]                       else if (inherits(cond, "warning")) {
[08:25:48.719]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.719]                         if (muffled) 
[08:25:48.719]                           invokeRestart("muffleWarning")
[08:25:48.719]                       }
[08:25:48.719]                       else if (inherits(cond, "condition")) {
[08:25:48.719]                         if (!is.null(pattern)) {
[08:25:48.719]                           computeRestarts <- base::computeRestarts
[08:25:48.719]                           grepl <- base::grepl
[08:25:48.719]                           restarts <- computeRestarts(cond)
[08:25:48.719]                           for (restart in restarts) {
[08:25:48.719]                             name <- restart$name
[08:25:48.719]                             if (is.null(name)) 
[08:25:48.719]                               next
[08:25:48.719]                             if (!grepl(pattern, name)) 
[08:25:48.719]                               next
[08:25:48.719]                             invokeRestart(restart)
[08:25:48.719]                             muffled <- TRUE
[08:25:48.719]                             break
[08:25:48.719]                           }
[08:25:48.719]                         }
[08:25:48.719]                       }
[08:25:48.719]                       invisible(muffled)
[08:25:48.719]                     }
[08:25:48.719]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.719]                   }
[08:25:48.719]                 }
[08:25:48.719]             }
[08:25:48.719]         }))
[08:25:48.719]     }, error = function(ex) {
[08:25:48.719]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.719]                 ...future.rng), started = ...future.startTime, 
[08:25:48.719]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.719]             version = "1.8"), class = "FutureResult")
[08:25:48.719]     }, finally = {
[08:25:48.719]         if (!identical(...future.workdir, getwd())) 
[08:25:48.719]             setwd(...future.workdir)
[08:25:48.719]         {
[08:25:48.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.719]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.719]             }
[08:25:48.719]             base::options(...future.oldOptions)
[08:25:48.719]             if (.Platform$OS.type == "windows") {
[08:25:48.719]                 old_names <- names(...future.oldEnvVars)
[08:25:48.719]                 envs <- base::Sys.getenv()
[08:25:48.719]                 names <- names(envs)
[08:25:48.719]                 common <- intersect(names, old_names)
[08:25:48.719]                 added <- setdiff(names, old_names)
[08:25:48.719]                 removed <- setdiff(old_names, names)
[08:25:48.719]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.719]                   envs[common]]
[08:25:48.719]                 NAMES <- toupper(changed)
[08:25:48.719]                 args <- list()
[08:25:48.719]                 for (kk in seq_along(NAMES)) {
[08:25:48.719]                   name <- changed[[kk]]
[08:25:48.719]                   NAME <- NAMES[[kk]]
[08:25:48.719]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.719]                     next
[08:25:48.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.719]                 }
[08:25:48.719]                 NAMES <- toupper(added)
[08:25:48.719]                 for (kk in seq_along(NAMES)) {
[08:25:48.719]                   name <- added[[kk]]
[08:25:48.719]                   NAME <- NAMES[[kk]]
[08:25:48.719]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.719]                     next
[08:25:48.719]                   args[[name]] <- ""
[08:25:48.719]                 }
[08:25:48.719]                 NAMES <- toupper(removed)
[08:25:48.719]                 for (kk in seq_along(NAMES)) {
[08:25:48.719]                   name <- removed[[kk]]
[08:25:48.719]                   NAME <- NAMES[[kk]]
[08:25:48.719]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.719]                     next
[08:25:48.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.719]                 }
[08:25:48.719]                 if (length(args) > 0) 
[08:25:48.719]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.719]             }
[08:25:48.719]             else {
[08:25:48.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.719]             }
[08:25:48.719]             {
[08:25:48.719]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.719]                   0L) {
[08:25:48.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.719]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.719]                   base::options(opts)
[08:25:48.719]                 }
[08:25:48.719]                 {
[08:25:48.719]                   {
[08:25:48.719]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.719]                     NULL
[08:25:48.719]                   }
[08:25:48.719]                   options(future.plan = NULL)
[08:25:48.719]                   if (is.na(NA_character_)) 
[08:25:48.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.719]                     .init = FALSE)
[08:25:48.719]                 }
[08:25:48.719]             }
[08:25:48.719]         }
[08:25:48.719]     })
[08:25:48.719]     if (TRUE) {
[08:25:48.719]         base::sink(type = "output", split = FALSE)
[08:25:48.719]         if (TRUE) {
[08:25:48.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.719]         }
[08:25:48.719]         else {
[08:25:48.719]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.719]         }
[08:25:48.719]         base::close(...future.stdout)
[08:25:48.719]         ...future.stdout <- NULL
[08:25:48.719]     }
[08:25:48.719]     ...future.result$conditions <- ...future.conditions
[08:25:48.719]     ...future.result$finished <- base::Sys.time()
[08:25:48.719]     ...future.result
[08:25:48.719] }
[08:25:48.725] assign_globals() ...
[08:25:48.726] List of 5
[08:25:48.726]  $ ...future.FUN            :function (x, y)  
[08:25:48.726]  $ MoreArgs                 : list()
[08:25:48.726]  $ ...future.elements_ii    :List of 2
[08:25:48.726]   ..$ :List of 2
[08:25:48.726]   .. ..$ b: num 2
[08:25:48.726]   .. ..$ c: num 3
[08:25:48.726]   ..$ :List of 2
[08:25:48.726]   .. ..$ B: num 0
[08:25:48.726]   .. ..$ C: num -10
[08:25:48.726]  $ ...future.seeds_ii       : NULL
[08:25:48.726]  $ ...future.globals.maxSize: NULL
[08:25:48.726]  - attr(*, "where")=List of 5
[08:25:48.726]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.726]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.726]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.726]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.726]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.726]  - attr(*, "resolved")= logi FALSE
[08:25:48.726]  - attr(*, "total_size")= num 699
[08:25:48.726]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.726]  - attr(*, "already-done")= logi TRUE
[08:25:48.738] - reassign environment for ‘...future.FUN’
[08:25:48.738] - copied ‘...future.FUN’ to environment
[08:25:48.738] - copied ‘MoreArgs’ to environment
[08:25:48.738] - copied ‘...future.elements_ii’ to environment
[08:25:48.738] - copied ‘...future.seeds_ii’ to environment
[08:25:48.738] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.739] assign_globals() ... done
[08:25:48.739] requestCore(): workers = 2
[08:25:48.742] MulticoreFuture started
[08:25:48.742] - Launch lazy future ... done
[08:25:48.742] run() for ‘MulticoreFuture’ ... done
[08:25:48.743] Created future:
[08:25:48.743] plan(): Setting new future strategy stack:
[08:25:48.743] List of future strategies:
[08:25:48.743] 1. sequential:
[08:25:48.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.743]    - tweaked: FALSE
[08:25:48.743]    - call: NULL
[08:25:48.744] plan(): nbrOfWorkers() = 1
[08:25:48.746] plan(): Setting new future strategy stack:
[08:25:48.747] List of future strategies:
[08:25:48.747] 1. multicore:
[08:25:48.747]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.747]    - tweaked: FALSE
[08:25:48.747]    - call: plan(strategy)
[08:25:48.750] plan(): nbrOfWorkers() = 2
[08:25:48.743] MulticoreFuture:
[08:25:48.743] Label: ‘future_.mapply-2’
[08:25:48.743] Expression:
[08:25:48.743] {
[08:25:48.743]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.743]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.743]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.743]         on.exit(options(oopts), add = TRUE)
[08:25:48.743]     }
[08:25:48.743]     {
[08:25:48.743]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.743]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.743]         do.call(mapply, args = args)
[08:25:48.743]     }
[08:25:48.743] }
[08:25:48.743] Lazy evaluation: FALSE
[08:25:48.743] Asynchronous evaluation: TRUE
[08:25:48.743] Local evaluation: TRUE
[08:25:48.743] Environment: R_GlobalEnv
[08:25:48.743] Capture standard output: TRUE
[08:25:48.743] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.743] Globals: 5 objects totaling 699 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.743] Packages: <none>
[08:25:48.743] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.743] Resolved: TRUE
[08:25:48.743] Value: <not collected>
[08:25:48.743] Conditions captured: <none>
[08:25:48.743] Early signaling: FALSE
[08:25:48.743] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.743] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.751] Chunk #2 of 2 ... DONE
[08:25:48.751] Launching 2 futures (chunks) ... DONE
[08:25:48.751] Resolving 2 futures (chunks) ...
[08:25:48.751] resolve() on list ...
[08:25:48.752]  recursive: 0
[08:25:48.752]  length: 2
[08:25:48.752] 
[08:25:48.752] Future #1
[08:25:48.752] result() for MulticoreFuture ...
[08:25:48.753] result() for MulticoreFuture ...
[08:25:48.753] result() for MulticoreFuture ... done
[08:25:48.754] result() for MulticoreFuture ... done
[08:25:48.754] result() for MulticoreFuture ...
[08:25:48.754] result() for MulticoreFuture ... done
[08:25:48.754] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:48.754] - nx: 2
[08:25:48.754] - relay: TRUE
[08:25:48.754] - stdout: TRUE
[08:25:48.755] - signal: TRUE
[08:25:48.755] - resignal: FALSE
[08:25:48.755] - force: TRUE
[08:25:48.755] - relayed: [n=2] FALSE, FALSE
[08:25:48.755] - queued futures: [n=2] FALSE, FALSE
[08:25:48.755]  - until=1
[08:25:48.755]  - relaying element #1
[08:25:48.756] result() for MulticoreFuture ...
[08:25:48.756] result() for MulticoreFuture ... done
[08:25:48.756] result() for MulticoreFuture ...
[08:25:48.756] result() for MulticoreFuture ... done
[08:25:48.756] result() for MulticoreFuture ...
[08:25:48.756] result() for MulticoreFuture ... done
[08:25:48.756] result() for MulticoreFuture ...
[08:25:48.757] result() for MulticoreFuture ... done
[08:25:48.757] - relayed: [n=2] TRUE, FALSE
[08:25:48.757] - queued futures: [n=2] TRUE, FALSE
[08:25:48.757] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:48.757]  length: 1 (resolved future 1)
[08:25:48.758] Future #2
[08:25:48.758] result() for MulticoreFuture ...
[08:25:48.759] result() for MulticoreFuture ...
[08:25:48.759] result() for MulticoreFuture ... done
[08:25:48.759] result() for MulticoreFuture ... done
[08:25:48.759] result() for MulticoreFuture ...
[08:25:48.759] result() for MulticoreFuture ... done
[08:25:48.759] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:48.760] - nx: 2
[08:25:48.760] - relay: TRUE
[08:25:48.760] - stdout: TRUE
[08:25:48.760] - signal: TRUE
[08:25:48.760] - resignal: FALSE
[08:25:48.760] - force: TRUE
[08:25:48.760] - relayed: [n=2] TRUE, FALSE
[08:25:48.760] - queued futures: [n=2] TRUE, FALSE
[08:25:48.761]  - until=2
[08:25:48.761]  - relaying element #2
[08:25:48.761] result() for MulticoreFuture ...
[08:25:48.761] result() for MulticoreFuture ... done
[08:25:48.761] result() for MulticoreFuture ...
[08:25:48.761] result() for MulticoreFuture ... done
[08:25:48.761] result() for MulticoreFuture ...
[08:25:48.762] result() for MulticoreFuture ... done
[08:25:48.762] result() for MulticoreFuture ...
[08:25:48.762] result() for MulticoreFuture ... done
[08:25:48.762] - relayed: [n=2] TRUE, TRUE
[08:25:48.762] - queued futures: [n=2] TRUE, TRUE
[08:25:48.762] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:48.762]  length: 0 (resolved future 2)
[08:25:48.762] Relaying remaining futures
[08:25:48.763] signalConditionsASAP(NULL, pos=0) ...
[08:25:48.763] - nx: 2
[08:25:48.763] - relay: TRUE
[08:25:48.763] - stdout: TRUE
[08:25:48.763] - signal: TRUE
[08:25:48.763] - resignal: FALSE
[08:25:48.763] - force: TRUE
[08:25:48.763] - relayed: [n=2] TRUE, TRUE
[08:25:48.763] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:48.763] - relayed: [n=2] TRUE, TRUE
[08:25:48.764] - queued futures: [n=2] TRUE, TRUE
[08:25:48.764] signalConditionsASAP(NULL, pos=0) ... done
[08:25:48.764] resolve() on list ... DONE
[08:25:48.764] result() for MulticoreFuture ...
[08:25:48.764] result() for MulticoreFuture ... done
[08:25:48.764] result() for MulticoreFuture ...
[08:25:48.764] result() for MulticoreFuture ... done
[08:25:48.764] result() for MulticoreFuture ...
[08:25:48.765] result() for MulticoreFuture ... done
[08:25:48.765] result() for MulticoreFuture ...
[08:25:48.765] result() for MulticoreFuture ... done
[08:25:48.765]  - Number of value chunks collected: 2
[08:25:48.765] Resolving 2 futures (chunks) ... DONE
[08:25:48.765] Reducing values from 2 chunks ...
[08:25:48.765]  - Number of values collected after concatenation: 3
[08:25:48.765]  - Number of values expected: 3
[08:25:48.766] Reducing values from 2 chunks ... DONE
[08:25:48.766] future_mapply() ... DONE
[08:25:48.769] future_mapply() ...
[08:25:48.772] Number of chunks: 5
[08:25:48.772] getGlobalsAndPackagesXApply() ...
[08:25:48.772]  - future.globals: TRUE
[08:25:48.772] getGlobalsAndPackages() ...
[08:25:48.772] Searching for globals...
[08:25:48.775] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:48.775] Searching for globals ... DONE
[08:25:48.775] Resolving globals: FALSE
[08:25:48.776] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:48.776] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:48.776] - globals: [1] ‘FUN’
[08:25:48.776] 
[08:25:48.776] getGlobalsAndPackages() ... DONE
[08:25:48.777]  - globals found/used: [n=1] ‘FUN’
[08:25:48.777]  - needed namespaces: [n=0] 
[08:25:48.777] Finding globals ... DONE
[08:25:48.777] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:48.777] List of 2
[08:25:48.777]  $ ...future.FUN:function (C, k)  
[08:25:48.777]  $ MoreArgs     : NULL
[08:25:48.777]  - attr(*, "where")=List of 2
[08:25:48.777]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:48.777]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:48.777]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.777]  - attr(*, "resolved")= logi FALSE
[08:25:48.777]  - attr(*, "total_size")= num NA
[08:25:48.780] Packages to be attached in all futures: [n=0] 
[08:25:48.781] getGlobalsAndPackagesXApply() ... DONE
[08:25:48.781] Number of futures (= number of chunks): 5
[08:25:48.781] Launching 5 futures (chunks) ...
[08:25:48.781] Chunk #1 of 5 ...
[08:25:48.781]  - Finding globals in '...' for chunk #1 ...
[08:25:48.781] getGlobalsAndPackages() ...
[08:25:48.781] Searching for globals...
[08:25:48.782] 
[08:25:48.782] Searching for globals ... DONE
[08:25:48.782] - globals: [0] <none>
[08:25:48.782] getGlobalsAndPackages() ... DONE
[08:25:48.782]    + additional globals found: [n=0] 
[08:25:48.782]    + additional namespaces needed: [n=0] 
[08:25:48.782]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:48.782]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:48.782]  - seeds: <none>
[08:25:48.783]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.783] getGlobalsAndPackages() ...
[08:25:48.783] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.783] Resolving globals: FALSE
[08:25:48.783] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:48.784] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.784] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.784] 
[08:25:48.784] getGlobalsAndPackages() ... DONE
[08:25:48.785] run() for ‘Future’ ...
[08:25:48.785] - state: ‘created’
[08:25:48.785] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.787] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.787]   - Field: ‘label’
[08:25:48.787]   - Field: ‘local’
[08:25:48.787]   - Field: ‘owner’
[08:25:48.787]   - Field: ‘envir’
[08:25:48.787]   - Field: ‘workers’
[08:25:48.787]   - Field: ‘packages’
[08:25:48.788]   - Field: ‘gc’
[08:25:48.788]   - Field: ‘job’
[08:25:48.788]   - Field: ‘conditions’
[08:25:48.788]   - Field: ‘expr’
[08:25:48.788]   - Field: ‘uuid’
[08:25:48.788]   - Field: ‘seed’
[08:25:48.788]   - Field: ‘version’
[08:25:48.788]   - Field: ‘result’
[08:25:48.788]   - Field: ‘asynchronous’
[08:25:48.788]   - Field: ‘calls’
[08:25:48.788]   - Field: ‘globals’
[08:25:48.789]   - Field: ‘stdout’
[08:25:48.789]   - Field: ‘earlySignal’
[08:25:48.789]   - Field: ‘lazy’
[08:25:48.789]   - Field: ‘state’
[08:25:48.789] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.789] - Launch lazy future ...
[08:25:48.789] Packages needed by the future expression (n = 0): <none>
[08:25:48.789] Packages needed by future strategies (n = 0): <none>
[08:25:48.790] {
[08:25:48.790]     {
[08:25:48.790]         {
[08:25:48.790]             ...future.startTime <- base::Sys.time()
[08:25:48.790]             {
[08:25:48.790]                 {
[08:25:48.790]                   {
[08:25:48.790]                     {
[08:25:48.790]                       base::local({
[08:25:48.790]                         has_future <- base::requireNamespace("future", 
[08:25:48.790]                           quietly = TRUE)
[08:25:48.790]                         if (has_future) {
[08:25:48.790]                           ns <- base::getNamespace("future")
[08:25:48.790]                           version <- ns[[".package"]][["version"]]
[08:25:48.790]                           if (is.null(version)) 
[08:25:48.790]                             version <- utils::packageVersion("future")
[08:25:48.790]                         }
[08:25:48.790]                         else {
[08:25:48.790]                           version <- NULL
[08:25:48.790]                         }
[08:25:48.790]                         if (!has_future || version < "1.8.0") {
[08:25:48.790]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.790]                             "", base::R.version$version.string), 
[08:25:48.790]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.790]                               "release", "version")], collapse = " "), 
[08:25:48.790]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.790]                             info)
[08:25:48.790]                           info <- base::paste(info, collapse = "; ")
[08:25:48.790]                           if (!has_future) {
[08:25:48.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.790]                               info)
[08:25:48.790]                           }
[08:25:48.790]                           else {
[08:25:48.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.790]                               info, version)
[08:25:48.790]                           }
[08:25:48.790]                           base::stop(msg)
[08:25:48.790]                         }
[08:25:48.790]                       })
[08:25:48.790]                     }
[08:25:48.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.790]                     base::options(mc.cores = 1L)
[08:25:48.790]                   }
[08:25:48.790]                   ...future.strategy.old <- future::plan("list")
[08:25:48.790]                   options(future.plan = NULL)
[08:25:48.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.790]                 }
[08:25:48.790]                 ...future.workdir <- getwd()
[08:25:48.790]             }
[08:25:48.790]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.790]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.790]         }
[08:25:48.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.790]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:48.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.790]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.790]             base::names(...future.oldOptions))
[08:25:48.790]     }
[08:25:48.790]     if (FALSE) {
[08:25:48.790]     }
[08:25:48.790]     else {
[08:25:48.790]         if (TRUE) {
[08:25:48.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.790]                 open = "w")
[08:25:48.790]         }
[08:25:48.790]         else {
[08:25:48.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.790]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.790]         }
[08:25:48.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.790]             base::sink(type = "output", split = FALSE)
[08:25:48.790]             base::close(...future.stdout)
[08:25:48.790]         }, add = TRUE)
[08:25:48.790]     }
[08:25:48.790]     ...future.frame <- base::sys.nframe()
[08:25:48.790]     ...future.conditions <- base::list()
[08:25:48.790]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.790]     if (FALSE) {
[08:25:48.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.790]     }
[08:25:48.790]     ...future.result <- base::tryCatch({
[08:25:48.790]         base::withCallingHandlers({
[08:25:48.790]             ...future.value <- base::withVisible(base::local({
[08:25:48.790]                 withCallingHandlers({
[08:25:48.790]                   {
[08:25:48.790]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.790]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.790]                       ...future.globals.maxSize)) {
[08:25:48.790]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.790]                       on.exit(options(oopts), add = TRUE)
[08:25:48.790]                     }
[08:25:48.790]                     {
[08:25:48.790]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.790]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.790]                         USE.NAMES = FALSE)
[08:25:48.790]                       do.call(mapply, args = args)
[08:25:48.790]                     }
[08:25:48.790]                   }
[08:25:48.790]                 }, immediateCondition = function(cond) {
[08:25:48.790]                   save_rds <- function (object, pathname, ...) 
[08:25:48.790]                   {
[08:25:48.790]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.790]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.790]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.790]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.790]                         fi_tmp[["mtime"]])
[08:25:48.790]                     }
[08:25:48.790]                     tryCatch({
[08:25:48.790]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.790]                     }, error = function(ex) {
[08:25:48.790]                       msg <- conditionMessage(ex)
[08:25:48.790]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.790]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.790]                         fi_tmp[["mtime"]], msg)
[08:25:48.790]                       ex$message <- msg
[08:25:48.790]                       stop(ex)
[08:25:48.790]                     })
[08:25:48.790]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.790]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.790]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.790]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.790]                       fi <- file.info(pathname)
[08:25:48.790]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.790]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.790]                         fi[["size"]], fi[["mtime"]])
[08:25:48.790]                       stop(msg)
[08:25:48.790]                     }
[08:25:48.790]                     invisible(pathname)
[08:25:48.790]                   }
[08:25:48.790]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.790]                     rootPath = tempdir()) 
[08:25:48.790]                   {
[08:25:48.790]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.790]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.790]                       tmpdir = path, fileext = ".rds")
[08:25:48.790]                     save_rds(obj, file)
[08:25:48.790]                   }
[08:25:48.790]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.790]                   {
[08:25:48.790]                     inherits <- base::inherits
[08:25:48.790]                     invokeRestart <- base::invokeRestart
[08:25:48.790]                     is.null <- base::is.null
[08:25:48.790]                     muffled <- FALSE
[08:25:48.790]                     if (inherits(cond, "message")) {
[08:25:48.790]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.790]                       if (muffled) 
[08:25:48.790]                         invokeRestart("muffleMessage")
[08:25:48.790]                     }
[08:25:48.790]                     else if (inherits(cond, "warning")) {
[08:25:48.790]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.790]                       if (muffled) 
[08:25:48.790]                         invokeRestart("muffleWarning")
[08:25:48.790]                     }
[08:25:48.790]                     else if (inherits(cond, "condition")) {
[08:25:48.790]                       if (!is.null(pattern)) {
[08:25:48.790]                         computeRestarts <- base::computeRestarts
[08:25:48.790]                         grepl <- base::grepl
[08:25:48.790]                         restarts <- computeRestarts(cond)
[08:25:48.790]                         for (restart in restarts) {
[08:25:48.790]                           name <- restart$name
[08:25:48.790]                           if (is.null(name)) 
[08:25:48.790]                             next
[08:25:48.790]                           if (!grepl(pattern, name)) 
[08:25:48.790]                             next
[08:25:48.790]                           invokeRestart(restart)
[08:25:48.790]                           muffled <- TRUE
[08:25:48.790]                           break
[08:25:48.790]                         }
[08:25:48.790]                       }
[08:25:48.790]                     }
[08:25:48.790]                     invisible(muffled)
[08:25:48.790]                   }
[08:25:48.790]                   muffleCondition(cond)
[08:25:48.790]                 })
[08:25:48.790]             }))
[08:25:48.790]             future::FutureResult(value = ...future.value$value, 
[08:25:48.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.790]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.790]                     ...future.globalenv.names))
[08:25:48.790]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.790]         }, condition = base::local({
[08:25:48.790]             c <- base::c
[08:25:48.790]             inherits <- base::inherits
[08:25:48.790]             invokeRestart <- base::invokeRestart
[08:25:48.790]             length <- base::length
[08:25:48.790]             list <- base::list
[08:25:48.790]             seq.int <- base::seq.int
[08:25:48.790]             signalCondition <- base::signalCondition
[08:25:48.790]             sys.calls <- base::sys.calls
[08:25:48.790]             `[[` <- base::`[[`
[08:25:48.790]             `+` <- base::`+`
[08:25:48.790]             `<<-` <- base::`<<-`
[08:25:48.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.790]                   3L)]
[08:25:48.790]             }
[08:25:48.790]             function(cond) {
[08:25:48.790]                 is_error <- inherits(cond, "error")
[08:25:48.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.790]                   NULL)
[08:25:48.790]                 if (is_error) {
[08:25:48.790]                   sessionInformation <- function() {
[08:25:48.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.790]                       search = base::search(), system = base::Sys.info())
[08:25:48.790]                   }
[08:25:48.790]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.790]                     cond$call), session = sessionInformation(), 
[08:25:48.790]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.790]                   signalCondition(cond)
[08:25:48.790]                 }
[08:25:48.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.790]                 "immediateCondition"))) {
[08:25:48.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.790]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.790]                   if (TRUE && !signal) {
[08:25:48.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.790]                     {
[08:25:48.790]                       inherits <- base::inherits
[08:25:48.790]                       invokeRestart <- base::invokeRestart
[08:25:48.790]                       is.null <- base::is.null
[08:25:48.790]                       muffled <- FALSE
[08:25:48.790]                       if (inherits(cond, "message")) {
[08:25:48.790]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.790]                         if (muffled) 
[08:25:48.790]                           invokeRestart("muffleMessage")
[08:25:48.790]                       }
[08:25:48.790]                       else if (inherits(cond, "warning")) {
[08:25:48.790]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.790]                         if (muffled) 
[08:25:48.790]                           invokeRestart("muffleWarning")
[08:25:48.790]                       }
[08:25:48.790]                       else if (inherits(cond, "condition")) {
[08:25:48.790]                         if (!is.null(pattern)) {
[08:25:48.790]                           computeRestarts <- base::computeRestarts
[08:25:48.790]                           grepl <- base::grepl
[08:25:48.790]                           restarts <- computeRestarts(cond)
[08:25:48.790]                           for (restart in restarts) {
[08:25:48.790]                             name <- restart$name
[08:25:48.790]                             if (is.null(name)) 
[08:25:48.790]                               next
[08:25:48.790]                             if (!grepl(pattern, name)) 
[08:25:48.790]                               next
[08:25:48.790]                             invokeRestart(restart)
[08:25:48.790]                             muffled <- TRUE
[08:25:48.790]                             break
[08:25:48.790]                           }
[08:25:48.790]                         }
[08:25:48.790]                       }
[08:25:48.790]                       invisible(muffled)
[08:25:48.790]                     }
[08:25:48.790]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.790]                   }
[08:25:48.790]                 }
[08:25:48.790]                 else {
[08:25:48.790]                   if (TRUE) {
[08:25:48.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.790]                     {
[08:25:48.790]                       inherits <- base::inherits
[08:25:48.790]                       invokeRestart <- base::invokeRestart
[08:25:48.790]                       is.null <- base::is.null
[08:25:48.790]                       muffled <- FALSE
[08:25:48.790]                       if (inherits(cond, "message")) {
[08:25:48.790]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.790]                         if (muffled) 
[08:25:48.790]                           invokeRestart("muffleMessage")
[08:25:48.790]                       }
[08:25:48.790]                       else if (inherits(cond, "warning")) {
[08:25:48.790]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.790]                         if (muffled) 
[08:25:48.790]                           invokeRestart("muffleWarning")
[08:25:48.790]                       }
[08:25:48.790]                       else if (inherits(cond, "condition")) {
[08:25:48.790]                         if (!is.null(pattern)) {
[08:25:48.790]                           computeRestarts <- base::computeRestarts
[08:25:48.790]                           grepl <- base::grepl
[08:25:48.790]                           restarts <- computeRestarts(cond)
[08:25:48.790]                           for (restart in restarts) {
[08:25:48.790]                             name <- restart$name
[08:25:48.790]                             if (is.null(name)) 
[08:25:48.790]                               next
[08:25:48.790]                             if (!grepl(pattern, name)) 
[08:25:48.790]                               next
[08:25:48.790]                             invokeRestart(restart)
[08:25:48.790]                             muffled <- TRUE
[08:25:48.790]                             break
[08:25:48.790]                           }
[08:25:48.790]                         }
[08:25:48.790]                       }
[08:25:48.790]                       invisible(muffled)
[08:25:48.790]                     }
[08:25:48.790]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.790]                   }
[08:25:48.790]                 }
[08:25:48.790]             }
[08:25:48.790]         }))
[08:25:48.790]     }, error = function(ex) {
[08:25:48.790]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.790]                 ...future.rng), started = ...future.startTime, 
[08:25:48.790]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.790]             version = "1.8"), class = "FutureResult")
[08:25:48.790]     }, finally = {
[08:25:48.790]         if (!identical(...future.workdir, getwd())) 
[08:25:48.790]             setwd(...future.workdir)
[08:25:48.790]         {
[08:25:48.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.790]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.790]             }
[08:25:48.790]             base::options(...future.oldOptions)
[08:25:48.790]             if (.Platform$OS.type == "windows") {
[08:25:48.790]                 old_names <- names(...future.oldEnvVars)
[08:25:48.790]                 envs <- base::Sys.getenv()
[08:25:48.790]                 names <- names(envs)
[08:25:48.790]                 common <- intersect(names, old_names)
[08:25:48.790]                 added <- setdiff(names, old_names)
[08:25:48.790]                 removed <- setdiff(old_names, names)
[08:25:48.790]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.790]                   envs[common]]
[08:25:48.790]                 NAMES <- toupper(changed)
[08:25:48.790]                 args <- list()
[08:25:48.790]                 for (kk in seq_along(NAMES)) {
[08:25:48.790]                   name <- changed[[kk]]
[08:25:48.790]                   NAME <- NAMES[[kk]]
[08:25:48.790]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.790]                     next
[08:25:48.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.790]                 }
[08:25:48.790]                 NAMES <- toupper(added)
[08:25:48.790]                 for (kk in seq_along(NAMES)) {
[08:25:48.790]                   name <- added[[kk]]
[08:25:48.790]                   NAME <- NAMES[[kk]]
[08:25:48.790]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.790]                     next
[08:25:48.790]                   args[[name]] <- ""
[08:25:48.790]                 }
[08:25:48.790]                 NAMES <- toupper(removed)
[08:25:48.790]                 for (kk in seq_along(NAMES)) {
[08:25:48.790]                   name <- removed[[kk]]
[08:25:48.790]                   NAME <- NAMES[[kk]]
[08:25:48.790]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.790]                     next
[08:25:48.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.790]                 }
[08:25:48.790]                 if (length(args) > 0) 
[08:25:48.790]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.790]             }
[08:25:48.790]             else {
[08:25:48.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.790]             }
[08:25:48.790]             {
[08:25:48.790]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.790]                   0L) {
[08:25:48.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.790]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.790]                   base::options(opts)
[08:25:48.790]                 }
[08:25:48.790]                 {
[08:25:48.790]                   {
[08:25:48.790]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.790]                     NULL
[08:25:48.790]                   }
[08:25:48.790]                   options(future.plan = NULL)
[08:25:48.790]                   if (is.na(NA_character_)) 
[08:25:48.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.790]                     .init = FALSE)
[08:25:48.790]                 }
[08:25:48.790]             }
[08:25:48.790]         }
[08:25:48.790]     })
[08:25:48.790]     if (TRUE) {
[08:25:48.790]         base::sink(type = "output", split = FALSE)
[08:25:48.790]         if (TRUE) {
[08:25:48.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.790]         }
[08:25:48.790]         else {
[08:25:48.790]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.790]         }
[08:25:48.790]         base::close(...future.stdout)
[08:25:48.790]         ...future.stdout <- NULL
[08:25:48.790]     }
[08:25:48.790]     ...future.result$conditions <- ...future.conditions
[08:25:48.790]     ...future.result$finished <- base::Sys.time()
[08:25:48.790]     ...future.result
[08:25:48.790] }
[08:25:48.793] assign_globals() ...
[08:25:48.793] List of 5
[08:25:48.793]  $ ...future.FUN            :function (C, k)  
[08:25:48.793]  $ MoreArgs                 : NULL
[08:25:48.793]  $ ...future.elements_ii    :List of 2
[08:25:48.793]   ..$ :List of 1
[08:25:48.793]   .. ..$ : chr "A"
[08:25:48.793]   ..$ :List of 1
[08:25:48.793]   .. ..$ : int 5
[08:25:48.793]  $ ...future.seeds_ii       : NULL
[08:25:48.793]  $ ...future.globals.maxSize: NULL
[08:25:48.793]  - attr(*, "where")=List of 5
[08:25:48.793]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.793]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.793]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.793]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.793]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.793]  - attr(*, "resolved")= logi FALSE
[08:25:48.793]  - attr(*, "total_size")= num 847
[08:25:48.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.793]  - attr(*, "already-done")= logi TRUE
[08:25:48.801] - reassign environment for ‘...future.FUN’
[08:25:48.801] - copied ‘...future.FUN’ to environment
[08:25:48.801] - copied ‘MoreArgs’ to environment
[08:25:48.801] - copied ‘...future.elements_ii’ to environment
[08:25:48.801] - copied ‘...future.seeds_ii’ to environment
[08:25:48.802] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.802] assign_globals() ... done
[08:25:48.802] requestCore(): workers = 2
[08:25:48.804] MulticoreFuture started
[08:25:48.805] - Launch lazy future ... done
[08:25:48.805] run() for ‘MulticoreFuture’ ... done
[08:25:48.805] plan(): Setting new future strategy stack:
[08:25:48.805] Created future:
[08:25:48.806] List of future strategies:
[08:25:48.806] 1. sequential:
[08:25:48.806]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.806]    - tweaked: FALSE
[08:25:48.806]    - call: NULL
[08:25:48.807] plan(): nbrOfWorkers() = 1
[08:25:48.809] plan(): Setting new future strategy stack:
[08:25:48.810] List of future strategies:
[08:25:48.810] 1. multicore:
[08:25:48.810]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.810]    - tweaked: FALSE
[08:25:48.810]    - call: plan(strategy)
[08:25:48.813] plan(): nbrOfWorkers() = 2
[08:25:48.806] MulticoreFuture:
[08:25:48.806] Label: ‘future_mapply-1’
[08:25:48.806] Expression:
[08:25:48.806] {
[08:25:48.806]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.806]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.806]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.806]         on.exit(options(oopts), add = TRUE)
[08:25:48.806]     }
[08:25:48.806]     {
[08:25:48.806]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.806]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.806]         do.call(mapply, args = args)
[08:25:48.806]     }
[08:25:48.806] }
[08:25:48.806] Lazy evaluation: FALSE
[08:25:48.806] Asynchronous evaluation: TRUE
[08:25:48.806] Local evaluation: TRUE
[08:25:48.806] Environment: R_GlobalEnv
[08:25:48.806] Capture standard output: TRUE
[08:25:48.806] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.806] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.806] Packages: <none>
[08:25:48.806] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.806] Resolved: TRUE
[08:25:48.806] Value: <not collected>
[08:25:48.806] Conditions captured: <none>
[08:25:48.806] Early signaling: FALSE
[08:25:48.806] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.806] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.814] Chunk #1 of 5 ... DONE
[08:25:48.815] Chunk #2 of 5 ...
[08:25:48.815]  - Finding globals in '...' for chunk #2 ...
[08:25:48.815] getGlobalsAndPackages() ...
[08:25:48.815] Searching for globals...
[08:25:48.816] 
[08:25:48.816] Searching for globals ... DONE
[08:25:48.816] - globals: [0] <none>
[08:25:48.816] getGlobalsAndPackages() ... DONE
[08:25:48.816]    + additional globals found: [n=0] 
[08:25:48.817]    + additional namespaces needed: [n=0] 
[08:25:48.817]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:48.817]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:48.817]  - seeds: <none>
[08:25:48.817]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.817] getGlobalsAndPackages() ...
[08:25:48.818] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.818] Resolving globals: FALSE
[08:25:48.819] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:48.819] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.820] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.820] 
[08:25:48.820] getGlobalsAndPackages() ... DONE
[08:25:48.820] run() for ‘Future’ ...
[08:25:48.821] - state: ‘created’
[08:25:48.821] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.823] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.824]   - Field: ‘label’
[08:25:48.824]   - Field: ‘local’
[08:25:48.824]   - Field: ‘owner’
[08:25:48.824]   - Field: ‘envir’
[08:25:48.824]   - Field: ‘workers’
[08:25:48.824]   - Field: ‘packages’
[08:25:48.825]   - Field: ‘gc’
[08:25:48.825]   - Field: ‘job’
[08:25:48.825]   - Field: ‘conditions’
[08:25:48.825]   - Field: ‘expr’
[08:25:48.825]   - Field: ‘uuid’
[08:25:48.825]   - Field: ‘seed’
[08:25:48.825]   - Field: ‘version’
[08:25:48.825]   - Field: ‘result’
[08:25:48.826]   - Field: ‘asynchronous’
[08:25:48.826]   - Field: ‘calls’
[08:25:48.826]   - Field: ‘globals’
[08:25:48.826]   - Field: ‘stdout’
[08:25:48.826]   - Field: ‘earlySignal’
[08:25:48.826]   - Field: ‘lazy’
[08:25:48.826]   - Field: ‘state’
[08:25:48.827] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.827] - Launch lazy future ...
[08:25:48.827] Packages needed by the future expression (n = 0): <none>
[08:25:48.827] Packages needed by future strategies (n = 0): <none>
[08:25:48.828] {
[08:25:48.828]     {
[08:25:48.828]         {
[08:25:48.828]             ...future.startTime <- base::Sys.time()
[08:25:48.828]             {
[08:25:48.828]                 {
[08:25:48.828]                   {
[08:25:48.828]                     {
[08:25:48.828]                       base::local({
[08:25:48.828]                         has_future <- base::requireNamespace("future", 
[08:25:48.828]                           quietly = TRUE)
[08:25:48.828]                         if (has_future) {
[08:25:48.828]                           ns <- base::getNamespace("future")
[08:25:48.828]                           version <- ns[[".package"]][["version"]]
[08:25:48.828]                           if (is.null(version)) 
[08:25:48.828]                             version <- utils::packageVersion("future")
[08:25:48.828]                         }
[08:25:48.828]                         else {
[08:25:48.828]                           version <- NULL
[08:25:48.828]                         }
[08:25:48.828]                         if (!has_future || version < "1.8.0") {
[08:25:48.828]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.828]                             "", base::R.version$version.string), 
[08:25:48.828]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.828]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.828]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.828]                               "release", "version")], collapse = " "), 
[08:25:48.828]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.828]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.828]                             info)
[08:25:48.828]                           info <- base::paste(info, collapse = "; ")
[08:25:48.828]                           if (!has_future) {
[08:25:48.828]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.828]                               info)
[08:25:48.828]                           }
[08:25:48.828]                           else {
[08:25:48.828]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.828]                               info, version)
[08:25:48.828]                           }
[08:25:48.828]                           base::stop(msg)
[08:25:48.828]                         }
[08:25:48.828]                       })
[08:25:48.828]                     }
[08:25:48.828]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.828]                     base::options(mc.cores = 1L)
[08:25:48.828]                   }
[08:25:48.828]                   ...future.strategy.old <- future::plan("list")
[08:25:48.828]                   options(future.plan = NULL)
[08:25:48.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.828]                 }
[08:25:48.828]                 ...future.workdir <- getwd()
[08:25:48.828]             }
[08:25:48.828]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.828]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.828]         }
[08:25:48.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.828]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:48.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.828]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.828]             base::names(...future.oldOptions))
[08:25:48.828]     }
[08:25:48.828]     if (FALSE) {
[08:25:48.828]     }
[08:25:48.828]     else {
[08:25:48.828]         if (TRUE) {
[08:25:48.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.828]                 open = "w")
[08:25:48.828]         }
[08:25:48.828]         else {
[08:25:48.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.828]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.828]         }
[08:25:48.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.828]             base::sink(type = "output", split = FALSE)
[08:25:48.828]             base::close(...future.stdout)
[08:25:48.828]         }, add = TRUE)
[08:25:48.828]     }
[08:25:48.828]     ...future.frame <- base::sys.nframe()
[08:25:48.828]     ...future.conditions <- base::list()
[08:25:48.828]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.828]     if (FALSE) {
[08:25:48.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.828]     }
[08:25:48.828]     ...future.result <- base::tryCatch({
[08:25:48.828]         base::withCallingHandlers({
[08:25:48.828]             ...future.value <- base::withVisible(base::local({
[08:25:48.828]                 withCallingHandlers({
[08:25:48.828]                   {
[08:25:48.828]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.828]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.828]                       ...future.globals.maxSize)) {
[08:25:48.828]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.828]                       on.exit(options(oopts), add = TRUE)
[08:25:48.828]                     }
[08:25:48.828]                     {
[08:25:48.828]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.828]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.828]                         USE.NAMES = FALSE)
[08:25:48.828]                       do.call(mapply, args = args)
[08:25:48.828]                     }
[08:25:48.828]                   }
[08:25:48.828]                 }, immediateCondition = function(cond) {
[08:25:48.828]                   save_rds <- function (object, pathname, ...) 
[08:25:48.828]                   {
[08:25:48.828]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.828]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.828]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.828]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.828]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.828]                         fi_tmp[["mtime"]])
[08:25:48.828]                     }
[08:25:48.828]                     tryCatch({
[08:25:48.828]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.828]                     }, error = function(ex) {
[08:25:48.828]                       msg <- conditionMessage(ex)
[08:25:48.828]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.828]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.828]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.828]                         fi_tmp[["mtime"]], msg)
[08:25:48.828]                       ex$message <- msg
[08:25:48.828]                       stop(ex)
[08:25:48.828]                     })
[08:25:48.828]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.828]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.828]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.828]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.828]                       fi <- file.info(pathname)
[08:25:48.828]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.828]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.828]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.828]                         fi[["size"]], fi[["mtime"]])
[08:25:48.828]                       stop(msg)
[08:25:48.828]                     }
[08:25:48.828]                     invisible(pathname)
[08:25:48.828]                   }
[08:25:48.828]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.828]                     rootPath = tempdir()) 
[08:25:48.828]                   {
[08:25:48.828]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.828]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.828]                       tmpdir = path, fileext = ".rds")
[08:25:48.828]                     save_rds(obj, file)
[08:25:48.828]                   }
[08:25:48.828]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.828]                   {
[08:25:48.828]                     inherits <- base::inherits
[08:25:48.828]                     invokeRestart <- base::invokeRestart
[08:25:48.828]                     is.null <- base::is.null
[08:25:48.828]                     muffled <- FALSE
[08:25:48.828]                     if (inherits(cond, "message")) {
[08:25:48.828]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.828]                       if (muffled) 
[08:25:48.828]                         invokeRestart("muffleMessage")
[08:25:48.828]                     }
[08:25:48.828]                     else if (inherits(cond, "warning")) {
[08:25:48.828]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.828]                       if (muffled) 
[08:25:48.828]                         invokeRestart("muffleWarning")
[08:25:48.828]                     }
[08:25:48.828]                     else if (inherits(cond, "condition")) {
[08:25:48.828]                       if (!is.null(pattern)) {
[08:25:48.828]                         computeRestarts <- base::computeRestarts
[08:25:48.828]                         grepl <- base::grepl
[08:25:48.828]                         restarts <- computeRestarts(cond)
[08:25:48.828]                         for (restart in restarts) {
[08:25:48.828]                           name <- restart$name
[08:25:48.828]                           if (is.null(name)) 
[08:25:48.828]                             next
[08:25:48.828]                           if (!grepl(pattern, name)) 
[08:25:48.828]                             next
[08:25:48.828]                           invokeRestart(restart)
[08:25:48.828]                           muffled <- TRUE
[08:25:48.828]                           break
[08:25:48.828]                         }
[08:25:48.828]                       }
[08:25:48.828]                     }
[08:25:48.828]                     invisible(muffled)
[08:25:48.828]                   }
[08:25:48.828]                   muffleCondition(cond)
[08:25:48.828]                 })
[08:25:48.828]             }))
[08:25:48.828]             future::FutureResult(value = ...future.value$value, 
[08:25:48.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.828]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.828]                     ...future.globalenv.names))
[08:25:48.828]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.828]         }, condition = base::local({
[08:25:48.828]             c <- base::c
[08:25:48.828]             inherits <- base::inherits
[08:25:48.828]             invokeRestart <- base::invokeRestart
[08:25:48.828]             length <- base::length
[08:25:48.828]             list <- base::list
[08:25:48.828]             seq.int <- base::seq.int
[08:25:48.828]             signalCondition <- base::signalCondition
[08:25:48.828]             sys.calls <- base::sys.calls
[08:25:48.828]             `[[` <- base::`[[`
[08:25:48.828]             `+` <- base::`+`
[08:25:48.828]             `<<-` <- base::`<<-`
[08:25:48.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.828]                   3L)]
[08:25:48.828]             }
[08:25:48.828]             function(cond) {
[08:25:48.828]                 is_error <- inherits(cond, "error")
[08:25:48.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.828]                   NULL)
[08:25:48.828]                 if (is_error) {
[08:25:48.828]                   sessionInformation <- function() {
[08:25:48.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.828]                       search = base::search(), system = base::Sys.info())
[08:25:48.828]                   }
[08:25:48.828]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.828]                     cond$call), session = sessionInformation(), 
[08:25:48.828]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.828]                   signalCondition(cond)
[08:25:48.828]                 }
[08:25:48.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.828]                 "immediateCondition"))) {
[08:25:48.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.828]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.828]                   if (TRUE && !signal) {
[08:25:48.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.828]                     {
[08:25:48.828]                       inherits <- base::inherits
[08:25:48.828]                       invokeRestart <- base::invokeRestart
[08:25:48.828]                       is.null <- base::is.null
[08:25:48.828]                       muffled <- FALSE
[08:25:48.828]                       if (inherits(cond, "message")) {
[08:25:48.828]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.828]                         if (muffled) 
[08:25:48.828]                           invokeRestart("muffleMessage")
[08:25:48.828]                       }
[08:25:48.828]                       else if (inherits(cond, "warning")) {
[08:25:48.828]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.828]                         if (muffled) 
[08:25:48.828]                           invokeRestart("muffleWarning")
[08:25:48.828]                       }
[08:25:48.828]                       else if (inherits(cond, "condition")) {
[08:25:48.828]                         if (!is.null(pattern)) {
[08:25:48.828]                           computeRestarts <- base::computeRestarts
[08:25:48.828]                           grepl <- base::grepl
[08:25:48.828]                           restarts <- computeRestarts(cond)
[08:25:48.828]                           for (restart in restarts) {
[08:25:48.828]                             name <- restart$name
[08:25:48.828]                             if (is.null(name)) 
[08:25:48.828]                               next
[08:25:48.828]                             if (!grepl(pattern, name)) 
[08:25:48.828]                               next
[08:25:48.828]                             invokeRestart(restart)
[08:25:48.828]                             muffled <- TRUE
[08:25:48.828]                             break
[08:25:48.828]                           }
[08:25:48.828]                         }
[08:25:48.828]                       }
[08:25:48.828]                       invisible(muffled)
[08:25:48.828]                     }
[08:25:48.828]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.828]                   }
[08:25:48.828]                 }
[08:25:48.828]                 else {
[08:25:48.828]                   if (TRUE) {
[08:25:48.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.828]                     {
[08:25:48.828]                       inherits <- base::inherits
[08:25:48.828]                       invokeRestart <- base::invokeRestart
[08:25:48.828]                       is.null <- base::is.null
[08:25:48.828]                       muffled <- FALSE
[08:25:48.828]                       if (inherits(cond, "message")) {
[08:25:48.828]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.828]                         if (muffled) 
[08:25:48.828]                           invokeRestart("muffleMessage")
[08:25:48.828]                       }
[08:25:48.828]                       else if (inherits(cond, "warning")) {
[08:25:48.828]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.828]                         if (muffled) 
[08:25:48.828]                           invokeRestart("muffleWarning")
[08:25:48.828]                       }
[08:25:48.828]                       else if (inherits(cond, "condition")) {
[08:25:48.828]                         if (!is.null(pattern)) {
[08:25:48.828]                           computeRestarts <- base::computeRestarts
[08:25:48.828]                           grepl <- base::grepl
[08:25:48.828]                           restarts <- computeRestarts(cond)
[08:25:48.828]                           for (restart in restarts) {
[08:25:48.828]                             name <- restart$name
[08:25:48.828]                             if (is.null(name)) 
[08:25:48.828]                               next
[08:25:48.828]                             if (!grepl(pattern, name)) 
[08:25:48.828]                               next
[08:25:48.828]                             invokeRestart(restart)
[08:25:48.828]                             muffled <- TRUE
[08:25:48.828]                             break
[08:25:48.828]                           }
[08:25:48.828]                         }
[08:25:48.828]                       }
[08:25:48.828]                       invisible(muffled)
[08:25:48.828]                     }
[08:25:48.828]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.828]                   }
[08:25:48.828]                 }
[08:25:48.828]             }
[08:25:48.828]         }))
[08:25:48.828]     }, error = function(ex) {
[08:25:48.828]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.828]                 ...future.rng), started = ...future.startTime, 
[08:25:48.828]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.828]             version = "1.8"), class = "FutureResult")
[08:25:48.828]     }, finally = {
[08:25:48.828]         if (!identical(...future.workdir, getwd())) 
[08:25:48.828]             setwd(...future.workdir)
[08:25:48.828]         {
[08:25:48.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.828]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.828]             }
[08:25:48.828]             base::options(...future.oldOptions)
[08:25:48.828]             if (.Platform$OS.type == "windows") {
[08:25:48.828]                 old_names <- names(...future.oldEnvVars)
[08:25:48.828]                 envs <- base::Sys.getenv()
[08:25:48.828]                 names <- names(envs)
[08:25:48.828]                 common <- intersect(names, old_names)
[08:25:48.828]                 added <- setdiff(names, old_names)
[08:25:48.828]                 removed <- setdiff(old_names, names)
[08:25:48.828]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.828]                   envs[common]]
[08:25:48.828]                 NAMES <- toupper(changed)
[08:25:48.828]                 args <- list()
[08:25:48.828]                 for (kk in seq_along(NAMES)) {
[08:25:48.828]                   name <- changed[[kk]]
[08:25:48.828]                   NAME <- NAMES[[kk]]
[08:25:48.828]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.828]                     next
[08:25:48.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.828]                 }
[08:25:48.828]                 NAMES <- toupper(added)
[08:25:48.828]                 for (kk in seq_along(NAMES)) {
[08:25:48.828]                   name <- added[[kk]]
[08:25:48.828]                   NAME <- NAMES[[kk]]
[08:25:48.828]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.828]                     next
[08:25:48.828]                   args[[name]] <- ""
[08:25:48.828]                 }
[08:25:48.828]                 NAMES <- toupper(removed)
[08:25:48.828]                 for (kk in seq_along(NAMES)) {
[08:25:48.828]                   name <- removed[[kk]]
[08:25:48.828]                   NAME <- NAMES[[kk]]
[08:25:48.828]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.828]                     next
[08:25:48.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.828]                 }
[08:25:48.828]                 if (length(args) > 0) 
[08:25:48.828]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.828]             }
[08:25:48.828]             else {
[08:25:48.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.828]             }
[08:25:48.828]             {
[08:25:48.828]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.828]                   0L) {
[08:25:48.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.828]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.828]                   base::options(opts)
[08:25:48.828]                 }
[08:25:48.828]                 {
[08:25:48.828]                   {
[08:25:48.828]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.828]                     NULL
[08:25:48.828]                   }
[08:25:48.828]                   options(future.plan = NULL)
[08:25:48.828]                   if (is.na(NA_character_)) 
[08:25:48.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.828]                     .init = FALSE)
[08:25:48.828]                 }
[08:25:48.828]             }
[08:25:48.828]         }
[08:25:48.828]     })
[08:25:48.828]     if (TRUE) {
[08:25:48.828]         base::sink(type = "output", split = FALSE)
[08:25:48.828]         if (TRUE) {
[08:25:48.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.828]         }
[08:25:48.828]         else {
[08:25:48.828]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.828]         }
[08:25:48.828]         base::close(...future.stdout)
[08:25:48.828]         ...future.stdout <- NULL
[08:25:48.828]     }
[08:25:48.828]     ...future.result$conditions <- ...future.conditions
[08:25:48.828]     ...future.result$finished <- base::Sys.time()
[08:25:48.828]     ...future.result
[08:25:48.828] }
[08:25:48.832] assign_globals() ...
[08:25:48.832] List of 5
[08:25:48.832]  $ ...future.FUN            :function (C, k)  
[08:25:48.832]  $ MoreArgs                 : NULL
[08:25:48.832]  $ ...future.elements_ii    :List of 2
[08:25:48.832]   ..$ :List of 1
[08:25:48.832]   .. ..$ : chr "B"
[08:25:48.832]   ..$ :List of 1
[08:25:48.832]   .. ..$ : int 4
[08:25:48.832]  $ ...future.seeds_ii       : NULL
[08:25:48.832]  $ ...future.globals.maxSize: NULL
[08:25:48.832]  - attr(*, "where")=List of 5
[08:25:48.832]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.832]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.832]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.832]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.832]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.832]  - attr(*, "resolved")= logi FALSE
[08:25:48.832]  - attr(*, "total_size")= num 847
[08:25:48.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.832]  - attr(*, "already-done")= logi TRUE
[08:25:48.848] - reassign environment for ‘...future.FUN’
[08:25:48.848] - copied ‘...future.FUN’ to environment
[08:25:48.848] - copied ‘MoreArgs’ to environment
[08:25:48.849] - copied ‘...future.elements_ii’ to environment
[08:25:48.849] - copied ‘...future.seeds_ii’ to environment
[08:25:48.849] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.849] assign_globals() ... done
[08:25:48.849] requestCore(): workers = 2
[08:25:48.852] MulticoreFuture started
[08:25:48.853] - Launch lazy future ... done
[08:25:48.853] plan(): Setting new future strategy stack:
[08:25:48.853] run() for ‘MulticoreFuture’ ... done
[08:25:48.854] Created future:
[08:25:48.854] List of future strategies:
[08:25:48.854] 1. sequential:
[08:25:48.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.854]    - tweaked: FALSE
[08:25:48.854]    - call: NULL
[08:25:48.856] plan(): nbrOfWorkers() = 1
[08:25:48.859] plan(): Setting new future strategy stack:
[08:25:48.860] List of future strategies:
[08:25:48.860] 1. multicore:
[08:25:48.860]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.860]    - tweaked: FALSE
[08:25:48.860]    - call: plan(strategy)
[08:25:48.864] plan(): nbrOfWorkers() = 2
[08:25:48.855] MulticoreFuture:
[08:25:48.855] Label: ‘future_mapply-2’
[08:25:48.855] Expression:
[08:25:48.855] {
[08:25:48.855]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.855]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.855]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.855]         on.exit(options(oopts), add = TRUE)
[08:25:48.855]     }
[08:25:48.855]     {
[08:25:48.855]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.855]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.855]         do.call(mapply, args = args)
[08:25:48.855]     }
[08:25:48.855] }
[08:25:48.855] Lazy evaluation: FALSE
[08:25:48.855] Asynchronous evaluation: TRUE
[08:25:48.855] Local evaluation: TRUE
[08:25:48.855] Environment: R_GlobalEnv
[08:25:48.855] Capture standard output: TRUE
[08:25:48.855] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.855] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.855] Packages: <none>
[08:25:48.855] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.855] Resolved: TRUE
[08:25:48.855] Value: <not collected>
[08:25:48.855] Conditions captured: <none>
[08:25:48.855] Early signaling: FALSE
[08:25:48.855] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.855] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.866] Chunk #2 of 5 ... DONE
[08:25:48.866] Chunk #3 of 5 ...
[08:25:48.866]  - Finding globals in '...' for chunk #3 ...
[08:25:48.866] getGlobalsAndPackages() ...
[08:25:48.867] Searching for globals...
[08:25:48.868] 
[08:25:48.868] Searching for globals ... DONE
[08:25:48.868] - globals: [0] <none>
[08:25:48.868] getGlobalsAndPackages() ... DONE
[08:25:48.868]    + additional globals found: [n=0] 
[08:25:48.869]    + additional namespaces needed: [n=0] 
[08:25:48.869]  - Finding globals in '...' for chunk #3 ... DONE
[08:25:48.869]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:48.869]  - seeds: <none>
[08:25:48.869]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.870] getGlobalsAndPackages() ...
[08:25:48.870] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.870] Resolving globals: FALSE
[08:25:48.871] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:48.872] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.873] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.873] 
[08:25:48.873] getGlobalsAndPackages() ... DONE
[08:25:48.874] run() for ‘Future’ ...
[08:25:48.874] - state: ‘created’
[08:25:48.874] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.877] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.877] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.877]   - Field: ‘label’
[08:25:48.877]   - Field: ‘local’
[08:25:48.877]   - Field: ‘owner’
[08:25:48.878]   - Field: ‘envir’
[08:25:48.878]   - Field: ‘workers’
[08:25:48.878]   - Field: ‘packages’
[08:25:48.878]   - Field: ‘gc’
[08:25:48.878]   - Field: ‘job’
[08:25:48.878]   - Field: ‘conditions’
[08:25:48.879]   - Field: ‘expr’
[08:25:48.879]   - Field: ‘uuid’
[08:25:48.879]   - Field: ‘seed’
[08:25:48.879]   - Field: ‘version’
[08:25:48.879]   - Field: ‘result’
[08:25:48.879]   - Field: ‘asynchronous’
[08:25:48.879]   - Field: ‘calls’
[08:25:48.879]   - Field: ‘globals’
[08:25:48.880]   - Field: ‘stdout’
[08:25:48.880]   - Field: ‘earlySignal’
[08:25:48.880]   - Field: ‘lazy’
[08:25:48.880]   - Field: ‘state’
[08:25:48.880] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.880] - Launch lazy future ...
[08:25:48.881] Packages needed by the future expression (n = 0): <none>
[08:25:48.881] Packages needed by future strategies (n = 0): <none>
[08:25:48.881] {
[08:25:48.881]     {
[08:25:48.881]         {
[08:25:48.881]             ...future.startTime <- base::Sys.time()
[08:25:48.881]             {
[08:25:48.881]                 {
[08:25:48.881]                   {
[08:25:48.881]                     {
[08:25:48.881]                       base::local({
[08:25:48.881]                         has_future <- base::requireNamespace("future", 
[08:25:48.881]                           quietly = TRUE)
[08:25:48.881]                         if (has_future) {
[08:25:48.881]                           ns <- base::getNamespace("future")
[08:25:48.881]                           version <- ns[[".package"]][["version"]]
[08:25:48.881]                           if (is.null(version)) 
[08:25:48.881]                             version <- utils::packageVersion("future")
[08:25:48.881]                         }
[08:25:48.881]                         else {
[08:25:48.881]                           version <- NULL
[08:25:48.881]                         }
[08:25:48.881]                         if (!has_future || version < "1.8.0") {
[08:25:48.881]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.881]                             "", base::R.version$version.string), 
[08:25:48.881]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.881]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.881]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.881]                               "release", "version")], collapse = " "), 
[08:25:48.881]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.881]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.881]                             info)
[08:25:48.881]                           info <- base::paste(info, collapse = "; ")
[08:25:48.881]                           if (!has_future) {
[08:25:48.881]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.881]                               info)
[08:25:48.881]                           }
[08:25:48.881]                           else {
[08:25:48.881]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.881]                               info, version)
[08:25:48.881]                           }
[08:25:48.881]                           base::stop(msg)
[08:25:48.881]                         }
[08:25:48.881]                       })
[08:25:48.881]                     }
[08:25:48.881]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.881]                     base::options(mc.cores = 1L)
[08:25:48.881]                   }
[08:25:48.881]                   ...future.strategy.old <- future::plan("list")
[08:25:48.881]                   options(future.plan = NULL)
[08:25:48.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.881]                 }
[08:25:48.881]                 ...future.workdir <- getwd()
[08:25:48.881]             }
[08:25:48.881]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.881]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.881]         }
[08:25:48.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.881]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:48.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.881]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.881]             base::names(...future.oldOptions))
[08:25:48.881]     }
[08:25:48.881]     if (FALSE) {
[08:25:48.881]     }
[08:25:48.881]     else {
[08:25:48.881]         if (TRUE) {
[08:25:48.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.881]                 open = "w")
[08:25:48.881]         }
[08:25:48.881]         else {
[08:25:48.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.881]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.881]         }
[08:25:48.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.881]             base::sink(type = "output", split = FALSE)
[08:25:48.881]             base::close(...future.stdout)
[08:25:48.881]         }, add = TRUE)
[08:25:48.881]     }
[08:25:48.881]     ...future.frame <- base::sys.nframe()
[08:25:48.881]     ...future.conditions <- base::list()
[08:25:48.881]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.881]     if (FALSE) {
[08:25:48.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.881]     }
[08:25:48.881]     ...future.result <- base::tryCatch({
[08:25:48.881]         base::withCallingHandlers({
[08:25:48.881]             ...future.value <- base::withVisible(base::local({
[08:25:48.881]                 withCallingHandlers({
[08:25:48.881]                   {
[08:25:48.881]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.881]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.881]                       ...future.globals.maxSize)) {
[08:25:48.881]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.881]                       on.exit(options(oopts), add = TRUE)
[08:25:48.881]                     }
[08:25:48.881]                     {
[08:25:48.881]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.881]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.881]                         USE.NAMES = FALSE)
[08:25:48.881]                       do.call(mapply, args = args)
[08:25:48.881]                     }
[08:25:48.881]                   }
[08:25:48.881]                 }, immediateCondition = function(cond) {
[08:25:48.881]                   save_rds <- function (object, pathname, ...) 
[08:25:48.881]                   {
[08:25:48.881]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.881]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.881]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.881]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.881]                         fi_tmp[["mtime"]])
[08:25:48.881]                     }
[08:25:48.881]                     tryCatch({
[08:25:48.881]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.881]                     }, error = function(ex) {
[08:25:48.881]                       msg <- conditionMessage(ex)
[08:25:48.881]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.881]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.881]                         fi_tmp[["mtime"]], msg)
[08:25:48.881]                       ex$message <- msg
[08:25:48.881]                       stop(ex)
[08:25:48.881]                     })
[08:25:48.881]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.881]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.881]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.881]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.881]                       fi <- file.info(pathname)
[08:25:48.881]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.881]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.881]                         fi[["size"]], fi[["mtime"]])
[08:25:48.881]                       stop(msg)
[08:25:48.881]                     }
[08:25:48.881]                     invisible(pathname)
[08:25:48.881]                   }
[08:25:48.881]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.881]                     rootPath = tempdir()) 
[08:25:48.881]                   {
[08:25:48.881]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.881]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.881]                       tmpdir = path, fileext = ".rds")
[08:25:48.881]                     save_rds(obj, file)
[08:25:48.881]                   }
[08:25:48.881]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.881]                   {
[08:25:48.881]                     inherits <- base::inherits
[08:25:48.881]                     invokeRestart <- base::invokeRestart
[08:25:48.881]                     is.null <- base::is.null
[08:25:48.881]                     muffled <- FALSE
[08:25:48.881]                     if (inherits(cond, "message")) {
[08:25:48.881]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.881]                       if (muffled) 
[08:25:48.881]                         invokeRestart("muffleMessage")
[08:25:48.881]                     }
[08:25:48.881]                     else if (inherits(cond, "warning")) {
[08:25:48.881]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.881]                       if (muffled) 
[08:25:48.881]                         invokeRestart("muffleWarning")
[08:25:48.881]                     }
[08:25:48.881]                     else if (inherits(cond, "condition")) {
[08:25:48.881]                       if (!is.null(pattern)) {
[08:25:48.881]                         computeRestarts <- base::computeRestarts
[08:25:48.881]                         grepl <- base::grepl
[08:25:48.881]                         restarts <- computeRestarts(cond)
[08:25:48.881]                         for (restart in restarts) {
[08:25:48.881]                           name <- restart$name
[08:25:48.881]                           if (is.null(name)) 
[08:25:48.881]                             next
[08:25:48.881]                           if (!grepl(pattern, name)) 
[08:25:48.881]                             next
[08:25:48.881]                           invokeRestart(restart)
[08:25:48.881]                           muffled <- TRUE
[08:25:48.881]                           break
[08:25:48.881]                         }
[08:25:48.881]                       }
[08:25:48.881]                     }
[08:25:48.881]                     invisible(muffled)
[08:25:48.881]                   }
[08:25:48.881]                   muffleCondition(cond)
[08:25:48.881]                 })
[08:25:48.881]             }))
[08:25:48.881]             future::FutureResult(value = ...future.value$value, 
[08:25:48.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.881]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.881]                     ...future.globalenv.names))
[08:25:48.881]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.881]         }, condition = base::local({
[08:25:48.881]             c <- base::c
[08:25:48.881]             inherits <- base::inherits
[08:25:48.881]             invokeRestart <- base::invokeRestart
[08:25:48.881]             length <- base::length
[08:25:48.881]             list <- base::list
[08:25:48.881]             seq.int <- base::seq.int
[08:25:48.881]             signalCondition <- base::signalCondition
[08:25:48.881]             sys.calls <- base::sys.calls
[08:25:48.881]             `[[` <- base::`[[`
[08:25:48.881]             `+` <- base::`+`
[08:25:48.881]             `<<-` <- base::`<<-`
[08:25:48.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.881]                   3L)]
[08:25:48.881]             }
[08:25:48.881]             function(cond) {
[08:25:48.881]                 is_error <- inherits(cond, "error")
[08:25:48.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.881]                   NULL)
[08:25:48.881]                 if (is_error) {
[08:25:48.881]                   sessionInformation <- function() {
[08:25:48.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.881]                       search = base::search(), system = base::Sys.info())
[08:25:48.881]                   }
[08:25:48.881]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.881]                     cond$call), session = sessionInformation(), 
[08:25:48.881]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.881]                   signalCondition(cond)
[08:25:48.881]                 }
[08:25:48.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.881]                 "immediateCondition"))) {
[08:25:48.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.881]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.881]                   if (TRUE && !signal) {
[08:25:48.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.881]                     {
[08:25:48.881]                       inherits <- base::inherits
[08:25:48.881]                       invokeRestart <- base::invokeRestart
[08:25:48.881]                       is.null <- base::is.null
[08:25:48.881]                       muffled <- FALSE
[08:25:48.881]                       if (inherits(cond, "message")) {
[08:25:48.881]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.881]                         if (muffled) 
[08:25:48.881]                           invokeRestart("muffleMessage")
[08:25:48.881]                       }
[08:25:48.881]                       else if (inherits(cond, "warning")) {
[08:25:48.881]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.881]                         if (muffled) 
[08:25:48.881]                           invokeRestart("muffleWarning")
[08:25:48.881]                       }
[08:25:48.881]                       else if (inherits(cond, "condition")) {
[08:25:48.881]                         if (!is.null(pattern)) {
[08:25:48.881]                           computeRestarts <- base::computeRestarts
[08:25:48.881]                           grepl <- base::grepl
[08:25:48.881]                           restarts <- computeRestarts(cond)
[08:25:48.881]                           for (restart in restarts) {
[08:25:48.881]                             name <- restart$name
[08:25:48.881]                             if (is.null(name)) 
[08:25:48.881]                               next
[08:25:48.881]                             if (!grepl(pattern, name)) 
[08:25:48.881]                               next
[08:25:48.881]                             invokeRestart(restart)
[08:25:48.881]                             muffled <- TRUE
[08:25:48.881]                             break
[08:25:48.881]                           }
[08:25:48.881]                         }
[08:25:48.881]                       }
[08:25:48.881]                       invisible(muffled)
[08:25:48.881]                     }
[08:25:48.881]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.881]                   }
[08:25:48.881]                 }
[08:25:48.881]                 else {
[08:25:48.881]                   if (TRUE) {
[08:25:48.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.881]                     {
[08:25:48.881]                       inherits <- base::inherits
[08:25:48.881]                       invokeRestart <- base::invokeRestart
[08:25:48.881]                       is.null <- base::is.null
[08:25:48.881]                       muffled <- FALSE
[08:25:48.881]                       if (inherits(cond, "message")) {
[08:25:48.881]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.881]                         if (muffled) 
[08:25:48.881]                           invokeRestart("muffleMessage")
[08:25:48.881]                       }
[08:25:48.881]                       else if (inherits(cond, "warning")) {
[08:25:48.881]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.881]                         if (muffled) 
[08:25:48.881]                           invokeRestart("muffleWarning")
[08:25:48.881]                       }
[08:25:48.881]                       else if (inherits(cond, "condition")) {
[08:25:48.881]                         if (!is.null(pattern)) {
[08:25:48.881]                           computeRestarts <- base::computeRestarts
[08:25:48.881]                           grepl <- base::grepl
[08:25:48.881]                           restarts <- computeRestarts(cond)
[08:25:48.881]                           for (restart in restarts) {
[08:25:48.881]                             name <- restart$name
[08:25:48.881]                             if (is.null(name)) 
[08:25:48.881]                               next
[08:25:48.881]                             if (!grepl(pattern, name)) 
[08:25:48.881]                               next
[08:25:48.881]                             invokeRestart(restart)
[08:25:48.881]                             muffled <- TRUE
[08:25:48.881]                             break
[08:25:48.881]                           }
[08:25:48.881]                         }
[08:25:48.881]                       }
[08:25:48.881]                       invisible(muffled)
[08:25:48.881]                     }
[08:25:48.881]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.881]                   }
[08:25:48.881]                 }
[08:25:48.881]             }
[08:25:48.881]         }))
[08:25:48.881]     }, error = function(ex) {
[08:25:48.881]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.881]                 ...future.rng), started = ...future.startTime, 
[08:25:48.881]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.881]             version = "1.8"), class = "FutureResult")
[08:25:48.881]     }, finally = {
[08:25:48.881]         if (!identical(...future.workdir, getwd())) 
[08:25:48.881]             setwd(...future.workdir)
[08:25:48.881]         {
[08:25:48.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.881]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.881]             }
[08:25:48.881]             base::options(...future.oldOptions)
[08:25:48.881]             if (.Platform$OS.type == "windows") {
[08:25:48.881]                 old_names <- names(...future.oldEnvVars)
[08:25:48.881]                 envs <- base::Sys.getenv()
[08:25:48.881]                 names <- names(envs)
[08:25:48.881]                 common <- intersect(names, old_names)
[08:25:48.881]                 added <- setdiff(names, old_names)
[08:25:48.881]                 removed <- setdiff(old_names, names)
[08:25:48.881]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.881]                   envs[common]]
[08:25:48.881]                 NAMES <- toupper(changed)
[08:25:48.881]                 args <- list()
[08:25:48.881]                 for (kk in seq_along(NAMES)) {
[08:25:48.881]                   name <- changed[[kk]]
[08:25:48.881]                   NAME <- NAMES[[kk]]
[08:25:48.881]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.881]                     next
[08:25:48.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.881]                 }
[08:25:48.881]                 NAMES <- toupper(added)
[08:25:48.881]                 for (kk in seq_along(NAMES)) {
[08:25:48.881]                   name <- added[[kk]]
[08:25:48.881]                   NAME <- NAMES[[kk]]
[08:25:48.881]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.881]                     next
[08:25:48.881]                   args[[name]] <- ""
[08:25:48.881]                 }
[08:25:48.881]                 NAMES <- toupper(removed)
[08:25:48.881]                 for (kk in seq_along(NAMES)) {
[08:25:48.881]                   name <- removed[[kk]]
[08:25:48.881]                   NAME <- NAMES[[kk]]
[08:25:48.881]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.881]                     next
[08:25:48.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.881]                 }
[08:25:48.881]                 if (length(args) > 0) 
[08:25:48.881]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.881]             }
[08:25:48.881]             else {
[08:25:48.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.881]             }
[08:25:48.881]             {
[08:25:48.881]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.881]                   0L) {
[08:25:48.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.881]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.881]                   base::options(opts)
[08:25:48.881]                 }
[08:25:48.881]                 {
[08:25:48.881]                   {
[08:25:48.881]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.881]                     NULL
[08:25:48.881]                   }
[08:25:48.881]                   options(future.plan = NULL)
[08:25:48.881]                   if (is.na(NA_character_)) 
[08:25:48.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.881]                     .init = FALSE)
[08:25:48.881]                 }
[08:25:48.881]             }
[08:25:48.881]         }
[08:25:48.881]     })
[08:25:48.881]     if (TRUE) {
[08:25:48.881]         base::sink(type = "output", split = FALSE)
[08:25:48.881]         if (TRUE) {
[08:25:48.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.881]         }
[08:25:48.881]         else {
[08:25:48.881]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.881]         }
[08:25:48.881]         base::close(...future.stdout)
[08:25:48.881]         ...future.stdout <- NULL
[08:25:48.881]     }
[08:25:48.881]     ...future.result$conditions <- ...future.conditions
[08:25:48.881]     ...future.result$finished <- base::Sys.time()
[08:25:48.881]     ...future.result
[08:25:48.881] }
[08:25:48.885] assign_globals() ...
[08:25:48.885] List of 5
[08:25:48.885]  $ ...future.FUN            :function (C, k)  
[08:25:48.885]  $ MoreArgs                 : NULL
[08:25:48.885]  $ ...future.elements_ii    :List of 2
[08:25:48.885]   ..$ :List of 1
[08:25:48.885]   .. ..$ : chr "C"
[08:25:48.885]   ..$ :List of 1
[08:25:48.885]   .. ..$ : int 3
[08:25:48.885]  $ ...future.seeds_ii       : NULL
[08:25:48.885]  $ ...future.globals.maxSize: NULL
[08:25:48.885]  - attr(*, "where")=List of 5
[08:25:48.885]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.885]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.885]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.885]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.885]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.885]  - attr(*, "resolved")= logi FALSE
[08:25:48.885]  - attr(*, "total_size")= num 847
[08:25:48.885]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.885]  - attr(*, "already-done")= logi TRUE
[08:25:48.892] - reassign environment for ‘...future.FUN’
[08:25:48.892] - copied ‘...future.FUN’ to environment
[08:25:48.892] - copied ‘MoreArgs’ to environment
[08:25:48.892] - copied ‘...future.elements_ii’ to environment
[08:25:48.892] - copied ‘...future.seeds_ii’ to environment
[08:25:48.892] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.892] assign_globals() ... done
[08:25:48.893] requestCore(): workers = 2
[08:25:48.893] Poll #1 (0): usedCores() = 2, workers = 2
[08:25:48.904] result() for MulticoreFuture ...
[08:25:48.905] result() for MulticoreFuture ...
[08:25:48.905] result() for MulticoreFuture ... done
[08:25:48.905] result() for MulticoreFuture ... done
[08:25:48.905] result() for MulticoreFuture ...
[08:25:48.905] result() for MulticoreFuture ... done
[08:25:48.908] MulticoreFuture started
[08:25:48.908] - Launch lazy future ... done
[08:25:48.909] run() for ‘MulticoreFuture’ ... done
[08:25:48.909] Created future:
[08:25:48.909] plan(): Setting new future strategy stack:
[08:25:48.910] List of future strategies:
[08:25:48.910] 1. sequential:
[08:25:48.910]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.910]    - tweaked: FALSE
[08:25:48.910]    - call: NULL
[08:25:48.911] plan(): nbrOfWorkers() = 1
[08:25:48.913] plan(): Setting new future strategy stack:
[08:25:48.913] List of future strategies:
[08:25:48.913] 1. multicore:
[08:25:48.913]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.913]    - tweaked: FALSE
[08:25:48.913]    - call: plan(strategy)
[08:25:48.909] MulticoreFuture:
[08:25:48.909] Label: ‘future_mapply-3’
[08:25:48.909] Expression:
[08:25:48.909] {
[08:25:48.909]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.909]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.909]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.909]         on.exit(options(oopts), add = TRUE)
[08:25:48.909]     }
[08:25:48.909]     {
[08:25:48.909]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.909]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.909]         do.call(mapply, args = args)
[08:25:48.909]     }
[08:25:48.909] }
[08:25:48.909] Lazy evaluation: FALSE
[08:25:48.909] Asynchronous evaluation: TRUE
[08:25:48.909] Local evaluation: TRUE
[08:25:48.909] Environment: R_GlobalEnv
[08:25:48.909] Capture standard output: TRUE
[08:25:48.909] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.909] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.909] Packages: <none>
[08:25:48.909] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.909] Resolved: FALSE
[08:25:48.909] Value: <not collected>
[08:25:48.909] Conditions captured: <none>
[08:25:48.909] Early signaling: FALSE
[08:25:48.909] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.909] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.923] Chunk #3 of 5 ... DONE
[08:25:48.923] Chunk #4 of 5 ...
[08:25:48.923]  - Finding globals in '...' for chunk #4 ...
[08:25:48.923] getGlobalsAndPackages() ...
[08:25:48.924] Searching for globals...
[08:25:48.925] plan(): nbrOfWorkers() = 2
[08:25:48.928] 
[08:25:48.928] Searching for globals ... DONE
[08:25:48.929] - globals: [0] <none>
[08:25:48.929] getGlobalsAndPackages() ... DONE
[08:25:48.929]    + additional globals found: [n=0] 
[08:25:48.929]    + additional namespaces needed: [n=0] 
[08:25:48.929]  - Finding globals in '...' for chunk #4 ... DONE
[08:25:48.930]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:48.930]  - seeds: <none>
[08:25:48.930]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.930] getGlobalsAndPackages() ...
[08:25:48.931] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.931] Resolving globals: FALSE
[08:25:48.932] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:48.933] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.933] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.934] 
[08:25:48.934] getGlobalsAndPackages() ... DONE
[08:25:48.934] run() for ‘Future’ ...
[08:25:48.935] - state: ‘created’
[08:25:48.935] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:48.938] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:48.939]   - Field: ‘label’
[08:25:48.939]   - Field: ‘local’
[08:25:48.939]   - Field: ‘owner’
[08:25:48.940]   - Field: ‘envir’
[08:25:48.940]   - Field: ‘workers’
[08:25:48.940]   - Field: ‘packages’
[08:25:48.940]   - Field: ‘gc’
[08:25:48.940]   - Field: ‘job’
[08:25:48.941]   - Field: ‘conditions’
[08:25:48.941]   - Field: ‘expr’
[08:25:48.941]   - Field: ‘uuid’
[08:25:48.941]   - Field: ‘seed’
[08:25:48.941]   - Field: ‘version’
[08:25:48.941]   - Field: ‘result’
[08:25:48.941]   - Field: ‘asynchronous’
[08:25:48.942]   - Field: ‘calls’
[08:25:48.942]   - Field: ‘globals’
[08:25:48.942]   - Field: ‘stdout’
[08:25:48.942]   - Field: ‘earlySignal’
[08:25:48.942]   - Field: ‘lazy’
[08:25:48.942]   - Field: ‘state’
[08:25:48.942] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:48.943] - Launch lazy future ...
[08:25:48.943] Packages needed by the future expression (n = 0): <none>
[08:25:48.943] Packages needed by future strategies (n = 0): <none>
[08:25:48.944] {
[08:25:48.944]     {
[08:25:48.944]         {
[08:25:48.944]             ...future.startTime <- base::Sys.time()
[08:25:48.944]             {
[08:25:48.944]                 {
[08:25:48.944]                   {
[08:25:48.944]                     {
[08:25:48.944]                       base::local({
[08:25:48.944]                         has_future <- base::requireNamespace("future", 
[08:25:48.944]                           quietly = TRUE)
[08:25:48.944]                         if (has_future) {
[08:25:48.944]                           ns <- base::getNamespace("future")
[08:25:48.944]                           version <- ns[[".package"]][["version"]]
[08:25:48.944]                           if (is.null(version)) 
[08:25:48.944]                             version <- utils::packageVersion("future")
[08:25:48.944]                         }
[08:25:48.944]                         else {
[08:25:48.944]                           version <- NULL
[08:25:48.944]                         }
[08:25:48.944]                         if (!has_future || version < "1.8.0") {
[08:25:48.944]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:48.944]                             "", base::R.version$version.string), 
[08:25:48.944]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:48.944]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:48.944]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:48.944]                               "release", "version")], collapse = " "), 
[08:25:48.944]                             hostname = base::Sys.info()[["nodename"]])
[08:25:48.944]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:48.944]                             info)
[08:25:48.944]                           info <- base::paste(info, collapse = "; ")
[08:25:48.944]                           if (!has_future) {
[08:25:48.944]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:48.944]                               info)
[08:25:48.944]                           }
[08:25:48.944]                           else {
[08:25:48.944]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:48.944]                               info, version)
[08:25:48.944]                           }
[08:25:48.944]                           base::stop(msg)
[08:25:48.944]                         }
[08:25:48.944]                       })
[08:25:48.944]                     }
[08:25:48.944]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:48.944]                     base::options(mc.cores = 1L)
[08:25:48.944]                   }
[08:25:48.944]                   ...future.strategy.old <- future::plan("list")
[08:25:48.944]                   options(future.plan = NULL)
[08:25:48.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:48.944]                 }
[08:25:48.944]                 ...future.workdir <- getwd()
[08:25:48.944]             }
[08:25:48.944]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:48.944]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:48.944]         }
[08:25:48.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:48.944]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:48.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:48.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:48.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:48.944]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:48.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:48.944]             base::names(...future.oldOptions))
[08:25:48.944]     }
[08:25:48.944]     if (FALSE) {
[08:25:48.944]     }
[08:25:48.944]     else {
[08:25:48.944]         if (TRUE) {
[08:25:48.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:48.944]                 open = "w")
[08:25:48.944]         }
[08:25:48.944]         else {
[08:25:48.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:48.944]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:48.944]         }
[08:25:48.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:48.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:48.944]             base::sink(type = "output", split = FALSE)
[08:25:48.944]             base::close(...future.stdout)
[08:25:48.944]         }, add = TRUE)
[08:25:48.944]     }
[08:25:48.944]     ...future.frame <- base::sys.nframe()
[08:25:48.944]     ...future.conditions <- base::list()
[08:25:48.944]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:48.944]     if (FALSE) {
[08:25:48.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:48.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:48.944]     }
[08:25:48.944]     ...future.result <- base::tryCatch({
[08:25:48.944]         base::withCallingHandlers({
[08:25:48.944]             ...future.value <- base::withVisible(base::local({
[08:25:48.944]                 withCallingHandlers({
[08:25:48.944]                   {
[08:25:48.944]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.944]                     if (!identical(...future.globals.maxSize.org, 
[08:25:48.944]                       ...future.globals.maxSize)) {
[08:25:48.944]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.944]                       on.exit(options(oopts), add = TRUE)
[08:25:48.944]                     }
[08:25:48.944]                     {
[08:25:48.944]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.944]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:48.944]                         USE.NAMES = FALSE)
[08:25:48.944]                       do.call(mapply, args = args)
[08:25:48.944]                     }
[08:25:48.944]                   }
[08:25:48.944]                 }, immediateCondition = function(cond) {
[08:25:48.944]                   save_rds <- function (object, pathname, ...) 
[08:25:48.944]                   {
[08:25:48.944]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:48.944]                     if (file_test("-f", pathname_tmp)) {
[08:25:48.944]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.944]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:48.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.944]                         fi_tmp[["mtime"]])
[08:25:48.944]                     }
[08:25:48.944]                     tryCatch({
[08:25:48.944]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:48.944]                     }, error = function(ex) {
[08:25:48.944]                       msg <- conditionMessage(ex)
[08:25:48.944]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.944]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:48.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.944]                         fi_tmp[["mtime"]], msg)
[08:25:48.944]                       ex$message <- msg
[08:25:48.944]                       stop(ex)
[08:25:48.944]                     })
[08:25:48.944]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:48.944]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:48.944]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:48.944]                       fi_tmp <- file.info(pathname_tmp)
[08:25:48.944]                       fi <- file.info(pathname)
[08:25:48.944]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:48.944]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:48.944]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:48.944]                         fi[["size"]], fi[["mtime"]])
[08:25:48.944]                       stop(msg)
[08:25:48.944]                     }
[08:25:48.944]                     invisible(pathname)
[08:25:48.944]                   }
[08:25:48.944]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:48.944]                     rootPath = tempdir()) 
[08:25:48.944]                   {
[08:25:48.944]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:48.944]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:48.944]                       tmpdir = path, fileext = ".rds")
[08:25:48.944]                     save_rds(obj, file)
[08:25:48.944]                   }
[08:25:48.944]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:48.944]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.944]                   {
[08:25:48.944]                     inherits <- base::inherits
[08:25:48.944]                     invokeRestart <- base::invokeRestart
[08:25:48.944]                     is.null <- base::is.null
[08:25:48.944]                     muffled <- FALSE
[08:25:48.944]                     if (inherits(cond, "message")) {
[08:25:48.944]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:48.944]                       if (muffled) 
[08:25:48.944]                         invokeRestart("muffleMessage")
[08:25:48.944]                     }
[08:25:48.944]                     else if (inherits(cond, "warning")) {
[08:25:48.944]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:48.944]                       if (muffled) 
[08:25:48.944]                         invokeRestart("muffleWarning")
[08:25:48.944]                     }
[08:25:48.944]                     else if (inherits(cond, "condition")) {
[08:25:48.944]                       if (!is.null(pattern)) {
[08:25:48.944]                         computeRestarts <- base::computeRestarts
[08:25:48.944]                         grepl <- base::grepl
[08:25:48.944]                         restarts <- computeRestarts(cond)
[08:25:48.944]                         for (restart in restarts) {
[08:25:48.944]                           name <- restart$name
[08:25:48.944]                           if (is.null(name)) 
[08:25:48.944]                             next
[08:25:48.944]                           if (!grepl(pattern, name)) 
[08:25:48.944]                             next
[08:25:48.944]                           invokeRestart(restart)
[08:25:48.944]                           muffled <- TRUE
[08:25:48.944]                           break
[08:25:48.944]                         }
[08:25:48.944]                       }
[08:25:48.944]                     }
[08:25:48.944]                     invisible(muffled)
[08:25:48.944]                   }
[08:25:48.944]                   muffleCondition(cond)
[08:25:48.944]                 })
[08:25:48.944]             }))
[08:25:48.944]             future::FutureResult(value = ...future.value$value, 
[08:25:48.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.944]                   ...future.rng), globalenv = if (FALSE) 
[08:25:48.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:48.944]                     ...future.globalenv.names))
[08:25:48.944]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:48.944]         }, condition = base::local({
[08:25:48.944]             c <- base::c
[08:25:48.944]             inherits <- base::inherits
[08:25:48.944]             invokeRestart <- base::invokeRestart
[08:25:48.944]             length <- base::length
[08:25:48.944]             list <- base::list
[08:25:48.944]             seq.int <- base::seq.int
[08:25:48.944]             signalCondition <- base::signalCondition
[08:25:48.944]             sys.calls <- base::sys.calls
[08:25:48.944]             `[[` <- base::`[[`
[08:25:48.944]             `+` <- base::`+`
[08:25:48.944]             `<<-` <- base::`<<-`
[08:25:48.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:48.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:48.944]                   3L)]
[08:25:48.944]             }
[08:25:48.944]             function(cond) {
[08:25:48.944]                 is_error <- inherits(cond, "error")
[08:25:48.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:48.944]                   NULL)
[08:25:48.944]                 if (is_error) {
[08:25:48.944]                   sessionInformation <- function() {
[08:25:48.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:48.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:48.944]                       search = base::search(), system = base::Sys.info())
[08:25:48.944]                   }
[08:25:48.944]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:48.944]                     cond$call), session = sessionInformation(), 
[08:25:48.944]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:48.944]                   signalCondition(cond)
[08:25:48.944]                 }
[08:25:48.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:48.944]                 "immediateCondition"))) {
[08:25:48.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:48.944]                   ...future.conditions[[length(...future.conditions) + 
[08:25:48.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:48.944]                   if (TRUE && !signal) {
[08:25:48.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.944]                     {
[08:25:48.944]                       inherits <- base::inherits
[08:25:48.944]                       invokeRestart <- base::invokeRestart
[08:25:48.944]                       is.null <- base::is.null
[08:25:48.944]                       muffled <- FALSE
[08:25:48.944]                       if (inherits(cond, "message")) {
[08:25:48.944]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.944]                         if (muffled) 
[08:25:48.944]                           invokeRestart("muffleMessage")
[08:25:48.944]                       }
[08:25:48.944]                       else if (inherits(cond, "warning")) {
[08:25:48.944]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.944]                         if (muffled) 
[08:25:48.944]                           invokeRestart("muffleWarning")
[08:25:48.944]                       }
[08:25:48.944]                       else if (inherits(cond, "condition")) {
[08:25:48.944]                         if (!is.null(pattern)) {
[08:25:48.944]                           computeRestarts <- base::computeRestarts
[08:25:48.944]                           grepl <- base::grepl
[08:25:48.944]                           restarts <- computeRestarts(cond)
[08:25:48.944]                           for (restart in restarts) {
[08:25:48.944]                             name <- restart$name
[08:25:48.944]                             if (is.null(name)) 
[08:25:48.944]                               next
[08:25:48.944]                             if (!grepl(pattern, name)) 
[08:25:48.944]                               next
[08:25:48.944]                             invokeRestart(restart)
[08:25:48.944]                             muffled <- TRUE
[08:25:48.944]                             break
[08:25:48.944]                           }
[08:25:48.944]                         }
[08:25:48.944]                       }
[08:25:48.944]                       invisible(muffled)
[08:25:48.944]                     }
[08:25:48.944]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.944]                   }
[08:25:48.944]                 }
[08:25:48.944]                 else {
[08:25:48.944]                   if (TRUE) {
[08:25:48.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:48.944]                     {
[08:25:48.944]                       inherits <- base::inherits
[08:25:48.944]                       invokeRestart <- base::invokeRestart
[08:25:48.944]                       is.null <- base::is.null
[08:25:48.944]                       muffled <- FALSE
[08:25:48.944]                       if (inherits(cond, "message")) {
[08:25:48.944]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:48.944]                         if (muffled) 
[08:25:48.944]                           invokeRestart("muffleMessage")
[08:25:48.944]                       }
[08:25:48.944]                       else if (inherits(cond, "warning")) {
[08:25:48.944]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:48.944]                         if (muffled) 
[08:25:48.944]                           invokeRestart("muffleWarning")
[08:25:48.944]                       }
[08:25:48.944]                       else if (inherits(cond, "condition")) {
[08:25:48.944]                         if (!is.null(pattern)) {
[08:25:48.944]                           computeRestarts <- base::computeRestarts
[08:25:48.944]                           grepl <- base::grepl
[08:25:48.944]                           restarts <- computeRestarts(cond)
[08:25:48.944]                           for (restart in restarts) {
[08:25:48.944]                             name <- restart$name
[08:25:48.944]                             if (is.null(name)) 
[08:25:48.944]                               next
[08:25:48.944]                             if (!grepl(pattern, name)) 
[08:25:48.944]                               next
[08:25:48.944]                             invokeRestart(restart)
[08:25:48.944]                             muffled <- TRUE
[08:25:48.944]                             break
[08:25:48.944]                           }
[08:25:48.944]                         }
[08:25:48.944]                       }
[08:25:48.944]                       invisible(muffled)
[08:25:48.944]                     }
[08:25:48.944]                     muffleCondition(cond, pattern = "^muffle")
[08:25:48.944]                   }
[08:25:48.944]                 }
[08:25:48.944]             }
[08:25:48.944]         }))
[08:25:48.944]     }, error = function(ex) {
[08:25:48.944]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:48.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:48.944]                 ...future.rng), started = ...future.startTime, 
[08:25:48.944]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:48.944]             version = "1.8"), class = "FutureResult")
[08:25:48.944]     }, finally = {
[08:25:48.944]         if (!identical(...future.workdir, getwd())) 
[08:25:48.944]             setwd(...future.workdir)
[08:25:48.944]         {
[08:25:48.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:48.944]                 ...future.oldOptions$nwarnings <- NULL
[08:25:48.944]             }
[08:25:48.944]             base::options(...future.oldOptions)
[08:25:48.944]             if (.Platform$OS.type == "windows") {
[08:25:48.944]                 old_names <- names(...future.oldEnvVars)
[08:25:48.944]                 envs <- base::Sys.getenv()
[08:25:48.944]                 names <- names(envs)
[08:25:48.944]                 common <- intersect(names, old_names)
[08:25:48.944]                 added <- setdiff(names, old_names)
[08:25:48.944]                 removed <- setdiff(old_names, names)
[08:25:48.944]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:48.944]                   envs[common]]
[08:25:48.944]                 NAMES <- toupper(changed)
[08:25:48.944]                 args <- list()
[08:25:48.944]                 for (kk in seq_along(NAMES)) {
[08:25:48.944]                   name <- changed[[kk]]
[08:25:48.944]                   NAME <- NAMES[[kk]]
[08:25:48.944]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.944]                     next
[08:25:48.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.944]                 }
[08:25:48.944]                 NAMES <- toupper(added)
[08:25:48.944]                 for (kk in seq_along(NAMES)) {
[08:25:48.944]                   name <- added[[kk]]
[08:25:48.944]                   NAME <- NAMES[[kk]]
[08:25:48.944]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.944]                     next
[08:25:48.944]                   args[[name]] <- ""
[08:25:48.944]                 }
[08:25:48.944]                 NAMES <- toupper(removed)
[08:25:48.944]                 for (kk in seq_along(NAMES)) {
[08:25:48.944]                   name <- removed[[kk]]
[08:25:48.944]                   NAME <- NAMES[[kk]]
[08:25:48.944]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:48.944]                     next
[08:25:48.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:48.944]                 }
[08:25:48.944]                 if (length(args) > 0) 
[08:25:48.944]                   base::do.call(base::Sys.setenv, args = args)
[08:25:48.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:48.944]             }
[08:25:48.944]             else {
[08:25:48.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:48.944]             }
[08:25:48.944]             {
[08:25:48.944]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:48.944]                   0L) {
[08:25:48.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:48.944]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:48.944]                   base::options(opts)
[08:25:48.944]                 }
[08:25:48.944]                 {
[08:25:48.944]                   {
[08:25:48.944]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:48.944]                     NULL
[08:25:48.944]                   }
[08:25:48.944]                   options(future.plan = NULL)
[08:25:48.944]                   if (is.na(NA_character_)) 
[08:25:48.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:48.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:48.944]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:48.944]                     .init = FALSE)
[08:25:48.944]                 }
[08:25:48.944]             }
[08:25:48.944]         }
[08:25:48.944]     })
[08:25:48.944]     if (TRUE) {
[08:25:48.944]         base::sink(type = "output", split = FALSE)
[08:25:48.944]         if (TRUE) {
[08:25:48.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:48.944]         }
[08:25:48.944]         else {
[08:25:48.944]             ...future.result["stdout"] <- base::list(NULL)
[08:25:48.944]         }
[08:25:48.944]         base::close(...future.stdout)
[08:25:48.944]         ...future.stdout <- NULL
[08:25:48.944]     }
[08:25:48.944]     ...future.result$conditions <- ...future.conditions
[08:25:48.944]     ...future.result$finished <- base::Sys.time()
[08:25:48.944]     ...future.result
[08:25:48.944] }
[08:25:48.947] assign_globals() ...
[08:25:48.947] List of 5
[08:25:48.947]  $ ...future.FUN            :function (C, k)  
[08:25:48.947]  $ MoreArgs                 : NULL
[08:25:48.947]  $ ...future.elements_ii    :List of 2
[08:25:48.947]   ..$ :List of 1
[08:25:48.947]   .. ..$ : chr "D"
[08:25:48.947]   ..$ :List of 1
[08:25:48.947]   .. ..$ : int 2
[08:25:48.947]  $ ...future.seeds_ii       : NULL
[08:25:48.947]  $ ...future.globals.maxSize: NULL
[08:25:48.947]  - attr(*, "where")=List of 5
[08:25:48.947]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:48.947]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:48.947]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:48.947]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:48.947]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:48.947]  - attr(*, "resolved")= logi FALSE
[08:25:48.947]  - attr(*, "total_size")= num 847
[08:25:48.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:48.947]  - attr(*, "already-done")= logi TRUE
[08:25:48.953] - reassign environment for ‘...future.FUN’
[08:25:48.953] - copied ‘...future.FUN’ to environment
[08:25:48.953] - copied ‘MoreArgs’ to environment
[08:25:48.954] - copied ‘...future.elements_ii’ to environment
[08:25:48.954] - copied ‘...future.seeds_ii’ to environment
[08:25:48.954] - copied ‘...future.globals.maxSize’ to environment
[08:25:48.954] assign_globals() ... done
[08:25:48.954] requestCore(): workers = 2
[08:25:48.954] Poll #1 (0): usedCores() = 2, workers = 2
[08:25:48.978] result() for MulticoreFuture ...
[08:25:48.979] result() for MulticoreFuture ...
[08:25:48.979] result() for MulticoreFuture ... done
[08:25:48.979] result() for MulticoreFuture ... done
[08:25:48.979] result() for MulticoreFuture ...
[08:25:48.979] result() for MulticoreFuture ... done
[08:25:48.982] MulticoreFuture started
[08:25:48.983] - Launch lazy future ... done
[08:25:48.983] run() for ‘MulticoreFuture’ ... done
[08:25:48.983] plan(): Setting new future strategy stack:
[08:25:48.984] Created future:
[08:25:48.984] List of future strategies:
[08:25:48.984] 1. sequential:
[08:25:48.984]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:48.984]    - tweaked: FALSE
[08:25:48.984]    - call: NULL
[08:25:48.986] plan(): nbrOfWorkers() = 1
[08:25:48.988] plan(): Setting new future strategy stack:
[08:25:48.989] List of future strategies:
[08:25:48.989] 1. multicore:
[08:25:48.989]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:48.989]    - tweaked: FALSE
[08:25:48.989]    - call: plan(strategy)
[08:25:48.993] plan(): nbrOfWorkers() = 2
[08:25:48.984] MulticoreFuture:
[08:25:48.984] Label: ‘future_mapply-4’
[08:25:48.984] Expression:
[08:25:48.984] {
[08:25:48.984]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:48.984]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:48.984]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:48.984]         on.exit(options(oopts), add = TRUE)
[08:25:48.984]     }
[08:25:48.984]     {
[08:25:48.984]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:48.984]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:48.984]         do.call(mapply, args = args)
[08:25:48.984]     }
[08:25:48.984] }
[08:25:48.984] Lazy evaluation: FALSE
[08:25:48.984] Asynchronous evaluation: TRUE
[08:25:48.984] Local evaluation: TRUE
[08:25:48.984] Environment: R_GlobalEnv
[08:25:48.984] Capture standard output: TRUE
[08:25:48.984] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:48.984] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:48.984] Packages: <none>
[08:25:48.984] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:48.984] Resolved: TRUE
[08:25:48.984] Value: <not collected>
[08:25:48.984] Conditions captured: <none>
[08:25:48.984] Early signaling: FALSE
[08:25:48.984] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:48.984] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:48.994] Chunk #4 of 5 ... DONE
[08:25:48.994] Chunk #5 of 5 ...
[08:25:48.994]  - Finding globals in '...' for chunk #5 ...
[08:25:48.994] getGlobalsAndPackages() ...
[08:25:48.994] Searching for globals...
[08:25:48.995] 
[08:25:48.995] Searching for globals ... DONE
[08:25:48.995] - globals: [0] <none>
[08:25:48.995] getGlobalsAndPackages() ... DONE
[08:25:48.996]    + additional globals found: [n=0] 
[08:25:48.996]    + additional namespaces needed: [n=0] 
[08:25:48.996]  - Finding globals in '...' for chunk #5 ... DONE
[08:25:48.996]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:48.996]  - seeds: <none>
[08:25:48.996]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.997] getGlobalsAndPackages() ...
[08:25:48.997] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.997] Resolving globals: FALSE
[08:25:48.998] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:48.999] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:48.999] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:48.999] 
[08:25:48.999] getGlobalsAndPackages() ... DONE
[08:25:49.000] run() for ‘Future’ ...
[08:25:49.000] - state: ‘created’
[08:25:49.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.003]   - Field: ‘label’
[08:25:49.003]   - Field: ‘local’
[08:25:49.003]   - Field: ‘owner’
[08:25:49.003]   - Field: ‘envir’
[08:25:49.003]   - Field: ‘workers’
[08:25:49.004]   - Field: ‘packages’
[08:25:49.004]   - Field: ‘gc’
[08:25:49.004]   - Field: ‘job’
[08:25:49.004]   - Field: ‘conditions’
[08:25:49.004]   - Field: ‘expr’
[08:25:49.004]   - Field: ‘uuid’
[08:25:49.004]   - Field: ‘seed’
[08:25:49.004]   - Field: ‘version’
[08:25:49.005]   - Field: ‘result’
[08:25:49.005]   - Field: ‘asynchronous’
[08:25:49.005]   - Field: ‘calls’
[08:25:49.005]   - Field: ‘globals’
[08:25:49.005]   - Field: ‘stdout’
[08:25:49.005]   - Field: ‘earlySignal’
[08:25:49.005]   - Field: ‘lazy’
[08:25:49.006]   - Field: ‘state’
[08:25:49.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.006] - Launch lazy future ...
[08:25:49.006] Packages needed by the future expression (n = 0): <none>
[08:25:49.007] Packages needed by future strategies (n = 0): <none>
[08:25:49.007] {
[08:25:49.007]     {
[08:25:49.007]         {
[08:25:49.007]             ...future.startTime <- base::Sys.time()
[08:25:49.007]             {
[08:25:49.007]                 {
[08:25:49.007]                   {
[08:25:49.007]                     {
[08:25:49.007]                       base::local({
[08:25:49.007]                         has_future <- base::requireNamespace("future", 
[08:25:49.007]                           quietly = TRUE)
[08:25:49.007]                         if (has_future) {
[08:25:49.007]                           ns <- base::getNamespace("future")
[08:25:49.007]                           version <- ns[[".package"]][["version"]]
[08:25:49.007]                           if (is.null(version)) 
[08:25:49.007]                             version <- utils::packageVersion("future")
[08:25:49.007]                         }
[08:25:49.007]                         else {
[08:25:49.007]                           version <- NULL
[08:25:49.007]                         }
[08:25:49.007]                         if (!has_future || version < "1.8.0") {
[08:25:49.007]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.007]                             "", base::R.version$version.string), 
[08:25:49.007]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.007]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.007]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.007]                               "release", "version")], collapse = " "), 
[08:25:49.007]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.007]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.007]                             info)
[08:25:49.007]                           info <- base::paste(info, collapse = "; ")
[08:25:49.007]                           if (!has_future) {
[08:25:49.007]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.007]                               info)
[08:25:49.007]                           }
[08:25:49.007]                           else {
[08:25:49.007]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.007]                               info, version)
[08:25:49.007]                           }
[08:25:49.007]                           base::stop(msg)
[08:25:49.007]                         }
[08:25:49.007]                       })
[08:25:49.007]                     }
[08:25:49.007]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.007]                     base::options(mc.cores = 1L)
[08:25:49.007]                   }
[08:25:49.007]                   ...future.strategy.old <- future::plan("list")
[08:25:49.007]                   options(future.plan = NULL)
[08:25:49.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.007]                 }
[08:25:49.007]                 ...future.workdir <- getwd()
[08:25:49.007]             }
[08:25:49.007]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.007]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.007]         }
[08:25:49.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.007]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:49.007]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.007]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.007]             base::names(...future.oldOptions))
[08:25:49.007]     }
[08:25:49.007]     if (FALSE) {
[08:25:49.007]     }
[08:25:49.007]     else {
[08:25:49.007]         if (TRUE) {
[08:25:49.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.007]                 open = "w")
[08:25:49.007]         }
[08:25:49.007]         else {
[08:25:49.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.007]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.007]         }
[08:25:49.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.007]             base::sink(type = "output", split = FALSE)
[08:25:49.007]             base::close(...future.stdout)
[08:25:49.007]         }, add = TRUE)
[08:25:49.007]     }
[08:25:49.007]     ...future.frame <- base::sys.nframe()
[08:25:49.007]     ...future.conditions <- base::list()
[08:25:49.007]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.007]     if (FALSE) {
[08:25:49.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.007]     }
[08:25:49.007]     ...future.result <- base::tryCatch({
[08:25:49.007]         base::withCallingHandlers({
[08:25:49.007]             ...future.value <- base::withVisible(base::local({
[08:25:49.007]                 withCallingHandlers({
[08:25:49.007]                   {
[08:25:49.007]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.007]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.007]                       ...future.globals.maxSize)) {
[08:25:49.007]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.007]                       on.exit(options(oopts), add = TRUE)
[08:25:49.007]                     }
[08:25:49.007]                     {
[08:25:49.007]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.007]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.007]                         USE.NAMES = FALSE)
[08:25:49.007]                       do.call(mapply, args = args)
[08:25:49.007]                     }
[08:25:49.007]                   }
[08:25:49.007]                 }, immediateCondition = function(cond) {
[08:25:49.007]                   save_rds <- function (object, pathname, ...) 
[08:25:49.007]                   {
[08:25:49.007]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.007]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.007]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.007]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.007]                         fi_tmp[["mtime"]])
[08:25:49.007]                     }
[08:25:49.007]                     tryCatch({
[08:25:49.007]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.007]                     }, error = function(ex) {
[08:25:49.007]                       msg <- conditionMessage(ex)
[08:25:49.007]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.007]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.007]                         fi_tmp[["mtime"]], msg)
[08:25:49.007]                       ex$message <- msg
[08:25:49.007]                       stop(ex)
[08:25:49.007]                     })
[08:25:49.007]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.007]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.007]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.007]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.007]                       fi <- file.info(pathname)
[08:25:49.007]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.007]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.007]                         fi[["size"]], fi[["mtime"]])
[08:25:49.007]                       stop(msg)
[08:25:49.007]                     }
[08:25:49.007]                     invisible(pathname)
[08:25:49.007]                   }
[08:25:49.007]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.007]                     rootPath = tempdir()) 
[08:25:49.007]                   {
[08:25:49.007]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.007]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.007]                       tmpdir = path, fileext = ".rds")
[08:25:49.007]                     save_rds(obj, file)
[08:25:49.007]                   }
[08:25:49.007]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.007]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.007]                   {
[08:25:49.007]                     inherits <- base::inherits
[08:25:49.007]                     invokeRestart <- base::invokeRestart
[08:25:49.007]                     is.null <- base::is.null
[08:25:49.007]                     muffled <- FALSE
[08:25:49.007]                     if (inherits(cond, "message")) {
[08:25:49.007]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.007]                       if (muffled) 
[08:25:49.007]                         invokeRestart("muffleMessage")
[08:25:49.007]                     }
[08:25:49.007]                     else if (inherits(cond, "warning")) {
[08:25:49.007]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.007]                       if (muffled) 
[08:25:49.007]                         invokeRestart("muffleWarning")
[08:25:49.007]                     }
[08:25:49.007]                     else if (inherits(cond, "condition")) {
[08:25:49.007]                       if (!is.null(pattern)) {
[08:25:49.007]                         computeRestarts <- base::computeRestarts
[08:25:49.007]                         grepl <- base::grepl
[08:25:49.007]                         restarts <- computeRestarts(cond)
[08:25:49.007]                         for (restart in restarts) {
[08:25:49.007]                           name <- restart$name
[08:25:49.007]                           if (is.null(name)) 
[08:25:49.007]                             next
[08:25:49.007]                           if (!grepl(pattern, name)) 
[08:25:49.007]                             next
[08:25:49.007]                           invokeRestart(restart)
[08:25:49.007]                           muffled <- TRUE
[08:25:49.007]                           break
[08:25:49.007]                         }
[08:25:49.007]                       }
[08:25:49.007]                     }
[08:25:49.007]                     invisible(muffled)
[08:25:49.007]                   }
[08:25:49.007]                   muffleCondition(cond)
[08:25:49.007]                 })
[08:25:49.007]             }))
[08:25:49.007]             future::FutureResult(value = ...future.value$value, 
[08:25:49.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.007]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.007]                     ...future.globalenv.names))
[08:25:49.007]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.007]         }, condition = base::local({
[08:25:49.007]             c <- base::c
[08:25:49.007]             inherits <- base::inherits
[08:25:49.007]             invokeRestart <- base::invokeRestart
[08:25:49.007]             length <- base::length
[08:25:49.007]             list <- base::list
[08:25:49.007]             seq.int <- base::seq.int
[08:25:49.007]             signalCondition <- base::signalCondition
[08:25:49.007]             sys.calls <- base::sys.calls
[08:25:49.007]             `[[` <- base::`[[`
[08:25:49.007]             `+` <- base::`+`
[08:25:49.007]             `<<-` <- base::`<<-`
[08:25:49.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.007]                   3L)]
[08:25:49.007]             }
[08:25:49.007]             function(cond) {
[08:25:49.007]                 is_error <- inherits(cond, "error")
[08:25:49.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.007]                   NULL)
[08:25:49.007]                 if (is_error) {
[08:25:49.007]                   sessionInformation <- function() {
[08:25:49.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.007]                       search = base::search(), system = base::Sys.info())
[08:25:49.007]                   }
[08:25:49.007]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.007]                     cond$call), session = sessionInformation(), 
[08:25:49.007]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.007]                   signalCondition(cond)
[08:25:49.007]                 }
[08:25:49.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.007]                 "immediateCondition"))) {
[08:25:49.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.007]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.007]                   if (TRUE && !signal) {
[08:25:49.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.007]                     {
[08:25:49.007]                       inherits <- base::inherits
[08:25:49.007]                       invokeRestart <- base::invokeRestart
[08:25:49.007]                       is.null <- base::is.null
[08:25:49.007]                       muffled <- FALSE
[08:25:49.007]                       if (inherits(cond, "message")) {
[08:25:49.007]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.007]                         if (muffled) 
[08:25:49.007]                           invokeRestart("muffleMessage")
[08:25:49.007]                       }
[08:25:49.007]                       else if (inherits(cond, "warning")) {
[08:25:49.007]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.007]                         if (muffled) 
[08:25:49.007]                           invokeRestart("muffleWarning")
[08:25:49.007]                       }
[08:25:49.007]                       else if (inherits(cond, "condition")) {
[08:25:49.007]                         if (!is.null(pattern)) {
[08:25:49.007]                           computeRestarts <- base::computeRestarts
[08:25:49.007]                           grepl <- base::grepl
[08:25:49.007]                           restarts <- computeRestarts(cond)
[08:25:49.007]                           for (restart in restarts) {
[08:25:49.007]                             name <- restart$name
[08:25:49.007]                             if (is.null(name)) 
[08:25:49.007]                               next
[08:25:49.007]                             if (!grepl(pattern, name)) 
[08:25:49.007]                               next
[08:25:49.007]                             invokeRestart(restart)
[08:25:49.007]                             muffled <- TRUE
[08:25:49.007]                             break
[08:25:49.007]                           }
[08:25:49.007]                         }
[08:25:49.007]                       }
[08:25:49.007]                       invisible(muffled)
[08:25:49.007]                     }
[08:25:49.007]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.007]                   }
[08:25:49.007]                 }
[08:25:49.007]                 else {
[08:25:49.007]                   if (TRUE) {
[08:25:49.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.007]                     {
[08:25:49.007]                       inherits <- base::inherits
[08:25:49.007]                       invokeRestart <- base::invokeRestart
[08:25:49.007]                       is.null <- base::is.null
[08:25:49.007]                       muffled <- FALSE
[08:25:49.007]                       if (inherits(cond, "message")) {
[08:25:49.007]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.007]                         if (muffled) 
[08:25:49.007]                           invokeRestart("muffleMessage")
[08:25:49.007]                       }
[08:25:49.007]                       else if (inherits(cond, "warning")) {
[08:25:49.007]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.007]                         if (muffled) 
[08:25:49.007]                           invokeRestart("muffleWarning")
[08:25:49.007]                       }
[08:25:49.007]                       else if (inherits(cond, "condition")) {
[08:25:49.007]                         if (!is.null(pattern)) {
[08:25:49.007]                           computeRestarts <- base::computeRestarts
[08:25:49.007]                           grepl <- base::grepl
[08:25:49.007]                           restarts <- computeRestarts(cond)
[08:25:49.007]                           for (restart in restarts) {
[08:25:49.007]                             name <- restart$name
[08:25:49.007]                             if (is.null(name)) 
[08:25:49.007]                               next
[08:25:49.007]                             if (!grepl(pattern, name)) 
[08:25:49.007]                               next
[08:25:49.007]                             invokeRestart(restart)
[08:25:49.007]                             muffled <- TRUE
[08:25:49.007]                             break
[08:25:49.007]                           }
[08:25:49.007]                         }
[08:25:49.007]                       }
[08:25:49.007]                       invisible(muffled)
[08:25:49.007]                     }
[08:25:49.007]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.007]                   }
[08:25:49.007]                 }
[08:25:49.007]             }
[08:25:49.007]         }))
[08:25:49.007]     }, error = function(ex) {
[08:25:49.007]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.007]                 ...future.rng), started = ...future.startTime, 
[08:25:49.007]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.007]             version = "1.8"), class = "FutureResult")
[08:25:49.007]     }, finally = {
[08:25:49.007]         if (!identical(...future.workdir, getwd())) 
[08:25:49.007]             setwd(...future.workdir)
[08:25:49.007]         {
[08:25:49.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.007]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.007]             }
[08:25:49.007]             base::options(...future.oldOptions)
[08:25:49.007]             if (.Platform$OS.type == "windows") {
[08:25:49.007]                 old_names <- names(...future.oldEnvVars)
[08:25:49.007]                 envs <- base::Sys.getenv()
[08:25:49.007]                 names <- names(envs)
[08:25:49.007]                 common <- intersect(names, old_names)
[08:25:49.007]                 added <- setdiff(names, old_names)
[08:25:49.007]                 removed <- setdiff(old_names, names)
[08:25:49.007]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.007]                   envs[common]]
[08:25:49.007]                 NAMES <- toupper(changed)
[08:25:49.007]                 args <- list()
[08:25:49.007]                 for (kk in seq_along(NAMES)) {
[08:25:49.007]                   name <- changed[[kk]]
[08:25:49.007]                   NAME <- NAMES[[kk]]
[08:25:49.007]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.007]                     next
[08:25:49.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.007]                 }
[08:25:49.007]                 NAMES <- toupper(added)
[08:25:49.007]                 for (kk in seq_along(NAMES)) {
[08:25:49.007]                   name <- added[[kk]]
[08:25:49.007]                   NAME <- NAMES[[kk]]
[08:25:49.007]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.007]                     next
[08:25:49.007]                   args[[name]] <- ""
[08:25:49.007]                 }
[08:25:49.007]                 NAMES <- toupper(removed)
[08:25:49.007]                 for (kk in seq_along(NAMES)) {
[08:25:49.007]                   name <- removed[[kk]]
[08:25:49.007]                   NAME <- NAMES[[kk]]
[08:25:49.007]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.007]                     next
[08:25:49.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.007]                 }
[08:25:49.007]                 if (length(args) > 0) 
[08:25:49.007]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.007]             }
[08:25:49.007]             else {
[08:25:49.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.007]             }
[08:25:49.007]             {
[08:25:49.007]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.007]                   0L) {
[08:25:49.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.007]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.007]                   base::options(opts)
[08:25:49.007]                 }
[08:25:49.007]                 {
[08:25:49.007]                   {
[08:25:49.007]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.007]                     NULL
[08:25:49.007]                   }
[08:25:49.007]                   options(future.plan = NULL)
[08:25:49.007]                   if (is.na(NA_character_)) 
[08:25:49.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.007]                     .init = FALSE)
[08:25:49.007]                 }
[08:25:49.007]             }
[08:25:49.007]         }
[08:25:49.007]     })
[08:25:49.007]     if (TRUE) {
[08:25:49.007]         base::sink(type = "output", split = FALSE)
[08:25:49.007]         if (TRUE) {
[08:25:49.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.007]         }
[08:25:49.007]         else {
[08:25:49.007]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.007]         }
[08:25:49.007]         base::close(...future.stdout)
[08:25:49.007]         ...future.stdout <- NULL
[08:25:49.007]     }
[08:25:49.007]     ...future.result$conditions <- ...future.conditions
[08:25:49.007]     ...future.result$finished <- base::Sys.time()
[08:25:49.007]     ...future.result
[08:25:49.007] }
[08:25:49.011] assign_globals() ...
[08:25:49.011] List of 5
[08:25:49.011]  $ ...future.FUN            :function (C, k)  
[08:25:49.011]  $ MoreArgs                 : NULL
[08:25:49.011]  $ ...future.elements_ii    :List of 2
[08:25:49.011]   ..$ :List of 1
[08:25:49.011]   .. ..$ : chr "E"
[08:25:49.011]   ..$ :List of 1
[08:25:49.011]   .. ..$ : int 1
[08:25:49.011]  $ ...future.seeds_ii       : NULL
[08:25:49.011]  $ ...future.globals.maxSize: NULL
[08:25:49.011]  - attr(*, "where")=List of 5
[08:25:49.011]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.011]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.011]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.011]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.011]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.011]  - attr(*, "resolved")= logi FALSE
[08:25:49.011]  - attr(*, "total_size")= num 847
[08:25:49.011]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.011]  - attr(*, "already-done")= logi TRUE
[08:25:49.023] - reassign environment for ‘...future.FUN’
[08:25:49.023] - copied ‘...future.FUN’ to environment
[08:25:49.023] - copied ‘MoreArgs’ to environment
[08:25:49.023] - copied ‘...future.elements_ii’ to environment
[08:25:49.024] - copied ‘...future.seeds_ii’ to environment
[08:25:49.024] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.024] assign_globals() ... done
[08:25:49.024] requestCore(): workers = 2
[08:25:49.024] Poll #1 (0): usedCores() = 2, workers = 2
[08:25:49.035] result() for MulticoreFuture ...
[08:25:49.036] result() for MulticoreFuture ...
[08:25:49.037] result() for MulticoreFuture ... done
[08:25:49.037] result() for MulticoreFuture ... done
[08:25:49.037] result() for MulticoreFuture ...
[08:25:49.037] result() for MulticoreFuture ... done
[08:25:49.041] MulticoreFuture started
[08:25:49.042] - Launch lazy future ... done
[08:25:49.042] plan(): Setting new future strategy stack:
[08:25:49.042] run() for ‘MulticoreFuture’ ... done
[08:25:49.043] Created future:
[08:25:49.043] List of future strategies:
[08:25:49.043] 1. sequential:
[08:25:49.043]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.043]    - tweaked: FALSE
[08:25:49.043]    - call: NULL
[08:25:49.045] plan(): nbrOfWorkers() = 1
[08:25:49.048] plan(): Setting new future strategy stack:
[08:25:49.048] List of future strategies:
[08:25:49.048] 1. multicore:
[08:25:49.048]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.048]    - tweaked: FALSE
[08:25:49.048]    - call: plan(strategy)
[08:25:49.053] plan(): nbrOfWorkers() = 2
[08:25:49.043] MulticoreFuture:
[08:25:49.043] Label: ‘future_mapply-5’
[08:25:49.043] Expression:
[08:25:49.043] {
[08:25:49.043]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.043]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.043]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.043]         on.exit(options(oopts), add = TRUE)
[08:25:49.043]     }
[08:25:49.043]     {
[08:25:49.043]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.043]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.043]         do.call(mapply, args = args)
[08:25:49.043]     }
[08:25:49.043] }
[08:25:49.043] Lazy evaluation: FALSE
[08:25:49.043] Asynchronous evaluation: TRUE
[08:25:49.043] Local evaluation: TRUE
[08:25:49.043] Environment: R_GlobalEnv
[08:25:49.043] Capture standard output: TRUE
[08:25:49.043] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.043] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.043] Packages: <none>
[08:25:49.043] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.043] Resolved: TRUE
[08:25:49.043] Value: <not collected>
[08:25:49.043] Conditions captured: <none>
[08:25:49.043] Early signaling: FALSE
[08:25:49.043] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.043] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.054] Chunk #5 of 5 ... DONE
[08:25:49.055] Launching 5 futures (chunks) ... DONE
[08:25:49.055] Resolving 5 futures (chunks) ...
[08:25:49.055] resolve() on list ...
[08:25:49.055]  recursive: 0
[08:25:49.056]  length: 5
[08:25:49.056] 
[08:25:49.056] Future #1
[08:25:49.056] result() for MulticoreFuture ...
[08:25:49.057] result() for MulticoreFuture ... done
[08:25:49.057] result() for MulticoreFuture ...
[08:25:49.057] result() for MulticoreFuture ... done
[08:25:49.057] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:49.057] - nx: 5
[08:25:49.057] - relay: TRUE
[08:25:49.058] - stdout: TRUE
[08:25:49.058] - signal: TRUE
[08:25:49.058] - resignal: FALSE
[08:25:49.058] - force: TRUE
[08:25:49.058] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[08:25:49.058] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[08:25:49.059]  - until=1
[08:25:49.059]  - relaying element #1
[08:25:49.059] result() for MulticoreFuture ...
[08:25:49.059] result() for MulticoreFuture ... done
[08:25:49.059] result() for MulticoreFuture ...
[08:25:49.059] result() for MulticoreFuture ... done
[08:25:49.060] result() for MulticoreFuture ...
[08:25:49.060] result() for MulticoreFuture ... done
[08:25:49.060] result() for MulticoreFuture ...
[08:25:49.060] result() for MulticoreFuture ... done
[08:25:49.060] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:49.061] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:49.061] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:49.061]  length: 4 (resolved future 1)
[08:25:49.061] Future #2
[08:25:49.061] result() for MulticoreFuture ...
[08:25:49.061] result() for MulticoreFuture ... done
[08:25:49.062] result() for MulticoreFuture ...
[08:25:49.062] result() for MulticoreFuture ... done
[08:25:49.062] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:49.062] - nx: 5
[08:25:49.062] - relay: TRUE
[08:25:49.062] - stdout: TRUE
[08:25:49.062] - signal: TRUE
[08:25:49.062] - resignal: FALSE
[08:25:49.063] - force: TRUE
[08:25:49.063] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:49.063] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:49.063]  - until=2
[08:25:49.063]  - relaying element #2
[08:25:49.063] result() for MulticoreFuture ...
[08:25:49.063] result() for MulticoreFuture ... done
[08:25:49.063] result() for MulticoreFuture ...
[08:25:49.064] result() for MulticoreFuture ... done
[08:25:49.064] result() for MulticoreFuture ...
[08:25:49.064] result() for MulticoreFuture ... done
[08:25:49.064] result() for MulticoreFuture ...
[08:25:49.064] result() for MulticoreFuture ... done
[08:25:49.064] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:49.064] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:49.065] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:49.065]  length: 3 (resolved future 2)
[08:25:49.065] Future #3
[08:25:49.065] result() for MulticoreFuture ...
[08:25:49.065] result() for MulticoreFuture ... done
[08:25:49.065] result() for MulticoreFuture ...
[08:25:49.065] result() for MulticoreFuture ... done
[08:25:49.066] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:25:49.066] - nx: 5
[08:25:49.066] - relay: TRUE
[08:25:49.066] - stdout: TRUE
[08:25:49.066] - signal: TRUE
[08:25:49.066] - resignal: FALSE
[08:25:49.066] - force: TRUE
[08:25:49.066] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:49.066] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:49.067]  - until=3
[08:25:49.067]  - relaying element #3
[08:25:49.067] result() for MulticoreFuture ...
[08:25:49.067] result() for MulticoreFuture ... done
[08:25:49.067] result() for MulticoreFuture ...
[08:25:49.067] result() for MulticoreFuture ... done
[08:25:49.067] result() for MulticoreFuture ...
[08:25:49.067] result() for MulticoreFuture ... done
[08:25:49.068] result() for MulticoreFuture ...
[08:25:49.068] result() for MulticoreFuture ... done
[08:25:49.068] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:49.068] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:49.068] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:25:49.068]  length: 2 (resolved future 3)
[08:25:49.069] Future #4
[08:25:49.069] result() for MulticoreFuture ...
[08:25:49.070] result() for MulticoreFuture ...
[08:25:49.070] result() for MulticoreFuture ... done
[08:25:49.070] result() for MulticoreFuture ... done
[08:25:49.070] result() for MulticoreFuture ...
[08:25:49.070] result() for MulticoreFuture ... done
[08:25:49.071] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:25:49.071] - nx: 5
[08:25:49.071] - relay: TRUE
[08:25:49.071] - stdout: TRUE
[08:25:49.071] - signal: TRUE
[08:25:49.071] - resignal: FALSE
[08:25:49.072] - force: TRUE
[08:25:49.072] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:49.072] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:49.072]  - until=4
[08:25:49.072]  - relaying element #4
[08:25:49.072] result() for MulticoreFuture ...
[08:25:49.073] result() for MulticoreFuture ... done
[08:25:49.073] result() for MulticoreFuture ...
[08:25:49.073] result() for MulticoreFuture ... done
[08:25:49.073] result() for MulticoreFuture ...
[08:25:49.073] result() for MulticoreFuture ... done
[08:25:49.074] result() for MulticoreFuture ...
[08:25:49.074] result() for MulticoreFuture ... done
[08:25:49.074] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:49.074] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:49.074] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:25:49.074]  length: 1 (resolved future 4)
[08:25:49.075] Future #5
[08:25:49.075] result() for MulticoreFuture ...
[08:25:49.076] result() for MulticoreFuture ...
[08:25:49.076] result() for MulticoreFuture ... done
[08:25:49.076] result() for MulticoreFuture ... done
[08:25:49.076] result() for MulticoreFuture ...
[08:25:49.077] result() for MulticoreFuture ... done
[08:25:49.077] signalConditionsASAP(MulticoreFuture, pos=5) ...
[08:25:49.077] - nx: 5
[08:25:49.077] - relay: TRUE
[08:25:49.077] - stdout: TRUE
[08:25:49.077] - signal: TRUE
[08:25:49.077] - resignal: FALSE
[08:25:49.077] - force: TRUE
[08:25:49.077] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:49.078] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:49.078]  - until=5
[08:25:49.078]  - relaying element #5
[08:25:49.078] result() for MulticoreFuture ...
[08:25:49.078] result() for MulticoreFuture ... done
[08:25:49.078] result() for MulticoreFuture ...
[08:25:49.078] result() for MulticoreFuture ... done
[08:25:49.078] result() for MulticoreFuture ...
[08:25:49.078] result() for MulticoreFuture ... done
[08:25:49.079] result() for MulticoreFuture ...
[08:25:49.079] result() for MulticoreFuture ... done
[08:25:49.079] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:49.082] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:49.082] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[08:25:49.082]  length: 0 (resolved future 5)
[08:25:49.082] Relaying remaining futures
[08:25:49.082] signalConditionsASAP(NULL, pos=0) ...
[08:25:49.082] - nx: 5
[08:25:49.082] - relay: TRUE
[08:25:49.083] - stdout: TRUE
[08:25:49.083] - signal: TRUE
[08:25:49.083] - resignal: FALSE
[08:25:49.083] - force: TRUE
[08:25:49.083] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:49.083] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[08:25:49.083] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:49.083] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:49.084] signalConditionsASAP(NULL, pos=0) ... done
[08:25:49.084] resolve() on list ... DONE
[08:25:49.084] result() for MulticoreFuture ...
[08:25:49.084] result() for MulticoreFuture ... done
[08:25:49.084] result() for MulticoreFuture ...
[08:25:49.084] result() for MulticoreFuture ... done
[08:25:49.084] result() for MulticoreFuture ...
[08:25:49.085] result() for MulticoreFuture ... done
[08:25:49.085] result() for MulticoreFuture ...
[08:25:49.085] result() for MulticoreFuture ... done
[08:25:49.085] result() for MulticoreFuture ...
[08:25:49.085] result() for MulticoreFuture ... done
[08:25:49.085] result() for MulticoreFuture ...
[08:25:49.085] result() for MulticoreFuture ... done
[08:25:49.085] result() for MulticoreFuture ...
[08:25:49.086] result() for MulticoreFuture ... done
[08:25:49.086] result() for MulticoreFuture ...
[08:25:49.086] result() for MulticoreFuture ... done
[08:25:49.086] result() for MulticoreFuture ...
[08:25:49.086] result() for MulticoreFuture ... done
[08:25:49.086] result() for MulticoreFuture ...
[08:25:49.086] result() for MulticoreFuture ... done
[08:25:49.086]  - Number of value chunks collected: 5
[08:25:49.087] Resolving 5 futures (chunks) ... DONE
[08:25:49.087] Reducing values from 5 chunks ...
[08:25:49.087]  - Number of values collected after concatenation: 5
[08:25:49.087]  - Number of values expected: 5
[08:25:49.087] Reducing values from 5 chunks ... DONE
[08:25:49.087] future_mapply() ... DONE
[08:25:49.087] future_mapply() ...
[08:25:49.090] Number of chunks: 2
[08:25:49.090] getGlobalsAndPackagesXApply() ...
[08:25:49.090]  - future.globals: TRUE
[08:25:49.090] getGlobalsAndPackages() ...
[08:25:49.090] Searching for globals...
[08:25:49.092] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:49.092] Searching for globals ... DONE
[08:25:49.092] Resolving globals: FALSE
[08:25:49.092] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:49.093] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:49.093] - globals: [1] ‘FUN’
[08:25:49.093] 
[08:25:49.093] getGlobalsAndPackages() ... DONE
[08:25:49.093]  - globals found/used: [n=1] ‘FUN’
[08:25:49.093]  - needed namespaces: [n=0] 
[08:25:49.093] Finding globals ... DONE
[08:25:49.093] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:49.094] List of 2
[08:25:49.094]  $ ...future.FUN:function (C, k)  
[08:25:49.094]  $ MoreArgs     : list()
[08:25:49.094]  - attr(*, "where")=List of 2
[08:25:49.094]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:49.094]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:49.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.094]  - attr(*, "resolved")= logi FALSE
[08:25:49.094]  - attr(*, "total_size")= num NA
[08:25:49.096] Packages to be attached in all futures: [n=0] 
[08:25:49.096] getGlobalsAndPackagesXApply() ... DONE
[08:25:49.097] Number of futures (= number of chunks): 2
[08:25:49.097] Launching 2 futures (chunks) ...
[08:25:49.097] Chunk #1 of 2 ...
[08:25:49.097]  - Finding globals in '...' for chunk #1 ...
[08:25:49.097] getGlobalsAndPackages() ...
[08:25:49.097] Searching for globals...
[08:25:49.098] 
[08:25:49.098] Searching for globals ... DONE
[08:25:49.098] - globals: [0] <none>
[08:25:49.098] getGlobalsAndPackages() ... DONE
[08:25:49.098]    + additional globals found: [n=0] 
[08:25:49.098]    + additional namespaces needed: [n=0] 
[08:25:49.098]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:49.098]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.098]  - seeds: <none>
[08:25:49.098]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.098] getGlobalsAndPackages() ...
[08:25:49.099] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.099] Resolving globals: FALSE
[08:25:49.099] The total size of the 5 globals is 880 bytes (880 bytes)
[08:25:49.100] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:49.100] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.100] 
[08:25:49.100] getGlobalsAndPackages() ... DONE
[08:25:49.100] run() for ‘Future’ ...
[08:25:49.100] - state: ‘created’
[08:25:49.101] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.102] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.102] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.102]   - Field: ‘label’
[08:25:49.103]   - Field: ‘local’
[08:25:49.103]   - Field: ‘owner’
[08:25:49.103]   - Field: ‘envir’
[08:25:49.103]   - Field: ‘workers’
[08:25:49.103]   - Field: ‘packages’
[08:25:49.103]   - Field: ‘gc’
[08:25:49.103]   - Field: ‘job’
[08:25:49.103]   - Field: ‘conditions’
[08:25:49.103]   - Field: ‘expr’
[08:25:49.103]   - Field: ‘uuid’
[08:25:49.104]   - Field: ‘seed’
[08:25:49.104]   - Field: ‘version’
[08:25:49.104]   - Field: ‘result’
[08:25:49.104]   - Field: ‘asynchronous’
[08:25:49.104]   - Field: ‘calls’
[08:25:49.104]   - Field: ‘globals’
[08:25:49.104]   - Field: ‘stdout’
[08:25:49.104]   - Field: ‘earlySignal’
[08:25:49.104]   - Field: ‘lazy’
[08:25:49.104]   - Field: ‘state’
[08:25:49.104] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.105] - Launch lazy future ...
[08:25:49.107] Packages needed by the future expression (n = 0): <none>
[08:25:49.107] Packages needed by future strategies (n = 0): <none>
[08:25:49.108] {
[08:25:49.108]     {
[08:25:49.108]         {
[08:25:49.108]             ...future.startTime <- base::Sys.time()
[08:25:49.108]             {
[08:25:49.108]                 {
[08:25:49.108]                   {
[08:25:49.108]                     {
[08:25:49.108]                       base::local({
[08:25:49.108]                         has_future <- base::requireNamespace("future", 
[08:25:49.108]                           quietly = TRUE)
[08:25:49.108]                         if (has_future) {
[08:25:49.108]                           ns <- base::getNamespace("future")
[08:25:49.108]                           version <- ns[[".package"]][["version"]]
[08:25:49.108]                           if (is.null(version)) 
[08:25:49.108]                             version <- utils::packageVersion("future")
[08:25:49.108]                         }
[08:25:49.108]                         else {
[08:25:49.108]                           version <- NULL
[08:25:49.108]                         }
[08:25:49.108]                         if (!has_future || version < "1.8.0") {
[08:25:49.108]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.108]                             "", base::R.version$version.string), 
[08:25:49.108]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.108]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.108]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.108]                               "release", "version")], collapse = " "), 
[08:25:49.108]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.108]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.108]                             info)
[08:25:49.108]                           info <- base::paste(info, collapse = "; ")
[08:25:49.108]                           if (!has_future) {
[08:25:49.108]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.108]                               info)
[08:25:49.108]                           }
[08:25:49.108]                           else {
[08:25:49.108]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.108]                               info, version)
[08:25:49.108]                           }
[08:25:49.108]                           base::stop(msg)
[08:25:49.108]                         }
[08:25:49.108]                       })
[08:25:49.108]                     }
[08:25:49.108]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.108]                     base::options(mc.cores = 1L)
[08:25:49.108]                   }
[08:25:49.108]                   ...future.strategy.old <- future::plan("list")
[08:25:49.108]                   options(future.plan = NULL)
[08:25:49.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.108]                 }
[08:25:49.108]                 ...future.workdir <- getwd()
[08:25:49.108]             }
[08:25:49.108]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.108]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.108]         }
[08:25:49.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.108]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.108]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.108]             base::names(...future.oldOptions))
[08:25:49.108]     }
[08:25:49.108]     if (FALSE) {
[08:25:49.108]     }
[08:25:49.108]     else {
[08:25:49.108]         if (TRUE) {
[08:25:49.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.108]                 open = "w")
[08:25:49.108]         }
[08:25:49.108]         else {
[08:25:49.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.108]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.108]         }
[08:25:49.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.108]             base::sink(type = "output", split = FALSE)
[08:25:49.108]             base::close(...future.stdout)
[08:25:49.108]         }, add = TRUE)
[08:25:49.108]     }
[08:25:49.108]     ...future.frame <- base::sys.nframe()
[08:25:49.108]     ...future.conditions <- base::list()
[08:25:49.108]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.108]     if (FALSE) {
[08:25:49.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.108]     }
[08:25:49.108]     ...future.result <- base::tryCatch({
[08:25:49.108]         base::withCallingHandlers({
[08:25:49.108]             ...future.value <- base::withVisible(base::local({
[08:25:49.108]                 withCallingHandlers({
[08:25:49.108]                   {
[08:25:49.108]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.108]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.108]                       ...future.globals.maxSize)) {
[08:25:49.108]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.108]                       on.exit(options(oopts), add = TRUE)
[08:25:49.108]                     }
[08:25:49.108]                     {
[08:25:49.108]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.108]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.108]                         USE.NAMES = FALSE)
[08:25:49.108]                       do.call(mapply, args = args)
[08:25:49.108]                     }
[08:25:49.108]                   }
[08:25:49.108]                 }, immediateCondition = function(cond) {
[08:25:49.108]                   save_rds <- function (object, pathname, ...) 
[08:25:49.108]                   {
[08:25:49.108]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.108]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.108]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.108]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.108]                         fi_tmp[["mtime"]])
[08:25:49.108]                     }
[08:25:49.108]                     tryCatch({
[08:25:49.108]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.108]                     }, error = function(ex) {
[08:25:49.108]                       msg <- conditionMessage(ex)
[08:25:49.108]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.108]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.108]                         fi_tmp[["mtime"]], msg)
[08:25:49.108]                       ex$message <- msg
[08:25:49.108]                       stop(ex)
[08:25:49.108]                     })
[08:25:49.108]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.108]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.108]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.108]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.108]                       fi <- file.info(pathname)
[08:25:49.108]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.108]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.108]                         fi[["size"]], fi[["mtime"]])
[08:25:49.108]                       stop(msg)
[08:25:49.108]                     }
[08:25:49.108]                     invisible(pathname)
[08:25:49.108]                   }
[08:25:49.108]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.108]                     rootPath = tempdir()) 
[08:25:49.108]                   {
[08:25:49.108]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.108]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.108]                       tmpdir = path, fileext = ".rds")
[08:25:49.108]                     save_rds(obj, file)
[08:25:49.108]                   }
[08:25:49.108]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.108]                   {
[08:25:49.108]                     inherits <- base::inherits
[08:25:49.108]                     invokeRestart <- base::invokeRestart
[08:25:49.108]                     is.null <- base::is.null
[08:25:49.108]                     muffled <- FALSE
[08:25:49.108]                     if (inherits(cond, "message")) {
[08:25:49.108]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.108]                       if (muffled) 
[08:25:49.108]                         invokeRestart("muffleMessage")
[08:25:49.108]                     }
[08:25:49.108]                     else if (inherits(cond, "warning")) {
[08:25:49.108]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.108]                       if (muffled) 
[08:25:49.108]                         invokeRestart("muffleWarning")
[08:25:49.108]                     }
[08:25:49.108]                     else if (inherits(cond, "condition")) {
[08:25:49.108]                       if (!is.null(pattern)) {
[08:25:49.108]                         computeRestarts <- base::computeRestarts
[08:25:49.108]                         grepl <- base::grepl
[08:25:49.108]                         restarts <- computeRestarts(cond)
[08:25:49.108]                         for (restart in restarts) {
[08:25:49.108]                           name <- restart$name
[08:25:49.108]                           if (is.null(name)) 
[08:25:49.108]                             next
[08:25:49.108]                           if (!grepl(pattern, name)) 
[08:25:49.108]                             next
[08:25:49.108]                           invokeRestart(restart)
[08:25:49.108]                           muffled <- TRUE
[08:25:49.108]                           break
[08:25:49.108]                         }
[08:25:49.108]                       }
[08:25:49.108]                     }
[08:25:49.108]                     invisible(muffled)
[08:25:49.108]                   }
[08:25:49.108]                   muffleCondition(cond)
[08:25:49.108]                 })
[08:25:49.108]             }))
[08:25:49.108]             future::FutureResult(value = ...future.value$value, 
[08:25:49.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.108]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.108]                     ...future.globalenv.names))
[08:25:49.108]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.108]         }, condition = base::local({
[08:25:49.108]             c <- base::c
[08:25:49.108]             inherits <- base::inherits
[08:25:49.108]             invokeRestart <- base::invokeRestart
[08:25:49.108]             length <- base::length
[08:25:49.108]             list <- base::list
[08:25:49.108]             seq.int <- base::seq.int
[08:25:49.108]             signalCondition <- base::signalCondition
[08:25:49.108]             sys.calls <- base::sys.calls
[08:25:49.108]             `[[` <- base::`[[`
[08:25:49.108]             `+` <- base::`+`
[08:25:49.108]             `<<-` <- base::`<<-`
[08:25:49.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.108]                   3L)]
[08:25:49.108]             }
[08:25:49.108]             function(cond) {
[08:25:49.108]                 is_error <- inherits(cond, "error")
[08:25:49.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.108]                   NULL)
[08:25:49.108]                 if (is_error) {
[08:25:49.108]                   sessionInformation <- function() {
[08:25:49.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.108]                       search = base::search(), system = base::Sys.info())
[08:25:49.108]                   }
[08:25:49.108]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.108]                     cond$call), session = sessionInformation(), 
[08:25:49.108]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.108]                   signalCondition(cond)
[08:25:49.108]                 }
[08:25:49.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.108]                 "immediateCondition"))) {
[08:25:49.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.108]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.108]                   if (TRUE && !signal) {
[08:25:49.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.108]                     {
[08:25:49.108]                       inherits <- base::inherits
[08:25:49.108]                       invokeRestart <- base::invokeRestart
[08:25:49.108]                       is.null <- base::is.null
[08:25:49.108]                       muffled <- FALSE
[08:25:49.108]                       if (inherits(cond, "message")) {
[08:25:49.108]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.108]                         if (muffled) 
[08:25:49.108]                           invokeRestart("muffleMessage")
[08:25:49.108]                       }
[08:25:49.108]                       else if (inherits(cond, "warning")) {
[08:25:49.108]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.108]                         if (muffled) 
[08:25:49.108]                           invokeRestart("muffleWarning")
[08:25:49.108]                       }
[08:25:49.108]                       else if (inherits(cond, "condition")) {
[08:25:49.108]                         if (!is.null(pattern)) {
[08:25:49.108]                           computeRestarts <- base::computeRestarts
[08:25:49.108]                           grepl <- base::grepl
[08:25:49.108]                           restarts <- computeRestarts(cond)
[08:25:49.108]                           for (restart in restarts) {
[08:25:49.108]                             name <- restart$name
[08:25:49.108]                             if (is.null(name)) 
[08:25:49.108]                               next
[08:25:49.108]                             if (!grepl(pattern, name)) 
[08:25:49.108]                               next
[08:25:49.108]                             invokeRestart(restart)
[08:25:49.108]                             muffled <- TRUE
[08:25:49.108]                             break
[08:25:49.108]                           }
[08:25:49.108]                         }
[08:25:49.108]                       }
[08:25:49.108]                       invisible(muffled)
[08:25:49.108]                     }
[08:25:49.108]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.108]                   }
[08:25:49.108]                 }
[08:25:49.108]                 else {
[08:25:49.108]                   if (TRUE) {
[08:25:49.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.108]                     {
[08:25:49.108]                       inherits <- base::inherits
[08:25:49.108]                       invokeRestart <- base::invokeRestart
[08:25:49.108]                       is.null <- base::is.null
[08:25:49.108]                       muffled <- FALSE
[08:25:49.108]                       if (inherits(cond, "message")) {
[08:25:49.108]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.108]                         if (muffled) 
[08:25:49.108]                           invokeRestart("muffleMessage")
[08:25:49.108]                       }
[08:25:49.108]                       else if (inherits(cond, "warning")) {
[08:25:49.108]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.108]                         if (muffled) 
[08:25:49.108]                           invokeRestart("muffleWarning")
[08:25:49.108]                       }
[08:25:49.108]                       else if (inherits(cond, "condition")) {
[08:25:49.108]                         if (!is.null(pattern)) {
[08:25:49.108]                           computeRestarts <- base::computeRestarts
[08:25:49.108]                           grepl <- base::grepl
[08:25:49.108]                           restarts <- computeRestarts(cond)
[08:25:49.108]                           for (restart in restarts) {
[08:25:49.108]                             name <- restart$name
[08:25:49.108]                             if (is.null(name)) 
[08:25:49.108]                               next
[08:25:49.108]                             if (!grepl(pattern, name)) 
[08:25:49.108]                               next
[08:25:49.108]                             invokeRestart(restart)
[08:25:49.108]                             muffled <- TRUE
[08:25:49.108]                             break
[08:25:49.108]                           }
[08:25:49.108]                         }
[08:25:49.108]                       }
[08:25:49.108]                       invisible(muffled)
[08:25:49.108]                     }
[08:25:49.108]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.108]                   }
[08:25:49.108]                 }
[08:25:49.108]             }
[08:25:49.108]         }))
[08:25:49.108]     }, error = function(ex) {
[08:25:49.108]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.108]                 ...future.rng), started = ...future.startTime, 
[08:25:49.108]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.108]             version = "1.8"), class = "FutureResult")
[08:25:49.108]     }, finally = {
[08:25:49.108]         if (!identical(...future.workdir, getwd())) 
[08:25:49.108]             setwd(...future.workdir)
[08:25:49.108]         {
[08:25:49.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.108]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.108]             }
[08:25:49.108]             base::options(...future.oldOptions)
[08:25:49.108]             if (.Platform$OS.type == "windows") {
[08:25:49.108]                 old_names <- names(...future.oldEnvVars)
[08:25:49.108]                 envs <- base::Sys.getenv()
[08:25:49.108]                 names <- names(envs)
[08:25:49.108]                 common <- intersect(names, old_names)
[08:25:49.108]                 added <- setdiff(names, old_names)
[08:25:49.108]                 removed <- setdiff(old_names, names)
[08:25:49.108]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.108]                   envs[common]]
[08:25:49.108]                 NAMES <- toupper(changed)
[08:25:49.108]                 args <- list()
[08:25:49.108]                 for (kk in seq_along(NAMES)) {
[08:25:49.108]                   name <- changed[[kk]]
[08:25:49.108]                   NAME <- NAMES[[kk]]
[08:25:49.108]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.108]                     next
[08:25:49.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.108]                 }
[08:25:49.108]                 NAMES <- toupper(added)
[08:25:49.108]                 for (kk in seq_along(NAMES)) {
[08:25:49.108]                   name <- added[[kk]]
[08:25:49.108]                   NAME <- NAMES[[kk]]
[08:25:49.108]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.108]                     next
[08:25:49.108]                   args[[name]] <- ""
[08:25:49.108]                 }
[08:25:49.108]                 NAMES <- toupper(removed)
[08:25:49.108]                 for (kk in seq_along(NAMES)) {
[08:25:49.108]                   name <- removed[[kk]]
[08:25:49.108]                   NAME <- NAMES[[kk]]
[08:25:49.108]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.108]                     next
[08:25:49.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.108]                 }
[08:25:49.108]                 if (length(args) > 0) 
[08:25:49.108]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.108]             }
[08:25:49.108]             else {
[08:25:49.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.108]             }
[08:25:49.108]             {
[08:25:49.108]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.108]                   0L) {
[08:25:49.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.108]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.108]                   base::options(opts)
[08:25:49.108]                 }
[08:25:49.108]                 {
[08:25:49.108]                   {
[08:25:49.108]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.108]                     NULL
[08:25:49.108]                   }
[08:25:49.108]                   options(future.plan = NULL)
[08:25:49.108]                   if (is.na(NA_character_)) 
[08:25:49.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.108]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.108]                     .init = FALSE)
[08:25:49.108]                 }
[08:25:49.108]             }
[08:25:49.108]         }
[08:25:49.108]     })
[08:25:49.108]     if (TRUE) {
[08:25:49.108]         base::sink(type = "output", split = FALSE)
[08:25:49.108]         if (TRUE) {
[08:25:49.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.108]         }
[08:25:49.108]         else {
[08:25:49.108]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.108]         }
[08:25:49.108]         base::close(...future.stdout)
[08:25:49.108]         ...future.stdout <- NULL
[08:25:49.108]     }
[08:25:49.108]     ...future.result$conditions <- ...future.conditions
[08:25:49.108]     ...future.result$finished <- base::Sys.time()
[08:25:49.108]     ...future.result
[08:25:49.108] }
[08:25:49.110] assign_globals() ...
[08:25:49.111] List of 5
[08:25:49.111]  $ ...future.FUN            :function (C, k)  
[08:25:49.111]  $ MoreArgs                 : list()
[08:25:49.111]  $ ...future.elements_ii    :List of 2
[08:25:49.111]   ..$ :List of 2
[08:25:49.111]   .. ..$ : chr "A"
[08:25:49.111]   .. ..$ : chr "B"
[08:25:49.111]   ..$ :List of 2
[08:25:49.111]   .. ..$ : int 5
[08:25:49.111]   .. ..$ : int 4
[08:25:49.111]  $ ...future.seeds_ii       : NULL
[08:25:49.111]  $ ...future.globals.maxSize: NULL
[08:25:49.111]  - attr(*, "where")=List of 5
[08:25:49.111]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.111]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.111]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.111]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.111]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.111]  - attr(*, "resolved")= logi FALSE
[08:25:49.111]  - attr(*, "total_size")= num 880
[08:25:49.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.111]  - attr(*, "already-done")= logi TRUE
[08:25:49.117] - reassign environment for ‘...future.FUN’
[08:25:49.117] - copied ‘...future.FUN’ to environment
[08:25:49.117] - copied ‘MoreArgs’ to environment
[08:25:49.117] - copied ‘...future.elements_ii’ to environment
[08:25:49.118] - copied ‘...future.seeds_ii’ to environment
[08:25:49.118] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.118] assign_globals() ... done
[08:25:49.118] requestCore(): workers = 2
[08:25:49.120] MulticoreFuture started
[08:25:49.121] - Launch lazy future ... done
[08:25:49.121] run() for ‘MulticoreFuture’ ... done
[08:25:49.121] plan(): Setting new future strategy stack:
[08:25:49.122] Created future:
[08:25:49.122] List of future strategies:
[08:25:49.122] 1. sequential:
[08:25:49.122]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.122]    - tweaked: FALSE
[08:25:49.122]    - call: NULL
[08:25:49.123] plan(): nbrOfWorkers() = 1
[08:25:49.125] plan(): Setting new future strategy stack:
[08:25:49.125] List of future strategies:
[08:25:49.125] 1. multicore:
[08:25:49.125]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.125]    - tweaked: FALSE
[08:25:49.125]    - call: plan(strategy)
[08:25:49.129] plan(): nbrOfWorkers() = 2
[08:25:49.122] MulticoreFuture:
[08:25:49.122] Label: ‘future_.mapply-1’
[08:25:49.122] Expression:
[08:25:49.122] {
[08:25:49.122]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.122]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.122]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.122]         on.exit(options(oopts), add = TRUE)
[08:25:49.122]     }
[08:25:49.122]     {
[08:25:49.122]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.122]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.122]         do.call(mapply, args = args)
[08:25:49.122]     }
[08:25:49.122] }
[08:25:49.122] Lazy evaluation: FALSE
[08:25:49.122] Asynchronous evaluation: TRUE
[08:25:49.122] Local evaluation: TRUE
[08:25:49.122] Environment: R_GlobalEnv
[08:25:49.122] Capture standard output: TRUE
[08:25:49.122] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.122] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.122] Packages: <none>
[08:25:49.122] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.122] Resolved: TRUE
[08:25:49.122] Value: <not collected>
[08:25:49.122] Conditions captured: <none>
[08:25:49.122] Early signaling: FALSE
[08:25:49.122] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.122] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.130] Chunk #1 of 2 ... DONE
[08:25:49.130] Chunk #2 of 2 ...
[08:25:49.130]  - Finding globals in '...' for chunk #2 ...
[08:25:49.130] getGlobalsAndPackages() ...
[08:25:49.130] Searching for globals...
[08:25:49.131] 
[08:25:49.131] Searching for globals ... DONE
[08:25:49.131] - globals: [0] <none>
[08:25:49.131] getGlobalsAndPackages() ... DONE
[08:25:49.131]    + additional globals found: [n=0] 
[08:25:49.132]    + additional namespaces needed: [n=0] 
[08:25:49.132]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:49.132]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.132]  - seeds: <none>
[08:25:49.132]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.132] getGlobalsAndPackages() ...
[08:25:49.132] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.133] Resolving globals: FALSE
[08:25:49.133] The total size of the 5 globals is 909 bytes (909 bytes)
[08:25:49.134] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:49.134] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.135] 
[08:25:49.135] getGlobalsAndPackages() ... DONE
[08:25:49.135] run() for ‘Future’ ...
[08:25:49.135] - state: ‘created’
[08:25:49.136] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.138] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.139]   - Field: ‘label’
[08:25:49.139]   - Field: ‘local’
[08:25:49.139]   - Field: ‘owner’
[08:25:49.139]   - Field: ‘envir’
[08:25:49.139]   - Field: ‘workers’
[08:25:49.140]   - Field: ‘packages’
[08:25:49.140]   - Field: ‘gc’
[08:25:49.140]   - Field: ‘job’
[08:25:49.140]   - Field: ‘conditions’
[08:25:49.140]   - Field: ‘expr’
[08:25:49.140]   - Field: ‘uuid’
[08:25:49.140]   - Field: ‘seed’
[08:25:49.141]   - Field: ‘version’
[08:25:49.141]   - Field: ‘result’
[08:25:49.141]   - Field: ‘asynchronous’
[08:25:49.141]   - Field: ‘calls’
[08:25:49.141]   - Field: ‘globals’
[08:25:49.141]   - Field: ‘stdout’
[08:25:49.142]   - Field: ‘earlySignal’
[08:25:49.142]   - Field: ‘lazy’
[08:25:49.142]   - Field: ‘state’
[08:25:49.142] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.142] - Launch lazy future ...
[08:25:49.143] Packages needed by the future expression (n = 0): <none>
[08:25:49.143] Packages needed by future strategies (n = 0): <none>
[08:25:49.144] {
[08:25:49.144]     {
[08:25:49.144]         {
[08:25:49.144]             ...future.startTime <- base::Sys.time()
[08:25:49.144]             {
[08:25:49.144]                 {
[08:25:49.144]                   {
[08:25:49.144]                     {
[08:25:49.144]                       base::local({
[08:25:49.144]                         has_future <- base::requireNamespace("future", 
[08:25:49.144]                           quietly = TRUE)
[08:25:49.144]                         if (has_future) {
[08:25:49.144]                           ns <- base::getNamespace("future")
[08:25:49.144]                           version <- ns[[".package"]][["version"]]
[08:25:49.144]                           if (is.null(version)) 
[08:25:49.144]                             version <- utils::packageVersion("future")
[08:25:49.144]                         }
[08:25:49.144]                         else {
[08:25:49.144]                           version <- NULL
[08:25:49.144]                         }
[08:25:49.144]                         if (!has_future || version < "1.8.0") {
[08:25:49.144]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.144]                             "", base::R.version$version.string), 
[08:25:49.144]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.144]                               "release", "version")], collapse = " "), 
[08:25:49.144]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.144]                             info)
[08:25:49.144]                           info <- base::paste(info, collapse = "; ")
[08:25:49.144]                           if (!has_future) {
[08:25:49.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.144]                               info)
[08:25:49.144]                           }
[08:25:49.144]                           else {
[08:25:49.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.144]                               info, version)
[08:25:49.144]                           }
[08:25:49.144]                           base::stop(msg)
[08:25:49.144]                         }
[08:25:49.144]                       })
[08:25:49.144]                     }
[08:25:49.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.144]                     base::options(mc.cores = 1L)
[08:25:49.144]                   }
[08:25:49.144]                   ...future.strategy.old <- future::plan("list")
[08:25:49.144]                   options(future.plan = NULL)
[08:25:49.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.144]                 }
[08:25:49.144]                 ...future.workdir <- getwd()
[08:25:49.144]             }
[08:25:49.144]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.144]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.144]         }
[08:25:49.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.144]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.144]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.144]             base::names(...future.oldOptions))
[08:25:49.144]     }
[08:25:49.144]     if (FALSE) {
[08:25:49.144]     }
[08:25:49.144]     else {
[08:25:49.144]         if (TRUE) {
[08:25:49.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.144]                 open = "w")
[08:25:49.144]         }
[08:25:49.144]         else {
[08:25:49.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.144]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.144]         }
[08:25:49.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.144]             base::sink(type = "output", split = FALSE)
[08:25:49.144]             base::close(...future.stdout)
[08:25:49.144]         }, add = TRUE)
[08:25:49.144]     }
[08:25:49.144]     ...future.frame <- base::sys.nframe()
[08:25:49.144]     ...future.conditions <- base::list()
[08:25:49.144]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.144]     if (FALSE) {
[08:25:49.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.144]     }
[08:25:49.144]     ...future.result <- base::tryCatch({
[08:25:49.144]         base::withCallingHandlers({
[08:25:49.144]             ...future.value <- base::withVisible(base::local({
[08:25:49.144]                 withCallingHandlers({
[08:25:49.144]                   {
[08:25:49.144]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.144]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.144]                       ...future.globals.maxSize)) {
[08:25:49.144]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.144]                       on.exit(options(oopts), add = TRUE)
[08:25:49.144]                     }
[08:25:49.144]                     {
[08:25:49.144]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.144]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.144]                         USE.NAMES = FALSE)
[08:25:49.144]                       do.call(mapply, args = args)
[08:25:49.144]                     }
[08:25:49.144]                   }
[08:25:49.144]                 }, immediateCondition = function(cond) {
[08:25:49.144]                   save_rds <- function (object, pathname, ...) 
[08:25:49.144]                   {
[08:25:49.144]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.144]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.144]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.144]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.144]                         fi_tmp[["mtime"]])
[08:25:49.144]                     }
[08:25:49.144]                     tryCatch({
[08:25:49.144]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.144]                     }, error = function(ex) {
[08:25:49.144]                       msg <- conditionMessage(ex)
[08:25:49.144]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.144]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.144]                         fi_tmp[["mtime"]], msg)
[08:25:49.144]                       ex$message <- msg
[08:25:49.144]                       stop(ex)
[08:25:49.144]                     })
[08:25:49.144]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.144]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.144]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.144]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.144]                       fi <- file.info(pathname)
[08:25:49.144]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.144]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.144]                         fi[["size"]], fi[["mtime"]])
[08:25:49.144]                       stop(msg)
[08:25:49.144]                     }
[08:25:49.144]                     invisible(pathname)
[08:25:49.144]                   }
[08:25:49.144]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.144]                     rootPath = tempdir()) 
[08:25:49.144]                   {
[08:25:49.144]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.144]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.144]                       tmpdir = path, fileext = ".rds")
[08:25:49.144]                     save_rds(obj, file)
[08:25:49.144]                   }
[08:25:49.144]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.144]                   {
[08:25:49.144]                     inherits <- base::inherits
[08:25:49.144]                     invokeRestart <- base::invokeRestart
[08:25:49.144]                     is.null <- base::is.null
[08:25:49.144]                     muffled <- FALSE
[08:25:49.144]                     if (inherits(cond, "message")) {
[08:25:49.144]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.144]                       if (muffled) 
[08:25:49.144]                         invokeRestart("muffleMessage")
[08:25:49.144]                     }
[08:25:49.144]                     else if (inherits(cond, "warning")) {
[08:25:49.144]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.144]                       if (muffled) 
[08:25:49.144]                         invokeRestart("muffleWarning")
[08:25:49.144]                     }
[08:25:49.144]                     else if (inherits(cond, "condition")) {
[08:25:49.144]                       if (!is.null(pattern)) {
[08:25:49.144]                         computeRestarts <- base::computeRestarts
[08:25:49.144]                         grepl <- base::grepl
[08:25:49.144]                         restarts <- computeRestarts(cond)
[08:25:49.144]                         for (restart in restarts) {
[08:25:49.144]                           name <- restart$name
[08:25:49.144]                           if (is.null(name)) 
[08:25:49.144]                             next
[08:25:49.144]                           if (!grepl(pattern, name)) 
[08:25:49.144]                             next
[08:25:49.144]                           invokeRestart(restart)
[08:25:49.144]                           muffled <- TRUE
[08:25:49.144]                           break
[08:25:49.144]                         }
[08:25:49.144]                       }
[08:25:49.144]                     }
[08:25:49.144]                     invisible(muffled)
[08:25:49.144]                   }
[08:25:49.144]                   muffleCondition(cond)
[08:25:49.144]                 })
[08:25:49.144]             }))
[08:25:49.144]             future::FutureResult(value = ...future.value$value, 
[08:25:49.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.144]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.144]                     ...future.globalenv.names))
[08:25:49.144]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.144]         }, condition = base::local({
[08:25:49.144]             c <- base::c
[08:25:49.144]             inherits <- base::inherits
[08:25:49.144]             invokeRestart <- base::invokeRestart
[08:25:49.144]             length <- base::length
[08:25:49.144]             list <- base::list
[08:25:49.144]             seq.int <- base::seq.int
[08:25:49.144]             signalCondition <- base::signalCondition
[08:25:49.144]             sys.calls <- base::sys.calls
[08:25:49.144]             `[[` <- base::`[[`
[08:25:49.144]             `+` <- base::`+`
[08:25:49.144]             `<<-` <- base::`<<-`
[08:25:49.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.144]                   3L)]
[08:25:49.144]             }
[08:25:49.144]             function(cond) {
[08:25:49.144]                 is_error <- inherits(cond, "error")
[08:25:49.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.144]                   NULL)
[08:25:49.144]                 if (is_error) {
[08:25:49.144]                   sessionInformation <- function() {
[08:25:49.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.144]                       search = base::search(), system = base::Sys.info())
[08:25:49.144]                   }
[08:25:49.144]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.144]                     cond$call), session = sessionInformation(), 
[08:25:49.144]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.144]                   signalCondition(cond)
[08:25:49.144]                 }
[08:25:49.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.144]                 "immediateCondition"))) {
[08:25:49.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.144]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.144]                   if (TRUE && !signal) {
[08:25:49.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.144]                     {
[08:25:49.144]                       inherits <- base::inherits
[08:25:49.144]                       invokeRestart <- base::invokeRestart
[08:25:49.144]                       is.null <- base::is.null
[08:25:49.144]                       muffled <- FALSE
[08:25:49.144]                       if (inherits(cond, "message")) {
[08:25:49.144]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.144]                         if (muffled) 
[08:25:49.144]                           invokeRestart("muffleMessage")
[08:25:49.144]                       }
[08:25:49.144]                       else if (inherits(cond, "warning")) {
[08:25:49.144]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.144]                         if (muffled) 
[08:25:49.144]                           invokeRestart("muffleWarning")
[08:25:49.144]                       }
[08:25:49.144]                       else if (inherits(cond, "condition")) {
[08:25:49.144]                         if (!is.null(pattern)) {
[08:25:49.144]                           computeRestarts <- base::computeRestarts
[08:25:49.144]                           grepl <- base::grepl
[08:25:49.144]                           restarts <- computeRestarts(cond)
[08:25:49.144]                           for (restart in restarts) {
[08:25:49.144]                             name <- restart$name
[08:25:49.144]                             if (is.null(name)) 
[08:25:49.144]                               next
[08:25:49.144]                             if (!grepl(pattern, name)) 
[08:25:49.144]                               next
[08:25:49.144]                             invokeRestart(restart)
[08:25:49.144]                             muffled <- TRUE
[08:25:49.144]                             break
[08:25:49.144]                           }
[08:25:49.144]                         }
[08:25:49.144]                       }
[08:25:49.144]                       invisible(muffled)
[08:25:49.144]                     }
[08:25:49.144]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.144]                   }
[08:25:49.144]                 }
[08:25:49.144]                 else {
[08:25:49.144]                   if (TRUE) {
[08:25:49.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.144]                     {
[08:25:49.144]                       inherits <- base::inherits
[08:25:49.144]                       invokeRestart <- base::invokeRestart
[08:25:49.144]                       is.null <- base::is.null
[08:25:49.144]                       muffled <- FALSE
[08:25:49.144]                       if (inherits(cond, "message")) {
[08:25:49.144]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.144]                         if (muffled) 
[08:25:49.144]                           invokeRestart("muffleMessage")
[08:25:49.144]                       }
[08:25:49.144]                       else if (inherits(cond, "warning")) {
[08:25:49.144]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.144]                         if (muffled) 
[08:25:49.144]                           invokeRestart("muffleWarning")
[08:25:49.144]                       }
[08:25:49.144]                       else if (inherits(cond, "condition")) {
[08:25:49.144]                         if (!is.null(pattern)) {
[08:25:49.144]                           computeRestarts <- base::computeRestarts
[08:25:49.144]                           grepl <- base::grepl
[08:25:49.144]                           restarts <- computeRestarts(cond)
[08:25:49.144]                           for (restart in restarts) {
[08:25:49.144]                             name <- restart$name
[08:25:49.144]                             if (is.null(name)) 
[08:25:49.144]                               next
[08:25:49.144]                             if (!grepl(pattern, name)) 
[08:25:49.144]                               next
[08:25:49.144]                             invokeRestart(restart)
[08:25:49.144]                             muffled <- TRUE
[08:25:49.144]                             break
[08:25:49.144]                           }
[08:25:49.144]                         }
[08:25:49.144]                       }
[08:25:49.144]                       invisible(muffled)
[08:25:49.144]                     }
[08:25:49.144]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.144]                   }
[08:25:49.144]                 }
[08:25:49.144]             }
[08:25:49.144]         }))
[08:25:49.144]     }, error = function(ex) {
[08:25:49.144]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.144]                 ...future.rng), started = ...future.startTime, 
[08:25:49.144]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.144]             version = "1.8"), class = "FutureResult")
[08:25:49.144]     }, finally = {
[08:25:49.144]         if (!identical(...future.workdir, getwd())) 
[08:25:49.144]             setwd(...future.workdir)
[08:25:49.144]         {
[08:25:49.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.144]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.144]             }
[08:25:49.144]             base::options(...future.oldOptions)
[08:25:49.144]             if (.Platform$OS.type == "windows") {
[08:25:49.144]                 old_names <- names(...future.oldEnvVars)
[08:25:49.144]                 envs <- base::Sys.getenv()
[08:25:49.144]                 names <- names(envs)
[08:25:49.144]                 common <- intersect(names, old_names)
[08:25:49.144]                 added <- setdiff(names, old_names)
[08:25:49.144]                 removed <- setdiff(old_names, names)
[08:25:49.144]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.144]                   envs[common]]
[08:25:49.144]                 NAMES <- toupper(changed)
[08:25:49.144]                 args <- list()
[08:25:49.144]                 for (kk in seq_along(NAMES)) {
[08:25:49.144]                   name <- changed[[kk]]
[08:25:49.144]                   NAME <- NAMES[[kk]]
[08:25:49.144]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.144]                     next
[08:25:49.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.144]                 }
[08:25:49.144]                 NAMES <- toupper(added)
[08:25:49.144]                 for (kk in seq_along(NAMES)) {
[08:25:49.144]                   name <- added[[kk]]
[08:25:49.144]                   NAME <- NAMES[[kk]]
[08:25:49.144]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.144]                     next
[08:25:49.144]                   args[[name]] <- ""
[08:25:49.144]                 }
[08:25:49.144]                 NAMES <- toupper(removed)
[08:25:49.144]                 for (kk in seq_along(NAMES)) {
[08:25:49.144]                   name <- removed[[kk]]
[08:25:49.144]                   NAME <- NAMES[[kk]]
[08:25:49.144]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.144]                     next
[08:25:49.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.144]                 }
[08:25:49.144]                 if (length(args) > 0) 
[08:25:49.144]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.144]             }
[08:25:49.144]             else {
[08:25:49.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.144]             }
[08:25:49.144]             {
[08:25:49.144]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.144]                   0L) {
[08:25:49.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.144]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.144]                   base::options(opts)
[08:25:49.144]                 }
[08:25:49.144]                 {
[08:25:49.144]                   {
[08:25:49.144]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.144]                     NULL
[08:25:49.144]                   }
[08:25:49.144]                   options(future.plan = NULL)
[08:25:49.144]                   if (is.na(NA_character_)) 
[08:25:49.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.144]                     .init = FALSE)
[08:25:49.144]                 }
[08:25:49.144]             }
[08:25:49.144]         }
[08:25:49.144]     })
[08:25:49.144]     if (TRUE) {
[08:25:49.144]         base::sink(type = "output", split = FALSE)
[08:25:49.144]         if (TRUE) {
[08:25:49.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.144]         }
[08:25:49.144]         else {
[08:25:49.144]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.144]         }
[08:25:49.144]         base::close(...future.stdout)
[08:25:49.144]         ...future.stdout <- NULL
[08:25:49.144]     }
[08:25:49.144]     ...future.result$conditions <- ...future.conditions
[08:25:49.144]     ...future.result$finished <- base::Sys.time()
[08:25:49.144]     ...future.result
[08:25:49.144] }
[08:25:49.147] assign_globals() ...
[08:25:49.147] List of 5
[08:25:49.147]  $ ...future.FUN            :function (C, k)  
[08:25:49.147]  $ MoreArgs                 : list()
[08:25:49.147]  $ ...future.elements_ii    :List of 2
[08:25:49.147]   ..$ :List of 3
[08:25:49.147]   .. ..$ : chr "C"
[08:25:49.147]   .. ..$ : chr "D"
[08:25:49.147]   .. ..$ : chr "E"
[08:25:49.147]   ..$ :List of 3
[08:25:49.147]   .. ..$ : int 3
[08:25:49.147]   .. ..$ : int 2
[08:25:49.147]   .. ..$ : int 1
[08:25:49.147]  $ ...future.seeds_ii       : NULL
[08:25:49.147]  $ ...future.globals.maxSize: NULL
[08:25:49.147]  - attr(*, "where")=List of 5
[08:25:49.147]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.147]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.147]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.147]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.147]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.147]  - attr(*, "resolved")= logi FALSE
[08:25:49.147]  - attr(*, "total_size")= num 909
[08:25:49.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.147]  - attr(*, "already-done")= logi TRUE
[08:25:49.163] - reassign environment for ‘...future.FUN’
[08:25:49.163] - copied ‘...future.FUN’ to environment
[08:25:49.164] - copied ‘MoreArgs’ to environment
[08:25:49.164] - copied ‘...future.elements_ii’ to environment
[08:25:49.164] - copied ‘...future.seeds_ii’ to environment
[08:25:49.164] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.164] assign_globals() ... done
[08:25:49.164] requestCore(): workers = 2
[08:25:49.167] MulticoreFuture started
[08:25:49.168] - Launch lazy future ... done
[08:25:49.168] run() for ‘MulticoreFuture’ ... done
[08:25:49.168] plan(): Setting new future strategy stack:
[08:25:49.168] Created future:
[08:25:49.169] List of future strategies:
[08:25:49.169] 1. sequential:
[08:25:49.169]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.169]    - tweaked: FALSE
[08:25:49.169]    - call: NULL
[08:25:49.170] plan(): nbrOfWorkers() = 1
[08:25:49.173] plan(): Setting new future strategy stack:
[08:25:49.173] List of future strategies:
[08:25:49.173] 1. multicore:
[08:25:49.173]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.173]    - tweaked: FALSE
[08:25:49.173]    - call: plan(strategy)
[08:25:49.176] plan(): nbrOfWorkers() = 2
[08:25:49.169] MulticoreFuture:
[08:25:49.169] Label: ‘future_.mapply-2’
[08:25:49.169] Expression:
[08:25:49.169] {
[08:25:49.169]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.169]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.169]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.169]         on.exit(options(oopts), add = TRUE)
[08:25:49.169]     }
[08:25:49.169]     {
[08:25:49.169]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.169]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.169]         do.call(mapply, args = args)
[08:25:49.169]     }
[08:25:49.169] }
[08:25:49.169] Lazy evaluation: FALSE
[08:25:49.169] Asynchronous evaluation: TRUE
[08:25:49.169] Local evaluation: TRUE
[08:25:49.169] Environment: R_GlobalEnv
[08:25:49.169] Capture standard output: TRUE
[08:25:49.169] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.169] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.169] Packages: <none>
[08:25:49.169] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.169] Resolved: TRUE
[08:25:49.169] Value: <not collected>
[08:25:49.169] Conditions captured: <none>
[08:25:49.169] Early signaling: FALSE
[08:25:49.169] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.169] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.178] Chunk #2 of 2 ... DONE
[08:25:49.178] Launching 2 futures (chunks) ... DONE
[08:25:49.178] Resolving 2 futures (chunks) ...
[08:25:49.178] resolve() on list ...
[08:25:49.178]  recursive: 0
[08:25:49.179]  length: 2
[08:25:49.179] 
[08:25:49.179] Future #1
[08:25:49.179] result() for MulticoreFuture ...
[08:25:49.180] result() for MulticoreFuture ...
[08:25:49.180] result() for MulticoreFuture ... done
[08:25:49.181] result() for MulticoreFuture ... done
[08:25:49.181] result() for MulticoreFuture ...
[08:25:49.181] result() for MulticoreFuture ... done
[08:25:49.181] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:49.181] - nx: 2
[08:25:49.181] - relay: TRUE
[08:25:49.182] - stdout: TRUE
[08:25:49.182] - signal: TRUE
[08:25:49.182] - resignal: FALSE
[08:25:49.182] - force: TRUE
[08:25:49.182] - relayed: [n=2] FALSE, FALSE
[08:25:49.182] - queued futures: [n=2] FALSE, FALSE
[08:25:49.182]  - until=1
[08:25:49.183]  - relaying element #1
[08:25:49.183] result() for MulticoreFuture ...
[08:25:49.183] result() for MulticoreFuture ... done
[08:25:49.183] result() for MulticoreFuture ...
[08:25:49.183] result() for MulticoreFuture ... done
[08:25:49.183] result() for MulticoreFuture ...
[08:25:49.183] result() for MulticoreFuture ... done
[08:25:49.184] result() for MulticoreFuture ...
[08:25:49.184] result() for MulticoreFuture ... done
[08:25:49.184] - relayed: [n=2] TRUE, FALSE
[08:25:49.184] - queued futures: [n=2] TRUE, FALSE
[08:25:49.184] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:49.184]  length: 1 (resolved future 1)
[08:25:49.185] Future #2
[08:25:49.185] result() for MulticoreFuture ...
[08:25:49.185] result() for MulticoreFuture ...
[08:25:49.186] result() for MulticoreFuture ... done
[08:25:49.186] result() for MulticoreFuture ... done
[08:25:49.186] result() for MulticoreFuture ...
[08:25:49.186] result() for MulticoreFuture ... done
[08:25:49.186] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:49.186] - nx: 2
[08:25:49.186] - relay: TRUE
[08:25:49.186] - stdout: TRUE
[08:25:49.187] - signal: TRUE
[08:25:49.187] - resignal: FALSE
[08:25:49.187] - force: TRUE
[08:25:49.187] - relayed: [n=2] TRUE, FALSE
[08:25:49.187] - queued futures: [n=2] TRUE, FALSE
[08:25:49.187]  - until=2
[08:25:49.187]  - relaying element #2
[08:25:49.187] result() for MulticoreFuture ...
[08:25:49.188] result() for MulticoreFuture ... done
[08:25:49.188] result() for MulticoreFuture ...
[08:25:49.188] result() for MulticoreFuture ... done
[08:25:49.188] result() for MulticoreFuture ...
[08:25:49.188] result() for MulticoreFuture ... done
[08:25:49.188] result() for MulticoreFuture ...
[08:25:49.188] result() for MulticoreFuture ... done
[08:25:49.188] - relayed: [n=2] TRUE, TRUE
[08:25:49.189] - queued futures: [n=2] TRUE, TRUE
[08:25:49.189] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:49.189]  length: 0 (resolved future 2)
[08:25:49.189] Relaying remaining futures
[08:25:49.189] signalConditionsASAP(NULL, pos=0) ...
[08:25:49.189] - nx: 2
[08:25:49.189] - relay: TRUE
[08:25:49.189] - stdout: TRUE
[08:25:49.189] - signal: TRUE
[08:25:49.190] - resignal: FALSE
[08:25:49.190] - force: TRUE
[08:25:49.190] - relayed: [n=2] TRUE, TRUE
[08:25:49.190] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:49.190] - relayed: [n=2] TRUE, TRUE
[08:25:49.190] - queued futures: [n=2] TRUE, TRUE
[08:25:49.190] signalConditionsASAP(NULL, pos=0) ... done
[08:25:49.190] resolve() on list ... DONE
[08:25:49.191] result() for MulticoreFuture ...
[08:25:49.191] result() for MulticoreFuture ... done
[08:25:49.191] result() for MulticoreFuture ...
[08:25:49.191] result() for MulticoreFuture ... done
[08:25:49.191] result() for MulticoreFuture ...
[08:25:49.191] result() for MulticoreFuture ... done
[08:25:49.191] result() for MulticoreFuture ...
[08:25:49.191] result() for MulticoreFuture ... done
[08:25:49.192]  - Number of value chunks collected: 2
[08:25:49.192] Resolving 2 futures (chunks) ... DONE
[08:25:49.192] Reducing values from 2 chunks ...
[08:25:49.192]  - Number of values collected after concatenation: 5
[08:25:49.192]  - Number of values expected: 5
[08:25:49.192] Reducing values from 2 chunks ... DONE
[08:25:49.192] future_mapply() ... DONE
[08:25:49.193] future_mapply() ...
[08:25:49.195] Number of chunks: 3
[08:25:49.195] Index remapping (attribute 'ordering'): [n = 5] 3, 4, 2, 5, 1
[08:25:49.198] getGlobalsAndPackagesXApply() ...
[08:25:49.198]  - future.globals: TRUE
[08:25:49.198] getGlobalsAndPackages() ...
[08:25:49.198] Searching for globals...
[08:25:49.201] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:49.201] Searching for globals ... DONE
[08:25:49.201] Resolving globals: FALSE
[08:25:49.202] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:49.202] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:49.202] - globals: [1] ‘FUN’
[08:25:49.202] 
[08:25:49.203] getGlobalsAndPackages() ... DONE
[08:25:49.203]  - globals found/used: [n=1] ‘FUN’
[08:25:49.203]  - needed namespaces: [n=0] 
[08:25:49.203] Finding globals ... DONE
[08:25:49.203] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:49.203] List of 2
[08:25:49.203]  $ ...future.FUN:function (C, k)  
[08:25:49.203]  $ MoreArgs     : NULL
[08:25:49.203]  - attr(*, "where")=List of 2
[08:25:49.203]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:49.203]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:49.203]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.203]  - attr(*, "resolved")= logi FALSE
[08:25:49.203]  - attr(*, "total_size")= num NA
[08:25:49.207] Packages to be attached in all futures: [n=0] 
[08:25:49.207] getGlobalsAndPackagesXApply() ... DONE
[08:25:49.208] Number of futures (= number of chunks): 3
[08:25:49.208] Launching 3 futures (chunks) ...
[08:25:49.208] Chunk #1 of 3 ...
[08:25:49.208]  - Finding globals in '...' for chunk #1 ...
[08:25:49.208] getGlobalsAndPackages() ...
[08:25:49.208] Searching for globals...
[08:25:49.209] 
[08:25:49.209] Searching for globals ... DONE
[08:25:49.209] - globals: [0] <none>
[08:25:49.209] getGlobalsAndPackages() ... DONE
[08:25:49.209]    + additional globals found: [n=0] 
[08:25:49.209]    + additional namespaces needed: [n=0] 
[08:25:49.209]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:49.209]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[08:25:49.209]  - seeds: <none>
[08:25:49.209]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.210] getGlobalsAndPackages() ...
[08:25:49.210] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.210] Resolving globals: FALSE
[08:25:49.210] The total size of the 5 globals is 876 bytes (876 bytes)
[08:25:49.211] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:49.211] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.211] 
[08:25:49.211] getGlobalsAndPackages() ... DONE
[08:25:49.211] run() for ‘Future’ ...
[08:25:49.212] - state: ‘created’
[08:25:49.212] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.213] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.214] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.214]   - Field: ‘label’
[08:25:49.214]   - Field: ‘local’
[08:25:49.214]   - Field: ‘owner’
[08:25:49.214]   - Field: ‘envir’
[08:25:49.214]   - Field: ‘workers’
[08:25:49.214]   - Field: ‘packages’
[08:25:49.214]   - Field: ‘gc’
[08:25:49.214]   - Field: ‘job’
[08:25:49.215]   - Field: ‘conditions’
[08:25:49.215]   - Field: ‘expr’
[08:25:49.215]   - Field: ‘uuid’
[08:25:49.215]   - Field: ‘seed’
[08:25:49.215]   - Field: ‘version’
[08:25:49.215]   - Field: ‘result’
[08:25:49.215]   - Field: ‘asynchronous’
[08:25:49.215]   - Field: ‘calls’
[08:25:49.215]   - Field: ‘globals’
[08:25:49.215]   - Field: ‘stdout’
[08:25:49.215]   - Field: ‘earlySignal’
[08:25:49.216]   - Field: ‘lazy’
[08:25:49.216]   - Field: ‘state’
[08:25:49.216] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.216] - Launch lazy future ...
[08:25:49.216] Packages needed by the future expression (n = 0): <none>
[08:25:49.216] Packages needed by future strategies (n = 0): <none>
[08:25:49.217] {
[08:25:49.217]     {
[08:25:49.217]         {
[08:25:49.217]             ...future.startTime <- base::Sys.time()
[08:25:49.217]             {
[08:25:49.217]                 {
[08:25:49.217]                   {
[08:25:49.217]                     {
[08:25:49.217]                       base::local({
[08:25:49.217]                         has_future <- base::requireNamespace("future", 
[08:25:49.217]                           quietly = TRUE)
[08:25:49.217]                         if (has_future) {
[08:25:49.217]                           ns <- base::getNamespace("future")
[08:25:49.217]                           version <- ns[[".package"]][["version"]]
[08:25:49.217]                           if (is.null(version)) 
[08:25:49.217]                             version <- utils::packageVersion("future")
[08:25:49.217]                         }
[08:25:49.217]                         else {
[08:25:49.217]                           version <- NULL
[08:25:49.217]                         }
[08:25:49.217]                         if (!has_future || version < "1.8.0") {
[08:25:49.217]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.217]                             "", base::R.version$version.string), 
[08:25:49.217]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.217]                               "release", "version")], collapse = " "), 
[08:25:49.217]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.217]                             info)
[08:25:49.217]                           info <- base::paste(info, collapse = "; ")
[08:25:49.217]                           if (!has_future) {
[08:25:49.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.217]                               info)
[08:25:49.217]                           }
[08:25:49.217]                           else {
[08:25:49.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.217]                               info, version)
[08:25:49.217]                           }
[08:25:49.217]                           base::stop(msg)
[08:25:49.217]                         }
[08:25:49.217]                       })
[08:25:49.217]                     }
[08:25:49.217]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.217]                     base::options(mc.cores = 1L)
[08:25:49.217]                   }
[08:25:49.217]                   ...future.strategy.old <- future::plan("list")
[08:25:49.217]                   options(future.plan = NULL)
[08:25:49.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.217]                 }
[08:25:49.217]                 ...future.workdir <- getwd()
[08:25:49.217]             }
[08:25:49.217]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.217]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.217]         }
[08:25:49.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.217]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[08:25:49.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.217]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.217]             base::names(...future.oldOptions))
[08:25:49.217]     }
[08:25:49.217]     if (FALSE) {
[08:25:49.217]     }
[08:25:49.217]     else {
[08:25:49.217]         if (TRUE) {
[08:25:49.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.217]                 open = "w")
[08:25:49.217]         }
[08:25:49.217]         else {
[08:25:49.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.217]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.217]         }
[08:25:49.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.217]             base::sink(type = "output", split = FALSE)
[08:25:49.217]             base::close(...future.stdout)
[08:25:49.217]         }, add = TRUE)
[08:25:49.217]     }
[08:25:49.217]     ...future.frame <- base::sys.nframe()
[08:25:49.217]     ...future.conditions <- base::list()
[08:25:49.217]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.217]     if (FALSE) {
[08:25:49.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.217]     }
[08:25:49.217]     ...future.result <- base::tryCatch({
[08:25:49.217]         base::withCallingHandlers({
[08:25:49.217]             ...future.value <- base::withVisible(base::local({
[08:25:49.217]                 withCallingHandlers({
[08:25:49.217]                   {
[08:25:49.217]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.217]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.217]                       ...future.globals.maxSize)) {
[08:25:49.217]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.217]                       on.exit(options(oopts), add = TRUE)
[08:25:49.217]                     }
[08:25:49.217]                     {
[08:25:49.217]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.217]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.217]                         USE.NAMES = FALSE)
[08:25:49.217]                       do.call(mapply, args = args)
[08:25:49.217]                     }
[08:25:49.217]                   }
[08:25:49.217]                 }, immediateCondition = function(cond) {
[08:25:49.217]                   save_rds <- function (object, pathname, ...) 
[08:25:49.217]                   {
[08:25:49.217]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.217]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.217]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.217]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.217]                         fi_tmp[["mtime"]])
[08:25:49.217]                     }
[08:25:49.217]                     tryCatch({
[08:25:49.217]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.217]                     }, error = function(ex) {
[08:25:49.217]                       msg <- conditionMessage(ex)
[08:25:49.217]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.217]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.217]                         fi_tmp[["mtime"]], msg)
[08:25:49.217]                       ex$message <- msg
[08:25:49.217]                       stop(ex)
[08:25:49.217]                     })
[08:25:49.217]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.217]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.217]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.217]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.217]                       fi <- file.info(pathname)
[08:25:49.217]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.217]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.217]                         fi[["size"]], fi[["mtime"]])
[08:25:49.217]                       stop(msg)
[08:25:49.217]                     }
[08:25:49.217]                     invisible(pathname)
[08:25:49.217]                   }
[08:25:49.217]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.217]                     rootPath = tempdir()) 
[08:25:49.217]                   {
[08:25:49.217]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.217]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.217]                       tmpdir = path, fileext = ".rds")
[08:25:49.217]                     save_rds(obj, file)
[08:25:49.217]                   }
[08:25:49.217]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.217]                   {
[08:25:49.217]                     inherits <- base::inherits
[08:25:49.217]                     invokeRestart <- base::invokeRestart
[08:25:49.217]                     is.null <- base::is.null
[08:25:49.217]                     muffled <- FALSE
[08:25:49.217]                     if (inherits(cond, "message")) {
[08:25:49.217]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.217]                       if (muffled) 
[08:25:49.217]                         invokeRestart("muffleMessage")
[08:25:49.217]                     }
[08:25:49.217]                     else if (inherits(cond, "warning")) {
[08:25:49.217]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.217]                       if (muffled) 
[08:25:49.217]                         invokeRestart("muffleWarning")
[08:25:49.217]                     }
[08:25:49.217]                     else if (inherits(cond, "condition")) {
[08:25:49.217]                       if (!is.null(pattern)) {
[08:25:49.217]                         computeRestarts <- base::computeRestarts
[08:25:49.217]                         grepl <- base::grepl
[08:25:49.217]                         restarts <- computeRestarts(cond)
[08:25:49.217]                         for (restart in restarts) {
[08:25:49.217]                           name <- restart$name
[08:25:49.217]                           if (is.null(name)) 
[08:25:49.217]                             next
[08:25:49.217]                           if (!grepl(pattern, name)) 
[08:25:49.217]                             next
[08:25:49.217]                           invokeRestart(restart)
[08:25:49.217]                           muffled <- TRUE
[08:25:49.217]                           break
[08:25:49.217]                         }
[08:25:49.217]                       }
[08:25:49.217]                     }
[08:25:49.217]                     invisible(muffled)
[08:25:49.217]                   }
[08:25:49.217]                   muffleCondition(cond)
[08:25:49.217]                 })
[08:25:49.217]             }))
[08:25:49.217]             future::FutureResult(value = ...future.value$value, 
[08:25:49.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.217]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.217]                     ...future.globalenv.names))
[08:25:49.217]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.217]         }, condition = base::local({
[08:25:49.217]             c <- base::c
[08:25:49.217]             inherits <- base::inherits
[08:25:49.217]             invokeRestart <- base::invokeRestart
[08:25:49.217]             length <- base::length
[08:25:49.217]             list <- base::list
[08:25:49.217]             seq.int <- base::seq.int
[08:25:49.217]             signalCondition <- base::signalCondition
[08:25:49.217]             sys.calls <- base::sys.calls
[08:25:49.217]             `[[` <- base::`[[`
[08:25:49.217]             `+` <- base::`+`
[08:25:49.217]             `<<-` <- base::`<<-`
[08:25:49.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.217]                   3L)]
[08:25:49.217]             }
[08:25:49.217]             function(cond) {
[08:25:49.217]                 is_error <- inherits(cond, "error")
[08:25:49.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.217]                   NULL)
[08:25:49.217]                 if (is_error) {
[08:25:49.217]                   sessionInformation <- function() {
[08:25:49.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.217]                       search = base::search(), system = base::Sys.info())
[08:25:49.217]                   }
[08:25:49.217]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.217]                     cond$call), session = sessionInformation(), 
[08:25:49.217]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.217]                   signalCondition(cond)
[08:25:49.217]                 }
[08:25:49.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.217]                 "immediateCondition"))) {
[08:25:49.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.217]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.217]                   if (TRUE && !signal) {
[08:25:49.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.217]                     {
[08:25:49.217]                       inherits <- base::inherits
[08:25:49.217]                       invokeRestart <- base::invokeRestart
[08:25:49.217]                       is.null <- base::is.null
[08:25:49.217]                       muffled <- FALSE
[08:25:49.217]                       if (inherits(cond, "message")) {
[08:25:49.217]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.217]                         if (muffled) 
[08:25:49.217]                           invokeRestart("muffleMessage")
[08:25:49.217]                       }
[08:25:49.217]                       else if (inherits(cond, "warning")) {
[08:25:49.217]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.217]                         if (muffled) 
[08:25:49.217]                           invokeRestart("muffleWarning")
[08:25:49.217]                       }
[08:25:49.217]                       else if (inherits(cond, "condition")) {
[08:25:49.217]                         if (!is.null(pattern)) {
[08:25:49.217]                           computeRestarts <- base::computeRestarts
[08:25:49.217]                           grepl <- base::grepl
[08:25:49.217]                           restarts <- computeRestarts(cond)
[08:25:49.217]                           for (restart in restarts) {
[08:25:49.217]                             name <- restart$name
[08:25:49.217]                             if (is.null(name)) 
[08:25:49.217]                               next
[08:25:49.217]                             if (!grepl(pattern, name)) 
[08:25:49.217]                               next
[08:25:49.217]                             invokeRestart(restart)
[08:25:49.217]                             muffled <- TRUE
[08:25:49.217]                             break
[08:25:49.217]                           }
[08:25:49.217]                         }
[08:25:49.217]                       }
[08:25:49.217]                       invisible(muffled)
[08:25:49.217]                     }
[08:25:49.217]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.217]                   }
[08:25:49.217]                 }
[08:25:49.217]                 else {
[08:25:49.217]                   if (TRUE) {
[08:25:49.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.217]                     {
[08:25:49.217]                       inherits <- base::inherits
[08:25:49.217]                       invokeRestart <- base::invokeRestart
[08:25:49.217]                       is.null <- base::is.null
[08:25:49.217]                       muffled <- FALSE
[08:25:49.217]                       if (inherits(cond, "message")) {
[08:25:49.217]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.217]                         if (muffled) 
[08:25:49.217]                           invokeRestart("muffleMessage")
[08:25:49.217]                       }
[08:25:49.217]                       else if (inherits(cond, "warning")) {
[08:25:49.217]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.217]                         if (muffled) 
[08:25:49.217]                           invokeRestart("muffleWarning")
[08:25:49.217]                       }
[08:25:49.217]                       else if (inherits(cond, "condition")) {
[08:25:49.217]                         if (!is.null(pattern)) {
[08:25:49.217]                           computeRestarts <- base::computeRestarts
[08:25:49.217]                           grepl <- base::grepl
[08:25:49.217]                           restarts <- computeRestarts(cond)
[08:25:49.217]                           for (restart in restarts) {
[08:25:49.217]                             name <- restart$name
[08:25:49.217]                             if (is.null(name)) 
[08:25:49.217]                               next
[08:25:49.217]                             if (!grepl(pattern, name)) 
[08:25:49.217]                               next
[08:25:49.217]                             invokeRestart(restart)
[08:25:49.217]                             muffled <- TRUE
[08:25:49.217]                             break
[08:25:49.217]                           }
[08:25:49.217]                         }
[08:25:49.217]                       }
[08:25:49.217]                       invisible(muffled)
[08:25:49.217]                     }
[08:25:49.217]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.217]                   }
[08:25:49.217]                 }
[08:25:49.217]             }
[08:25:49.217]         }))
[08:25:49.217]     }, error = function(ex) {
[08:25:49.217]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.217]                 ...future.rng), started = ...future.startTime, 
[08:25:49.217]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.217]             version = "1.8"), class = "FutureResult")
[08:25:49.217]     }, finally = {
[08:25:49.217]         if (!identical(...future.workdir, getwd())) 
[08:25:49.217]             setwd(...future.workdir)
[08:25:49.217]         {
[08:25:49.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.217]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.217]             }
[08:25:49.217]             base::options(...future.oldOptions)
[08:25:49.217]             if (.Platform$OS.type == "windows") {
[08:25:49.217]                 old_names <- names(...future.oldEnvVars)
[08:25:49.217]                 envs <- base::Sys.getenv()
[08:25:49.217]                 names <- names(envs)
[08:25:49.217]                 common <- intersect(names, old_names)
[08:25:49.217]                 added <- setdiff(names, old_names)
[08:25:49.217]                 removed <- setdiff(old_names, names)
[08:25:49.217]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.217]                   envs[common]]
[08:25:49.217]                 NAMES <- toupper(changed)
[08:25:49.217]                 args <- list()
[08:25:49.217]                 for (kk in seq_along(NAMES)) {
[08:25:49.217]                   name <- changed[[kk]]
[08:25:49.217]                   NAME <- NAMES[[kk]]
[08:25:49.217]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.217]                     next
[08:25:49.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.217]                 }
[08:25:49.217]                 NAMES <- toupper(added)
[08:25:49.217]                 for (kk in seq_along(NAMES)) {
[08:25:49.217]                   name <- added[[kk]]
[08:25:49.217]                   NAME <- NAMES[[kk]]
[08:25:49.217]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.217]                     next
[08:25:49.217]                   args[[name]] <- ""
[08:25:49.217]                 }
[08:25:49.217]                 NAMES <- toupper(removed)
[08:25:49.217]                 for (kk in seq_along(NAMES)) {
[08:25:49.217]                   name <- removed[[kk]]
[08:25:49.217]                   NAME <- NAMES[[kk]]
[08:25:49.217]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.217]                     next
[08:25:49.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.217]                 }
[08:25:49.217]                 if (length(args) > 0) 
[08:25:49.217]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.217]             }
[08:25:49.217]             else {
[08:25:49.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.217]             }
[08:25:49.217]             {
[08:25:49.217]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.217]                   0L) {
[08:25:49.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.217]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.217]                   base::options(opts)
[08:25:49.217]                 }
[08:25:49.217]                 {
[08:25:49.217]                   {
[08:25:49.217]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.217]                     NULL
[08:25:49.217]                   }
[08:25:49.217]                   options(future.plan = NULL)
[08:25:49.217]                   if (is.na(NA_character_)) 
[08:25:49.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.217]                     .init = FALSE)
[08:25:49.217]                 }
[08:25:49.217]             }
[08:25:49.217]         }
[08:25:49.217]     })
[08:25:49.217]     if (TRUE) {
[08:25:49.217]         base::sink(type = "output", split = FALSE)
[08:25:49.217]         if (TRUE) {
[08:25:49.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.217]         }
[08:25:49.217]         else {
[08:25:49.217]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.217]         }
[08:25:49.217]         base::close(...future.stdout)
[08:25:49.217]         ...future.stdout <- NULL
[08:25:49.217]     }
[08:25:49.217]     ...future.result$conditions <- ...future.conditions
[08:25:49.217]     ...future.result$finished <- base::Sys.time()
[08:25:49.217]     ...future.result
[08:25:49.217] }
[08:25:49.219] assign_globals() ...
[08:25:49.220] List of 5
[08:25:49.220]  $ ...future.FUN            :function (C, k)  
[08:25:49.220]  $ MoreArgs                 : NULL
[08:25:49.220]  $ ...future.elements_ii    :List of 2
[08:25:49.220]   ..$ :List of 2
[08:25:49.220]   .. ..$ : chr "C"
[08:25:49.220]   .. ..$ : chr "D"
[08:25:49.220]   ..$ :List of 2
[08:25:49.220]   .. ..$ : int 3
[08:25:49.220]   .. ..$ : int 2
[08:25:49.220]  $ ...future.seeds_ii       : NULL
[08:25:49.220]  $ ...future.globals.maxSize: NULL
[08:25:49.220]  - attr(*, "where")=List of 5
[08:25:49.220]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.220]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.220]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.220]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.220]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.220]  - attr(*, "resolved")= logi FALSE
[08:25:49.220]  - attr(*, "total_size")= num 876
[08:25:49.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.220]  - attr(*, "already-done")= logi TRUE
[08:25:49.228] - reassign environment for ‘...future.FUN’
[08:25:49.228] - copied ‘...future.FUN’ to environment
[08:25:49.229] - copied ‘MoreArgs’ to environment
[08:25:49.229] - copied ‘...future.elements_ii’ to environment
[08:25:49.229] - copied ‘...future.seeds_ii’ to environment
[08:25:49.229] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.229] assign_globals() ... done
[08:25:49.229] requestCore(): workers = 2
[08:25:49.232] MulticoreFuture started
[08:25:49.233] - Launch lazy future ... done
[08:25:49.233] plan(): Setting new future strategy stack:
[08:25:49.233] run() for ‘MulticoreFuture’ ... done
[08:25:49.234] Created future:
[08:25:49.233] List of future strategies:
[08:25:49.233] 1. sequential:
[08:25:49.233]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.233]    - tweaked: FALSE
[08:25:49.233]    - call: NULL
[08:25:49.235] plan(): nbrOfWorkers() = 1
[08:25:49.239] plan(): Setting new future strategy stack:
[08:25:49.239] List of future strategies:
[08:25:49.239] 1. multicore:
[08:25:49.239]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.239]    - tweaked: FALSE
[08:25:49.239]    - call: plan(strategy)
[08:25:49.243] plan(): nbrOfWorkers() = 2
[08:25:49.234] MulticoreFuture:
[08:25:49.234] Label: ‘future_mapply-1’
[08:25:49.234] Expression:
[08:25:49.234] {
[08:25:49.234]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.234]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.234]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.234]         on.exit(options(oopts), add = TRUE)
[08:25:49.234]     }
[08:25:49.234]     {
[08:25:49.234]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.234]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.234]         do.call(mapply, args = args)
[08:25:49.234]     }
[08:25:49.234] }
[08:25:49.234] Lazy evaluation: FALSE
[08:25:49.234] Asynchronous evaluation: TRUE
[08:25:49.234] Local evaluation: TRUE
[08:25:49.234] Environment: R_GlobalEnv
[08:25:49.234] Capture standard output: TRUE
[08:25:49.234] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.234] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.234] Packages: <none>
[08:25:49.234] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.234] Resolved: TRUE
[08:25:49.234] Value: <not collected>
[08:25:49.234] Conditions captured: <none>
[08:25:49.234] Early signaling: FALSE
[08:25:49.234] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.234] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.245] Chunk #1 of 3 ... DONE
[08:25:49.245] Chunk #2 of 3 ...
[08:25:49.245]  - Finding globals in '...' for chunk #2 ...
[08:25:49.245] getGlobalsAndPackages() ...
[08:25:49.246] Searching for globals...
[08:25:49.246] 
[08:25:49.247] Searching for globals ... DONE
[08:25:49.247] - globals: [0] <none>
[08:25:49.247] getGlobalsAndPackages() ... DONE
[08:25:49.247]    + additional globals found: [n=0] 
[08:25:49.247]    + additional namespaces needed: [n=0] 
[08:25:49.248]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:49.248]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[08:25:49.248]  - seeds: <none>
[08:25:49.248]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.248] getGlobalsAndPackages() ...
[08:25:49.248] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.249] Resolving globals: FALSE
[08:25:49.250] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:49.250] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:49.251] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.251] 
[08:25:49.251] getGlobalsAndPackages() ... DONE
[08:25:49.251] run() for ‘Future’ ...
[08:25:49.252] - state: ‘created’
[08:25:49.252] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.255] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.255] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.255]   - Field: ‘label’
[08:25:49.255]   - Field: ‘local’
[08:25:49.255]   - Field: ‘owner’
[08:25:49.255]   - Field: ‘envir’
[08:25:49.255]   - Field: ‘workers’
[08:25:49.256]   - Field: ‘packages’
[08:25:49.256]   - Field: ‘gc’
[08:25:49.256]   - Field: ‘job’
[08:25:49.256]   - Field: ‘conditions’
[08:25:49.256]   - Field: ‘expr’
[08:25:49.256]   - Field: ‘uuid’
[08:25:49.256]   - Field: ‘seed’
[08:25:49.257]   - Field: ‘version’
[08:25:49.257]   - Field: ‘result’
[08:25:49.257]   - Field: ‘asynchronous’
[08:25:49.257]   - Field: ‘calls’
[08:25:49.257]   - Field: ‘globals’
[08:25:49.257]   - Field: ‘stdout’
[08:25:49.257]   - Field: ‘earlySignal’
[08:25:49.257]   - Field: ‘lazy’
[08:25:49.257]   - Field: ‘state’
[08:25:49.258] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.258] - Launch lazy future ...
[08:25:49.258] Packages needed by the future expression (n = 0): <none>
[08:25:49.258] Packages needed by future strategies (n = 0): <none>
[08:25:49.259] {
[08:25:49.259]     {
[08:25:49.259]         {
[08:25:49.259]             ...future.startTime <- base::Sys.time()
[08:25:49.259]             {
[08:25:49.259]                 {
[08:25:49.259]                   {
[08:25:49.259]                     {
[08:25:49.259]                       base::local({
[08:25:49.259]                         has_future <- base::requireNamespace("future", 
[08:25:49.259]                           quietly = TRUE)
[08:25:49.259]                         if (has_future) {
[08:25:49.259]                           ns <- base::getNamespace("future")
[08:25:49.259]                           version <- ns[[".package"]][["version"]]
[08:25:49.259]                           if (is.null(version)) 
[08:25:49.259]                             version <- utils::packageVersion("future")
[08:25:49.259]                         }
[08:25:49.259]                         else {
[08:25:49.259]                           version <- NULL
[08:25:49.259]                         }
[08:25:49.259]                         if (!has_future || version < "1.8.0") {
[08:25:49.259]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.259]                             "", base::R.version$version.string), 
[08:25:49.259]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.259]                               "release", "version")], collapse = " "), 
[08:25:49.259]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.259]                             info)
[08:25:49.259]                           info <- base::paste(info, collapse = "; ")
[08:25:49.259]                           if (!has_future) {
[08:25:49.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.259]                               info)
[08:25:49.259]                           }
[08:25:49.259]                           else {
[08:25:49.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.259]                               info, version)
[08:25:49.259]                           }
[08:25:49.259]                           base::stop(msg)
[08:25:49.259]                         }
[08:25:49.259]                       })
[08:25:49.259]                     }
[08:25:49.259]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.259]                     base::options(mc.cores = 1L)
[08:25:49.259]                   }
[08:25:49.259]                   ...future.strategy.old <- future::plan("list")
[08:25:49.259]                   options(future.plan = NULL)
[08:25:49.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.259]                 }
[08:25:49.259]                 ...future.workdir <- getwd()
[08:25:49.259]             }
[08:25:49.259]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.259]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.259]         }
[08:25:49.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.259]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[08:25:49.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.259]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.259]             base::names(...future.oldOptions))
[08:25:49.259]     }
[08:25:49.259]     if (FALSE) {
[08:25:49.259]     }
[08:25:49.259]     else {
[08:25:49.259]         if (TRUE) {
[08:25:49.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.259]                 open = "w")
[08:25:49.259]         }
[08:25:49.259]         else {
[08:25:49.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.259]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.259]         }
[08:25:49.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.259]             base::sink(type = "output", split = FALSE)
[08:25:49.259]             base::close(...future.stdout)
[08:25:49.259]         }, add = TRUE)
[08:25:49.259]     }
[08:25:49.259]     ...future.frame <- base::sys.nframe()
[08:25:49.259]     ...future.conditions <- base::list()
[08:25:49.259]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.259]     if (FALSE) {
[08:25:49.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.259]     }
[08:25:49.259]     ...future.result <- base::tryCatch({
[08:25:49.259]         base::withCallingHandlers({
[08:25:49.259]             ...future.value <- base::withVisible(base::local({
[08:25:49.259]                 withCallingHandlers({
[08:25:49.259]                   {
[08:25:49.259]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.259]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.259]                       ...future.globals.maxSize)) {
[08:25:49.259]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.259]                       on.exit(options(oopts), add = TRUE)
[08:25:49.259]                     }
[08:25:49.259]                     {
[08:25:49.259]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.259]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.259]                         USE.NAMES = FALSE)
[08:25:49.259]                       do.call(mapply, args = args)
[08:25:49.259]                     }
[08:25:49.259]                   }
[08:25:49.259]                 }, immediateCondition = function(cond) {
[08:25:49.259]                   save_rds <- function (object, pathname, ...) 
[08:25:49.259]                   {
[08:25:49.259]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.259]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.259]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.259]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.259]                         fi_tmp[["mtime"]])
[08:25:49.259]                     }
[08:25:49.259]                     tryCatch({
[08:25:49.259]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.259]                     }, error = function(ex) {
[08:25:49.259]                       msg <- conditionMessage(ex)
[08:25:49.259]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.259]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.259]                         fi_tmp[["mtime"]], msg)
[08:25:49.259]                       ex$message <- msg
[08:25:49.259]                       stop(ex)
[08:25:49.259]                     })
[08:25:49.259]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.259]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.259]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.259]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.259]                       fi <- file.info(pathname)
[08:25:49.259]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.259]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.259]                         fi[["size"]], fi[["mtime"]])
[08:25:49.259]                       stop(msg)
[08:25:49.259]                     }
[08:25:49.259]                     invisible(pathname)
[08:25:49.259]                   }
[08:25:49.259]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.259]                     rootPath = tempdir()) 
[08:25:49.259]                   {
[08:25:49.259]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.259]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.259]                       tmpdir = path, fileext = ".rds")
[08:25:49.259]                     save_rds(obj, file)
[08:25:49.259]                   }
[08:25:49.259]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.259]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.259]                   {
[08:25:49.259]                     inherits <- base::inherits
[08:25:49.259]                     invokeRestart <- base::invokeRestart
[08:25:49.259]                     is.null <- base::is.null
[08:25:49.259]                     muffled <- FALSE
[08:25:49.259]                     if (inherits(cond, "message")) {
[08:25:49.259]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.259]                       if (muffled) 
[08:25:49.259]                         invokeRestart("muffleMessage")
[08:25:49.259]                     }
[08:25:49.259]                     else if (inherits(cond, "warning")) {
[08:25:49.259]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.259]                       if (muffled) 
[08:25:49.259]                         invokeRestart("muffleWarning")
[08:25:49.259]                     }
[08:25:49.259]                     else if (inherits(cond, "condition")) {
[08:25:49.259]                       if (!is.null(pattern)) {
[08:25:49.259]                         computeRestarts <- base::computeRestarts
[08:25:49.259]                         grepl <- base::grepl
[08:25:49.259]                         restarts <- computeRestarts(cond)
[08:25:49.259]                         for (restart in restarts) {
[08:25:49.259]                           name <- restart$name
[08:25:49.259]                           if (is.null(name)) 
[08:25:49.259]                             next
[08:25:49.259]                           if (!grepl(pattern, name)) 
[08:25:49.259]                             next
[08:25:49.259]                           invokeRestart(restart)
[08:25:49.259]                           muffled <- TRUE
[08:25:49.259]                           break
[08:25:49.259]                         }
[08:25:49.259]                       }
[08:25:49.259]                     }
[08:25:49.259]                     invisible(muffled)
[08:25:49.259]                   }
[08:25:49.259]                   muffleCondition(cond)
[08:25:49.259]                 })
[08:25:49.259]             }))
[08:25:49.259]             future::FutureResult(value = ...future.value$value, 
[08:25:49.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.259]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.259]                     ...future.globalenv.names))
[08:25:49.259]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.259]         }, condition = base::local({
[08:25:49.259]             c <- base::c
[08:25:49.259]             inherits <- base::inherits
[08:25:49.259]             invokeRestart <- base::invokeRestart
[08:25:49.259]             length <- base::length
[08:25:49.259]             list <- base::list
[08:25:49.259]             seq.int <- base::seq.int
[08:25:49.259]             signalCondition <- base::signalCondition
[08:25:49.259]             sys.calls <- base::sys.calls
[08:25:49.259]             `[[` <- base::`[[`
[08:25:49.259]             `+` <- base::`+`
[08:25:49.259]             `<<-` <- base::`<<-`
[08:25:49.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.259]                   3L)]
[08:25:49.259]             }
[08:25:49.259]             function(cond) {
[08:25:49.259]                 is_error <- inherits(cond, "error")
[08:25:49.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.259]                   NULL)
[08:25:49.259]                 if (is_error) {
[08:25:49.259]                   sessionInformation <- function() {
[08:25:49.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.259]                       search = base::search(), system = base::Sys.info())
[08:25:49.259]                   }
[08:25:49.259]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.259]                     cond$call), session = sessionInformation(), 
[08:25:49.259]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.259]                   signalCondition(cond)
[08:25:49.259]                 }
[08:25:49.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.259]                 "immediateCondition"))) {
[08:25:49.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.259]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.259]                   if (TRUE && !signal) {
[08:25:49.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.259]                     {
[08:25:49.259]                       inherits <- base::inherits
[08:25:49.259]                       invokeRestart <- base::invokeRestart
[08:25:49.259]                       is.null <- base::is.null
[08:25:49.259]                       muffled <- FALSE
[08:25:49.259]                       if (inherits(cond, "message")) {
[08:25:49.259]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.259]                         if (muffled) 
[08:25:49.259]                           invokeRestart("muffleMessage")
[08:25:49.259]                       }
[08:25:49.259]                       else if (inherits(cond, "warning")) {
[08:25:49.259]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.259]                         if (muffled) 
[08:25:49.259]                           invokeRestart("muffleWarning")
[08:25:49.259]                       }
[08:25:49.259]                       else if (inherits(cond, "condition")) {
[08:25:49.259]                         if (!is.null(pattern)) {
[08:25:49.259]                           computeRestarts <- base::computeRestarts
[08:25:49.259]                           grepl <- base::grepl
[08:25:49.259]                           restarts <- computeRestarts(cond)
[08:25:49.259]                           for (restart in restarts) {
[08:25:49.259]                             name <- restart$name
[08:25:49.259]                             if (is.null(name)) 
[08:25:49.259]                               next
[08:25:49.259]                             if (!grepl(pattern, name)) 
[08:25:49.259]                               next
[08:25:49.259]                             invokeRestart(restart)
[08:25:49.259]                             muffled <- TRUE
[08:25:49.259]                             break
[08:25:49.259]                           }
[08:25:49.259]                         }
[08:25:49.259]                       }
[08:25:49.259]                       invisible(muffled)
[08:25:49.259]                     }
[08:25:49.259]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.259]                   }
[08:25:49.259]                 }
[08:25:49.259]                 else {
[08:25:49.259]                   if (TRUE) {
[08:25:49.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.259]                     {
[08:25:49.259]                       inherits <- base::inherits
[08:25:49.259]                       invokeRestart <- base::invokeRestart
[08:25:49.259]                       is.null <- base::is.null
[08:25:49.259]                       muffled <- FALSE
[08:25:49.259]                       if (inherits(cond, "message")) {
[08:25:49.259]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.259]                         if (muffled) 
[08:25:49.259]                           invokeRestart("muffleMessage")
[08:25:49.259]                       }
[08:25:49.259]                       else if (inherits(cond, "warning")) {
[08:25:49.259]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.259]                         if (muffled) 
[08:25:49.259]                           invokeRestart("muffleWarning")
[08:25:49.259]                       }
[08:25:49.259]                       else if (inherits(cond, "condition")) {
[08:25:49.259]                         if (!is.null(pattern)) {
[08:25:49.259]                           computeRestarts <- base::computeRestarts
[08:25:49.259]                           grepl <- base::grepl
[08:25:49.259]                           restarts <- computeRestarts(cond)
[08:25:49.259]                           for (restart in restarts) {
[08:25:49.259]                             name <- restart$name
[08:25:49.259]                             if (is.null(name)) 
[08:25:49.259]                               next
[08:25:49.259]                             if (!grepl(pattern, name)) 
[08:25:49.259]                               next
[08:25:49.259]                             invokeRestart(restart)
[08:25:49.259]                             muffled <- TRUE
[08:25:49.259]                             break
[08:25:49.259]                           }
[08:25:49.259]                         }
[08:25:49.259]                       }
[08:25:49.259]                       invisible(muffled)
[08:25:49.259]                     }
[08:25:49.259]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.259]                   }
[08:25:49.259]                 }
[08:25:49.259]             }
[08:25:49.259]         }))
[08:25:49.259]     }, error = function(ex) {
[08:25:49.259]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.259]                 ...future.rng), started = ...future.startTime, 
[08:25:49.259]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.259]             version = "1.8"), class = "FutureResult")
[08:25:49.259]     }, finally = {
[08:25:49.259]         if (!identical(...future.workdir, getwd())) 
[08:25:49.259]             setwd(...future.workdir)
[08:25:49.259]         {
[08:25:49.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.259]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.259]             }
[08:25:49.259]             base::options(...future.oldOptions)
[08:25:49.259]             if (.Platform$OS.type == "windows") {
[08:25:49.259]                 old_names <- names(...future.oldEnvVars)
[08:25:49.259]                 envs <- base::Sys.getenv()
[08:25:49.259]                 names <- names(envs)
[08:25:49.259]                 common <- intersect(names, old_names)
[08:25:49.259]                 added <- setdiff(names, old_names)
[08:25:49.259]                 removed <- setdiff(old_names, names)
[08:25:49.259]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.259]                   envs[common]]
[08:25:49.259]                 NAMES <- toupper(changed)
[08:25:49.259]                 args <- list()
[08:25:49.259]                 for (kk in seq_along(NAMES)) {
[08:25:49.259]                   name <- changed[[kk]]
[08:25:49.259]                   NAME <- NAMES[[kk]]
[08:25:49.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.259]                     next
[08:25:49.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.259]                 }
[08:25:49.259]                 NAMES <- toupper(added)
[08:25:49.259]                 for (kk in seq_along(NAMES)) {
[08:25:49.259]                   name <- added[[kk]]
[08:25:49.259]                   NAME <- NAMES[[kk]]
[08:25:49.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.259]                     next
[08:25:49.259]                   args[[name]] <- ""
[08:25:49.259]                 }
[08:25:49.259]                 NAMES <- toupper(removed)
[08:25:49.259]                 for (kk in seq_along(NAMES)) {
[08:25:49.259]                   name <- removed[[kk]]
[08:25:49.259]                   NAME <- NAMES[[kk]]
[08:25:49.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.259]                     next
[08:25:49.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.259]                 }
[08:25:49.259]                 if (length(args) > 0) 
[08:25:49.259]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.259]             }
[08:25:49.259]             else {
[08:25:49.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.259]             }
[08:25:49.259]             {
[08:25:49.259]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.259]                   0L) {
[08:25:49.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.259]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.259]                   base::options(opts)
[08:25:49.259]                 }
[08:25:49.259]                 {
[08:25:49.259]                   {
[08:25:49.259]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.259]                     NULL
[08:25:49.259]                   }
[08:25:49.259]                   options(future.plan = NULL)
[08:25:49.259]                   if (is.na(NA_character_)) 
[08:25:49.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.259]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.259]                     .init = FALSE)
[08:25:49.259]                 }
[08:25:49.259]             }
[08:25:49.259]         }
[08:25:49.259]     })
[08:25:49.259]     if (TRUE) {
[08:25:49.259]         base::sink(type = "output", split = FALSE)
[08:25:49.259]         if (TRUE) {
[08:25:49.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.259]         }
[08:25:49.259]         else {
[08:25:49.259]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.259]         }
[08:25:49.259]         base::close(...future.stdout)
[08:25:49.259]         ...future.stdout <- NULL
[08:25:49.259]     }
[08:25:49.259]     ...future.result$conditions <- ...future.conditions
[08:25:49.259]     ...future.result$finished <- base::Sys.time()
[08:25:49.259]     ...future.result
[08:25:49.259] }
[08:25:49.263] assign_globals() ...
[08:25:49.263] List of 5
[08:25:49.263]  $ ...future.FUN            :function (C, k)  
[08:25:49.263]  $ MoreArgs                 : NULL
[08:25:49.263]  $ ...future.elements_ii    :List of 2
[08:25:49.263]   ..$ :List of 1
[08:25:49.263]   .. ..$ : chr "B"
[08:25:49.263]   ..$ :List of 1
[08:25:49.263]   .. ..$ : int 4
[08:25:49.263]  $ ...future.seeds_ii       : NULL
[08:25:49.263]  $ ...future.globals.maxSize: NULL
[08:25:49.263]  - attr(*, "where")=List of 5
[08:25:49.263]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.263]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.263]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.263]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.263]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.263]  - attr(*, "resolved")= logi FALSE
[08:25:49.263]  - attr(*, "total_size")= num 847
[08:25:49.263]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.263]  - attr(*, "already-done")= logi TRUE
[08:25:49.270] - reassign environment for ‘...future.FUN’
[08:25:49.270] - copied ‘...future.FUN’ to environment
[08:25:49.270] - copied ‘MoreArgs’ to environment
[08:25:49.270] - copied ‘...future.elements_ii’ to environment
[08:25:49.271] - copied ‘...future.seeds_ii’ to environment
[08:25:49.271] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.271] assign_globals() ... done
[08:25:49.271] requestCore(): workers = 2
[08:25:49.276] MulticoreFuture started
[08:25:49.277] - Launch lazy future ... done
[08:25:49.278] run() for ‘MulticoreFuture’ ... done
[08:25:49.278] plan(): Setting new future strategy stack:
[08:25:49.278] Created future:
[08:25:49.278] List of future strategies:
[08:25:49.278] 1. sequential:
[08:25:49.278]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.278]    - tweaked: FALSE
[08:25:49.278]    - call: NULL
[08:25:49.280] plan(): nbrOfWorkers() = 1
[08:25:49.283] plan(): Setting new future strategy stack:
[08:25:49.284] List of future strategies:
[08:25:49.284] 1. multicore:
[08:25:49.284]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.284]    - tweaked: FALSE
[08:25:49.284]    - call: plan(strategy)
[08:25:49.288] plan(): nbrOfWorkers() = 2
[08:25:49.279] MulticoreFuture:
[08:25:49.279] Label: ‘future_mapply-2’
[08:25:49.279] Expression:
[08:25:49.279] {
[08:25:49.279]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.279]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.279]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.279]         on.exit(options(oopts), add = TRUE)
[08:25:49.279]     }
[08:25:49.279]     {
[08:25:49.279]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.279]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.279]         do.call(mapply, args = args)
[08:25:49.279]     }
[08:25:49.279] }
[08:25:49.279] Lazy evaluation: FALSE
[08:25:49.279] Asynchronous evaluation: TRUE
[08:25:49.279] Local evaluation: TRUE
[08:25:49.279] Environment: R_GlobalEnv
[08:25:49.279] Capture standard output: TRUE
[08:25:49.279] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.279] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.279] Packages: <none>
[08:25:49.279] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.279] Resolved: TRUE
[08:25:49.279] Value: <not collected>
[08:25:49.279] Conditions captured: <none>
[08:25:49.279] Early signaling: FALSE
[08:25:49.279] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.279] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.290] Chunk #2 of 3 ... DONE
[08:25:49.290] Chunk #3 of 3 ...
[08:25:49.290]  - Finding globals in '...' for chunk #3 ...
[08:25:49.290] getGlobalsAndPackages() ...
[08:25:49.291] Searching for globals...
[08:25:49.292] 
[08:25:49.292] Searching for globals ... DONE
[08:25:49.292] - globals: [0] <none>
[08:25:49.292] getGlobalsAndPackages() ... DONE
[08:25:49.292]    + additional globals found: [n=0] 
[08:25:49.293]    + additional namespaces needed: [n=0] 
[08:25:49.293]  - Finding globals in '...' for chunk #3 ... DONE
[08:25:49.293]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[08:25:49.293]  - seeds: <none>
[08:25:49.293]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.294] getGlobalsAndPackages() ...
[08:25:49.294] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.294] Resolving globals: FALSE
[08:25:49.295] The total size of the 5 globals is 876 bytes (876 bytes)
[08:25:49.296] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:49.296] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.297] 
[08:25:49.297] getGlobalsAndPackages() ... DONE
[08:25:49.298] run() for ‘Future’ ...
[08:25:49.298] - state: ‘created’
[08:25:49.298] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.301] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.301] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.301]   - Field: ‘label’
[08:25:49.302]   - Field: ‘local’
[08:25:49.302]   - Field: ‘owner’
[08:25:49.302]   - Field: ‘envir’
[08:25:49.302]   - Field: ‘workers’
[08:25:49.302]   - Field: ‘packages’
[08:25:49.302]   - Field: ‘gc’
[08:25:49.302]   - Field: ‘job’
[08:25:49.303]   - Field: ‘conditions’
[08:25:49.303]   - Field: ‘expr’
[08:25:49.303]   - Field: ‘uuid’
[08:25:49.303]   - Field: ‘seed’
[08:25:49.303]   - Field: ‘version’
[08:25:49.303]   - Field: ‘result’
[08:25:49.303]   - Field: ‘asynchronous’
[08:25:49.304]   - Field: ‘calls’
[08:25:49.304]   - Field: ‘globals’
[08:25:49.304]   - Field: ‘stdout’
[08:25:49.304]   - Field: ‘earlySignal’
[08:25:49.304]   - Field: ‘lazy’
[08:25:49.304]   - Field: ‘state’
[08:25:49.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.304] - Launch lazy future ...
[08:25:49.305] Packages needed by the future expression (n = 0): <none>
[08:25:49.305] Packages needed by future strategies (n = 0): <none>
[08:25:49.306] {
[08:25:49.306]     {
[08:25:49.306]         {
[08:25:49.306]             ...future.startTime <- base::Sys.time()
[08:25:49.306]             {
[08:25:49.306]                 {
[08:25:49.306]                   {
[08:25:49.306]                     {
[08:25:49.306]                       base::local({
[08:25:49.306]                         has_future <- base::requireNamespace("future", 
[08:25:49.306]                           quietly = TRUE)
[08:25:49.306]                         if (has_future) {
[08:25:49.306]                           ns <- base::getNamespace("future")
[08:25:49.306]                           version <- ns[[".package"]][["version"]]
[08:25:49.306]                           if (is.null(version)) 
[08:25:49.306]                             version <- utils::packageVersion("future")
[08:25:49.306]                         }
[08:25:49.306]                         else {
[08:25:49.306]                           version <- NULL
[08:25:49.306]                         }
[08:25:49.306]                         if (!has_future || version < "1.8.0") {
[08:25:49.306]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.306]                             "", base::R.version$version.string), 
[08:25:49.306]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.306]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.306]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.306]                               "release", "version")], collapse = " "), 
[08:25:49.306]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.306]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.306]                             info)
[08:25:49.306]                           info <- base::paste(info, collapse = "; ")
[08:25:49.306]                           if (!has_future) {
[08:25:49.306]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.306]                               info)
[08:25:49.306]                           }
[08:25:49.306]                           else {
[08:25:49.306]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.306]                               info, version)
[08:25:49.306]                           }
[08:25:49.306]                           base::stop(msg)
[08:25:49.306]                         }
[08:25:49.306]                       })
[08:25:49.306]                     }
[08:25:49.306]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.306]                     base::options(mc.cores = 1L)
[08:25:49.306]                   }
[08:25:49.306]                   ...future.strategy.old <- future::plan("list")
[08:25:49.306]                   options(future.plan = NULL)
[08:25:49.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.306]                 }
[08:25:49.306]                 ...future.workdir <- getwd()
[08:25:49.306]             }
[08:25:49.306]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.306]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.306]         }
[08:25:49.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.306]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[08:25:49.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.306]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.306]             base::names(...future.oldOptions))
[08:25:49.306]     }
[08:25:49.306]     if (FALSE) {
[08:25:49.306]     }
[08:25:49.306]     else {
[08:25:49.306]         if (TRUE) {
[08:25:49.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.306]                 open = "w")
[08:25:49.306]         }
[08:25:49.306]         else {
[08:25:49.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.306]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.306]         }
[08:25:49.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.306]             base::sink(type = "output", split = FALSE)
[08:25:49.306]             base::close(...future.stdout)
[08:25:49.306]         }, add = TRUE)
[08:25:49.306]     }
[08:25:49.306]     ...future.frame <- base::sys.nframe()
[08:25:49.306]     ...future.conditions <- base::list()
[08:25:49.306]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.306]     if (FALSE) {
[08:25:49.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.306]     }
[08:25:49.306]     ...future.result <- base::tryCatch({
[08:25:49.306]         base::withCallingHandlers({
[08:25:49.306]             ...future.value <- base::withVisible(base::local({
[08:25:49.306]                 withCallingHandlers({
[08:25:49.306]                   {
[08:25:49.306]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.306]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.306]                       ...future.globals.maxSize)) {
[08:25:49.306]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.306]                       on.exit(options(oopts), add = TRUE)
[08:25:49.306]                     }
[08:25:49.306]                     {
[08:25:49.306]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.306]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.306]                         USE.NAMES = FALSE)
[08:25:49.306]                       do.call(mapply, args = args)
[08:25:49.306]                     }
[08:25:49.306]                   }
[08:25:49.306]                 }, immediateCondition = function(cond) {
[08:25:49.306]                   save_rds <- function (object, pathname, ...) 
[08:25:49.306]                   {
[08:25:49.306]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.306]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.306]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.306]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.306]                         fi_tmp[["mtime"]])
[08:25:49.306]                     }
[08:25:49.306]                     tryCatch({
[08:25:49.306]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.306]                     }, error = function(ex) {
[08:25:49.306]                       msg <- conditionMessage(ex)
[08:25:49.306]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.306]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.306]                         fi_tmp[["mtime"]], msg)
[08:25:49.306]                       ex$message <- msg
[08:25:49.306]                       stop(ex)
[08:25:49.306]                     })
[08:25:49.306]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.306]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.306]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.306]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.306]                       fi <- file.info(pathname)
[08:25:49.306]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.306]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.306]                         fi[["size"]], fi[["mtime"]])
[08:25:49.306]                       stop(msg)
[08:25:49.306]                     }
[08:25:49.306]                     invisible(pathname)
[08:25:49.306]                   }
[08:25:49.306]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.306]                     rootPath = tempdir()) 
[08:25:49.306]                   {
[08:25:49.306]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.306]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.306]                       tmpdir = path, fileext = ".rds")
[08:25:49.306]                     save_rds(obj, file)
[08:25:49.306]                   }
[08:25:49.306]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.306]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.306]                   {
[08:25:49.306]                     inherits <- base::inherits
[08:25:49.306]                     invokeRestart <- base::invokeRestart
[08:25:49.306]                     is.null <- base::is.null
[08:25:49.306]                     muffled <- FALSE
[08:25:49.306]                     if (inherits(cond, "message")) {
[08:25:49.306]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.306]                       if (muffled) 
[08:25:49.306]                         invokeRestart("muffleMessage")
[08:25:49.306]                     }
[08:25:49.306]                     else if (inherits(cond, "warning")) {
[08:25:49.306]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.306]                       if (muffled) 
[08:25:49.306]                         invokeRestart("muffleWarning")
[08:25:49.306]                     }
[08:25:49.306]                     else if (inherits(cond, "condition")) {
[08:25:49.306]                       if (!is.null(pattern)) {
[08:25:49.306]                         computeRestarts <- base::computeRestarts
[08:25:49.306]                         grepl <- base::grepl
[08:25:49.306]                         restarts <- computeRestarts(cond)
[08:25:49.306]                         for (restart in restarts) {
[08:25:49.306]                           name <- restart$name
[08:25:49.306]                           if (is.null(name)) 
[08:25:49.306]                             next
[08:25:49.306]                           if (!grepl(pattern, name)) 
[08:25:49.306]                             next
[08:25:49.306]                           invokeRestart(restart)
[08:25:49.306]                           muffled <- TRUE
[08:25:49.306]                           break
[08:25:49.306]                         }
[08:25:49.306]                       }
[08:25:49.306]                     }
[08:25:49.306]                     invisible(muffled)
[08:25:49.306]                   }
[08:25:49.306]                   muffleCondition(cond)
[08:25:49.306]                 })
[08:25:49.306]             }))
[08:25:49.306]             future::FutureResult(value = ...future.value$value, 
[08:25:49.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.306]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.306]                     ...future.globalenv.names))
[08:25:49.306]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.306]         }, condition = base::local({
[08:25:49.306]             c <- base::c
[08:25:49.306]             inherits <- base::inherits
[08:25:49.306]             invokeRestart <- base::invokeRestart
[08:25:49.306]             length <- base::length
[08:25:49.306]             list <- base::list
[08:25:49.306]             seq.int <- base::seq.int
[08:25:49.306]             signalCondition <- base::signalCondition
[08:25:49.306]             sys.calls <- base::sys.calls
[08:25:49.306]             `[[` <- base::`[[`
[08:25:49.306]             `+` <- base::`+`
[08:25:49.306]             `<<-` <- base::`<<-`
[08:25:49.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.306]                   3L)]
[08:25:49.306]             }
[08:25:49.306]             function(cond) {
[08:25:49.306]                 is_error <- inherits(cond, "error")
[08:25:49.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.306]                   NULL)
[08:25:49.306]                 if (is_error) {
[08:25:49.306]                   sessionInformation <- function() {
[08:25:49.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.306]                       search = base::search(), system = base::Sys.info())
[08:25:49.306]                   }
[08:25:49.306]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.306]                     cond$call), session = sessionInformation(), 
[08:25:49.306]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.306]                   signalCondition(cond)
[08:25:49.306]                 }
[08:25:49.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.306]                 "immediateCondition"))) {
[08:25:49.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.306]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.306]                   if (TRUE && !signal) {
[08:25:49.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.306]                     {
[08:25:49.306]                       inherits <- base::inherits
[08:25:49.306]                       invokeRestart <- base::invokeRestart
[08:25:49.306]                       is.null <- base::is.null
[08:25:49.306]                       muffled <- FALSE
[08:25:49.306]                       if (inherits(cond, "message")) {
[08:25:49.306]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.306]                         if (muffled) 
[08:25:49.306]                           invokeRestart("muffleMessage")
[08:25:49.306]                       }
[08:25:49.306]                       else if (inherits(cond, "warning")) {
[08:25:49.306]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.306]                         if (muffled) 
[08:25:49.306]                           invokeRestart("muffleWarning")
[08:25:49.306]                       }
[08:25:49.306]                       else if (inherits(cond, "condition")) {
[08:25:49.306]                         if (!is.null(pattern)) {
[08:25:49.306]                           computeRestarts <- base::computeRestarts
[08:25:49.306]                           grepl <- base::grepl
[08:25:49.306]                           restarts <- computeRestarts(cond)
[08:25:49.306]                           for (restart in restarts) {
[08:25:49.306]                             name <- restart$name
[08:25:49.306]                             if (is.null(name)) 
[08:25:49.306]                               next
[08:25:49.306]                             if (!grepl(pattern, name)) 
[08:25:49.306]                               next
[08:25:49.306]                             invokeRestart(restart)
[08:25:49.306]                             muffled <- TRUE
[08:25:49.306]                             break
[08:25:49.306]                           }
[08:25:49.306]                         }
[08:25:49.306]                       }
[08:25:49.306]                       invisible(muffled)
[08:25:49.306]                     }
[08:25:49.306]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.306]                   }
[08:25:49.306]                 }
[08:25:49.306]                 else {
[08:25:49.306]                   if (TRUE) {
[08:25:49.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.306]                     {
[08:25:49.306]                       inherits <- base::inherits
[08:25:49.306]                       invokeRestart <- base::invokeRestart
[08:25:49.306]                       is.null <- base::is.null
[08:25:49.306]                       muffled <- FALSE
[08:25:49.306]                       if (inherits(cond, "message")) {
[08:25:49.306]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.306]                         if (muffled) 
[08:25:49.306]                           invokeRestart("muffleMessage")
[08:25:49.306]                       }
[08:25:49.306]                       else if (inherits(cond, "warning")) {
[08:25:49.306]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.306]                         if (muffled) 
[08:25:49.306]                           invokeRestart("muffleWarning")
[08:25:49.306]                       }
[08:25:49.306]                       else if (inherits(cond, "condition")) {
[08:25:49.306]                         if (!is.null(pattern)) {
[08:25:49.306]                           computeRestarts <- base::computeRestarts
[08:25:49.306]                           grepl <- base::grepl
[08:25:49.306]                           restarts <- computeRestarts(cond)
[08:25:49.306]                           for (restart in restarts) {
[08:25:49.306]                             name <- restart$name
[08:25:49.306]                             if (is.null(name)) 
[08:25:49.306]                               next
[08:25:49.306]                             if (!grepl(pattern, name)) 
[08:25:49.306]                               next
[08:25:49.306]                             invokeRestart(restart)
[08:25:49.306]                             muffled <- TRUE
[08:25:49.306]                             break
[08:25:49.306]                           }
[08:25:49.306]                         }
[08:25:49.306]                       }
[08:25:49.306]                       invisible(muffled)
[08:25:49.306]                     }
[08:25:49.306]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.306]                   }
[08:25:49.306]                 }
[08:25:49.306]             }
[08:25:49.306]         }))
[08:25:49.306]     }, error = function(ex) {
[08:25:49.306]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.306]                 ...future.rng), started = ...future.startTime, 
[08:25:49.306]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.306]             version = "1.8"), class = "FutureResult")
[08:25:49.306]     }, finally = {
[08:25:49.306]         if (!identical(...future.workdir, getwd())) 
[08:25:49.306]             setwd(...future.workdir)
[08:25:49.306]         {
[08:25:49.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.306]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.306]             }
[08:25:49.306]             base::options(...future.oldOptions)
[08:25:49.306]             if (.Platform$OS.type == "windows") {
[08:25:49.306]                 old_names <- names(...future.oldEnvVars)
[08:25:49.306]                 envs <- base::Sys.getenv()
[08:25:49.306]                 names <- names(envs)
[08:25:49.306]                 common <- intersect(names, old_names)
[08:25:49.306]                 added <- setdiff(names, old_names)
[08:25:49.306]                 removed <- setdiff(old_names, names)
[08:25:49.306]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.306]                   envs[common]]
[08:25:49.306]                 NAMES <- toupper(changed)
[08:25:49.306]                 args <- list()
[08:25:49.306]                 for (kk in seq_along(NAMES)) {
[08:25:49.306]                   name <- changed[[kk]]
[08:25:49.306]                   NAME <- NAMES[[kk]]
[08:25:49.306]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.306]                     next
[08:25:49.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.306]                 }
[08:25:49.306]                 NAMES <- toupper(added)
[08:25:49.306]                 for (kk in seq_along(NAMES)) {
[08:25:49.306]                   name <- added[[kk]]
[08:25:49.306]                   NAME <- NAMES[[kk]]
[08:25:49.306]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.306]                     next
[08:25:49.306]                   args[[name]] <- ""
[08:25:49.306]                 }
[08:25:49.306]                 NAMES <- toupper(removed)
[08:25:49.306]                 for (kk in seq_along(NAMES)) {
[08:25:49.306]                   name <- removed[[kk]]
[08:25:49.306]                   NAME <- NAMES[[kk]]
[08:25:49.306]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.306]                     next
[08:25:49.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.306]                 }
[08:25:49.306]                 if (length(args) > 0) 
[08:25:49.306]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.306]             }
[08:25:49.306]             else {
[08:25:49.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.306]             }
[08:25:49.306]             {
[08:25:49.306]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.306]                   0L) {
[08:25:49.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.306]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.306]                   base::options(opts)
[08:25:49.306]                 }
[08:25:49.306]                 {
[08:25:49.306]                   {
[08:25:49.306]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.306]                     NULL
[08:25:49.306]                   }
[08:25:49.306]                   options(future.plan = NULL)
[08:25:49.306]                   if (is.na(NA_character_)) 
[08:25:49.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.306]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.306]                     .init = FALSE)
[08:25:49.306]                 }
[08:25:49.306]             }
[08:25:49.306]         }
[08:25:49.306]     })
[08:25:49.306]     if (TRUE) {
[08:25:49.306]         base::sink(type = "output", split = FALSE)
[08:25:49.306]         if (TRUE) {
[08:25:49.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.306]         }
[08:25:49.306]         else {
[08:25:49.306]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.306]         }
[08:25:49.306]         base::close(...future.stdout)
[08:25:49.306]         ...future.stdout <- NULL
[08:25:49.306]     }
[08:25:49.306]     ...future.result$conditions <- ...future.conditions
[08:25:49.306]     ...future.result$finished <- base::Sys.time()
[08:25:49.306]     ...future.result
[08:25:49.306] }
[08:25:49.309] assign_globals() ...
[08:25:49.309] List of 5
[08:25:49.309]  $ ...future.FUN            :function (C, k)  
[08:25:49.309]  $ MoreArgs                 : NULL
[08:25:49.309]  $ ...future.elements_ii    :List of 2
[08:25:49.309]   ..$ :List of 2
[08:25:49.309]   .. ..$ : chr "E"
[08:25:49.309]   .. ..$ : chr "A"
[08:25:49.309]   ..$ :List of 2
[08:25:49.309]   .. ..$ : int 1
[08:25:49.309]   .. ..$ : int 5
[08:25:49.309]  $ ...future.seeds_ii       : NULL
[08:25:49.309]  $ ...future.globals.maxSize: NULL
[08:25:49.309]  - attr(*, "where")=List of 5
[08:25:49.309]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.309]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.309]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.309]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.309]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.309]  - attr(*, "resolved")= logi FALSE
[08:25:49.309]  - attr(*, "total_size")= num 876
[08:25:49.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.309]  - attr(*, "already-done")= logi TRUE
[08:25:49.316] - reassign environment for ‘...future.FUN’
[08:25:49.316] - copied ‘...future.FUN’ to environment
[08:25:49.316] - copied ‘MoreArgs’ to environment
[08:25:49.317] - copied ‘...future.elements_ii’ to environment
[08:25:49.317] - copied ‘...future.seeds_ii’ to environment
[08:25:49.317] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.317] assign_globals() ... done
[08:25:49.317] requestCore(): workers = 2
[08:25:49.317] Poll #1 (0): usedCores() = 2, workers = 2
[08:25:49.328] result() for MulticoreFuture ...
[08:25:49.329] result() for MulticoreFuture ...
[08:25:49.329] result() for MulticoreFuture ... done
[08:25:49.329] result() for MulticoreFuture ... done
[08:25:49.329] result() for MulticoreFuture ...
[08:25:49.329] result() for MulticoreFuture ... done
[08:25:49.332] MulticoreFuture started
[08:25:49.332] - Launch lazy future ... done
[08:25:49.332] run() for ‘MulticoreFuture’ ... done
[08:25:49.333] Created future:
[08:25:49.333] plan(): Setting new future strategy stack:
[08:25:49.333] List of future strategies:
[08:25:49.333] 1. sequential:
[08:25:49.333]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.333]    - tweaked: FALSE
[08:25:49.333]    - call: NULL
[08:25:49.335] plan(): nbrOfWorkers() = 1
[08:25:49.344] plan(): Setting new future strategy stack:
[08:25:49.344] List of future strategies:
[08:25:49.344] 1. multicore:
[08:25:49.344]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.344]    - tweaked: FALSE
[08:25:49.344]    - call: plan(strategy)
[08:25:49.349] plan(): nbrOfWorkers() = 2
[08:25:49.333] MulticoreFuture:
[08:25:49.333] Label: ‘future_mapply-3’
[08:25:49.333] Expression:
[08:25:49.333] {
[08:25:49.333]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.333]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.333]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.333]         on.exit(options(oopts), add = TRUE)
[08:25:49.333]     }
[08:25:49.333]     {
[08:25:49.333]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.333]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.333]         do.call(mapply, args = args)
[08:25:49.333]     }
[08:25:49.333] }
[08:25:49.333] Lazy evaluation: FALSE
[08:25:49.333] Asynchronous evaluation: TRUE
[08:25:49.333] Local evaluation: TRUE
[08:25:49.333] Environment: R_GlobalEnv
[08:25:49.333] Capture standard output: TRUE
[08:25:49.333] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.333] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.333] Packages: <none>
[08:25:49.333] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.333] Resolved: TRUE
[08:25:49.333] Value: <not collected>
[08:25:49.333] Conditions captured: <none>
[08:25:49.333] Early signaling: FALSE
[08:25:49.333] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.333] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.351] Chunk #3 of 3 ... DONE
[08:25:49.351] Launching 3 futures (chunks) ... DONE
[08:25:49.351] Resolving 3 futures (chunks) ...
[08:25:49.351] resolve() on list ...
[08:25:49.352]  recursive: 0
[08:25:49.352]  length: 3
[08:25:49.352] 
[08:25:49.352] Future #1
[08:25:49.353] result() for MulticoreFuture ...
[08:25:49.353] result() for MulticoreFuture ... done
[08:25:49.353] result() for MulticoreFuture ...
[08:25:49.353] result() for MulticoreFuture ... done
[08:25:49.353] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:49.354] - nx: 3
[08:25:49.354] - relay: TRUE
[08:25:49.354] - stdout: TRUE
[08:25:49.354] - signal: TRUE
[08:25:49.354] - resignal: FALSE
[08:25:49.355] - force: TRUE
[08:25:49.355] - relayed: [n=3] FALSE, FALSE, FALSE
[08:25:49.355] - queued futures: [n=3] FALSE, FALSE, FALSE
[08:25:49.355]  - until=1
[08:25:49.355]  - relaying element #1
[08:25:49.356] result() for MulticoreFuture ...
[08:25:49.356] result() for MulticoreFuture ... done
[08:25:49.356] result() for MulticoreFuture ...
[08:25:49.356] result() for MulticoreFuture ... done
[08:25:49.357] result() for MulticoreFuture ...
[08:25:49.357] result() for MulticoreFuture ... done
[08:25:49.357] result() for MulticoreFuture ...
[08:25:49.357] result() for MulticoreFuture ... done
[08:25:49.357] - relayed: [n=3] TRUE, FALSE, FALSE
[08:25:49.358] - queued futures: [n=3] TRUE, FALSE, FALSE
[08:25:49.358] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:49.358]  length: 2 (resolved future 1)
[08:25:49.359] Future #2
[08:25:49.359] result() for MulticoreFuture ...
[08:25:49.360] result() for MulticoreFuture ...
[08:25:49.360] result() for MulticoreFuture ... done
[08:25:49.360] result() for MulticoreFuture ... done
[08:25:49.361] result() for MulticoreFuture ...
[08:25:49.361] result() for MulticoreFuture ... done
[08:25:49.361] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:49.361] - nx: 3
[08:25:49.361] - relay: TRUE
[08:25:49.362] - stdout: TRUE
[08:25:49.362] - signal: TRUE
[08:25:49.362] - resignal: FALSE
[08:25:49.362] - force: TRUE
[08:25:49.362] - relayed: [n=3] TRUE, FALSE, FALSE
[08:25:49.362] - queued futures: [n=3] TRUE, FALSE, FALSE
[08:25:49.362]  - until=2
[08:25:49.362]  - relaying element #2
[08:25:49.363] result() for MulticoreFuture ...
[08:25:49.363] result() for MulticoreFuture ... done
[08:25:49.363] result() for MulticoreFuture ...
[08:25:49.363] result() for MulticoreFuture ... done
[08:25:49.363] result() for MulticoreFuture ...
[08:25:49.363] result() for MulticoreFuture ... done
[08:25:49.364] result() for MulticoreFuture ...
[08:25:49.364] result() for MulticoreFuture ... done
[08:25:49.364] - relayed: [n=3] TRUE, TRUE, FALSE
[08:25:49.364] - queued futures: [n=3] TRUE, TRUE, FALSE
[08:25:49.364] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:49.364]  length: 1 (resolved future 2)
[08:25:49.364] Future #3
[08:25:49.365] result() for MulticoreFuture ...
[08:25:49.365] result() for MulticoreFuture ...
[08:25:49.365] result() for MulticoreFuture ... done
[08:25:49.366] result() for MulticoreFuture ... done
[08:25:49.366] result() for MulticoreFuture ...
[08:25:49.366] result() for MulticoreFuture ... done
[08:25:49.366] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:25:49.366] - nx: 3
[08:25:49.367] - relay: TRUE
[08:25:49.367] - stdout: TRUE
[08:25:49.367] - signal: TRUE
[08:25:49.367] - resignal: FALSE
[08:25:49.367] - force: TRUE
[08:25:49.367] - relayed: [n=3] TRUE, TRUE, FALSE
[08:25:49.367] - queued futures: [n=3] TRUE, TRUE, FALSE
[08:25:49.368]  - until=3
[08:25:49.368]  - relaying element #3
[08:25:49.368] result() for MulticoreFuture ...
[08:25:49.368] result() for MulticoreFuture ... done
[08:25:49.368] result() for MulticoreFuture ...
[08:25:49.368] result() for MulticoreFuture ... done
[08:25:49.368] result() for MulticoreFuture ...
[08:25:49.369] result() for MulticoreFuture ... done
[08:25:49.369] result() for MulticoreFuture ...
[08:25:49.369] result() for MulticoreFuture ... done
[08:25:49.369] - relayed: [n=3] TRUE, TRUE, TRUE
[08:25:49.369] - queued futures: [n=3] TRUE, TRUE, TRUE
[08:25:49.369] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:25:49.369]  length: 0 (resolved future 3)
[08:25:49.370] Relaying remaining futures
[08:25:49.370] signalConditionsASAP(NULL, pos=0) ...
[08:25:49.370] - nx: 3
[08:25:49.370] - relay: TRUE
[08:25:49.370] - stdout: TRUE
[08:25:49.370] - signal: TRUE
[08:25:49.370] - resignal: FALSE
[08:25:49.370] - force: TRUE
[08:25:49.370] - relayed: [n=3] TRUE, TRUE, TRUE
[08:25:49.370] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[08:25:49.371] - relayed: [n=3] TRUE, TRUE, TRUE
[08:25:49.371] - queued futures: [n=3] TRUE, TRUE, TRUE
[08:25:49.371] signalConditionsASAP(NULL, pos=0) ... done
[08:25:49.371] resolve() on list ... DONE
[08:25:49.371] result() for MulticoreFuture ...
[08:25:49.371] result() for MulticoreFuture ... done
[08:25:49.371] result() for MulticoreFuture ...
[08:25:49.371] result() for MulticoreFuture ... done
[08:25:49.371] result() for MulticoreFuture ...
[08:25:49.371] result() for MulticoreFuture ... done
[08:25:49.372] result() for MulticoreFuture ...
[08:25:49.372] result() for MulticoreFuture ... done
[08:25:49.372] result() for MulticoreFuture ...
[08:25:49.372] result() for MulticoreFuture ... done
[08:25:49.372] result() for MulticoreFuture ...
[08:25:49.372] result() for MulticoreFuture ... done
[08:25:49.372]  - Number of value chunks collected: 3
[08:25:49.372] Resolving 3 futures (chunks) ... DONE
[08:25:49.372] Reducing values from 3 chunks ...
[08:25:49.372]  - Number of values collected after concatenation: 5
[08:25:49.373]  - Number of values expected: 5
[08:25:49.373] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 3, 1, 2, 4
[08:25:49.373] Reducing values from 3 chunks ... DONE
[08:25:49.373] future_mapply() ... DONE
[08:25:49.373] future_mapply() ...
[08:25:49.375] Number of chunks: 2
[08:25:49.376] getGlobalsAndPackagesXApply() ...
[08:25:49.376]  - future.globals: TRUE
[08:25:49.376] getGlobalsAndPackages() ...
[08:25:49.376] Searching for globals...
[08:25:49.377] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:49.378] Searching for globals ... DONE
[08:25:49.378] Resolving globals: FALSE
[08:25:49.378] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:49.378] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:49.379] - globals: [1] ‘FUN’
[08:25:49.379] 
[08:25:49.379] getGlobalsAndPackages() ... DONE
[08:25:49.379]  - globals found/used: [n=1] ‘FUN’
[08:25:49.379]  - needed namespaces: [n=0] 
[08:25:49.379] Finding globals ... DONE
[08:25:49.381] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:49.382] List of 2
[08:25:49.382]  $ ...future.FUN:function (C, k)  
[08:25:49.382]  $ MoreArgs     : list()
[08:25:49.382]  - attr(*, "where")=List of 2
[08:25:49.382]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:49.382]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:49.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.382]  - attr(*, "resolved")= logi FALSE
[08:25:49.382]  - attr(*, "total_size")= num NA
[08:25:49.385] Packages to be attached in all futures: [n=0] 
[08:25:49.385] getGlobalsAndPackagesXApply() ... DONE
[08:25:49.385] Number of futures (= number of chunks): 2
[08:25:49.385] Launching 2 futures (chunks) ...
[08:25:49.385] Chunk #1 of 2 ...
[08:25:49.386]  - Finding globals in '...' for chunk #1 ...
[08:25:49.386] getGlobalsAndPackages() ...
[08:25:49.386] Searching for globals...
[08:25:49.386] 
[08:25:49.386] Searching for globals ... DONE
[08:25:49.387] - globals: [0] <none>
[08:25:49.387] getGlobalsAndPackages() ... DONE
[08:25:49.387]    + additional globals found: [n=0] 
[08:25:49.387]    + additional namespaces needed: [n=0] 
[08:25:49.387]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:49.387]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.387]  - seeds: <none>
[08:25:49.387]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.387] getGlobalsAndPackages() ...
[08:25:49.387] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.388] Resolving globals: FALSE
[08:25:49.388] The total size of the 5 globals is 880 bytes (880 bytes)
[08:25:49.388] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:49.389] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.389] 
[08:25:49.389] getGlobalsAndPackages() ... DONE
[08:25:49.389] run() for ‘Future’ ...
[08:25:49.389] - state: ‘created’
[08:25:49.389] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.391] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.391] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.391]   - Field: ‘label’
[08:25:49.392]   - Field: ‘local’
[08:25:49.392]   - Field: ‘owner’
[08:25:49.392]   - Field: ‘envir’
[08:25:49.392]   - Field: ‘workers’
[08:25:49.392]   - Field: ‘packages’
[08:25:49.392]   - Field: ‘gc’
[08:25:49.392]   - Field: ‘job’
[08:25:49.392]   - Field: ‘conditions’
[08:25:49.392]   - Field: ‘expr’
[08:25:49.392]   - Field: ‘uuid’
[08:25:49.393]   - Field: ‘seed’
[08:25:49.393]   - Field: ‘version’
[08:25:49.393]   - Field: ‘result’
[08:25:49.393]   - Field: ‘asynchronous’
[08:25:49.393]   - Field: ‘calls’
[08:25:49.393]   - Field: ‘globals’
[08:25:49.393]   - Field: ‘stdout’
[08:25:49.393]   - Field: ‘earlySignal’
[08:25:49.393]   - Field: ‘lazy’
[08:25:49.393]   - Field: ‘state’
[08:25:49.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.394] - Launch lazy future ...
[08:25:49.394] Packages needed by the future expression (n = 0): <none>
[08:25:49.394] Packages needed by future strategies (n = 0): <none>
[08:25:49.394] {
[08:25:49.394]     {
[08:25:49.394]         {
[08:25:49.394]             ...future.startTime <- base::Sys.time()
[08:25:49.394]             {
[08:25:49.394]                 {
[08:25:49.394]                   {
[08:25:49.394]                     {
[08:25:49.394]                       base::local({
[08:25:49.394]                         has_future <- base::requireNamespace("future", 
[08:25:49.394]                           quietly = TRUE)
[08:25:49.394]                         if (has_future) {
[08:25:49.394]                           ns <- base::getNamespace("future")
[08:25:49.394]                           version <- ns[[".package"]][["version"]]
[08:25:49.394]                           if (is.null(version)) 
[08:25:49.394]                             version <- utils::packageVersion("future")
[08:25:49.394]                         }
[08:25:49.394]                         else {
[08:25:49.394]                           version <- NULL
[08:25:49.394]                         }
[08:25:49.394]                         if (!has_future || version < "1.8.0") {
[08:25:49.394]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.394]                             "", base::R.version$version.string), 
[08:25:49.394]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.394]                               "release", "version")], collapse = " "), 
[08:25:49.394]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.394]                             info)
[08:25:49.394]                           info <- base::paste(info, collapse = "; ")
[08:25:49.394]                           if (!has_future) {
[08:25:49.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.394]                               info)
[08:25:49.394]                           }
[08:25:49.394]                           else {
[08:25:49.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.394]                               info, version)
[08:25:49.394]                           }
[08:25:49.394]                           base::stop(msg)
[08:25:49.394]                         }
[08:25:49.394]                       })
[08:25:49.394]                     }
[08:25:49.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.394]                     base::options(mc.cores = 1L)
[08:25:49.394]                   }
[08:25:49.394]                   ...future.strategy.old <- future::plan("list")
[08:25:49.394]                   options(future.plan = NULL)
[08:25:49.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.394]                 }
[08:25:49.394]                 ...future.workdir <- getwd()
[08:25:49.394]             }
[08:25:49.394]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.394]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.394]         }
[08:25:49.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.394]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.394]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.394]             base::names(...future.oldOptions))
[08:25:49.394]     }
[08:25:49.394]     if (FALSE) {
[08:25:49.394]     }
[08:25:49.394]     else {
[08:25:49.394]         if (TRUE) {
[08:25:49.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.394]                 open = "w")
[08:25:49.394]         }
[08:25:49.394]         else {
[08:25:49.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.394]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.394]         }
[08:25:49.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.394]             base::sink(type = "output", split = FALSE)
[08:25:49.394]             base::close(...future.stdout)
[08:25:49.394]         }, add = TRUE)
[08:25:49.394]     }
[08:25:49.394]     ...future.frame <- base::sys.nframe()
[08:25:49.394]     ...future.conditions <- base::list()
[08:25:49.394]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.394]     if (FALSE) {
[08:25:49.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.394]     }
[08:25:49.394]     ...future.result <- base::tryCatch({
[08:25:49.394]         base::withCallingHandlers({
[08:25:49.394]             ...future.value <- base::withVisible(base::local({
[08:25:49.394]                 withCallingHandlers({
[08:25:49.394]                   {
[08:25:49.394]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.394]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.394]                       ...future.globals.maxSize)) {
[08:25:49.394]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.394]                       on.exit(options(oopts), add = TRUE)
[08:25:49.394]                     }
[08:25:49.394]                     {
[08:25:49.394]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.394]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.394]                         USE.NAMES = FALSE)
[08:25:49.394]                       do.call(mapply, args = args)
[08:25:49.394]                     }
[08:25:49.394]                   }
[08:25:49.394]                 }, immediateCondition = function(cond) {
[08:25:49.394]                   save_rds <- function (object, pathname, ...) 
[08:25:49.394]                   {
[08:25:49.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.394]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.394]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.394]                         fi_tmp[["mtime"]])
[08:25:49.394]                     }
[08:25:49.394]                     tryCatch({
[08:25:49.394]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.394]                     }, error = function(ex) {
[08:25:49.394]                       msg <- conditionMessage(ex)
[08:25:49.394]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.394]                         fi_tmp[["mtime"]], msg)
[08:25:49.394]                       ex$message <- msg
[08:25:49.394]                       stop(ex)
[08:25:49.394]                     })
[08:25:49.394]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.394]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.394]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.394]                       fi <- file.info(pathname)
[08:25:49.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.394]                         fi[["size"]], fi[["mtime"]])
[08:25:49.394]                       stop(msg)
[08:25:49.394]                     }
[08:25:49.394]                     invisible(pathname)
[08:25:49.394]                   }
[08:25:49.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.394]                     rootPath = tempdir()) 
[08:25:49.394]                   {
[08:25:49.394]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.394]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.394]                       tmpdir = path, fileext = ".rds")
[08:25:49.394]                     save_rds(obj, file)
[08:25:49.394]                   }
[08:25:49.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.394]                   {
[08:25:49.394]                     inherits <- base::inherits
[08:25:49.394]                     invokeRestart <- base::invokeRestart
[08:25:49.394]                     is.null <- base::is.null
[08:25:49.394]                     muffled <- FALSE
[08:25:49.394]                     if (inherits(cond, "message")) {
[08:25:49.394]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.394]                       if (muffled) 
[08:25:49.394]                         invokeRestart("muffleMessage")
[08:25:49.394]                     }
[08:25:49.394]                     else if (inherits(cond, "warning")) {
[08:25:49.394]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.394]                       if (muffled) 
[08:25:49.394]                         invokeRestart("muffleWarning")
[08:25:49.394]                     }
[08:25:49.394]                     else if (inherits(cond, "condition")) {
[08:25:49.394]                       if (!is.null(pattern)) {
[08:25:49.394]                         computeRestarts <- base::computeRestarts
[08:25:49.394]                         grepl <- base::grepl
[08:25:49.394]                         restarts <- computeRestarts(cond)
[08:25:49.394]                         for (restart in restarts) {
[08:25:49.394]                           name <- restart$name
[08:25:49.394]                           if (is.null(name)) 
[08:25:49.394]                             next
[08:25:49.394]                           if (!grepl(pattern, name)) 
[08:25:49.394]                             next
[08:25:49.394]                           invokeRestart(restart)
[08:25:49.394]                           muffled <- TRUE
[08:25:49.394]                           break
[08:25:49.394]                         }
[08:25:49.394]                       }
[08:25:49.394]                     }
[08:25:49.394]                     invisible(muffled)
[08:25:49.394]                   }
[08:25:49.394]                   muffleCondition(cond)
[08:25:49.394]                 })
[08:25:49.394]             }))
[08:25:49.394]             future::FutureResult(value = ...future.value$value, 
[08:25:49.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.394]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.394]                     ...future.globalenv.names))
[08:25:49.394]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.394]         }, condition = base::local({
[08:25:49.394]             c <- base::c
[08:25:49.394]             inherits <- base::inherits
[08:25:49.394]             invokeRestart <- base::invokeRestart
[08:25:49.394]             length <- base::length
[08:25:49.394]             list <- base::list
[08:25:49.394]             seq.int <- base::seq.int
[08:25:49.394]             signalCondition <- base::signalCondition
[08:25:49.394]             sys.calls <- base::sys.calls
[08:25:49.394]             `[[` <- base::`[[`
[08:25:49.394]             `+` <- base::`+`
[08:25:49.394]             `<<-` <- base::`<<-`
[08:25:49.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.394]                   3L)]
[08:25:49.394]             }
[08:25:49.394]             function(cond) {
[08:25:49.394]                 is_error <- inherits(cond, "error")
[08:25:49.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.394]                   NULL)
[08:25:49.394]                 if (is_error) {
[08:25:49.394]                   sessionInformation <- function() {
[08:25:49.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.394]                       search = base::search(), system = base::Sys.info())
[08:25:49.394]                   }
[08:25:49.394]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.394]                     cond$call), session = sessionInformation(), 
[08:25:49.394]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.394]                   signalCondition(cond)
[08:25:49.394]                 }
[08:25:49.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.394]                 "immediateCondition"))) {
[08:25:49.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.394]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.394]                   if (TRUE && !signal) {
[08:25:49.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.394]                     {
[08:25:49.394]                       inherits <- base::inherits
[08:25:49.394]                       invokeRestart <- base::invokeRestart
[08:25:49.394]                       is.null <- base::is.null
[08:25:49.394]                       muffled <- FALSE
[08:25:49.394]                       if (inherits(cond, "message")) {
[08:25:49.394]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.394]                         if (muffled) 
[08:25:49.394]                           invokeRestart("muffleMessage")
[08:25:49.394]                       }
[08:25:49.394]                       else if (inherits(cond, "warning")) {
[08:25:49.394]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.394]                         if (muffled) 
[08:25:49.394]                           invokeRestart("muffleWarning")
[08:25:49.394]                       }
[08:25:49.394]                       else if (inherits(cond, "condition")) {
[08:25:49.394]                         if (!is.null(pattern)) {
[08:25:49.394]                           computeRestarts <- base::computeRestarts
[08:25:49.394]                           grepl <- base::grepl
[08:25:49.394]                           restarts <- computeRestarts(cond)
[08:25:49.394]                           for (restart in restarts) {
[08:25:49.394]                             name <- restart$name
[08:25:49.394]                             if (is.null(name)) 
[08:25:49.394]                               next
[08:25:49.394]                             if (!grepl(pattern, name)) 
[08:25:49.394]                               next
[08:25:49.394]                             invokeRestart(restart)
[08:25:49.394]                             muffled <- TRUE
[08:25:49.394]                             break
[08:25:49.394]                           }
[08:25:49.394]                         }
[08:25:49.394]                       }
[08:25:49.394]                       invisible(muffled)
[08:25:49.394]                     }
[08:25:49.394]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.394]                   }
[08:25:49.394]                 }
[08:25:49.394]                 else {
[08:25:49.394]                   if (TRUE) {
[08:25:49.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.394]                     {
[08:25:49.394]                       inherits <- base::inherits
[08:25:49.394]                       invokeRestart <- base::invokeRestart
[08:25:49.394]                       is.null <- base::is.null
[08:25:49.394]                       muffled <- FALSE
[08:25:49.394]                       if (inherits(cond, "message")) {
[08:25:49.394]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.394]                         if (muffled) 
[08:25:49.394]                           invokeRestart("muffleMessage")
[08:25:49.394]                       }
[08:25:49.394]                       else if (inherits(cond, "warning")) {
[08:25:49.394]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.394]                         if (muffled) 
[08:25:49.394]                           invokeRestart("muffleWarning")
[08:25:49.394]                       }
[08:25:49.394]                       else if (inherits(cond, "condition")) {
[08:25:49.394]                         if (!is.null(pattern)) {
[08:25:49.394]                           computeRestarts <- base::computeRestarts
[08:25:49.394]                           grepl <- base::grepl
[08:25:49.394]                           restarts <- computeRestarts(cond)
[08:25:49.394]                           for (restart in restarts) {
[08:25:49.394]                             name <- restart$name
[08:25:49.394]                             if (is.null(name)) 
[08:25:49.394]                               next
[08:25:49.394]                             if (!grepl(pattern, name)) 
[08:25:49.394]                               next
[08:25:49.394]                             invokeRestart(restart)
[08:25:49.394]                             muffled <- TRUE
[08:25:49.394]                             break
[08:25:49.394]                           }
[08:25:49.394]                         }
[08:25:49.394]                       }
[08:25:49.394]                       invisible(muffled)
[08:25:49.394]                     }
[08:25:49.394]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.394]                   }
[08:25:49.394]                 }
[08:25:49.394]             }
[08:25:49.394]         }))
[08:25:49.394]     }, error = function(ex) {
[08:25:49.394]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.394]                 ...future.rng), started = ...future.startTime, 
[08:25:49.394]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.394]             version = "1.8"), class = "FutureResult")
[08:25:49.394]     }, finally = {
[08:25:49.394]         if (!identical(...future.workdir, getwd())) 
[08:25:49.394]             setwd(...future.workdir)
[08:25:49.394]         {
[08:25:49.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.394]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.394]             }
[08:25:49.394]             base::options(...future.oldOptions)
[08:25:49.394]             if (.Platform$OS.type == "windows") {
[08:25:49.394]                 old_names <- names(...future.oldEnvVars)
[08:25:49.394]                 envs <- base::Sys.getenv()
[08:25:49.394]                 names <- names(envs)
[08:25:49.394]                 common <- intersect(names, old_names)
[08:25:49.394]                 added <- setdiff(names, old_names)
[08:25:49.394]                 removed <- setdiff(old_names, names)
[08:25:49.394]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.394]                   envs[common]]
[08:25:49.394]                 NAMES <- toupper(changed)
[08:25:49.394]                 args <- list()
[08:25:49.394]                 for (kk in seq_along(NAMES)) {
[08:25:49.394]                   name <- changed[[kk]]
[08:25:49.394]                   NAME <- NAMES[[kk]]
[08:25:49.394]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.394]                     next
[08:25:49.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.394]                 }
[08:25:49.394]                 NAMES <- toupper(added)
[08:25:49.394]                 for (kk in seq_along(NAMES)) {
[08:25:49.394]                   name <- added[[kk]]
[08:25:49.394]                   NAME <- NAMES[[kk]]
[08:25:49.394]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.394]                     next
[08:25:49.394]                   args[[name]] <- ""
[08:25:49.394]                 }
[08:25:49.394]                 NAMES <- toupper(removed)
[08:25:49.394]                 for (kk in seq_along(NAMES)) {
[08:25:49.394]                   name <- removed[[kk]]
[08:25:49.394]                   NAME <- NAMES[[kk]]
[08:25:49.394]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.394]                     next
[08:25:49.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.394]                 }
[08:25:49.394]                 if (length(args) > 0) 
[08:25:49.394]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.394]             }
[08:25:49.394]             else {
[08:25:49.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.394]             }
[08:25:49.394]             {
[08:25:49.394]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.394]                   0L) {
[08:25:49.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.394]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.394]                   base::options(opts)
[08:25:49.394]                 }
[08:25:49.394]                 {
[08:25:49.394]                   {
[08:25:49.394]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.394]                     NULL
[08:25:49.394]                   }
[08:25:49.394]                   options(future.plan = NULL)
[08:25:49.394]                   if (is.na(NA_character_)) 
[08:25:49.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.394]                     .init = FALSE)
[08:25:49.394]                 }
[08:25:49.394]             }
[08:25:49.394]         }
[08:25:49.394]     })
[08:25:49.394]     if (TRUE) {
[08:25:49.394]         base::sink(type = "output", split = FALSE)
[08:25:49.394]         if (TRUE) {
[08:25:49.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.394]         }
[08:25:49.394]         else {
[08:25:49.394]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.394]         }
[08:25:49.394]         base::close(...future.stdout)
[08:25:49.394]         ...future.stdout <- NULL
[08:25:49.394]     }
[08:25:49.394]     ...future.result$conditions <- ...future.conditions
[08:25:49.394]     ...future.result$finished <- base::Sys.time()
[08:25:49.394]     ...future.result
[08:25:49.394] }
[08:25:49.397] assign_globals() ...
[08:25:49.397] List of 5
[08:25:49.397]  $ ...future.FUN            :function (C, k)  
[08:25:49.397]  $ MoreArgs                 : list()
[08:25:49.397]  $ ...future.elements_ii    :List of 2
[08:25:49.397]   ..$ :List of 2
[08:25:49.397]   .. ..$ : chr "A"
[08:25:49.397]   .. ..$ : chr "B"
[08:25:49.397]   ..$ :List of 2
[08:25:49.397]   .. ..$ : int 5
[08:25:49.397]   .. ..$ : int 4
[08:25:49.397]  $ ...future.seeds_ii       : NULL
[08:25:49.397]  $ ...future.globals.maxSize: NULL
[08:25:49.397]  - attr(*, "where")=List of 5
[08:25:49.397]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.397]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.397]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.397]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.397]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.397]  - attr(*, "resolved")= logi FALSE
[08:25:49.397]  - attr(*, "total_size")= num 880
[08:25:49.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.397]  - attr(*, "already-done")= logi TRUE
[08:25:49.403] - reassign environment for ‘...future.FUN’
[08:25:49.403] - copied ‘...future.FUN’ to environment
[08:25:49.403] - copied ‘MoreArgs’ to environment
[08:25:49.403] - copied ‘...future.elements_ii’ to environment
[08:25:49.403] - copied ‘...future.seeds_ii’ to environment
[08:25:49.403] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.405] assign_globals() ... done
[08:25:49.405] requestCore(): workers = 2
[08:25:49.408] MulticoreFuture started
[08:25:49.409] - Launch lazy future ... done
[08:25:49.409] plan(): Setting new future strategy stack:
[08:25:49.409] run() for ‘MulticoreFuture’ ... done
[08:25:49.410] Created future:
[08:25:49.410] List of future strategies:
[08:25:49.410] 1. sequential:
[08:25:49.410]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.410]    - tweaked: FALSE
[08:25:49.410]    - call: NULL
[08:25:49.412] plan(): nbrOfWorkers() = 1
[08:25:49.415] plan(): Setting new future strategy stack:
[08:25:49.415] List of future strategies:
[08:25:49.415] 1. multicore:
[08:25:49.415]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.415]    - tweaked: FALSE
[08:25:49.415]    - call: plan(strategy)
[08:25:49.420] plan(): nbrOfWorkers() = 2
[08:25:49.410] MulticoreFuture:
[08:25:49.410] Label: ‘future_.mapply-1’
[08:25:49.410] Expression:
[08:25:49.410] {
[08:25:49.410]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.410]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.410]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.410]         on.exit(options(oopts), add = TRUE)
[08:25:49.410]     }
[08:25:49.410]     {
[08:25:49.410]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.410]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.410]         do.call(mapply, args = args)
[08:25:49.410]     }
[08:25:49.410] }
[08:25:49.410] Lazy evaluation: FALSE
[08:25:49.410] Asynchronous evaluation: TRUE
[08:25:49.410] Local evaluation: TRUE
[08:25:49.410] Environment: R_GlobalEnv
[08:25:49.410] Capture standard output: TRUE
[08:25:49.410] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.410] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.410] Packages: <none>
[08:25:49.410] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.410] Resolved: TRUE
[08:25:49.410] Value: <not collected>
[08:25:49.410] Conditions captured: <none>
[08:25:49.410] Early signaling: FALSE
[08:25:49.410] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.410] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.421] Chunk #1 of 2 ... DONE
[08:25:49.421] Chunk #2 of 2 ...
[08:25:49.422]  - Finding globals in '...' for chunk #2 ...
[08:25:49.422] getGlobalsAndPackages() ...
[08:25:49.422] Searching for globals...
[08:25:49.423] 
[08:25:49.423] Searching for globals ... DONE
[08:25:49.423] - globals: [0] <none>
[08:25:49.424] getGlobalsAndPackages() ... DONE
[08:25:49.424]    + additional globals found: [n=0] 
[08:25:49.424]    + additional namespaces needed: [n=0] 
[08:25:49.424]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:49.424]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.425]  - seeds: <none>
[08:25:49.425]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.425] getGlobalsAndPackages() ...
[08:25:49.425] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.426] Resolving globals: FALSE
[08:25:49.427] The total size of the 5 globals is 909 bytes (909 bytes)
[08:25:49.428] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:49.428] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.428] 
[08:25:49.429] getGlobalsAndPackages() ... DONE
[08:25:49.429] run() for ‘Future’ ...
[08:25:49.430] - state: ‘created’
[08:25:49.430] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.433] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.433] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.433]   - Field: ‘label’
[08:25:49.433]   - Field: ‘local’
[08:25:49.433]   - Field: ‘owner’
[08:25:49.433]   - Field: ‘envir’
[08:25:49.434]   - Field: ‘workers’
[08:25:49.434]   - Field: ‘packages’
[08:25:49.434]   - Field: ‘gc’
[08:25:49.434]   - Field: ‘job’
[08:25:49.434]   - Field: ‘conditions’
[08:25:49.434]   - Field: ‘expr’
[08:25:49.434]   - Field: ‘uuid’
[08:25:49.434]   - Field: ‘seed’
[08:25:49.435]   - Field: ‘version’
[08:25:49.435]   - Field: ‘result’
[08:25:49.435]   - Field: ‘asynchronous’
[08:25:49.435]   - Field: ‘calls’
[08:25:49.435]   - Field: ‘globals’
[08:25:49.435]   - Field: ‘stdout’
[08:25:49.435]   - Field: ‘earlySignal’
[08:25:49.435]   - Field: ‘lazy’
[08:25:49.436]   - Field: ‘state’
[08:25:49.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.436] - Launch lazy future ...
[08:25:49.436] Packages needed by the future expression (n = 0): <none>
[08:25:49.436] Packages needed by future strategies (n = 0): <none>
[08:25:49.437] {
[08:25:49.437]     {
[08:25:49.437]         {
[08:25:49.437]             ...future.startTime <- base::Sys.time()
[08:25:49.437]             {
[08:25:49.437]                 {
[08:25:49.437]                   {
[08:25:49.437]                     {
[08:25:49.437]                       base::local({
[08:25:49.437]                         has_future <- base::requireNamespace("future", 
[08:25:49.437]                           quietly = TRUE)
[08:25:49.437]                         if (has_future) {
[08:25:49.437]                           ns <- base::getNamespace("future")
[08:25:49.437]                           version <- ns[[".package"]][["version"]]
[08:25:49.437]                           if (is.null(version)) 
[08:25:49.437]                             version <- utils::packageVersion("future")
[08:25:49.437]                         }
[08:25:49.437]                         else {
[08:25:49.437]                           version <- NULL
[08:25:49.437]                         }
[08:25:49.437]                         if (!has_future || version < "1.8.0") {
[08:25:49.437]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.437]                             "", base::R.version$version.string), 
[08:25:49.437]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.437]                               "release", "version")], collapse = " "), 
[08:25:49.437]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.437]                             info)
[08:25:49.437]                           info <- base::paste(info, collapse = "; ")
[08:25:49.437]                           if (!has_future) {
[08:25:49.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.437]                               info)
[08:25:49.437]                           }
[08:25:49.437]                           else {
[08:25:49.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.437]                               info, version)
[08:25:49.437]                           }
[08:25:49.437]                           base::stop(msg)
[08:25:49.437]                         }
[08:25:49.437]                       })
[08:25:49.437]                     }
[08:25:49.437]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.437]                     base::options(mc.cores = 1L)
[08:25:49.437]                   }
[08:25:49.437]                   ...future.strategy.old <- future::plan("list")
[08:25:49.437]                   options(future.plan = NULL)
[08:25:49.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.437]                 }
[08:25:49.437]                 ...future.workdir <- getwd()
[08:25:49.437]             }
[08:25:49.437]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.437]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.437]         }
[08:25:49.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.437]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.437]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.437]             base::names(...future.oldOptions))
[08:25:49.437]     }
[08:25:49.437]     if (FALSE) {
[08:25:49.437]     }
[08:25:49.437]     else {
[08:25:49.437]         if (TRUE) {
[08:25:49.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.437]                 open = "w")
[08:25:49.437]         }
[08:25:49.437]         else {
[08:25:49.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.437]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.437]         }
[08:25:49.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.437]             base::sink(type = "output", split = FALSE)
[08:25:49.437]             base::close(...future.stdout)
[08:25:49.437]         }, add = TRUE)
[08:25:49.437]     }
[08:25:49.437]     ...future.frame <- base::sys.nframe()
[08:25:49.437]     ...future.conditions <- base::list()
[08:25:49.437]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.437]     if (FALSE) {
[08:25:49.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.437]     }
[08:25:49.437]     ...future.result <- base::tryCatch({
[08:25:49.437]         base::withCallingHandlers({
[08:25:49.437]             ...future.value <- base::withVisible(base::local({
[08:25:49.437]                 withCallingHandlers({
[08:25:49.437]                   {
[08:25:49.437]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.437]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.437]                       ...future.globals.maxSize)) {
[08:25:49.437]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.437]                       on.exit(options(oopts), add = TRUE)
[08:25:49.437]                     }
[08:25:49.437]                     {
[08:25:49.437]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.437]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.437]                         USE.NAMES = FALSE)
[08:25:49.437]                       do.call(mapply, args = args)
[08:25:49.437]                     }
[08:25:49.437]                   }
[08:25:49.437]                 }, immediateCondition = function(cond) {
[08:25:49.437]                   save_rds <- function (object, pathname, ...) 
[08:25:49.437]                   {
[08:25:49.437]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.437]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.437]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.437]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.437]                         fi_tmp[["mtime"]])
[08:25:49.437]                     }
[08:25:49.437]                     tryCatch({
[08:25:49.437]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.437]                     }, error = function(ex) {
[08:25:49.437]                       msg <- conditionMessage(ex)
[08:25:49.437]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.437]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.437]                         fi_tmp[["mtime"]], msg)
[08:25:49.437]                       ex$message <- msg
[08:25:49.437]                       stop(ex)
[08:25:49.437]                     })
[08:25:49.437]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.437]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.437]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.437]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.437]                       fi <- file.info(pathname)
[08:25:49.437]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.437]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.437]                         fi[["size"]], fi[["mtime"]])
[08:25:49.437]                       stop(msg)
[08:25:49.437]                     }
[08:25:49.437]                     invisible(pathname)
[08:25:49.437]                   }
[08:25:49.437]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.437]                     rootPath = tempdir()) 
[08:25:49.437]                   {
[08:25:49.437]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.437]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.437]                       tmpdir = path, fileext = ".rds")
[08:25:49.437]                     save_rds(obj, file)
[08:25:49.437]                   }
[08:25:49.437]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.437]                   {
[08:25:49.437]                     inherits <- base::inherits
[08:25:49.437]                     invokeRestart <- base::invokeRestart
[08:25:49.437]                     is.null <- base::is.null
[08:25:49.437]                     muffled <- FALSE
[08:25:49.437]                     if (inherits(cond, "message")) {
[08:25:49.437]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.437]                       if (muffled) 
[08:25:49.437]                         invokeRestart("muffleMessage")
[08:25:49.437]                     }
[08:25:49.437]                     else if (inherits(cond, "warning")) {
[08:25:49.437]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.437]                       if (muffled) 
[08:25:49.437]                         invokeRestart("muffleWarning")
[08:25:49.437]                     }
[08:25:49.437]                     else if (inherits(cond, "condition")) {
[08:25:49.437]                       if (!is.null(pattern)) {
[08:25:49.437]                         computeRestarts <- base::computeRestarts
[08:25:49.437]                         grepl <- base::grepl
[08:25:49.437]                         restarts <- computeRestarts(cond)
[08:25:49.437]                         for (restart in restarts) {
[08:25:49.437]                           name <- restart$name
[08:25:49.437]                           if (is.null(name)) 
[08:25:49.437]                             next
[08:25:49.437]                           if (!grepl(pattern, name)) 
[08:25:49.437]                             next
[08:25:49.437]                           invokeRestart(restart)
[08:25:49.437]                           muffled <- TRUE
[08:25:49.437]                           break
[08:25:49.437]                         }
[08:25:49.437]                       }
[08:25:49.437]                     }
[08:25:49.437]                     invisible(muffled)
[08:25:49.437]                   }
[08:25:49.437]                   muffleCondition(cond)
[08:25:49.437]                 })
[08:25:49.437]             }))
[08:25:49.437]             future::FutureResult(value = ...future.value$value, 
[08:25:49.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.437]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.437]                     ...future.globalenv.names))
[08:25:49.437]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.437]         }, condition = base::local({
[08:25:49.437]             c <- base::c
[08:25:49.437]             inherits <- base::inherits
[08:25:49.437]             invokeRestart <- base::invokeRestart
[08:25:49.437]             length <- base::length
[08:25:49.437]             list <- base::list
[08:25:49.437]             seq.int <- base::seq.int
[08:25:49.437]             signalCondition <- base::signalCondition
[08:25:49.437]             sys.calls <- base::sys.calls
[08:25:49.437]             `[[` <- base::`[[`
[08:25:49.437]             `+` <- base::`+`
[08:25:49.437]             `<<-` <- base::`<<-`
[08:25:49.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.437]                   3L)]
[08:25:49.437]             }
[08:25:49.437]             function(cond) {
[08:25:49.437]                 is_error <- inherits(cond, "error")
[08:25:49.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.437]                   NULL)
[08:25:49.437]                 if (is_error) {
[08:25:49.437]                   sessionInformation <- function() {
[08:25:49.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.437]                       search = base::search(), system = base::Sys.info())
[08:25:49.437]                   }
[08:25:49.437]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.437]                     cond$call), session = sessionInformation(), 
[08:25:49.437]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.437]                   signalCondition(cond)
[08:25:49.437]                 }
[08:25:49.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.437]                 "immediateCondition"))) {
[08:25:49.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.437]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.437]                   if (TRUE && !signal) {
[08:25:49.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.437]                     {
[08:25:49.437]                       inherits <- base::inherits
[08:25:49.437]                       invokeRestart <- base::invokeRestart
[08:25:49.437]                       is.null <- base::is.null
[08:25:49.437]                       muffled <- FALSE
[08:25:49.437]                       if (inherits(cond, "message")) {
[08:25:49.437]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.437]                         if (muffled) 
[08:25:49.437]                           invokeRestart("muffleMessage")
[08:25:49.437]                       }
[08:25:49.437]                       else if (inherits(cond, "warning")) {
[08:25:49.437]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.437]                         if (muffled) 
[08:25:49.437]                           invokeRestart("muffleWarning")
[08:25:49.437]                       }
[08:25:49.437]                       else if (inherits(cond, "condition")) {
[08:25:49.437]                         if (!is.null(pattern)) {
[08:25:49.437]                           computeRestarts <- base::computeRestarts
[08:25:49.437]                           grepl <- base::grepl
[08:25:49.437]                           restarts <- computeRestarts(cond)
[08:25:49.437]                           for (restart in restarts) {
[08:25:49.437]                             name <- restart$name
[08:25:49.437]                             if (is.null(name)) 
[08:25:49.437]                               next
[08:25:49.437]                             if (!grepl(pattern, name)) 
[08:25:49.437]                               next
[08:25:49.437]                             invokeRestart(restart)
[08:25:49.437]                             muffled <- TRUE
[08:25:49.437]                             break
[08:25:49.437]                           }
[08:25:49.437]                         }
[08:25:49.437]                       }
[08:25:49.437]                       invisible(muffled)
[08:25:49.437]                     }
[08:25:49.437]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.437]                   }
[08:25:49.437]                 }
[08:25:49.437]                 else {
[08:25:49.437]                   if (TRUE) {
[08:25:49.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.437]                     {
[08:25:49.437]                       inherits <- base::inherits
[08:25:49.437]                       invokeRestart <- base::invokeRestart
[08:25:49.437]                       is.null <- base::is.null
[08:25:49.437]                       muffled <- FALSE
[08:25:49.437]                       if (inherits(cond, "message")) {
[08:25:49.437]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.437]                         if (muffled) 
[08:25:49.437]                           invokeRestart("muffleMessage")
[08:25:49.437]                       }
[08:25:49.437]                       else if (inherits(cond, "warning")) {
[08:25:49.437]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.437]                         if (muffled) 
[08:25:49.437]                           invokeRestart("muffleWarning")
[08:25:49.437]                       }
[08:25:49.437]                       else if (inherits(cond, "condition")) {
[08:25:49.437]                         if (!is.null(pattern)) {
[08:25:49.437]                           computeRestarts <- base::computeRestarts
[08:25:49.437]                           grepl <- base::grepl
[08:25:49.437]                           restarts <- computeRestarts(cond)
[08:25:49.437]                           for (restart in restarts) {
[08:25:49.437]                             name <- restart$name
[08:25:49.437]                             if (is.null(name)) 
[08:25:49.437]                               next
[08:25:49.437]                             if (!grepl(pattern, name)) 
[08:25:49.437]                               next
[08:25:49.437]                             invokeRestart(restart)
[08:25:49.437]                             muffled <- TRUE
[08:25:49.437]                             break
[08:25:49.437]                           }
[08:25:49.437]                         }
[08:25:49.437]                       }
[08:25:49.437]                       invisible(muffled)
[08:25:49.437]                     }
[08:25:49.437]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.437]                   }
[08:25:49.437]                 }
[08:25:49.437]             }
[08:25:49.437]         }))
[08:25:49.437]     }, error = function(ex) {
[08:25:49.437]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.437]                 ...future.rng), started = ...future.startTime, 
[08:25:49.437]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.437]             version = "1.8"), class = "FutureResult")
[08:25:49.437]     }, finally = {
[08:25:49.437]         if (!identical(...future.workdir, getwd())) 
[08:25:49.437]             setwd(...future.workdir)
[08:25:49.437]         {
[08:25:49.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.437]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.437]             }
[08:25:49.437]             base::options(...future.oldOptions)
[08:25:49.437]             if (.Platform$OS.type == "windows") {
[08:25:49.437]                 old_names <- names(...future.oldEnvVars)
[08:25:49.437]                 envs <- base::Sys.getenv()
[08:25:49.437]                 names <- names(envs)
[08:25:49.437]                 common <- intersect(names, old_names)
[08:25:49.437]                 added <- setdiff(names, old_names)
[08:25:49.437]                 removed <- setdiff(old_names, names)
[08:25:49.437]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.437]                   envs[common]]
[08:25:49.437]                 NAMES <- toupper(changed)
[08:25:49.437]                 args <- list()
[08:25:49.437]                 for (kk in seq_along(NAMES)) {
[08:25:49.437]                   name <- changed[[kk]]
[08:25:49.437]                   NAME <- NAMES[[kk]]
[08:25:49.437]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.437]                     next
[08:25:49.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.437]                 }
[08:25:49.437]                 NAMES <- toupper(added)
[08:25:49.437]                 for (kk in seq_along(NAMES)) {
[08:25:49.437]                   name <- added[[kk]]
[08:25:49.437]                   NAME <- NAMES[[kk]]
[08:25:49.437]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.437]                     next
[08:25:49.437]                   args[[name]] <- ""
[08:25:49.437]                 }
[08:25:49.437]                 NAMES <- toupper(removed)
[08:25:49.437]                 for (kk in seq_along(NAMES)) {
[08:25:49.437]                   name <- removed[[kk]]
[08:25:49.437]                   NAME <- NAMES[[kk]]
[08:25:49.437]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.437]                     next
[08:25:49.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.437]                 }
[08:25:49.437]                 if (length(args) > 0) 
[08:25:49.437]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.437]             }
[08:25:49.437]             else {
[08:25:49.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.437]             }
[08:25:49.437]             {
[08:25:49.437]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.437]                   0L) {
[08:25:49.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.437]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.437]                   base::options(opts)
[08:25:49.437]                 }
[08:25:49.437]                 {
[08:25:49.437]                   {
[08:25:49.437]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.437]                     NULL
[08:25:49.437]                   }
[08:25:49.437]                   options(future.plan = NULL)
[08:25:49.437]                   if (is.na(NA_character_)) 
[08:25:49.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.437]                     .init = FALSE)
[08:25:49.437]                 }
[08:25:49.437]             }
[08:25:49.437]         }
[08:25:49.437]     })
[08:25:49.437]     if (TRUE) {
[08:25:49.437]         base::sink(type = "output", split = FALSE)
[08:25:49.437]         if (TRUE) {
[08:25:49.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.437]         }
[08:25:49.437]         else {
[08:25:49.437]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.437]         }
[08:25:49.437]         base::close(...future.stdout)
[08:25:49.437]         ...future.stdout <- NULL
[08:25:49.437]     }
[08:25:49.437]     ...future.result$conditions <- ...future.conditions
[08:25:49.437]     ...future.result$finished <- base::Sys.time()
[08:25:49.437]     ...future.result
[08:25:49.437] }
[08:25:49.441] assign_globals() ...
[08:25:49.441] List of 5
[08:25:49.441]  $ ...future.FUN            :function (C, k)  
[08:25:49.441]  $ MoreArgs                 : list()
[08:25:49.441]  $ ...future.elements_ii    :List of 2
[08:25:49.441]   ..$ :List of 3
[08:25:49.441]   .. ..$ : chr "C"
[08:25:49.441]   .. ..$ : chr "D"
[08:25:49.441]   .. ..$ : chr "E"
[08:25:49.441]   ..$ :List of 3
[08:25:49.441]   .. ..$ : int 3
[08:25:49.441]   .. ..$ : int 2
[08:25:49.441]   .. ..$ : int 1
[08:25:49.441]  $ ...future.seeds_ii       : NULL
[08:25:49.441]  $ ...future.globals.maxSize: NULL
[08:25:49.441]  - attr(*, "where")=List of 5
[08:25:49.441]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.441]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.441]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.441]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.441]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.441]  - attr(*, "resolved")= logi FALSE
[08:25:49.441]  - attr(*, "total_size")= num 909
[08:25:49.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.441]  - attr(*, "already-done")= logi TRUE
[08:25:49.449] - reassign environment for ‘...future.FUN’
[08:25:49.449] - copied ‘...future.FUN’ to environment
[08:25:49.449] - copied ‘MoreArgs’ to environment
[08:25:49.449] - copied ‘...future.elements_ii’ to environment
[08:25:49.449] - copied ‘...future.seeds_ii’ to environment
[08:25:49.449] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.449] assign_globals() ... done
[08:25:49.450] requestCore(): workers = 2
[08:25:49.452] MulticoreFuture started
[08:25:49.453] - Launch lazy future ... done
[08:25:49.453] run() for ‘MulticoreFuture’ ... done
[08:25:49.453] Created future:
[08:25:49.453] plan(): Setting new future strategy stack:
[08:25:49.453] List of future strategies:
[08:25:49.453] 1. sequential:
[08:25:49.453]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.453]    - tweaked: FALSE
[08:25:49.453]    - call: NULL
[08:25:49.459] plan(): nbrOfWorkers() = 1
[08:25:49.462] plan(): Setting new future strategy stack:
[08:25:49.462] List of future strategies:
[08:25:49.462] 1. multicore:
[08:25:49.462]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.462]    - tweaked: FALSE
[08:25:49.462]    - call: plan(strategy)
[08:25:49.467] plan(): nbrOfWorkers() = 2
[08:25:49.453] MulticoreFuture:
[08:25:49.453] Label: ‘future_.mapply-2’
[08:25:49.453] Expression:
[08:25:49.453] {
[08:25:49.453]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.453]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.453]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.453]         on.exit(options(oopts), add = TRUE)
[08:25:49.453]     }
[08:25:49.453]     {
[08:25:49.453]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.453]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.453]         do.call(mapply, args = args)
[08:25:49.453]     }
[08:25:49.453] }
[08:25:49.453] Lazy evaluation: FALSE
[08:25:49.453] Asynchronous evaluation: TRUE
[08:25:49.453] Local evaluation: TRUE
[08:25:49.453] Environment: R_GlobalEnv
[08:25:49.453] Capture standard output: TRUE
[08:25:49.453] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.453] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.453] Packages: <none>
[08:25:49.453] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.453] Resolved: TRUE
[08:25:49.453] Value: <not collected>
[08:25:49.453] Conditions captured: <none>
[08:25:49.453] Early signaling: FALSE
[08:25:49.453] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.453] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.469] Chunk #2 of 2 ... DONE
[08:25:49.469] Launching 2 futures (chunks) ... DONE
[08:25:49.469] Resolving 2 futures (chunks) ...
[08:25:49.469] resolve() on list ...
[08:25:49.470]  recursive: 0
[08:25:49.470]  length: 2
[08:25:49.470] 
[08:25:49.470] Future #1
[08:25:49.471] result() for MulticoreFuture ...
[08:25:49.472] result() for MulticoreFuture ...
[08:25:49.472] result() for MulticoreFuture ... done
[08:25:49.472] result() for MulticoreFuture ... done
[08:25:49.472] result() for MulticoreFuture ...
[08:25:49.473] result() for MulticoreFuture ... done
[08:25:49.473] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:49.473] - nx: 2
[08:25:49.473] - relay: TRUE
[08:25:49.473] - stdout: TRUE
[08:25:49.474] - signal: TRUE
[08:25:49.474] - resignal: FALSE
[08:25:49.474] - force: TRUE
[08:25:49.474] - relayed: [n=2] FALSE, FALSE
[08:25:49.474] - queued futures: [n=2] FALSE, FALSE
[08:25:49.475]  - until=1
[08:25:49.475]  - relaying element #1
[08:25:49.475] result() for MulticoreFuture ...
[08:25:49.475] result() for MulticoreFuture ... done
[08:25:49.476] result() for MulticoreFuture ...
[08:25:49.476] result() for MulticoreFuture ... done
[08:25:49.476] result() for MulticoreFuture ...
[08:25:49.476] result() for MulticoreFuture ... done
[08:25:49.477] result() for MulticoreFuture ...
[08:25:49.477] result() for MulticoreFuture ... done
[08:25:49.477] - relayed: [n=2] TRUE, FALSE
[08:25:49.477] - queued futures: [n=2] TRUE, FALSE
[08:25:49.478] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:49.478]  length: 1 (resolved future 1)
[08:25:49.478] Future #2
[08:25:49.479] result() for MulticoreFuture ...
[08:25:49.479] result() for MulticoreFuture ...
[08:25:49.480] result() for MulticoreFuture ... done
[08:25:49.480] result() for MulticoreFuture ... done
[08:25:49.480] result() for MulticoreFuture ...
[08:25:49.480] result() for MulticoreFuture ... done
[08:25:49.480] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:49.480] - nx: 2
[08:25:49.480] - relay: TRUE
[08:25:49.481] - stdout: TRUE
[08:25:49.481] - signal: TRUE
[08:25:49.481] - resignal: FALSE
[08:25:49.481] - force: TRUE
[08:25:49.481] - relayed: [n=2] TRUE, FALSE
[08:25:49.481] - queued futures: [n=2] TRUE, FALSE
[08:25:49.481]  - until=2
[08:25:49.481]  - relaying element #2
[08:25:49.482] result() for MulticoreFuture ...
[08:25:49.482] result() for MulticoreFuture ... done
[08:25:49.482] result() for MulticoreFuture ...
[08:25:49.482] result() for MulticoreFuture ... done
[08:25:49.482] result() for MulticoreFuture ...
[08:25:49.482] result() for MulticoreFuture ... done
[08:25:49.482] result() for MulticoreFuture ...
[08:25:49.482] result() for MulticoreFuture ... done
[08:25:49.482] - relayed: [n=2] TRUE, TRUE
[08:25:49.483] - queued futures: [n=2] TRUE, TRUE
[08:25:49.483] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:49.483]  length: 0 (resolved future 2)
[08:25:49.483] Relaying remaining futures
[08:25:49.483] signalConditionsASAP(NULL, pos=0) ...
[08:25:49.483] - nx: 2
[08:25:49.483] - relay: TRUE
[08:25:49.483] - stdout: TRUE
[08:25:49.483] - signal: TRUE
[08:25:49.483] - resignal: FALSE
[08:25:49.484] - force: TRUE
[08:25:49.484] - relayed: [n=2] TRUE, TRUE
[08:25:49.484] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:49.484] - relayed: [n=2] TRUE, TRUE
[08:25:49.484] - queued futures: [n=2] TRUE, TRUE
[08:25:49.484] signalConditionsASAP(NULL, pos=0) ... done
[08:25:49.484] resolve() on list ... DONE
[08:25:49.484] result() for MulticoreFuture ...
[08:25:49.484] result() for MulticoreFuture ... done
[08:25:49.485] result() for MulticoreFuture ...
[08:25:49.485] result() for MulticoreFuture ... done
[08:25:49.485] result() for MulticoreFuture ...
[08:25:49.485] result() for MulticoreFuture ... done
[08:25:49.485] result() for MulticoreFuture ...
[08:25:49.485] result() for MulticoreFuture ... done
[08:25:49.485]  - Number of value chunks collected: 2
[08:25:49.485] Resolving 2 futures (chunks) ... DONE
[08:25:49.485] Reducing values from 2 chunks ...
[08:25:49.486]  - Number of values collected after concatenation: 5
[08:25:49.486]  - Number of values expected: 5
[08:25:49.486] Reducing values from 2 chunks ... DONE
[08:25:49.486] future_mapply() ... DONE
[08:25:49.486] future_mapply() ...
[08:25:49.488] Number of chunks: 2
[08:25:49.488] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[08:25:49.489] getGlobalsAndPackagesXApply() ...
[08:25:49.489]  - future.globals: TRUE
[08:25:49.489] getGlobalsAndPackages() ...
[08:25:49.489] Searching for globals...
[08:25:49.490] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:49.491] Searching for globals ... DONE
[08:25:49.491] Resolving globals: FALSE
[08:25:49.491] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:49.491] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:49.492] - globals: [1] ‘FUN’
[08:25:49.492] 
[08:25:49.492] getGlobalsAndPackages() ... DONE
[08:25:49.492]  - globals found/used: [n=1] ‘FUN’
[08:25:49.492]  - needed namespaces: [n=0] 
[08:25:49.492] Finding globals ... DONE
[08:25:49.492] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:49.492] List of 2
[08:25:49.492]  $ ...future.FUN:function (C, k)  
[08:25:49.492]  $ MoreArgs     : NULL
[08:25:49.492]  - attr(*, "where")=List of 2
[08:25:49.492]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:49.492]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:49.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.492]  - attr(*, "resolved")= logi FALSE
[08:25:49.492]  - attr(*, "total_size")= num NA
[08:25:49.498] Packages to be attached in all futures: [n=0] 
[08:25:49.498] getGlobalsAndPackagesXApply() ... DONE
[08:25:49.498] Number of futures (= number of chunks): 2
[08:25:49.498] Launching 2 futures (chunks) ...
[08:25:49.498] Chunk #1 of 2 ...
[08:25:49.498]  - Finding globals in '...' for chunk #1 ...
[08:25:49.499] getGlobalsAndPackages() ...
[08:25:49.499] Searching for globals...
[08:25:49.499] 
[08:25:49.499] Searching for globals ... DONE
[08:25:49.499] - globals: [0] <none>
[08:25:49.499] getGlobalsAndPackages() ... DONE
[08:25:49.500]    + additional globals found: [n=0] 
[08:25:49.500]    + additional namespaces needed: [n=0] 
[08:25:49.500]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:49.500]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.500]  - seeds: <none>
[08:25:49.500]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.500] getGlobalsAndPackages() ...
[08:25:49.500] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.500] Resolving globals: FALSE
[08:25:49.501] The total size of the 5 globals is 876 bytes (876 bytes)
[08:25:49.502] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:49.502] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.502] 
[08:25:49.502] getGlobalsAndPackages() ... DONE
[08:25:49.502] run() for ‘Future’ ...
[08:25:49.502] - state: ‘created’
[08:25:49.503] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.505] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.505] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.505]   - Field: ‘label’
[08:25:49.505]   - Field: ‘local’
[08:25:49.505]   - Field: ‘owner’
[08:25:49.505]   - Field: ‘envir’
[08:25:49.505]   - Field: ‘workers’
[08:25:49.505]   - Field: ‘packages’
[08:25:49.506]   - Field: ‘gc’
[08:25:49.506]   - Field: ‘job’
[08:25:49.506]   - Field: ‘conditions’
[08:25:49.506]   - Field: ‘expr’
[08:25:49.506]   - Field: ‘uuid’
[08:25:49.506]   - Field: ‘seed’
[08:25:49.506]   - Field: ‘version’
[08:25:49.506]   - Field: ‘result’
[08:25:49.506]   - Field: ‘asynchronous’
[08:25:49.506]   - Field: ‘calls’
[08:25:49.507]   - Field: ‘globals’
[08:25:49.507]   - Field: ‘stdout’
[08:25:49.507]   - Field: ‘earlySignal’
[08:25:49.507]   - Field: ‘lazy’
[08:25:49.507]   - Field: ‘state’
[08:25:49.507] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.507] - Launch lazy future ...
[08:25:49.507] Packages needed by the future expression (n = 0): <none>
[08:25:49.508] Packages needed by future strategies (n = 0): <none>
[08:25:49.508] {
[08:25:49.508]     {
[08:25:49.508]         {
[08:25:49.508]             ...future.startTime <- base::Sys.time()
[08:25:49.508]             {
[08:25:49.508]                 {
[08:25:49.508]                   {
[08:25:49.508]                     {
[08:25:49.508]                       base::local({
[08:25:49.508]                         has_future <- base::requireNamespace("future", 
[08:25:49.508]                           quietly = TRUE)
[08:25:49.508]                         if (has_future) {
[08:25:49.508]                           ns <- base::getNamespace("future")
[08:25:49.508]                           version <- ns[[".package"]][["version"]]
[08:25:49.508]                           if (is.null(version)) 
[08:25:49.508]                             version <- utils::packageVersion("future")
[08:25:49.508]                         }
[08:25:49.508]                         else {
[08:25:49.508]                           version <- NULL
[08:25:49.508]                         }
[08:25:49.508]                         if (!has_future || version < "1.8.0") {
[08:25:49.508]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.508]                             "", base::R.version$version.string), 
[08:25:49.508]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.508]                               "release", "version")], collapse = " "), 
[08:25:49.508]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.508]                             info)
[08:25:49.508]                           info <- base::paste(info, collapse = "; ")
[08:25:49.508]                           if (!has_future) {
[08:25:49.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.508]                               info)
[08:25:49.508]                           }
[08:25:49.508]                           else {
[08:25:49.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.508]                               info, version)
[08:25:49.508]                           }
[08:25:49.508]                           base::stop(msg)
[08:25:49.508]                         }
[08:25:49.508]                       })
[08:25:49.508]                     }
[08:25:49.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.508]                     base::options(mc.cores = 1L)
[08:25:49.508]                   }
[08:25:49.508]                   ...future.strategy.old <- future::plan("list")
[08:25:49.508]                   options(future.plan = NULL)
[08:25:49.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.508]                 }
[08:25:49.508]                 ...future.workdir <- getwd()
[08:25:49.508]             }
[08:25:49.508]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.508]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.508]         }
[08:25:49.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.508]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.508]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.508]             base::names(...future.oldOptions))
[08:25:49.508]     }
[08:25:49.508]     if (FALSE) {
[08:25:49.508]     }
[08:25:49.508]     else {
[08:25:49.508]         if (TRUE) {
[08:25:49.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.508]                 open = "w")
[08:25:49.508]         }
[08:25:49.508]         else {
[08:25:49.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.508]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.508]         }
[08:25:49.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.508]             base::sink(type = "output", split = FALSE)
[08:25:49.508]             base::close(...future.stdout)
[08:25:49.508]         }, add = TRUE)
[08:25:49.508]     }
[08:25:49.508]     ...future.frame <- base::sys.nframe()
[08:25:49.508]     ...future.conditions <- base::list()
[08:25:49.508]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.508]     if (FALSE) {
[08:25:49.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.508]     }
[08:25:49.508]     ...future.result <- base::tryCatch({
[08:25:49.508]         base::withCallingHandlers({
[08:25:49.508]             ...future.value <- base::withVisible(base::local({
[08:25:49.508]                 withCallingHandlers({
[08:25:49.508]                   {
[08:25:49.508]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.508]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.508]                       ...future.globals.maxSize)) {
[08:25:49.508]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.508]                       on.exit(options(oopts), add = TRUE)
[08:25:49.508]                     }
[08:25:49.508]                     {
[08:25:49.508]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.508]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.508]                         USE.NAMES = FALSE)
[08:25:49.508]                       do.call(mapply, args = args)
[08:25:49.508]                     }
[08:25:49.508]                   }
[08:25:49.508]                 }, immediateCondition = function(cond) {
[08:25:49.508]                   save_rds <- function (object, pathname, ...) 
[08:25:49.508]                   {
[08:25:49.508]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.508]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.508]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.508]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.508]                         fi_tmp[["mtime"]])
[08:25:49.508]                     }
[08:25:49.508]                     tryCatch({
[08:25:49.508]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.508]                     }, error = function(ex) {
[08:25:49.508]                       msg <- conditionMessage(ex)
[08:25:49.508]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.508]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.508]                         fi_tmp[["mtime"]], msg)
[08:25:49.508]                       ex$message <- msg
[08:25:49.508]                       stop(ex)
[08:25:49.508]                     })
[08:25:49.508]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.508]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.508]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.508]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.508]                       fi <- file.info(pathname)
[08:25:49.508]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.508]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.508]                         fi[["size"]], fi[["mtime"]])
[08:25:49.508]                       stop(msg)
[08:25:49.508]                     }
[08:25:49.508]                     invisible(pathname)
[08:25:49.508]                   }
[08:25:49.508]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.508]                     rootPath = tempdir()) 
[08:25:49.508]                   {
[08:25:49.508]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.508]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.508]                       tmpdir = path, fileext = ".rds")
[08:25:49.508]                     save_rds(obj, file)
[08:25:49.508]                   }
[08:25:49.508]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.508]                   {
[08:25:49.508]                     inherits <- base::inherits
[08:25:49.508]                     invokeRestart <- base::invokeRestart
[08:25:49.508]                     is.null <- base::is.null
[08:25:49.508]                     muffled <- FALSE
[08:25:49.508]                     if (inherits(cond, "message")) {
[08:25:49.508]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.508]                       if (muffled) 
[08:25:49.508]                         invokeRestart("muffleMessage")
[08:25:49.508]                     }
[08:25:49.508]                     else if (inherits(cond, "warning")) {
[08:25:49.508]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.508]                       if (muffled) 
[08:25:49.508]                         invokeRestart("muffleWarning")
[08:25:49.508]                     }
[08:25:49.508]                     else if (inherits(cond, "condition")) {
[08:25:49.508]                       if (!is.null(pattern)) {
[08:25:49.508]                         computeRestarts <- base::computeRestarts
[08:25:49.508]                         grepl <- base::grepl
[08:25:49.508]                         restarts <- computeRestarts(cond)
[08:25:49.508]                         for (restart in restarts) {
[08:25:49.508]                           name <- restart$name
[08:25:49.508]                           if (is.null(name)) 
[08:25:49.508]                             next
[08:25:49.508]                           if (!grepl(pattern, name)) 
[08:25:49.508]                             next
[08:25:49.508]                           invokeRestart(restart)
[08:25:49.508]                           muffled <- TRUE
[08:25:49.508]                           break
[08:25:49.508]                         }
[08:25:49.508]                       }
[08:25:49.508]                     }
[08:25:49.508]                     invisible(muffled)
[08:25:49.508]                   }
[08:25:49.508]                   muffleCondition(cond)
[08:25:49.508]                 })
[08:25:49.508]             }))
[08:25:49.508]             future::FutureResult(value = ...future.value$value, 
[08:25:49.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.508]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.508]                     ...future.globalenv.names))
[08:25:49.508]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.508]         }, condition = base::local({
[08:25:49.508]             c <- base::c
[08:25:49.508]             inherits <- base::inherits
[08:25:49.508]             invokeRestart <- base::invokeRestart
[08:25:49.508]             length <- base::length
[08:25:49.508]             list <- base::list
[08:25:49.508]             seq.int <- base::seq.int
[08:25:49.508]             signalCondition <- base::signalCondition
[08:25:49.508]             sys.calls <- base::sys.calls
[08:25:49.508]             `[[` <- base::`[[`
[08:25:49.508]             `+` <- base::`+`
[08:25:49.508]             `<<-` <- base::`<<-`
[08:25:49.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.508]                   3L)]
[08:25:49.508]             }
[08:25:49.508]             function(cond) {
[08:25:49.508]                 is_error <- inherits(cond, "error")
[08:25:49.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.508]                   NULL)
[08:25:49.508]                 if (is_error) {
[08:25:49.508]                   sessionInformation <- function() {
[08:25:49.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.508]                       search = base::search(), system = base::Sys.info())
[08:25:49.508]                   }
[08:25:49.508]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.508]                     cond$call), session = sessionInformation(), 
[08:25:49.508]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.508]                   signalCondition(cond)
[08:25:49.508]                 }
[08:25:49.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.508]                 "immediateCondition"))) {
[08:25:49.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.508]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.508]                   if (TRUE && !signal) {
[08:25:49.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.508]                     {
[08:25:49.508]                       inherits <- base::inherits
[08:25:49.508]                       invokeRestart <- base::invokeRestart
[08:25:49.508]                       is.null <- base::is.null
[08:25:49.508]                       muffled <- FALSE
[08:25:49.508]                       if (inherits(cond, "message")) {
[08:25:49.508]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.508]                         if (muffled) 
[08:25:49.508]                           invokeRestart("muffleMessage")
[08:25:49.508]                       }
[08:25:49.508]                       else if (inherits(cond, "warning")) {
[08:25:49.508]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.508]                         if (muffled) 
[08:25:49.508]                           invokeRestart("muffleWarning")
[08:25:49.508]                       }
[08:25:49.508]                       else if (inherits(cond, "condition")) {
[08:25:49.508]                         if (!is.null(pattern)) {
[08:25:49.508]                           computeRestarts <- base::computeRestarts
[08:25:49.508]                           grepl <- base::grepl
[08:25:49.508]                           restarts <- computeRestarts(cond)
[08:25:49.508]                           for (restart in restarts) {
[08:25:49.508]                             name <- restart$name
[08:25:49.508]                             if (is.null(name)) 
[08:25:49.508]                               next
[08:25:49.508]                             if (!grepl(pattern, name)) 
[08:25:49.508]                               next
[08:25:49.508]                             invokeRestart(restart)
[08:25:49.508]                             muffled <- TRUE
[08:25:49.508]                             break
[08:25:49.508]                           }
[08:25:49.508]                         }
[08:25:49.508]                       }
[08:25:49.508]                       invisible(muffled)
[08:25:49.508]                     }
[08:25:49.508]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.508]                   }
[08:25:49.508]                 }
[08:25:49.508]                 else {
[08:25:49.508]                   if (TRUE) {
[08:25:49.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.508]                     {
[08:25:49.508]                       inherits <- base::inherits
[08:25:49.508]                       invokeRestart <- base::invokeRestart
[08:25:49.508]                       is.null <- base::is.null
[08:25:49.508]                       muffled <- FALSE
[08:25:49.508]                       if (inherits(cond, "message")) {
[08:25:49.508]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.508]                         if (muffled) 
[08:25:49.508]                           invokeRestart("muffleMessage")
[08:25:49.508]                       }
[08:25:49.508]                       else if (inherits(cond, "warning")) {
[08:25:49.508]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.508]                         if (muffled) 
[08:25:49.508]                           invokeRestart("muffleWarning")
[08:25:49.508]                       }
[08:25:49.508]                       else if (inherits(cond, "condition")) {
[08:25:49.508]                         if (!is.null(pattern)) {
[08:25:49.508]                           computeRestarts <- base::computeRestarts
[08:25:49.508]                           grepl <- base::grepl
[08:25:49.508]                           restarts <- computeRestarts(cond)
[08:25:49.508]                           for (restart in restarts) {
[08:25:49.508]                             name <- restart$name
[08:25:49.508]                             if (is.null(name)) 
[08:25:49.508]                               next
[08:25:49.508]                             if (!grepl(pattern, name)) 
[08:25:49.508]                               next
[08:25:49.508]                             invokeRestart(restart)
[08:25:49.508]                             muffled <- TRUE
[08:25:49.508]                             break
[08:25:49.508]                           }
[08:25:49.508]                         }
[08:25:49.508]                       }
[08:25:49.508]                       invisible(muffled)
[08:25:49.508]                     }
[08:25:49.508]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.508]                   }
[08:25:49.508]                 }
[08:25:49.508]             }
[08:25:49.508]         }))
[08:25:49.508]     }, error = function(ex) {
[08:25:49.508]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.508]                 ...future.rng), started = ...future.startTime, 
[08:25:49.508]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.508]             version = "1.8"), class = "FutureResult")
[08:25:49.508]     }, finally = {
[08:25:49.508]         if (!identical(...future.workdir, getwd())) 
[08:25:49.508]             setwd(...future.workdir)
[08:25:49.508]         {
[08:25:49.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.508]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.508]             }
[08:25:49.508]             base::options(...future.oldOptions)
[08:25:49.508]             if (.Platform$OS.type == "windows") {
[08:25:49.508]                 old_names <- names(...future.oldEnvVars)
[08:25:49.508]                 envs <- base::Sys.getenv()
[08:25:49.508]                 names <- names(envs)
[08:25:49.508]                 common <- intersect(names, old_names)
[08:25:49.508]                 added <- setdiff(names, old_names)
[08:25:49.508]                 removed <- setdiff(old_names, names)
[08:25:49.508]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.508]                   envs[common]]
[08:25:49.508]                 NAMES <- toupper(changed)
[08:25:49.508]                 args <- list()
[08:25:49.508]                 for (kk in seq_along(NAMES)) {
[08:25:49.508]                   name <- changed[[kk]]
[08:25:49.508]                   NAME <- NAMES[[kk]]
[08:25:49.508]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.508]                     next
[08:25:49.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.508]                 }
[08:25:49.508]                 NAMES <- toupper(added)
[08:25:49.508]                 for (kk in seq_along(NAMES)) {
[08:25:49.508]                   name <- added[[kk]]
[08:25:49.508]                   NAME <- NAMES[[kk]]
[08:25:49.508]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.508]                     next
[08:25:49.508]                   args[[name]] <- ""
[08:25:49.508]                 }
[08:25:49.508]                 NAMES <- toupper(removed)
[08:25:49.508]                 for (kk in seq_along(NAMES)) {
[08:25:49.508]                   name <- removed[[kk]]
[08:25:49.508]                   NAME <- NAMES[[kk]]
[08:25:49.508]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.508]                     next
[08:25:49.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.508]                 }
[08:25:49.508]                 if (length(args) > 0) 
[08:25:49.508]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.508]             }
[08:25:49.508]             else {
[08:25:49.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.508]             }
[08:25:49.508]             {
[08:25:49.508]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.508]                   0L) {
[08:25:49.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.508]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.508]                   base::options(opts)
[08:25:49.508]                 }
[08:25:49.508]                 {
[08:25:49.508]                   {
[08:25:49.508]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.508]                     NULL
[08:25:49.508]                   }
[08:25:49.508]                   options(future.plan = NULL)
[08:25:49.508]                   if (is.na(NA_character_)) 
[08:25:49.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.508]                     .init = FALSE)
[08:25:49.508]                 }
[08:25:49.508]             }
[08:25:49.508]         }
[08:25:49.508]     })
[08:25:49.508]     if (TRUE) {
[08:25:49.508]         base::sink(type = "output", split = FALSE)
[08:25:49.508]         if (TRUE) {
[08:25:49.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.508]         }
[08:25:49.508]         else {
[08:25:49.508]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.508]         }
[08:25:49.508]         base::close(...future.stdout)
[08:25:49.508]         ...future.stdout <- NULL
[08:25:49.508]     }
[08:25:49.508]     ...future.result$conditions <- ...future.conditions
[08:25:49.508]     ...future.result$finished <- base::Sys.time()
[08:25:49.508]     ...future.result
[08:25:49.508] }
[08:25:49.510] assign_globals() ...
[08:25:49.511] List of 5
[08:25:49.511]  $ ...future.FUN            :function (C, k)  
[08:25:49.511]  $ MoreArgs                 : NULL
[08:25:49.511]  $ ...future.elements_ii    :List of 2
[08:25:49.511]   ..$ :List of 2
[08:25:49.511]   .. ..$ : chr "E"
[08:25:49.511]   .. ..$ : chr "D"
[08:25:49.511]   ..$ :List of 2
[08:25:49.511]   .. ..$ : int 1
[08:25:49.511]   .. ..$ : int 2
[08:25:49.511]  $ ...future.seeds_ii       : NULL
[08:25:49.511]  $ ...future.globals.maxSize: NULL
[08:25:49.511]  - attr(*, "where")=List of 5
[08:25:49.511]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.511]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.511]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.511]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.511]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.511]  - attr(*, "resolved")= logi FALSE
[08:25:49.511]  - attr(*, "total_size")= num 876
[08:25:49.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.511]  - attr(*, "already-done")= logi TRUE
[08:25:49.516] - reassign environment for ‘...future.FUN’
[08:25:49.516] - copied ‘...future.FUN’ to environment
[08:25:49.516] - copied ‘MoreArgs’ to environment
[08:25:49.517] - copied ‘...future.elements_ii’ to environment
[08:25:49.517] - copied ‘...future.seeds_ii’ to environment
[08:25:49.517] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.517] assign_globals() ... done
[08:25:49.517] requestCore(): workers = 2
[08:25:49.519] MulticoreFuture started
[08:25:49.520] - Launch lazy future ... done
[08:25:49.520] run() for ‘MulticoreFuture’ ... done
[08:25:49.520] Created future:
[08:25:49.520] plan(): Setting new future strategy stack:
[08:25:49.521] List of future strategies:
[08:25:49.521] 1. sequential:
[08:25:49.521]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.521]    - tweaked: FALSE
[08:25:49.521]    - call: NULL
[08:25:49.521] plan(): nbrOfWorkers() = 1
[08:25:49.524] plan(): Setting new future strategy stack:
[08:25:49.524] List of future strategies:
[08:25:49.524] 1. multicore:
[08:25:49.524]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.524]    - tweaked: FALSE
[08:25:49.524]    - call: plan(strategy)
[08:25:49.520] MulticoreFuture:
[08:25:49.520] Label: ‘future_mapply-1’
[08:25:49.520] Expression:
[08:25:49.520] {
[08:25:49.520]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.520]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.520]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.520]         on.exit(options(oopts), add = TRUE)
[08:25:49.520]     }
[08:25:49.520]     {
[08:25:49.520]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.520]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.520]         do.call(mapply, args = args)
[08:25:49.520]     }
[08:25:49.520] }
[08:25:49.520] Lazy evaluation: FALSE
[08:25:49.520] Asynchronous evaluation: TRUE
[08:25:49.520] Local evaluation: TRUE
[08:25:49.520] Environment: R_GlobalEnv
[08:25:49.520] Capture standard output: TRUE
[08:25:49.520] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.520] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.520] Packages: <none>
[08:25:49.520] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.520] Resolved: FALSE
[08:25:49.520] Value: <not collected>
[08:25:49.520] Conditions captured: <none>
[08:25:49.520] Early signaling: FALSE
[08:25:49.520] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.520] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.533] plan(): nbrOfWorkers() = 2
[08:25:49.533] Chunk #1 of 2 ... DONE
[08:25:49.533] Chunk #2 of 2 ...
[08:25:49.533]  - Finding globals in '...' for chunk #2 ...
[08:25:49.533] getGlobalsAndPackages() ...
[08:25:49.534] Searching for globals...
[08:25:49.534] 
[08:25:49.534] Searching for globals ... DONE
[08:25:49.534] - globals: [0] <none>
[08:25:49.537] getGlobalsAndPackages() ... DONE
[08:25:49.537]    + additional globals found: [n=0] 
[08:25:49.538]    + additional namespaces needed: [n=0] 
[08:25:49.538]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:49.538]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.538]  - seeds: <none>
[08:25:49.539]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.539] getGlobalsAndPackages() ...
[08:25:49.539] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.540] Resolving globals: FALSE
[08:25:49.541] The total size of the 5 globals is 905 bytes (905 bytes)
[08:25:49.542] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 905 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:49.543] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.543] 
[08:25:49.543] getGlobalsAndPackages() ... DONE
[08:25:49.544] run() for ‘Future’ ...
[08:25:49.544] - state: ‘created’
[08:25:49.544] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.548] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.548] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.548]   - Field: ‘label’
[08:25:49.548]   - Field: ‘local’
[08:25:49.549]   - Field: ‘owner’
[08:25:49.549]   - Field: ‘envir’
[08:25:49.549]   - Field: ‘workers’
[08:25:49.549]   - Field: ‘packages’
[08:25:49.550]   - Field: ‘gc’
[08:25:49.550]   - Field: ‘job’
[08:25:49.550]   - Field: ‘conditions’
[08:25:49.550]   - Field: ‘expr’
[08:25:49.550]   - Field: ‘uuid’
[08:25:49.551]   - Field: ‘seed’
[08:25:49.551]   - Field: ‘version’
[08:25:49.551]   - Field: ‘result’
[08:25:49.551]   - Field: ‘asynchronous’
[08:25:49.551]   - Field: ‘calls’
[08:25:49.551]   - Field: ‘globals’
[08:25:49.551]   - Field: ‘stdout’
[08:25:49.552]   - Field: ‘earlySignal’
[08:25:49.552]   - Field: ‘lazy’
[08:25:49.552]   - Field: ‘state’
[08:25:49.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.552] - Launch lazy future ...
[08:25:49.553] Packages needed by the future expression (n = 0): <none>
[08:25:49.553] Packages needed by future strategies (n = 0): <none>
[08:25:49.554] {
[08:25:49.554]     {
[08:25:49.554]         {
[08:25:49.554]             ...future.startTime <- base::Sys.time()
[08:25:49.554]             {
[08:25:49.554]                 {
[08:25:49.554]                   {
[08:25:49.554]                     {
[08:25:49.554]                       base::local({
[08:25:49.554]                         has_future <- base::requireNamespace("future", 
[08:25:49.554]                           quietly = TRUE)
[08:25:49.554]                         if (has_future) {
[08:25:49.554]                           ns <- base::getNamespace("future")
[08:25:49.554]                           version <- ns[[".package"]][["version"]]
[08:25:49.554]                           if (is.null(version)) 
[08:25:49.554]                             version <- utils::packageVersion("future")
[08:25:49.554]                         }
[08:25:49.554]                         else {
[08:25:49.554]                           version <- NULL
[08:25:49.554]                         }
[08:25:49.554]                         if (!has_future || version < "1.8.0") {
[08:25:49.554]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.554]                             "", base::R.version$version.string), 
[08:25:49.554]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.554]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.554]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.554]                               "release", "version")], collapse = " "), 
[08:25:49.554]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.554]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.554]                             info)
[08:25:49.554]                           info <- base::paste(info, collapse = "; ")
[08:25:49.554]                           if (!has_future) {
[08:25:49.554]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.554]                               info)
[08:25:49.554]                           }
[08:25:49.554]                           else {
[08:25:49.554]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.554]                               info, version)
[08:25:49.554]                           }
[08:25:49.554]                           base::stop(msg)
[08:25:49.554]                         }
[08:25:49.554]                       })
[08:25:49.554]                     }
[08:25:49.554]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.554]                     base::options(mc.cores = 1L)
[08:25:49.554]                   }
[08:25:49.554]                   ...future.strategy.old <- future::plan("list")
[08:25:49.554]                   options(future.plan = NULL)
[08:25:49.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.554]                 }
[08:25:49.554]                 ...future.workdir <- getwd()
[08:25:49.554]             }
[08:25:49.554]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.554]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.554]         }
[08:25:49.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.554]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.554]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.554]             base::names(...future.oldOptions))
[08:25:49.554]     }
[08:25:49.554]     if (FALSE) {
[08:25:49.554]     }
[08:25:49.554]     else {
[08:25:49.554]         if (TRUE) {
[08:25:49.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.554]                 open = "w")
[08:25:49.554]         }
[08:25:49.554]         else {
[08:25:49.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.554]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.554]         }
[08:25:49.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.554]             base::sink(type = "output", split = FALSE)
[08:25:49.554]             base::close(...future.stdout)
[08:25:49.554]         }, add = TRUE)
[08:25:49.554]     }
[08:25:49.554]     ...future.frame <- base::sys.nframe()
[08:25:49.554]     ...future.conditions <- base::list()
[08:25:49.554]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.554]     if (FALSE) {
[08:25:49.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.554]     }
[08:25:49.554]     ...future.result <- base::tryCatch({
[08:25:49.554]         base::withCallingHandlers({
[08:25:49.554]             ...future.value <- base::withVisible(base::local({
[08:25:49.554]                 withCallingHandlers({
[08:25:49.554]                   {
[08:25:49.554]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.554]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.554]                       ...future.globals.maxSize)) {
[08:25:49.554]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.554]                       on.exit(options(oopts), add = TRUE)
[08:25:49.554]                     }
[08:25:49.554]                     {
[08:25:49.554]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.554]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.554]                         USE.NAMES = FALSE)
[08:25:49.554]                       do.call(mapply, args = args)
[08:25:49.554]                     }
[08:25:49.554]                   }
[08:25:49.554]                 }, immediateCondition = function(cond) {
[08:25:49.554]                   save_rds <- function (object, pathname, ...) 
[08:25:49.554]                   {
[08:25:49.554]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.554]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.554]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.554]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.554]                         fi_tmp[["mtime"]])
[08:25:49.554]                     }
[08:25:49.554]                     tryCatch({
[08:25:49.554]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.554]                     }, error = function(ex) {
[08:25:49.554]                       msg <- conditionMessage(ex)
[08:25:49.554]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.554]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.554]                         fi_tmp[["mtime"]], msg)
[08:25:49.554]                       ex$message <- msg
[08:25:49.554]                       stop(ex)
[08:25:49.554]                     })
[08:25:49.554]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.554]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.554]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.554]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.554]                       fi <- file.info(pathname)
[08:25:49.554]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.554]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.554]                         fi[["size"]], fi[["mtime"]])
[08:25:49.554]                       stop(msg)
[08:25:49.554]                     }
[08:25:49.554]                     invisible(pathname)
[08:25:49.554]                   }
[08:25:49.554]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.554]                     rootPath = tempdir()) 
[08:25:49.554]                   {
[08:25:49.554]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.554]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.554]                       tmpdir = path, fileext = ".rds")
[08:25:49.554]                     save_rds(obj, file)
[08:25:49.554]                   }
[08:25:49.554]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.554]                   {
[08:25:49.554]                     inherits <- base::inherits
[08:25:49.554]                     invokeRestart <- base::invokeRestart
[08:25:49.554]                     is.null <- base::is.null
[08:25:49.554]                     muffled <- FALSE
[08:25:49.554]                     if (inherits(cond, "message")) {
[08:25:49.554]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.554]                       if (muffled) 
[08:25:49.554]                         invokeRestart("muffleMessage")
[08:25:49.554]                     }
[08:25:49.554]                     else if (inherits(cond, "warning")) {
[08:25:49.554]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.554]                       if (muffled) 
[08:25:49.554]                         invokeRestart("muffleWarning")
[08:25:49.554]                     }
[08:25:49.554]                     else if (inherits(cond, "condition")) {
[08:25:49.554]                       if (!is.null(pattern)) {
[08:25:49.554]                         computeRestarts <- base::computeRestarts
[08:25:49.554]                         grepl <- base::grepl
[08:25:49.554]                         restarts <- computeRestarts(cond)
[08:25:49.554]                         for (restart in restarts) {
[08:25:49.554]                           name <- restart$name
[08:25:49.554]                           if (is.null(name)) 
[08:25:49.554]                             next
[08:25:49.554]                           if (!grepl(pattern, name)) 
[08:25:49.554]                             next
[08:25:49.554]                           invokeRestart(restart)
[08:25:49.554]                           muffled <- TRUE
[08:25:49.554]                           break
[08:25:49.554]                         }
[08:25:49.554]                       }
[08:25:49.554]                     }
[08:25:49.554]                     invisible(muffled)
[08:25:49.554]                   }
[08:25:49.554]                   muffleCondition(cond)
[08:25:49.554]                 })
[08:25:49.554]             }))
[08:25:49.554]             future::FutureResult(value = ...future.value$value, 
[08:25:49.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.554]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.554]                     ...future.globalenv.names))
[08:25:49.554]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.554]         }, condition = base::local({
[08:25:49.554]             c <- base::c
[08:25:49.554]             inherits <- base::inherits
[08:25:49.554]             invokeRestart <- base::invokeRestart
[08:25:49.554]             length <- base::length
[08:25:49.554]             list <- base::list
[08:25:49.554]             seq.int <- base::seq.int
[08:25:49.554]             signalCondition <- base::signalCondition
[08:25:49.554]             sys.calls <- base::sys.calls
[08:25:49.554]             `[[` <- base::`[[`
[08:25:49.554]             `+` <- base::`+`
[08:25:49.554]             `<<-` <- base::`<<-`
[08:25:49.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.554]                   3L)]
[08:25:49.554]             }
[08:25:49.554]             function(cond) {
[08:25:49.554]                 is_error <- inherits(cond, "error")
[08:25:49.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.554]                   NULL)
[08:25:49.554]                 if (is_error) {
[08:25:49.554]                   sessionInformation <- function() {
[08:25:49.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.554]                       search = base::search(), system = base::Sys.info())
[08:25:49.554]                   }
[08:25:49.554]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.554]                     cond$call), session = sessionInformation(), 
[08:25:49.554]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.554]                   signalCondition(cond)
[08:25:49.554]                 }
[08:25:49.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.554]                 "immediateCondition"))) {
[08:25:49.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.554]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.554]                   if (TRUE && !signal) {
[08:25:49.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.554]                     {
[08:25:49.554]                       inherits <- base::inherits
[08:25:49.554]                       invokeRestart <- base::invokeRestart
[08:25:49.554]                       is.null <- base::is.null
[08:25:49.554]                       muffled <- FALSE
[08:25:49.554]                       if (inherits(cond, "message")) {
[08:25:49.554]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.554]                         if (muffled) 
[08:25:49.554]                           invokeRestart("muffleMessage")
[08:25:49.554]                       }
[08:25:49.554]                       else if (inherits(cond, "warning")) {
[08:25:49.554]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.554]                         if (muffled) 
[08:25:49.554]                           invokeRestart("muffleWarning")
[08:25:49.554]                       }
[08:25:49.554]                       else if (inherits(cond, "condition")) {
[08:25:49.554]                         if (!is.null(pattern)) {
[08:25:49.554]                           computeRestarts <- base::computeRestarts
[08:25:49.554]                           grepl <- base::grepl
[08:25:49.554]                           restarts <- computeRestarts(cond)
[08:25:49.554]                           for (restart in restarts) {
[08:25:49.554]                             name <- restart$name
[08:25:49.554]                             if (is.null(name)) 
[08:25:49.554]                               next
[08:25:49.554]                             if (!grepl(pattern, name)) 
[08:25:49.554]                               next
[08:25:49.554]                             invokeRestart(restart)
[08:25:49.554]                             muffled <- TRUE
[08:25:49.554]                             break
[08:25:49.554]                           }
[08:25:49.554]                         }
[08:25:49.554]                       }
[08:25:49.554]                       invisible(muffled)
[08:25:49.554]                     }
[08:25:49.554]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.554]                   }
[08:25:49.554]                 }
[08:25:49.554]                 else {
[08:25:49.554]                   if (TRUE) {
[08:25:49.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.554]                     {
[08:25:49.554]                       inherits <- base::inherits
[08:25:49.554]                       invokeRestart <- base::invokeRestart
[08:25:49.554]                       is.null <- base::is.null
[08:25:49.554]                       muffled <- FALSE
[08:25:49.554]                       if (inherits(cond, "message")) {
[08:25:49.554]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.554]                         if (muffled) 
[08:25:49.554]                           invokeRestart("muffleMessage")
[08:25:49.554]                       }
[08:25:49.554]                       else if (inherits(cond, "warning")) {
[08:25:49.554]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.554]                         if (muffled) 
[08:25:49.554]                           invokeRestart("muffleWarning")
[08:25:49.554]                       }
[08:25:49.554]                       else if (inherits(cond, "condition")) {
[08:25:49.554]                         if (!is.null(pattern)) {
[08:25:49.554]                           computeRestarts <- base::computeRestarts
[08:25:49.554]                           grepl <- base::grepl
[08:25:49.554]                           restarts <- computeRestarts(cond)
[08:25:49.554]                           for (restart in restarts) {
[08:25:49.554]                             name <- restart$name
[08:25:49.554]                             if (is.null(name)) 
[08:25:49.554]                               next
[08:25:49.554]                             if (!grepl(pattern, name)) 
[08:25:49.554]                               next
[08:25:49.554]                             invokeRestart(restart)
[08:25:49.554]                             muffled <- TRUE
[08:25:49.554]                             break
[08:25:49.554]                           }
[08:25:49.554]                         }
[08:25:49.554]                       }
[08:25:49.554]                       invisible(muffled)
[08:25:49.554]                     }
[08:25:49.554]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.554]                   }
[08:25:49.554]                 }
[08:25:49.554]             }
[08:25:49.554]         }))
[08:25:49.554]     }, error = function(ex) {
[08:25:49.554]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.554]                 ...future.rng), started = ...future.startTime, 
[08:25:49.554]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.554]             version = "1.8"), class = "FutureResult")
[08:25:49.554]     }, finally = {
[08:25:49.554]         if (!identical(...future.workdir, getwd())) 
[08:25:49.554]             setwd(...future.workdir)
[08:25:49.554]         {
[08:25:49.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.554]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.554]             }
[08:25:49.554]             base::options(...future.oldOptions)
[08:25:49.554]             if (.Platform$OS.type == "windows") {
[08:25:49.554]                 old_names <- names(...future.oldEnvVars)
[08:25:49.554]                 envs <- base::Sys.getenv()
[08:25:49.554]                 names <- names(envs)
[08:25:49.554]                 common <- intersect(names, old_names)
[08:25:49.554]                 added <- setdiff(names, old_names)
[08:25:49.554]                 removed <- setdiff(old_names, names)
[08:25:49.554]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.554]                   envs[common]]
[08:25:49.554]                 NAMES <- toupper(changed)
[08:25:49.554]                 args <- list()
[08:25:49.554]                 for (kk in seq_along(NAMES)) {
[08:25:49.554]                   name <- changed[[kk]]
[08:25:49.554]                   NAME <- NAMES[[kk]]
[08:25:49.554]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.554]                     next
[08:25:49.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.554]                 }
[08:25:49.554]                 NAMES <- toupper(added)
[08:25:49.554]                 for (kk in seq_along(NAMES)) {
[08:25:49.554]                   name <- added[[kk]]
[08:25:49.554]                   NAME <- NAMES[[kk]]
[08:25:49.554]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.554]                     next
[08:25:49.554]                   args[[name]] <- ""
[08:25:49.554]                 }
[08:25:49.554]                 NAMES <- toupper(removed)
[08:25:49.554]                 for (kk in seq_along(NAMES)) {
[08:25:49.554]                   name <- removed[[kk]]
[08:25:49.554]                   NAME <- NAMES[[kk]]
[08:25:49.554]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.554]                     next
[08:25:49.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.554]                 }
[08:25:49.554]                 if (length(args) > 0) 
[08:25:49.554]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.554]             }
[08:25:49.554]             else {
[08:25:49.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.554]             }
[08:25:49.554]             {
[08:25:49.554]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.554]                   0L) {
[08:25:49.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.554]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.554]                   base::options(opts)
[08:25:49.554]                 }
[08:25:49.554]                 {
[08:25:49.554]                   {
[08:25:49.554]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.554]                     NULL
[08:25:49.554]                   }
[08:25:49.554]                   options(future.plan = NULL)
[08:25:49.554]                   if (is.na(NA_character_)) 
[08:25:49.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.554]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.554]                     .init = FALSE)
[08:25:49.554]                 }
[08:25:49.554]             }
[08:25:49.554]         }
[08:25:49.554]     })
[08:25:49.554]     if (TRUE) {
[08:25:49.554]         base::sink(type = "output", split = FALSE)
[08:25:49.554]         if (TRUE) {
[08:25:49.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.554]         }
[08:25:49.554]         else {
[08:25:49.554]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.554]         }
[08:25:49.554]         base::close(...future.stdout)
[08:25:49.554]         ...future.stdout <- NULL
[08:25:49.554]     }
[08:25:49.554]     ...future.result$conditions <- ...future.conditions
[08:25:49.554]     ...future.result$finished <- base::Sys.time()
[08:25:49.554]     ...future.result
[08:25:49.554] }
[08:25:49.556] assign_globals() ...
[08:25:49.557] List of 5
[08:25:49.557]  $ ...future.FUN            :function (C, k)  
[08:25:49.557]  $ MoreArgs                 : NULL
[08:25:49.557]  $ ...future.elements_ii    :List of 2
[08:25:49.557]   ..$ :List of 3
[08:25:49.557]   .. ..$ : chr "C"
[08:25:49.557]   .. ..$ : chr "B"
[08:25:49.557]   .. ..$ : chr "A"
[08:25:49.557]   ..$ :List of 3
[08:25:49.557]   .. ..$ : int 3
[08:25:49.557]   .. ..$ : int 4
[08:25:49.557]   .. ..$ : int 5
[08:25:49.557]  $ ...future.seeds_ii       : NULL
[08:25:49.557]  $ ...future.globals.maxSize: NULL
[08:25:49.557]  - attr(*, "where")=List of 5
[08:25:49.557]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.557]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.557]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.557]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.557]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.557]  - attr(*, "resolved")= logi FALSE
[08:25:49.557]  - attr(*, "total_size")= num 905
[08:25:49.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.557]  - attr(*, "already-done")= logi TRUE
[08:25:49.564] - reassign environment for ‘...future.FUN’
[08:25:49.565] - copied ‘...future.FUN’ to environment
[08:25:49.565] - copied ‘MoreArgs’ to environment
[08:25:49.565] - copied ‘...future.elements_ii’ to environment
[08:25:49.565] - copied ‘...future.seeds_ii’ to environment
[08:25:49.565] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.565] assign_globals() ... done
[08:25:49.565] requestCore(): workers = 2
[08:25:49.568] MulticoreFuture started
[08:25:49.568] - Launch lazy future ... done
[08:25:49.568] run() for ‘MulticoreFuture’ ... done
[08:25:49.569] Created future:
[08:25:49.569] plan(): Setting new future strategy stack:
[08:25:49.569] List of future strategies:
[08:25:49.569] 1. sequential:
[08:25:49.569]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.569]    - tweaked: FALSE
[08:25:49.569]    - call: NULL
[08:25:49.570] plan(): nbrOfWorkers() = 1
[08:25:49.573] plan(): Setting new future strategy stack:
[08:25:49.573] List of future strategies:
[08:25:49.573] 1. multicore:
[08:25:49.573]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.573]    - tweaked: FALSE
[08:25:49.573]    - call: plan(strategy)
[08:25:49.576] plan(): nbrOfWorkers() = 2
[08:25:49.569] MulticoreFuture:
[08:25:49.569] Label: ‘future_mapply-2’
[08:25:49.569] Expression:
[08:25:49.569] {
[08:25:49.569]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.569]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.569]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.569]         on.exit(options(oopts), add = TRUE)
[08:25:49.569]     }
[08:25:49.569]     {
[08:25:49.569]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.569]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.569]         do.call(mapply, args = args)
[08:25:49.569]     }
[08:25:49.569] }
[08:25:49.569] Lazy evaluation: FALSE
[08:25:49.569] Asynchronous evaluation: TRUE
[08:25:49.569] Local evaluation: TRUE
[08:25:49.569] Environment: R_GlobalEnv
[08:25:49.569] Capture standard output: TRUE
[08:25:49.569] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.569] Globals: 5 objects totaling 905 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.569] Packages: <none>
[08:25:49.569] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.569] Resolved: TRUE
[08:25:49.569] Value: <not collected>
[08:25:49.569] Conditions captured: <none>
[08:25:49.569] Early signaling: FALSE
[08:25:49.569] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.569] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.577] Chunk #2 of 2 ... DONE
[08:25:49.577] Launching 2 futures (chunks) ... DONE
[08:25:49.577] Resolving 2 futures (chunks) ...
[08:25:49.578] resolve() on list ...
[08:25:49.578]  recursive: 0
[08:25:49.578]  length: 2
[08:25:49.578] 
[08:25:49.578] Future #1
[08:25:49.579] result() for MulticoreFuture ...
[08:25:49.579] result() for MulticoreFuture ...
[08:25:49.580] result() for MulticoreFuture ... done
[08:25:49.580] result() for MulticoreFuture ... done
[08:25:49.580] result() for MulticoreFuture ...
[08:25:49.580] result() for MulticoreFuture ... done
[08:25:49.580] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:49.584] - nx: 2
[08:25:49.584] - relay: TRUE
[08:25:49.585] - stdout: TRUE
[08:25:49.585] - signal: TRUE
[08:25:49.586] - resignal: FALSE
[08:25:49.586] - force: TRUE
[08:25:49.586] - relayed: [n=2] FALSE, FALSE
[08:25:49.586] - queued futures: [n=2] FALSE, FALSE
[08:25:49.587]  - until=1
[08:25:49.587]  - relaying element #1
[08:25:49.587] result() for MulticoreFuture ...
[08:25:49.588] result() for MulticoreFuture ... done
[08:25:49.588] result() for MulticoreFuture ...
[08:25:49.588] result() for MulticoreFuture ... done
[08:25:49.589] result() for MulticoreFuture ...
[08:25:49.589] result() for MulticoreFuture ... done
[08:25:49.589] result() for MulticoreFuture ...
[08:25:49.589] result() for MulticoreFuture ... done
[08:25:49.589] - relayed: [n=2] TRUE, FALSE
[08:25:49.590] - queued futures: [n=2] TRUE, FALSE
[08:25:49.590] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:49.590]  length: 1 (resolved future 1)
[08:25:49.591] Future #2
[08:25:49.591] result() for MulticoreFuture ...
[08:25:49.592] result() for MulticoreFuture ...
[08:25:49.592] result() for MulticoreFuture ... done
[08:25:49.592] result() for MulticoreFuture ... done
[08:25:49.593] result() for MulticoreFuture ...
[08:25:49.593] result() for MulticoreFuture ... done
[08:25:49.593] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:49.593] - nx: 2
[08:25:49.593] - relay: TRUE
[08:25:49.593] - stdout: TRUE
[08:25:49.594] - signal: TRUE
[08:25:49.594] - resignal: FALSE
[08:25:49.594] - force: TRUE
[08:25:49.594] - relayed: [n=2] TRUE, FALSE
[08:25:49.594] - queued futures: [n=2] TRUE, FALSE
[08:25:49.595]  - until=2
[08:25:49.595]  - relaying element #2
[08:25:49.595] result() for MulticoreFuture ...
[08:25:49.595] result() for MulticoreFuture ... done
[08:25:49.595] result() for MulticoreFuture ...
[08:25:49.595] result() for MulticoreFuture ... done
[08:25:49.596] result() for MulticoreFuture ...
[08:25:49.596] result() for MulticoreFuture ... done
[08:25:49.596] result() for MulticoreFuture ...
[08:25:49.596] result() for MulticoreFuture ... done
[08:25:49.596] - relayed: [n=2] TRUE, TRUE
[08:25:49.596] - queued futures: [n=2] TRUE, TRUE
[08:25:49.596] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:49.596]  length: 0 (resolved future 2)
[08:25:49.597] Relaying remaining futures
[08:25:49.597] signalConditionsASAP(NULL, pos=0) ...
[08:25:49.597] - nx: 2
[08:25:49.597] - relay: TRUE
[08:25:49.597] - stdout: TRUE
[08:25:49.597] - signal: TRUE
[08:25:49.597] - resignal: FALSE
[08:25:49.597] - force: TRUE
[08:25:49.597] - relayed: [n=2] TRUE, TRUE
[08:25:49.598] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:49.598] - relayed: [n=2] TRUE, TRUE
[08:25:49.598] - queued futures: [n=2] TRUE, TRUE
[08:25:49.598] signalConditionsASAP(NULL, pos=0) ... done
[08:25:49.598] resolve() on list ... DONE
[08:25:49.598] result() for MulticoreFuture ...
[08:25:49.598] result() for MulticoreFuture ... done
[08:25:49.598] result() for MulticoreFuture ...
[08:25:49.598] result() for MulticoreFuture ... done
[08:25:49.599] result() for MulticoreFuture ...
[08:25:49.599] result() for MulticoreFuture ... done
[08:25:49.599] result() for MulticoreFuture ...
[08:25:49.599] result() for MulticoreFuture ... done
[08:25:49.599]  - Number of value chunks collected: 2
[08:25:49.599] Resolving 2 futures (chunks) ... DONE
[08:25:49.599] Reducing values from 2 chunks ...
[08:25:49.599]  - Number of values collected after concatenation: 5
[08:25:49.600]  - Number of values expected: 5
[08:25:49.600] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[08:25:49.600] Reducing values from 2 chunks ... DONE
[08:25:49.600] future_mapply() ... DONE
[08:25:49.600] future_mapply() ...
[08:25:49.602] Number of chunks: 2
[08:25:49.603] getGlobalsAndPackagesXApply() ...
[08:25:49.603]  - future.globals: TRUE
[08:25:49.603] getGlobalsAndPackages() ...
[08:25:49.603] Searching for globals...
[08:25:49.604] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:49.605] Searching for globals ... DONE
[08:25:49.605] Resolving globals: FALSE
[08:25:49.605] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:49.605] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:49.606] - globals: [1] ‘FUN’
[08:25:49.606] 
[08:25:49.606] getGlobalsAndPackages() ... DONE
[08:25:49.606]  - globals found/used: [n=1] ‘FUN’
[08:25:49.606]  - needed namespaces: [n=0] 
[08:25:49.606] Finding globals ... DONE
[08:25:49.606] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:49.606] List of 2
[08:25:49.606]  $ ...future.FUN:function (C, k)  
[08:25:49.606]  $ MoreArgs     : list()
[08:25:49.606]  - attr(*, "where")=List of 2
[08:25:49.606]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:49.606]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:49.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.606]  - attr(*, "resolved")= logi FALSE
[08:25:49.606]  - attr(*, "total_size")= num NA
[08:25:49.609] Packages to be attached in all futures: [n=0] 
[08:25:49.609] getGlobalsAndPackagesXApply() ... DONE
[08:25:49.610] Number of futures (= number of chunks): 2
[08:25:49.610] Launching 2 futures (chunks) ...
[08:25:49.610] Chunk #1 of 2 ...
[08:25:49.610]  - Finding globals in '...' for chunk #1 ...
[08:25:49.610] getGlobalsAndPackages() ...
[08:25:49.610] Searching for globals...
[08:25:49.611] 
[08:25:49.611] Searching for globals ... DONE
[08:25:49.611] - globals: [0] <none>
[08:25:49.611] getGlobalsAndPackages() ... DONE
[08:25:49.611]    + additional globals found: [n=0] 
[08:25:49.611]    + additional namespaces needed: [n=0] 
[08:25:49.611]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:49.613]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.614]  - seeds: <none>
[08:25:49.614]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.614] getGlobalsAndPackages() ...
[08:25:49.614] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.614] Resolving globals: FALSE
[08:25:49.615] The total size of the 5 globals is 880 bytes (880 bytes)
[08:25:49.615] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:49.616] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.616] 
[08:25:49.616] getGlobalsAndPackages() ... DONE
[08:25:49.616] run() for ‘Future’ ...
[08:25:49.616] - state: ‘created’
[08:25:49.616] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.619] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.619] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.619]   - Field: ‘label’
[08:25:49.619]   - Field: ‘local’
[08:25:49.619]   - Field: ‘owner’
[08:25:49.619]   - Field: ‘envir’
[08:25:49.619]   - Field: ‘workers’
[08:25:49.619]   - Field: ‘packages’
[08:25:49.620]   - Field: ‘gc’
[08:25:49.620]   - Field: ‘job’
[08:25:49.620]   - Field: ‘conditions’
[08:25:49.620]   - Field: ‘expr’
[08:25:49.620]   - Field: ‘uuid’
[08:25:49.620]   - Field: ‘seed’
[08:25:49.620]   - Field: ‘version’
[08:25:49.620]   - Field: ‘result’
[08:25:49.620]   - Field: ‘asynchronous’
[08:25:49.621]   - Field: ‘calls’
[08:25:49.621]   - Field: ‘globals’
[08:25:49.621]   - Field: ‘stdout’
[08:25:49.621]   - Field: ‘earlySignal’
[08:25:49.621]   - Field: ‘lazy’
[08:25:49.621]   - Field: ‘state’
[08:25:49.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.621] - Launch lazy future ...
[08:25:49.622] Packages needed by the future expression (n = 0): <none>
[08:25:49.622] Packages needed by future strategies (n = 0): <none>
[08:25:49.622] {
[08:25:49.622]     {
[08:25:49.622]         {
[08:25:49.622]             ...future.startTime <- base::Sys.time()
[08:25:49.622]             {
[08:25:49.622]                 {
[08:25:49.622]                   {
[08:25:49.622]                     {
[08:25:49.622]                       base::local({
[08:25:49.622]                         has_future <- base::requireNamespace("future", 
[08:25:49.622]                           quietly = TRUE)
[08:25:49.622]                         if (has_future) {
[08:25:49.622]                           ns <- base::getNamespace("future")
[08:25:49.622]                           version <- ns[[".package"]][["version"]]
[08:25:49.622]                           if (is.null(version)) 
[08:25:49.622]                             version <- utils::packageVersion("future")
[08:25:49.622]                         }
[08:25:49.622]                         else {
[08:25:49.622]                           version <- NULL
[08:25:49.622]                         }
[08:25:49.622]                         if (!has_future || version < "1.8.0") {
[08:25:49.622]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.622]                             "", base::R.version$version.string), 
[08:25:49.622]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.622]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.622]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.622]                               "release", "version")], collapse = " "), 
[08:25:49.622]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.622]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.622]                             info)
[08:25:49.622]                           info <- base::paste(info, collapse = "; ")
[08:25:49.622]                           if (!has_future) {
[08:25:49.622]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.622]                               info)
[08:25:49.622]                           }
[08:25:49.622]                           else {
[08:25:49.622]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.622]                               info, version)
[08:25:49.622]                           }
[08:25:49.622]                           base::stop(msg)
[08:25:49.622]                         }
[08:25:49.622]                       })
[08:25:49.622]                     }
[08:25:49.622]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.622]                     base::options(mc.cores = 1L)
[08:25:49.622]                   }
[08:25:49.622]                   ...future.strategy.old <- future::plan("list")
[08:25:49.622]                   options(future.plan = NULL)
[08:25:49.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.622]                 }
[08:25:49.622]                 ...future.workdir <- getwd()
[08:25:49.622]             }
[08:25:49.622]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.622]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.622]         }
[08:25:49.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.622]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.622]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.622]             base::names(...future.oldOptions))
[08:25:49.622]     }
[08:25:49.622]     if (FALSE) {
[08:25:49.622]     }
[08:25:49.622]     else {
[08:25:49.622]         if (TRUE) {
[08:25:49.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.622]                 open = "w")
[08:25:49.622]         }
[08:25:49.622]         else {
[08:25:49.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.622]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.622]         }
[08:25:49.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.622]             base::sink(type = "output", split = FALSE)
[08:25:49.622]             base::close(...future.stdout)
[08:25:49.622]         }, add = TRUE)
[08:25:49.622]     }
[08:25:49.622]     ...future.frame <- base::sys.nframe()
[08:25:49.622]     ...future.conditions <- base::list()
[08:25:49.622]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.622]     if (FALSE) {
[08:25:49.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.622]     }
[08:25:49.622]     ...future.result <- base::tryCatch({
[08:25:49.622]         base::withCallingHandlers({
[08:25:49.622]             ...future.value <- base::withVisible(base::local({
[08:25:49.622]                 withCallingHandlers({
[08:25:49.622]                   {
[08:25:49.622]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.622]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.622]                       ...future.globals.maxSize)) {
[08:25:49.622]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.622]                       on.exit(options(oopts), add = TRUE)
[08:25:49.622]                     }
[08:25:49.622]                     {
[08:25:49.622]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.622]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.622]                         USE.NAMES = FALSE)
[08:25:49.622]                       do.call(mapply, args = args)
[08:25:49.622]                     }
[08:25:49.622]                   }
[08:25:49.622]                 }, immediateCondition = function(cond) {
[08:25:49.622]                   save_rds <- function (object, pathname, ...) 
[08:25:49.622]                   {
[08:25:49.622]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.622]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.622]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.622]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.622]                         fi_tmp[["mtime"]])
[08:25:49.622]                     }
[08:25:49.622]                     tryCatch({
[08:25:49.622]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.622]                     }, error = function(ex) {
[08:25:49.622]                       msg <- conditionMessage(ex)
[08:25:49.622]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.622]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.622]                         fi_tmp[["mtime"]], msg)
[08:25:49.622]                       ex$message <- msg
[08:25:49.622]                       stop(ex)
[08:25:49.622]                     })
[08:25:49.622]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.622]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.622]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.622]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.622]                       fi <- file.info(pathname)
[08:25:49.622]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.622]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.622]                         fi[["size"]], fi[["mtime"]])
[08:25:49.622]                       stop(msg)
[08:25:49.622]                     }
[08:25:49.622]                     invisible(pathname)
[08:25:49.622]                   }
[08:25:49.622]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.622]                     rootPath = tempdir()) 
[08:25:49.622]                   {
[08:25:49.622]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.622]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.622]                       tmpdir = path, fileext = ".rds")
[08:25:49.622]                     save_rds(obj, file)
[08:25:49.622]                   }
[08:25:49.622]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.622]                   {
[08:25:49.622]                     inherits <- base::inherits
[08:25:49.622]                     invokeRestart <- base::invokeRestart
[08:25:49.622]                     is.null <- base::is.null
[08:25:49.622]                     muffled <- FALSE
[08:25:49.622]                     if (inherits(cond, "message")) {
[08:25:49.622]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.622]                       if (muffled) 
[08:25:49.622]                         invokeRestart("muffleMessage")
[08:25:49.622]                     }
[08:25:49.622]                     else if (inherits(cond, "warning")) {
[08:25:49.622]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.622]                       if (muffled) 
[08:25:49.622]                         invokeRestart("muffleWarning")
[08:25:49.622]                     }
[08:25:49.622]                     else if (inherits(cond, "condition")) {
[08:25:49.622]                       if (!is.null(pattern)) {
[08:25:49.622]                         computeRestarts <- base::computeRestarts
[08:25:49.622]                         grepl <- base::grepl
[08:25:49.622]                         restarts <- computeRestarts(cond)
[08:25:49.622]                         for (restart in restarts) {
[08:25:49.622]                           name <- restart$name
[08:25:49.622]                           if (is.null(name)) 
[08:25:49.622]                             next
[08:25:49.622]                           if (!grepl(pattern, name)) 
[08:25:49.622]                             next
[08:25:49.622]                           invokeRestart(restart)
[08:25:49.622]                           muffled <- TRUE
[08:25:49.622]                           break
[08:25:49.622]                         }
[08:25:49.622]                       }
[08:25:49.622]                     }
[08:25:49.622]                     invisible(muffled)
[08:25:49.622]                   }
[08:25:49.622]                   muffleCondition(cond)
[08:25:49.622]                 })
[08:25:49.622]             }))
[08:25:49.622]             future::FutureResult(value = ...future.value$value, 
[08:25:49.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.622]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.622]                     ...future.globalenv.names))
[08:25:49.622]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.622]         }, condition = base::local({
[08:25:49.622]             c <- base::c
[08:25:49.622]             inherits <- base::inherits
[08:25:49.622]             invokeRestart <- base::invokeRestart
[08:25:49.622]             length <- base::length
[08:25:49.622]             list <- base::list
[08:25:49.622]             seq.int <- base::seq.int
[08:25:49.622]             signalCondition <- base::signalCondition
[08:25:49.622]             sys.calls <- base::sys.calls
[08:25:49.622]             `[[` <- base::`[[`
[08:25:49.622]             `+` <- base::`+`
[08:25:49.622]             `<<-` <- base::`<<-`
[08:25:49.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.622]                   3L)]
[08:25:49.622]             }
[08:25:49.622]             function(cond) {
[08:25:49.622]                 is_error <- inherits(cond, "error")
[08:25:49.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.622]                   NULL)
[08:25:49.622]                 if (is_error) {
[08:25:49.622]                   sessionInformation <- function() {
[08:25:49.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.622]                       search = base::search(), system = base::Sys.info())
[08:25:49.622]                   }
[08:25:49.622]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.622]                     cond$call), session = sessionInformation(), 
[08:25:49.622]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.622]                   signalCondition(cond)
[08:25:49.622]                 }
[08:25:49.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.622]                 "immediateCondition"))) {
[08:25:49.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.622]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.622]                   if (TRUE && !signal) {
[08:25:49.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.622]                     {
[08:25:49.622]                       inherits <- base::inherits
[08:25:49.622]                       invokeRestart <- base::invokeRestart
[08:25:49.622]                       is.null <- base::is.null
[08:25:49.622]                       muffled <- FALSE
[08:25:49.622]                       if (inherits(cond, "message")) {
[08:25:49.622]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.622]                         if (muffled) 
[08:25:49.622]                           invokeRestart("muffleMessage")
[08:25:49.622]                       }
[08:25:49.622]                       else if (inherits(cond, "warning")) {
[08:25:49.622]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.622]                         if (muffled) 
[08:25:49.622]                           invokeRestart("muffleWarning")
[08:25:49.622]                       }
[08:25:49.622]                       else if (inherits(cond, "condition")) {
[08:25:49.622]                         if (!is.null(pattern)) {
[08:25:49.622]                           computeRestarts <- base::computeRestarts
[08:25:49.622]                           grepl <- base::grepl
[08:25:49.622]                           restarts <- computeRestarts(cond)
[08:25:49.622]                           for (restart in restarts) {
[08:25:49.622]                             name <- restart$name
[08:25:49.622]                             if (is.null(name)) 
[08:25:49.622]                               next
[08:25:49.622]                             if (!grepl(pattern, name)) 
[08:25:49.622]                               next
[08:25:49.622]                             invokeRestart(restart)
[08:25:49.622]                             muffled <- TRUE
[08:25:49.622]                             break
[08:25:49.622]                           }
[08:25:49.622]                         }
[08:25:49.622]                       }
[08:25:49.622]                       invisible(muffled)
[08:25:49.622]                     }
[08:25:49.622]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.622]                   }
[08:25:49.622]                 }
[08:25:49.622]                 else {
[08:25:49.622]                   if (TRUE) {
[08:25:49.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.622]                     {
[08:25:49.622]                       inherits <- base::inherits
[08:25:49.622]                       invokeRestart <- base::invokeRestart
[08:25:49.622]                       is.null <- base::is.null
[08:25:49.622]                       muffled <- FALSE
[08:25:49.622]                       if (inherits(cond, "message")) {
[08:25:49.622]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.622]                         if (muffled) 
[08:25:49.622]                           invokeRestart("muffleMessage")
[08:25:49.622]                       }
[08:25:49.622]                       else if (inherits(cond, "warning")) {
[08:25:49.622]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.622]                         if (muffled) 
[08:25:49.622]                           invokeRestart("muffleWarning")
[08:25:49.622]                       }
[08:25:49.622]                       else if (inherits(cond, "condition")) {
[08:25:49.622]                         if (!is.null(pattern)) {
[08:25:49.622]                           computeRestarts <- base::computeRestarts
[08:25:49.622]                           grepl <- base::grepl
[08:25:49.622]                           restarts <- computeRestarts(cond)
[08:25:49.622]                           for (restart in restarts) {
[08:25:49.622]                             name <- restart$name
[08:25:49.622]                             if (is.null(name)) 
[08:25:49.622]                               next
[08:25:49.622]                             if (!grepl(pattern, name)) 
[08:25:49.622]                               next
[08:25:49.622]                             invokeRestart(restart)
[08:25:49.622]                             muffled <- TRUE
[08:25:49.622]                             break
[08:25:49.622]                           }
[08:25:49.622]                         }
[08:25:49.622]                       }
[08:25:49.622]                       invisible(muffled)
[08:25:49.622]                     }
[08:25:49.622]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.622]                   }
[08:25:49.622]                 }
[08:25:49.622]             }
[08:25:49.622]         }))
[08:25:49.622]     }, error = function(ex) {
[08:25:49.622]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.622]                 ...future.rng), started = ...future.startTime, 
[08:25:49.622]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.622]             version = "1.8"), class = "FutureResult")
[08:25:49.622]     }, finally = {
[08:25:49.622]         if (!identical(...future.workdir, getwd())) 
[08:25:49.622]             setwd(...future.workdir)
[08:25:49.622]         {
[08:25:49.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.622]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.622]             }
[08:25:49.622]             base::options(...future.oldOptions)
[08:25:49.622]             if (.Platform$OS.type == "windows") {
[08:25:49.622]                 old_names <- names(...future.oldEnvVars)
[08:25:49.622]                 envs <- base::Sys.getenv()
[08:25:49.622]                 names <- names(envs)
[08:25:49.622]                 common <- intersect(names, old_names)
[08:25:49.622]                 added <- setdiff(names, old_names)
[08:25:49.622]                 removed <- setdiff(old_names, names)
[08:25:49.622]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.622]                   envs[common]]
[08:25:49.622]                 NAMES <- toupper(changed)
[08:25:49.622]                 args <- list()
[08:25:49.622]                 for (kk in seq_along(NAMES)) {
[08:25:49.622]                   name <- changed[[kk]]
[08:25:49.622]                   NAME <- NAMES[[kk]]
[08:25:49.622]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.622]                     next
[08:25:49.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.622]                 }
[08:25:49.622]                 NAMES <- toupper(added)
[08:25:49.622]                 for (kk in seq_along(NAMES)) {
[08:25:49.622]                   name <- added[[kk]]
[08:25:49.622]                   NAME <- NAMES[[kk]]
[08:25:49.622]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.622]                     next
[08:25:49.622]                   args[[name]] <- ""
[08:25:49.622]                 }
[08:25:49.622]                 NAMES <- toupper(removed)
[08:25:49.622]                 for (kk in seq_along(NAMES)) {
[08:25:49.622]                   name <- removed[[kk]]
[08:25:49.622]                   NAME <- NAMES[[kk]]
[08:25:49.622]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.622]                     next
[08:25:49.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.622]                 }
[08:25:49.622]                 if (length(args) > 0) 
[08:25:49.622]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.622]             }
[08:25:49.622]             else {
[08:25:49.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.622]             }
[08:25:49.622]             {
[08:25:49.622]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.622]                   0L) {
[08:25:49.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.622]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.622]                   base::options(opts)
[08:25:49.622]                 }
[08:25:49.622]                 {
[08:25:49.622]                   {
[08:25:49.622]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.622]                     NULL
[08:25:49.622]                   }
[08:25:49.622]                   options(future.plan = NULL)
[08:25:49.622]                   if (is.na(NA_character_)) 
[08:25:49.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.622]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.622]                     .init = FALSE)
[08:25:49.622]                 }
[08:25:49.622]             }
[08:25:49.622]         }
[08:25:49.622]     })
[08:25:49.622]     if (TRUE) {
[08:25:49.622]         base::sink(type = "output", split = FALSE)
[08:25:49.622]         if (TRUE) {
[08:25:49.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.622]         }
[08:25:49.622]         else {
[08:25:49.622]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.622]         }
[08:25:49.622]         base::close(...future.stdout)
[08:25:49.622]         ...future.stdout <- NULL
[08:25:49.622]     }
[08:25:49.622]     ...future.result$conditions <- ...future.conditions
[08:25:49.622]     ...future.result$finished <- base::Sys.time()
[08:25:49.622]     ...future.result
[08:25:49.622] }
[08:25:49.625] assign_globals() ...
[08:25:49.625] List of 5
[08:25:49.625]  $ ...future.FUN            :function (C, k)  
[08:25:49.625]  $ MoreArgs                 : list()
[08:25:49.625]  $ ...future.elements_ii    :List of 2
[08:25:49.625]   ..$ :List of 2
[08:25:49.625]   .. ..$ : chr "A"
[08:25:49.625]   .. ..$ : chr "B"
[08:25:49.625]   ..$ :List of 2
[08:25:49.625]   .. ..$ : int 5
[08:25:49.625]   .. ..$ : int 4
[08:25:49.625]  $ ...future.seeds_ii       : NULL
[08:25:49.625]  $ ...future.globals.maxSize: NULL
[08:25:49.625]  - attr(*, "where")=List of 5
[08:25:49.625]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.625]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.625]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.625]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.625]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.625]  - attr(*, "resolved")= logi FALSE
[08:25:49.625]  - attr(*, "total_size")= num 880
[08:25:49.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.625]  - attr(*, "already-done")= logi TRUE
[08:25:49.630] - reassign environment for ‘...future.FUN’
[08:25:49.630] - copied ‘...future.FUN’ to environment
[08:25:49.631] - copied ‘MoreArgs’ to environment
[08:25:49.631] - copied ‘...future.elements_ii’ to environment
[08:25:49.631] - copied ‘...future.seeds_ii’ to environment
[08:25:49.631] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.631] assign_globals() ... done
[08:25:49.631] requestCore(): workers = 2
[08:25:49.634] MulticoreFuture started
[08:25:49.634] - Launch lazy future ... done
[08:25:49.634] run() for ‘MulticoreFuture’ ... done
[08:25:49.634] Created future:
[08:25:49.635] plan(): Setting new future strategy stack:
[08:25:49.635] List of future strategies:
[08:25:49.635] 1. sequential:
[08:25:49.635]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.635]    - tweaked: FALSE
[08:25:49.635]    - call: NULL
[08:25:49.636] plan(): nbrOfWorkers() = 1
[08:25:49.638] plan(): Setting new future strategy stack:
[08:25:49.638] List of future strategies:
[08:25:49.638] 1. multicore:
[08:25:49.638]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.638]    - tweaked: FALSE
[08:25:49.638]    - call: plan(strategy)
[08:25:49.642] plan(): nbrOfWorkers() = 2
[08:25:49.635] MulticoreFuture:
[08:25:49.635] Label: ‘future_.mapply-1’
[08:25:49.635] Expression:
[08:25:49.635] {
[08:25:49.635]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.635]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.635]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.635]         on.exit(options(oopts), add = TRUE)
[08:25:49.635]     }
[08:25:49.635]     {
[08:25:49.635]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.635]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.635]         do.call(mapply, args = args)
[08:25:49.635]     }
[08:25:49.635] }
[08:25:49.635] Lazy evaluation: FALSE
[08:25:49.635] Asynchronous evaluation: TRUE
[08:25:49.635] Local evaluation: TRUE
[08:25:49.635] Environment: R_GlobalEnv
[08:25:49.635] Capture standard output: TRUE
[08:25:49.635] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.635] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.635] Packages: <none>
[08:25:49.635] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.635] Resolved: TRUE
[08:25:49.635] Value: <not collected>
[08:25:49.635] Conditions captured: <none>
[08:25:49.635] Early signaling: FALSE
[08:25:49.635] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.635] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.643] Chunk #1 of 2 ... DONE
[08:25:49.643] Chunk #2 of 2 ...
[08:25:49.643]  - Finding globals in '...' for chunk #2 ...
[08:25:49.643] getGlobalsAndPackages() ...
[08:25:49.643] Searching for globals...
[08:25:49.644] 
[08:25:49.644] Searching for globals ... DONE
[08:25:49.644] - globals: [0] <none>
[08:25:49.644] getGlobalsAndPackages() ... DONE
[08:25:49.644]    + additional globals found: [n=0] 
[08:25:49.645]    + additional namespaces needed: [n=0] 
[08:25:49.645]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:49.645]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.645]  - seeds: <none>
[08:25:49.645]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.645] getGlobalsAndPackages() ...
[08:25:49.645] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.646] Resolving globals: FALSE
[08:25:49.646] The total size of the 5 globals is 909 bytes (909 bytes)
[08:25:49.651] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:49.652] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.652] 
[08:25:49.652] getGlobalsAndPackages() ... DONE
[08:25:49.653] run() for ‘Future’ ...
[08:25:49.654] - state: ‘created’
[08:25:49.654] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.658] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.658] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.658]   - Field: ‘label’
[08:25:49.659]   - Field: ‘local’
[08:25:49.659]   - Field: ‘owner’
[08:25:49.659]   - Field: ‘envir’
[08:25:49.659]   - Field: ‘workers’
[08:25:49.660]   - Field: ‘packages’
[08:25:49.660]   - Field: ‘gc’
[08:25:49.660]   - Field: ‘job’
[08:25:49.660]   - Field: ‘conditions’
[08:25:49.660]   - Field: ‘expr’
[08:25:49.661]   - Field: ‘uuid’
[08:25:49.661]   - Field: ‘seed’
[08:25:49.661]   - Field: ‘version’
[08:25:49.661]   - Field: ‘result’
[08:25:49.661]   - Field: ‘asynchronous’
[08:25:49.662]   - Field: ‘calls’
[08:25:49.662]   - Field: ‘globals’
[08:25:49.662]   - Field: ‘stdout’
[08:25:49.662]   - Field: ‘earlySignal’
[08:25:49.663]   - Field: ‘lazy’
[08:25:49.663]   - Field: ‘state’
[08:25:49.663] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.663] - Launch lazy future ...
[08:25:49.664] Packages needed by the future expression (n = 0): <none>
[08:25:49.664] Packages needed by future strategies (n = 0): <none>
[08:25:49.665] {
[08:25:49.665]     {
[08:25:49.665]         {
[08:25:49.665]             ...future.startTime <- base::Sys.time()
[08:25:49.665]             {
[08:25:49.665]                 {
[08:25:49.665]                   {
[08:25:49.665]                     {
[08:25:49.665]                       base::local({
[08:25:49.665]                         has_future <- base::requireNamespace("future", 
[08:25:49.665]                           quietly = TRUE)
[08:25:49.665]                         if (has_future) {
[08:25:49.665]                           ns <- base::getNamespace("future")
[08:25:49.665]                           version <- ns[[".package"]][["version"]]
[08:25:49.665]                           if (is.null(version)) 
[08:25:49.665]                             version <- utils::packageVersion("future")
[08:25:49.665]                         }
[08:25:49.665]                         else {
[08:25:49.665]                           version <- NULL
[08:25:49.665]                         }
[08:25:49.665]                         if (!has_future || version < "1.8.0") {
[08:25:49.665]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.665]                             "", base::R.version$version.string), 
[08:25:49.665]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.665]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.665]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.665]                               "release", "version")], collapse = " "), 
[08:25:49.665]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.665]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.665]                             info)
[08:25:49.665]                           info <- base::paste(info, collapse = "; ")
[08:25:49.665]                           if (!has_future) {
[08:25:49.665]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.665]                               info)
[08:25:49.665]                           }
[08:25:49.665]                           else {
[08:25:49.665]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.665]                               info, version)
[08:25:49.665]                           }
[08:25:49.665]                           base::stop(msg)
[08:25:49.665]                         }
[08:25:49.665]                       })
[08:25:49.665]                     }
[08:25:49.665]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.665]                     base::options(mc.cores = 1L)
[08:25:49.665]                   }
[08:25:49.665]                   ...future.strategy.old <- future::plan("list")
[08:25:49.665]                   options(future.plan = NULL)
[08:25:49.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.665]                 }
[08:25:49.665]                 ...future.workdir <- getwd()
[08:25:49.665]             }
[08:25:49.665]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.665]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.665]         }
[08:25:49.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.665]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.665]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.665]             base::names(...future.oldOptions))
[08:25:49.665]     }
[08:25:49.665]     if (FALSE) {
[08:25:49.665]     }
[08:25:49.665]     else {
[08:25:49.665]         if (TRUE) {
[08:25:49.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.665]                 open = "w")
[08:25:49.665]         }
[08:25:49.665]         else {
[08:25:49.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.665]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.665]         }
[08:25:49.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.665]             base::sink(type = "output", split = FALSE)
[08:25:49.665]             base::close(...future.stdout)
[08:25:49.665]         }, add = TRUE)
[08:25:49.665]     }
[08:25:49.665]     ...future.frame <- base::sys.nframe()
[08:25:49.665]     ...future.conditions <- base::list()
[08:25:49.665]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.665]     if (FALSE) {
[08:25:49.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.665]     }
[08:25:49.665]     ...future.result <- base::tryCatch({
[08:25:49.665]         base::withCallingHandlers({
[08:25:49.665]             ...future.value <- base::withVisible(base::local({
[08:25:49.665]                 withCallingHandlers({
[08:25:49.665]                   {
[08:25:49.665]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.665]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.665]                       ...future.globals.maxSize)) {
[08:25:49.665]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.665]                       on.exit(options(oopts), add = TRUE)
[08:25:49.665]                     }
[08:25:49.665]                     {
[08:25:49.665]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.665]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.665]                         USE.NAMES = FALSE)
[08:25:49.665]                       do.call(mapply, args = args)
[08:25:49.665]                     }
[08:25:49.665]                   }
[08:25:49.665]                 }, immediateCondition = function(cond) {
[08:25:49.665]                   save_rds <- function (object, pathname, ...) 
[08:25:49.665]                   {
[08:25:49.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.665]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.665]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.665]                         fi_tmp[["mtime"]])
[08:25:49.665]                     }
[08:25:49.665]                     tryCatch({
[08:25:49.665]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.665]                     }, error = function(ex) {
[08:25:49.665]                       msg <- conditionMessage(ex)
[08:25:49.665]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.665]                         fi_tmp[["mtime"]], msg)
[08:25:49.665]                       ex$message <- msg
[08:25:49.665]                       stop(ex)
[08:25:49.665]                     })
[08:25:49.665]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.665]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.665]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.665]                       fi <- file.info(pathname)
[08:25:49.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.665]                         fi[["size"]], fi[["mtime"]])
[08:25:49.665]                       stop(msg)
[08:25:49.665]                     }
[08:25:49.665]                     invisible(pathname)
[08:25:49.665]                   }
[08:25:49.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.665]                     rootPath = tempdir()) 
[08:25:49.665]                   {
[08:25:49.665]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.665]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.665]                       tmpdir = path, fileext = ".rds")
[08:25:49.665]                     save_rds(obj, file)
[08:25:49.665]                   }
[08:25:49.665]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.665]                   {
[08:25:49.665]                     inherits <- base::inherits
[08:25:49.665]                     invokeRestart <- base::invokeRestart
[08:25:49.665]                     is.null <- base::is.null
[08:25:49.665]                     muffled <- FALSE
[08:25:49.665]                     if (inherits(cond, "message")) {
[08:25:49.665]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.665]                       if (muffled) 
[08:25:49.665]                         invokeRestart("muffleMessage")
[08:25:49.665]                     }
[08:25:49.665]                     else if (inherits(cond, "warning")) {
[08:25:49.665]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.665]                       if (muffled) 
[08:25:49.665]                         invokeRestart("muffleWarning")
[08:25:49.665]                     }
[08:25:49.665]                     else if (inherits(cond, "condition")) {
[08:25:49.665]                       if (!is.null(pattern)) {
[08:25:49.665]                         computeRestarts <- base::computeRestarts
[08:25:49.665]                         grepl <- base::grepl
[08:25:49.665]                         restarts <- computeRestarts(cond)
[08:25:49.665]                         for (restart in restarts) {
[08:25:49.665]                           name <- restart$name
[08:25:49.665]                           if (is.null(name)) 
[08:25:49.665]                             next
[08:25:49.665]                           if (!grepl(pattern, name)) 
[08:25:49.665]                             next
[08:25:49.665]                           invokeRestart(restart)
[08:25:49.665]                           muffled <- TRUE
[08:25:49.665]                           break
[08:25:49.665]                         }
[08:25:49.665]                       }
[08:25:49.665]                     }
[08:25:49.665]                     invisible(muffled)
[08:25:49.665]                   }
[08:25:49.665]                   muffleCondition(cond)
[08:25:49.665]                 })
[08:25:49.665]             }))
[08:25:49.665]             future::FutureResult(value = ...future.value$value, 
[08:25:49.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.665]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.665]                     ...future.globalenv.names))
[08:25:49.665]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.665]         }, condition = base::local({
[08:25:49.665]             c <- base::c
[08:25:49.665]             inherits <- base::inherits
[08:25:49.665]             invokeRestart <- base::invokeRestart
[08:25:49.665]             length <- base::length
[08:25:49.665]             list <- base::list
[08:25:49.665]             seq.int <- base::seq.int
[08:25:49.665]             signalCondition <- base::signalCondition
[08:25:49.665]             sys.calls <- base::sys.calls
[08:25:49.665]             `[[` <- base::`[[`
[08:25:49.665]             `+` <- base::`+`
[08:25:49.665]             `<<-` <- base::`<<-`
[08:25:49.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.665]                   3L)]
[08:25:49.665]             }
[08:25:49.665]             function(cond) {
[08:25:49.665]                 is_error <- inherits(cond, "error")
[08:25:49.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.665]                   NULL)
[08:25:49.665]                 if (is_error) {
[08:25:49.665]                   sessionInformation <- function() {
[08:25:49.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.665]                       search = base::search(), system = base::Sys.info())
[08:25:49.665]                   }
[08:25:49.665]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.665]                     cond$call), session = sessionInformation(), 
[08:25:49.665]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.665]                   signalCondition(cond)
[08:25:49.665]                 }
[08:25:49.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.665]                 "immediateCondition"))) {
[08:25:49.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.665]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.665]                   if (TRUE && !signal) {
[08:25:49.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.665]                     {
[08:25:49.665]                       inherits <- base::inherits
[08:25:49.665]                       invokeRestart <- base::invokeRestart
[08:25:49.665]                       is.null <- base::is.null
[08:25:49.665]                       muffled <- FALSE
[08:25:49.665]                       if (inherits(cond, "message")) {
[08:25:49.665]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.665]                         if (muffled) 
[08:25:49.665]                           invokeRestart("muffleMessage")
[08:25:49.665]                       }
[08:25:49.665]                       else if (inherits(cond, "warning")) {
[08:25:49.665]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.665]                         if (muffled) 
[08:25:49.665]                           invokeRestart("muffleWarning")
[08:25:49.665]                       }
[08:25:49.665]                       else if (inherits(cond, "condition")) {
[08:25:49.665]                         if (!is.null(pattern)) {
[08:25:49.665]                           computeRestarts <- base::computeRestarts
[08:25:49.665]                           grepl <- base::grepl
[08:25:49.665]                           restarts <- computeRestarts(cond)
[08:25:49.665]                           for (restart in restarts) {
[08:25:49.665]                             name <- restart$name
[08:25:49.665]                             if (is.null(name)) 
[08:25:49.665]                               next
[08:25:49.665]                             if (!grepl(pattern, name)) 
[08:25:49.665]                               next
[08:25:49.665]                             invokeRestart(restart)
[08:25:49.665]                             muffled <- TRUE
[08:25:49.665]                             break
[08:25:49.665]                           }
[08:25:49.665]                         }
[08:25:49.665]                       }
[08:25:49.665]                       invisible(muffled)
[08:25:49.665]                     }
[08:25:49.665]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.665]                   }
[08:25:49.665]                 }
[08:25:49.665]                 else {
[08:25:49.665]                   if (TRUE) {
[08:25:49.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.665]                     {
[08:25:49.665]                       inherits <- base::inherits
[08:25:49.665]                       invokeRestart <- base::invokeRestart
[08:25:49.665]                       is.null <- base::is.null
[08:25:49.665]                       muffled <- FALSE
[08:25:49.665]                       if (inherits(cond, "message")) {
[08:25:49.665]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.665]                         if (muffled) 
[08:25:49.665]                           invokeRestart("muffleMessage")
[08:25:49.665]                       }
[08:25:49.665]                       else if (inherits(cond, "warning")) {
[08:25:49.665]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.665]                         if (muffled) 
[08:25:49.665]                           invokeRestart("muffleWarning")
[08:25:49.665]                       }
[08:25:49.665]                       else if (inherits(cond, "condition")) {
[08:25:49.665]                         if (!is.null(pattern)) {
[08:25:49.665]                           computeRestarts <- base::computeRestarts
[08:25:49.665]                           grepl <- base::grepl
[08:25:49.665]                           restarts <- computeRestarts(cond)
[08:25:49.665]                           for (restart in restarts) {
[08:25:49.665]                             name <- restart$name
[08:25:49.665]                             if (is.null(name)) 
[08:25:49.665]                               next
[08:25:49.665]                             if (!grepl(pattern, name)) 
[08:25:49.665]                               next
[08:25:49.665]                             invokeRestart(restart)
[08:25:49.665]                             muffled <- TRUE
[08:25:49.665]                             break
[08:25:49.665]                           }
[08:25:49.665]                         }
[08:25:49.665]                       }
[08:25:49.665]                       invisible(muffled)
[08:25:49.665]                     }
[08:25:49.665]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.665]                   }
[08:25:49.665]                 }
[08:25:49.665]             }
[08:25:49.665]         }))
[08:25:49.665]     }, error = function(ex) {
[08:25:49.665]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.665]                 ...future.rng), started = ...future.startTime, 
[08:25:49.665]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.665]             version = "1.8"), class = "FutureResult")
[08:25:49.665]     }, finally = {
[08:25:49.665]         if (!identical(...future.workdir, getwd())) 
[08:25:49.665]             setwd(...future.workdir)
[08:25:49.665]         {
[08:25:49.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.665]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.665]             }
[08:25:49.665]             base::options(...future.oldOptions)
[08:25:49.665]             if (.Platform$OS.type == "windows") {
[08:25:49.665]                 old_names <- names(...future.oldEnvVars)
[08:25:49.665]                 envs <- base::Sys.getenv()
[08:25:49.665]                 names <- names(envs)
[08:25:49.665]                 common <- intersect(names, old_names)
[08:25:49.665]                 added <- setdiff(names, old_names)
[08:25:49.665]                 removed <- setdiff(old_names, names)
[08:25:49.665]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.665]                   envs[common]]
[08:25:49.665]                 NAMES <- toupper(changed)
[08:25:49.665]                 args <- list()
[08:25:49.665]                 for (kk in seq_along(NAMES)) {
[08:25:49.665]                   name <- changed[[kk]]
[08:25:49.665]                   NAME <- NAMES[[kk]]
[08:25:49.665]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.665]                     next
[08:25:49.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.665]                 }
[08:25:49.665]                 NAMES <- toupper(added)
[08:25:49.665]                 for (kk in seq_along(NAMES)) {
[08:25:49.665]                   name <- added[[kk]]
[08:25:49.665]                   NAME <- NAMES[[kk]]
[08:25:49.665]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.665]                     next
[08:25:49.665]                   args[[name]] <- ""
[08:25:49.665]                 }
[08:25:49.665]                 NAMES <- toupper(removed)
[08:25:49.665]                 for (kk in seq_along(NAMES)) {
[08:25:49.665]                   name <- removed[[kk]]
[08:25:49.665]                   NAME <- NAMES[[kk]]
[08:25:49.665]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.665]                     next
[08:25:49.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.665]                 }
[08:25:49.665]                 if (length(args) > 0) 
[08:25:49.665]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.665]             }
[08:25:49.665]             else {
[08:25:49.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.665]             }
[08:25:49.665]             {
[08:25:49.665]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.665]                   0L) {
[08:25:49.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.665]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.665]                   base::options(opts)
[08:25:49.665]                 }
[08:25:49.665]                 {
[08:25:49.665]                   {
[08:25:49.665]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.665]                     NULL
[08:25:49.665]                   }
[08:25:49.665]                   options(future.plan = NULL)
[08:25:49.665]                   if (is.na(NA_character_)) 
[08:25:49.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.665]                     .init = FALSE)
[08:25:49.665]                 }
[08:25:49.665]             }
[08:25:49.665]         }
[08:25:49.665]     })
[08:25:49.665]     if (TRUE) {
[08:25:49.665]         base::sink(type = "output", split = FALSE)
[08:25:49.665]         if (TRUE) {
[08:25:49.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.665]         }
[08:25:49.665]         else {
[08:25:49.665]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.665]         }
[08:25:49.665]         base::close(...future.stdout)
[08:25:49.665]         ...future.stdout <- NULL
[08:25:49.665]     }
[08:25:49.665]     ...future.result$conditions <- ...future.conditions
[08:25:49.665]     ...future.result$finished <- base::Sys.time()
[08:25:49.665]     ...future.result
[08:25:49.665] }
[08:25:49.668] assign_globals() ...
[08:25:49.668] List of 5
[08:25:49.668]  $ ...future.FUN            :function (C, k)  
[08:25:49.668]  $ MoreArgs                 : list()
[08:25:49.668]  $ ...future.elements_ii    :List of 2
[08:25:49.668]   ..$ :List of 3
[08:25:49.668]   .. ..$ : chr "C"
[08:25:49.668]   .. ..$ : chr "D"
[08:25:49.668]   .. ..$ : chr "E"
[08:25:49.668]   ..$ :List of 3
[08:25:49.668]   .. ..$ : int 3
[08:25:49.668]   .. ..$ : int 2
[08:25:49.668]   .. ..$ : int 1
[08:25:49.668]  $ ...future.seeds_ii       : NULL
[08:25:49.668]  $ ...future.globals.maxSize: NULL
[08:25:49.668]  - attr(*, "where")=List of 5
[08:25:49.668]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.668]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.668]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.668]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.668]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.668]  - attr(*, "resolved")= logi FALSE
[08:25:49.668]  - attr(*, "total_size")= num 909
[08:25:49.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.668]  - attr(*, "already-done")= logi TRUE
[08:25:49.676] - reassign environment for ‘...future.FUN’
[08:25:49.676] - copied ‘...future.FUN’ to environment
[08:25:49.676] - copied ‘MoreArgs’ to environment
[08:25:49.677] - copied ‘...future.elements_ii’ to environment
[08:25:49.677] - copied ‘...future.seeds_ii’ to environment
[08:25:49.677] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.677] assign_globals() ... done
[08:25:49.677] requestCore(): workers = 2
[08:25:49.680] MulticoreFuture started
[08:25:49.680] - Launch lazy future ... done
[08:25:49.680] run() for ‘MulticoreFuture’ ... done
[08:25:49.680] Created future:
[08:25:49.681] plan(): Setting new future strategy stack:
[08:25:49.681] List of future strategies:
[08:25:49.681] 1. sequential:
[08:25:49.681]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.681]    - tweaked: FALSE
[08:25:49.681]    - call: NULL
[08:25:49.682] plan(): nbrOfWorkers() = 1
[08:25:49.684] plan(): Setting new future strategy stack:
[08:25:49.684] List of future strategies:
[08:25:49.684] 1. multicore:
[08:25:49.684]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.684]    - tweaked: FALSE
[08:25:49.684]    - call: plan(strategy)
[08:25:49.688] plan(): nbrOfWorkers() = 2
[08:25:49.681] MulticoreFuture:
[08:25:49.681] Label: ‘future_.mapply-2’
[08:25:49.681] Expression:
[08:25:49.681] {
[08:25:49.681]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.681]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.681]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.681]         on.exit(options(oopts), add = TRUE)
[08:25:49.681]     }
[08:25:49.681]     {
[08:25:49.681]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.681]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.681]         do.call(mapply, args = args)
[08:25:49.681]     }
[08:25:49.681] }
[08:25:49.681] Lazy evaluation: FALSE
[08:25:49.681] Asynchronous evaluation: TRUE
[08:25:49.681] Local evaluation: TRUE
[08:25:49.681] Environment: R_GlobalEnv
[08:25:49.681] Capture standard output: TRUE
[08:25:49.681] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.681] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.681] Packages: <none>
[08:25:49.681] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.681] Resolved: TRUE
[08:25:49.681] Value: <not collected>
[08:25:49.681] Conditions captured: <none>
[08:25:49.681] Early signaling: FALSE
[08:25:49.681] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.681] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.689] Chunk #2 of 2 ... DONE
[08:25:49.689] Launching 2 futures (chunks) ... DONE
[08:25:49.689] Resolving 2 futures (chunks) ...
[08:25:49.689] resolve() on list ...
[08:25:49.690]  recursive: 0
[08:25:49.690]  length: 2
[08:25:49.690] 
[08:25:49.690] Future #1
[08:25:49.690] result() for MulticoreFuture ...
[08:25:49.691] result() for MulticoreFuture ...
[08:25:49.691] result() for MulticoreFuture ... done
[08:25:49.691] result() for MulticoreFuture ... done
[08:25:49.692] result() for MulticoreFuture ...
[08:25:49.692] result() for MulticoreFuture ... done
[08:25:49.692] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:49.692] - nx: 2
[08:25:49.692] - relay: TRUE
[08:25:49.692] - stdout: TRUE
[08:25:49.692] - signal: TRUE
[08:25:49.693] - resignal: FALSE
[08:25:49.693] - force: TRUE
[08:25:49.693] - relayed: [n=2] FALSE, FALSE
[08:25:49.693] - queued futures: [n=2] FALSE, FALSE
[08:25:49.693]  - until=1
[08:25:49.693]  - relaying element #1
[08:25:49.693] result() for MulticoreFuture ...
[08:25:49.694] result() for MulticoreFuture ... done
[08:25:49.698] result() for MulticoreFuture ...
[08:25:49.698] result() for MulticoreFuture ... done
[08:25:49.699] result() for MulticoreFuture ...
[08:25:49.699] result() for MulticoreFuture ... done
[08:25:49.699] result() for MulticoreFuture ...
[08:25:49.700] result() for MulticoreFuture ... done
[08:25:49.700] - relayed: [n=2] TRUE, FALSE
[08:25:49.700] - queued futures: [n=2] TRUE, FALSE
[08:25:49.701] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:49.701]  length: 1 (resolved future 1)
[08:25:49.701] Future #2
[08:25:49.702] result() for MulticoreFuture ...
[08:25:49.703] result() for MulticoreFuture ...
[08:25:49.703] result() for MulticoreFuture ... done
[08:25:49.703] result() for MulticoreFuture ... done
[08:25:49.704] result() for MulticoreFuture ...
[08:25:49.704] result() for MulticoreFuture ... done
[08:25:49.704] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:49.704] - nx: 2
[08:25:49.704] - relay: TRUE
[08:25:49.705] - stdout: TRUE
[08:25:49.705] - signal: TRUE
[08:25:49.705] - resignal: FALSE
[08:25:49.705] - force: TRUE
[08:25:49.705] - relayed: [n=2] TRUE, FALSE
[08:25:49.705] - queued futures: [n=2] TRUE, FALSE
[08:25:49.706]  - until=2
[08:25:49.706]  - relaying element #2
[08:25:49.706] result() for MulticoreFuture ...
[08:25:49.706] result() for MulticoreFuture ... done
[08:25:49.706] result() for MulticoreFuture ...
[08:25:49.706] result() for MulticoreFuture ... done
[08:25:49.707] result() for MulticoreFuture ...
[08:25:49.707] result() for MulticoreFuture ... done
[08:25:49.707] result() for MulticoreFuture ...
[08:25:49.707] result() for MulticoreFuture ... done
[08:25:49.707] - relayed: [n=2] TRUE, TRUE
[08:25:49.707] - queued futures: [n=2] TRUE, TRUE
[08:25:49.708] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:49.708]  length: 0 (resolved future 2)
[08:25:49.708] Relaying remaining futures
[08:25:49.708] signalConditionsASAP(NULL, pos=0) ...
[08:25:49.708] - nx: 2
[08:25:49.708] - relay: TRUE
[08:25:49.708] - stdout: TRUE
[08:25:49.709] - signal: TRUE
[08:25:49.709] - resignal: FALSE
[08:25:49.709] - force: TRUE
[08:25:49.709] - relayed: [n=2] TRUE, TRUE
[08:25:49.709] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:49.709] - relayed: [n=2] TRUE, TRUE
[08:25:49.709] - queued futures: [n=2] TRUE, TRUE
[08:25:49.709] signalConditionsASAP(NULL, pos=0) ... done
[08:25:49.709] resolve() on list ... DONE
[08:25:49.710] result() for MulticoreFuture ...
[08:25:49.710] result() for MulticoreFuture ... done
[08:25:49.710] result() for MulticoreFuture ...
[08:25:49.710] result() for MulticoreFuture ... done
[08:25:49.710] result() for MulticoreFuture ...
[08:25:49.710] result() for MulticoreFuture ... done
[08:25:49.710] result() for MulticoreFuture ...
[08:25:49.710] result() for MulticoreFuture ... done
[08:25:49.711]  - Number of value chunks collected: 2
[08:25:49.711] Resolving 2 futures (chunks) ... DONE
[08:25:49.711] Reducing values from 2 chunks ...
[08:25:49.711]  - Number of values collected after concatenation: 5
[08:25:49.711]  - Number of values expected: 5
[08:25:49.711] Reducing values from 2 chunks ... DONE
[08:25:49.711] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[08:25:49.712] future_mapply() ...
[08:25:49.714] Number of chunks: 1
[08:25:49.714] getGlobalsAndPackagesXApply() ...
[08:25:49.714]  - future.globals: TRUE
[08:25:49.714] getGlobalsAndPackages() ...
[08:25:49.714] Searching for globals...
[08:25:49.715] - globals found: [1] ‘FUN’
[08:25:49.715] Searching for globals ... DONE
[08:25:49.716] Resolving globals: FALSE
[08:25:49.716] The total size of the 1 globals is 185 bytes (185 bytes)
[08:25:49.716] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:25:49.716] - globals: [1] ‘FUN’
[08:25:49.717] 
[08:25:49.717] getGlobalsAndPackages() ... DONE
[08:25:49.717]  - globals found/used: [n=1] ‘FUN’
[08:25:49.717]  - needed namespaces: [n=0] 
[08:25:49.717] Finding globals ... DONE
[08:25:49.717] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:49.717] List of 2
[08:25:49.717]  $ ...future.FUN:function (x)  
[08:25:49.717]  $ MoreArgs     : NULL
[08:25:49.717]  - attr(*, "where")=List of 2
[08:25:49.717]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:49.717]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:49.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.717]  - attr(*, "resolved")= logi FALSE
[08:25:49.717]  - attr(*, "total_size")= num NA
[08:25:49.720] Packages to be attached in all futures: [n=0] 
[08:25:49.720] getGlobalsAndPackagesXApply() ... DONE
[08:25:49.721] Number of futures (= number of chunks): 1
[08:25:49.721] Launching 1 futures (chunks) ...
[08:25:49.721] Chunk #1 of 1 ...
[08:25:49.721]  - Finding globals in '...' for chunk #1 ...
[08:25:49.721] getGlobalsAndPackages() ...
[08:25:49.721] Searching for globals...
[08:25:49.721] 
[08:25:49.722] Searching for globals ... DONE
[08:25:49.722] - globals: [0] <none>
[08:25:49.722] getGlobalsAndPackages() ... DONE
[08:25:49.722]    + additional globals found: [n=0] 
[08:25:49.722]    + additional namespaces needed: [n=0] 
[08:25:49.722]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:49.722]  - seeds: <none>
[08:25:49.722]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.722] getGlobalsAndPackages() ...
[08:25:49.722] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.723] Resolving globals: FALSE
[08:25:49.723] The total size of the 5 globals is 366 bytes (366 bytes)
[08:25:49.723] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 366 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:49.724] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.724] 
[08:25:49.724] getGlobalsAndPackages() ... DONE
[08:25:49.727] run() for ‘Future’ ...
[08:25:49.727] - state: ‘created’
[08:25:49.727] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.729] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.729] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.729]   - Field: ‘label’
[08:25:49.729]   - Field: ‘local’
[08:25:49.730]   - Field: ‘owner’
[08:25:49.730]   - Field: ‘envir’
[08:25:49.730]   - Field: ‘workers’
[08:25:49.730]   - Field: ‘packages’
[08:25:49.730]   - Field: ‘gc’
[08:25:49.730]   - Field: ‘job’
[08:25:49.730]   - Field: ‘conditions’
[08:25:49.730]   - Field: ‘expr’
[08:25:49.731]   - Field: ‘uuid’
[08:25:49.731]   - Field: ‘seed’
[08:25:49.731]   - Field: ‘version’
[08:25:49.731]   - Field: ‘result’
[08:25:49.731]   - Field: ‘asynchronous’
[08:25:49.731]   - Field: ‘calls’
[08:25:49.731]   - Field: ‘globals’
[08:25:49.731]   - Field: ‘stdout’
[08:25:49.732]   - Field: ‘earlySignal’
[08:25:49.732]   - Field: ‘lazy’
[08:25:49.732]   - Field: ‘state’
[08:25:49.732] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.732] - Launch lazy future ...
[08:25:49.732] Packages needed by the future expression (n = 0): <none>
[08:25:49.732] Packages needed by future strategies (n = 0): <none>
[08:25:49.733] {
[08:25:49.733]     {
[08:25:49.733]         {
[08:25:49.733]             ...future.startTime <- base::Sys.time()
[08:25:49.733]             {
[08:25:49.733]                 {
[08:25:49.733]                   {
[08:25:49.733]                     {
[08:25:49.733]                       base::local({
[08:25:49.733]                         has_future <- base::requireNamespace("future", 
[08:25:49.733]                           quietly = TRUE)
[08:25:49.733]                         if (has_future) {
[08:25:49.733]                           ns <- base::getNamespace("future")
[08:25:49.733]                           version <- ns[[".package"]][["version"]]
[08:25:49.733]                           if (is.null(version)) 
[08:25:49.733]                             version <- utils::packageVersion("future")
[08:25:49.733]                         }
[08:25:49.733]                         else {
[08:25:49.733]                           version <- NULL
[08:25:49.733]                         }
[08:25:49.733]                         if (!has_future || version < "1.8.0") {
[08:25:49.733]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.733]                             "", base::R.version$version.string), 
[08:25:49.733]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.733]                               "release", "version")], collapse = " "), 
[08:25:49.733]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.733]                             info)
[08:25:49.733]                           info <- base::paste(info, collapse = "; ")
[08:25:49.733]                           if (!has_future) {
[08:25:49.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.733]                               info)
[08:25:49.733]                           }
[08:25:49.733]                           else {
[08:25:49.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.733]                               info, version)
[08:25:49.733]                           }
[08:25:49.733]                           base::stop(msg)
[08:25:49.733]                         }
[08:25:49.733]                       })
[08:25:49.733]                     }
[08:25:49.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.733]                     base::options(mc.cores = 1L)
[08:25:49.733]                   }
[08:25:49.733]                   ...future.strategy.old <- future::plan("list")
[08:25:49.733]                   options(future.plan = NULL)
[08:25:49.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.733]                 }
[08:25:49.733]                 ...future.workdir <- getwd()
[08:25:49.733]             }
[08:25:49.733]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.733]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.733]         }
[08:25:49.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:49.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.733]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.733]             base::names(...future.oldOptions))
[08:25:49.733]     }
[08:25:49.733]     if (FALSE) {
[08:25:49.733]     }
[08:25:49.733]     else {
[08:25:49.733]         if (TRUE) {
[08:25:49.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.733]                 open = "w")
[08:25:49.733]         }
[08:25:49.733]         else {
[08:25:49.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.733]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.733]         }
[08:25:49.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.733]             base::sink(type = "output", split = FALSE)
[08:25:49.733]             base::close(...future.stdout)
[08:25:49.733]         }, add = TRUE)
[08:25:49.733]     }
[08:25:49.733]     ...future.frame <- base::sys.nframe()
[08:25:49.733]     ...future.conditions <- base::list()
[08:25:49.733]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.733]     if (FALSE) {
[08:25:49.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.733]     }
[08:25:49.733]     ...future.result <- base::tryCatch({
[08:25:49.733]         base::withCallingHandlers({
[08:25:49.733]             ...future.value <- base::withVisible(base::local({
[08:25:49.733]                 withCallingHandlers({
[08:25:49.733]                   {
[08:25:49.733]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.733]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.733]                       ...future.globals.maxSize)) {
[08:25:49.733]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.733]                       on.exit(options(oopts), add = TRUE)
[08:25:49.733]                     }
[08:25:49.733]                     {
[08:25:49.733]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.733]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.733]                         USE.NAMES = FALSE)
[08:25:49.733]                       do.call(mapply, args = args)
[08:25:49.733]                     }
[08:25:49.733]                   }
[08:25:49.733]                 }, immediateCondition = function(cond) {
[08:25:49.733]                   save_rds <- function (object, pathname, ...) 
[08:25:49.733]                   {
[08:25:49.733]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.733]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.733]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.733]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.733]                         fi_tmp[["mtime"]])
[08:25:49.733]                     }
[08:25:49.733]                     tryCatch({
[08:25:49.733]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.733]                     }, error = function(ex) {
[08:25:49.733]                       msg <- conditionMessage(ex)
[08:25:49.733]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.733]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.733]                         fi_tmp[["mtime"]], msg)
[08:25:49.733]                       ex$message <- msg
[08:25:49.733]                       stop(ex)
[08:25:49.733]                     })
[08:25:49.733]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.733]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.733]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.733]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.733]                       fi <- file.info(pathname)
[08:25:49.733]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.733]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.733]                         fi[["size"]], fi[["mtime"]])
[08:25:49.733]                       stop(msg)
[08:25:49.733]                     }
[08:25:49.733]                     invisible(pathname)
[08:25:49.733]                   }
[08:25:49.733]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.733]                     rootPath = tempdir()) 
[08:25:49.733]                   {
[08:25:49.733]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.733]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.733]                       tmpdir = path, fileext = ".rds")
[08:25:49.733]                     save_rds(obj, file)
[08:25:49.733]                   }
[08:25:49.733]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.733]                   {
[08:25:49.733]                     inherits <- base::inherits
[08:25:49.733]                     invokeRestart <- base::invokeRestart
[08:25:49.733]                     is.null <- base::is.null
[08:25:49.733]                     muffled <- FALSE
[08:25:49.733]                     if (inherits(cond, "message")) {
[08:25:49.733]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.733]                       if (muffled) 
[08:25:49.733]                         invokeRestart("muffleMessage")
[08:25:49.733]                     }
[08:25:49.733]                     else if (inherits(cond, "warning")) {
[08:25:49.733]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.733]                       if (muffled) 
[08:25:49.733]                         invokeRestart("muffleWarning")
[08:25:49.733]                     }
[08:25:49.733]                     else if (inherits(cond, "condition")) {
[08:25:49.733]                       if (!is.null(pattern)) {
[08:25:49.733]                         computeRestarts <- base::computeRestarts
[08:25:49.733]                         grepl <- base::grepl
[08:25:49.733]                         restarts <- computeRestarts(cond)
[08:25:49.733]                         for (restart in restarts) {
[08:25:49.733]                           name <- restart$name
[08:25:49.733]                           if (is.null(name)) 
[08:25:49.733]                             next
[08:25:49.733]                           if (!grepl(pattern, name)) 
[08:25:49.733]                             next
[08:25:49.733]                           invokeRestart(restart)
[08:25:49.733]                           muffled <- TRUE
[08:25:49.733]                           break
[08:25:49.733]                         }
[08:25:49.733]                       }
[08:25:49.733]                     }
[08:25:49.733]                     invisible(muffled)
[08:25:49.733]                   }
[08:25:49.733]                   muffleCondition(cond)
[08:25:49.733]                 })
[08:25:49.733]             }))
[08:25:49.733]             future::FutureResult(value = ...future.value$value, 
[08:25:49.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.733]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.733]                     ...future.globalenv.names))
[08:25:49.733]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.733]         }, condition = base::local({
[08:25:49.733]             c <- base::c
[08:25:49.733]             inherits <- base::inherits
[08:25:49.733]             invokeRestart <- base::invokeRestart
[08:25:49.733]             length <- base::length
[08:25:49.733]             list <- base::list
[08:25:49.733]             seq.int <- base::seq.int
[08:25:49.733]             signalCondition <- base::signalCondition
[08:25:49.733]             sys.calls <- base::sys.calls
[08:25:49.733]             `[[` <- base::`[[`
[08:25:49.733]             `+` <- base::`+`
[08:25:49.733]             `<<-` <- base::`<<-`
[08:25:49.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.733]                   3L)]
[08:25:49.733]             }
[08:25:49.733]             function(cond) {
[08:25:49.733]                 is_error <- inherits(cond, "error")
[08:25:49.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.733]                   NULL)
[08:25:49.733]                 if (is_error) {
[08:25:49.733]                   sessionInformation <- function() {
[08:25:49.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.733]                       search = base::search(), system = base::Sys.info())
[08:25:49.733]                   }
[08:25:49.733]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.733]                     cond$call), session = sessionInformation(), 
[08:25:49.733]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.733]                   signalCondition(cond)
[08:25:49.733]                 }
[08:25:49.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.733]                 "immediateCondition"))) {
[08:25:49.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.733]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.733]                   if (TRUE && !signal) {
[08:25:49.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.733]                     {
[08:25:49.733]                       inherits <- base::inherits
[08:25:49.733]                       invokeRestart <- base::invokeRestart
[08:25:49.733]                       is.null <- base::is.null
[08:25:49.733]                       muffled <- FALSE
[08:25:49.733]                       if (inherits(cond, "message")) {
[08:25:49.733]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.733]                         if (muffled) 
[08:25:49.733]                           invokeRestart("muffleMessage")
[08:25:49.733]                       }
[08:25:49.733]                       else if (inherits(cond, "warning")) {
[08:25:49.733]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.733]                         if (muffled) 
[08:25:49.733]                           invokeRestart("muffleWarning")
[08:25:49.733]                       }
[08:25:49.733]                       else if (inherits(cond, "condition")) {
[08:25:49.733]                         if (!is.null(pattern)) {
[08:25:49.733]                           computeRestarts <- base::computeRestarts
[08:25:49.733]                           grepl <- base::grepl
[08:25:49.733]                           restarts <- computeRestarts(cond)
[08:25:49.733]                           for (restart in restarts) {
[08:25:49.733]                             name <- restart$name
[08:25:49.733]                             if (is.null(name)) 
[08:25:49.733]                               next
[08:25:49.733]                             if (!grepl(pattern, name)) 
[08:25:49.733]                               next
[08:25:49.733]                             invokeRestart(restart)
[08:25:49.733]                             muffled <- TRUE
[08:25:49.733]                             break
[08:25:49.733]                           }
[08:25:49.733]                         }
[08:25:49.733]                       }
[08:25:49.733]                       invisible(muffled)
[08:25:49.733]                     }
[08:25:49.733]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.733]                   }
[08:25:49.733]                 }
[08:25:49.733]                 else {
[08:25:49.733]                   if (TRUE) {
[08:25:49.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.733]                     {
[08:25:49.733]                       inherits <- base::inherits
[08:25:49.733]                       invokeRestart <- base::invokeRestart
[08:25:49.733]                       is.null <- base::is.null
[08:25:49.733]                       muffled <- FALSE
[08:25:49.733]                       if (inherits(cond, "message")) {
[08:25:49.733]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.733]                         if (muffled) 
[08:25:49.733]                           invokeRestart("muffleMessage")
[08:25:49.733]                       }
[08:25:49.733]                       else if (inherits(cond, "warning")) {
[08:25:49.733]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.733]                         if (muffled) 
[08:25:49.733]                           invokeRestart("muffleWarning")
[08:25:49.733]                       }
[08:25:49.733]                       else if (inherits(cond, "condition")) {
[08:25:49.733]                         if (!is.null(pattern)) {
[08:25:49.733]                           computeRestarts <- base::computeRestarts
[08:25:49.733]                           grepl <- base::grepl
[08:25:49.733]                           restarts <- computeRestarts(cond)
[08:25:49.733]                           for (restart in restarts) {
[08:25:49.733]                             name <- restart$name
[08:25:49.733]                             if (is.null(name)) 
[08:25:49.733]                               next
[08:25:49.733]                             if (!grepl(pattern, name)) 
[08:25:49.733]                               next
[08:25:49.733]                             invokeRestart(restart)
[08:25:49.733]                             muffled <- TRUE
[08:25:49.733]                             break
[08:25:49.733]                           }
[08:25:49.733]                         }
[08:25:49.733]                       }
[08:25:49.733]                       invisible(muffled)
[08:25:49.733]                     }
[08:25:49.733]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.733]                   }
[08:25:49.733]                 }
[08:25:49.733]             }
[08:25:49.733]         }))
[08:25:49.733]     }, error = function(ex) {
[08:25:49.733]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.733]                 ...future.rng), started = ...future.startTime, 
[08:25:49.733]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.733]             version = "1.8"), class = "FutureResult")
[08:25:49.733]     }, finally = {
[08:25:49.733]         if (!identical(...future.workdir, getwd())) 
[08:25:49.733]             setwd(...future.workdir)
[08:25:49.733]         {
[08:25:49.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.733]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.733]             }
[08:25:49.733]             base::options(...future.oldOptions)
[08:25:49.733]             if (.Platform$OS.type == "windows") {
[08:25:49.733]                 old_names <- names(...future.oldEnvVars)
[08:25:49.733]                 envs <- base::Sys.getenv()
[08:25:49.733]                 names <- names(envs)
[08:25:49.733]                 common <- intersect(names, old_names)
[08:25:49.733]                 added <- setdiff(names, old_names)
[08:25:49.733]                 removed <- setdiff(old_names, names)
[08:25:49.733]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.733]                   envs[common]]
[08:25:49.733]                 NAMES <- toupper(changed)
[08:25:49.733]                 args <- list()
[08:25:49.733]                 for (kk in seq_along(NAMES)) {
[08:25:49.733]                   name <- changed[[kk]]
[08:25:49.733]                   NAME <- NAMES[[kk]]
[08:25:49.733]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.733]                     next
[08:25:49.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.733]                 }
[08:25:49.733]                 NAMES <- toupper(added)
[08:25:49.733]                 for (kk in seq_along(NAMES)) {
[08:25:49.733]                   name <- added[[kk]]
[08:25:49.733]                   NAME <- NAMES[[kk]]
[08:25:49.733]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.733]                     next
[08:25:49.733]                   args[[name]] <- ""
[08:25:49.733]                 }
[08:25:49.733]                 NAMES <- toupper(removed)
[08:25:49.733]                 for (kk in seq_along(NAMES)) {
[08:25:49.733]                   name <- removed[[kk]]
[08:25:49.733]                   NAME <- NAMES[[kk]]
[08:25:49.733]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.733]                     next
[08:25:49.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.733]                 }
[08:25:49.733]                 if (length(args) > 0) 
[08:25:49.733]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.733]             }
[08:25:49.733]             else {
[08:25:49.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.733]             }
[08:25:49.733]             {
[08:25:49.733]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.733]                   0L) {
[08:25:49.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.733]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.733]                   base::options(opts)
[08:25:49.733]                 }
[08:25:49.733]                 {
[08:25:49.733]                   {
[08:25:49.733]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.733]                     NULL
[08:25:49.733]                   }
[08:25:49.733]                   options(future.plan = NULL)
[08:25:49.733]                   if (is.na(NA_character_)) 
[08:25:49.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.733]                     .init = FALSE)
[08:25:49.733]                 }
[08:25:49.733]             }
[08:25:49.733]         }
[08:25:49.733]     })
[08:25:49.733]     if (TRUE) {
[08:25:49.733]         base::sink(type = "output", split = FALSE)
[08:25:49.733]         if (TRUE) {
[08:25:49.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.733]         }
[08:25:49.733]         else {
[08:25:49.733]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.733]         }
[08:25:49.733]         base::close(...future.stdout)
[08:25:49.733]         ...future.stdout <- NULL
[08:25:49.733]     }
[08:25:49.733]     ...future.result$conditions <- ...future.conditions
[08:25:49.733]     ...future.result$finished <- base::Sys.time()
[08:25:49.733]     ...future.result
[08:25:49.733] }
[08:25:49.736] assign_globals() ...
[08:25:49.736] List of 5
[08:25:49.736]  $ ...future.FUN            :function (x)  
[08:25:49.736]  $ MoreArgs                 : NULL
[08:25:49.736]  $ ...future.elements_ii    :List of 1
[08:25:49.736]   ..$ :List of 1
[08:25:49.736]   .. ..$ : Date[1:1], format: "2018-06-01"
[08:25:49.736]  $ ...future.seeds_ii       : NULL
[08:25:49.736]  $ ...future.globals.maxSize: NULL
[08:25:49.736]  - attr(*, "where")=List of 5
[08:25:49.736]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.736]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.736]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.736]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.736]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.736]  - attr(*, "resolved")= logi FALSE
[08:25:49.736]  - attr(*, "total_size")= num 366
[08:25:49.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.736]  - attr(*, "already-done")= logi TRUE
[08:25:49.741] - copied ‘...future.FUN’ to environment
[08:25:49.741] - copied ‘MoreArgs’ to environment
[08:25:49.741] - copied ‘...future.elements_ii’ to environment
[08:25:49.741] - copied ‘...future.seeds_ii’ to environment
[08:25:49.741] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.741] assign_globals() ... done
[08:25:49.741] requestCore(): workers = 2
[08:25:49.744] MulticoreFuture started
[08:25:49.744] - Launch lazy future ... done
[08:25:49.745] run() for ‘MulticoreFuture’ ... done
[08:25:49.745] plan(): Setting new future strategy stack:
[08:25:49.745] Created future:
[08:25:49.745] List of future strategies:
[08:25:49.745] 1. sequential:
[08:25:49.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.745]    - tweaked: FALSE
[08:25:49.745]    - call: NULL
[08:25:49.746] plan(): nbrOfWorkers() = 1
[08:25:49.748] plan(): Setting new future strategy stack:
[08:25:49.748] List of future strategies:
[08:25:49.748] 1. multicore:
[08:25:49.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.748]    - tweaked: FALSE
[08:25:49.748]    - call: plan(strategy)
[08:25:49.752] plan(): nbrOfWorkers() = 2
[08:25:49.745] MulticoreFuture:
[08:25:49.745] Label: ‘future_mapply-1’
[08:25:49.745] Expression:
[08:25:49.745] {
[08:25:49.745]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.745]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.745]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.745]         on.exit(options(oopts), add = TRUE)
[08:25:49.745]     }
[08:25:49.745]     {
[08:25:49.745]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.745]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.745]         do.call(mapply, args = args)
[08:25:49.745]     }
[08:25:49.745] }
[08:25:49.745] Lazy evaluation: FALSE
[08:25:49.745] Asynchronous evaluation: TRUE
[08:25:49.745] Local evaluation: TRUE
[08:25:49.745] Environment: R_GlobalEnv
[08:25:49.745] Capture standard output: TRUE
[08:25:49.745] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.745] Globals: 5 objects totaling 366 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.745] Packages: <none>
[08:25:49.745] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.745] Resolved: TRUE
[08:25:49.745] Value: <not collected>
[08:25:49.745] Conditions captured: <none>
[08:25:49.745] Early signaling: FALSE
[08:25:49.745] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.745] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.753] Chunk #1 of 1 ... DONE
[08:25:49.753] Launching 1 futures (chunks) ... DONE
[08:25:49.753] Resolving 1 futures (chunks) ...
[08:25:49.754] resolve() on list ...
[08:25:49.754]  recursive: 0
[08:25:49.754]  length: 1
[08:25:49.754] 
[08:25:49.754] Future #1
[08:25:49.755] result() for MulticoreFuture ...
[08:25:49.756] result() for MulticoreFuture ...
[08:25:49.756] result() for MulticoreFuture ... done
[08:25:49.756] result() for MulticoreFuture ... done
[08:25:49.756] result() for MulticoreFuture ...
[08:25:49.756] result() for MulticoreFuture ... done
[08:25:49.756] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:49.757] - nx: 1
[08:25:49.757] - relay: TRUE
[08:25:49.757] - stdout: TRUE
[08:25:49.757] - signal: TRUE
[08:25:49.757] - resignal: FALSE
[08:25:49.757] - force: TRUE
[08:25:49.758] - relayed: [n=1] FALSE
[08:25:49.758] - queued futures: [n=1] FALSE
[08:25:49.758]  - until=1
[08:25:49.758]  - relaying element #1
[08:25:49.758] result() for MulticoreFuture ...
[08:25:49.758] result() for MulticoreFuture ... done
[08:25:49.758] result() for MulticoreFuture ...
[08:25:49.759] result() for MulticoreFuture ... done
[08:25:49.759] result() for MulticoreFuture ...
[08:25:49.759] result() for MulticoreFuture ... done
[08:25:49.759] result() for MulticoreFuture ...
[08:25:49.759] result() for MulticoreFuture ... done
[08:25:49.759] - relayed: [n=1] TRUE
[08:25:49.759] - queued futures: [n=1] TRUE
[08:25:49.759] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:49.760]  length: 0 (resolved future 1)
[08:25:49.760] Relaying remaining futures
[08:25:49.760] signalConditionsASAP(NULL, pos=0) ...
[08:25:49.760] - nx: 1
[08:25:49.760] - relay: TRUE
[08:25:49.760] - stdout: TRUE
[08:25:49.760] - signal: TRUE
[08:25:49.760] - resignal: FALSE
[08:25:49.760] - force: TRUE
[08:25:49.761] - relayed: [n=1] TRUE
[08:25:49.761] - queued futures: [n=1] TRUE
 - flush all
[08:25:49.761] - relayed: [n=1] TRUE
[08:25:49.761] - queued futures: [n=1] TRUE
[08:25:49.767] signalConditionsASAP(NULL, pos=0) ... done
[08:25:49.767] resolve() on list ... DONE
[08:25:49.768] result() for MulticoreFuture ...
[08:25:49.768] result() for MulticoreFuture ... done
[08:25:49.768] result() for MulticoreFuture ...
[08:25:49.768] result() for MulticoreFuture ... done
[08:25:49.768]  - Number of value chunks collected: 1
[08:25:49.768] Resolving 1 futures (chunks) ... DONE
[08:25:49.768] Reducing values from 1 chunks ...
[08:25:49.768]  - Number of values collected after concatenation: 1
[08:25:49.769]  - Number of values expected: 1
[08:25:49.769] Reducing values from 1 chunks ... DONE
[08:25:49.769] future_mapply() ... DONE
[08:25:49.769] future_mapply() ...
[08:25:49.771] Number of chunks: 1
[08:25:49.771] getGlobalsAndPackagesXApply() ...
[08:25:49.772]  - future.globals: TRUE
[08:25:49.772] getGlobalsAndPackages() ...
[08:25:49.772] Searching for globals...
[08:25:49.773] - globals found: [1] ‘FUN’
[08:25:49.774] Searching for globals ... DONE
[08:25:49.774] Resolving globals: FALSE
[08:25:49.774] The total size of the 1 globals is 185 bytes (185 bytes)
[08:25:49.775] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:25:49.775] - globals: [1] ‘FUN’
[08:25:49.775] 
[08:25:49.775] getGlobalsAndPackages() ... DONE
[08:25:49.775]  - globals found/used: [n=1] ‘FUN’
[08:25:49.775]  - needed namespaces: [n=0] 
[08:25:49.776] Finding globals ... DONE
[08:25:49.776] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:49.776] List of 2
[08:25:49.776]  $ ...future.FUN:function (x)  
[08:25:49.776]  $ MoreArgs     : list()
[08:25:49.776]  - attr(*, "where")=List of 2
[08:25:49.776]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:49.776]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:49.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.776]  - attr(*, "resolved")= logi FALSE
[08:25:49.776]  - attr(*, "total_size")= num NA
[08:25:49.779] Packages to be attached in all futures: [n=0] 
[08:25:49.780] getGlobalsAndPackagesXApply() ... DONE
[08:25:49.780] Number of futures (= number of chunks): 1
[08:25:49.780] Launching 1 futures (chunks) ...
[08:25:49.780] Chunk #1 of 1 ...
[08:25:49.780]  - Finding globals in '...' for chunk #1 ...
[08:25:49.780] getGlobalsAndPackages() ...
[08:25:49.780] Searching for globals...
[08:25:49.781] 
[08:25:49.781] Searching for globals ... DONE
[08:25:49.781] - globals: [0] <none>
[08:25:49.781] getGlobalsAndPackages() ... DONE
[08:25:49.781]    + additional globals found: [n=0] 
[08:25:49.781]    + additional namespaces needed: [n=0] 
[08:25:49.781]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:49.781]  - seeds: <none>
[08:25:49.782]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.782] getGlobalsAndPackages() ...
[08:25:49.782] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.782] Resolving globals: FALSE
[08:25:49.782] The total size of the 5 globals is 370 bytes (370 bytes)
[08:25:49.783] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 370 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:49.783] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.783] 
[08:25:49.783] getGlobalsAndPackages() ... DONE
[08:25:49.784] run() for ‘Future’ ...
[08:25:49.784] - state: ‘created’
[08:25:49.784] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.786] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.786]   - Field: ‘label’
[08:25:49.786]   - Field: ‘local’
[08:25:49.786]   - Field: ‘owner’
[08:25:49.786]   - Field: ‘envir’
[08:25:49.786]   - Field: ‘workers’
[08:25:49.786]   - Field: ‘packages’
[08:25:49.787]   - Field: ‘gc’
[08:25:49.787]   - Field: ‘job’
[08:25:49.787]   - Field: ‘conditions’
[08:25:49.787]   - Field: ‘expr’
[08:25:49.787]   - Field: ‘uuid’
[08:25:49.787]   - Field: ‘seed’
[08:25:49.787]   - Field: ‘version’
[08:25:49.787]   - Field: ‘result’
[08:25:49.787]   - Field: ‘asynchronous’
[08:25:49.787]   - Field: ‘calls’
[08:25:49.788]   - Field: ‘globals’
[08:25:49.788]   - Field: ‘stdout’
[08:25:49.788]   - Field: ‘earlySignal’
[08:25:49.788]   - Field: ‘lazy’
[08:25:49.788]   - Field: ‘state’
[08:25:49.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.788] - Launch lazy future ...
[08:25:49.788] Packages needed by the future expression (n = 0): <none>
[08:25:49.789] Packages needed by future strategies (n = 0): <none>
[08:25:49.789] {
[08:25:49.789]     {
[08:25:49.789]         {
[08:25:49.789]             ...future.startTime <- base::Sys.time()
[08:25:49.789]             {
[08:25:49.789]                 {
[08:25:49.789]                   {
[08:25:49.789]                     {
[08:25:49.789]                       base::local({
[08:25:49.789]                         has_future <- base::requireNamespace("future", 
[08:25:49.789]                           quietly = TRUE)
[08:25:49.789]                         if (has_future) {
[08:25:49.789]                           ns <- base::getNamespace("future")
[08:25:49.789]                           version <- ns[[".package"]][["version"]]
[08:25:49.789]                           if (is.null(version)) 
[08:25:49.789]                             version <- utils::packageVersion("future")
[08:25:49.789]                         }
[08:25:49.789]                         else {
[08:25:49.789]                           version <- NULL
[08:25:49.789]                         }
[08:25:49.789]                         if (!has_future || version < "1.8.0") {
[08:25:49.789]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.789]                             "", base::R.version$version.string), 
[08:25:49.789]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.789]                               "release", "version")], collapse = " "), 
[08:25:49.789]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.789]                             info)
[08:25:49.789]                           info <- base::paste(info, collapse = "; ")
[08:25:49.789]                           if (!has_future) {
[08:25:49.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.789]                               info)
[08:25:49.789]                           }
[08:25:49.789]                           else {
[08:25:49.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.789]                               info, version)
[08:25:49.789]                           }
[08:25:49.789]                           base::stop(msg)
[08:25:49.789]                         }
[08:25:49.789]                       })
[08:25:49.789]                     }
[08:25:49.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.789]                     base::options(mc.cores = 1L)
[08:25:49.789]                   }
[08:25:49.789]                   ...future.strategy.old <- future::plan("list")
[08:25:49.789]                   options(future.plan = NULL)
[08:25:49.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.789]                 }
[08:25:49.789]                 ...future.workdir <- getwd()
[08:25:49.789]             }
[08:25:49.789]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.789]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.789]         }
[08:25:49.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.789]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:49.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.789]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.789]             base::names(...future.oldOptions))
[08:25:49.789]     }
[08:25:49.789]     if (FALSE) {
[08:25:49.789]     }
[08:25:49.789]     else {
[08:25:49.789]         if (TRUE) {
[08:25:49.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.789]                 open = "w")
[08:25:49.789]         }
[08:25:49.789]         else {
[08:25:49.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.789]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.789]         }
[08:25:49.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.789]             base::sink(type = "output", split = FALSE)
[08:25:49.789]             base::close(...future.stdout)
[08:25:49.789]         }, add = TRUE)
[08:25:49.789]     }
[08:25:49.789]     ...future.frame <- base::sys.nframe()
[08:25:49.789]     ...future.conditions <- base::list()
[08:25:49.789]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.789]     if (FALSE) {
[08:25:49.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.789]     }
[08:25:49.789]     ...future.result <- base::tryCatch({
[08:25:49.789]         base::withCallingHandlers({
[08:25:49.789]             ...future.value <- base::withVisible(base::local({
[08:25:49.789]                 withCallingHandlers({
[08:25:49.789]                   {
[08:25:49.789]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.789]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.789]                       ...future.globals.maxSize)) {
[08:25:49.789]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.789]                       on.exit(options(oopts), add = TRUE)
[08:25:49.789]                     }
[08:25:49.789]                     {
[08:25:49.789]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.789]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.789]                         USE.NAMES = FALSE)
[08:25:49.789]                       do.call(mapply, args = args)
[08:25:49.789]                     }
[08:25:49.789]                   }
[08:25:49.789]                 }, immediateCondition = function(cond) {
[08:25:49.789]                   save_rds <- function (object, pathname, ...) 
[08:25:49.789]                   {
[08:25:49.789]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.789]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.789]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.789]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.789]                         fi_tmp[["mtime"]])
[08:25:49.789]                     }
[08:25:49.789]                     tryCatch({
[08:25:49.789]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.789]                     }, error = function(ex) {
[08:25:49.789]                       msg <- conditionMessage(ex)
[08:25:49.789]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.789]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.789]                         fi_tmp[["mtime"]], msg)
[08:25:49.789]                       ex$message <- msg
[08:25:49.789]                       stop(ex)
[08:25:49.789]                     })
[08:25:49.789]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.789]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.789]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.789]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.789]                       fi <- file.info(pathname)
[08:25:49.789]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.789]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.789]                         fi[["size"]], fi[["mtime"]])
[08:25:49.789]                       stop(msg)
[08:25:49.789]                     }
[08:25:49.789]                     invisible(pathname)
[08:25:49.789]                   }
[08:25:49.789]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.789]                     rootPath = tempdir()) 
[08:25:49.789]                   {
[08:25:49.789]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.789]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.789]                       tmpdir = path, fileext = ".rds")
[08:25:49.789]                     save_rds(obj, file)
[08:25:49.789]                   }
[08:25:49.789]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.789]                   {
[08:25:49.789]                     inherits <- base::inherits
[08:25:49.789]                     invokeRestart <- base::invokeRestart
[08:25:49.789]                     is.null <- base::is.null
[08:25:49.789]                     muffled <- FALSE
[08:25:49.789]                     if (inherits(cond, "message")) {
[08:25:49.789]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.789]                       if (muffled) 
[08:25:49.789]                         invokeRestart("muffleMessage")
[08:25:49.789]                     }
[08:25:49.789]                     else if (inherits(cond, "warning")) {
[08:25:49.789]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.789]                       if (muffled) 
[08:25:49.789]                         invokeRestart("muffleWarning")
[08:25:49.789]                     }
[08:25:49.789]                     else if (inherits(cond, "condition")) {
[08:25:49.789]                       if (!is.null(pattern)) {
[08:25:49.789]                         computeRestarts <- base::computeRestarts
[08:25:49.789]                         grepl <- base::grepl
[08:25:49.789]                         restarts <- computeRestarts(cond)
[08:25:49.789]                         for (restart in restarts) {
[08:25:49.789]                           name <- restart$name
[08:25:49.789]                           if (is.null(name)) 
[08:25:49.789]                             next
[08:25:49.789]                           if (!grepl(pattern, name)) 
[08:25:49.789]                             next
[08:25:49.789]                           invokeRestart(restart)
[08:25:49.789]                           muffled <- TRUE
[08:25:49.789]                           break
[08:25:49.789]                         }
[08:25:49.789]                       }
[08:25:49.789]                     }
[08:25:49.789]                     invisible(muffled)
[08:25:49.789]                   }
[08:25:49.789]                   muffleCondition(cond)
[08:25:49.789]                 })
[08:25:49.789]             }))
[08:25:49.789]             future::FutureResult(value = ...future.value$value, 
[08:25:49.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.789]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.789]                     ...future.globalenv.names))
[08:25:49.789]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.789]         }, condition = base::local({
[08:25:49.789]             c <- base::c
[08:25:49.789]             inherits <- base::inherits
[08:25:49.789]             invokeRestart <- base::invokeRestart
[08:25:49.789]             length <- base::length
[08:25:49.789]             list <- base::list
[08:25:49.789]             seq.int <- base::seq.int
[08:25:49.789]             signalCondition <- base::signalCondition
[08:25:49.789]             sys.calls <- base::sys.calls
[08:25:49.789]             `[[` <- base::`[[`
[08:25:49.789]             `+` <- base::`+`
[08:25:49.789]             `<<-` <- base::`<<-`
[08:25:49.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.789]                   3L)]
[08:25:49.789]             }
[08:25:49.789]             function(cond) {
[08:25:49.789]                 is_error <- inherits(cond, "error")
[08:25:49.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.789]                   NULL)
[08:25:49.789]                 if (is_error) {
[08:25:49.789]                   sessionInformation <- function() {
[08:25:49.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.789]                       search = base::search(), system = base::Sys.info())
[08:25:49.789]                   }
[08:25:49.789]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.789]                     cond$call), session = sessionInformation(), 
[08:25:49.789]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.789]                   signalCondition(cond)
[08:25:49.789]                 }
[08:25:49.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.789]                 "immediateCondition"))) {
[08:25:49.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.789]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.789]                   if (TRUE && !signal) {
[08:25:49.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.789]                     {
[08:25:49.789]                       inherits <- base::inherits
[08:25:49.789]                       invokeRestart <- base::invokeRestart
[08:25:49.789]                       is.null <- base::is.null
[08:25:49.789]                       muffled <- FALSE
[08:25:49.789]                       if (inherits(cond, "message")) {
[08:25:49.789]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.789]                         if (muffled) 
[08:25:49.789]                           invokeRestart("muffleMessage")
[08:25:49.789]                       }
[08:25:49.789]                       else if (inherits(cond, "warning")) {
[08:25:49.789]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.789]                         if (muffled) 
[08:25:49.789]                           invokeRestart("muffleWarning")
[08:25:49.789]                       }
[08:25:49.789]                       else if (inherits(cond, "condition")) {
[08:25:49.789]                         if (!is.null(pattern)) {
[08:25:49.789]                           computeRestarts <- base::computeRestarts
[08:25:49.789]                           grepl <- base::grepl
[08:25:49.789]                           restarts <- computeRestarts(cond)
[08:25:49.789]                           for (restart in restarts) {
[08:25:49.789]                             name <- restart$name
[08:25:49.789]                             if (is.null(name)) 
[08:25:49.789]                               next
[08:25:49.789]                             if (!grepl(pattern, name)) 
[08:25:49.789]                               next
[08:25:49.789]                             invokeRestart(restart)
[08:25:49.789]                             muffled <- TRUE
[08:25:49.789]                             break
[08:25:49.789]                           }
[08:25:49.789]                         }
[08:25:49.789]                       }
[08:25:49.789]                       invisible(muffled)
[08:25:49.789]                     }
[08:25:49.789]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.789]                   }
[08:25:49.789]                 }
[08:25:49.789]                 else {
[08:25:49.789]                   if (TRUE) {
[08:25:49.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.789]                     {
[08:25:49.789]                       inherits <- base::inherits
[08:25:49.789]                       invokeRestart <- base::invokeRestart
[08:25:49.789]                       is.null <- base::is.null
[08:25:49.789]                       muffled <- FALSE
[08:25:49.789]                       if (inherits(cond, "message")) {
[08:25:49.789]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.789]                         if (muffled) 
[08:25:49.789]                           invokeRestart("muffleMessage")
[08:25:49.789]                       }
[08:25:49.789]                       else if (inherits(cond, "warning")) {
[08:25:49.789]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.789]                         if (muffled) 
[08:25:49.789]                           invokeRestart("muffleWarning")
[08:25:49.789]                       }
[08:25:49.789]                       else if (inherits(cond, "condition")) {
[08:25:49.789]                         if (!is.null(pattern)) {
[08:25:49.789]                           computeRestarts <- base::computeRestarts
[08:25:49.789]                           grepl <- base::grepl
[08:25:49.789]                           restarts <- computeRestarts(cond)
[08:25:49.789]                           for (restart in restarts) {
[08:25:49.789]                             name <- restart$name
[08:25:49.789]                             if (is.null(name)) 
[08:25:49.789]                               next
[08:25:49.789]                             if (!grepl(pattern, name)) 
[08:25:49.789]                               next
[08:25:49.789]                             invokeRestart(restart)
[08:25:49.789]                             muffled <- TRUE
[08:25:49.789]                             break
[08:25:49.789]                           }
[08:25:49.789]                         }
[08:25:49.789]                       }
[08:25:49.789]                       invisible(muffled)
[08:25:49.789]                     }
[08:25:49.789]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.789]                   }
[08:25:49.789]                 }
[08:25:49.789]             }
[08:25:49.789]         }))
[08:25:49.789]     }, error = function(ex) {
[08:25:49.789]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.789]                 ...future.rng), started = ...future.startTime, 
[08:25:49.789]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.789]             version = "1.8"), class = "FutureResult")
[08:25:49.789]     }, finally = {
[08:25:49.789]         if (!identical(...future.workdir, getwd())) 
[08:25:49.789]             setwd(...future.workdir)
[08:25:49.789]         {
[08:25:49.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.789]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.789]             }
[08:25:49.789]             base::options(...future.oldOptions)
[08:25:49.789]             if (.Platform$OS.type == "windows") {
[08:25:49.789]                 old_names <- names(...future.oldEnvVars)
[08:25:49.789]                 envs <- base::Sys.getenv()
[08:25:49.789]                 names <- names(envs)
[08:25:49.789]                 common <- intersect(names, old_names)
[08:25:49.789]                 added <- setdiff(names, old_names)
[08:25:49.789]                 removed <- setdiff(old_names, names)
[08:25:49.789]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.789]                   envs[common]]
[08:25:49.789]                 NAMES <- toupper(changed)
[08:25:49.789]                 args <- list()
[08:25:49.789]                 for (kk in seq_along(NAMES)) {
[08:25:49.789]                   name <- changed[[kk]]
[08:25:49.789]                   NAME <- NAMES[[kk]]
[08:25:49.789]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.789]                     next
[08:25:49.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.789]                 }
[08:25:49.789]                 NAMES <- toupper(added)
[08:25:49.789]                 for (kk in seq_along(NAMES)) {
[08:25:49.789]                   name <- added[[kk]]
[08:25:49.789]                   NAME <- NAMES[[kk]]
[08:25:49.789]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.789]                     next
[08:25:49.789]                   args[[name]] <- ""
[08:25:49.789]                 }
[08:25:49.789]                 NAMES <- toupper(removed)
[08:25:49.789]                 for (kk in seq_along(NAMES)) {
[08:25:49.789]                   name <- removed[[kk]]
[08:25:49.789]                   NAME <- NAMES[[kk]]
[08:25:49.789]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.789]                     next
[08:25:49.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.789]                 }
[08:25:49.789]                 if (length(args) > 0) 
[08:25:49.789]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.789]             }
[08:25:49.789]             else {
[08:25:49.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.789]             }
[08:25:49.789]             {
[08:25:49.789]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.789]                   0L) {
[08:25:49.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.789]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.789]                   base::options(opts)
[08:25:49.789]                 }
[08:25:49.789]                 {
[08:25:49.789]                   {
[08:25:49.789]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.789]                     NULL
[08:25:49.789]                   }
[08:25:49.789]                   options(future.plan = NULL)
[08:25:49.789]                   if (is.na(NA_character_)) 
[08:25:49.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.789]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.789]                     .init = FALSE)
[08:25:49.789]                 }
[08:25:49.789]             }
[08:25:49.789]         }
[08:25:49.789]     })
[08:25:49.789]     if (TRUE) {
[08:25:49.789]         base::sink(type = "output", split = FALSE)
[08:25:49.789]         if (TRUE) {
[08:25:49.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.789]         }
[08:25:49.789]         else {
[08:25:49.789]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.789]         }
[08:25:49.789]         base::close(...future.stdout)
[08:25:49.789]         ...future.stdout <- NULL
[08:25:49.789]     }
[08:25:49.789]     ...future.result$conditions <- ...future.conditions
[08:25:49.789]     ...future.result$finished <- base::Sys.time()
[08:25:49.789]     ...future.result
[08:25:49.789] }
[08:25:49.792] assign_globals() ...
[08:25:49.792] List of 5
[08:25:49.792]  $ ...future.FUN            :function (x)  
[08:25:49.792]  $ MoreArgs                 : list()
[08:25:49.792]  $ ...future.elements_ii    :List of 1
[08:25:49.792]   ..$ :List of 1
[08:25:49.792]   .. ..$ : Date[1:1], format: "2018-06-01"
[08:25:49.792]  $ ...future.seeds_ii       : NULL
[08:25:49.792]  $ ...future.globals.maxSize: NULL
[08:25:49.792]  - attr(*, "where")=List of 5
[08:25:49.792]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.792]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.792]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.792]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.792]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.792]  - attr(*, "resolved")= logi FALSE
[08:25:49.792]  - attr(*, "total_size")= num 370
[08:25:49.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.792]  - attr(*, "already-done")= logi TRUE
[08:25:49.799] - copied ‘...future.FUN’ to environment
[08:25:49.800] - copied ‘MoreArgs’ to environment
[08:25:49.800] - copied ‘...future.elements_ii’ to environment
[08:25:49.800] - copied ‘...future.seeds_ii’ to environment
[08:25:49.800] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.800] assign_globals() ... done
[08:25:49.800] requestCore(): workers = 2
[08:25:49.803] MulticoreFuture started
[08:25:49.804] - Launch lazy future ... done
[08:25:49.805] plan(): Setting new future strategy stack:
[08:25:49.805] run() for ‘MulticoreFuture’ ... done
[08:25:49.806] Created future:
[08:25:49.805] List of future strategies:
[08:25:49.805] 1. sequential:
[08:25:49.805]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.805]    - tweaked: FALSE
[08:25:49.805]    - call: NULL
[08:25:49.807] plan(): nbrOfWorkers() = 1
[08:25:49.811] plan(): Setting new future strategy stack:
[08:25:49.811] List of future strategies:
[08:25:49.811] 1. multicore:
[08:25:49.811]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.811]    - tweaked: FALSE
[08:25:49.811]    - call: plan(strategy)
[08:25:49.816] plan(): nbrOfWorkers() = 2
[08:25:49.806] MulticoreFuture:
[08:25:49.806] Label: ‘future_.mapply-1’
[08:25:49.806] Expression:
[08:25:49.806] {
[08:25:49.806]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.806]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.806]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.806]         on.exit(options(oopts), add = TRUE)
[08:25:49.806]     }
[08:25:49.806]     {
[08:25:49.806]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.806]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.806]         do.call(mapply, args = args)
[08:25:49.806]     }
[08:25:49.806] }
[08:25:49.806] Lazy evaluation: FALSE
[08:25:49.806] Asynchronous evaluation: TRUE
[08:25:49.806] Local evaluation: TRUE
[08:25:49.806] Environment: R_GlobalEnv
[08:25:49.806] Capture standard output: TRUE
[08:25:49.806] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.806] Globals: 5 objects totaling 370 bytes (function ‘...future.FUN’ of 185 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.806] Packages: <none>
[08:25:49.806] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.806] Resolved: TRUE
[08:25:49.806] Value: <not collected>
[08:25:49.806] Conditions captured: <none>
[08:25:49.806] Early signaling: FALSE
[08:25:49.806] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.806] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.817] Chunk #1 of 1 ... DONE
[08:25:49.817] Launching 1 futures (chunks) ... DONE
[08:25:49.818] Resolving 1 futures (chunks) ...
[08:25:49.818] resolve() on list ...
[08:25:49.818]  recursive: 0
[08:25:49.818]  length: 1
[08:25:49.819] 
[08:25:49.819] Future #1
[08:25:49.819] result() for MulticoreFuture ...
[08:25:49.820] result() for MulticoreFuture ...
[08:25:49.821] result() for MulticoreFuture ... done
[08:25:49.821] result() for MulticoreFuture ... done
[08:25:49.821] result() for MulticoreFuture ...
[08:25:49.821] result() for MulticoreFuture ... done
[08:25:49.822] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:49.822] - nx: 1
[08:25:49.822] - relay: TRUE
[08:25:49.823] - stdout: TRUE
[08:25:49.823] - signal: TRUE
[08:25:49.823] - resignal: FALSE
[08:25:49.823] - force: TRUE
[08:25:49.823] - relayed: [n=1] FALSE
[08:25:49.823] - queued futures: [n=1] FALSE
[08:25:49.824]  - until=1
[08:25:49.824]  - relaying element #1
[08:25:49.824] result() for MulticoreFuture ...
[08:25:49.824] result() for MulticoreFuture ... done
[08:25:49.824] result() for MulticoreFuture ...
[08:25:49.824] result() for MulticoreFuture ... done
[08:25:49.824] result() for MulticoreFuture ...
[08:25:49.825] result() for MulticoreFuture ... done
[08:25:49.825] result() for MulticoreFuture ...
[08:25:49.825] result() for MulticoreFuture ... done
[08:25:49.825] - relayed: [n=1] TRUE
[08:25:49.825] - queued futures: [n=1] TRUE
[08:25:49.825] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:49.825]  length: 0 (resolved future 1)
[08:25:49.825] Relaying remaining futures
[08:25:49.826] signalConditionsASAP(NULL, pos=0) ...
[08:25:49.826] - nx: 1
[08:25:49.826] - relay: TRUE
[08:25:49.826] - stdout: TRUE
[08:25:49.826] - signal: TRUE
[08:25:49.826] - resignal: FALSE
[08:25:49.826] - force: TRUE
[08:25:49.826] - relayed: [n=1] TRUE
[08:25:49.826] - queued futures: [n=1] TRUE
 - flush all
[08:25:49.827] - relayed: [n=1] TRUE
[08:25:49.827] - queued futures: [n=1] TRUE
[08:25:49.827] signalConditionsASAP(NULL, pos=0) ... done
[08:25:49.827] resolve() on list ... DONE
[08:25:49.827] result() for MulticoreFuture ...
[08:25:49.827] result() for MulticoreFuture ... done
[08:25:49.827] result() for MulticoreFuture ...
[08:25:49.827] result() for MulticoreFuture ... done
[08:25:49.827]  - Number of value chunks collected: 1
[08:25:49.827] Resolving 1 futures (chunks) ... DONE
[08:25:49.828] Reducing values from 1 chunks ...
[08:25:49.828]  - Number of values collected after concatenation: 1
[08:25:49.828]  - Number of values expected: 1
[08:25:49.828] Reducing values from 1 chunks ... DONE
[08:25:49.828] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[08:25:49.828] future_mapply() ...
[08:25:49.831] Number of chunks: 2
[08:25:49.831] getGlobalsAndPackagesXApply() ...
[08:25:49.831]  - future.globals: TRUE
[08:25:49.831] getGlobalsAndPackages() ...
[08:25:49.831] Searching for globals...
[08:25:49.832] - globals found: [1] ‘FUN’
[08:25:49.832] Searching for globals ... DONE
[08:25:49.833] Resolving globals: FALSE
[08:25:49.833] The total size of the 1 globals is 326 bytes (326 bytes)
[08:25:49.833] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[08:25:49.833] - globals: [1] ‘FUN’
[08:25:49.834] 
[08:25:49.834] getGlobalsAndPackages() ... DONE
[08:25:49.834]  - globals found/used: [n=1] ‘FUN’
[08:25:49.834]  - needed namespaces: [n=0] 
[08:25:49.834] Finding globals ... DONE
[08:25:49.834] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:49.834] List of 2
[08:25:49.834]  $ ...future.FUN:function (x, y)  
[08:25:49.834]  $ MoreArgs     :List of 1
[08:25:49.834]   ..$ y: int [1:2] 3 4
[08:25:49.834]  - attr(*, "where")=List of 2
[08:25:49.834]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:49.834]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:49.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.834]  - attr(*, "resolved")= logi FALSE
[08:25:49.834]  - attr(*, "total_size")= num NA
[08:25:49.838] Packages to be attached in all futures: [n=0] 
[08:25:49.838] getGlobalsAndPackagesXApply() ... DONE
[08:25:49.838] Number of futures (= number of chunks): 2
[08:25:49.838] Launching 2 futures (chunks) ...
[08:25:49.838] Chunk #1 of 2 ...
[08:25:49.838]  - Finding globals in '...' for chunk #1 ...
[08:25:49.841] getGlobalsAndPackages() ...
[08:25:49.841] Searching for globals...
[08:25:49.842] 
[08:25:49.842] Searching for globals ... DONE
[08:25:49.842] - globals: [0] <none>
[08:25:49.842] getGlobalsAndPackages() ... DONE
[08:25:49.842]    + additional globals found: [n=0] 
[08:25:49.842]    + additional namespaces needed: [n=0] 
[08:25:49.842]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:49.843]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.843]  - seeds: <none>
[08:25:49.843]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.843] getGlobalsAndPackages() ...
[08:25:49.843] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.843] Resolving globals: FALSE
[08:25:49.844] The total size of the 5 globals is 656 bytes (656 bytes)
[08:25:49.844] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:49.844] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.845] 
[08:25:49.845] getGlobalsAndPackages() ... DONE
[08:25:49.845] run() for ‘Future’ ...
[08:25:49.845] - state: ‘created’
[08:25:49.845] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.847] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.848]   - Field: ‘label’
[08:25:49.848]   - Field: ‘local’
[08:25:49.848]   - Field: ‘owner’
[08:25:49.848]   - Field: ‘envir’
[08:25:49.848]   - Field: ‘workers’
[08:25:49.848]   - Field: ‘packages’
[08:25:49.848]   - Field: ‘gc’
[08:25:49.848]   - Field: ‘job’
[08:25:49.849]   - Field: ‘conditions’
[08:25:49.849]   - Field: ‘expr’
[08:25:49.849]   - Field: ‘uuid’
[08:25:49.849]   - Field: ‘seed’
[08:25:49.849]   - Field: ‘version’
[08:25:49.849]   - Field: ‘result’
[08:25:49.849]   - Field: ‘asynchronous’
[08:25:49.849]   - Field: ‘calls’
[08:25:49.850]   - Field: ‘globals’
[08:25:49.850]   - Field: ‘stdout’
[08:25:49.850]   - Field: ‘earlySignal’
[08:25:49.850]   - Field: ‘lazy’
[08:25:49.850]   - Field: ‘state’
[08:25:49.850] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.850] - Launch lazy future ...
[08:25:49.850] Packages needed by the future expression (n = 0): <none>
[08:25:49.851] Packages needed by future strategies (n = 0): <none>
[08:25:49.851] {
[08:25:49.851]     {
[08:25:49.851]         {
[08:25:49.851]             ...future.startTime <- base::Sys.time()
[08:25:49.851]             {
[08:25:49.851]                 {
[08:25:49.851]                   {
[08:25:49.851]                     {
[08:25:49.851]                       base::local({
[08:25:49.851]                         has_future <- base::requireNamespace("future", 
[08:25:49.851]                           quietly = TRUE)
[08:25:49.851]                         if (has_future) {
[08:25:49.851]                           ns <- base::getNamespace("future")
[08:25:49.851]                           version <- ns[[".package"]][["version"]]
[08:25:49.851]                           if (is.null(version)) 
[08:25:49.851]                             version <- utils::packageVersion("future")
[08:25:49.851]                         }
[08:25:49.851]                         else {
[08:25:49.851]                           version <- NULL
[08:25:49.851]                         }
[08:25:49.851]                         if (!has_future || version < "1.8.0") {
[08:25:49.851]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.851]                             "", base::R.version$version.string), 
[08:25:49.851]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.851]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.851]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.851]                               "release", "version")], collapse = " "), 
[08:25:49.851]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.851]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.851]                             info)
[08:25:49.851]                           info <- base::paste(info, collapse = "; ")
[08:25:49.851]                           if (!has_future) {
[08:25:49.851]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.851]                               info)
[08:25:49.851]                           }
[08:25:49.851]                           else {
[08:25:49.851]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.851]                               info, version)
[08:25:49.851]                           }
[08:25:49.851]                           base::stop(msg)
[08:25:49.851]                         }
[08:25:49.851]                       })
[08:25:49.851]                     }
[08:25:49.851]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.851]                     base::options(mc.cores = 1L)
[08:25:49.851]                   }
[08:25:49.851]                   ...future.strategy.old <- future::plan("list")
[08:25:49.851]                   options(future.plan = NULL)
[08:25:49.851]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.851]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.851]                 }
[08:25:49.851]                 ...future.workdir <- getwd()
[08:25:49.851]             }
[08:25:49.851]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.851]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.851]         }
[08:25:49.851]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.851]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.851]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.851]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.851]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.851]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.851]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.851]             base::names(...future.oldOptions))
[08:25:49.851]     }
[08:25:49.851]     if (FALSE) {
[08:25:49.851]     }
[08:25:49.851]     else {
[08:25:49.851]         if (TRUE) {
[08:25:49.851]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.851]                 open = "w")
[08:25:49.851]         }
[08:25:49.851]         else {
[08:25:49.851]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.851]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.851]         }
[08:25:49.851]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.851]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.851]             base::sink(type = "output", split = FALSE)
[08:25:49.851]             base::close(...future.stdout)
[08:25:49.851]         }, add = TRUE)
[08:25:49.851]     }
[08:25:49.851]     ...future.frame <- base::sys.nframe()
[08:25:49.851]     ...future.conditions <- base::list()
[08:25:49.851]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.851]     if (FALSE) {
[08:25:49.851]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.851]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.851]     }
[08:25:49.851]     ...future.result <- base::tryCatch({
[08:25:49.851]         base::withCallingHandlers({
[08:25:49.851]             ...future.value <- base::withVisible(base::local({
[08:25:49.851]                 withCallingHandlers({
[08:25:49.851]                   {
[08:25:49.851]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.851]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.851]                       ...future.globals.maxSize)) {
[08:25:49.851]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.851]                       on.exit(options(oopts), add = TRUE)
[08:25:49.851]                     }
[08:25:49.851]                     {
[08:25:49.851]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.851]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.851]                         USE.NAMES = FALSE)
[08:25:49.851]                       do.call(mapply, args = args)
[08:25:49.851]                     }
[08:25:49.851]                   }
[08:25:49.851]                 }, immediateCondition = function(cond) {
[08:25:49.851]                   save_rds <- function (object, pathname, ...) 
[08:25:49.851]                   {
[08:25:49.851]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.851]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.851]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.851]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.851]                         fi_tmp[["mtime"]])
[08:25:49.851]                     }
[08:25:49.851]                     tryCatch({
[08:25:49.851]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.851]                     }, error = function(ex) {
[08:25:49.851]                       msg <- conditionMessage(ex)
[08:25:49.851]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.851]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.851]                         fi_tmp[["mtime"]], msg)
[08:25:49.851]                       ex$message <- msg
[08:25:49.851]                       stop(ex)
[08:25:49.851]                     })
[08:25:49.851]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.851]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.851]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.851]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.851]                       fi <- file.info(pathname)
[08:25:49.851]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.851]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.851]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.851]                         fi[["size"]], fi[["mtime"]])
[08:25:49.851]                       stop(msg)
[08:25:49.851]                     }
[08:25:49.851]                     invisible(pathname)
[08:25:49.851]                   }
[08:25:49.851]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.851]                     rootPath = tempdir()) 
[08:25:49.851]                   {
[08:25:49.851]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.851]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.851]                       tmpdir = path, fileext = ".rds")
[08:25:49.851]                     save_rds(obj, file)
[08:25:49.851]                   }
[08:25:49.851]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.851]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.851]                   {
[08:25:49.851]                     inherits <- base::inherits
[08:25:49.851]                     invokeRestart <- base::invokeRestart
[08:25:49.851]                     is.null <- base::is.null
[08:25:49.851]                     muffled <- FALSE
[08:25:49.851]                     if (inherits(cond, "message")) {
[08:25:49.851]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.851]                       if (muffled) 
[08:25:49.851]                         invokeRestart("muffleMessage")
[08:25:49.851]                     }
[08:25:49.851]                     else if (inherits(cond, "warning")) {
[08:25:49.851]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.851]                       if (muffled) 
[08:25:49.851]                         invokeRestart("muffleWarning")
[08:25:49.851]                     }
[08:25:49.851]                     else if (inherits(cond, "condition")) {
[08:25:49.851]                       if (!is.null(pattern)) {
[08:25:49.851]                         computeRestarts <- base::computeRestarts
[08:25:49.851]                         grepl <- base::grepl
[08:25:49.851]                         restarts <- computeRestarts(cond)
[08:25:49.851]                         for (restart in restarts) {
[08:25:49.851]                           name <- restart$name
[08:25:49.851]                           if (is.null(name)) 
[08:25:49.851]                             next
[08:25:49.851]                           if (!grepl(pattern, name)) 
[08:25:49.851]                             next
[08:25:49.851]                           invokeRestart(restart)
[08:25:49.851]                           muffled <- TRUE
[08:25:49.851]                           break
[08:25:49.851]                         }
[08:25:49.851]                       }
[08:25:49.851]                     }
[08:25:49.851]                     invisible(muffled)
[08:25:49.851]                   }
[08:25:49.851]                   muffleCondition(cond)
[08:25:49.851]                 })
[08:25:49.851]             }))
[08:25:49.851]             future::FutureResult(value = ...future.value$value, 
[08:25:49.851]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.851]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.851]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.851]                     ...future.globalenv.names))
[08:25:49.851]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.851]         }, condition = base::local({
[08:25:49.851]             c <- base::c
[08:25:49.851]             inherits <- base::inherits
[08:25:49.851]             invokeRestart <- base::invokeRestart
[08:25:49.851]             length <- base::length
[08:25:49.851]             list <- base::list
[08:25:49.851]             seq.int <- base::seq.int
[08:25:49.851]             signalCondition <- base::signalCondition
[08:25:49.851]             sys.calls <- base::sys.calls
[08:25:49.851]             `[[` <- base::`[[`
[08:25:49.851]             `+` <- base::`+`
[08:25:49.851]             `<<-` <- base::`<<-`
[08:25:49.851]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.851]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.851]                   3L)]
[08:25:49.851]             }
[08:25:49.851]             function(cond) {
[08:25:49.851]                 is_error <- inherits(cond, "error")
[08:25:49.851]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.851]                   NULL)
[08:25:49.851]                 if (is_error) {
[08:25:49.851]                   sessionInformation <- function() {
[08:25:49.851]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.851]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.851]                       search = base::search(), system = base::Sys.info())
[08:25:49.851]                   }
[08:25:49.851]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.851]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.851]                     cond$call), session = sessionInformation(), 
[08:25:49.851]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.851]                   signalCondition(cond)
[08:25:49.851]                 }
[08:25:49.851]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.851]                 "immediateCondition"))) {
[08:25:49.851]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.851]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.851]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.851]                   if (TRUE && !signal) {
[08:25:49.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.851]                     {
[08:25:49.851]                       inherits <- base::inherits
[08:25:49.851]                       invokeRestart <- base::invokeRestart
[08:25:49.851]                       is.null <- base::is.null
[08:25:49.851]                       muffled <- FALSE
[08:25:49.851]                       if (inherits(cond, "message")) {
[08:25:49.851]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.851]                         if (muffled) 
[08:25:49.851]                           invokeRestart("muffleMessage")
[08:25:49.851]                       }
[08:25:49.851]                       else if (inherits(cond, "warning")) {
[08:25:49.851]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.851]                         if (muffled) 
[08:25:49.851]                           invokeRestart("muffleWarning")
[08:25:49.851]                       }
[08:25:49.851]                       else if (inherits(cond, "condition")) {
[08:25:49.851]                         if (!is.null(pattern)) {
[08:25:49.851]                           computeRestarts <- base::computeRestarts
[08:25:49.851]                           grepl <- base::grepl
[08:25:49.851]                           restarts <- computeRestarts(cond)
[08:25:49.851]                           for (restart in restarts) {
[08:25:49.851]                             name <- restart$name
[08:25:49.851]                             if (is.null(name)) 
[08:25:49.851]                               next
[08:25:49.851]                             if (!grepl(pattern, name)) 
[08:25:49.851]                               next
[08:25:49.851]                             invokeRestart(restart)
[08:25:49.851]                             muffled <- TRUE
[08:25:49.851]                             break
[08:25:49.851]                           }
[08:25:49.851]                         }
[08:25:49.851]                       }
[08:25:49.851]                       invisible(muffled)
[08:25:49.851]                     }
[08:25:49.851]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.851]                   }
[08:25:49.851]                 }
[08:25:49.851]                 else {
[08:25:49.851]                   if (TRUE) {
[08:25:49.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.851]                     {
[08:25:49.851]                       inherits <- base::inherits
[08:25:49.851]                       invokeRestart <- base::invokeRestart
[08:25:49.851]                       is.null <- base::is.null
[08:25:49.851]                       muffled <- FALSE
[08:25:49.851]                       if (inherits(cond, "message")) {
[08:25:49.851]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.851]                         if (muffled) 
[08:25:49.851]                           invokeRestart("muffleMessage")
[08:25:49.851]                       }
[08:25:49.851]                       else if (inherits(cond, "warning")) {
[08:25:49.851]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.851]                         if (muffled) 
[08:25:49.851]                           invokeRestart("muffleWarning")
[08:25:49.851]                       }
[08:25:49.851]                       else if (inherits(cond, "condition")) {
[08:25:49.851]                         if (!is.null(pattern)) {
[08:25:49.851]                           computeRestarts <- base::computeRestarts
[08:25:49.851]                           grepl <- base::grepl
[08:25:49.851]                           restarts <- computeRestarts(cond)
[08:25:49.851]                           for (restart in restarts) {
[08:25:49.851]                             name <- restart$name
[08:25:49.851]                             if (is.null(name)) 
[08:25:49.851]                               next
[08:25:49.851]                             if (!grepl(pattern, name)) 
[08:25:49.851]                               next
[08:25:49.851]                             invokeRestart(restart)
[08:25:49.851]                             muffled <- TRUE
[08:25:49.851]                             break
[08:25:49.851]                           }
[08:25:49.851]                         }
[08:25:49.851]                       }
[08:25:49.851]                       invisible(muffled)
[08:25:49.851]                     }
[08:25:49.851]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.851]                   }
[08:25:49.851]                 }
[08:25:49.851]             }
[08:25:49.851]         }))
[08:25:49.851]     }, error = function(ex) {
[08:25:49.851]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.851]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.851]                 ...future.rng), started = ...future.startTime, 
[08:25:49.851]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.851]             version = "1.8"), class = "FutureResult")
[08:25:49.851]     }, finally = {
[08:25:49.851]         if (!identical(...future.workdir, getwd())) 
[08:25:49.851]             setwd(...future.workdir)
[08:25:49.851]         {
[08:25:49.851]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.851]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.851]             }
[08:25:49.851]             base::options(...future.oldOptions)
[08:25:49.851]             if (.Platform$OS.type == "windows") {
[08:25:49.851]                 old_names <- names(...future.oldEnvVars)
[08:25:49.851]                 envs <- base::Sys.getenv()
[08:25:49.851]                 names <- names(envs)
[08:25:49.851]                 common <- intersect(names, old_names)
[08:25:49.851]                 added <- setdiff(names, old_names)
[08:25:49.851]                 removed <- setdiff(old_names, names)
[08:25:49.851]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.851]                   envs[common]]
[08:25:49.851]                 NAMES <- toupper(changed)
[08:25:49.851]                 args <- list()
[08:25:49.851]                 for (kk in seq_along(NAMES)) {
[08:25:49.851]                   name <- changed[[kk]]
[08:25:49.851]                   NAME <- NAMES[[kk]]
[08:25:49.851]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.851]                     next
[08:25:49.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.851]                 }
[08:25:49.851]                 NAMES <- toupper(added)
[08:25:49.851]                 for (kk in seq_along(NAMES)) {
[08:25:49.851]                   name <- added[[kk]]
[08:25:49.851]                   NAME <- NAMES[[kk]]
[08:25:49.851]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.851]                     next
[08:25:49.851]                   args[[name]] <- ""
[08:25:49.851]                 }
[08:25:49.851]                 NAMES <- toupper(removed)
[08:25:49.851]                 for (kk in seq_along(NAMES)) {
[08:25:49.851]                   name <- removed[[kk]]
[08:25:49.851]                   NAME <- NAMES[[kk]]
[08:25:49.851]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.851]                     next
[08:25:49.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.851]                 }
[08:25:49.851]                 if (length(args) > 0) 
[08:25:49.851]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.851]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.851]             }
[08:25:49.851]             else {
[08:25:49.851]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.851]             }
[08:25:49.851]             {
[08:25:49.851]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.851]                   0L) {
[08:25:49.851]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.851]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.851]                   base::options(opts)
[08:25:49.851]                 }
[08:25:49.851]                 {
[08:25:49.851]                   {
[08:25:49.851]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.851]                     NULL
[08:25:49.851]                   }
[08:25:49.851]                   options(future.plan = NULL)
[08:25:49.851]                   if (is.na(NA_character_)) 
[08:25:49.851]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.851]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.851]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.851]                     .init = FALSE)
[08:25:49.851]                 }
[08:25:49.851]             }
[08:25:49.851]         }
[08:25:49.851]     })
[08:25:49.851]     if (TRUE) {
[08:25:49.851]         base::sink(type = "output", split = FALSE)
[08:25:49.851]         if (TRUE) {
[08:25:49.851]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.851]         }
[08:25:49.851]         else {
[08:25:49.851]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.851]         }
[08:25:49.851]         base::close(...future.stdout)
[08:25:49.851]         ...future.stdout <- NULL
[08:25:49.851]     }
[08:25:49.851]     ...future.result$conditions <- ...future.conditions
[08:25:49.851]     ...future.result$finished <- base::Sys.time()
[08:25:49.851]     ...future.result
[08:25:49.851] }
[08:25:49.854] assign_globals() ...
[08:25:49.854] List of 5
[08:25:49.854]  $ ...future.FUN            :function (x, y)  
[08:25:49.854]  $ MoreArgs                 :List of 1
[08:25:49.854]   ..$ y: int [1:2] 3 4
[08:25:49.854]  $ ...future.elements_ii    :List of 1
[08:25:49.854]   ..$ x:List of 1
[08:25:49.854]   .. ..$ : int 1
[08:25:49.854]  $ ...future.seeds_ii       : NULL
[08:25:49.854]  $ ...future.globals.maxSize: NULL
[08:25:49.854]  - attr(*, "where")=List of 5
[08:25:49.854]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.854]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.854]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.854]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.854]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.854]  - attr(*, "resolved")= logi FALSE
[08:25:49.854]  - attr(*, "total_size")= num 656
[08:25:49.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.854]  - attr(*, "already-done")= logi TRUE
[08:25:49.859] - reassign environment for ‘...future.FUN’
[08:25:49.859] - copied ‘...future.FUN’ to environment
[08:25:49.859] - copied ‘MoreArgs’ to environment
[08:25:49.859] - copied ‘...future.elements_ii’ to environment
[08:25:49.859] - copied ‘...future.seeds_ii’ to environment
[08:25:49.859] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.860] assign_globals() ... done
[08:25:49.860] requestCore(): workers = 2
[08:25:49.862] MulticoreFuture started
[08:25:49.863] - Launch lazy future ... done
[08:25:49.863] plan(): Setting new future strategy stack:
[08:25:49.863] run() for ‘MulticoreFuture’ ... done
[08:25:49.864] Created future:
[08:25:49.863] List of future strategies:
[08:25:49.863] 1. sequential:
[08:25:49.863]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.863]    - tweaked: FALSE
[08:25:49.863]    - call: NULL
[08:25:49.865] plan(): nbrOfWorkers() = 1
[08:25:49.868] plan(): Setting new future strategy stack:
[08:25:49.868] List of future strategies:
[08:25:49.868] 1. multicore:
[08:25:49.868]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.868]    - tweaked: FALSE
[08:25:49.868]    - call: plan(strategy)
[08:25:49.873] plan(): nbrOfWorkers() = 2
[08:25:49.864] MulticoreFuture:
[08:25:49.864] Label: ‘future_mapply-1’
[08:25:49.864] Expression:
[08:25:49.864] {
[08:25:49.864]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.864]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.864]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.864]         on.exit(options(oopts), add = TRUE)
[08:25:49.864]     }
[08:25:49.864]     {
[08:25:49.864]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.864]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.864]         do.call(mapply, args = args)
[08:25:49.864]     }
[08:25:49.864] }
[08:25:49.864] Lazy evaluation: FALSE
[08:25:49.864] Asynchronous evaluation: TRUE
[08:25:49.864] Local evaluation: TRUE
[08:25:49.864] Environment: R_GlobalEnv
[08:25:49.864] Capture standard output: TRUE
[08:25:49.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.864] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.864] Packages: <none>
[08:25:49.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.864] Resolved: TRUE
[08:25:49.864] Value: <not collected>
[08:25:49.864] Conditions captured: <none>
[08:25:49.864] Early signaling: FALSE
[08:25:49.864] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.864] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.874] Chunk #1 of 2 ... DONE
[08:25:49.874] Chunk #2 of 2 ...
[08:25:49.875]  - Finding globals in '...' for chunk #2 ...
[08:25:49.875] getGlobalsAndPackages() ...
[08:25:49.875] Searching for globals...
[08:25:49.876] 
[08:25:49.876] Searching for globals ... DONE
[08:25:49.876] - globals: [0] <none>
[08:25:49.876] getGlobalsAndPackages() ... DONE
[08:25:49.876]    + additional globals found: [n=0] 
[08:25:49.876]    + additional namespaces needed: [n=0] 
[08:25:49.877]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:49.877]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.877]  - seeds: <none>
[08:25:49.877]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.877] getGlobalsAndPackages() ...
[08:25:49.877] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.878] Resolving globals: FALSE
[08:25:49.879] The total size of the 5 globals is 656 bytes (656 bytes)
[08:25:49.880] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:49.880] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.880] 
[08:25:49.880] getGlobalsAndPackages() ... DONE
[08:25:49.881] run() for ‘Future’ ...
[08:25:49.881] - state: ‘created’
[08:25:49.887] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.893] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.893] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.894]   - Field: ‘label’
[08:25:49.894]   - Field: ‘local’
[08:25:49.894]   - Field: ‘owner’
[08:25:49.895]   - Field: ‘envir’
[08:25:49.895]   - Field: ‘workers’
[08:25:49.895]   - Field: ‘packages’
[08:25:49.896]   - Field: ‘gc’
[08:25:49.896]   - Field: ‘job’
[08:25:49.896]   - Field: ‘conditions’
[08:25:49.896]   - Field: ‘expr’
[08:25:49.897]   - Field: ‘uuid’
[08:25:49.897]   - Field: ‘seed’
[08:25:49.897]   - Field: ‘version’
[08:25:49.898]   - Field: ‘result’
[08:25:49.898]   - Field: ‘asynchronous’
[08:25:49.898]   - Field: ‘calls’
[08:25:49.898]   - Field: ‘globals’
[08:25:49.898]   - Field: ‘stdout’
[08:25:49.899]   - Field: ‘earlySignal’
[08:25:49.899]   - Field: ‘lazy’
[08:25:49.899]   - Field: ‘state’
[08:25:49.899] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.900] - Launch lazy future ...
[08:25:49.900] Packages needed by the future expression (n = 0): <none>
[08:25:49.901] Packages needed by future strategies (n = 0): <none>
[08:25:49.902] {
[08:25:49.902]     {
[08:25:49.902]         {
[08:25:49.902]             ...future.startTime <- base::Sys.time()
[08:25:49.902]             {
[08:25:49.902]                 {
[08:25:49.902]                   {
[08:25:49.902]                     {
[08:25:49.902]                       base::local({
[08:25:49.902]                         has_future <- base::requireNamespace("future", 
[08:25:49.902]                           quietly = TRUE)
[08:25:49.902]                         if (has_future) {
[08:25:49.902]                           ns <- base::getNamespace("future")
[08:25:49.902]                           version <- ns[[".package"]][["version"]]
[08:25:49.902]                           if (is.null(version)) 
[08:25:49.902]                             version <- utils::packageVersion("future")
[08:25:49.902]                         }
[08:25:49.902]                         else {
[08:25:49.902]                           version <- NULL
[08:25:49.902]                         }
[08:25:49.902]                         if (!has_future || version < "1.8.0") {
[08:25:49.902]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.902]                             "", base::R.version$version.string), 
[08:25:49.902]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.902]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.902]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.902]                               "release", "version")], collapse = " "), 
[08:25:49.902]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.902]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.902]                             info)
[08:25:49.902]                           info <- base::paste(info, collapse = "; ")
[08:25:49.902]                           if (!has_future) {
[08:25:49.902]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.902]                               info)
[08:25:49.902]                           }
[08:25:49.902]                           else {
[08:25:49.902]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.902]                               info, version)
[08:25:49.902]                           }
[08:25:49.902]                           base::stop(msg)
[08:25:49.902]                         }
[08:25:49.902]                       })
[08:25:49.902]                     }
[08:25:49.902]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.902]                     base::options(mc.cores = 1L)
[08:25:49.902]                   }
[08:25:49.902]                   ...future.strategy.old <- future::plan("list")
[08:25:49.902]                   options(future.plan = NULL)
[08:25:49.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.902]                 }
[08:25:49.902]                 ...future.workdir <- getwd()
[08:25:49.902]             }
[08:25:49.902]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.902]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.902]         }
[08:25:49.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.902]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.902]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.902]             base::names(...future.oldOptions))
[08:25:49.902]     }
[08:25:49.902]     if (FALSE) {
[08:25:49.902]     }
[08:25:49.902]     else {
[08:25:49.902]         if (TRUE) {
[08:25:49.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.902]                 open = "w")
[08:25:49.902]         }
[08:25:49.902]         else {
[08:25:49.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.902]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.902]         }
[08:25:49.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.902]             base::sink(type = "output", split = FALSE)
[08:25:49.902]             base::close(...future.stdout)
[08:25:49.902]         }, add = TRUE)
[08:25:49.902]     }
[08:25:49.902]     ...future.frame <- base::sys.nframe()
[08:25:49.902]     ...future.conditions <- base::list()
[08:25:49.902]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.902]     if (FALSE) {
[08:25:49.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.902]     }
[08:25:49.902]     ...future.result <- base::tryCatch({
[08:25:49.902]         base::withCallingHandlers({
[08:25:49.902]             ...future.value <- base::withVisible(base::local({
[08:25:49.902]                 withCallingHandlers({
[08:25:49.902]                   {
[08:25:49.902]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.902]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.902]                       ...future.globals.maxSize)) {
[08:25:49.902]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.902]                       on.exit(options(oopts), add = TRUE)
[08:25:49.902]                     }
[08:25:49.902]                     {
[08:25:49.902]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.902]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.902]                         USE.NAMES = FALSE)
[08:25:49.902]                       do.call(mapply, args = args)
[08:25:49.902]                     }
[08:25:49.902]                   }
[08:25:49.902]                 }, immediateCondition = function(cond) {
[08:25:49.902]                   save_rds <- function (object, pathname, ...) 
[08:25:49.902]                   {
[08:25:49.902]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.902]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.902]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.902]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.902]                         fi_tmp[["mtime"]])
[08:25:49.902]                     }
[08:25:49.902]                     tryCatch({
[08:25:49.902]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.902]                     }, error = function(ex) {
[08:25:49.902]                       msg <- conditionMessage(ex)
[08:25:49.902]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.902]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.902]                         fi_tmp[["mtime"]], msg)
[08:25:49.902]                       ex$message <- msg
[08:25:49.902]                       stop(ex)
[08:25:49.902]                     })
[08:25:49.902]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.902]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.902]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.902]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.902]                       fi <- file.info(pathname)
[08:25:49.902]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.902]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.902]                         fi[["size"]], fi[["mtime"]])
[08:25:49.902]                       stop(msg)
[08:25:49.902]                     }
[08:25:49.902]                     invisible(pathname)
[08:25:49.902]                   }
[08:25:49.902]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.902]                     rootPath = tempdir()) 
[08:25:49.902]                   {
[08:25:49.902]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.902]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.902]                       tmpdir = path, fileext = ".rds")
[08:25:49.902]                     save_rds(obj, file)
[08:25:49.902]                   }
[08:25:49.902]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.902]                   {
[08:25:49.902]                     inherits <- base::inherits
[08:25:49.902]                     invokeRestart <- base::invokeRestart
[08:25:49.902]                     is.null <- base::is.null
[08:25:49.902]                     muffled <- FALSE
[08:25:49.902]                     if (inherits(cond, "message")) {
[08:25:49.902]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.902]                       if (muffled) 
[08:25:49.902]                         invokeRestart("muffleMessage")
[08:25:49.902]                     }
[08:25:49.902]                     else if (inherits(cond, "warning")) {
[08:25:49.902]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.902]                       if (muffled) 
[08:25:49.902]                         invokeRestart("muffleWarning")
[08:25:49.902]                     }
[08:25:49.902]                     else if (inherits(cond, "condition")) {
[08:25:49.902]                       if (!is.null(pattern)) {
[08:25:49.902]                         computeRestarts <- base::computeRestarts
[08:25:49.902]                         grepl <- base::grepl
[08:25:49.902]                         restarts <- computeRestarts(cond)
[08:25:49.902]                         for (restart in restarts) {
[08:25:49.902]                           name <- restart$name
[08:25:49.902]                           if (is.null(name)) 
[08:25:49.902]                             next
[08:25:49.902]                           if (!grepl(pattern, name)) 
[08:25:49.902]                             next
[08:25:49.902]                           invokeRestart(restart)
[08:25:49.902]                           muffled <- TRUE
[08:25:49.902]                           break
[08:25:49.902]                         }
[08:25:49.902]                       }
[08:25:49.902]                     }
[08:25:49.902]                     invisible(muffled)
[08:25:49.902]                   }
[08:25:49.902]                   muffleCondition(cond)
[08:25:49.902]                 })
[08:25:49.902]             }))
[08:25:49.902]             future::FutureResult(value = ...future.value$value, 
[08:25:49.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.902]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.902]                     ...future.globalenv.names))
[08:25:49.902]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.902]         }, condition = base::local({
[08:25:49.902]             c <- base::c
[08:25:49.902]             inherits <- base::inherits
[08:25:49.902]             invokeRestart <- base::invokeRestart
[08:25:49.902]             length <- base::length
[08:25:49.902]             list <- base::list
[08:25:49.902]             seq.int <- base::seq.int
[08:25:49.902]             signalCondition <- base::signalCondition
[08:25:49.902]             sys.calls <- base::sys.calls
[08:25:49.902]             `[[` <- base::`[[`
[08:25:49.902]             `+` <- base::`+`
[08:25:49.902]             `<<-` <- base::`<<-`
[08:25:49.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.902]                   3L)]
[08:25:49.902]             }
[08:25:49.902]             function(cond) {
[08:25:49.902]                 is_error <- inherits(cond, "error")
[08:25:49.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.902]                   NULL)
[08:25:49.902]                 if (is_error) {
[08:25:49.902]                   sessionInformation <- function() {
[08:25:49.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.902]                       search = base::search(), system = base::Sys.info())
[08:25:49.902]                   }
[08:25:49.902]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.902]                     cond$call), session = sessionInformation(), 
[08:25:49.902]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.902]                   signalCondition(cond)
[08:25:49.902]                 }
[08:25:49.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.902]                 "immediateCondition"))) {
[08:25:49.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.902]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.902]                   if (TRUE && !signal) {
[08:25:49.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.902]                     {
[08:25:49.902]                       inherits <- base::inherits
[08:25:49.902]                       invokeRestart <- base::invokeRestart
[08:25:49.902]                       is.null <- base::is.null
[08:25:49.902]                       muffled <- FALSE
[08:25:49.902]                       if (inherits(cond, "message")) {
[08:25:49.902]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.902]                         if (muffled) 
[08:25:49.902]                           invokeRestart("muffleMessage")
[08:25:49.902]                       }
[08:25:49.902]                       else if (inherits(cond, "warning")) {
[08:25:49.902]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.902]                         if (muffled) 
[08:25:49.902]                           invokeRestart("muffleWarning")
[08:25:49.902]                       }
[08:25:49.902]                       else if (inherits(cond, "condition")) {
[08:25:49.902]                         if (!is.null(pattern)) {
[08:25:49.902]                           computeRestarts <- base::computeRestarts
[08:25:49.902]                           grepl <- base::grepl
[08:25:49.902]                           restarts <- computeRestarts(cond)
[08:25:49.902]                           for (restart in restarts) {
[08:25:49.902]                             name <- restart$name
[08:25:49.902]                             if (is.null(name)) 
[08:25:49.902]                               next
[08:25:49.902]                             if (!grepl(pattern, name)) 
[08:25:49.902]                               next
[08:25:49.902]                             invokeRestart(restart)
[08:25:49.902]                             muffled <- TRUE
[08:25:49.902]                             break
[08:25:49.902]                           }
[08:25:49.902]                         }
[08:25:49.902]                       }
[08:25:49.902]                       invisible(muffled)
[08:25:49.902]                     }
[08:25:49.902]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.902]                   }
[08:25:49.902]                 }
[08:25:49.902]                 else {
[08:25:49.902]                   if (TRUE) {
[08:25:49.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.902]                     {
[08:25:49.902]                       inherits <- base::inherits
[08:25:49.902]                       invokeRestart <- base::invokeRestart
[08:25:49.902]                       is.null <- base::is.null
[08:25:49.902]                       muffled <- FALSE
[08:25:49.902]                       if (inherits(cond, "message")) {
[08:25:49.902]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.902]                         if (muffled) 
[08:25:49.902]                           invokeRestart("muffleMessage")
[08:25:49.902]                       }
[08:25:49.902]                       else if (inherits(cond, "warning")) {
[08:25:49.902]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.902]                         if (muffled) 
[08:25:49.902]                           invokeRestart("muffleWarning")
[08:25:49.902]                       }
[08:25:49.902]                       else if (inherits(cond, "condition")) {
[08:25:49.902]                         if (!is.null(pattern)) {
[08:25:49.902]                           computeRestarts <- base::computeRestarts
[08:25:49.902]                           grepl <- base::grepl
[08:25:49.902]                           restarts <- computeRestarts(cond)
[08:25:49.902]                           for (restart in restarts) {
[08:25:49.902]                             name <- restart$name
[08:25:49.902]                             if (is.null(name)) 
[08:25:49.902]                               next
[08:25:49.902]                             if (!grepl(pattern, name)) 
[08:25:49.902]                               next
[08:25:49.902]                             invokeRestart(restart)
[08:25:49.902]                             muffled <- TRUE
[08:25:49.902]                             break
[08:25:49.902]                           }
[08:25:49.902]                         }
[08:25:49.902]                       }
[08:25:49.902]                       invisible(muffled)
[08:25:49.902]                     }
[08:25:49.902]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.902]                   }
[08:25:49.902]                 }
[08:25:49.902]             }
[08:25:49.902]         }))
[08:25:49.902]     }, error = function(ex) {
[08:25:49.902]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.902]                 ...future.rng), started = ...future.startTime, 
[08:25:49.902]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.902]             version = "1.8"), class = "FutureResult")
[08:25:49.902]     }, finally = {
[08:25:49.902]         if (!identical(...future.workdir, getwd())) 
[08:25:49.902]             setwd(...future.workdir)
[08:25:49.902]         {
[08:25:49.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.902]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.902]             }
[08:25:49.902]             base::options(...future.oldOptions)
[08:25:49.902]             if (.Platform$OS.type == "windows") {
[08:25:49.902]                 old_names <- names(...future.oldEnvVars)
[08:25:49.902]                 envs <- base::Sys.getenv()
[08:25:49.902]                 names <- names(envs)
[08:25:49.902]                 common <- intersect(names, old_names)
[08:25:49.902]                 added <- setdiff(names, old_names)
[08:25:49.902]                 removed <- setdiff(old_names, names)
[08:25:49.902]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.902]                   envs[common]]
[08:25:49.902]                 NAMES <- toupper(changed)
[08:25:49.902]                 args <- list()
[08:25:49.902]                 for (kk in seq_along(NAMES)) {
[08:25:49.902]                   name <- changed[[kk]]
[08:25:49.902]                   NAME <- NAMES[[kk]]
[08:25:49.902]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.902]                     next
[08:25:49.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.902]                 }
[08:25:49.902]                 NAMES <- toupper(added)
[08:25:49.902]                 for (kk in seq_along(NAMES)) {
[08:25:49.902]                   name <- added[[kk]]
[08:25:49.902]                   NAME <- NAMES[[kk]]
[08:25:49.902]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.902]                     next
[08:25:49.902]                   args[[name]] <- ""
[08:25:49.902]                 }
[08:25:49.902]                 NAMES <- toupper(removed)
[08:25:49.902]                 for (kk in seq_along(NAMES)) {
[08:25:49.902]                   name <- removed[[kk]]
[08:25:49.902]                   NAME <- NAMES[[kk]]
[08:25:49.902]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.902]                     next
[08:25:49.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.902]                 }
[08:25:49.902]                 if (length(args) > 0) 
[08:25:49.902]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.902]             }
[08:25:49.902]             else {
[08:25:49.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.902]             }
[08:25:49.902]             {
[08:25:49.902]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.902]                   0L) {
[08:25:49.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.902]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.902]                   base::options(opts)
[08:25:49.902]                 }
[08:25:49.902]                 {
[08:25:49.902]                   {
[08:25:49.902]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.902]                     NULL
[08:25:49.902]                   }
[08:25:49.902]                   options(future.plan = NULL)
[08:25:49.902]                   if (is.na(NA_character_)) 
[08:25:49.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.902]                     .init = FALSE)
[08:25:49.902]                 }
[08:25:49.902]             }
[08:25:49.902]         }
[08:25:49.902]     })
[08:25:49.902]     if (TRUE) {
[08:25:49.902]         base::sink(type = "output", split = FALSE)
[08:25:49.902]         if (TRUE) {
[08:25:49.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.902]         }
[08:25:49.902]         else {
[08:25:49.902]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.902]         }
[08:25:49.902]         base::close(...future.stdout)
[08:25:49.902]         ...future.stdout <- NULL
[08:25:49.902]     }
[08:25:49.902]     ...future.result$conditions <- ...future.conditions
[08:25:49.902]     ...future.result$finished <- base::Sys.time()
[08:25:49.902]     ...future.result
[08:25:49.902] }
[08:25:49.905] assign_globals() ...
[08:25:49.906] List of 5
[08:25:49.906]  $ ...future.FUN            :function (x, y)  
[08:25:49.906]  $ MoreArgs                 :List of 1
[08:25:49.906]   ..$ y: int [1:2] 3 4
[08:25:49.906]  $ ...future.elements_ii    :List of 1
[08:25:49.906]   ..$ x:List of 1
[08:25:49.906]   .. ..$ : int 2
[08:25:49.906]  $ ...future.seeds_ii       : NULL
[08:25:49.906]  $ ...future.globals.maxSize: NULL
[08:25:49.906]  - attr(*, "where")=List of 5
[08:25:49.906]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.906]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.906]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.906]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.906]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.906]  - attr(*, "resolved")= logi FALSE
[08:25:49.906]  - attr(*, "total_size")= num 656
[08:25:49.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.906]  - attr(*, "already-done")= logi TRUE
[08:25:49.915] - reassign environment for ‘...future.FUN’
[08:25:49.916] - copied ‘...future.FUN’ to environment
[08:25:49.916] - copied ‘MoreArgs’ to environment
[08:25:49.916] - copied ‘...future.elements_ii’ to environment
[08:25:49.916] - copied ‘...future.seeds_ii’ to environment
[08:25:49.916] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.916] assign_globals() ... done
[08:25:49.916] requestCore(): workers = 2
[08:25:49.919] MulticoreFuture started
[08:25:49.920] - Launch lazy future ... done
[08:25:49.920] run() for ‘MulticoreFuture’ ... done
[08:25:49.920] plan(): Setting new future strategy stack:
[08:25:49.920] Created future:
[08:25:49.920] List of future strategies:
[08:25:49.920] 1. sequential:
[08:25:49.920]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.920]    - tweaked: FALSE
[08:25:49.920]    - call: NULL
[08:25:49.921] plan(): nbrOfWorkers() = 1
[08:25:49.924] plan(): Setting new future strategy stack:
[08:25:49.924] List of future strategies:
[08:25:49.924] 1. multicore:
[08:25:49.924]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.924]    - tweaked: FALSE
[08:25:49.924]    - call: plan(strategy)
[08:25:49.927] plan(): nbrOfWorkers() = 2
[08:25:49.921] MulticoreFuture:
[08:25:49.921] Label: ‘future_mapply-2’
[08:25:49.921] Expression:
[08:25:49.921] {
[08:25:49.921]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.921]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.921]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.921]         on.exit(options(oopts), add = TRUE)
[08:25:49.921]     }
[08:25:49.921]     {
[08:25:49.921]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:49.921]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.921]         do.call(mapply, args = args)
[08:25:49.921]     }
[08:25:49.921] }
[08:25:49.921] Lazy evaluation: FALSE
[08:25:49.921] Asynchronous evaluation: TRUE
[08:25:49.921] Local evaluation: TRUE
[08:25:49.921] Environment: R_GlobalEnv
[08:25:49.921] Capture standard output: TRUE
[08:25:49.921] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.921] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.921] Packages: <none>
[08:25:49.921] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:49.921] Resolved: TRUE
[08:25:49.921] Value: <not collected>
[08:25:49.921] Conditions captured: <none>
[08:25:49.921] Early signaling: FALSE
[08:25:49.921] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.921] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.928] Chunk #2 of 2 ... DONE
[08:25:49.928] Launching 2 futures (chunks) ... DONE
[08:25:49.929] Resolving 2 futures (chunks) ...
[08:25:49.929] resolve() on list ...
[08:25:49.929]  recursive: 0
[08:25:49.929]  length: 2
[08:25:49.929] 
[08:25:49.930] Future #1
[08:25:49.930] result() for MulticoreFuture ...
[08:25:49.931] result() for MulticoreFuture ...
[08:25:49.931] result() for MulticoreFuture ... done
[08:25:49.931] result() for MulticoreFuture ... done
[08:25:49.931] result() for MulticoreFuture ...
[08:25:49.932] result() for MulticoreFuture ... done
[08:25:49.932] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:49.932] - nx: 2
[08:25:49.932] - relay: TRUE
[08:25:49.932] - stdout: TRUE
[08:25:49.933] - signal: TRUE
[08:25:49.933] - resignal: FALSE
[08:25:49.933] - force: TRUE
[08:25:49.933] - relayed: [n=2] FALSE, FALSE
[08:25:49.933] - queued futures: [n=2] FALSE, FALSE
[08:25:49.934]  - until=1
[08:25:49.934]  - relaying element #1
[08:25:49.934] result() for MulticoreFuture ...
[08:25:49.934] result() for MulticoreFuture ... done
[08:25:49.934] result() for MulticoreFuture ...
[08:25:49.935] result() for MulticoreFuture ... done
[08:25:49.935] result() for MulticoreFuture ...
[08:25:49.935] result() for MulticoreFuture ... done
[08:25:49.935] result() for MulticoreFuture ...
[08:25:49.935] result() for MulticoreFuture ... done
[08:25:49.935] - relayed: [n=2] TRUE, FALSE
[08:25:49.936] - queued futures: [n=2] TRUE, FALSE
[08:25:49.936] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:49.936]  length: 1 (resolved future 1)
[08:25:49.936] Future #2
[08:25:49.937] result() for MulticoreFuture ...
[08:25:49.937] result() for MulticoreFuture ...
[08:25:49.937] result() for MulticoreFuture ... done
[08:25:49.938] result() for MulticoreFuture ... done
[08:25:49.938] result() for MulticoreFuture ...
[08:25:49.938] result() for MulticoreFuture ... done
[08:25:49.938] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:49.938] - nx: 2
[08:25:49.938] - relay: TRUE
[08:25:49.939] - stdout: TRUE
[08:25:49.939] - signal: TRUE
[08:25:49.939] - resignal: FALSE
[08:25:49.939] - force: TRUE
[08:25:49.939] - relayed: [n=2] TRUE, FALSE
[08:25:49.939] - queued futures: [n=2] TRUE, FALSE
[08:25:49.939]  - until=2
[08:25:49.939]  - relaying element #2
[08:25:49.940] result() for MulticoreFuture ...
[08:25:49.943] result() for MulticoreFuture ... done
[08:25:49.943] result() for MulticoreFuture ...
[08:25:49.943] result() for MulticoreFuture ... done
[08:25:49.943] result() for MulticoreFuture ...
[08:25:49.944] result() for MulticoreFuture ... done
[08:25:49.944] result() for MulticoreFuture ...
[08:25:49.944] result() for MulticoreFuture ... done
[08:25:49.944] - relayed: [n=2] TRUE, TRUE
[08:25:49.944] - queued futures: [n=2] TRUE, TRUE
[08:25:49.944] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:49.945]  length: 0 (resolved future 2)
[08:25:49.945] Relaying remaining futures
[08:25:49.945] signalConditionsASAP(NULL, pos=0) ...
[08:25:49.945] - nx: 2
[08:25:49.945] - relay: TRUE
[08:25:49.945] - stdout: TRUE
[08:25:49.946] - signal: TRUE
[08:25:49.946] - resignal: FALSE
[08:25:49.946] - force: TRUE
[08:25:49.946] - relayed: [n=2] TRUE, TRUE
[08:25:49.946] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:49.946] - relayed: [n=2] TRUE, TRUE
[08:25:49.947] - queued futures: [n=2] TRUE, TRUE
[08:25:49.947] signalConditionsASAP(NULL, pos=0) ... done
[08:25:49.947] resolve() on list ... DONE
[08:25:49.947] result() for MulticoreFuture ...
[08:25:49.947] result() for MulticoreFuture ... done
[08:25:49.947] result() for MulticoreFuture ...
[08:25:49.947] result() for MulticoreFuture ... done
[08:25:49.948] result() for MulticoreFuture ...
[08:25:49.948] result() for MulticoreFuture ... done
[08:25:49.948] result() for MulticoreFuture ...
[08:25:49.948] result() for MulticoreFuture ... done
[08:25:49.948]  - Number of value chunks collected: 2
[08:25:49.948] Resolving 2 futures (chunks) ... DONE
[08:25:49.948] Reducing values from 2 chunks ...
[08:25:49.949]  - Number of values collected after concatenation: 2
[08:25:49.949]  - Number of values expected: 2
[08:25:49.949] Reducing values from 2 chunks ... DONE
[08:25:49.949] future_mapply() ... DONE
[08:25:49.949] future_mapply() ...
[08:25:49.949] Generating random seeds ...
[08:25:49.950] Generating random seed streams for 2 elements ...
[08:25:49.950] Generating random seed streams for 2 elements ... DONE
[08:25:49.950] Generating random seeds ... DONE
[08:25:49.950] Will set RNG state on exit: 10407, 2029980239, 1558418872, -1439061041, -2128337370, -167161828, -1889642093
[08:25:49.953] Number of chunks: 2
[08:25:49.953] getGlobalsAndPackagesXApply() ...
[08:25:49.953]  - future.globals: TRUE
[08:25:49.953] getGlobalsAndPackages() ...
[08:25:49.953] Searching for globals...
[08:25:49.955] - globals found: [1] ‘FUN’
[08:25:49.955] Searching for globals ... DONE
[08:25:49.955] Resolving globals: FALSE
[08:25:49.955] The total size of the 1 globals is 326 bytes (326 bytes)
[08:25:49.956] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[08:25:49.956] - globals: [1] ‘FUN’
[08:25:49.956] 
[08:25:49.956] getGlobalsAndPackages() ... DONE
[08:25:49.956]  - globals found/used: [n=1] ‘FUN’
[08:25:49.956]  - needed namespaces: [n=0] 
[08:25:49.957] Finding globals ... DONE
[08:25:49.957] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:49.957] List of 2
[08:25:49.957]  $ ...future.FUN:function (x, y)  
[08:25:49.957]  $ MoreArgs     :List of 1
[08:25:49.957]   ..$ y: int [1:2] 3 4
[08:25:49.957]  - attr(*, "where")=List of 2
[08:25:49.957]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:49.957]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:49.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.957]  - attr(*, "resolved")= logi FALSE
[08:25:49.957]  - attr(*, "total_size")= num NA
[08:25:49.960] Packages to be attached in all futures: [n=0] 
[08:25:49.960] getGlobalsAndPackagesXApply() ... DONE
[08:25:49.960] Number of futures (= number of chunks): 2
[08:25:49.961] Launching 2 futures (chunks) ...
[08:25:49.961] Chunk #1 of 2 ...
[08:25:49.961]  - Finding globals in '...' for chunk #1 ...
[08:25:49.961] getGlobalsAndPackages() ...
[08:25:49.961] Searching for globals...
[08:25:49.961] 
[08:25:49.961] Searching for globals ... DONE
[08:25:49.962] - globals: [0] <none>
[08:25:49.962] getGlobalsAndPackages() ... DONE
[08:25:49.962]    + additional globals found: [n=0] 
[08:25:49.962]    + additional namespaces needed: [n=0] 
[08:25:49.962]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:49.962]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.962]  - seeds: [1] <seeds>
[08:25:49.962]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.962] getGlobalsAndPackages() ...
[08:25:49.962] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.963] Resolving globals: FALSE
[08:25:49.963] The total size of the 5 globals is 696 bytes (696 bytes)
[08:25:49.964] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:49.964] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.964] 
[08:25:49.964] getGlobalsAndPackages() ... DONE
[08:25:49.964] run() for ‘Future’ ...
[08:25:49.964] - state: ‘created’
[08:25:49.964] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:49.966] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.966] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:49.966]   - Field: ‘label’
[08:25:49.967]   - Field: ‘local’
[08:25:49.967]   - Field: ‘owner’
[08:25:49.967]   - Field: ‘envir’
[08:25:49.967]   - Field: ‘workers’
[08:25:49.967]   - Field: ‘packages’
[08:25:49.967]   - Field: ‘gc’
[08:25:49.967]   - Field: ‘job’
[08:25:49.967]   - Field: ‘conditions’
[08:25:49.967]   - Field: ‘expr’
[08:25:49.967]   - Field: ‘uuid’
[08:25:49.968]   - Field: ‘seed’
[08:25:49.968]   - Field: ‘version’
[08:25:49.968]   - Field: ‘result’
[08:25:49.968]   - Field: ‘asynchronous’
[08:25:49.968]   - Field: ‘calls’
[08:25:49.970]   - Field: ‘globals’
[08:25:49.970]   - Field: ‘stdout’
[08:25:49.971]   - Field: ‘earlySignal’
[08:25:49.971]   - Field: ‘lazy’
[08:25:49.971]   - Field: ‘state’
[08:25:49.971] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:49.971] - Launch lazy future ...
[08:25:49.971] Packages needed by the future expression (n = 0): <none>
[08:25:49.972] Packages needed by future strategies (n = 0): <none>
[08:25:49.972] {
[08:25:49.972]     {
[08:25:49.972]         {
[08:25:49.972]             ...future.startTime <- base::Sys.time()
[08:25:49.972]             {
[08:25:49.972]                 {
[08:25:49.972]                   {
[08:25:49.972]                     {
[08:25:49.972]                       base::local({
[08:25:49.972]                         has_future <- base::requireNamespace("future", 
[08:25:49.972]                           quietly = TRUE)
[08:25:49.972]                         if (has_future) {
[08:25:49.972]                           ns <- base::getNamespace("future")
[08:25:49.972]                           version <- ns[[".package"]][["version"]]
[08:25:49.972]                           if (is.null(version)) 
[08:25:49.972]                             version <- utils::packageVersion("future")
[08:25:49.972]                         }
[08:25:49.972]                         else {
[08:25:49.972]                           version <- NULL
[08:25:49.972]                         }
[08:25:49.972]                         if (!has_future || version < "1.8.0") {
[08:25:49.972]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:49.972]                             "", base::R.version$version.string), 
[08:25:49.972]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:49.972]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:49.972]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:49.972]                               "release", "version")], collapse = " "), 
[08:25:49.972]                             hostname = base::Sys.info()[["nodename"]])
[08:25:49.972]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:49.972]                             info)
[08:25:49.972]                           info <- base::paste(info, collapse = "; ")
[08:25:49.972]                           if (!has_future) {
[08:25:49.972]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:49.972]                               info)
[08:25:49.972]                           }
[08:25:49.972]                           else {
[08:25:49.972]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:49.972]                               info, version)
[08:25:49.972]                           }
[08:25:49.972]                           base::stop(msg)
[08:25:49.972]                         }
[08:25:49.972]                       })
[08:25:49.972]                     }
[08:25:49.972]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:49.972]                     base::options(mc.cores = 1L)
[08:25:49.972]                   }
[08:25:49.972]                   ...future.strategy.old <- future::plan("list")
[08:25:49.972]                   options(future.plan = NULL)
[08:25:49.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:49.972]                 }
[08:25:49.972]                 ...future.workdir <- getwd()
[08:25:49.972]             }
[08:25:49.972]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:49.972]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:49.972]         }
[08:25:49.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:49.972]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:49.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:49.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:49.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:49.972]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:49.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:49.972]             base::names(...future.oldOptions))
[08:25:49.972]     }
[08:25:49.972]     if (FALSE) {
[08:25:49.972]     }
[08:25:49.972]     else {
[08:25:49.972]         if (TRUE) {
[08:25:49.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:49.972]                 open = "w")
[08:25:49.972]         }
[08:25:49.972]         else {
[08:25:49.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:49.972]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:49.972]         }
[08:25:49.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:49.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:49.972]             base::sink(type = "output", split = FALSE)
[08:25:49.972]             base::close(...future.stdout)
[08:25:49.972]         }, add = TRUE)
[08:25:49.972]     }
[08:25:49.972]     ...future.frame <- base::sys.nframe()
[08:25:49.972]     ...future.conditions <- base::list()
[08:25:49.972]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:49.972]     if (FALSE) {
[08:25:49.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:49.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:49.972]     }
[08:25:49.972]     ...future.result <- base::tryCatch({
[08:25:49.972]         base::withCallingHandlers({
[08:25:49.972]             ...future.value <- base::withVisible(base::local({
[08:25:49.972]                 withCallingHandlers({
[08:25:49.972]                   {
[08:25:49.972]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.972]                     if (!identical(...future.globals.maxSize.org, 
[08:25:49.972]                       ...future.globals.maxSize)) {
[08:25:49.972]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.972]                       on.exit(options(oopts), add = TRUE)
[08:25:49.972]                     }
[08:25:49.972]                     {
[08:25:49.972]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:49.972]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:49.972]                           envir = globalenv(), inherits = FALSE)
[08:25:49.972]                         ...future.FUN(...)
[08:25:49.972]                       }
[08:25:49.972]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:49.972]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:49.972]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:49.972]                         USE.NAMES = FALSE)
[08:25:49.972]                       do.call(mapply, args = args)
[08:25:49.972]                     }
[08:25:49.972]                   }
[08:25:49.972]                 }, immediateCondition = function(cond) {
[08:25:49.972]                   save_rds <- function (object, pathname, ...) 
[08:25:49.972]                   {
[08:25:49.972]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:49.972]                     if (file_test("-f", pathname_tmp)) {
[08:25:49.972]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.972]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:49.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.972]                         fi_tmp[["mtime"]])
[08:25:49.972]                     }
[08:25:49.972]                     tryCatch({
[08:25:49.972]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:49.972]                     }, error = function(ex) {
[08:25:49.972]                       msg <- conditionMessage(ex)
[08:25:49.972]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.972]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:49.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.972]                         fi_tmp[["mtime"]], msg)
[08:25:49.972]                       ex$message <- msg
[08:25:49.972]                       stop(ex)
[08:25:49.972]                     })
[08:25:49.972]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:49.972]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:49.972]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:49.972]                       fi_tmp <- file.info(pathname_tmp)
[08:25:49.972]                       fi <- file.info(pathname)
[08:25:49.972]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:49.972]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:49.972]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:49.972]                         fi[["size"]], fi[["mtime"]])
[08:25:49.972]                       stop(msg)
[08:25:49.972]                     }
[08:25:49.972]                     invisible(pathname)
[08:25:49.972]                   }
[08:25:49.972]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:49.972]                     rootPath = tempdir()) 
[08:25:49.972]                   {
[08:25:49.972]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:49.972]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:49.972]                       tmpdir = path, fileext = ".rds")
[08:25:49.972]                     save_rds(obj, file)
[08:25:49.972]                   }
[08:25:49.972]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:49.972]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.972]                   {
[08:25:49.972]                     inherits <- base::inherits
[08:25:49.972]                     invokeRestart <- base::invokeRestart
[08:25:49.972]                     is.null <- base::is.null
[08:25:49.972]                     muffled <- FALSE
[08:25:49.972]                     if (inherits(cond, "message")) {
[08:25:49.972]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:49.972]                       if (muffled) 
[08:25:49.972]                         invokeRestart("muffleMessage")
[08:25:49.972]                     }
[08:25:49.972]                     else if (inherits(cond, "warning")) {
[08:25:49.972]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:49.972]                       if (muffled) 
[08:25:49.972]                         invokeRestart("muffleWarning")
[08:25:49.972]                     }
[08:25:49.972]                     else if (inherits(cond, "condition")) {
[08:25:49.972]                       if (!is.null(pattern)) {
[08:25:49.972]                         computeRestarts <- base::computeRestarts
[08:25:49.972]                         grepl <- base::grepl
[08:25:49.972]                         restarts <- computeRestarts(cond)
[08:25:49.972]                         for (restart in restarts) {
[08:25:49.972]                           name <- restart$name
[08:25:49.972]                           if (is.null(name)) 
[08:25:49.972]                             next
[08:25:49.972]                           if (!grepl(pattern, name)) 
[08:25:49.972]                             next
[08:25:49.972]                           invokeRestart(restart)
[08:25:49.972]                           muffled <- TRUE
[08:25:49.972]                           break
[08:25:49.972]                         }
[08:25:49.972]                       }
[08:25:49.972]                     }
[08:25:49.972]                     invisible(muffled)
[08:25:49.972]                   }
[08:25:49.972]                   muffleCondition(cond)
[08:25:49.972]                 })
[08:25:49.972]             }))
[08:25:49.972]             future::FutureResult(value = ...future.value$value, 
[08:25:49.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.972]                   ...future.rng), globalenv = if (FALSE) 
[08:25:49.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:49.972]                     ...future.globalenv.names))
[08:25:49.972]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:49.972]         }, condition = base::local({
[08:25:49.972]             c <- base::c
[08:25:49.972]             inherits <- base::inherits
[08:25:49.972]             invokeRestart <- base::invokeRestart
[08:25:49.972]             length <- base::length
[08:25:49.972]             list <- base::list
[08:25:49.972]             seq.int <- base::seq.int
[08:25:49.972]             signalCondition <- base::signalCondition
[08:25:49.972]             sys.calls <- base::sys.calls
[08:25:49.972]             `[[` <- base::`[[`
[08:25:49.972]             `+` <- base::`+`
[08:25:49.972]             `<<-` <- base::`<<-`
[08:25:49.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:49.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:49.972]                   3L)]
[08:25:49.972]             }
[08:25:49.972]             function(cond) {
[08:25:49.972]                 is_error <- inherits(cond, "error")
[08:25:49.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:49.972]                   NULL)
[08:25:49.972]                 if (is_error) {
[08:25:49.972]                   sessionInformation <- function() {
[08:25:49.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:49.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:49.972]                       search = base::search(), system = base::Sys.info())
[08:25:49.972]                   }
[08:25:49.972]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:49.972]                     cond$call), session = sessionInformation(), 
[08:25:49.972]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:49.972]                   signalCondition(cond)
[08:25:49.972]                 }
[08:25:49.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:49.972]                 "immediateCondition"))) {
[08:25:49.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:49.972]                   ...future.conditions[[length(...future.conditions) + 
[08:25:49.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:49.972]                   if (TRUE && !signal) {
[08:25:49.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.972]                     {
[08:25:49.972]                       inherits <- base::inherits
[08:25:49.972]                       invokeRestart <- base::invokeRestart
[08:25:49.972]                       is.null <- base::is.null
[08:25:49.972]                       muffled <- FALSE
[08:25:49.972]                       if (inherits(cond, "message")) {
[08:25:49.972]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.972]                         if (muffled) 
[08:25:49.972]                           invokeRestart("muffleMessage")
[08:25:49.972]                       }
[08:25:49.972]                       else if (inherits(cond, "warning")) {
[08:25:49.972]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.972]                         if (muffled) 
[08:25:49.972]                           invokeRestart("muffleWarning")
[08:25:49.972]                       }
[08:25:49.972]                       else if (inherits(cond, "condition")) {
[08:25:49.972]                         if (!is.null(pattern)) {
[08:25:49.972]                           computeRestarts <- base::computeRestarts
[08:25:49.972]                           grepl <- base::grepl
[08:25:49.972]                           restarts <- computeRestarts(cond)
[08:25:49.972]                           for (restart in restarts) {
[08:25:49.972]                             name <- restart$name
[08:25:49.972]                             if (is.null(name)) 
[08:25:49.972]                               next
[08:25:49.972]                             if (!grepl(pattern, name)) 
[08:25:49.972]                               next
[08:25:49.972]                             invokeRestart(restart)
[08:25:49.972]                             muffled <- TRUE
[08:25:49.972]                             break
[08:25:49.972]                           }
[08:25:49.972]                         }
[08:25:49.972]                       }
[08:25:49.972]                       invisible(muffled)
[08:25:49.972]                     }
[08:25:49.972]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.972]                   }
[08:25:49.972]                 }
[08:25:49.972]                 else {
[08:25:49.972]                   if (TRUE) {
[08:25:49.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:49.972]                     {
[08:25:49.972]                       inherits <- base::inherits
[08:25:49.972]                       invokeRestart <- base::invokeRestart
[08:25:49.972]                       is.null <- base::is.null
[08:25:49.972]                       muffled <- FALSE
[08:25:49.972]                       if (inherits(cond, "message")) {
[08:25:49.972]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:49.972]                         if (muffled) 
[08:25:49.972]                           invokeRestart("muffleMessage")
[08:25:49.972]                       }
[08:25:49.972]                       else if (inherits(cond, "warning")) {
[08:25:49.972]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:49.972]                         if (muffled) 
[08:25:49.972]                           invokeRestart("muffleWarning")
[08:25:49.972]                       }
[08:25:49.972]                       else if (inherits(cond, "condition")) {
[08:25:49.972]                         if (!is.null(pattern)) {
[08:25:49.972]                           computeRestarts <- base::computeRestarts
[08:25:49.972]                           grepl <- base::grepl
[08:25:49.972]                           restarts <- computeRestarts(cond)
[08:25:49.972]                           for (restart in restarts) {
[08:25:49.972]                             name <- restart$name
[08:25:49.972]                             if (is.null(name)) 
[08:25:49.972]                               next
[08:25:49.972]                             if (!grepl(pattern, name)) 
[08:25:49.972]                               next
[08:25:49.972]                             invokeRestart(restart)
[08:25:49.972]                             muffled <- TRUE
[08:25:49.972]                             break
[08:25:49.972]                           }
[08:25:49.972]                         }
[08:25:49.972]                       }
[08:25:49.972]                       invisible(muffled)
[08:25:49.972]                     }
[08:25:49.972]                     muffleCondition(cond, pattern = "^muffle")
[08:25:49.972]                   }
[08:25:49.972]                 }
[08:25:49.972]             }
[08:25:49.972]         }))
[08:25:49.972]     }, error = function(ex) {
[08:25:49.972]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:49.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:49.972]                 ...future.rng), started = ...future.startTime, 
[08:25:49.972]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:49.972]             version = "1.8"), class = "FutureResult")
[08:25:49.972]     }, finally = {
[08:25:49.972]         if (!identical(...future.workdir, getwd())) 
[08:25:49.972]             setwd(...future.workdir)
[08:25:49.972]         {
[08:25:49.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:49.972]                 ...future.oldOptions$nwarnings <- NULL
[08:25:49.972]             }
[08:25:49.972]             base::options(...future.oldOptions)
[08:25:49.972]             if (.Platform$OS.type == "windows") {
[08:25:49.972]                 old_names <- names(...future.oldEnvVars)
[08:25:49.972]                 envs <- base::Sys.getenv()
[08:25:49.972]                 names <- names(envs)
[08:25:49.972]                 common <- intersect(names, old_names)
[08:25:49.972]                 added <- setdiff(names, old_names)
[08:25:49.972]                 removed <- setdiff(old_names, names)
[08:25:49.972]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:49.972]                   envs[common]]
[08:25:49.972]                 NAMES <- toupper(changed)
[08:25:49.972]                 args <- list()
[08:25:49.972]                 for (kk in seq_along(NAMES)) {
[08:25:49.972]                   name <- changed[[kk]]
[08:25:49.972]                   NAME <- NAMES[[kk]]
[08:25:49.972]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.972]                     next
[08:25:49.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.972]                 }
[08:25:49.972]                 NAMES <- toupper(added)
[08:25:49.972]                 for (kk in seq_along(NAMES)) {
[08:25:49.972]                   name <- added[[kk]]
[08:25:49.972]                   NAME <- NAMES[[kk]]
[08:25:49.972]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.972]                     next
[08:25:49.972]                   args[[name]] <- ""
[08:25:49.972]                 }
[08:25:49.972]                 NAMES <- toupper(removed)
[08:25:49.972]                 for (kk in seq_along(NAMES)) {
[08:25:49.972]                   name <- removed[[kk]]
[08:25:49.972]                   NAME <- NAMES[[kk]]
[08:25:49.972]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:49.972]                     next
[08:25:49.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:49.972]                 }
[08:25:49.972]                 if (length(args) > 0) 
[08:25:49.972]                   base::do.call(base::Sys.setenv, args = args)
[08:25:49.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:49.972]             }
[08:25:49.972]             else {
[08:25:49.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:49.972]             }
[08:25:49.972]             {
[08:25:49.972]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:49.972]                   0L) {
[08:25:49.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:49.972]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:49.972]                   base::options(opts)
[08:25:49.972]                 }
[08:25:49.972]                 {
[08:25:49.972]                   {
[08:25:49.972]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:49.972]                     NULL
[08:25:49.972]                   }
[08:25:49.972]                   options(future.plan = NULL)
[08:25:49.972]                   if (is.na(NA_character_)) 
[08:25:49.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:49.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:49.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:49.972]                     .init = FALSE)
[08:25:49.972]                 }
[08:25:49.972]             }
[08:25:49.972]         }
[08:25:49.972]     })
[08:25:49.972]     if (TRUE) {
[08:25:49.972]         base::sink(type = "output", split = FALSE)
[08:25:49.972]         if (TRUE) {
[08:25:49.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:49.972]         }
[08:25:49.972]         else {
[08:25:49.972]             ...future.result["stdout"] <- base::list(NULL)
[08:25:49.972]         }
[08:25:49.972]         base::close(...future.stdout)
[08:25:49.972]         ...future.stdout <- NULL
[08:25:49.972]     }
[08:25:49.972]     ...future.result$conditions <- ...future.conditions
[08:25:49.972]     ...future.result$finished <- base::Sys.time()
[08:25:49.972]     ...future.result
[08:25:49.972] }
[08:25:49.975] assign_globals() ...
[08:25:49.975] List of 5
[08:25:49.975]  $ ...future.FUN            :function (x, y)  
[08:25:49.975]  $ MoreArgs                 :List of 1
[08:25:49.975]   ..$ y: int [1:2] 3 4
[08:25:49.975]  $ ...future.elements_ii    :List of 1
[08:25:49.975]   ..$ x:List of 1
[08:25:49.975]   .. ..$ : int 1
[08:25:49.975]  $ ...future.seeds_ii       :List of 1
[08:25:49.975]   ..$ : int [1:7] 10407 -386615959 -1295019863 866509990 -1978537995 -91425002 -2143328717
[08:25:49.975]  $ ...future.globals.maxSize: NULL
[08:25:49.975]  - attr(*, "where")=List of 5
[08:25:49.975]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:49.975]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:49.975]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:49.975]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:49.975]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:49.975]  - attr(*, "resolved")= logi FALSE
[08:25:49.975]  - attr(*, "total_size")= num 696
[08:25:49.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:49.975]  - attr(*, "already-done")= logi TRUE
[08:25:49.981] - reassign environment for ‘...future.FUN’
[08:25:49.982] - copied ‘...future.FUN’ to environment
[08:25:49.982] - copied ‘MoreArgs’ to environment
[08:25:49.982] - copied ‘...future.elements_ii’ to environment
[08:25:49.982] - copied ‘...future.seeds_ii’ to environment
[08:25:49.982] - copied ‘...future.globals.maxSize’ to environment
[08:25:49.982] assign_globals() ... done
[08:25:49.982] requestCore(): workers = 2
[08:25:49.985] MulticoreFuture started
[08:25:49.985] - Launch lazy future ... done
[08:25:49.986] run() for ‘MulticoreFuture’ ... done
[08:25:49.986] plan(): Setting new future strategy stack:
[08:25:49.986] Created future:
[08:25:49.986] List of future strategies:
[08:25:49.986] 1. sequential:
[08:25:49.986]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:49.986]    - tweaked: FALSE
[08:25:49.986]    - call: NULL
[08:25:49.987] plan(): nbrOfWorkers() = 1
[08:25:49.990] plan(): Setting new future strategy stack:
[08:25:49.990] List of future strategies:
[08:25:49.990] 1. multicore:
[08:25:49.990]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:49.990]    - tweaked: FALSE
[08:25:49.990]    - call: plan(strategy)
[08:25:49.993] plan(): nbrOfWorkers() = 2
[08:25:49.986] MulticoreFuture:
[08:25:49.986] Label: ‘future_mapply-1’
[08:25:49.986] Expression:
[08:25:49.986] {
[08:25:49.986]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:49.986]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:49.986]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:49.986]         on.exit(options(oopts), add = TRUE)
[08:25:49.986]     }
[08:25:49.986]     {
[08:25:49.986]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:49.986]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:49.986]                 inherits = FALSE)
[08:25:49.986]             ...future.FUN(...)
[08:25:49.986]         }
[08:25:49.986]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:49.986]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:49.986]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:49.986]         do.call(mapply, args = args)
[08:25:49.986]     }
[08:25:49.986] }
[08:25:49.986] Lazy evaluation: FALSE
[08:25:49.986] Asynchronous evaluation: TRUE
[08:25:49.986] Local evaluation: TRUE
[08:25:49.986] Environment: R_GlobalEnv
[08:25:49.986] Capture standard output: TRUE
[08:25:49.986] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:49.986] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:49.986] Packages: <none>
[08:25:49.986] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:49.986] Resolved: TRUE
[08:25:49.986] Value: <not collected>
[08:25:49.986] Conditions captured: <none>
[08:25:49.986] Early signaling: FALSE
[08:25:49.986] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:49.986] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:49.994] Chunk #1 of 2 ... DONE
[08:25:49.994] Chunk #2 of 2 ...
[08:25:49.995]  - Finding globals in '...' for chunk #2 ...
[08:25:49.995] getGlobalsAndPackages() ...
[08:25:49.995] Searching for globals...
[08:25:49.995] 
[08:25:49.996] Searching for globals ... DONE
[08:25:49.996] - globals: [0] <none>
[08:25:49.996] getGlobalsAndPackages() ... DONE
[08:25:49.996]    + additional globals found: [n=0] 
[08:25:49.996]    + additional namespaces needed: [n=0] 
[08:25:49.996]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:49.996]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:49.997]  - seeds: [1] <seeds>
[08:25:49.997]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.997] getGlobalsAndPackages() ...
[08:25:49.997] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.997] Resolving globals: FALSE
[08:25:49.998] The total size of the 5 globals is 696 bytes (696 bytes)
[08:25:49.999] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:49.999] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:49.999] 
[08:25:49.999] getGlobalsAndPackages() ... DONE
[08:25:50.000] run() for ‘Future’ ...
[08:25:50.000] - state: ‘created’
[08:25:50.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.003]   - Field: ‘label’
[08:25:50.003]   - Field: ‘local’
[08:25:50.004]   - Field: ‘owner’
[08:25:50.004]   - Field: ‘envir’
[08:25:50.004]   - Field: ‘workers’
[08:25:50.004]   - Field: ‘packages’
[08:25:50.004]   - Field: ‘gc’
[08:25:50.004]   - Field: ‘job’
[08:25:50.005]   - Field: ‘conditions’
[08:25:50.005]   - Field: ‘expr’
[08:25:50.005]   - Field: ‘uuid’
[08:25:50.005]   - Field: ‘seed’
[08:25:50.005]   - Field: ‘version’
[08:25:50.005]   - Field: ‘result’
[08:25:50.005]   - Field: ‘asynchronous’
[08:25:50.006]   - Field: ‘calls’
[08:25:50.006]   - Field: ‘globals’
[08:25:50.006]   - Field: ‘stdout’
[08:25:50.006]   - Field: ‘earlySignal’
[08:25:50.006]   - Field: ‘lazy’
[08:25:50.006]   - Field: ‘state’
[08:25:50.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.007] - Launch lazy future ...
[08:25:50.007] Packages needed by the future expression (n = 0): <none>
[08:25:50.007] Packages needed by future strategies (n = 0): <none>
[08:25:50.008] {
[08:25:50.008]     {
[08:25:50.008]         {
[08:25:50.008]             ...future.startTime <- base::Sys.time()
[08:25:50.008]             {
[08:25:50.008]                 {
[08:25:50.008]                   {
[08:25:50.008]                     {
[08:25:50.008]                       base::local({
[08:25:50.008]                         has_future <- base::requireNamespace("future", 
[08:25:50.008]                           quietly = TRUE)
[08:25:50.008]                         if (has_future) {
[08:25:50.008]                           ns <- base::getNamespace("future")
[08:25:50.008]                           version <- ns[[".package"]][["version"]]
[08:25:50.008]                           if (is.null(version)) 
[08:25:50.008]                             version <- utils::packageVersion("future")
[08:25:50.008]                         }
[08:25:50.008]                         else {
[08:25:50.008]                           version <- NULL
[08:25:50.008]                         }
[08:25:50.008]                         if (!has_future || version < "1.8.0") {
[08:25:50.008]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.008]                             "", base::R.version$version.string), 
[08:25:50.008]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:50.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:50.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.008]                               "release", "version")], collapse = " "), 
[08:25:50.008]                             hostname = base::Sys.info()[["nodename"]])
[08:25:50.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.008]                             info)
[08:25:50.008]                           info <- base::paste(info, collapse = "; ")
[08:25:50.008]                           if (!has_future) {
[08:25:50.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.008]                               info)
[08:25:50.008]                           }
[08:25:50.008]                           else {
[08:25:50.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.008]                               info, version)
[08:25:50.008]                           }
[08:25:50.008]                           base::stop(msg)
[08:25:50.008]                         }
[08:25:50.008]                       })
[08:25:50.008]                     }
[08:25:50.008]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.008]                     base::options(mc.cores = 1L)
[08:25:50.008]                   }
[08:25:50.008]                   ...future.strategy.old <- future::plan("list")
[08:25:50.008]                   options(future.plan = NULL)
[08:25:50.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.008]                 }
[08:25:50.008]                 ...future.workdir <- getwd()
[08:25:50.008]             }
[08:25:50.008]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.008]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.008]         }
[08:25:50.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.008]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.008]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.008]             base::names(...future.oldOptions))
[08:25:50.008]     }
[08:25:50.008]     if (FALSE) {
[08:25:50.008]     }
[08:25:50.008]     else {
[08:25:50.008]         if (TRUE) {
[08:25:50.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.008]                 open = "w")
[08:25:50.008]         }
[08:25:50.008]         else {
[08:25:50.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.008]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.008]         }
[08:25:50.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.008]             base::sink(type = "output", split = FALSE)
[08:25:50.008]             base::close(...future.stdout)
[08:25:50.008]         }, add = TRUE)
[08:25:50.008]     }
[08:25:50.008]     ...future.frame <- base::sys.nframe()
[08:25:50.008]     ...future.conditions <- base::list()
[08:25:50.008]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.008]     if (FALSE) {
[08:25:50.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.008]     }
[08:25:50.008]     ...future.result <- base::tryCatch({
[08:25:50.008]         base::withCallingHandlers({
[08:25:50.008]             ...future.value <- base::withVisible(base::local({
[08:25:50.008]                 withCallingHandlers({
[08:25:50.008]                   {
[08:25:50.008]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.008]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.008]                       ...future.globals.maxSize)) {
[08:25:50.008]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.008]                       on.exit(options(oopts), add = TRUE)
[08:25:50.008]                     }
[08:25:50.008]                     {
[08:25:50.008]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:50.008]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:50.008]                           envir = globalenv(), inherits = FALSE)
[08:25:50.008]                         ...future.FUN(...)
[08:25:50.008]                       }
[08:25:50.008]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:50.008]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:50.008]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.008]                         USE.NAMES = FALSE)
[08:25:50.008]                       do.call(mapply, args = args)
[08:25:50.008]                     }
[08:25:50.008]                   }
[08:25:50.008]                 }, immediateCondition = function(cond) {
[08:25:50.008]                   save_rds <- function (object, pathname, ...) 
[08:25:50.008]                   {
[08:25:50.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.008]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.008]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.008]                         fi_tmp[["mtime"]])
[08:25:50.008]                     }
[08:25:50.008]                     tryCatch({
[08:25:50.008]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.008]                     }, error = function(ex) {
[08:25:50.008]                       msg <- conditionMessage(ex)
[08:25:50.008]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.008]                         fi_tmp[["mtime"]], msg)
[08:25:50.008]                       ex$message <- msg
[08:25:50.008]                       stop(ex)
[08:25:50.008]                     })
[08:25:50.008]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.008]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.008]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.008]                       fi <- file.info(pathname)
[08:25:50.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.008]                         fi[["size"]], fi[["mtime"]])
[08:25:50.008]                       stop(msg)
[08:25:50.008]                     }
[08:25:50.008]                     invisible(pathname)
[08:25:50.008]                   }
[08:25:50.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.008]                     rootPath = tempdir()) 
[08:25:50.008]                   {
[08:25:50.008]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.008]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.008]                       tmpdir = path, fileext = ".rds")
[08:25:50.008]                     save_rds(obj, file)
[08:25:50.008]                   }
[08:25:50.008]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.008]                   {
[08:25:50.008]                     inherits <- base::inherits
[08:25:50.008]                     invokeRestart <- base::invokeRestart
[08:25:50.008]                     is.null <- base::is.null
[08:25:50.008]                     muffled <- FALSE
[08:25:50.008]                     if (inherits(cond, "message")) {
[08:25:50.008]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.008]                       if (muffled) 
[08:25:50.008]                         invokeRestart("muffleMessage")
[08:25:50.008]                     }
[08:25:50.008]                     else if (inherits(cond, "warning")) {
[08:25:50.008]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.008]                       if (muffled) 
[08:25:50.008]                         invokeRestart("muffleWarning")
[08:25:50.008]                     }
[08:25:50.008]                     else if (inherits(cond, "condition")) {
[08:25:50.008]                       if (!is.null(pattern)) {
[08:25:50.008]                         computeRestarts <- base::computeRestarts
[08:25:50.008]                         grepl <- base::grepl
[08:25:50.008]                         restarts <- computeRestarts(cond)
[08:25:50.008]                         for (restart in restarts) {
[08:25:50.008]                           name <- restart$name
[08:25:50.008]                           if (is.null(name)) 
[08:25:50.008]                             next
[08:25:50.008]                           if (!grepl(pattern, name)) 
[08:25:50.008]                             next
[08:25:50.008]                           invokeRestart(restart)
[08:25:50.008]                           muffled <- TRUE
[08:25:50.008]                           break
[08:25:50.008]                         }
[08:25:50.008]                       }
[08:25:50.008]                     }
[08:25:50.008]                     invisible(muffled)
[08:25:50.008]                   }
[08:25:50.008]                   muffleCondition(cond)
[08:25:50.008]                 })
[08:25:50.008]             }))
[08:25:50.008]             future::FutureResult(value = ...future.value$value, 
[08:25:50.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.008]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.008]                     ...future.globalenv.names))
[08:25:50.008]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.008]         }, condition = base::local({
[08:25:50.008]             c <- base::c
[08:25:50.008]             inherits <- base::inherits
[08:25:50.008]             invokeRestart <- base::invokeRestart
[08:25:50.008]             length <- base::length
[08:25:50.008]             list <- base::list
[08:25:50.008]             seq.int <- base::seq.int
[08:25:50.008]             signalCondition <- base::signalCondition
[08:25:50.008]             sys.calls <- base::sys.calls
[08:25:50.008]             `[[` <- base::`[[`
[08:25:50.008]             `+` <- base::`+`
[08:25:50.008]             `<<-` <- base::`<<-`
[08:25:50.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.008]                   3L)]
[08:25:50.008]             }
[08:25:50.008]             function(cond) {
[08:25:50.008]                 is_error <- inherits(cond, "error")
[08:25:50.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.008]                   NULL)
[08:25:50.008]                 if (is_error) {
[08:25:50.008]                   sessionInformation <- function() {
[08:25:50.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.008]                       search = base::search(), system = base::Sys.info())
[08:25:50.008]                   }
[08:25:50.008]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.008]                     cond$call), session = sessionInformation(), 
[08:25:50.008]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.008]                   signalCondition(cond)
[08:25:50.008]                 }
[08:25:50.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.008]                 "immediateCondition"))) {
[08:25:50.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.008]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.008]                   if (TRUE && !signal) {
[08:25:50.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.008]                     {
[08:25:50.008]                       inherits <- base::inherits
[08:25:50.008]                       invokeRestart <- base::invokeRestart
[08:25:50.008]                       is.null <- base::is.null
[08:25:50.008]                       muffled <- FALSE
[08:25:50.008]                       if (inherits(cond, "message")) {
[08:25:50.008]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.008]                         if (muffled) 
[08:25:50.008]                           invokeRestart("muffleMessage")
[08:25:50.008]                       }
[08:25:50.008]                       else if (inherits(cond, "warning")) {
[08:25:50.008]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.008]                         if (muffled) 
[08:25:50.008]                           invokeRestart("muffleWarning")
[08:25:50.008]                       }
[08:25:50.008]                       else if (inherits(cond, "condition")) {
[08:25:50.008]                         if (!is.null(pattern)) {
[08:25:50.008]                           computeRestarts <- base::computeRestarts
[08:25:50.008]                           grepl <- base::grepl
[08:25:50.008]                           restarts <- computeRestarts(cond)
[08:25:50.008]                           for (restart in restarts) {
[08:25:50.008]                             name <- restart$name
[08:25:50.008]                             if (is.null(name)) 
[08:25:50.008]                               next
[08:25:50.008]                             if (!grepl(pattern, name)) 
[08:25:50.008]                               next
[08:25:50.008]                             invokeRestart(restart)
[08:25:50.008]                             muffled <- TRUE
[08:25:50.008]                             break
[08:25:50.008]                           }
[08:25:50.008]                         }
[08:25:50.008]                       }
[08:25:50.008]                       invisible(muffled)
[08:25:50.008]                     }
[08:25:50.008]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.008]                   }
[08:25:50.008]                 }
[08:25:50.008]                 else {
[08:25:50.008]                   if (TRUE) {
[08:25:50.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.008]                     {
[08:25:50.008]                       inherits <- base::inherits
[08:25:50.008]                       invokeRestart <- base::invokeRestart
[08:25:50.008]                       is.null <- base::is.null
[08:25:50.008]                       muffled <- FALSE
[08:25:50.008]                       if (inherits(cond, "message")) {
[08:25:50.008]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.008]                         if (muffled) 
[08:25:50.008]                           invokeRestart("muffleMessage")
[08:25:50.008]                       }
[08:25:50.008]                       else if (inherits(cond, "warning")) {
[08:25:50.008]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.008]                         if (muffled) 
[08:25:50.008]                           invokeRestart("muffleWarning")
[08:25:50.008]                       }
[08:25:50.008]                       else if (inherits(cond, "condition")) {
[08:25:50.008]                         if (!is.null(pattern)) {
[08:25:50.008]                           computeRestarts <- base::computeRestarts
[08:25:50.008]                           grepl <- base::grepl
[08:25:50.008]                           restarts <- computeRestarts(cond)
[08:25:50.008]                           for (restart in restarts) {
[08:25:50.008]                             name <- restart$name
[08:25:50.008]                             if (is.null(name)) 
[08:25:50.008]                               next
[08:25:50.008]                             if (!grepl(pattern, name)) 
[08:25:50.008]                               next
[08:25:50.008]                             invokeRestart(restart)
[08:25:50.008]                             muffled <- TRUE
[08:25:50.008]                             break
[08:25:50.008]                           }
[08:25:50.008]                         }
[08:25:50.008]                       }
[08:25:50.008]                       invisible(muffled)
[08:25:50.008]                     }
[08:25:50.008]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.008]                   }
[08:25:50.008]                 }
[08:25:50.008]             }
[08:25:50.008]         }))
[08:25:50.008]     }, error = function(ex) {
[08:25:50.008]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.008]                 ...future.rng), started = ...future.startTime, 
[08:25:50.008]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.008]             version = "1.8"), class = "FutureResult")
[08:25:50.008]     }, finally = {
[08:25:50.008]         if (!identical(...future.workdir, getwd())) 
[08:25:50.008]             setwd(...future.workdir)
[08:25:50.008]         {
[08:25:50.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.008]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.008]             }
[08:25:50.008]             base::options(...future.oldOptions)
[08:25:50.008]             if (.Platform$OS.type == "windows") {
[08:25:50.008]                 old_names <- names(...future.oldEnvVars)
[08:25:50.008]                 envs <- base::Sys.getenv()
[08:25:50.008]                 names <- names(envs)
[08:25:50.008]                 common <- intersect(names, old_names)
[08:25:50.008]                 added <- setdiff(names, old_names)
[08:25:50.008]                 removed <- setdiff(old_names, names)
[08:25:50.008]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.008]                   envs[common]]
[08:25:50.008]                 NAMES <- toupper(changed)
[08:25:50.008]                 args <- list()
[08:25:50.008]                 for (kk in seq_along(NAMES)) {
[08:25:50.008]                   name <- changed[[kk]]
[08:25:50.008]                   NAME <- NAMES[[kk]]
[08:25:50.008]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.008]                     next
[08:25:50.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.008]                 }
[08:25:50.008]                 NAMES <- toupper(added)
[08:25:50.008]                 for (kk in seq_along(NAMES)) {
[08:25:50.008]                   name <- added[[kk]]
[08:25:50.008]                   NAME <- NAMES[[kk]]
[08:25:50.008]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.008]                     next
[08:25:50.008]                   args[[name]] <- ""
[08:25:50.008]                 }
[08:25:50.008]                 NAMES <- toupper(removed)
[08:25:50.008]                 for (kk in seq_along(NAMES)) {
[08:25:50.008]                   name <- removed[[kk]]
[08:25:50.008]                   NAME <- NAMES[[kk]]
[08:25:50.008]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.008]                     next
[08:25:50.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.008]                 }
[08:25:50.008]                 if (length(args) > 0) 
[08:25:50.008]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.008]             }
[08:25:50.008]             else {
[08:25:50.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.008]             }
[08:25:50.008]             {
[08:25:50.008]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.008]                   0L) {
[08:25:50.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.008]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.008]                   base::options(opts)
[08:25:50.008]                 }
[08:25:50.008]                 {
[08:25:50.008]                   {
[08:25:50.008]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.008]                     NULL
[08:25:50.008]                   }
[08:25:50.008]                   options(future.plan = NULL)
[08:25:50.008]                   if (is.na(NA_character_)) 
[08:25:50.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.008]                     .init = FALSE)
[08:25:50.008]                 }
[08:25:50.008]             }
[08:25:50.008]         }
[08:25:50.008]     })
[08:25:50.008]     if (TRUE) {
[08:25:50.008]         base::sink(type = "output", split = FALSE)
[08:25:50.008]         if (TRUE) {
[08:25:50.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.008]         }
[08:25:50.008]         else {
[08:25:50.008]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.008]         }
[08:25:50.008]         base::close(...future.stdout)
[08:25:50.008]         ...future.stdout <- NULL
[08:25:50.008]     }
[08:25:50.008]     ...future.result$conditions <- ...future.conditions
[08:25:50.008]     ...future.result$finished <- base::Sys.time()
[08:25:50.008]     ...future.result
[08:25:50.008] }
[08:25:50.012] assign_globals() ...
[08:25:50.012] List of 5
[08:25:50.012]  $ ...future.FUN            :function (x, y)  
[08:25:50.012]  $ MoreArgs                 :List of 1
[08:25:50.012]   ..$ y: int [1:2] 3 4
[08:25:50.012]  $ ...future.elements_ii    :List of 1
[08:25:50.012]   ..$ x:List of 1
[08:25:50.012]   .. ..$ : int 2
[08:25:50.012]  $ ...future.seeds_ii       :List of 1
[08:25:50.012]   ..$ : int [1:7] 10407 -1710729809 391767721 -288056269 -1907940479 -423875482 -1002944428
[08:25:50.012]  $ ...future.globals.maxSize: NULL
[08:25:50.012]  - attr(*, "where")=List of 5
[08:25:50.012]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.012]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.012]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.012]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.012]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.012]  - attr(*, "resolved")= logi FALSE
[08:25:50.012]  - attr(*, "total_size")= num 696
[08:25:50.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.012]  - attr(*, "already-done")= logi TRUE
[08:25:50.027] - reassign environment for ‘...future.FUN’
[08:25:50.027] - copied ‘...future.FUN’ to environment
[08:25:50.027] - copied ‘MoreArgs’ to environment
[08:25:50.027] - copied ‘...future.elements_ii’ to environment
[08:25:50.027] - copied ‘...future.seeds_ii’ to environment
[08:25:50.028] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.028] assign_globals() ... done
[08:25:50.028] requestCore(): workers = 2
[08:25:50.031] MulticoreFuture started
[08:25:50.031] - Launch lazy future ... done
[08:25:50.031] run() for ‘MulticoreFuture’ ... done
[08:25:50.032] Created future:
[08:25:50.032] plan(): Setting new future strategy stack:
[08:25:50.032] List of future strategies:
[08:25:50.032] 1. sequential:
[08:25:50.032]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.032]    - tweaked: FALSE
[08:25:50.032]    - call: NULL
[08:25:50.033] plan(): nbrOfWorkers() = 1
[08:25:50.036] plan(): Setting new future strategy stack:
[08:25:50.036] List of future strategies:
[08:25:50.036] 1. multicore:
[08:25:50.036]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.036]    - tweaked: FALSE
[08:25:50.036]    - call: plan(strategy)
[08:25:50.040] plan(): nbrOfWorkers() = 2
[08:25:50.032] MulticoreFuture:
[08:25:50.032] Label: ‘future_mapply-2’
[08:25:50.032] Expression:
[08:25:50.032] {
[08:25:50.032]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.032]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.032]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.032]         on.exit(options(oopts), add = TRUE)
[08:25:50.032]     }
[08:25:50.032]     {
[08:25:50.032]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:50.032]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:50.032]                 inherits = FALSE)
[08:25:50.032]             ...future.FUN(...)
[08:25:50.032]         }
[08:25:50.032]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:50.032]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:50.032]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.032]         do.call(mapply, args = args)
[08:25:50.032]     }
[08:25:50.032] }
[08:25:50.032] Lazy evaluation: FALSE
[08:25:50.032] Asynchronous evaluation: TRUE
[08:25:50.032] Local evaluation: TRUE
[08:25:50.032] Environment: R_GlobalEnv
[08:25:50.032] Capture standard output: TRUE
[08:25:50.032] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.032] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.032] Packages: <none>
[08:25:50.032] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:50.032] Resolved: TRUE
[08:25:50.032] Value: <not collected>
[08:25:50.032] Conditions captured: <none>
[08:25:50.032] Early signaling: FALSE
[08:25:50.032] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.032] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.041] Chunk #2 of 2 ... DONE
[08:25:50.042] Launching 2 futures (chunks) ... DONE
[08:25:50.042] Resolving 2 futures (chunks) ...
[08:25:50.042] resolve() on list ...
[08:25:50.042]  recursive: 0
[08:25:50.042]  length: 2
[08:25:50.042] 
[08:25:50.043] Future #1
[08:25:50.043] result() for MulticoreFuture ...
[08:25:50.044] result() for MulticoreFuture ...
[08:25:50.044] result() for MulticoreFuture ... done
[08:25:50.044] result() for MulticoreFuture ... done
[08:25:50.044] result() for MulticoreFuture ...
[08:25:50.045] result() for MulticoreFuture ... done
[08:25:50.045] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:50.045] - nx: 2
[08:25:50.045] - relay: TRUE
[08:25:50.045] - stdout: TRUE
[08:25:50.045] - signal: TRUE
[08:25:50.046] - resignal: FALSE
[08:25:50.046] - force: TRUE
[08:25:50.046] - relayed: [n=2] FALSE, FALSE
[08:25:50.046] - queued futures: [n=2] FALSE, FALSE
[08:25:50.046]  - until=1
[08:25:50.046]  - relaying element #1
[08:25:50.047] result() for MulticoreFuture ...
[08:25:50.047] result() for MulticoreFuture ... done
[08:25:50.047] result() for MulticoreFuture ...
[08:25:50.047] result() for MulticoreFuture ... done
[08:25:50.047] result() for MulticoreFuture ...
[08:25:50.047] result() for MulticoreFuture ... done
[08:25:50.047] result() for MulticoreFuture ...
[08:25:50.048] result() for MulticoreFuture ... done
[08:25:50.048] - relayed: [n=2] TRUE, FALSE
[08:25:50.048] - queued futures: [n=2] TRUE, FALSE
[08:25:50.048] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:50.048]  length: 1 (resolved future 1)
[08:25:50.049] Future #2
[08:25:50.049] result() for MulticoreFuture ...
[08:25:50.049] result() for MulticoreFuture ...
[08:25:50.050] result() for MulticoreFuture ... done
[08:25:50.050] result() for MulticoreFuture ... done
[08:25:50.050] result() for MulticoreFuture ...
[08:25:50.050] result() for MulticoreFuture ... done
[08:25:50.050] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:50.050] - nx: 2
[08:25:50.050] - relay: TRUE
[08:25:50.050] - stdout: TRUE
[08:25:50.051] - signal: TRUE
[08:25:50.051] - resignal: FALSE
[08:25:50.051] - force: TRUE
[08:25:50.051] - relayed: [n=2] TRUE, FALSE
[08:25:50.051] - queued futures: [n=2] TRUE, FALSE
[08:25:50.051]  - until=2
[08:25:50.051]  - relaying element #2
[08:25:50.051] result() for MulticoreFuture ...
[08:25:50.051] result() for MulticoreFuture ... done
[08:25:50.052] result() for MulticoreFuture ...
[08:25:50.052] result() for MulticoreFuture ... done
[08:25:50.052] result() for MulticoreFuture ...
[08:25:50.052] result() for MulticoreFuture ... done
[08:25:50.052] result() for MulticoreFuture ...
[08:25:50.052] result() for MulticoreFuture ... done
[08:25:50.052] - relayed: [n=2] TRUE, TRUE
[08:25:50.053] - queued futures: [n=2] TRUE, TRUE
[08:25:50.053] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:50.053]  length: 0 (resolved future 2)
[08:25:50.053] Relaying remaining futures
[08:25:50.053] signalConditionsASAP(NULL, pos=0) ...
[08:25:50.053] - nx: 2
[08:25:50.053] - relay: TRUE
[08:25:50.053] - stdout: TRUE
[08:25:50.053] - signal: TRUE
[08:25:50.054] - resignal: FALSE
[08:25:50.054] - force: TRUE
[08:25:50.054] - relayed: [n=2] TRUE, TRUE
[08:25:50.054] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:50.054] - relayed: [n=2] TRUE, TRUE
[08:25:50.054] - queued futures: [n=2] TRUE, TRUE
[08:25:50.054] signalConditionsASAP(NULL, pos=0) ... done
[08:25:50.054] resolve() on list ... DONE
[08:25:50.054] result() for MulticoreFuture ...
[08:25:50.055] result() for MulticoreFuture ... done
[08:25:50.055] result() for MulticoreFuture ...
[08:25:50.055] result() for MulticoreFuture ... done
[08:25:50.055] result() for MulticoreFuture ...
[08:25:50.055] result() for MulticoreFuture ... done
[08:25:50.055] result() for MulticoreFuture ...
[08:25:50.055] result() for MulticoreFuture ... done
[08:25:50.055]  - Number of value chunks collected: 2
[08:25:50.056] Resolving 2 futures (chunks) ... DONE
[08:25:50.056] Reducing values from 2 chunks ...
[08:25:50.056]  - Number of values collected after concatenation: 2
[08:25:50.056]  - Number of values expected: 2
[08:25:50.056] Reducing values from 2 chunks ... DONE
[08:25:50.056] future_mapply() ... DONE
[08:25:50.056] future_mapply() ...
[08:25:50.062] Number of chunks: 2
[08:25:50.062] getGlobalsAndPackagesXApply() ...
[08:25:50.062]  - future.globals: TRUE
[08:25:50.062] getGlobalsAndPackages() ...
[08:25:50.062] Searching for globals...
[08:25:50.064] - globals found: [1] ‘FUN’
[08:25:50.064] Searching for globals ... DONE
[08:25:50.065] Resolving globals: FALSE
[08:25:50.065] The total size of the 1 globals is 326 bytes (326 bytes)
[08:25:50.065] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[08:25:50.066] - globals: [1] ‘FUN’
[08:25:50.066] 
[08:25:50.066] getGlobalsAndPackages() ... DONE
[08:25:50.066]  - globals found/used: [n=1] ‘FUN’
[08:25:50.066]  - needed namespaces: [n=0] 
[08:25:50.066] Finding globals ... DONE
[08:25:50.067] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:50.067] List of 2
[08:25:50.067]  $ ...future.FUN:function (x, y)  
[08:25:50.067]  $ MoreArgs     :List of 1
[08:25:50.067]   ..$ y: int [1:2] 3 4
[08:25:50.067]  - attr(*, "where")=List of 2
[08:25:50.067]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:50.067]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:50.067]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.067]  - attr(*, "resolved")= logi FALSE
[08:25:50.067]  - attr(*, "total_size")= num NA
[08:25:50.071] Packages to be attached in all futures: [n=0] 
[08:25:50.071] getGlobalsAndPackagesXApply() ... DONE
[08:25:50.071] Number of futures (= number of chunks): 2
[08:25:50.071] Launching 2 futures (chunks) ...
[08:25:50.071] Chunk #1 of 2 ...
[08:25:50.072]  - Finding globals in '...' for chunk #1 ...
[08:25:50.072] getGlobalsAndPackages() ...
[08:25:50.072] Searching for globals...
[08:25:50.072] 
[08:25:50.072] Searching for globals ... DONE
[08:25:50.072] - globals: [0] <none>
[08:25:50.072] getGlobalsAndPackages() ... DONE
[08:25:50.072]    + additional globals found: [n=0] 
[08:25:50.073]    + additional namespaces needed: [n=0] 
[08:25:50.073]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:50.073]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.073]  - seeds: <none>
[08:25:50.073]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.073] getGlobalsAndPackages() ...
[08:25:50.073] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.073] Resolving globals: FALSE
[08:25:50.074] The total size of the 5 globals is 656 bytes (656 bytes)
[08:25:50.074] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:50.074] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.074] 
[08:25:50.075] getGlobalsAndPackages() ... DONE
[08:25:50.075] run() for ‘Future’ ...
[08:25:50.075] - state: ‘created’
[08:25:50.075] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.077] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.077] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.077]   - Field: ‘label’
[08:25:50.077]   - Field: ‘local’
[08:25:50.077]   - Field: ‘owner’
[08:25:50.077]   - Field: ‘envir’
[08:25:50.078]   - Field: ‘workers’
[08:25:50.078]   - Field: ‘packages’
[08:25:50.078]   - Field: ‘gc’
[08:25:50.078]   - Field: ‘job’
[08:25:50.078]   - Field: ‘conditions’
[08:25:50.078]   - Field: ‘expr’
[08:25:50.078]   - Field: ‘uuid’
[08:25:50.078]   - Field: ‘seed’
[08:25:50.078]   - Field: ‘version’
[08:25:50.078]   - Field: ‘result’
[08:25:50.078]   - Field: ‘asynchronous’
[08:25:50.079]   - Field: ‘calls’
[08:25:50.079]   - Field: ‘globals’
[08:25:50.079]   - Field: ‘stdout’
[08:25:50.079]   - Field: ‘earlySignal’
[08:25:50.079]   - Field: ‘lazy’
[08:25:50.079]   - Field: ‘state’
[08:25:50.079] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.079] - Launch lazy future ...
[08:25:50.080] Packages needed by the future expression (n = 0): <none>
[08:25:50.080] Packages needed by future strategies (n = 0): <none>
[08:25:50.080] {
[08:25:50.080]     {
[08:25:50.080]         {
[08:25:50.080]             ...future.startTime <- base::Sys.time()
[08:25:50.080]             {
[08:25:50.080]                 {
[08:25:50.080]                   {
[08:25:50.080]                     {
[08:25:50.080]                       base::local({
[08:25:50.080]                         has_future <- base::requireNamespace("future", 
[08:25:50.080]                           quietly = TRUE)
[08:25:50.080]                         if (has_future) {
[08:25:50.080]                           ns <- base::getNamespace("future")
[08:25:50.080]                           version <- ns[[".package"]][["version"]]
[08:25:50.080]                           if (is.null(version)) 
[08:25:50.080]                             version <- utils::packageVersion("future")
[08:25:50.080]                         }
[08:25:50.080]                         else {
[08:25:50.080]                           version <- NULL
[08:25:50.080]                         }
[08:25:50.080]                         if (!has_future || version < "1.8.0") {
[08:25:50.080]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.080]                             "", base::R.version$version.string), 
[08:25:50.080]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:50.080]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:50.080]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.080]                               "release", "version")], collapse = " "), 
[08:25:50.080]                             hostname = base::Sys.info()[["nodename"]])
[08:25:50.080]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.080]                             info)
[08:25:50.080]                           info <- base::paste(info, collapse = "; ")
[08:25:50.080]                           if (!has_future) {
[08:25:50.080]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.080]                               info)
[08:25:50.080]                           }
[08:25:50.080]                           else {
[08:25:50.080]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.080]                               info, version)
[08:25:50.080]                           }
[08:25:50.080]                           base::stop(msg)
[08:25:50.080]                         }
[08:25:50.080]                       })
[08:25:50.080]                     }
[08:25:50.080]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.080]                     base::options(mc.cores = 1L)
[08:25:50.080]                   }
[08:25:50.080]                   ...future.strategy.old <- future::plan("list")
[08:25:50.080]                   options(future.plan = NULL)
[08:25:50.080]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.080]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.080]                 }
[08:25:50.080]                 ...future.workdir <- getwd()
[08:25:50.080]             }
[08:25:50.080]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.080]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.080]         }
[08:25:50.080]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.080]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.080]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.080]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.080]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.080]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.080]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.080]             base::names(...future.oldOptions))
[08:25:50.080]     }
[08:25:50.080]     if (FALSE) {
[08:25:50.080]     }
[08:25:50.080]     else {
[08:25:50.080]         if (TRUE) {
[08:25:50.080]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.080]                 open = "w")
[08:25:50.080]         }
[08:25:50.080]         else {
[08:25:50.080]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.080]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.080]         }
[08:25:50.080]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.080]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.080]             base::sink(type = "output", split = FALSE)
[08:25:50.080]             base::close(...future.stdout)
[08:25:50.080]         }, add = TRUE)
[08:25:50.080]     }
[08:25:50.080]     ...future.frame <- base::sys.nframe()
[08:25:50.080]     ...future.conditions <- base::list()
[08:25:50.080]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.080]     if (FALSE) {
[08:25:50.080]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.080]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.080]     }
[08:25:50.080]     ...future.result <- base::tryCatch({
[08:25:50.080]         base::withCallingHandlers({
[08:25:50.080]             ...future.value <- base::withVisible(base::local({
[08:25:50.080]                 withCallingHandlers({
[08:25:50.080]                   {
[08:25:50.080]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.080]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.080]                       ...future.globals.maxSize)) {
[08:25:50.080]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.080]                       on.exit(options(oopts), add = TRUE)
[08:25:50.080]                     }
[08:25:50.080]                     {
[08:25:50.080]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.080]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.080]                         USE.NAMES = FALSE)
[08:25:50.080]                       do.call(mapply, args = args)
[08:25:50.080]                     }
[08:25:50.080]                   }
[08:25:50.080]                 }, immediateCondition = function(cond) {
[08:25:50.080]                   save_rds <- function (object, pathname, ...) 
[08:25:50.080]                   {
[08:25:50.080]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.080]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.080]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.080]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.080]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.080]                         fi_tmp[["mtime"]])
[08:25:50.080]                     }
[08:25:50.080]                     tryCatch({
[08:25:50.080]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.080]                     }, error = function(ex) {
[08:25:50.080]                       msg <- conditionMessage(ex)
[08:25:50.080]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.080]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.080]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.080]                         fi_tmp[["mtime"]], msg)
[08:25:50.080]                       ex$message <- msg
[08:25:50.080]                       stop(ex)
[08:25:50.080]                     })
[08:25:50.080]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.080]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.080]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.080]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.080]                       fi <- file.info(pathname)
[08:25:50.080]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.080]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.080]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.080]                         fi[["size"]], fi[["mtime"]])
[08:25:50.080]                       stop(msg)
[08:25:50.080]                     }
[08:25:50.080]                     invisible(pathname)
[08:25:50.080]                   }
[08:25:50.080]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.080]                     rootPath = tempdir()) 
[08:25:50.080]                   {
[08:25:50.080]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.080]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.080]                       tmpdir = path, fileext = ".rds")
[08:25:50.080]                     save_rds(obj, file)
[08:25:50.080]                   }
[08:25:50.080]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.080]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.080]                   {
[08:25:50.080]                     inherits <- base::inherits
[08:25:50.080]                     invokeRestart <- base::invokeRestart
[08:25:50.080]                     is.null <- base::is.null
[08:25:50.080]                     muffled <- FALSE
[08:25:50.080]                     if (inherits(cond, "message")) {
[08:25:50.080]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.080]                       if (muffled) 
[08:25:50.080]                         invokeRestart("muffleMessage")
[08:25:50.080]                     }
[08:25:50.080]                     else if (inherits(cond, "warning")) {
[08:25:50.080]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.080]                       if (muffled) 
[08:25:50.080]                         invokeRestart("muffleWarning")
[08:25:50.080]                     }
[08:25:50.080]                     else if (inherits(cond, "condition")) {
[08:25:50.080]                       if (!is.null(pattern)) {
[08:25:50.080]                         computeRestarts <- base::computeRestarts
[08:25:50.080]                         grepl <- base::grepl
[08:25:50.080]                         restarts <- computeRestarts(cond)
[08:25:50.080]                         for (restart in restarts) {
[08:25:50.080]                           name <- restart$name
[08:25:50.080]                           if (is.null(name)) 
[08:25:50.080]                             next
[08:25:50.080]                           if (!grepl(pattern, name)) 
[08:25:50.080]                             next
[08:25:50.080]                           invokeRestart(restart)
[08:25:50.080]                           muffled <- TRUE
[08:25:50.080]                           break
[08:25:50.080]                         }
[08:25:50.080]                       }
[08:25:50.080]                     }
[08:25:50.080]                     invisible(muffled)
[08:25:50.080]                   }
[08:25:50.080]                   muffleCondition(cond)
[08:25:50.080]                 })
[08:25:50.080]             }))
[08:25:50.080]             future::FutureResult(value = ...future.value$value, 
[08:25:50.080]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.080]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.080]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.080]                     ...future.globalenv.names))
[08:25:50.080]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.080]         }, condition = base::local({
[08:25:50.080]             c <- base::c
[08:25:50.080]             inherits <- base::inherits
[08:25:50.080]             invokeRestart <- base::invokeRestart
[08:25:50.080]             length <- base::length
[08:25:50.080]             list <- base::list
[08:25:50.080]             seq.int <- base::seq.int
[08:25:50.080]             signalCondition <- base::signalCondition
[08:25:50.080]             sys.calls <- base::sys.calls
[08:25:50.080]             `[[` <- base::`[[`
[08:25:50.080]             `+` <- base::`+`
[08:25:50.080]             `<<-` <- base::`<<-`
[08:25:50.080]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.080]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.080]                   3L)]
[08:25:50.080]             }
[08:25:50.080]             function(cond) {
[08:25:50.080]                 is_error <- inherits(cond, "error")
[08:25:50.080]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.080]                   NULL)
[08:25:50.080]                 if (is_error) {
[08:25:50.080]                   sessionInformation <- function() {
[08:25:50.080]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.080]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.080]                       search = base::search(), system = base::Sys.info())
[08:25:50.080]                   }
[08:25:50.080]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.080]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.080]                     cond$call), session = sessionInformation(), 
[08:25:50.080]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.080]                   signalCondition(cond)
[08:25:50.080]                 }
[08:25:50.080]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.080]                 "immediateCondition"))) {
[08:25:50.080]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.080]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.080]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.080]                   if (TRUE && !signal) {
[08:25:50.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.080]                     {
[08:25:50.080]                       inherits <- base::inherits
[08:25:50.080]                       invokeRestart <- base::invokeRestart
[08:25:50.080]                       is.null <- base::is.null
[08:25:50.080]                       muffled <- FALSE
[08:25:50.080]                       if (inherits(cond, "message")) {
[08:25:50.080]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.080]                         if (muffled) 
[08:25:50.080]                           invokeRestart("muffleMessage")
[08:25:50.080]                       }
[08:25:50.080]                       else if (inherits(cond, "warning")) {
[08:25:50.080]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.080]                         if (muffled) 
[08:25:50.080]                           invokeRestart("muffleWarning")
[08:25:50.080]                       }
[08:25:50.080]                       else if (inherits(cond, "condition")) {
[08:25:50.080]                         if (!is.null(pattern)) {
[08:25:50.080]                           computeRestarts <- base::computeRestarts
[08:25:50.080]                           grepl <- base::grepl
[08:25:50.080]                           restarts <- computeRestarts(cond)
[08:25:50.080]                           for (restart in restarts) {
[08:25:50.080]                             name <- restart$name
[08:25:50.080]                             if (is.null(name)) 
[08:25:50.080]                               next
[08:25:50.080]                             if (!grepl(pattern, name)) 
[08:25:50.080]                               next
[08:25:50.080]                             invokeRestart(restart)
[08:25:50.080]                             muffled <- TRUE
[08:25:50.080]                             break
[08:25:50.080]                           }
[08:25:50.080]                         }
[08:25:50.080]                       }
[08:25:50.080]                       invisible(muffled)
[08:25:50.080]                     }
[08:25:50.080]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.080]                   }
[08:25:50.080]                 }
[08:25:50.080]                 else {
[08:25:50.080]                   if (TRUE) {
[08:25:50.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.080]                     {
[08:25:50.080]                       inherits <- base::inherits
[08:25:50.080]                       invokeRestart <- base::invokeRestart
[08:25:50.080]                       is.null <- base::is.null
[08:25:50.080]                       muffled <- FALSE
[08:25:50.080]                       if (inherits(cond, "message")) {
[08:25:50.080]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.080]                         if (muffled) 
[08:25:50.080]                           invokeRestart("muffleMessage")
[08:25:50.080]                       }
[08:25:50.080]                       else if (inherits(cond, "warning")) {
[08:25:50.080]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.080]                         if (muffled) 
[08:25:50.080]                           invokeRestart("muffleWarning")
[08:25:50.080]                       }
[08:25:50.080]                       else if (inherits(cond, "condition")) {
[08:25:50.080]                         if (!is.null(pattern)) {
[08:25:50.080]                           computeRestarts <- base::computeRestarts
[08:25:50.080]                           grepl <- base::grepl
[08:25:50.080]                           restarts <- computeRestarts(cond)
[08:25:50.080]                           for (restart in restarts) {
[08:25:50.080]                             name <- restart$name
[08:25:50.080]                             if (is.null(name)) 
[08:25:50.080]                               next
[08:25:50.080]                             if (!grepl(pattern, name)) 
[08:25:50.080]                               next
[08:25:50.080]                             invokeRestart(restart)
[08:25:50.080]                             muffled <- TRUE
[08:25:50.080]                             break
[08:25:50.080]                           }
[08:25:50.080]                         }
[08:25:50.080]                       }
[08:25:50.080]                       invisible(muffled)
[08:25:50.080]                     }
[08:25:50.080]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.080]                   }
[08:25:50.080]                 }
[08:25:50.080]             }
[08:25:50.080]         }))
[08:25:50.080]     }, error = function(ex) {
[08:25:50.080]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.080]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.080]                 ...future.rng), started = ...future.startTime, 
[08:25:50.080]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.080]             version = "1.8"), class = "FutureResult")
[08:25:50.080]     }, finally = {
[08:25:50.080]         if (!identical(...future.workdir, getwd())) 
[08:25:50.080]             setwd(...future.workdir)
[08:25:50.080]         {
[08:25:50.080]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.080]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.080]             }
[08:25:50.080]             base::options(...future.oldOptions)
[08:25:50.080]             if (.Platform$OS.type == "windows") {
[08:25:50.080]                 old_names <- names(...future.oldEnvVars)
[08:25:50.080]                 envs <- base::Sys.getenv()
[08:25:50.080]                 names <- names(envs)
[08:25:50.080]                 common <- intersect(names, old_names)
[08:25:50.080]                 added <- setdiff(names, old_names)
[08:25:50.080]                 removed <- setdiff(old_names, names)
[08:25:50.080]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.080]                   envs[common]]
[08:25:50.080]                 NAMES <- toupper(changed)
[08:25:50.080]                 args <- list()
[08:25:50.080]                 for (kk in seq_along(NAMES)) {
[08:25:50.080]                   name <- changed[[kk]]
[08:25:50.080]                   NAME <- NAMES[[kk]]
[08:25:50.080]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.080]                     next
[08:25:50.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.080]                 }
[08:25:50.080]                 NAMES <- toupper(added)
[08:25:50.080]                 for (kk in seq_along(NAMES)) {
[08:25:50.080]                   name <- added[[kk]]
[08:25:50.080]                   NAME <- NAMES[[kk]]
[08:25:50.080]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.080]                     next
[08:25:50.080]                   args[[name]] <- ""
[08:25:50.080]                 }
[08:25:50.080]                 NAMES <- toupper(removed)
[08:25:50.080]                 for (kk in seq_along(NAMES)) {
[08:25:50.080]                   name <- removed[[kk]]
[08:25:50.080]                   NAME <- NAMES[[kk]]
[08:25:50.080]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.080]                     next
[08:25:50.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.080]                 }
[08:25:50.080]                 if (length(args) > 0) 
[08:25:50.080]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.080]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.080]             }
[08:25:50.080]             else {
[08:25:50.080]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.080]             }
[08:25:50.080]             {
[08:25:50.080]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.080]                   0L) {
[08:25:50.080]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.080]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.080]                   base::options(opts)
[08:25:50.080]                 }
[08:25:50.080]                 {
[08:25:50.080]                   {
[08:25:50.080]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.080]                     NULL
[08:25:50.080]                   }
[08:25:50.080]                   options(future.plan = NULL)
[08:25:50.080]                   if (is.na(NA_character_)) 
[08:25:50.080]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.080]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.080]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.080]                     .init = FALSE)
[08:25:50.080]                 }
[08:25:50.080]             }
[08:25:50.080]         }
[08:25:50.080]     })
[08:25:50.080]     if (TRUE) {
[08:25:50.080]         base::sink(type = "output", split = FALSE)
[08:25:50.080]         if (TRUE) {
[08:25:50.080]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.080]         }
[08:25:50.080]         else {
[08:25:50.080]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.080]         }
[08:25:50.080]         base::close(...future.stdout)
[08:25:50.080]         ...future.stdout <- NULL
[08:25:50.080]     }
[08:25:50.080]     ...future.result$conditions <- ...future.conditions
[08:25:50.080]     ...future.result$finished <- base::Sys.time()
[08:25:50.080]     ...future.result
[08:25:50.080] }
[08:25:50.083] assign_globals() ...
[08:25:50.083] List of 5
[08:25:50.083]  $ ...future.FUN            :function (x, y)  
[08:25:50.083]  $ MoreArgs                 :List of 1
[08:25:50.083]   ..$ y: int [1:2] 3 4
[08:25:50.083]  $ ...future.elements_ii    :List of 1
[08:25:50.083]   ..$ x:List of 1
[08:25:50.083]   .. ..$ : int 1
[08:25:50.083]  $ ...future.seeds_ii       : NULL
[08:25:50.083]  $ ...future.globals.maxSize: NULL
[08:25:50.083]  - attr(*, "where")=List of 5
[08:25:50.083]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.083]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.083]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.083]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.083]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.083]  - attr(*, "resolved")= logi FALSE
[08:25:50.083]  - attr(*, "total_size")= num 656
[08:25:50.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.083]  - attr(*, "already-done")= logi TRUE
[08:25:50.091] - reassign environment for ‘...future.FUN’
[08:25:50.091] - copied ‘...future.FUN’ to environment
[08:25:50.091] - copied ‘MoreArgs’ to environment
[08:25:50.091] - copied ‘...future.elements_ii’ to environment
[08:25:50.092] - copied ‘...future.seeds_ii’ to environment
[08:25:50.092] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.092] assign_globals() ... done
[08:25:50.092] requestCore(): workers = 2
[08:25:50.095] MulticoreFuture started
[08:25:50.095] - Launch lazy future ... done
[08:25:50.096] plan(): Setting new future strategy stack:
[08:25:50.096] run() for ‘MulticoreFuture’ ... done
[08:25:50.097] Created future:
[08:25:50.096] List of future strategies:
[08:25:50.096] 1. sequential:
[08:25:50.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.096]    - tweaked: FALSE
[08:25:50.096]    - call: NULL
[08:25:50.098] plan(): nbrOfWorkers() = 1
[08:25:50.101] plan(): Setting new future strategy stack:
[08:25:50.102] List of future strategies:
[08:25:50.102] 1. multicore:
[08:25:50.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.102]    - tweaked: FALSE
[08:25:50.102]    - call: plan(strategy)
[08:25:50.106] plan(): nbrOfWorkers() = 2
[08:25:50.097] MulticoreFuture:
[08:25:50.097] Label: ‘future_.mapply-1’
[08:25:50.097] Expression:
[08:25:50.097] {
[08:25:50.097]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.097]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.097]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.097]         on.exit(options(oopts), add = TRUE)
[08:25:50.097]     }
[08:25:50.097]     {
[08:25:50.097]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.097]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.097]         do.call(mapply, args = args)
[08:25:50.097]     }
[08:25:50.097] }
[08:25:50.097] Lazy evaluation: FALSE
[08:25:50.097] Asynchronous evaluation: TRUE
[08:25:50.097] Local evaluation: TRUE
[08:25:50.097] Environment: R_GlobalEnv
[08:25:50.097] Capture standard output: TRUE
[08:25:50.097] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.097] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.097] Packages: <none>
[08:25:50.097] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:50.097] Resolved: TRUE
[08:25:50.097] Value: <not collected>
[08:25:50.097] Conditions captured: <none>
[08:25:50.097] Early signaling: FALSE
[08:25:50.097] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.097] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.108] Chunk #1 of 2 ... DONE
[08:25:50.108] Chunk #2 of 2 ...
[08:25:50.108]  - Finding globals in '...' for chunk #2 ...
[08:25:50.109] getGlobalsAndPackages() ...
[08:25:50.109] Searching for globals...
[08:25:50.110] 
[08:25:50.110] Searching for globals ... DONE
[08:25:50.110] - globals: [0] <none>
[08:25:50.110] getGlobalsAndPackages() ... DONE
[08:25:50.110]    + additional globals found: [n=0] 
[08:25:50.110]    + additional namespaces needed: [n=0] 
[08:25:50.111]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:50.111]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.111]  - seeds: <none>
[08:25:50.111]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.111] getGlobalsAndPackages() ...
[08:25:50.112] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.112] Resolving globals: FALSE
[08:25:50.113] The total size of the 5 globals is 656 bytes (656 bytes)
[08:25:50.113] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:50.114] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.114] 
[08:25:50.114] getGlobalsAndPackages() ... DONE
[08:25:50.115] run() for ‘Future’ ...
[08:25:50.115] - state: ‘created’
[08:25:50.115] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.118] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.118] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.118]   - Field: ‘label’
[08:25:50.118]   - Field: ‘local’
[08:25:50.118]   - Field: ‘owner’
[08:25:50.119]   - Field: ‘envir’
[08:25:50.119]   - Field: ‘workers’
[08:25:50.119]   - Field: ‘packages’
[08:25:50.119]   - Field: ‘gc’
[08:25:50.119]   - Field: ‘job’
[08:25:50.119]   - Field: ‘conditions’
[08:25:50.119]   - Field: ‘expr’
[08:25:50.119]   - Field: ‘uuid’
[08:25:50.120]   - Field: ‘seed’
[08:25:50.120]   - Field: ‘version’
[08:25:50.120]   - Field: ‘result’
[08:25:50.120]   - Field: ‘asynchronous’
[08:25:50.120]   - Field: ‘calls’
[08:25:50.120]   - Field: ‘globals’
[08:25:50.120]   - Field: ‘stdout’
[08:25:50.120]   - Field: ‘earlySignal’
[08:25:50.121]   - Field: ‘lazy’
[08:25:50.121]   - Field: ‘state’
[08:25:50.121] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.121] - Launch lazy future ...
[08:25:50.121] Packages needed by the future expression (n = 0): <none>
[08:25:50.121] Packages needed by future strategies (n = 0): <none>
[08:25:50.122] {
[08:25:50.122]     {
[08:25:50.122]         {
[08:25:50.122]             ...future.startTime <- base::Sys.time()
[08:25:50.122]             {
[08:25:50.122]                 {
[08:25:50.122]                   {
[08:25:50.122]                     {
[08:25:50.122]                       base::local({
[08:25:50.122]                         has_future <- base::requireNamespace("future", 
[08:25:50.122]                           quietly = TRUE)
[08:25:50.122]                         if (has_future) {
[08:25:50.122]                           ns <- base::getNamespace("future")
[08:25:50.122]                           version <- ns[[".package"]][["version"]]
[08:25:50.122]                           if (is.null(version)) 
[08:25:50.122]                             version <- utils::packageVersion("future")
[08:25:50.122]                         }
[08:25:50.122]                         else {
[08:25:50.122]                           version <- NULL
[08:25:50.122]                         }
[08:25:50.122]                         if (!has_future || version < "1.8.0") {
[08:25:50.122]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.122]                             "", base::R.version$version.string), 
[08:25:50.122]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:50.122]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:50.122]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.122]                               "release", "version")], collapse = " "), 
[08:25:50.122]                             hostname = base::Sys.info()[["nodename"]])
[08:25:50.122]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.122]                             info)
[08:25:50.122]                           info <- base::paste(info, collapse = "; ")
[08:25:50.122]                           if (!has_future) {
[08:25:50.122]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.122]                               info)
[08:25:50.122]                           }
[08:25:50.122]                           else {
[08:25:50.122]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.122]                               info, version)
[08:25:50.122]                           }
[08:25:50.122]                           base::stop(msg)
[08:25:50.122]                         }
[08:25:50.122]                       })
[08:25:50.122]                     }
[08:25:50.122]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.122]                     base::options(mc.cores = 1L)
[08:25:50.122]                   }
[08:25:50.122]                   ...future.strategy.old <- future::plan("list")
[08:25:50.122]                   options(future.plan = NULL)
[08:25:50.122]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.122]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.122]                 }
[08:25:50.122]                 ...future.workdir <- getwd()
[08:25:50.122]             }
[08:25:50.122]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.122]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.122]         }
[08:25:50.122]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.122]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.122]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.122]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.122]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.122]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.122]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.122]             base::names(...future.oldOptions))
[08:25:50.122]     }
[08:25:50.122]     if (FALSE) {
[08:25:50.122]     }
[08:25:50.122]     else {
[08:25:50.122]         if (TRUE) {
[08:25:50.122]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.122]                 open = "w")
[08:25:50.122]         }
[08:25:50.122]         else {
[08:25:50.122]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.122]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.122]         }
[08:25:50.122]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.122]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.122]             base::sink(type = "output", split = FALSE)
[08:25:50.122]             base::close(...future.stdout)
[08:25:50.122]         }, add = TRUE)
[08:25:50.122]     }
[08:25:50.122]     ...future.frame <- base::sys.nframe()
[08:25:50.122]     ...future.conditions <- base::list()
[08:25:50.122]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.122]     if (FALSE) {
[08:25:50.122]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.122]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.122]     }
[08:25:50.122]     ...future.result <- base::tryCatch({
[08:25:50.122]         base::withCallingHandlers({
[08:25:50.122]             ...future.value <- base::withVisible(base::local({
[08:25:50.122]                 withCallingHandlers({
[08:25:50.122]                   {
[08:25:50.122]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.122]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.122]                       ...future.globals.maxSize)) {
[08:25:50.122]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.122]                       on.exit(options(oopts), add = TRUE)
[08:25:50.122]                     }
[08:25:50.122]                     {
[08:25:50.122]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.122]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.122]                         USE.NAMES = FALSE)
[08:25:50.122]                       do.call(mapply, args = args)
[08:25:50.122]                     }
[08:25:50.122]                   }
[08:25:50.122]                 }, immediateCondition = function(cond) {
[08:25:50.122]                   save_rds <- function (object, pathname, ...) 
[08:25:50.122]                   {
[08:25:50.122]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.122]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.122]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.122]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.122]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.122]                         fi_tmp[["mtime"]])
[08:25:50.122]                     }
[08:25:50.122]                     tryCatch({
[08:25:50.122]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.122]                     }, error = function(ex) {
[08:25:50.122]                       msg <- conditionMessage(ex)
[08:25:50.122]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.122]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.122]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.122]                         fi_tmp[["mtime"]], msg)
[08:25:50.122]                       ex$message <- msg
[08:25:50.122]                       stop(ex)
[08:25:50.122]                     })
[08:25:50.122]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.122]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.122]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.122]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.122]                       fi <- file.info(pathname)
[08:25:50.122]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.122]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.122]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.122]                         fi[["size"]], fi[["mtime"]])
[08:25:50.122]                       stop(msg)
[08:25:50.122]                     }
[08:25:50.122]                     invisible(pathname)
[08:25:50.122]                   }
[08:25:50.122]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.122]                     rootPath = tempdir()) 
[08:25:50.122]                   {
[08:25:50.122]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.122]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.122]                       tmpdir = path, fileext = ".rds")
[08:25:50.122]                     save_rds(obj, file)
[08:25:50.122]                   }
[08:25:50.122]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.122]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.122]                   {
[08:25:50.122]                     inherits <- base::inherits
[08:25:50.122]                     invokeRestart <- base::invokeRestart
[08:25:50.122]                     is.null <- base::is.null
[08:25:50.122]                     muffled <- FALSE
[08:25:50.122]                     if (inherits(cond, "message")) {
[08:25:50.122]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.122]                       if (muffled) 
[08:25:50.122]                         invokeRestart("muffleMessage")
[08:25:50.122]                     }
[08:25:50.122]                     else if (inherits(cond, "warning")) {
[08:25:50.122]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.122]                       if (muffled) 
[08:25:50.122]                         invokeRestart("muffleWarning")
[08:25:50.122]                     }
[08:25:50.122]                     else if (inherits(cond, "condition")) {
[08:25:50.122]                       if (!is.null(pattern)) {
[08:25:50.122]                         computeRestarts <- base::computeRestarts
[08:25:50.122]                         grepl <- base::grepl
[08:25:50.122]                         restarts <- computeRestarts(cond)
[08:25:50.122]                         for (restart in restarts) {
[08:25:50.122]                           name <- restart$name
[08:25:50.122]                           if (is.null(name)) 
[08:25:50.122]                             next
[08:25:50.122]                           if (!grepl(pattern, name)) 
[08:25:50.122]                             next
[08:25:50.122]                           invokeRestart(restart)
[08:25:50.122]                           muffled <- TRUE
[08:25:50.122]                           break
[08:25:50.122]                         }
[08:25:50.122]                       }
[08:25:50.122]                     }
[08:25:50.122]                     invisible(muffled)
[08:25:50.122]                   }
[08:25:50.122]                   muffleCondition(cond)
[08:25:50.122]                 })
[08:25:50.122]             }))
[08:25:50.122]             future::FutureResult(value = ...future.value$value, 
[08:25:50.122]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.122]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.122]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.122]                     ...future.globalenv.names))
[08:25:50.122]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.122]         }, condition = base::local({
[08:25:50.122]             c <- base::c
[08:25:50.122]             inherits <- base::inherits
[08:25:50.122]             invokeRestart <- base::invokeRestart
[08:25:50.122]             length <- base::length
[08:25:50.122]             list <- base::list
[08:25:50.122]             seq.int <- base::seq.int
[08:25:50.122]             signalCondition <- base::signalCondition
[08:25:50.122]             sys.calls <- base::sys.calls
[08:25:50.122]             `[[` <- base::`[[`
[08:25:50.122]             `+` <- base::`+`
[08:25:50.122]             `<<-` <- base::`<<-`
[08:25:50.122]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.122]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.122]                   3L)]
[08:25:50.122]             }
[08:25:50.122]             function(cond) {
[08:25:50.122]                 is_error <- inherits(cond, "error")
[08:25:50.122]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.122]                   NULL)
[08:25:50.122]                 if (is_error) {
[08:25:50.122]                   sessionInformation <- function() {
[08:25:50.122]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.122]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.122]                       search = base::search(), system = base::Sys.info())
[08:25:50.122]                   }
[08:25:50.122]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.122]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.122]                     cond$call), session = sessionInformation(), 
[08:25:50.122]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.122]                   signalCondition(cond)
[08:25:50.122]                 }
[08:25:50.122]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.122]                 "immediateCondition"))) {
[08:25:50.122]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.122]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.122]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.122]                   if (TRUE && !signal) {
[08:25:50.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.122]                     {
[08:25:50.122]                       inherits <- base::inherits
[08:25:50.122]                       invokeRestart <- base::invokeRestart
[08:25:50.122]                       is.null <- base::is.null
[08:25:50.122]                       muffled <- FALSE
[08:25:50.122]                       if (inherits(cond, "message")) {
[08:25:50.122]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.122]                         if (muffled) 
[08:25:50.122]                           invokeRestart("muffleMessage")
[08:25:50.122]                       }
[08:25:50.122]                       else if (inherits(cond, "warning")) {
[08:25:50.122]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.122]                         if (muffled) 
[08:25:50.122]                           invokeRestart("muffleWarning")
[08:25:50.122]                       }
[08:25:50.122]                       else if (inherits(cond, "condition")) {
[08:25:50.122]                         if (!is.null(pattern)) {
[08:25:50.122]                           computeRestarts <- base::computeRestarts
[08:25:50.122]                           grepl <- base::grepl
[08:25:50.122]                           restarts <- computeRestarts(cond)
[08:25:50.122]                           for (restart in restarts) {
[08:25:50.122]                             name <- restart$name
[08:25:50.122]                             if (is.null(name)) 
[08:25:50.122]                               next
[08:25:50.122]                             if (!grepl(pattern, name)) 
[08:25:50.122]                               next
[08:25:50.122]                             invokeRestart(restart)
[08:25:50.122]                             muffled <- TRUE
[08:25:50.122]                             break
[08:25:50.122]                           }
[08:25:50.122]                         }
[08:25:50.122]                       }
[08:25:50.122]                       invisible(muffled)
[08:25:50.122]                     }
[08:25:50.122]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.122]                   }
[08:25:50.122]                 }
[08:25:50.122]                 else {
[08:25:50.122]                   if (TRUE) {
[08:25:50.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.122]                     {
[08:25:50.122]                       inherits <- base::inherits
[08:25:50.122]                       invokeRestart <- base::invokeRestart
[08:25:50.122]                       is.null <- base::is.null
[08:25:50.122]                       muffled <- FALSE
[08:25:50.122]                       if (inherits(cond, "message")) {
[08:25:50.122]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.122]                         if (muffled) 
[08:25:50.122]                           invokeRestart("muffleMessage")
[08:25:50.122]                       }
[08:25:50.122]                       else if (inherits(cond, "warning")) {
[08:25:50.122]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.122]                         if (muffled) 
[08:25:50.122]                           invokeRestart("muffleWarning")
[08:25:50.122]                       }
[08:25:50.122]                       else if (inherits(cond, "condition")) {
[08:25:50.122]                         if (!is.null(pattern)) {
[08:25:50.122]                           computeRestarts <- base::computeRestarts
[08:25:50.122]                           grepl <- base::grepl
[08:25:50.122]                           restarts <- computeRestarts(cond)
[08:25:50.122]                           for (restart in restarts) {
[08:25:50.122]                             name <- restart$name
[08:25:50.122]                             if (is.null(name)) 
[08:25:50.122]                               next
[08:25:50.122]                             if (!grepl(pattern, name)) 
[08:25:50.122]                               next
[08:25:50.122]                             invokeRestart(restart)
[08:25:50.122]                             muffled <- TRUE
[08:25:50.122]                             break
[08:25:50.122]                           }
[08:25:50.122]                         }
[08:25:50.122]                       }
[08:25:50.122]                       invisible(muffled)
[08:25:50.122]                     }
[08:25:50.122]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.122]                   }
[08:25:50.122]                 }
[08:25:50.122]             }
[08:25:50.122]         }))
[08:25:50.122]     }, error = function(ex) {
[08:25:50.122]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.122]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.122]                 ...future.rng), started = ...future.startTime, 
[08:25:50.122]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.122]             version = "1.8"), class = "FutureResult")
[08:25:50.122]     }, finally = {
[08:25:50.122]         if (!identical(...future.workdir, getwd())) 
[08:25:50.122]             setwd(...future.workdir)
[08:25:50.122]         {
[08:25:50.122]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.122]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.122]             }
[08:25:50.122]             base::options(...future.oldOptions)
[08:25:50.122]             if (.Platform$OS.type == "windows") {
[08:25:50.122]                 old_names <- names(...future.oldEnvVars)
[08:25:50.122]                 envs <- base::Sys.getenv()
[08:25:50.122]                 names <- names(envs)
[08:25:50.122]                 common <- intersect(names, old_names)
[08:25:50.122]                 added <- setdiff(names, old_names)
[08:25:50.122]                 removed <- setdiff(old_names, names)
[08:25:50.122]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.122]                   envs[common]]
[08:25:50.122]                 NAMES <- toupper(changed)
[08:25:50.122]                 args <- list()
[08:25:50.122]                 for (kk in seq_along(NAMES)) {
[08:25:50.122]                   name <- changed[[kk]]
[08:25:50.122]                   NAME <- NAMES[[kk]]
[08:25:50.122]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.122]                     next
[08:25:50.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.122]                 }
[08:25:50.122]                 NAMES <- toupper(added)
[08:25:50.122]                 for (kk in seq_along(NAMES)) {
[08:25:50.122]                   name <- added[[kk]]
[08:25:50.122]                   NAME <- NAMES[[kk]]
[08:25:50.122]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.122]                     next
[08:25:50.122]                   args[[name]] <- ""
[08:25:50.122]                 }
[08:25:50.122]                 NAMES <- toupper(removed)
[08:25:50.122]                 for (kk in seq_along(NAMES)) {
[08:25:50.122]                   name <- removed[[kk]]
[08:25:50.122]                   NAME <- NAMES[[kk]]
[08:25:50.122]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.122]                     next
[08:25:50.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.122]                 }
[08:25:50.122]                 if (length(args) > 0) 
[08:25:50.122]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.122]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.122]             }
[08:25:50.122]             else {
[08:25:50.122]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.122]             }
[08:25:50.122]             {
[08:25:50.122]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.122]                   0L) {
[08:25:50.122]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.122]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.122]                   base::options(opts)
[08:25:50.122]                 }
[08:25:50.122]                 {
[08:25:50.122]                   {
[08:25:50.122]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.122]                     NULL
[08:25:50.122]                   }
[08:25:50.122]                   options(future.plan = NULL)
[08:25:50.122]                   if (is.na(NA_character_)) 
[08:25:50.122]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.122]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.122]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.122]                     .init = FALSE)
[08:25:50.122]                 }
[08:25:50.122]             }
[08:25:50.122]         }
[08:25:50.122]     })
[08:25:50.122]     if (TRUE) {
[08:25:50.122]         base::sink(type = "output", split = FALSE)
[08:25:50.122]         if (TRUE) {
[08:25:50.122]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.122]         }
[08:25:50.122]         else {
[08:25:50.122]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.122]         }
[08:25:50.122]         base::close(...future.stdout)
[08:25:50.122]         ...future.stdout <- NULL
[08:25:50.122]     }
[08:25:50.122]     ...future.result$conditions <- ...future.conditions
[08:25:50.122]     ...future.result$finished <- base::Sys.time()
[08:25:50.122]     ...future.result
[08:25:50.122] }
[08:25:50.126] assign_globals() ...
[08:25:50.126] List of 5
[08:25:50.126]  $ ...future.FUN            :function (x, y)  
[08:25:50.126]  $ MoreArgs                 :List of 1
[08:25:50.126]   ..$ y: int [1:2] 3 4
[08:25:50.126]  $ ...future.elements_ii    :List of 1
[08:25:50.126]   ..$ x:List of 1
[08:25:50.126]   .. ..$ : int 2
[08:25:50.126]  $ ...future.seeds_ii       : NULL
[08:25:50.126]  $ ...future.globals.maxSize: NULL
[08:25:50.126]  - attr(*, "where")=List of 5
[08:25:50.126]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.126]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.126]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.126]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.126]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.126]  - attr(*, "resolved")= logi FALSE
[08:25:50.126]  - attr(*, "total_size")= num 656
[08:25:50.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.126]  - attr(*, "already-done")= logi TRUE
[08:25:50.136] - reassign environment for ‘...future.FUN’
[08:25:50.136] - copied ‘...future.FUN’ to environment
[08:25:50.136] - copied ‘MoreArgs’ to environment
[08:25:50.136] - copied ‘...future.elements_ii’ to environment
[08:25:50.136] - copied ‘...future.seeds_ii’ to environment
[08:25:50.137] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.137] assign_globals() ... done
[08:25:50.137] requestCore(): workers = 2
[08:25:50.140] MulticoreFuture started
[08:25:50.141] - Launch lazy future ... done
[08:25:50.141] plan(): Setting new future strategy stack:
[08:25:50.141] run() for ‘MulticoreFuture’ ... done
[08:25:50.142] Created future:
[08:25:50.141] List of future strategies:
[08:25:50.141] 1. sequential:
[08:25:50.141]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.141]    - tweaked: FALSE
[08:25:50.141]    - call: NULL
[08:25:50.143] plan(): nbrOfWorkers() = 1
[08:25:50.146] plan(): Setting new future strategy stack:
[08:25:50.147] List of future strategies:
[08:25:50.147] 1. multicore:
[08:25:50.147]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.147]    - tweaked: FALSE
[08:25:50.147]    - call: plan(strategy)
[08:25:50.151] plan(): nbrOfWorkers() = 2
[08:25:50.142] MulticoreFuture:
[08:25:50.142] Label: ‘future_.mapply-2’
[08:25:50.142] Expression:
[08:25:50.142] {
[08:25:50.142]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.142]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.142]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.142]         on.exit(options(oopts), add = TRUE)
[08:25:50.142]     }
[08:25:50.142]     {
[08:25:50.142]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.142]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.142]         do.call(mapply, args = args)
[08:25:50.142]     }
[08:25:50.142] }
[08:25:50.142] Lazy evaluation: FALSE
[08:25:50.142] Asynchronous evaluation: TRUE
[08:25:50.142] Local evaluation: TRUE
[08:25:50.142] Environment: R_GlobalEnv
[08:25:50.142] Capture standard output: TRUE
[08:25:50.142] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.142] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.142] Packages: <none>
[08:25:50.142] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:50.142] Resolved: TRUE
[08:25:50.142] Value: <not collected>
[08:25:50.142] Conditions captured: <none>
[08:25:50.142] Early signaling: FALSE
[08:25:50.142] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.142] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.153] Chunk #2 of 2 ... DONE
[08:25:50.153] Launching 2 futures (chunks) ... DONE
[08:25:50.153] Resolving 2 futures (chunks) ...
[08:25:50.153] resolve() on list ...
[08:25:50.153]  recursive: 0
[08:25:50.154]  length: 2
[08:25:50.154] 
[08:25:50.154] Future #1
[08:25:50.154] result() for MulticoreFuture ...
[08:25:50.155] result() for MulticoreFuture ...
[08:25:50.156] result() for MulticoreFuture ... done
[08:25:50.156] result() for MulticoreFuture ... done
[08:25:50.156] result() for MulticoreFuture ...
[08:25:50.156] result() for MulticoreFuture ... done
[08:25:50.157] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:50.157] - nx: 2
[08:25:50.157] - relay: TRUE
[08:25:50.157] - stdout: TRUE
[08:25:50.157] - signal: TRUE
[08:25:50.158] - resignal: FALSE
[08:25:50.158] - force: TRUE
[08:25:50.158] - relayed: [n=2] FALSE, FALSE
[08:25:50.158] - queued futures: [n=2] FALSE, FALSE
[08:25:50.158]  - until=1
[08:25:50.159]  - relaying element #1
[08:25:50.159] result() for MulticoreFuture ...
[08:25:50.159] result() for MulticoreFuture ... done
[08:25:50.159] result() for MulticoreFuture ...
[08:25:50.160] result() for MulticoreFuture ... done
[08:25:50.160] result() for MulticoreFuture ...
[08:25:50.160] result() for MulticoreFuture ... done
[08:25:50.160] result() for MulticoreFuture ...
[08:25:50.161] result() for MulticoreFuture ... done
[08:25:50.161] - relayed: [n=2] TRUE, FALSE
[08:25:50.161] - queued futures: [n=2] TRUE, FALSE
[08:25:50.161] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:50.161]  length: 1 (resolved future 1)
[08:25:50.162] Future #2
[08:25:50.162] result() for MulticoreFuture ...
[08:25:50.162] result() for MulticoreFuture ...
[08:25:50.163] result() for MulticoreFuture ... done
[08:25:50.163] result() for MulticoreFuture ... done
[08:25:50.163] result() for MulticoreFuture ...
[08:25:50.163] result() for MulticoreFuture ... done
[08:25:50.163] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:50.163] - nx: 2
[08:25:50.164] - relay: TRUE
[08:25:50.164] - stdout: TRUE
[08:25:50.164] - signal: TRUE
[08:25:50.164] - resignal: FALSE
[08:25:50.164] - force: TRUE
[08:25:50.164] - relayed: [n=2] TRUE, FALSE
[08:25:50.164] - queued futures: [n=2] TRUE, FALSE
[08:25:50.164]  - until=2
[08:25:50.164]  - relaying element #2
[08:25:50.165] result() for MulticoreFuture ...
[08:25:50.165] result() for MulticoreFuture ... done
[08:25:50.165] result() for MulticoreFuture ...
[08:25:50.165] result() for MulticoreFuture ... done
[08:25:50.165] result() for MulticoreFuture ...
[08:25:50.165] result() for MulticoreFuture ... done
[08:25:50.165] result() for MulticoreFuture ...
[08:25:50.165] result() for MulticoreFuture ... done
[08:25:50.165] - relayed: [n=2] TRUE, TRUE
[08:25:50.166] - queued futures: [n=2] TRUE, TRUE
[08:25:50.166] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:50.166]  length: 0 (resolved future 2)
[08:25:50.166] Relaying remaining futures
[08:25:50.166] signalConditionsASAP(NULL, pos=0) ...
[08:25:50.166] - nx: 2
[08:25:50.166] - relay: TRUE
[08:25:50.166] - stdout: TRUE
[08:25:50.166] - signal: TRUE
[08:25:50.166] - resignal: FALSE
[08:25:50.167] - force: TRUE
[08:25:50.167] - relayed: [n=2] TRUE, TRUE
[08:25:50.167] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:50.167] - relayed: [n=2] TRUE, TRUE
[08:25:50.167] - queued futures: [n=2] TRUE, TRUE
[08:25:50.167] signalConditionsASAP(NULL, pos=0) ... done
[08:25:50.167] resolve() on list ... DONE
[08:25:50.167] result() for MulticoreFuture ...
[08:25:50.167] result() for MulticoreFuture ... done
[08:25:50.168] result() for MulticoreFuture ...
[08:25:50.168] result() for MulticoreFuture ... done
[08:25:50.168] result() for MulticoreFuture ...
[08:25:50.168] result() for MulticoreFuture ... done
[08:25:50.168] result() for MulticoreFuture ...
[08:25:50.168] result() for MulticoreFuture ... done
[08:25:50.168]  - Number of value chunks collected: 2
[08:25:50.168] Resolving 2 futures (chunks) ... DONE
[08:25:50.168] Reducing values from 2 chunks ...
[08:25:50.168]  - Number of values collected after concatenation: 2
[08:25:50.169]  - Number of values expected: 2
[08:25:50.169] Reducing values from 2 chunks ... DONE
[08:25:50.169] future_mapply() ... DONE
- Recycle arguments to same length ...
[08:25:50.169] future_mapply() ...
[08:25:50.171] Number of chunks: 2
[08:25:50.171] getGlobalsAndPackagesXApply() ...
[08:25:50.171]  - future.globals: TRUE
[08:25:50.172] getGlobalsAndPackages() ...
[08:25:50.172] Searching for globals...
[08:25:50.172] - globals found: [1] ‘FUN’
[08:25:50.173] Searching for globals ... DONE
[08:25:50.173] Resolving globals: FALSE
[08:25:50.173] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:50.173] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:50.174] - globals: [1] ‘FUN’
[08:25:50.174] 
[08:25:50.174] getGlobalsAndPackages() ... DONE
[08:25:50.174]  - globals found/used: [n=1] ‘FUN’
[08:25:50.174]  - needed namespaces: [n=0] 
[08:25:50.174] Finding globals ... DONE
[08:25:50.174] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:50.174] List of 2
[08:25:50.174]  $ ...future.FUN:function (x, ...)  
[08:25:50.174]  $ MoreArgs     : NULL
[08:25:50.174]  - attr(*, "where")=List of 2
[08:25:50.174]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:50.174]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:50.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.174]  - attr(*, "resolved")= logi FALSE
[08:25:50.174]  - attr(*, "total_size")= num NA
[08:25:50.180] Packages to be attached in all futures: [n=0] 
[08:25:50.181] getGlobalsAndPackagesXApply() ... DONE
[08:25:50.181] Number of futures (= number of chunks): 2
[08:25:50.181] Launching 2 futures (chunks) ...
[08:25:50.181] Chunk #1 of 2 ...
[08:25:50.181]  - Finding globals in '...' for chunk #1 ...
[08:25:50.181] getGlobalsAndPackages() ...
[08:25:50.181] Searching for globals...
[08:25:50.182] 
[08:25:50.182] Searching for globals ... DONE
[08:25:50.182] - globals: [0] <none>
[08:25:50.182] getGlobalsAndPackages() ... DONE
[08:25:50.182]    + additional globals found: [n=0] 
[08:25:50.182]    + additional namespaces needed: [n=0] 
[08:25:50.183]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:50.183]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.183]  - seeds: <none>
[08:25:50.183]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.183] getGlobalsAndPackages() ...
[08:25:50.183] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.183] Resolving globals: FALSE
[08:25:50.184] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:50.184] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:50.185] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.185] 
[08:25:50.185] getGlobalsAndPackages() ... DONE
[08:25:50.185] run() for ‘Future’ ...
[08:25:50.185] - state: ‘created’
[08:25:50.185] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.187] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.188]   - Field: ‘label’
[08:25:50.188]   - Field: ‘local’
[08:25:50.188]   - Field: ‘owner’
[08:25:50.188]   - Field: ‘envir’
[08:25:50.188]   - Field: ‘workers’
[08:25:50.188]   - Field: ‘packages’
[08:25:50.188]   - Field: ‘gc’
[08:25:50.188]   - Field: ‘job’
[08:25:50.188]   - Field: ‘conditions’
[08:25:50.189]   - Field: ‘expr’
[08:25:50.189]   - Field: ‘uuid’
[08:25:50.189]   - Field: ‘seed’
[08:25:50.189]   - Field: ‘version’
[08:25:50.189]   - Field: ‘result’
[08:25:50.189]   - Field: ‘asynchronous’
[08:25:50.189]   - Field: ‘calls’
[08:25:50.189]   - Field: ‘globals’
[08:25:50.189]   - Field: ‘stdout’
[08:25:50.189]   - Field: ‘earlySignal’
[08:25:50.189]   - Field: ‘lazy’
[08:25:50.190]   - Field: ‘state’
[08:25:50.190] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.190] - Launch lazy future ...
[08:25:50.190] Packages needed by the future expression (n = 0): <none>
[08:25:50.190] Packages needed by future strategies (n = 0): <none>
[08:25:50.191] {
[08:25:50.191]     {
[08:25:50.191]         {
[08:25:50.191]             ...future.startTime <- base::Sys.time()
[08:25:50.191]             {
[08:25:50.191]                 {
[08:25:50.191]                   {
[08:25:50.191]                     {
[08:25:50.191]                       base::local({
[08:25:50.191]                         has_future <- base::requireNamespace("future", 
[08:25:50.191]                           quietly = TRUE)
[08:25:50.191]                         if (has_future) {
[08:25:50.191]                           ns <- base::getNamespace("future")
[08:25:50.191]                           version <- ns[[".package"]][["version"]]
[08:25:50.191]                           if (is.null(version)) 
[08:25:50.191]                             version <- utils::packageVersion("future")
[08:25:50.191]                         }
[08:25:50.191]                         else {
[08:25:50.191]                           version <- NULL
[08:25:50.191]                         }
[08:25:50.191]                         if (!has_future || version < "1.8.0") {
[08:25:50.191]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.191]                             "", base::R.version$version.string), 
[08:25:50.191]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:50.191]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:50.191]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.191]                               "release", "version")], collapse = " "), 
[08:25:50.191]                             hostname = base::Sys.info()[["nodename"]])
[08:25:50.191]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.191]                             info)
[08:25:50.191]                           info <- base::paste(info, collapse = "; ")
[08:25:50.191]                           if (!has_future) {
[08:25:50.191]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.191]                               info)
[08:25:50.191]                           }
[08:25:50.191]                           else {
[08:25:50.191]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.191]                               info, version)
[08:25:50.191]                           }
[08:25:50.191]                           base::stop(msg)
[08:25:50.191]                         }
[08:25:50.191]                       })
[08:25:50.191]                     }
[08:25:50.191]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.191]                     base::options(mc.cores = 1L)
[08:25:50.191]                   }
[08:25:50.191]                   ...future.strategy.old <- future::plan("list")
[08:25:50.191]                   options(future.plan = NULL)
[08:25:50.191]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.191]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.191]                 }
[08:25:50.191]                 ...future.workdir <- getwd()
[08:25:50.191]             }
[08:25:50.191]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.191]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.191]         }
[08:25:50.191]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.191]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.191]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.191]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.191]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.191]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.191]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.191]             base::names(...future.oldOptions))
[08:25:50.191]     }
[08:25:50.191]     if (FALSE) {
[08:25:50.191]     }
[08:25:50.191]     else {
[08:25:50.191]         if (TRUE) {
[08:25:50.191]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.191]                 open = "w")
[08:25:50.191]         }
[08:25:50.191]         else {
[08:25:50.191]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.191]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.191]         }
[08:25:50.191]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.191]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.191]             base::sink(type = "output", split = FALSE)
[08:25:50.191]             base::close(...future.stdout)
[08:25:50.191]         }, add = TRUE)
[08:25:50.191]     }
[08:25:50.191]     ...future.frame <- base::sys.nframe()
[08:25:50.191]     ...future.conditions <- base::list()
[08:25:50.191]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.191]     if (FALSE) {
[08:25:50.191]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.191]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.191]     }
[08:25:50.191]     ...future.result <- base::tryCatch({
[08:25:50.191]         base::withCallingHandlers({
[08:25:50.191]             ...future.value <- base::withVisible(base::local({
[08:25:50.191]                 withCallingHandlers({
[08:25:50.191]                   {
[08:25:50.191]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.191]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.191]                       ...future.globals.maxSize)) {
[08:25:50.191]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.191]                       on.exit(options(oopts), add = TRUE)
[08:25:50.191]                     }
[08:25:50.191]                     {
[08:25:50.191]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.191]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.191]                         USE.NAMES = FALSE)
[08:25:50.191]                       do.call(mapply, args = args)
[08:25:50.191]                     }
[08:25:50.191]                   }
[08:25:50.191]                 }, immediateCondition = function(cond) {
[08:25:50.191]                   save_rds <- function (object, pathname, ...) 
[08:25:50.191]                   {
[08:25:50.191]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.191]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.191]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.191]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.191]                         fi_tmp[["mtime"]])
[08:25:50.191]                     }
[08:25:50.191]                     tryCatch({
[08:25:50.191]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.191]                     }, error = function(ex) {
[08:25:50.191]                       msg <- conditionMessage(ex)
[08:25:50.191]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.191]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.191]                         fi_tmp[["mtime"]], msg)
[08:25:50.191]                       ex$message <- msg
[08:25:50.191]                       stop(ex)
[08:25:50.191]                     })
[08:25:50.191]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.191]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.191]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.191]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.191]                       fi <- file.info(pathname)
[08:25:50.191]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.191]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.191]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.191]                         fi[["size"]], fi[["mtime"]])
[08:25:50.191]                       stop(msg)
[08:25:50.191]                     }
[08:25:50.191]                     invisible(pathname)
[08:25:50.191]                   }
[08:25:50.191]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.191]                     rootPath = tempdir()) 
[08:25:50.191]                   {
[08:25:50.191]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.191]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.191]                       tmpdir = path, fileext = ".rds")
[08:25:50.191]                     save_rds(obj, file)
[08:25:50.191]                   }
[08:25:50.191]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.191]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.191]                   {
[08:25:50.191]                     inherits <- base::inherits
[08:25:50.191]                     invokeRestart <- base::invokeRestart
[08:25:50.191]                     is.null <- base::is.null
[08:25:50.191]                     muffled <- FALSE
[08:25:50.191]                     if (inherits(cond, "message")) {
[08:25:50.191]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.191]                       if (muffled) 
[08:25:50.191]                         invokeRestart("muffleMessage")
[08:25:50.191]                     }
[08:25:50.191]                     else if (inherits(cond, "warning")) {
[08:25:50.191]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.191]                       if (muffled) 
[08:25:50.191]                         invokeRestart("muffleWarning")
[08:25:50.191]                     }
[08:25:50.191]                     else if (inherits(cond, "condition")) {
[08:25:50.191]                       if (!is.null(pattern)) {
[08:25:50.191]                         computeRestarts <- base::computeRestarts
[08:25:50.191]                         grepl <- base::grepl
[08:25:50.191]                         restarts <- computeRestarts(cond)
[08:25:50.191]                         for (restart in restarts) {
[08:25:50.191]                           name <- restart$name
[08:25:50.191]                           if (is.null(name)) 
[08:25:50.191]                             next
[08:25:50.191]                           if (!grepl(pattern, name)) 
[08:25:50.191]                             next
[08:25:50.191]                           invokeRestart(restart)
[08:25:50.191]                           muffled <- TRUE
[08:25:50.191]                           break
[08:25:50.191]                         }
[08:25:50.191]                       }
[08:25:50.191]                     }
[08:25:50.191]                     invisible(muffled)
[08:25:50.191]                   }
[08:25:50.191]                   muffleCondition(cond)
[08:25:50.191]                 })
[08:25:50.191]             }))
[08:25:50.191]             future::FutureResult(value = ...future.value$value, 
[08:25:50.191]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.191]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.191]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.191]                     ...future.globalenv.names))
[08:25:50.191]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.191]         }, condition = base::local({
[08:25:50.191]             c <- base::c
[08:25:50.191]             inherits <- base::inherits
[08:25:50.191]             invokeRestart <- base::invokeRestart
[08:25:50.191]             length <- base::length
[08:25:50.191]             list <- base::list
[08:25:50.191]             seq.int <- base::seq.int
[08:25:50.191]             signalCondition <- base::signalCondition
[08:25:50.191]             sys.calls <- base::sys.calls
[08:25:50.191]             `[[` <- base::`[[`
[08:25:50.191]             `+` <- base::`+`
[08:25:50.191]             `<<-` <- base::`<<-`
[08:25:50.191]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.191]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.191]                   3L)]
[08:25:50.191]             }
[08:25:50.191]             function(cond) {
[08:25:50.191]                 is_error <- inherits(cond, "error")
[08:25:50.191]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.191]                   NULL)
[08:25:50.191]                 if (is_error) {
[08:25:50.191]                   sessionInformation <- function() {
[08:25:50.191]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.191]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.191]                       search = base::search(), system = base::Sys.info())
[08:25:50.191]                   }
[08:25:50.191]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.191]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.191]                     cond$call), session = sessionInformation(), 
[08:25:50.191]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.191]                   signalCondition(cond)
[08:25:50.191]                 }
[08:25:50.191]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.191]                 "immediateCondition"))) {
[08:25:50.191]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.191]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.191]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.191]                   if (TRUE && !signal) {
[08:25:50.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.191]                     {
[08:25:50.191]                       inherits <- base::inherits
[08:25:50.191]                       invokeRestart <- base::invokeRestart
[08:25:50.191]                       is.null <- base::is.null
[08:25:50.191]                       muffled <- FALSE
[08:25:50.191]                       if (inherits(cond, "message")) {
[08:25:50.191]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.191]                         if (muffled) 
[08:25:50.191]                           invokeRestart("muffleMessage")
[08:25:50.191]                       }
[08:25:50.191]                       else if (inherits(cond, "warning")) {
[08:25:50.191]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.191]                         if (muffled) 
[08:25:50.191]                           invokeRestart("muffleWarning")
[08:25:50.191]                       }
[08:25:50.191]                       else if (inherits(cond, "condition")) {
[08:25:50.191]                         if (!is.null(pattern)) {
[08:25:50.191]                           computeRestarts <- base::computeRestarts
[08:25:50.191]                           grepl <- base::grepl
[08:25:50.191]                           restarts <- computeRestarts(cond)
[08:25:50.191]                           for (restart in restarts) {
[08:25:50.191]                             name <- restart$name
[08:25:50.191]                             if (is.null(name)) 
[08:25:50.191]                               next
[08:25:50.191]                             if (!grepl(pattern, name)) 
[08:25:50.191]                               next
[08:25:50.191]                             invokeRestart(restart)
[08:25:50.191]                             muffled <- TRUE
[08:25:50.191]                             break
[08:25:50.191]                           }
[08:25:50.191]                         }
[08:25:50.191]                       }
[08:25:50.191]                       invisible(muffled)
[08:25:50.191]                     }
[08:25:50.191]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.191]                   }
[08:25:50.191]                 }
[08:25:50.191]                 else {
[08:25:50.191]                   if (TRUE) {
[08:25:50.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.191]                     {
[08:25:50.191]                       inherits <- base::inherits
[08:25:50.191]                       invokeRestart <- base::invokeRestart
[08:25:50.191]                       is.null <- base::is.null
[08:25:50.191]                       muffled <- FALSE
[08:25:50.191]                       if (inherits(cond, "message")) {
[08:25:50.191]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.191]                         if (muffled) 
[08:25:50.191]                           invokeRestart("muffleMessage")
[08:25:50.191]                       }
[08:25:50.191]                       else if (inherits(cond, "warning")) {
[08:25:50.191]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.191]                         if (muffled) 
[08:25:50.191]                           invokeRestart("muffleWarning")
[08:25:50.191]                       }
[08:25:50.191]                       else if (inherits(cond, "condition")) {
[08:25:50.191]                         if (!is.null(pattern)) {
[08:25:50.191]                           computeRestarts <- base::computeRestarts
[08:25:50.191]                           grepl <- base::grepl
[08:25:50.191]                           restarts <- computeRestarts(cond)
[08:25:50.191]                           for (restart in restarts) {
[08:25:50.191]                             name <- restart$name
[08:25:50.191]                             if (is.null(name)) 
[08:25:50.191]                               next
[08:25:50.191]                             if (!grepl(pattern, name)) 
[08:25:50.191]                               next
[08:25:50.191]                             invokeRestart(restart)
[08:25:50.191]                             muffled <- TRUE
[08:25:50.191]                             break
[08:25:50.191]                           }
[08:25:50.191]                         }
[08:25:50.191]                       }
[08:25:50.191]                       invisible(muffled)
[08:25:50.191]                     }
[08:25:50.191]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.191]                   }
[08:25:50.191]                 }
[08:25:50.191]             }
[08:25:50.191]         }))
[08:25:50.191]     }, error = function(ex) {
[08:25:50.191]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.191]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.191]                 ...future.rng), started = ...future.startTime, 
[08:25:50.191]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.191]             version = "1.8"), class = "FutureResult")
[08:25:50.191]     }, finally = {
[08:25:50.191]         if (!identical(...future.workdir, getwd())) 
[08:25:50.191]             setwd(...future.workdir)
[08:25:50.191]         {
[08:25:50.191]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.191]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.191]             }
[08:25:50.191]             base::options(...future.oldOptions)
[08:25:50.191]             if (.Platform$OS.type == "windows") {
[08:25:50.191]                 old_names <- names(...future.oldEnvVars)
[08:25:50.191]                 envs <- base::Sys.getenv()
[08:25:50.191]                 names <- names(envs)
[08:25:50.191]                 common <- intersect(names, old_names)
[08:25:50.191]                 added <- setdiff(names, old_names)
[08:25:50.191]                 removed <- setdiff(old_names, names)
[08:25:50.191]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.191]                   envs[common]]
[08:25:50.191]                 NAMES <- toupper(changed)
[08:25:50.191]                 args <- list()
[08:25:50.191]                 for (kk in seq_along(NAMES)) {
[08:25:50.191]                   name <- changed[[kk]]
[08:25:50.191]                   NAME <- NAMES[[kk]]
[08:25:50.191]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.191]                     next
[08:25:50.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.191]                 }
[08:25:50.191]                 NAMES <- toupper(added)
[08:25:50.191]                 for (kk in seq_along(NAMES)) {
[08:25:50.191]                   name <- added[[kk]]
[08:25:50.191]                   NAME <- NAMES[[kk]]
[08:25:50.191]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.191]                     next
[08:25:50.191]                   args[[name]] <- ""
[08:25:50.191]                 }
[08:25:50.191]                 NAMES <- toupper(removed)
[08:25:50.191]                 for (kk in seq_along(NAMES)) {
[08:25:50.191]                   name <- removed[[kk]]
[08:25:50.191]                   NAME <- NAMES[[kk]]
[08:25:50.191]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.191]                     next
[08:25:50.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.191]                 }
[08:25:50.191]                 if (length(args) > 0) 
[08:25:50.191]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.191]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.191]             }
[08:25:50.191]             else {
[08:25:50.191]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.191]             }
[08:25:50.191]             {
[08:25:50.191]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.191]                   0L) {
[08:25:50.191]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.191]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.191]                   base::options(opts)
[08:25:50.191]                 }
[08:25:50.191]                 {
[08:25:50.191]                   {
[08:25:50.191]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.191]                     NULL
[08:25:50.191]                   }
[08:25:50.191]                   options(future.plan = NULL)
[08:25:50.191]                   if (is.na(NA_character_)) 
[08:25:50.191]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.191]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.191]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.191]                     .init = FALSE)
[08:25:50.191]                 }
[08:25:50.191]             }
[08:25:50.191]         }
[08:25:50.191]     })
[08:25:50.191]     if (TRUE) {
[08:25:50.191]         base::sink(type = "output", split = FALSE)
[08:25:50.191]         if (TRUE) {
[08:25:50.191]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.191]         }
[08:25:50.191]         else {
[08:25:50.191]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.191]         }
[08:25:50.191]         base::close(...future.stdout)
[08:25:50.191]         ...future.stdout <- NULL
[08:25:50.191]     }
[08:25:50.191]     ...future.result$conditions <- ...future.conditions
[08:25:50.191]     ...future.result$finished <- base::Sys.time()
[08:25:50.191]     ...future.result
[08:25:50.191] }
[08:25:50.193] assign_globals() ...
[08:25:50.194] List of 5
[08:25:50.194]  $ ...future.FUN            :function (x, ...)  
[08:25:50.194]  $ MoreArgs                 : NULL
[08:25:50.194]  $ ...future.elements_ii    :List of 2
[08:25:50.194]   ..$ :List of 2
[08:25:50.194]   .. ..$ : int 1
[08:25:50.194]   .. ..$ : int 2
[08:25:50.194]   ..$ :List of 2
[08:25:50.194]   .. ..$ : int 2
[08:25:50.194]   .. ..$ : int 1
[08:25:50.194]  $ ...future.seeds_ii       : NULL
[08:25:50.194]  $ ...future.globals.maxSize: NULL
[08:25:50.194]  - attr(*, "where")=List of 5
[08:25:50.194]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.194]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.194]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.194]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.194]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.194]  - attr(*, "resolved")= logi FALSE
[08:25:50.194]  - attr(*, "total_size")= num 210
[08:25:50.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.194]  - attr(*, "already-done")= logi TRUE
[08:25:50.199] - copied ‘...future.FUN’ to environment
[08:25:50.200] - copied ‘MoreArgs’ to environment
[08:25:50.200] - copied ‘...future.elements_ii’ to environment
[08:25:50.200] - copied ‘...future.seeds_ii’ to environment
[08:25:50.200] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.200] assign_globals() ... done
[08:25:50.200] requestCore(): workers = 2
[08:25:50.203] MulticoreFuture started
[08:25:50.208] - Launch lazy future ... done
[08:25:50.208] plan(): Setting new future strategy stack:
[08:25:50.208] run() for ‘MulticoreFuture’ ... done
[08:25:50.209] Created future:
[08:25:50.209] List of future strategies:
[08:25:50.209] 1. sequential:
[08:25:50.209]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.209]    - tweaked: FALSE
[08:25:50.209]    - call: NULL
[08:25:50.211] plan(): nbrOfWorkers() = 1
[08:25:50.214] plan(): Setting new future strategy stack:
[08:25:50.214] List of future strategies:
[08:25:50.214] 1. multicore:
[08:25:50.214]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.214]    - tweaked: FALSE
[08:25:50.214]    - call: plan(strategy)
[08:25:50.218] plan(): nbrOfWorkers() = 2
[08:25:50.209] MulticoreFuture:
[08:25:50.209] Label: ‘future_mapply-1’
[08:25:50.209] Expression:
[08:25:50.209] {
[08:25:50.209]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.209]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.209]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.209]         on.exit(options(oopts), add = TRUE)
[08:25:50.209]     }
[08:25:50.209]     {
[08:25:50.209]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.209]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.209]         do.call(mapply, args = args)
[08:25:50.209]     }
[08:25:50.209] }
[08:25:50.209] Lazy evaluation: FALSE
[08:25:50.209] Asynchronous evaluation: TRUE
[08:25:50.209] Local evaluation: TRUE
[08:25:50.209] Environment: R_GlobalEnv
[08:25:50.209] Capture standard output: TRUE
[08:25:50.209] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.209] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.209] Packages: <none>
[08:25:50.209] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:50.209] Resolved: TRUE
[08:25:50.209] Value: <not collected>
[08:25:50.209] Conditions captured: <none>
[08:25:50.209] Early signaling: FALSE
[08:25:50.209] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.209] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.220] Chunk #1 of 2 ... DONE
[08:25:50.220] Chunk #2 of 2 ...
[08:25:50.220]  - Finding globals in '...' for chunk #2 ...
[08:25:50.220] getGlobalsAndPackages() ...
[08:25:50.221] Searching for globals...
[08:25:50.221] 
[08:25:50.222] Searching for globals ... DONE
[08:25:50.222] - globals: [0] <none>
[08:25:50.222] getGlobalsAndPackages() ... DONE
[08:25:50.222]    + additional globals found: [n=0] 
[08:25:50.222]    + additional namespaces needed: [n=0] 
[08:25:50.222]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:50.223]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.223]  - seeds: <none>
[08:25:50.223]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.223] getGlobalsAndPackages() ...
[08:25:50.223] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.224] Resolving globals: FALSE
[08:25:50.225] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:50.226] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:50.226] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.226] 
[08:25:50.226] getGlobalsAndPackages() ... DONE
[08:25:50.227] run() for ‘Future’ ...
[08:25:50.227] - state: ‘created’
[08:25:50.227] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.230] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.231]   - Field: ‘label’
[08:25:50.231]   - Field: ‘local’
[08:25:50.231]   - Field: ‘owner’
[08:25:50.231]   - Field: ‘envir’
[08:25:50.232]   - Field: ‘workers’
[08:25:50.232]   - Field: ‘packages’
[08:25:50.232]   - Field: ‘gc’
[08:25:50.232]   - Field: ‘job’
[08:25:50.232]   - Field: ‘conditions’
[08:25:50.232]   - Field: ‘expr’
[08:25:50.232]   - Field: ‘uuid’
[08:25:50.233]   - Field: ‘seed’
[08:25:50.233]   - Field: ‘version’
[08:25:50.233]   - Field: ‘result’
[08:25:50.233]   - Field: ‘asynchronous’
[08:25:50.233]   - Field: ‘calls’
[08:25:50.233]   - Field: ‘globals’
[08:25:50.233]   - Field: ‘stdout’
[08:25:50.233]   - Field: ‘earlySignal’
[08:25:50.234]   - Field: ‘lazy’
[08:25:50.234]   - Field: ‘state’
[08:25:50.234] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.234] - Launch lazy future ...
[08:25:50.234] Packages needed by the future expression (n = 0): <none>
[08:25:50.235] Packages needed by future strategies (n = 0): <none>
[08:25:50.235] {
[08:25:50.235]     {
[08:25:50.235]         {
[08:25:50.235]             ...future.startTime <- base::Sys.time()
[08:25:50.235]             {
[08:25:50.235]                 {
[08:25:50.235]                   {
[08:25:50.235]                     {
[08:25:50.235]                       base::local({
[08:25:50.235]                         has_future <- base::requireNamespace("future", 
[08:25:50.235]                           quietly = TRUE)
[08:25:50.235]                         if (has_future) {
[08:25:50.235]                           ns <- base::getNamespace("future")
[08:25:50.235]                           version <- ns[[".package"]][["version"]]
[08:25:50.235]                           if (is.null(version)) 
[08:25:50.235]                             version <- utils::packageVersion("future")
[08:25:50.235]                         }
[08:25:50.235]                         else {
[08:25:50.235]                           version <- NULL
[08:25:50.235]                         }
[08:25:50.235]                         if (!has_future || version < "1.8.0") {
[08:25:50.235]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.235]                             "", base::R.version$version.string), 
[08:25:50.235]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:50.235]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:50.235]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.235]                               "release", "version")], collapse = " "), 
[08:25:50.235]                             hostname = base::Sys.info()[["nodename"]])
[08:25:50.235]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.235]                             info)
[08:25:50.235]                           info <- base::paste(info, collapse = "; ")
[08:25:50.235]                           if (!has_future) {
[08:25:50.235]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.235]                               info)
[08:25:50.235]                           }
[08:25:50.235]                           else {
[08:25:50.235]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.235]                               info, version)
[08:25:50.235]                           }
[08:25:50.235]                           base::stop(msg)
[08:25:50.235]                         }
[08:25:50.235]                       })
[08:25:50.235]                     }
[08:25:50.235]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.235]                     base::options(mc.cores = 1L)
[08:25:50.235]                   }
[08:25:50.235]                   ...future.strategy.old <- future::plan("list")
[08:25:50.235]                   options(future.plan = NULL)
[08:25:50.235]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.235]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.235]                 }
[08:25:50.235]                 ...future.workdir <- getwd()
[08:25:50.235]             }
[08:25:50.235]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.235]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.235]         }
[08:25:50.235]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.235]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.235]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.235]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.235]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.235]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.235]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.235]             base::names(...future.oldOptions))
[08:25:50.235]     }
[08:25:50.235]     if (FALSE) {
[08:25:50.235]     }
[08:25:50.235]     else {
[08:25:50.235]         if (TRUE) {
[08:25:50.235]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.235]                 open = "w")
[08:25:50.235]         }
[08:25:50.235]         else {
[08:25:50.235]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.235]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.235]         }
[08:25:50.235]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.235]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.235]             base::sink(type = "output", split = FALSE)
[08:25:50.235]             base::close(...future.stdout)
[08:25:50.235]         }, add = TRUE)
[08:25:50.235]     }
[08:25:50.235]     ...future.frame <- base::sys.nframe()
[08:25:50.235]     ...future.conditions <- base::list()
[08:25:50.235]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.235]     if (FALSE) {
[08:25:50.235]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.235]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.235]     }
[08:25:50.235]     ...future.result <- base::tryCatch({
[08:25:50.235]         base::withCallingHandlers({
[08:25:50.235]             ...future.value <- base::withVisible(base::local({
[08:25:50.235]                 withCallingHandlers({
[08:25:50.235]                   {
[08:25:50.235]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.235]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.235]                       ...future.globals.maxSize)) {
[08:25:50.235]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.235]                       on.exit(options(oopts), add = TRUE)
[08:25:50.235]                     }
[08:25:50.235]                     {
[08:25:50.235]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.235]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.235]                         USE.NAMES = FALSE)
[08:25:50.235]                       do.call(mapply, args = args)
[08:25:50.235]                     }
[08:25:50.235]                   }
[08:25:50.235]                 }, immediateCondition = function(cond) {
[08:25:50.235]                   save_rds <- function (object, pathname, ...) 
[08:25:50.235]                   {
[08:25:50.235]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.235]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.235]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.235]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.235]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.235]                         fi_tmp[["mtime"]])
[08:25:50.235]                     }
[08:25:50.235]                     tryCatch({
[08:25:50.235]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.235]                     }, error = function(ex) {
[08:25:50.235]                       msg <- conditionMessage(ex)
[08:25:50.235]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.235]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.235]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.235]                         fi_tmp[["mtime"]], msg)
[08:25:50.235]                       ex$message <- msg
[08:25:50.235]                       stop(ex)
[08:25:50.235]                     })
[08:25:50.235]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.235]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.235]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.235]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.235]                       fi <- file.info(pathname)
[08:25:50.235]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.235]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.235]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.235]                         fi[["size"]], fi[["mtime"]])
[08:25:50.235]                       stop(msg)
[08:25:50.235]                     }
[08:25:50.235]                     invisible(pathname)
[08:25:50.235]                   }
[08:25:50.235]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.235]                     rootPath = tempdir()) 
[08:25:50.235]                   {
[08:25:50.235]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.235]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.235]                       tmpdir = path, fileext = ".rds")
[08:25:50.235]                     save_rds(obj, file)
[08:25:50.235]                   }
[08:25:50.235]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.235]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.235]                   {
[08:25:50.235]                     inherits <- base::inherits
[08:25:50.235]                     invokeRestart <- base::invokeRestart
[08:25:50.235]                     is.null <- base::is.null
[08:25:50.235]                     muffled <- FALSE
[08:25:50.235]                     if (inherits(cond, "message")) {
[08:25:50.235]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.235]                       if (muffled) 
[08:25:50.235]                         invokeRestart("muffleMessage")
[08:25:50.235]                     }
[08:25:50.235]                     else if (inherits(cond, "warning")) {
[08:25:50.235]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.235]                       if (muffled) 
[08:25:50.235]                         invokeRestart("muffleWarning")
[08:25:50.235]                     }
[08:25:50.235]                     else if (inherits(cond, "condition")) {
[08:25:50.235]                       if (!is.null(pattern)) {
[08:25:50.235]                         computeRestarts <- base::computeRestarts
[08:25:50.235]                         grepl <- base::grepl
[08:25:50.235]                         restarts <- computeRestarts(cond)
[08:25:50.235]                         for (restart in restarts) {
[08:25:50.235]                           name <- restart$name
[08:25:50.235]                           if (is.null(name)) 
[08:25:50.235]                             next
[08:25:50.235]                           if (!grepl(pattern, name)) 
[08:25:50.235]                             next
[08:25:50.235]                           invokeRestart(restart)
[08:25:50.235]                           muffled <- TRUE
[08:25:50.235]                           break
[08:25:50.235]                         }
[08:25:50.235]                       }
[08:25:50.235]                     }
[08:25:50.235]                     invisible(muffled)
[08:25:50.235]                   }
[08:25:50.235]                   muffleCondition(cond)
[08:25:50.235]                 })
[08:25:50.235]             }))
[08:25:50.235]             future::FutureResult(value = ...future.value$value, 
[08:25:50.235]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.235]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.235]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.235]                     ...future.globalenv.names))
[08:25:50.235]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.235]         }, condition = base::local({
[08:25:50.235]             c <- base::c
[08:25:50.235]             inherits <- base::inherits
[08:25:50.235]             invokeRestart <- base::invokeRestart
[08:25:50.235]             length <- base::length
[08:25:50.235]             list <- base::list
[08:25:50.235]             seq.int <- base::seq.int
[08:25:50.235]             signalCondition <- base::signalCondition
[08:25:50.235]             sys.calls <- base::sys.calls
[08:25:50.235]             `[[` <- base::`[[`
[08:25:50.235]             `+` <- base::`+`
[08:25:50.235]             `<<-` <- base::`<<-`
[08:25:50.235]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.235]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.235]                   3L)]
[08:25:50.235]             }
[08:25:50.235]             function(cond) {
[08:25:50.235]                 is_error <- inherits(cond, "error")
[08:25:50.235]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.235]                   NULL)
[08:25:50.235]                 if (is_error) {
[08:25:50.235]                   sessionInformation <- function() {
[08:25:50.235]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.235]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.235]                       search = base::search(), system = base::Sys.info())
[08:25:50.235]                   }
[08:25:50.235]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.235]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.235]                     cond$call), session = sessionInformation(), 
[08:25:50.235]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.235]                   signalCondition(cond)
[08:25:50.235]                 }
[08:25:50.235]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.235]                 "immediateCondition"))) {
[08:25:50.235]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.235]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.235]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.235]                   if (TRUE && !signal) {
[08:25:50.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.235]                     {
[08:25:50.235]                       inherits <- base::inherits
[08:25:50.235]                       invokeRestart <- base::invokeRestart
[08:25:50.235]                       is.null <- base::is.null
[08:25:50.235]                       muffled <- FALSE
[08:25:50.235]                       if (inherits(cond, "message")) {
[08:25:50.235]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.235]                         if (muffled) 
[08:25:50.235]                           invokeRestart("muffleMessage")
[08:25:50.235]                       }
[08:25:50.235]                       else if (inherits(cond, "warning")) {
[08:25:50.235]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.235]                         if (muffled) 
[08:25:50.235]                           invokeRestart("muffleWarning")
[08:25:50.235]                       }
[08:25:50.235]                       else if (inherits(cond, "condition")) {
[08:25:50.235]                         if (!is.null(pattern)) {
[08:25:50.235]                           computeRestarts <- base::computeRestarts
[08:25:50.235]                           grepl <- base::grepl
[08:25:50.235]                           restarts <- computeRestarts(cond)
[08:25:50.235]                           for (restart in restarts) {
[08:25:50.235]                             name <- restart$name
[08:25:50.235]                             if (is.null(name)) 
[08:25:50.235]                               next
[08:25:50.235]                             if (!grepl(pattern, name)) 
[08:25:50.235]                               next
[08:25:50.235]                             invokeRestart(restart)
[08:25:50.235]                             muffled <- TRUE
[08:25:50.235]                             break
[08:25:50.235]                           }
[08:25:50.235]                         }
[08:25:50.235]                       }
[08:25:50.235]                       invisible(muffled)
[08:25:50.235]                     }
[08:25:50.235]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.235]                   }
[08:25:50.235]                 }
[08:25:50.235]                 else {
[08:25:50.235]                   if (TRUE) {
[08:25:50.235]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.235]                     {
[08:25:50.235]                       inherits <- base::inherits
[08:25:50.235]                       invokeRestart <- base::invokeRestart
[08:25:50.235]                       is.null <- base::is.null
[08:25:50.235]                       muffled <- FALSE
[08:25:50.235]                       if (inherits(cond, "message")) {
[08:25:50.235]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.235]                         if (muffled) 
[08:25:50.235]                           invokeRestart("muffleMessage")
[08:25:50.235]                       }
[08:25:50.235]                       else if (inherits(cond, "warning")) {
[08:25:50.235]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.235]                         if (muffled) 
[08:25:50.235]                           invokeRestart("muffleWarning")
[08:25:50.235]                       }
[08:25:50.235]                       else if (inherits(cond, "condition")) {
[08:25:50.235]                         if (!is.null(pattern)) {
[08:25:50.235]                           computeRestarts <- base::computeRestarts
[08:25:50.235]                           grepl <- base::grepl
[08:25:50.235]                           restarts <- computeRestarts(cond)
[08:25:50.235]                           for (restart in restarts) {
[08:25:50.235]                             name <- restart$name
[08:25:50.235]                             if (is.null(name)) 
[08:25:50.235]                               next
[08:25:50.235]                             if (!grepl(pattern, name)) 
[08:25:50.235]                               next
[08:25:50.235]                             invokeRestart(restart)
[08:25:50.235]                             muffled <- TRUE
[08:25:50.235]                             break
[08:25:50.235]                           }
[08:25:50.235]                         }
[08:25:50.235]                       }
[08:25:50.235]                       invisible(muffled)
[08:25:50.235]                     }
[08:25:50.235]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.235]                   }
[08:25:50.235]                 }
[08:25:50.235]             }
[08:25:50.235]         }))
[08:25:50.235]     }, error = function(ex) {
[08:25:50.235]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.235]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.235]                 ...future.rng), started = ...future.startTime, 
[08:25:50.235]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.235]             version = "1.8"), class = "FutureResult")
[08:25:50.235]     }, finally = {
[08:25:50.235]         if (!identical(...future.workdir, getwd())) 
[08:25:50.235]             setwd(...future.workdir)
[08:25:50.235]         {
[08:25:50.235]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.235]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.235]             }
[08:25:50.235]             base::options(...future.oldOptions)
[08:25:50.235]             if (.Platform$OS.type == "windows") {
[08:25:50.235]                 old_names <- names(...future.oldEnvVars)
[08:25:50.235]                 envs <- base::Sys.getenv()
[08:25:50.235]                 names <- names(envs)
[08:25:50.235]                 common <- intersect(names, old_names)
[08:25:50.235]                 added <- setdiff(names, old_names)
[08:25:50.235]                 removed <- setdiff(old_names, names)
[08:25:50.235]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.235]                   envs[common]]
[08:25:50.235]                 NAMES <- toupper(changed)
[08:25:50.235]                 args <- list()
[08:25:50.235]                 for (kk in seq_along(NAMES)) {
[08:25:50.235]                   name <- changed[[kk]]
[08:25:50.235]                   NAME <- NAMES[[kk]]
[08:25:50.235]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.235]                     next
[08:25:50.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.235]                 }
[08:25:50.235]                 NAMES <- toupper(added)
[08:25:50.235]                 for (kk in seq_along(NAMES)) {
[08:25:50.235]                   name <- added[[kk]]
[08:25:50.235]                   NAME <- NAMES[[kk]]
[08:25:50.235]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.235]                     next
[08:25:50.235]                   args[[name]] <- ""
[08:25:50.235]                 }
[08:25:50.235]                 NAMES <- toupper(removed)
[08:25:50.235]                 for (kk in seq_along(NAMES)) {
[08:25:50.235]                   name <- removed[[kk]]
[08:25:50.235]                   NAME <- NAMES[[kk]]
[08:25:50.235]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.235]                     next
[08:25:50.235]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.235]                 }
[08:25:50.235]                 if (length(args) > 0) 
[08:25:50.235]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.235]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.235]             }
[08:25:50.235]             else {
[08:25:50.235]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.235]             }
[08:25:50.235]             {
[08:25:50.235]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.235]                   0L) {
[08:25:50.235]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.235]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.235]                   base::options(opts)
[08:25:50.235]                 }
[08:25:50.235]                 {
[08:25:50.235]                   {
[08:25:50.235]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.235]                     NULL
[08:25:50.235]                   }
[08:25:50.235]                   options(future.plan = NULL)
[08:25:50.235]                   if (is.na(NA_character_)) 
[08:25:50.235]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.235]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.235]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.235]                     .init = FALSE)
[08:25:50.235]                 }
[08:25:50.235]             }
[08:25:50.235]         }
[08:25:50.235]     })
[08:25:50.235]     if (TRUE) {
[08:25:50.235]         base::sink(type = "output", split = FALSE)
[08:25:50.235]         if (TRUE) {
[08:25:50.235]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.235]         }
[08:25:50.235]         else {
[08:25:50.235]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.235]         }
[08:25:50.235]         base::close(...future.stdout)
[08:25:50.235]         ...future.stdout <- NULL
[08:25:50.235]     }
[08:25:50.235]     ...future.result$conditions <- ...future.conditions
[08:25:50.235]     ...future.result$finished <- base::Sys.time()
[08:25:50.235]     ...future.result
[08:25:50.235] }
[08:25:50.238] assign_globals() ...
[08:25:50.238] List of 5
[08:25:50.238]  $ ...future.FUN            :function (x, ...)  
[08:25:50.238]  $ MoreArgs                 : NULL
[08:25:50.238]  $ ...future.elements_ii    :List of 2
[08:25:50.238]   ..$ :List of 2
[08:25:50.238]   .. ..$ : int 3
[08:25:50.238]   .. ..$ : int 4
[08:25:50.238]   ..$ :List of 2
[08:25:50.238]   .. ..$ : int 2
[08:25:50.238]   .. ..$ : int 1
[08:25:50.238]  $ ...future.seeds_ii       : NULL
[08:25:50.238]  $ ...future.globals.maxSize: NULL
[08:25:50.238]  - attr(*, "where")=List of 5
[08:25:50.238]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.238]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.238]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.238]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.238]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.238]  - attr(*, "resolved")= logi FALSE
[08:25:50.238]  - attr(*, "total_size")= num 210
[08:25:50.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.238]  - attr(*, "already-done")= logi TRUE
[08:25:50.246] - copied ‘...future.FUN’ to environment
[08:25:50.246] - copied ‘MoreArgs’ to environment
[08:25:50.246] - copied ‘...future.elements_ii’ to environment
[08:25:50.246] - copied ‘...future.seeds_ii’ to environment
[08:25:50.246] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.246] assign_globals() ... done
[08:25:50.246] requestCore(): workers = 2
[08:25:50.249] MulticoreFuture started
[08:25:50.249] - Launch lazy future ... done
[08:25:50.249] run() for ‘MulticoreFuture’ ... done
[08:25:50.250] Created future:
[08:25:50.250] plan(): Setting new future strategy stack:
[08:25:50.250] List of future strategies:
[08:25:50.250] 1. sequential:
[08:25:50.250]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.250]    - tweaked: FALSE
[08:25:50.250]    - call: NULL
[08:25:50.251] plan(): nbrOfWorkers() = 1
[08:25:50.313] plan(): Setting new future strategy stack:
[08:25:50.313] List of future strategies:
[08:25:50.313] 1. multicore:
[08:25:50.313]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.313]    - tweaked: FALSE
[08:25:50.313]    - call: plan(strategy)
[08:25:50.315] plan(): nbrOfWorkers() = 2
[08:25:50.250] MulticoreFuture:
[08:25:50.250] Label: ‘future_mapply-2’
[08:25:50.250] Expression:
[08:25:50.250] {
[08:25:50.250]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.250]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.250]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.250]         on.exit(options(oopts), add = TRUE)
[08:25:50.250]     }
[08:25:50.250]     {
[08:25:50.250]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.250]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.250]         do.call(mapply, args = args)
[08:25:50.250]     }
[08:25:50.250] }
[08:25:50.250] Lazy evaluation: FALSE
[08:25:50.250] Asynchronous evaluation: TRUE
[08:25:50.250] Local evaluation: TRUE
[08:25:50.250] Environment: R_GlobalEnv
[08:25:50.250] Capture standard output: TRUE
[08:25:50.250] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.250] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.250] Packages: <none>
[08:25:50.250] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:50.250] Resolved: TRUE
[08:25:50.250] Value: <not collected>
[08:25:50.250] Conditions captured: <none>
[08:25:50.250] Early signaling: FALSE
[08:25:50.250] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.250] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.316] Chunk #2 of 2 ... DONE
[08:25:50.316] Launching 2 futures (chunks) ... DONE
[08:25:50.316] Resolving 2 futures (chunks) ...
[08:25:50.316] resolve() on list ...
[08:25:50.316]  recursive: 0
[08:25:50.316]  length: 2
[08:25:50.316] 
[08:25:50.317] Future #1
[08:25:50.317] result() for MulticoreFuture ...
[08:25:50.317] result() for MulticoreFuture ...
[08:25:50.317] result() for MulticoreFuture ... done
[08:25:50.318] result() for MulticoreFuture ... done
[08:25:50.318] result() for MulticoreFuture ...
[08:25:50.318] result() for MulticoreFuture ... done
[08:25:50.318] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:50.318] - nx: 2
[08:25:50.318] - relay: TRUE
[08:25:50.318] - stdout: TRUE
[08:25:50.318] - signal: TRUE
[08:25:50.318] - resignal: FALSE
[08:25:50.318] - force: TRUE
[08:25:50.318] - relayed: [n=2] FALSE, FALSE
[08:25:50.319] - queued futures: [n=2] FALSE, FALSE
[08:25:50.319]  - until=1
[08:25:50.319]  - relaying element #1
[08:25:50.319] result() for MulticoreFuture ...
[08:25:50.319] result() for MulticoreFuture ... done
[08:25:50.319] result() for MulticoreFuture ...
[08:25:50.319] result() for MulticoreFuture ... done
[08:25:50.319] result() for MulticoreFuture ...
[08:25:50.319] result() for MulticoreFuture ... done
[08:25:50.319] result() for MulticoreFuture ...
[08:25:50.319] result() for MulticoreFuture ... done
[08:25:50.320] - relayed: [n=2] TRUE, FALSE
[08:25:50.320] - queued futures: [n=2] TRUE, FALSE
[08:25:50.320] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:50.320]  length: 1 (resolved future 1)
[08:25:50.320] Future #2
[08:25:50.320] result() for MulticoreFuture ...
[08:25:50.321] result() for MulticoreFuture ...
[08:25:50.321] result() for MulticoreFuture ... done
[08:25:50.321] result() for MulticoreFuture ... done
[08:25:50.321] result() for MulticoreFuture ...
[08:25:50.321] result() for MulticoreFuture ... done
[08:25:50.321] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:50.321] - nx: 2
[08:25:50.321] - relay: TRUE
[08:25:50.321] - stdout: TRUE
[08:25:50.321] - signal: TRUE
[08:25:50.322] - resignal: FALSE
[08:25:50.322] - force: TRUE
[08:25:50.322] - relayed: [n=2] TRUE, FALSE
[08:25:50.322] - queued futures: [n=2] TRUE, FALSE
[08:25:50.322]  - until=2
[08:25:50.322]  - relaying element #2
[08:25:50.322] result() for MulticoreFuture ...
[08:25:50.322] result() for MulticoreFuture ... done
[08:25:50.322] result() for MulticoreFuture ...
[08:25:50.322] result() for MulticoreFuture ... done
[08:25:50.322] result() for MulticoreFuture ...
[08:25:50.323] result() for MulticoreFuture ... done
[08:25:50.323] result() for MulticoreFuture ...
[08:25:50.323] result() for MulticoreFuture ... done
[08:25:50.323] - relayed: [n=2] TRUE, TRUE
[08:25:50.323] - queued futures: [n=2] TRUE, TRUE
[08:25:50.323] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:50.323]  length: 0 (resolved future 2)
[08:25:50.323] Relaying remaining futures
[08:25:50.323] signalConditionsASAP(NULL, pos=0) ...
[08:25:50.323] - nx: 2
[08:25:50.323] - relay: TRUE
[08:25:50.323] - stdout: TRUE
[08:25:50.323] - signal: TRUE
[08:25:50.324] - resignal: FALSE
[08:25:50.324] - force: TRUE
[08:25:50.324] - relayed: [n=2] TRUE, TRUE
[08:25:50.324] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:50.324] - relayed: [n=2] TRUE, TRUE
[08:25:50.324] - queued futures: [n=2] TRUE, TRUE
[08:25:50.324] signalConditionsASAP(NULL, pos=0) ... done
[08:25:50.324] resolve() on list ... DONE
[08:25:50.324] result() for MulticoreFuture ...
[08:25:50.324] result() for MulticoreFuture ... done
[08:25:50.324] result() for MulticoreFuture ...
[08:25:50.325] result() for MulticoreFuture ... done
[08:25:50.325] result() for MulticoreFuture ...
[08:25:50.325] result() for MulticoreFuture ... done
[08:25:50.325] result() for MulticoreFuture ...
[08:25:50.325] result() for MulticoreFuture ... done
[08:25:50.325]  - Number of value chunks collected: 2
[08:25:50.325] Resolving 2 futures (chunks) ... DONE
[08:25:50.325] Reducing values from 2 chunks ...
[08:25:50.325]  - Number of values collected after concatenation: 4
[08:25:50.325]  - Number of values expected: 4
[08:25:50.325] Reducing values from 2 chunks ... DONE
[08:25:50.326] future_mapply() ... DONE
- Parallel RNG ...
[08:25:50.326] future_mapply() ...
[08:25:50.326] Generating random seeds ...
[08:25:50.326] Generating random seed streams for 4 elements ...
[08:25:50.326] Generating random seed streams for 4 elements ... DONE
[08:25:50.326] Generating random seeds ... DONE
[08:25:50.326] Will set RNG state on exit: 10407, -1439061041, -198447315, 1066786861, -1889642093, -529124813, 1644436578
[08:25:50.328] Number of chunks: 2
[08:25:50.328] getGlobalsAndPackagesXApply() ...
[08:25:50.328]  - future.globals: TRUE
[08:25:50.328] getGlobalsAndPackages() ...
[08:25:50.329] Searching for globals...
[08:25:50.330] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[08:25:50.330] Searching for globals ... DONE
[08:25:50.330] Resolving globals: FALSE
[08:25:50.331] The total size of the 1 globals is 501 bytes (501 bytes)
[08:25:50.331] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[08:25:50.331] - globals: [1] ‘FUN’
[08:25:50.331] - packages: [1] ‘stats’
[08:25:50.331] getGlobalsAndPackages() ... DONE
[08:25:50.331]  - globals found/used: [n=1] ‘FUN’
[08:25:50.332]  - needed namespaces: [n=1] ‘stats’
[08:25:50.332] Finding globals ... DONE
[08:25:50.332] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:50.332] List of 2
[08:25:50.332]  $ ...future.FUN:function (n, min = 0, max = 1)  
[08:25:50.332]  $ MoreArgs     :List of 1
[08:25:50.332]   ..$ min: num 1
[08:25:50.332]  - attr(*, "where")=List of 2
[08:25:50.332]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:50.332]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:50.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.332]  - attr(*, "resolved")= logi FALSE
[08:25:50.332]  - attr(*, "total_size")= num NA
[08:25:50.335] Packages to be attached in all futures: [n=1] ‘stats’
[08:25:50.335] getGlobalsAndPackagesXApply() ... DONE
[08:25:50.335] Number of futures (= number of chunks): 2
[08:25:50.335] Launching 2 futures (chunks) ...
[08:25:50.335] Chunk #1 of 2 ...
[08:25:50.335]  - Finding globals in '...' for chunk #1 ...
[08:25:50.336] getGlobalsAndPackages() ...
[08:25:50.336] Searching for globals...
[08:25:50.336] 
[08:25:50.336] Searching for globals ... DONE
[08:25:50.336] - globals: [0] <none>
[08:25:50.336] getGlobalsAndPackages() ... DONE
[08:25:50.336]    + additional globals found: [n=0] 
[08:25:50.336]    + additional namespaces needed: [n=0] 
[08:25:50.336]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:50.337]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.337]  - seeds: [2] <seeds>
[08:25:50.337]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.337] getGlobalsAndPackages() ...
[08:25:50.337] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.337] Resolving globals: FALSE
[08:25:50.337] The total size of the 5 globals is 870 bytes (870 bytes)
[08:25:50.338] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[08:25:50.338] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.338] - packages: [1] ‘stats’
[08:25:50.338] getGlobalsAndPackages() ... DONE
[08:25:50.339] run() for ‘Future’ ...
[08:25:50.339] - state: ‘created’
[08:25:50.339] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.341] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.341] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.341]   - Field: ‘label’
[08:25:50.341]   - Field: ‘local’
[08:25:50.341]   - Field: ‘owner’
[08:25:50.341]   - Field: ‘envir’
[08:25:50.341]   - Field: ‘workers’
[08:25:50.341]   - Field: ‘packages’
[08:25:50.341]   - Field: ‘gc’
[08:25:50.341]   - Field: ‘job’
[08:25:50.342]   - Field: ‘conditions’
[08:25:50.342]   - Field: ‘expr’
[08:25:50.342]   - Field: ‘uuid’
[08:25:50.342]   - Field: ‘seed’
[08:25:50.342]   - Field: ‘version’
[08:25:50.342]   - Field: ‘result’
[08:25:50.342]   - Field: ‘asynchronous’
[08:25:50.342]   - Field: ‘calls’
[08:25:50.342]   - Field: ‘globals’
[08:25:50.342]   - Field: ‘stdout’
[08:25:50.342]   - Field: ‘earlySignal’
[08:25:50.342]   - Field: ‘lazy’
[08:25:50.343]   - Field: ‘state’
[08:25:50.343] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.343] - Launch lazy future ...
[08:25:50.343] Packages needed by the future expression (n = 1): ‘stats’
[08:25:50.343] Packages needed by future strategies (n = 0): <none>
[08:25:50.344] {
[08:25:50.344]     {
[08:25:50.344]         {
[08:25:50.344]             ...future.startTime <- base::Sys.time()
[08:25:50.344]             {
[08:25:50.344]                 {
[08:25:50.344]                   {
[08:25:50.344]                     {
[08:25:50.344]                       {
[08:25:50.344]                         base::local({
[08:25:50.344]                           has_future <- base::requireNamespace("future", 
[08:25:50.344]                             quietly = TRUE)
[08:25:50.344]                           if (has_future) {
[08:25:50.344]                             ns <- base::getNamespace("future")
[08:25:50.344]                             version <- ns[[".package"]][["version"]]
[08:25:50.344]                             if (is.null(version)) 
[08:25:50.344]                               version <- utils::packageVersion("future")
[08:25:50.344]                           }
[08:25:50.344]                           else {
[08:25:50.344]                             version <- NULL
[08:25:50.344]                           }
[08:25:50.344]                           if (!has_future || version < "1.8.0") {
[08:25:50.344]                             info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.344]                               "", base::R.version$version.string), 
[08:25:50.344]                               platform = base::sprintf("%s (%s-bit)", 
[08:25:50.344]                                 base::R.version$platform, 8 * 
[08:25:50.344]                                   base::.Machine$sizeof.pointer), 
[08:25:50.344]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.344]                                 "release", "version")], collapse = " "), 
[08:25:50.344]                               hostname = base::Sys.info()[["nodename"]])
[08:25:50.344]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.344]                               info)
[08:25:50.344]                             info <- base::paste(info, collapse = "; ")
[08:25:50.344]                             if (!has_future) {
[08:25:50.344]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.344]                                 info)
[08:25:50.344]                             }
[08:25:50.344]                             else {
[08:25:50.344]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.344]                                 info, version)
[08:25:50.344]                             }
[08:25:50.344]                             base::stop(msg)
[08:25:50.344]                           }
[08:25:50.344]                         })
[08:25:50.344]                       }
[08:25:50.344]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.344]                       base::options(mc.cores = 1L)
[08:25:50.344]                     }
[08:25:50.344]                     base::local({
[08:25:50.344]                       for (pkg in "stats") {
[08:25:50.344]                         base::loadNamespace(pkg)
[08:25:50.344]                         base::library(pkg, character.only = TRUE)
[08:25:50.344]                       }
[08:25:50.344]                     })
[08:25:50.344]                   }
[08:25:50.344]                   ...future.strategy.old <- future::plan("list")
[08:25:50.344]                   options(future.plan = NULL)
[08:25:50.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.344]                 }
[08:25:50.344]                 ...future.workdir <- getwd()
[08:25:50.344]             }
[08:25:50.344]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.344]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.344]         }
[08:25:50.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.344]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.344]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.344]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.344]             base::names(...future.oldOptions))
[08:25:50.344]     }
[08:25:50.344]     if (FALSE) {
[08:25:50.344]     }
[08:25:50.344]     else {
[08:25:50.344]         if (TRUE) {
[08:25:50.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.344]                 open = "w")
[08:25:50.344]         }
[08:25:50.344]         else {
[08:25:50.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.344]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.344]         }
[08:25:50.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.344]             base::sink(type = "output", split = FALSE)
[08:25:50.344]             base::close(...future.stdout)
[08:25:50.344]         }, add = TRUE)
[08:25:50.344]     }
[08:25:50.344]     ...future.frame <- base::sys.nframe()
[08:25:50.344]     ...future.conditions <- base::list()
[08:25:50.344]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.344]     if (FALSE) {
[08:25:50.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.344]     }
[08:25:50.344]     ...future.result <- base::tryCatch({
[08:25:50.344]         base::withCallingHandlers({
[08:25:50.344]             ...future.value <- base::withVisible(base::local({
[08:25:50.344]                 withCallingHandlers({
[08:25:50.344]                   {
[08:25:50.344]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.344]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.344]                       ...future.globals.maxSize)) {
[08:25:50.344]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.344]                       on.exit(options(oopts), add = TRUE)
[08:25:50.344]                     }
[08:25:50.344]                     {
[08:25:50.344]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:50.344]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:50.344]                           envir = globalenv(), inherits = FALSE)
[08:25:50.344]                         ...future.FUN(...)
[08:25:50.344]                       }
[08:25:50.344]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:50.344]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:50.344]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.344]                         USE.NAMES = FALSE)
[08:25:50.344]                       do.call(mapply, args = args)
[08:25:50.344]                     }
[08:25:50.344]                   }
[08:25:50.344]                 }, immediateCondition = function(cond) {
[08:25:50.344]                   save_rds <- function (object, pathname, ...) 
[08:25:50.344]                   {
[08:25:50.344]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.344]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.344]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.344]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.344]                         fi_tmp[["mtime"]])
[08:25:50.344]                     }
[08:25:50.344]                     tryCatch({
[08:25:50.344]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.344]                     }, error = function(ex) {
[08:25:50.344]                       msg <- conditionMessage(ex)
[08:25:50.344]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.344]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.344]                         fi_tmp[["mtime"]], msg)
[08:25:50.344]                       ex$message <- msg
[08:25:50.344]                       stop(ex)
[08:25:50.344]                     })
[08:25:50.344]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.344]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.344]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.344]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.344]                       fi <- file.info(pathname)
[08:25:50.344]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.344]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.344]                         fi[["size"]], fi[["mtime"]])
[08:25:50.344]                       stop(msg)
[08:25:50.344]                     }
[08:25:50.344]                     invisible(pathname)
[08:25:50.344]                   }
[08:25:50.344]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.344]                     rootPath = tempdir()) 
[08:25:50.344]                   {
[08:25:50.344]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.344]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.344]                       tmpdir = path, fileext = ".rds")
[08:25:50.344]                     save_rds(obj, file)
[08:25:50.344]                   }
[08:25:50.344]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.344]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.344]                   {
[08:25:50.344]                     inherits <- base::inherits
[08:25:50.344]                     invokeRestart <- base::invokeRestart
[08:25:50.344]                     is.null <- base::is.null
[08:25:50.344]                     muffled <- FALSE
[08:25:50.344]                     if (inherits(cond, "message")) {
[08:25:50.344]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.344]                       if (muffled) 
[08:25:50.344]                         invokeRestart("muffleMessage")
[08:25:50.344]                     }
[08:25:50.344]                     else if (inherits(cond, "warning")) {
[08:25:50.344]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.344]                       if (muffled) 
[08:25:50.344]                         invokeRestart("muffleWarning")
[08:25:50.344]                     }
[08:25:50.344]                     else if (inherits(cond, "condition")) {
[08:25:50.344]                       if (!is.null(pattern)) {
[08:25:50.344]                         computeRestarts <- base::computeRestarts
[08:25:50.344]                         grepl <- base::grepl
[08:25:50.344]                         restarts <- computeRestarts(cond)
[08:25:50.344]                         for (restart in restarts) {
[08:25:50.344]                           name <- restart$name
[08:25:50.344]                           if (is.null(name)) 
[08:25:50.344]                             next
[08:25:50.344]                           if (!grepl(pattern, name)) 
[08:25:50.344]                             next
[08:25:50.344]                           invokeRestart(restart)
[08:25:50.344]                           muffled <- TRUE
[08:25:50.344]                           break
[08:25:50.344]                         }
[08:25:50.344]                       }
[08:25:50.344]                     }
[08:25:50.344]                     invisible(muffled)
[08:25:50.344]                   }
[08:25:50.344]                   muffleCondition(cond)
[08:25:50.344]                 })
[08:25:50.344]             }))
[08:25:50.344]             future::FutureResult(value = ...future.value$value, 
[08:25:50.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.344]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.344]                     ...future.globalenv.names))
[08:25:50.344]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.344]         }, condition = base::local({
[08:25:50.344]             c <- base::c
[08:25:50.344]             inherits <- base::inherits
[08:25:50.344]             invokeRestart <- base::invokeRestart
[08:25:50.344]             length <- base::length
[08:25:50.344]             list <- base::list
[08:25:50.344]             seq.int <- base::seq.int
[08:25:50.344]             signalCondition <- base::signalCondition
[08:25:50.344]             sys.calls <- base::sys.calls
[08:25:50.344]             `[[` <- base::`[[`
[08:25:50.344]             `+` <- base::`+`
[08:25:50.344]             `<<-` <- base::`<<-`
[08:25:50.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.344]                   3L)]
[08:25:50.344]             }
[08:25:50.344]             function(cond) {
[08:25:50.344]                 is_error <- inherits(cond, "error")
[08:25:50.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.344]                   NULL)
[08:25:50.344]                 if (is_error) {
[08:25:50.344]                   sessionInformation <- function() {
[08:25:50.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.344]                       search = base::search(), system = base::Sys.info())
[08:25:50.344]                   }
[08:25:50.344]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.344]                     cond$call), session = sessionInformation(), 
[08:25:50.344]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.344]                   signalCondition(cond)
[08:25:50.344]                 }
[08:25:50.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.344]                 "immediateCondition"))) {
[08:25:50.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.344]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.344]                   if (TRUE && !signal) {
[08:25:50.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.344]                     {
[08:25:50.344]                       inherits <- base::inherits
[08:25:50.344]                       invokeRestart <- base::invokeRestart
[08:25:50.344]                       is.null <- base::is.null
[08:25:50.344]                       muffled <- FALSE
[08:25:50.344]                       if (inherits(cond, "message")) {
[08:25:50.344]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.344]                         if (muffled) 
[08:25:50.344]                           invokeRestart("muffleMessage")
[08:25:50.344]                       }
[08:25:50.344]                       else if (inherits(cond, "warning")) {
[08:25:50.344]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.344]                         if (muffled) 
[08:25:50.344]                           invokeRestart("muffleWarning")
[08:25:50.344]                       }
[08:25:50.344]                       else if (inherits(cond, "condition")) {
[08:25:50.344]                         if (!is.null(pattern)) {
[08:25:50.344]                           computeRestarts <- base::computeRestarts
[08:25:50.344]                           grepl <- base::grepl
[08:25:50.344]                           restarts <- computeRestarts(cond)
[08:25:50.344]                           for (restart in restarts) {
[08:25:50.344]                             name <- restart$name
[08:25:50.344]                             if (is.null(name)) 
[08:25:50.344]                               next
[08:25:50.344]                             if (!grepl(pattern, name)) 
[08:25:50.344]                               next
[08:25:50.344]                             invokeRestart(restart)
[08:25:50.344]                             muffled <- TRUE
[08:25:50.344]                             break
[08:25:50.344]                           }
[08:25:50.344]                         }
[08:25:50.344]                       }
[08:25:50.344]                       invisible(muffled)
[08:25:50.344]                     }
[08:25:50.344]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.344]                   }
[08:25:50.344]                 }
[08:25:50.344]                 else {
[08:25:50.344]                   if (TRUE) {
[08:25:50.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.344]                     {
[08:25:50.344]                       inherits <- base::inherits
[08:25:50.344]                       invokeRestart <- base::invokeRestart
[08:25:50.344]                       is.null <- base::is.null
[08:25:50.344]                       muffled <- FALSE
[08:25:50.344]                       if (inherits(cond, "message")) {
[08:25:50.344]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.344]                         if (muffled) 
[08:25:50.344]                           invokeRestart("muffleMessage")
[08:25:50.344]                       }
[08:25:50.344]                       else if (inherits(cond, "warning")) {
[08:25:50.344]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.344]                         if (muffled) 
[08:25:50.344]                           invokeRestart("muffleWarning")
[08:25:50.344]                       }
[08:25:50.344]                       else if (inherits(cond, "condition")) {
[08:25:50.344]                         if (!is.null(pattern)) {
[08:25:50.344]                           computeRestarts <- base::computeRestarts
[08:25:50.344]                           grepl <- base::grepl
[08:25:50.344]                           restarts <- computeRestarts(cond)
[08:25:50.344]                           for (restart in restarts) {
[08:25:50.344]                             name <- restart$name
[08:25:50.344]                             if (is.null(name)) 
[08:25:50.344]                               next
[08:25:50.344]                             if (!grepl(pattern, name)) 
[08:25:50.344]                               next
[08:25:50.344]                             invokeRestart(restart)
[08:25:50.344]                             muffled <- TRUE
[08:25:50.344]                             break
[08:25:50.344]                           }
[08:25:50.344]                         }
[08:25:50.344]                       }
[08:25:50.344]                       invisible(muffled)
[08:25:50.344]                     }
[08:25:50.344]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.344]                   }
[08:25:50.344]                 }
[08:25:50.344]             }
[08:25:50.344]         }))
[08:25:50.344]     }, error = function(ex) {
[08:25:50.344]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.344]                 ...future.rng), started = ...future.startTime, 
[08:25:50.344]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.344]             version = "1.8"), class = "FutureResult")
[08:25:50.344]     }, finally = {
[08:25:50.344]         if (!identical(...future.workdir, getwd())) 
[08:25:50.344]             setwd(...future.workdir)
[08:25:50.344]         {
[08:25:50.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.344]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.344]             }
[08:25:50.344]             base::options(...future.oldOptions)
[08:25:50.344]             if (.Platform$OS.type == "windows") {
[08:25:50.344]                 old_names <- names(...future.oldEnvVars)
[08:25:50.344]                 envs <- base::Sys.getenv()
[08:25:50.344]                 names <- names(envs)
[08:25:50.344]                 common <- intersect(names, old_names)
[08:25:50.344]                 added <- setdiff(names, old_names)
[08:25:50.344]                 removed <- setdiff(old_names, names)
[08:25:50.344]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.344]                   envs[common]]
[08:25:50.344]                 NAMES <- toupper(changed)
[08:25:50.344]                 args <- list()
[08:25:50.344]                 for (kk in seq_along(NAMES)) {
[08:25:50.344]                   name <- changed[[kk]]
[08:25:50.344]                   NAME <- NAMES[[kk]]
[08:25:50.344]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.344]                     next
[08:25:50.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.344]                 }
[08:25:50.344]                 NAMES <- toupper(added)
[08:25:50.344]                 for (kk in seq_along(NAMES)) {
[08:25:50.344]                   name <- added[[kk]]
[08:25:50.344]                   NAME <- NAMES[[kk]]
[08:25:50.344]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.344]                     next
[08:25:50.344]                   args[[name]] <- ""
[08:25:50.344]                 }
[08:25:50.344]                 NAMES <- toupper(removed)
[08:25:50.344]                 for (kk in seq_along(NAMES)) {
[08:25:50.344]                   name <- removed[[kk]]
[08:25:50.344]                   NAME <- NAMES[[kk]]
[08:25:50.344]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.344]                     next
[08:25:50.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.344]                 }
[08:25:50.344]                 if (length(args) > 0) 
[08:25:50.344]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.344]             }
[08:25:50.344]             else {
[08:25:50.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.344]             }
[08:25:50.344]             {
[08:25:50.344]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.344]                   0L) {
[08:25:50.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.344]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.344]                   base::options(opts)
[08:25:50.344]                 }
[08:25:50.344]                 {
[08:25:50.344]                   {
[08:25:50.344]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.344]                     NULL
[08:25:50.344]                   }
[08:25:50.344]                   options(future.plan = NULL)
[08:25:50.344]                   if (is.na(NA_character_)) 
[08:25:50.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.344]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.344]                     .init = FALSE)
[08:25:50.344]                 }
[08:25:50.344]             }
[08:25:50.344]         }
[08:25:50.344]     })
[08:25:50.344]     if (TRUE) {
[08:25:50.344]         base::sink(type = "output", split = FALSE)
[08:25:50.344]         if (TRUE) {
[08:25:50.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.344]         }
[08:25:50.344]         else {
[08:25:50.344]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.344]         }
[08:25:50.344]         base::close(...future.stdout)
[08:25:50.344]         ...future.stdout <- NULL
[08:25:50.344]     }
[08:25:50.344]     ...future.result$conditions <- ...future.conditions
[08:25:50.344]     ...future.result$finished <- base::Sys.time()
[08:25:50.344]     ...future.result
[08:25:50.344] }
[08:25:50.346] assign_globals() ...
[08:25:50.346] List of 5
[08:25:50.346]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[08:25:50.346]  $ MoreArgs                 :List of 1
[08:25:50.346]   ..$ min: num 1
[08:25:50.346]  $ ...future.elements_ii    :List of 2
[08:25:50.346]   ..$ n  :List of 2
[08:25:50.346]   .. ..$ : int 1
[08:25:50.346]   .. ..$ : int 2
[08:25:50.346]   ..$ max:List of 2
[08:25:50.346]   .. ..$ : int 2
[08:25:50.346]   .. ..$ : int 3
[08:25:50.346]  $ ...future.seeds_ii       :List of 2
[08:25:50.346]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[08:25:50.346]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[08:25:50.346]  $ ...future.globals.maxSize: NULL
[08:25:50.346]  - attr(*, "where")=List of 5
[08:25:50.346]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.346]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.346]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.346]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.346]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.346]  - attr(*, "resolved")= logi FALSE
[08:25:50.346]  - attr(*, "total_size")= num 870
[08:25:50.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.346]  - attr(*, "already-done")= logi TRUE
[08:25:50.353] - copied ‘...future.FUN’ to environment
[08:25:50.353] - copied ‘MoreArgs’ to environment
[08:25:50.354] - copied ‘...future.elements_ii’ to environment
[08:25:50.354] - copied ‘...future.seeds_ii’ to environment
[08:25:50.354] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.354] assign_globals() ... done
[08:25:50.354] requestCore(): workers = 2
[08:25:50.356] MulticoreFuture started
[08:25:50.357] - Launch lazy future ... done
[08:25:50.357] run() for ‘MulticoreFuture’ ... done
[08:25:50.357] Created future:
[08:25:50.358] plan(): Setting new future strategy stack:
[08:25:50.358] List of future strategies:
[08:25:50.358] 1. sequential:
[08:25:50.358]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.358]    - tweaked: FALSE
[08:25:50.358]    - call: NULL
[08:25:50.359] plan(): nbrOfWorkers() = 1
[08:25:50.361] plan(): Setting new future strategy stack:
[08:25:50.361] List of future strategies:
[08:25:50.361] 1. multicore:
[08:25:50.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.361]    - tweaked: FALSE
[08:25:50.361]    - call: plan(strategy)
[08:25:50.364] plan(): nbrOfWorkers() = 2
[08:25:50.357] MulticoreFuture:
[08:25:50.357] Label: ‘future_mapply-1’
[08:25:50.357] Expression:
[08:25:50.357] {
[08:25:50.357]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.357]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.357]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.357]         on.exit(options(oopts), add = TRUE)
[08:25:50.357]     }
[08:25:50.357]     {
[08:25:50.357]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:50.357]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:50.357]                 inherits = FALSE)
[08:25:50.357]             ...future.FUN(...)
[08:25:50.357]         }
[08:25:50.357]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:50.357]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:50.357]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.357]         do.call(mapply, args = args)
[08:25:50.357]     }
[08:25:50.357] }
[08:25:50.357] Lazy evaluation: FALSE
[08:25:50.357] Asynchronous evaluation: TRUE
[08:25:50.357] Local evaluation: TRUE
[08:25:50.357] Environment: R_GlobalEnv
[08:25:50.357] Capture standard output: TRUE
[08:25:50.357] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.357] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.357] Packages: 1 packages (‘stats’)
[08:25:50.357] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:50.357] Resolved: TRUE
[08:25:50.357] Value: <not collected>
[08:25:50.357] Conditions captured: <none>
[08:25:50.357] Early signaling: FALSE
[08:25:50.357] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.357] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.365] Chunk #1 of 2 ... DONE
[08:25:50.365] Chunk #2 of 2 ...
[08:25:50.366]  - Finding globals in '...' for chunk #2 ...
[08:25:50.366] getGlobalsAndPackages() ...
[08:25:50.366] Searching for globals...
[08:25:50.366] 
[08:25:50.367] Searching for globals ... DONE
[08:25:50.367] - globals: [0] <none>
[08:25:50.367] getGlobalsAndPackages() ... DONE
[08:25:50.367]    + additional globals found: [n=0] 
[08:25:50.367]    + additional namespaces needed: [n=0] 
[08:25:50.367]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:50.367]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.367]  - seeds: [2] <seeds>
[08:25:50.368]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.368] getGlobalsAndPackages() ...
[08:25:50.368] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.368] Resolving globals: FALSE
[08:25:50.369] The total size of the 5 globals is 870 bytes (870 bytes)
[08:25:50.369] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[08:25:50.370] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.370] - packages: [1] ‘stats’
[08:25:50.370] getGlobalsAndPackages() ... DONE
[08:25:50.370] run() for ‘Future’ ...
[08:25:50.371] - state: ‘created’
[08:25:50.371] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.373] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.373] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.373]   - Field: ‘label’
[08:25:50.374]   - Field: ‘local’
[08:25:50.374]   - Field: ‘owner’
[08:25:50.374]   - Field: ‘envir’
[08:25:50.374]   - Field: ‘workers’
[08:25:50.374]   - Field: ‘packages’
[08:25:50.374]   - Field: ‘gc’
[08:25:50.374]   - Field: ‘job’
[08:25:50.374]   - Field: ‘conditions’
[08:25:50.375]   - Field: ‘expr’
[08:25:50.375]   - Field: ‘uuid’
[08:25:50.375]   - Field: ‘seed’
[08:25:50.375]   - Field: ‘version’
[08:25:50.375]   - Field: ‘result’
[08:25:50.375]   - Field: ‘asynchronous’
[08:25:50.375]   - Field: ‘calls’
[08:25:50.375]   - Field: ‘globals’
[08:25:50.375]   - Field: ‘stdout’
[08:25:50.376]   - Field: ‘earlySignal’
[08:25:50.376]   - Field: ‘lazy’
[08:25:50.376]   - Field: ‘state’
[08:25:50.376] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.376] - Launch lazy future ...
[08:25:50.376] Packages needed by the future expression (n = 1): ‘stats’
[08:25:50.377] Packages needed by future strategies (n = 0): <none>
[08:25:50.378] {
[08:25:50.378]     {
[08:25:50.378]         {
[08:25:50.378]             ...future.startTime <- base::Sys.time()
[08:25:50.378]             {
[08:25:50.378]                 {
[08:25:50.378]                   {
[08:25:50.378]                     {
[08:25:50.378]                       {
[08:25:50.378]                         base::local({
[08:25:50.378]                           has_future <- base::requireNamespace("future", 
[08:25:50.378]                             quietly = TRUE)
[08:25:50.378]                           if (has_future) {
[08:25:50.378]                             ns <- base::getNamespace("future")
[08:25:50.378]                             version <- ns[[".package"]][["version"]]
[08:25:50.378]                             if (is.null(version)) 
[08:25:50.378]                               version <- utils::packageVersion("future")
[08:25:50.378]                           }
[08:25:50.378]                           else {
[08:25:50.378]                             version <- NULL
[08:25:50.378]                           }
[08:25:50.378]                           if (!has_future || version < "1.8.0") {
[08:25:50.378]                             info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.378]                               "", base::R.version$version.string), 
[08:25:50.378]                               platform = base::sprintf("%s (%s-bit)", 
[08:25:50.378]                                 base::R.version$platform, 8 * 
[08:25:50.378]                                   base::.Machine$sizeof.pointer), 
[08:25:50.378]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.378]                                 "release", "version")], collapse = " "), 
[08:25:50.378]                               hostname = base::Sys.info()[["nodename"]])
[08:25:50.378]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.378]                               info)
[08:25:50.378]                             info <- base::paste(info, collapse = "; ")
[08:25:50.378]                             if (!has_future) {
[08:25:50.378]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.378]                                 info)
[08:25:50.378]                             }
[08:25:50.378]                             else {
[08:25:50.378]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.378]                                 info, version)
[08:25:50.378]                             }
[08:25:50.378]                             base::stop(msg)
[08:25:50.378]                           }
[08:25:50.378]                         })
[08:25:50.378]                       }
[08:25:50.378]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.378]                       base::options(mc.cores = 1L)
[08:25:50.378]                     }
[08:25:50.378]                     base::local({
[08:25:50.378]                       for (pkg in "stats") {
[08:25:50.378]                         base::loadNamespace(pkg)
[08:25:50.378]                         base::library(pkg, character.only = TRUE)
[08:25:50.378]                       }
[08:25:50.378]                     })
[08:25:50.378]                   }
[08:25:50.378]                   ...future.strategy.old <- future::plan("list")
[08:25:50.378]                   options(future.plan = NULL)
[08:25:50.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.378]                 }
[08:25:50.378]                 ...future.workdir <- getwd()
[08:25:50.378]             }
[08:25:50.378]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.378]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.378]         }
[08:25:50.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.378]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.378]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.378]             base::names(...future.oldOptions))
[08:25:50.378]     }
[08:25:50.378]     if (FALSE) {
[08:25:50.378]     }
[08:25:50.378]     else {
[08:25:50.378]         if (TRUE) {
[08:25:50.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.378]                 open = "w")
[08:25:50.378]         }
[08:25:50.378]         else {
[08:25:50.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.378]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.378]         }
[08:25:50.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.378]             base::sink(type = "output", split = FALSE)
[08:25:50.378]             base::close(...future.stdout)
[08:25:50.378]         }, add = TRUE)
[08:25:50.378]     }
[08:25:50.378]     ...future.frame <- base::sys.nframe()
[08:25:50.378]     ...future.conditions <- base::list()
[08:25:50.378]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.378]     if (FALSE) {
[08:25:50.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.378]     }
[08:25:50.378]     ...future.result <- base::tryCatch({
[08:25:50.378]         base::withCallingHandlers({
[08:25:50.378]             ...future.value <- base::withVisible(base::local({
[08:25:50.378]                 withCallingHandlers({
[08:25:50.378]                   {
[08:25:50.378]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.378]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.378]                       ...future.globals.maxSize)) {
[08:25:50.378]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.378]                       on.exit(options(oopts), add = TRUE)
[08:25:50.378]                     }
[08:25:50.378]                     {
[08:25:50.378]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:50.378]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:50.378]                           envir = globalenv(), inherits = FALSE)
[08:25:50.378]                         ...future.FUN(...)
[08:25:50.378]                       }
[08:25:50.378]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:50.378]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:50.378]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.378]                         USE.NAMES = FALSE)
[08:25:50.378]                       do.call(mapply, args = args)
[08:25:50.378]                     }
[08:25:50.378]                   }
[08:25:50.378]                 }, immediateCondition = function(cond) {
[08:25:50.378]                   save_rds <- function (object, pathname, ...) 
[08:25:50.378]                   {
[08:25:50.378]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.378]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.378]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.378]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.378]                         fi_tmp[["mtime"]])
[08:25:50.378]                     }
[08:25:50.378]                     tryCatch({
[08:25:50.378]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.378]                     }, error = function(ex) {
[08:25:50.378]                       msg <- conditionMessage(ex)
[08:25:50.378]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.378]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.378]                         fi_tmp[["mtime"]], msg)
[08:25:50.378]                       ex$message <- msg
[08:25:50.378]                       stop(ex)
[08:25:50.378]                     })
[08:25:50.378]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.378]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.378]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.378]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.378]                       fi <- file.info(pathname)
[08:25:50.378]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.378]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.378]                         fi[["size"]], fi[["mtime"]])
[08:25:50.378]                       stop(msg)
[08:25:50.378]                     }
[08:25:50.378]                     invisible(pathname)
[08:25:50.378]                   }
[08:25:50.378]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.378]                     rootPath = tempdir()) 
[08:25:50.378]                   {
[08:25:50.378]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.378]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.378]                       tmpdir = path, fileext = ".rds")
[08:25:50.378]                     save_rds(obj, file)
[08:25:50.378]                   }
[08:25:50.378]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.378]                   {
[08:25:50.378]                     inherits <- base::inherits
[08:25:50.378]                     invokeRestart <- base::invokeRestart
[08:25:50.378]                     is.null <- base::is.null
[08:25:50.378]                     muffled <- FALSE
[08:25:50.378]                     if (inherits(cond, "message")) {
[08:25:50.378]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.378]                       if (muffled) 
[08:25:50.378]                         invokeRestart("muffleMessage")
[08:25:50.378]                     }
[08:25:50.378]                     else if (inherits(cond, "warning")) {
[08:25:50.378]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.378]                       if (muffled) 
[08:25:50.378]                         invokeRestart("muffleWarning")
[08:25:50.378]                     }
[08:25:50.378]                     else if (inherits(cond, "condition")) {
[08:25:50.378]                       if (!is.null(pattern)) {
[08:25:50.378]                         computeRestarts <- base::computeRestarts
[08:25:50.378]                         grepl <- base::grepl
[08:25:50.378]                         restarts <- computeRestarts(cond)
[08:25:50.378]                         for (restart in restarts) {
[08:25:50.378]                           name <- restart$name
[08:25:50.378]                           if (is.null(name)) 
[08:25:50.378]                             next
[08:25:50.378]                           if (!grepl(pattern, name)) 
[08:25:50.378]                             next
[08:25:50.378]                           invokeRestart(restart)
[08:25:50.378]                           muffled <- TRUE
[08:25:50.378]                           break
[08:25:50.378]                         }
[08:25:50.378]                       }
[08:25:50.378]                     }
[08:25:50.378]                     invisible(muffled)
[08:25:50.378]                   }
[08:25:50.378]                   muffleCondition(cond)
[08:25:50.378]                 })
[08:25:50.378]             }))
[08:25:50.378]             future::FutureResult(value = ...future.value$value, 
[08:25:50.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.378]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.378]                     ...future.globalenv.names))
[08:25:50.378]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.378]         }, condition = base::local({
[08:25:50.378]             c <- base::c
[08:25:50.378]             inherits <- base::inherits
[08:25:50.378]             invokeRestart <- base::invokeRestart
[08:25:50.378]             length <- base::length
[08:25:50.378]             list <- base::list
[08:25:50.378]             seq.int <- base::seq.int
[08:25:50.378]             signalCondition <- base::signalCondition
[08:25:50.378]             sys.calls <- base::sys.calls
[08:25:50.378]             `[[` <- base::`[[`
[08:25:50.378]             `+` <- base::`+`
[08:25:50.378]             `<<-` <- base::`<<-`
[08:25:50.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.378]                   3L)]
[08:25:50.378]             }
[08:25:50.378]             function(cond) {
[08:25:50.378]                 is_error <- inherits(cond, "error")
[08:25:50.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.378]                   NULL)
[08:25:50.378]                 if (is_error) {
[08:25:50.378]                   sessionInformation <- function() {
[08:25:50.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.378]                       search = base::search(), system = base::Sys.info())
[08:25:50.378]                   }
[08:25:50.378]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.378]                     cond$call), session = sessionInformation(), 
[08:25:50.378]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.378]                   signalCondition(cond)
[08:25:50.378]                 }
[08:25:50.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.378]                 "immediateCondition"))) {
[08:25:50.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.378]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.378]                   if (TRUE && !signal) {
[08:25:50.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.378]                     {
[08:25:50.378]                       inherits <- base::inherits
[08:25:50.378]                       invokeRestart <- base::invokeRestart
[08:25:50.378]                       is.null <- base::is.null
[08:25:50.378]                       muffled <- FALSE
[08:25:50.378]                       if (inherits(cond, "message")) {
[08:25:50.378]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.378]                         if (muffled) 
[08:25:50.378]                           invokeRestart("muffleMessage")
[08:25:50.378]                       }
[08:25:50.378]                       else if (inherits(cond, "warning")) {
[08:25:50.378]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.378]                         if (muffled) 
[08:25:50.378]                           invokeRestart("muffleWarning")
[08:25:50.378]                       }
[08:25:50.378]                       else if (inherits(cond, "condition")) {
[08:25:50.378]                         if (!is.null(pattern)) {
[08:25:50.378]                           computeRestarts <- base::computeRestarts
[08:25:50.378]                           grepl <- base::grepl
[08:25:50.378]                           restarts <- computeRestarts(cond)
[08:25:50.378]                           for (restart in restarts) {
[08:25:50.378]                             name <- restart$name
[08:25:50.378]                             if (is.null(name)) 
[08:25:50.378]                               next
[08:25:50.378]                             if (!grepl(pattern, name)) 
[08:25:50.378]                               next
[08:25:50.378]                             invokeRestart(restart)
[08:25:50.378]                             muffled <- TRUE
[08:25:50.378]                             break
[08:25:50.378]                           }
[08:25:50.378]                         }
[08:25:50.378]                       }
[08:25:50.378]                       invisible(muffled)
[08:25:50.378]                     }
[08:25:50.378]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.378]                   }
[08:25:50.378]                 }
[08:25:50.378]                 else {
[08:25:50.378]                   if (TRUE) {
[08:25:50.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.378]                     {
[08:25:50.378]                       inherits <- base::inherits
[08:25:50.378]                       invokeRestart <- base::invokeRestart
[08:25:50.378]                       is.null <- base::is.null
[08:25:50.378]                       muffled <- FALSE
[08:25:50.378]                       if (inherits(cond, "message")) {
[08:25:50.378]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.378]                         if (muffled) 
[08:25:50.378]                           invokeRestart("muffleMessage")
[08:25:50.378]                       }
[08:25:50.378]                       else if (inherits(cond, "warning")) {
[08:25:50.378]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.378]                         if (muffled) 
[08:25:50.378]                           invokeRestart("muffleWarning")
[08:25:50.378]                       }
[08:25:50.378]                       else if (inherits(cond, "condition")) {
[08:25:50.378]                         if (!is.null(pattern)) {
[08:25:50.378]                           computeRestarts <- base::computeRestarts
[08:25:50.378]                           grepl <- base::grepl
[08:25:50.378]                           restarts <- computeRestarts(cond)
[08:25:50.378]                           for (restart in restarts) {
[08:25:50.378]                             name <- restart$name
[08:25:50.378]                             if (is.null(name)) 
[08:25:50.378]                               next
[08:25:50.378]                             if (!grepl(pattern, name)) 
[08:25:50.378]                               next
[08:25:50.378]                             invokeRestart(restart)
[08:25:50.378]                             muffled <- TRUE
[08:25:50.378]                             break
[08:25:50.378]                           }
[08:25:50.378]                         }
[08:25:50.378]                       }
[08:25:50.378]                       invisible(muffled)
[08:25:50.378]                     }
[08:25:50.378]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.378]                   }
[08:25:50.378]                 }
[08:25:50.378]             }
[08:25:50.378]         }))
[08:25:50.378]     }, error = function(ex) {
[08:25:50.378]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.378]                 ...future.rng), started = ...future.startTime, 
[08:25:50.378]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.378]             version = "1.8"), class = "FutureResult")
[08:25:50.378]     }, finally = {
[08:25:50.378]         if (!identical(...future.workdir, getwd())) 
[08:25:50.378]             setwd(...future.workdir)
[08:25:50.378]         {
[08:25:50.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.378]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.378]             }
[08:25:50.378]             base::options(...future.oldOptions)
[08:25:50.378]             if (.Platform$OS.type == "windows") {
[08:25:50.378]                 old_names <- names(...future.oldEnvVars)
[08:25:50.378]                 envs <- base::Sys.getenv()
[08:25:50.378]                 names <- names(envs)
[08:25:50.378]                 common <- intersect(names, old_names)
[08:25:50.378]                 added <- setdiff(names, old_names)
[08:25:50.378]                 removed <- setdiff(old_names, names)
[08:25:50.378]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.378]                   envs[common]]
[08:25:50.378]                 NAMES <- toupper(changed)
[08:25:50.378]                 args <- list()
[08:25:50.378]                 for (kk in seq_along(NAMES)) {
[08:25:50.378]                   name <- changed[[kk]]
[08:25:50.378]                   NAME <- NAMES[[kk]]
[08:25:50.378]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.378]                     next
[08:25:50.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.378]                 }
[08:25:50.378]                 NAMES <- toupper(added)
[08:25:50.378]                 for (kk in seq_along(NAMES)) {
[08:25:50.378]                   name <- added[[kk]]
[08:25:50.378]                   NAME <- NAMES[[kk]]
[08:25:50.378]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.378]                     next
[08:25:50.378]                   args[[name]] <- ""
[08:25:50.378]                 }
[08:25:50.378]                 NAMES <- toupper(removed)
[08:25:50.378]                 for (kk in seq_along(NAMES)) {
[08:25:50.378]                   name <- removed[[kk]]
[08:25:50.378]                   NAME <- NAMES[[kk]]
[08:25:50.378]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.378]                     next
[08:25:50.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.378]                 }
[08:25:50.378]                 if (length(args) > 0) 
[08:25:50.378]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.378]             }
[08:25:50.378]             else {
[08:25:50.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.378]             }
[08:25:50.378]             {
[08:25:50.378]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.378]                   0L) {
[08:25:50.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.378]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.378]                   base::options(opts)
[08:25:50.378]                 }
[08:25:50.378]                 {
[08:25:50.378]                   {
[08:25:50.378]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.378]                     NULL
[08:25:50.378]                   }
[08:25:50.378]                   options(future.plan = NULL)
[08:25:50.378]                   if (is.na(NA_character_)) 
[08:25:50.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.378]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.378]                     .init = FALSE)
[08:25:50.378]                 }
[08:25:50.378]             }
[08:25:50.378]         }
[08:25:50.378]     })
[08:25:50.378]     if (TRUE) {
[08:25:50.378]         base::sink(type = "output", split = FALSE)
[08:25:50.378]         if (TRUE) {
[08:25:50.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.378]         }
[08:25:50.378]         else {
[08:25:50.378]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.378]         }
[08:25:50.378]         base::close(...future.stdout)
[08:25:50.378]         ...future.stdout <- NULL
[08:25:50.378]     }
[08:25:50.378]     ...future.result$conditions <- ...future.conditions
[08:25:50.378]     ...future.result$finished <- base::Sys.time()
[08:25:50.378]     ...future.result
[08:25:50.378] }
[08:25:50.381] assign_globals() ...
[08:25:50.381] List of 5
[08:25:50.381]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[08:25:50.381]  $ MoreArgs                 :List of 1
[08:25:50.381]   ..$ min: num 1
[08:25:50.381]  $ ...future.elements_ii    :List of 2
[08:25:50.381]   ..$ n  :List of 2
[08:25:50.381]   .. ..$ : int 3
[08:25:50.381]   .. ..$ : int 4
[08:25:50.381]   ..$ max:List of 2
[08:25:50.381]   .. ..$ : int 4
[08:25:50.381]   .. ..$ : int 5
[08:25:50.381]  $ ...future.seeds_ii       :List of 2
[08:25:50.381]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[08:25:50.381]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[08:25:50.381]  $ ...future.globals.maxSize: NULL
[08:25:50.381]  - attr(*, "where")=List of 5
[08:25:50.381]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.381]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.381]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.381]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.381]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.381]  - attr(*, "resolved")= logi FALSE
[08:25:50.381]  - attr(*, "total_size")= num 870
[08:25:50.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.381]  - attr(*, "already-done")= logi TRUE
[08:25:50.390] - copied ‘...future.FUN’ to environment
[08:25:50.391] - copied ‘MoreArgs’ to environment
[08:25:50.391] - copied ‘...future.elements_ii’ to environment
[08:25:50.391] - copied ‘...future.seeds_ii’ to environment
[08:25:50.391] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.391] assign_globals() ... done
[08:25:50.391] requestCore(): workers = 2
[08:25:50.394] MulticoreFuture started
[08:25:50.394] - Launch lazy future ... done
[08:25:50.394] run() for ‘MulticoreFuture’ ... done
[08:25:50.395] Created future:
[08:25:50.395] plan(): Setting new future strategy stack:
[08:25:50.396] List of future strategies:
[08:25:50.396] 1. sequential:
[08:25:50.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.396]    - tweaked: FALSE
[08:25:50.396]    - call: NULL
[08:25:50.397] plan(): nbrOfWorkers() = 1
[08:25:50.399] plan(): Setting new future strategy stack:
[08:25:50.399] List of future strategies:
[08:25:50.399] 1. multicore:
[08:25:50.399]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.399]    - tweaked: FALSE
[08:25:50.399]    - call: plan(strategy)
[08:25:50.402] plan(): nbrOfWorkers() = 2
[08:25:50.395] MulticoreFuture:
[08:25:50.395] Label: ‘future_mapply-2’
[08:25:50.395] Expression:
[08:25:50.395] {
[08:25:50.395]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.395]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.395]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.395]         on.exit(options(oopts), add = TRUE)
[08:25:50.395]     }
[08:25:50.395]     {
[08:25:50.395]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:50.395]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:50.395]                 inherits = FALSE)
[08:25:50.395]             ...future.FUN(...)
[08:25:50.395]         }
[08:25:50.395]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:50.395]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:50.395]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.395]         do.call(mapply, args = args)
[08:25:50.395]     }
[08:25:50.395] }
[08:25:50.395] Lazy evaluation: FALSE
[08:25:50.395] Asynchronous evaluation: TRUE
[08:25:50.395] Local evaluation: TRUE
[08:25:50.395] Environment: R_GlobalEnv
[08:25:50.395] Capture standard output: TRUE
[08:25:50.395] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.395] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.395] Packages: 1 packages (‘stats’)
[08:25:50.395] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:50.395] Resolved: TRUE
[08:25:50.395] Value: <not collected>
[08:25:50.395] Conditions captured: <none>
[08:25:50.395] Early signaling: FALSE
[08:25:50.395] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.395] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.403] Chunk #2 of 2 ... DONE
[08:25:50.403] Launching 2 futures (chunks) ... DONE
[08:25:50.403] Resolving 2 futures (chunks) ...
[08:25:50.404] resolve() on list ...
[08:25:50.404]  recursive: 0
[08:25:50.404]  length: 2
[08:25:50.404] 
[08:25:50.404] Future #1
[08:25:50.404] result() for MulticoreFuture ...
[08:25:50.405] result() for MulticoreFuture ...
[08:25:50.406] result() for MulticoreFuture ... done
[08:25:50.406] result() for MulticoreFuture ... done
[08:25:50.406] result() for MulticoreFuture ...
[08:25:50.406] result() for MulticoreFuture ... done
[08:25:50.406] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:50.406] - nx: 2
[08:25:50.406] - relay: TRUE
[08:25:50.406] - stdout: TRUE
[08:25:50.407] - signal: TRUE
[08:25:50.407] - resignal: FALSE
[08:25:50.407] - force: TRUE
[08:25:50.407] - relayed: [n=2] FALSE, FALSE
[08:25:50.407] - queued futures: [n=2] FALSE, FALSE
[08:25:50.407]  - until=1
[08:25:50.407]  - relaying element #1
[08:25:50.407] result() for MulticoreFuture ...
[08:25:50.408] result() for MulticoreFuture ... done
[08:25:50.408] result() for MulticoreFuture ...
[08:25:50.408] result() for MulticoreFuture ... done
[08:25:50.408] result() for MulticoreFuture ...
[08:25:50.408] result() for MulticoreFuture ... done
[08:25:50.408] result() for MulticoreFuture ...
[08:25:50.408] result() for MulticoreFuture ... done
[08:25:50.408] - relayed: [n=2] TRUE, FALSE
[08:25:50.409] - queued futures: [n=2] TRUE, FALSE
[08:25:50.409] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:50.409]  length: 1 (resolved future 1)
[08:25:50.409] Future #2
[08:25:50.409] result() for MulticoreFuture ...
[08:25:50.410] result() for MulticoreFuture ...
[08:25:50.410] result() for MulticoreFuture ... done
[08:25:50.410] result() for MulticoreFuture ... done
[08:25:50.410] result() for MulticoreFuture ...
[08:25:50.411] result() for MulticoreFuture ... done
[08:25:50.411] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:50.411] - nx: 2
[08:25:50.411] - relay: TRUE
[08:25:50.411] - stdout: TRUE
[08:25:50.411] - signal: TRUE
[08:25:50.411] - resignal: FALSE
[08:25:50.411] - force: TRUE
[08:25:50.411] - relayed: [n=2] TRUE, FALSE
[08:25:50.412] - queued futures: [n=2] TRUE, FALSE
[08:25:50.412]  - until=2
[08:25:50.412]  - relaying element #2
[08:25:50.412] result() for MulticoreFuture ...
[08:25:50.412] result() for MulticoreFuture ... done
[08:25:50.412] result() for MulticoreFuture ...
[08:25:50.412] result() for MulticoreFuture ... done
[08:25:50.412] result() for MulticoreFuture ...
[08:25:50.413] result() for MulticoreFuture ... done
[08:25:50.413] result() for MulticoreFuture ...
[08:25:50.413] result() for MulticoreFuture ... done
[08:25:50.413] - relayed: [n=2] TRUE, TRUE
[08:25:50.413] - queued futures: [n=2] TRUE, TRUE
[08:25:50.413] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:50.413]  length: 0 (resolved future 2)
[08:25:50.413] Relaying remaining futures
[08:25:50.414] signalConditionsASAP(NULL, pos=0) ...
[08:25:50.414] - nx: 2
[08:25:50.414] - relay: TRUE
[08:25:50.414] - stdout: TRUE
[08:25:50.414] - signal: TRUE
[08:25:50.414] - resignal: FALSE
[08:25:50.414] - force: TRUE
[08:25:50.414] - relayed: [n=2] TRUE, TRUE
[08:25:50.414] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:50.415] - relayed: [n=2] TRUE, TRUE
[08:25:50.415] - queued futures: [n=2] TRUE, TRUE
[08:25:50.415] signalConditionsASAP(NULL, pos=0) ... done
[08:25:50.415] resolve() on list ... DONE
[08:25:50.415] result() for MulticoreFuture ...
[08:25:50.415] result() for MulticoreFuture ... done
[08:25:50.415] result() for MulticoreFuture ...
[08:25:50.415] result() for MulticoreFuture ... done
[08:25:50.416] result() for MulticoreFuture ...
[08:25:50.416] result() for MulticoreFuture ... done
[08:25:50.416] result() for MulticoreFuture ...
[08:25:50.416] result() for MulticoreFuture ... done
[08:25:50.416]  - Number of value chunks collected: 2
[08:25:50.416] Resolving 2 futures (chunks) ... DONE
[08:25:50.416] Reducing values from 2 chunks ...
[08:25:50.416]  - Number of values collected after concatenation: 4
[08:25:50.417]  - Number of values expected: 4
[08:25:50.417] Reducing values from 2 chunks ... DONE
[08:25:50.417] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[08:25:50.418] future_mapply() ...
[08:25:50.420] Number of chunks: 2
[08:25:50.420] getGlobalsAndPackagesXApply() ...
[08:25:50.420]  - future.globals: TRUE
[08:25:50.421] getGlobalsAndPackages() ...
[08:25:50.421] Searching for globals...
[08:25:50.422] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:25:50.423] Searching for globals ... DONE
[08:25:50.423] Resolving globals: FALSE
[08:25:50.423] The total size of the 1 globals is 337 bytes (337 bytes)
[08:25:50.424] The total size of the 1 globals exported for future expression (‘FUN()’) is 337 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (337 bytes of class ‘function’)
[08:25:50.424] - globals: [1] ‘FUN’
[08:25:50.424] - packages: [1] ‘stats’
[08:25:50.424] getGlobalsAndPackages() ... DONE
[08:25:50.424]  - globals found/used: [n=1] ‘FUN’
[08:25:50.424]  - needed namespaces: [n=1] ‘stats’
[08:25:50.425] Finding globals ... DONE
[08:25:50.425] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:50.425] List of 2
[08:25:50.425]  $ ...future.FUN:function (x, w, ...)  
[08:25:50.425]  $ MoreArgs     : NULL
[08:25:50.425]  - attr(*, "where")=List of 2
[08:25:50.425]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:50.425]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:50.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.425]  - attr(*, "resolved")= logi FALSE
[08:25:50.425]  - attr(*, "total_size")= num NA
[08:25:50.428] Packages to be attached in all futures: [n=1] ‘stats’
[08:25:50.428] getGlobalsAndPackagesXApply() ... DONE
[08:25:50.429] Number of futures (= number of chunks): 2
[08:25:50.429] Launching 2 futures (chunks) ...
[08:25:50.429] Chunk #1 of 2 ...
[08:25:50.429]  - Finding globals in '...' for chunk #1 ...
[08:25:50.429] getGlobalsAndPackages() ...
[08:25:50.429] Searching for globals...
[08:25:50.430] 
[08:25:50.430] Searching for globals ... DONE
[08:25:50.430] - globals: [0] <none>
[08:25:50.430] getGlobalsAndPackages() ... DONE
[08:25:50.430]    + additional globals found: [n=0] 
[08:25:50.430]    + additional namespaces needed: [n=0] 
[08:25:50.431]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:50.431]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.431]  - seeds: <none>
[08:25:50.431]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.431] getGlobalsAndPackages() ...
[08:25:50.431] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.431] Resolving globals: FALSE
[08:25:50.432] The total size of the 5 globals is 817 bytes (817 bytes)
[08:25:50.432] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 817 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (399 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:50.433] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.435] - packages: [1] ‘stats’
[08:25:50.435] getGlobalsAndPackages() ... DONE
[08:25:50.436] run() for ‘Future’ ...
[08:25:50.436] - state: ‘created’
[08:25:50.436] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.438] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.438]   - Field: ‘label’
[08:25:50.438]   - Field: ‘local’
[08:25:50.438]   - Field: ‘owner’
[08:25:50.439]   - Field: ‘envir’
[08:25:50.439]   - Field: ‘workers’
[08:25:50.439]   - Field: ‘packages’
[08:25:50.439]   - Field: ‘gc’
[08:25:50.439]   - Field: ‘job’
[08:25:50.439]   - Field: ‘conditions’
[08:25:50.439]   - Field: ‘expr’
[08:25:50.439]   - Field: ‘uuid’
[08:25:50.439]   - Field: ‘seed’
[08:25:50.440]   - Field: ‘version’
[08:25:50.440]   - Field: ‘result’
[08:25:50.440]   - Field: ‘asynchronous’
[08:25:50.440]   - Field: ‘calls’
[08:25:50.440]   - Field: ‘globals’
[08:25:50.440]   - Field: ‘stdout’
[08:25:50.440]   - Field: ‘earlySignal’
[08:25:50.440]   - Field: ‘lazy’
[08:25:50.440]   - Field: ‘state’
[08:25:50.440] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.441] - Launch lazy future ...
[08:25:50.441] Packages needed by the future expression (n = 1): ‘stats’
[08:25:50.441] Packages needed by future strategies (n = 0): <none>
[08:25:50.442] {
[08:25:50.442]     {
[08:25:50.442]         {
[08:25:50.442]             ...future.startTime <- base::Sys.time()
[08:25:50.442]             {
[08:25:50.442]                 {
[08:25:50.442]                   {
[08:25:50.442]                     {
[08:25:50.442]                       {
[08:25:50.442]                         base::local({
[08:25:50.442]                           has_future <- base::requireNamespace("future", 
[08:25:50.442]                             quietly = TRUE)
[08:25:50.442]                           if (has_future) {
[08:25:50.442]                             ns <- base::getNamespace("future")
[08:25:50.442]                             version <- ns[[".package"]][["version"]]
[08:25:50.442]                             if (is.null(version)) 
[08:25:50.442]                               version <- utils::packageVersion("future")
[08:25:50.442]                           }
[08:25:50.442]                           else {
[08:25:50.442]                             version <- NULL
[08:25:50.442]                           }
[08:25:50.442]                           if (!has_future || version < "1.8.0") {
[08:25:50.442]                             info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.442]                               "", base::R.version$version.string), 
[08:25:50.442]                               platform = base::sprintf("%s (%s-bit)", 
[08:25:50.442]                                 base::R.version$platform, 8 * 
[08:25:50.442]                                   base::.Machine$sizeof.pointer), 
[08:25:50.442]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.442]                                 "release", "version")], collapse = " "), 
[08:25:50.442]                               hostname = base::Sys.info()[["nodename"]])
[08:25:50.442]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.442]                               info)
[08:25:50.442]                             info <- base::paste(info, collapse = "; ")
[08:25:50.442]                             if (!has_future) {
[08:25:50.442]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.442]                                 info)
[08:25:50.442]                             }
[08:25:50.442]                             else {
[08:25:50.442]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.442]                                 info, version)
[08:25:50.442]                             }
[08:25:50.442]                             base::stop(msg)
[08:25:50.442]                           }
[08:25:50.442]                         })
[08:25:50.442]                       }
[08:25:50.442]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.442]                       base::options(mc.cores = 1L)
[08:25:50.442]                     }
[08:25:50.442]                     base::local({
[08:25:50.442]                       for (pkg in "stats") {
[08:25:50.442]                         base::loadNamespace(pkg)
[08:25:50.442]                         base::library(pkg, character.only = TRUE)
[08:25:50.442]                       }
[08:25:50.442]                     })
[08:25:50.442]                   }
[08:25:50.442]                   ...future.strategy.old <- future::plan("list")
[08:25:50.442]                   options(future.plan = NULL)
[08:25:50.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.442]                 }
[08:25:50.442]                 ...future.workdir <- getwd()
[08:25:50.442]             }
[08:25:50.442]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.442]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.442]         }
[08:25:50.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.442]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.442]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.442]             base::names(...future.oldOptions))
[08:25:50.442]     }
[08:25:50.442]     if (FALSE) {
[08:25:50.442]     }
[08:25:50.442]     else {
[08:25:50.442]         if (TRUE) {
[08:25:50.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.442]                 open = "w")
[08:25:50.442]         }
[08:25:50.442]         else {
[08:25:50.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.442]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.442]         }
[08:25:50.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.442]             base::sink(type = "output", split = FALSE)
[08:25:50.442]             base::close(...future.stdout)
[08:25:50.442]         }, add = TRUE)
[08:25:50.442]     }
[08:25:50.442]     ...future.frame <- base::sys.nframe()
[08:25:50.442]     ...future.conditions <- base::list()
[08:25:50.442]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.442]     if (FALSE) {
[08:25:50.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.442]     }
[08:25:50.442]     ...future.result <- base::tryCatch({
[08:25:50.442]         base::withCallingHandlers({
[08:25:50.442]             ...future.value <- base::withVisible(base::local({
[08:25:50.442]                 withCallingHandlers({
[08:25:50.442]                   {
[08:25:50.442]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.442]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.442]                       ...future.globals.maxSize)) {
[08:25:50.442]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.442]                       on.exit(options(oopts), add = TRUE)
[08:25:50.442]                     }
[08:25:50.442]                     {
[08:25:50.442]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.442]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.442]                         USE.NAMES = FALSE)
[08:25:50.442]                       do.call(mapply, args = args)
[08:25:50.442]                     }
[08:25:50.442]                   }
[08:25:50.442]                 }, immediateCondition = function(cond) {
[08:25:50.442]                   save_rds <- function (object, pathname, ...) 
[08:25:50.442]                   {
[08:25:50.442]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.442]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.442]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.442]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.442]                         fi_tmp[["mtime"]])
[08:25:50.442]                     }
[08:25:50.442]                     tryCatch({
[08:25:50.442]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.442]                     }, error = function(ex) {
[08:25:50.442]                       msg <- conditionMessage(ex)
[08:25:50.442]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.442]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.442]                         fi_tmp[["mtime"]], msg)
[08:25:50.442]                       ex$message <- msg
[08:25:50.442]                       stop(ex)
[08:25:50.442]                     })
[08:25:50.442]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.442]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.442]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.442]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.442]                       fi <- file.info(pathname)
[08:25:50.442]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.442]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.442]                         fi[["size"]], fi[["mtime"]])
[08:25:50.442]                       stop(msg)
[08:25:50.442]                     }
[08:25:50.442]                     invisible(pathname)
[08:25:50.442]                   }
[08:25:50.442]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.442]                     rootPath = tempdir()) 
[08:25:50.442]                   {
[08:25:50.442]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.442]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.442]                       tmpdir = path, fileext = ".rds")
[08:25:50.442]                     save_rds(obj, file)
[08:25:50.442]                   }
[08:25:50.442]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.442]                   {
[08:25:50.442]                     inherits <- base::inherits
[08:25:50.442]                     invokeRestart <- base::invokeRestart
[08:25:50.442]                     is.null <- base::is.null
[08:25:50.442]                     muffled <- FALSE
[08:25:50.442]                     if (inherits(cond, "message")) {
[08:25:50.442]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.442]                       if (muffled) 
[08:25:50.442]                         invokeRestart("muffleMessage")
[08:25:50.442]                     }
[08:25:50.442]                     else if (inherits(cond, "warning")) {
[08:25:50.442]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.442]                       if (muffled) 
[08:25:50.442]                         invokeRestart("muffleWarning")
[08:25:50.442]                     }
[08:25:50.442]                     else if (inherits(cond, "condition")) {
[08:25:50.442]                       if (!is.null(pattern)) {
[08:25:50.442]                         computeRestarts <- base::computeRestarts
[08:25:50.442]                         grepl <- base::grepl
[08:25:50.442]                         restarts <- computeRestarts(cond)
[08:25:50.442]                         for (restart in restarts) {
[08:25:50.442]                           name <- restart$name
[08:25:50.442]                           if (is.null(name)) 
[08:25:50.442]                             next
[08:25:50.442]                           if (!grepl(pattern, name)) 
[08:25:50.442]                             next
[08:25:50.442]                           invokeRestart(restart)
[08:25:50.442]                           muffled <- TRUE
[08:25:50.442]                           break
[08:25:50.442]                         }
[08:25:50.442]                       }
[08:25:50.442]                     }
[08:25:50.442]                     invisible(muffled)
[08:25:50.442]                   }
[08:25:50.442]                   muffleCondition(cond)
[08:25:50.442]                 })
[08:25:50.442]             }))
[08:25:50.442]             future::FutureResult(value = ...future.value$value, 
[08:25:50.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.442]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.442]                     ...future.globalenv.names))
[08:25:50.442]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.442]         }, condition = base::local({
[08:25:50.442]             c <- base::c
[08:25:50.442]             inherits <- base::inherits
[08:25:50.442]             invokeRestart <- base::invokeRestart
[08:25:50.442]             length <- base::length
[08:25:50.442]             list <- base::list
[08:25:50.442]             seq.int <- base::seq.int
[08:25:50.442]             signalCondition <- base::signalCondition
[08:25:50.442]             sys.calls <- base::sys.calls
[08:25:50.442]             `[[` <- base::`[[`
[08:25:50.442]             `+` <- base::`+`
[08:25:50.442]             `<<-` <- base::`<<-`
[08:25:50.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.442]                   3L)]
[08:25:50.442]             }
[08:25:50.442]             function(cond) {
[08:25:50.442]                 is_error <- inherits(cond, "error")
[08:25:50.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.442]                   NULL)
[08:25:50.442]                 if (is_error) {
[08:25:50.442]                   sessionInformation <- function() {
[08:25:50.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.442]                       search = base::search(), system = base::Sys.info())
[08:25:50.442]                   }
[08:25:50.442]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.442]                     cond$call), session = sessionInformation(), 
[08:25:50.442]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.442]                   signalCondition(cond)
[08:25:50.442]                 }
[08:25:50.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.442]                 "immediateCondition"))) {
[08:25:50.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.442]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.442]                   if (TRUE && !signal) {
[08:25:50.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.442]                     {
[08:25:50.442]                       inherits <- base::inherits
[08:25:50.442]                       invokeRestart <- base::invokeRestart
[08:25:50.442]                       is.null <- base::is.null
[08:25:50.442]                       muffled <- FALSE
[08:25:50.442]                       if (inherits(cond, "message")) {
[08:25:50.442]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.442]                         if (muffled) 
[08:25:50.442]                           invokeRestart("muffleMessage")
[08:25:50.442]                       }
[08:25:50.442]                       else if (inherits(cond, "warning")) {
[08:25:50.442]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.442]                         if (muffled) 
[08:25:50.442]                           invokeRestart("muffleWarning")
[08:25:50.442]                       }
[08:25:50.442]                       else if (inherits(cond, "condition")) {
[08:25:50.442]                         if (!is.null(pattern)) {
[08:25:50.442]                           computeRestarts <- base::computeRestarts
[08:25:50.442]                           grepl <- base::grepl
[08:25:50.442]                           restarts <- computeRestarts(cond)
[08:25:50.442]                           for (restart in restarts) {
[08:25:50.442]                             name <- restart$name
[08:25:50.442]                             if (is.null(name)) 
[08:25:50.442]                               next
[08:25:50.442]                             if (!grepl(pattern, name)) 
[08:25:50.442]                               next
[08:25:50.442]                             invokeRestart(restart)
[08:25:50.442]                             muffled <- TRUE
[08:25:50.442]                             break
[08:25:50.442]                           }
[08:25:50.442]                         }
[08:25:50.442]                       }
[08:25:50.442]                       invisible(muffled)
[08:25:50.442]                     }
[08:25:50.442]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.442]                   }
[08:25:50.442]                 }
[08:25:50.442]                 else {
[08:25:50.442]                   if (TRUE) {
[08:25:50.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.442]                     {
[08:25:50.442]                       inherits <- base::inherits
[08:25:50.442]                       invokeRestart <- base::invokeRestart
[08:25:50.442]                       is.null <- base::is.null
[08:25:50.442]                       muffled <- FALSE
[08:25:50.442]                       if (inherits(cond, "message")) {
[08:25:50.442]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.442]                         if (muffled) 
[08:25:50.442]                           invokeRestart("muffleMessage")
[08:25:50.442]                       }
[08:25:50.442]                       else if (inherits(cond, "warning")) {
[08:25:50.442]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.442]                         if (muffled) 
[08:25:50.442]                           invokeRestart("muffleWarning")
[08:25:50.442]                       }
[08:25:50.442]                       else if (inherits(cond, "condition")) {
[08:25:50.442]                         if (!is.null(pattern)) {
[08:25:50.442]                           computeRestarts <- base::computeRestarts
[08:25:50.442]                           grepl <- base::grepl
[08:25:50.442]                           restarts <- computeRestarts(cond)
[08:25:50.442]                           for (restart in restarts) {
[08:25:50.442]                             name <- restart$name
[08:25:50.442]                             if (is.null(name)) 
[08:25:50.442]                               next
[08:25:50.442]                             if (!grepl(pattern, name)) 
[08:25:50.442]                               next
[08:25:50.442]                             invokeRestart(restart)
[08:25:50.442]                             muffled <- TRUE
[08:25:50.442]                             break
[08:25:50.442]                           }
[08:25:50.442]                         }
[08:25:50.442]                       }
[08:25:50.442]                       invisible(muffled)
[08:25:50.442]                     }
[08:25:50.442]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.442]                   }
[08:25:50.442]                 }
[08:25:50.442]             }
[08:25:50.442]         }))
[08:25:50.442]     }, error = function(ex) {
[08:25:50.442]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.442]                 ...future.rng), started = ...future.startTime, 
[08:25:50.442]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.442]             version = "1.8"), class = "FutureResult")
[08:25:50.442]     }, finally = {
[08:25:50.442]         if (!identical(...future.workdir, getwd())) 
[08:25:50.442]             setwd(...future.workdir)
[08:25:50.442]         {
[08:25:50.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.442]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.442]             }
[08:25:50.442]             base::options(...future.oldOptions)
[08:25:50.442]             if (.Platform$OS.type == "windows") {
[08:25:50.442]                 old_names <- names(...future.oldEnvVars)
[08:25:50.442]                 envs <- base::Sys.getenv()
[08:25:50.442]                 names <- names(envs)
[08:25:50.442]                 common <- intersect(names, old_names)
[08:25:50.442]                 added <- setdiff(names, old_names)
[08:25:50.442]                 removed <- setdiff(old_names, names)
[08:25:50.442]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.442]                   envs[common]]
[08:25:50.442]                 NAMES <- toupper(changed)
[08:25:50.442]                 args <- list()
[08:25:50.442]                 for (kk in seq_along(NAMES)) {
[08:25:50.442]                   name <- changed[[kk]]
[08:25:50.442]                   NAME <- NAMES[[kk]]
[08:25:50.442]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.442]                     next
[08:25:50.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.442]                 }
[08:25:50.442]                 NAMES <- toupper(added)
[08:25:50.442]                 for (kk in seq_along(NAMES)) {
[08:25:50.442]                   name <- added[[kk]]
[08:25:50.442]                   NAME <- NAMES[[kk]]
[08:25:50.442]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.442]                     next
[08:25:50.442]                   args[[name]] <- ""
[08:25:50.442]                 }
[08:25:50.442]                 NAMES <- toupper(removed)
[08:25:50.442]                 for (kk in seq_along(NAMES)) {
[08:25:50.442]                   name <- removed[[kk]]
[08:25:50.442]                   NAME <- NAMES[[kk]]
[08:25:50.442]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.442]                     next
[08:25:50.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.442]                 }
[08:25:50.442]                 if (length(args) > 0) 
[08:25:50.442]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.442]             }
[08:25:50.442]             else {
[08:25:50.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.442]             }
[08:25:50.442]             {
[08:25:50.442]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.442]                   0L) {
[08:25:50.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.442]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.442]                   base::options(opts)
[08:25:50.442]                 }
[08:25:50.442]                 {
[08:25:50.442]                   {
[08:25:50.442]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.442]                     NULL
[08:25:50.442]                   }
[08:25:50.442]                   options(future.plan = NULL)
[08:25:50.442]                   if (is.na(NA_character_)) 
[08:25:50.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.442]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.442]                     .init = FALSE)
[08:25:50.442]                 }
[08:25:50.442]             }
[08:25:50.442]         }
[08:25:50.442]     })
[08:25:50.442]     if (TRUE) {
[08:25:50.442]         base::sink(type = "output", split = FALSE)
[08:25:50.442]         if (TRUE) {
[08:25:50.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.442]         }
[08:25:50.442]         else {
[08:25:50.442]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.442]         }
[08:25:50.442]         base::close(...future.stdout)
[08:25:50.442]         ...future.stdout <- NULL
[08:25:50.442]     }
[08:25:50.442]     ...future.result$conditions <- ...future.conditions
[08:25:50.442]     ...future.result$finished <- base::Sys.time()
[08:25:50.442]     ...future.result
[08:25:50.442] }
[08:25:50.444] assign_globals() ...
[08:25:50.444] List of 5
[08:25:50.444]  $ ...future.FUN            :function (x, w, ...)  
[08:25:50.444]  $ MoreArgs                 : NULL
[08:25:50.444]  $ ...future.elements_ii    :List of 2
[08:25:50.444]   ..$ :List of 2
[08:25:50.444]   .. ..$ : num [1:10] 0.751 0.565 0.329 0.499 0.727 ...
[08:25:50.444]   .. ..$ : num [1:10] 0.102 0.923 0.862 0.382 0.817 ...
[08:25:50.444]   ..$ :List of 2
[08:25:50.444]   .. ..$ : num [1:10] 3 5 10 6 5 5 6 9 2 4
[08:25:50.444]   .. ..$ : num [1:10] 8 8 7 6 6 6 6 5 5 6
[08:25:50.444]  $ ...future.seeds_ii       : NULL
[08:25:50.444]  $ ...future.globals.maxSize: NULL
[08:25:50.444]  - attr(*, "where")=List of 5
[08:25:50.444]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.444]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.444]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.444]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.444]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.444]  - attr(*, "resolved")= logi FALSE
[08:25:50.444]  - attr(*, "total_size")= num 817
[08:25:50.444]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.444]  - attr(*, "already-done")= logi TRUE
[08:25:50.451] - copied ‘...future.FUN’ to environment
[08:25:50.451] - copied ‘MoreArgs’ to environment
[08:25:50.451] - copied ‘...future.elements_ii’ to environment
[08:25:50.451] - copied ‘...future.seeds_ii’ to environment
[08:25:50.451] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.451] assign_globals() ... done
[08:25:50.451] requestCore(): workers = 2
[08:25:50.454] MulticoreFuture started
[08:25:50.455] - Launch lazy future ... done
[08:25:50.455] run() for ‘MulticoreFuture’ ... done
[08:25:50.455] Created future:
[08:25:50.456] plan(): Setting new future strategy stack:
[08:25:50.456] List of future strategies:
[08:25:50.456] 1. sequential:
[08:25:50.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.456]    - tweaked: FALSE
[08:25:50.456]    - call: NULL
[08:25:50.457] plan(): nbrOfWorkers() = 1
[08:25:50.459] plan(): Setting new future strategy stack:
[08:25:50.459] List of future strategies:
[08:25:50.459] 1. multicore:
[08:25:50.459]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.459]    - tweaked: FALSE
[08:25:50.459]    - call: plan(strategy)
[08:25:50.463] plan(): nbrOfWorkers() = 2
[08:25:50.455] MulticoreFuture:
[08:25:50.455] Label: ‘future_Map-1’
[08:25:50.455] Expression:
[08:25:50.455] {
[08:25:50.455]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.455]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.455]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.455]         on.exit(options(oopts), add = TRUE)
[08:25:50.455]     }
[08:25:50.455]     {
[08:25:50.455]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.455]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.455]         do.call(mapply, args = args)
[08:25:50.455]     }
[08:25:50.455] }
[08:25:50.455] Lazy evaluation: FALSE
[08:25:50.455] Asynchronous evaluation: TRUE
[08:25:50.455] Local evaluation: TRUE
[08:25:50.455] Environment: R_GlobalEnv
[08:25:50.455] Capture standard output: TRUE
[08:25:50.455] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.455] Globals: 5 objects totaling 817 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 399 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.455] Packages: 1 packages (‘stats’)
[08:25:50.455] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:50.455] Resolved: TRUE
[08:25:50.455] Value: <not collected>
[08:25:50.455] Conditions captured: <none>
[08:25:50.455] Early signaling: FALSE
[08:25:50.455] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.455] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.464] Chunk #1 of 2 ... DONE
[08:25:50.464] Chunk #2 of 2 ...
[08:25:50.464]  - Finding globals in '...' for chunk #2 ...
[08:25:50.464] getGlobalsAndPackages() ...
[08:25:50.464] Searching for globals...
[08:25:50.465] 
[08:25:50.465] Searching for globals ... DONE
[08:25:50.465] - globals: [0] <none>
[08:25:50.465] getGlobalsAndPackages() ... DONE
[08:25:50.465]    + additional globals found: [n=0] 
[08:25:50.465]    + additional namespaces needed: [n=0] 
[08:25:50.465]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:50.466]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.466]  - seeds: <none>
[08:25:50.466]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.466] getGlobalsAndPackages() ...
[08:25:50.466] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.466] Resolving globals: FALSE
[08:25:50.467] The total size of the 5 globals is 993 bytes (993 bytes)
[08:25:50.468] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 993 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (575 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:50.468] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.468] - packages: [1] ‘stats’
[08:25:50.468] getGlobalsAndPackages() ... DONE
[08:25:50.469] run() for ‘Future’ ...
[08:25:50.469] - state: ‘created’
[08:25:50.469] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.472] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.472]   - Field: ‘label’
[08:25:50.472]   - Field: ‘local’
[08:25:50.473]   - Field: ‘owner’
[08:25:50.473]   - Field: ‘envir’
[08:25:50.473]   - Field: ‘workers’
[08:25:50.473]   - Field: ‘packages’
[08:25:50.473]   - Field: ‘gc’
[08:25:50.473]   - Field: ‘job’
[08:25:50.473]   - Field: ‘conditions’
[08:25:50.473]   - Field: ‘expr’
[08:25:50.474]   - Field: ‘uuid’
[08:25:50.474]   - Field: ‘seed’
[08:25:50.474]   - Field: ‘version’
[08:25:50.474]   - Field: ‘result’
[08:25:50.474]   - Field: ‘asynchronous’
[08:25:50.474]   - Field: ‘calls’
[08:25:50.474]   - Field: ‘globals’
[08:25:50.475]   - Field: ‘stdout’
[08:25:50.475]   - Field: ‘earlySignal’
[08:25:50.475]   - Field: ‘lazy’
[08:25:50.475]   - Field: ‘state’
[08:25:50.475] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.476] - Launch lazy future ...
[08:25:50.476] Packages needed by the future expression (n = 1): ‘stats’
[08:25:50.476] Packages needed by future strategies (n = 0): <none>
[08:25:50.477] {
[08:25:50.477]     {
[08:25:50.477]         {
[08:25:50.477]             ...future.startTime <- base::Sys.time()
[08:25:50.477]             {
[08:25:50.477]                 {
[08:25:50.477]                   {
[08:25:50.477]                     {
[08:25:50.477]                       {
[08:25:50.477]                         base::local({
[08:25:50.477]                           has_future <- base::requireNamespace("future", 
[08:25:50.477]                             quietly = TRUE)
[08:25:50.477]                           if (has_future) {
[08:25:50.477]                             ns <- base::getNamespace("future")
[08:25:50.477]                             version <- ns[[".package"]][["version"]]
[08:25:50.477]                             if (is.null(version)) 
[08:25:50.477]                               version <- utils::packageVersion("future")
[08:25:50.477]                           }
[08:25:50.477]                           else {
[08:25:50.477]                             version <- NULL
[08:25:50.477]                           }
[08:25:50.477]                           if (!has_future || version < "1.8.0") {
[08:25:50.477]                             info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.477]                               "", base::R.version$version.string), 
[08:25:50.477]                               platform = base::sprintf("%s (%s-bit)", 
[08:25:50.477]                                 base::R.version$platform, 8 * 
[08:25:50.477]                                   base::.Machine$sizeof.pointer), 
[08:25:50.477]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.477]                                 "release", "version")], collapse = " "), 
[08:25:50.477]                               hostname = base::Sys.info()[["nodename"]])
[08:25:50.477]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.477]                               info)
[08:25:50.477]                             info <- base::paste(info, collapse = "; ")
[08:25:50.477]                             if (!has_future) {
[08:25:50.477]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.477]                                 info)
[08:25:50.477]                             }
[08:25:50.477]                             else {
[08:25:50.477]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.477]                                 info, version)
[08:25:50.477]                             }
[08:25:50.477]                             base::stop(msg)
[08:25:50.477]                           }
[08:25:50.477]                         })
[08:25:50.477]                       }
[08:25:50.477]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.477]                       base::options(mc.cores = 1L)
[08:25:50.477]                     }
[08:25:50.477]                     base::local({
[08:25:50.477]                       for (pkg in "stats") {
[08:25:50.477]                         base::loadNamespace(pkg)
[08:25:50.477]                         base::library(pkg, character.only = TRUE)
[08:25:50.477]                       }
[08:25:50.477]                     })
[08:25:50.477]                   }
[08:25:50.477]                   ...future.strategy.old <- future::plan("list")
[08:25:50.477]                   options(future.plan = NULL)
[08:25:50.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.477]                 }
[08:25:50.477]                 ...future.workdir <- getwd()
[08:25:50.477]             }
[08:25:50.477]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.477]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.477]         }
[08:25:50.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.477]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.477]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.477]             base::names(...future.oldOptions))
[08:25:50.477]     }
[08:25:50.477]     if (FALSE) {
[08:25:50.477]     }
[08:25:50.477]     else {
[08:25:50.477]         if (TRUE) {
[08:25:50.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.477]                 open = "w")
[08:25:50.477]         }
[08:25:50.477]         else {
[08:25:50.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.477]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.477]         }
[08:25:50.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.477]             base::sink(type = "output", split = FALSE)
[08:25:50.477]             base::close(...future.stdout)
[08:25:50.477]         }, add = TRUE)
[08:25:50.477]     }
[08:25:50.477]     ...future.frame <- base::sys.nframe()
[08:25:50.477]     ...future.conditions <- base::list()
[08:25:50.477]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.477]     if (FALSE) {
[08:25:50.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.477]     }
[08:25:50.477]     ...future.result <- base::tryCatch({
[08:25:50.477]         base::withCallingHandlers({
[08:25:50.477]             ...future.value <- base::withVisible(base::local({
[08:25:50.477]                 withCallingHandlers({
[08:25:50.477]                   {
[08:25:50.477]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.477]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.477]                       ...future.globals.maxSize)) {
[08:25:50.477]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.477]                       on.exit(options(oopts), add = TRUE)
[08:25:50.477]                     }
[08:25:50.477]                     {
[08:25:50.477]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.477]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.477]                         USE.NAMES = FALSE)
[08:25:50.477]                       do.call(mapply, args = args)
[08:25:50.477]                     }
[08:25:50.477]                   }
[08:25:50.477]                 }, immediateCondition = function(cond) {
[08:25:50.477]                   save_rds <- function (object, pathname, ...) 
[08:25:50.477]                   {
[08:25:50.477]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.477]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.477]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.477]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.477]                         fi_tmp[["mtime"]])
[08:25:50.477]                     }
[08:25:50.477]                     tryCatch({
[08:25:50.477]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.477]                     }, error = function(ex) {
[08:25:50.477]                       msg <- conditionMessage(ex)
[08:25:50.477]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.477]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.477]                         fi_tmp[["mtime"]], msg)
[08:25:50.477]                       ex$message <- msg
[08:25:50.477]                       stop(ex)
[08:25:50.477]                     })
[08:25:50.477]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.477]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.477]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.477]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.477]                       fi <- file.info(pathname)
[08:25:50.477]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.477]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.477]                         fi[["size"]], fi[["mtime"]])
[08:25:50.477]                       stop(msg)
[08:25:50.477]                     }
[08:25:50.477]                     invisible(pathname)
[08:25:50.477]                   }
[08:25:50.477]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.477]                     rootPath = tempdir()) 
[08:25:50.477]                   {
[08:25:50.477]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.477]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.477]                       tmpdir = path, fileext = ".rds")
[08:25:50.477]                     save_rds(obj, file)
[08:25:50.477]                   }
[08:25:50.477]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.477]                   {
[08:25:50.477]                     inherits <- base::inherits
[08:25:50.477]                     invokeRestart <- base::invokeRestart
[08:25:50.477]                     is.null <- base::is.null
[08:25:50.477]                     muffled <- FALSE
[08:25:50.477]                     if (inherits(cond, "message")) {
[08:25:50.477]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.477]                       if (muffled) 
[08:25:50.477]                         invokeRestart("muffleMessage")
[08:25:50.477]                     }
[08:25:50.477]                     else if (inherits(cond, "warning")) {
[08:25:50.477]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.477]                       if (muffled) 
[08:25:50.477]                         invokeRestart("muffleWarning")
[08:25:50.477]                     }
[08:25:50.477]                     else if (inherits(cond, "condition")) {
[08:25:50.477]                       if (!is.null(pattern)) {
[08:25:50.477]                         computeRestarts <- base::computeRestarts
[08:25:50.477]                         grepl <- base::grepl
[08:25:50.477]                         restarts <- computeRestarts(cond)
[08:25:50.477]                         for (restart in restarts) {
[08:25:50.477]                           name <- restart$name
[08:25:50.477]                           if (is.null(name)) 
[08:25:50.477]                             next
[08:25:50.477]                           if (!grepl(pattern, name)) 
[08:25:50.477]                             next
[08:25:50.477]                           invokeRestart(restart)
[08:25:50.477]                           muffled <- TRUE
[08:25:50.477]                           break
[08:25:50.477]                         }
[08:25:50.477]                       }
[08:25:50.477]                     }
[08:25:50.477]                     invisible(muffled)
[08:25:50.477]                   }
[08:25:50.477]                   muffleCondition(cond)
[08:25:50.477]                 })
[08:25:50.477]             }))
[08:25:50.477]             future::FutureResult(value = ...future.value$value, 
[08:25:50.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.477]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.477]                     ...future.globalenv.names))
[08:25:50.477]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.477]         }, condition = base::local({
[08:25:50.477]             c <- base::c
[08:25:50.477]             inherits <- base::inherits
[08:25:50.477]             invokeRestart <- base::invokeRestart
[08:25:50.477]             length <- base::length
[08:25:50.477]             list <- base::list
[08:25:50.477]             seq.int <- base::seq.int
[08:25:50.477]             signalCondition <- base::signalCondition
[08:25:50.477]             sys.calls <- base::sys.calls
[08:25:50.477]             `[[` <- base::`[[`
[08:25:50.477]             `+` <- base::`+`
[08:25:50.477]             `<<-` <- base::`<<-`
[08:25:50.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.477]                   3L)]
[08:25:50.477]             }
[08:25:50.477]             function(cond) {
[08:25:50.477]                 is_error <- inherits(cond, "error")
[08:25:50.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.477]                   NULL)
[08:25:50.477]                 if (is_error) {
[08:25:50.477]                   sessionInformation <- function() {
[08:25:50.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.477]                       search = base::search(), system = base::Sys.info())
[08:25:50.477]                   }
[08:25:50.477]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.477]                     cond$call), session = sessionInformation(), 
[08:25:50.477]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.477]                   signalCondition(cond)
[08:25:50.477]                 }
[08:25:50.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.477]                 "immediateCondition"))) {
[08:25:50.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.477]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.477]                   if (TRUE && !signal) {
[08:25:50.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.477]                     {
[08:25:50.477]                       inherits <- base::inherits
[08:25:50.477]                       invokeRestart <- base::invokeRestart
[08:25:50.477]                       is.null <- base::is.null
[08:25:50.477]                       muffled <- FALSE
[08:25:50.477]                       if (inherits(cond, "message")) {
[08:25:50.477]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.477]                         if (muffled) 
[08:25:50.477]                           invokeRestart("muffleMessage")
[08:25:50.477]                       }
[08:25:50.477]                       else if (inherits(cond, "warning")) {
[08:25:50.477]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.477]                         if (muffled) 
[08:25:50.477]                           invokeRestart("muffleWarning")
[08:25:50.477]                       }
[08:25:50.477]                       else if (inherits(cond, "condition")) {
[08:25:50.477]                         if (!is.null(pattern)) {
[08:25:50.477]                           computeRestarts <- base::computeRestarts
[08:25:50.477]                           grepl <- base::grepl
[08:25:50.477]                           restarts <- computeRestarts(cond)
[08:25:50.477]                           for (restart in restarts) {
[08:25:50.477]                             name <- restart$name
[08:25:50.477]                             if (is.null(name)) 
[08:25:50.477]                               next
[08:25:50.477]                             if (!grepl(pattern, name)) 
[08:25:50.477]                               next
[08:25:50.477]                             invokeRestart(restart)
[08:25:50.477]                             muffled <- TRUE
[08:25:50.477]                             break
[08:25:50.477]                           }
[08:25:50.477]                         }
[08:25:50.477]                       }
[08:25:50.477]                       invisible(muffled)
[08:25:50.477]                     }
[08:25:50.477]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.477]                   }
[08:25:50.477]                 }
[08:25:50.477]                 else {
[08:25:50.477]                   if (TRUE) {
[08:25:50.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.477]                     {
[08:25:50.477]                       inherits <- base::inherits
[08:25:50.477]                       invokeRestart <- base::invokeRestart
[08:25:50.477]                       is.null <- base::is.null
[08:25:50.477]                       muffled <- FALSE
[08:25:50.477]                       if (inherits(cond, "message")) {
[08:25:50.477]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.477]                         if (muffled) 
[08:25:50.477]                           invokeRestart("muffleMessage")
[08:25:50.477]                       }
[08:25:50.477]                       else if (inherits(cond, "warning")) {
[08:25:50.477]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.477]                         if (muffled) 
[08:25:50.477]                           invokeRestart("muffleWarning")
[08:25:50.477]                       }
[08:25:50.477]                       else if (inherits(cond, "condition")) {
[08:25:50.477]                         if (!is.null(pattern)) {
[08:25:50.477]                           computeRestarts <- base::computeRestarts
[08:25:50.477]                           grepl <- base::grepl
[08:25:50.477]                           restarts <- computeRestarts(cond)
[08:25:50.477]                           for (restart in restarts) {
[08:25:50.477]                             name <- restart$name
[08:25:50.477]                             if (is.null(name)) 
[08:25:50.477]                               next
[08:25:50.477]                             if (!grepl(pattern, name)) 
[08:25:50.477]                               next
[08:25:50.477]                             invokeRestart(restart)
[08:25:50.477]                             muffled <- TRUE
[08:25:50.477]                             break
[08:25:50.477]                           }
[08:25:50.477]                         }
[08:25:50.477]                       }
[08:25:50.477]                       invisible(muffled)
[08:25:50.477]                     }
[08:25:50.477]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.477]                   }
[08:25:50.477]                 }
[08:25:50.477]             }
[08:25:50.477]         }))
[08:25:50.477]     }, error = function(ex) {
[08:25:50.477]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.477]                 ...future.rng), started = ...future.startTime, 
[08:25:50.477]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.477]             version = "1.8"), class = "FutureResult")
[08:25:50.477]     }, finally = {
[08:25:50.477]         if (!identical(...future.workdir, getwd())) 
[08:25:50.477]             setwd(...future.workdir)
[08:25:50.477]         {
[08:25:50.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.477]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.477]             }
[08:25:50.477]             base::options(...future.oldOptions)
[08:25:50.477]             if (.Platform$OS.type == "windows") {
[08:25:50.477]                 old_names <- names(...future.oldEnvVars)
[08:25:50.477]                 envs <- base::Sys.getenv()
[08:25:50.477]                 names <- names(envs)
[08:25:50.477]                 common <- intersect(names, old_names)
[08:25:50.477]                 added <- setdiff(names, old_names)
[08:25:50.477]                 removed <- setdiff(old_names, names)
[08:25:50.477]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.477]                   envs[common]]
[08:25:50.477]                 NAMES <- toupper(changed)
[08:25:50.477]                 args <- list()
[08:25:50.477]                 for (kk in seq_along(NAMES)) {
[08:25:50.477]                   name <- changed[[kk]]
[08:25:50.477]                   NAME <- NAMES[[kk]]
[08:25:50.477]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.477]                     next
[08:25:50.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.477]                 }
[08:25:50.477]                 NAMES <- toupper(added)
[08:25:50.477]                 for (kk in seq_along(NAMES)) {
[08:25:50.477]                   name <- added[[kk]]
[08:25:50.477]                   NAME <- NAMES[[kk]]
[08:25:50.477]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.477]                     next
[08:25:50.477]                   args[[name]] <- ""
[08:25:50.477]                 }
[08:25:50.477]                 NAMES <- toupper(removed)
[08:25:50.477]                 for (kk in seq_along(NAMES)) {
[08:25:50.477]                   name <- removed[[kk]]
[08:25:50.477]                   NAME <- NAMES[[kk]]
[08:25:50.477]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.477]                     next
[08:25:50.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.477]                 }
[08:25:50.477]                 if (length(args) > 0) 
[08:25:50.477]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.477]             }
[08:25:50.477]             else {
[08:25:50.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.477]             }
[08:25:50.477]             {
[08:25:50.477]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.477]                   0L) {
[08:25:50.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.477]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.477]                   base::options(opts)
[08:25:50.477]                 }
[08:25:50.477]                 {
[08:25:50.477]                   {
[08:25:50.477]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.477]                     NULL
[08:25:50.477]                   }
[08:25:50.477]                   options(future.plan = NULL)
[08:25:50.477]                   if (is.na(NA_character_)) 
[08:25:50.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.477]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.477]                     .init = FALSE)
[08:25:50.477]                 }
[08:25:50.477]             }
[08:25:50.477]         }
[08:25:50.477]     })
[08:25:50.477]     if (TRUE) {
[08:25:50.477]         base::sink(type = "output", split = FALSE)
[08:25:50.477]         if (TRUE) {
[08:25:50.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.477]         }
[08:25:50.477]         else {
[08:25:50.477]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.477]         }
[08:25:50.477]         base::close(...future.stdout)
[08:25:50.477]         ...future.stdout <- NULL
[08:25:50.477]     }
[08:25:50.477]     ...future.result$conditions <- ...future.conditions
[08:25:50.477]     ...future.result$finished <- base::Sys.time()
[08:25:50.477]     ...future.result
[08:25:50.477] }
[08:25:50.481] assign_globals() ...
[08:25:50.481] List of 5
[08:25:50.481]  $ ...future.FUN            :function (x, w, ...)  
[08:25:50.481]  $ MoreArgs                 : NULL
[08:25:50.481]  $ ...future.elements_ii    :List of 2
[08:25:50.481]   ..$ :List of 3
[08:25:50.481]   .. ..$ : num [1:10] 0.8317 0.8112 0.0241 0.4239 0.0826 ...
[08:25:50.481]   .. ..$ : num [1:10] 0.22 0.3519 0.674 0.0277 0.045 ...
[08:25:50.481]   .. ..$ : num [1:10] 0.0529 0.2804 0.3107 0.9708 0.0806 ...
[08:25:50.481]   ..$ :List of 3
[08:25:50.481]   .. ..$ : num [1:10] 10 4 4 4 5 4 5 8 9 10
[08:25:50.481]   .. ..$ : num [1:10] 7 3 9 7 11 7 7 5 11 4
[08:25:50.481]   .. ..$ : num [1:10] 7 4 3 1 8 5 7 7 2 6
[08:25:50.481]  $ ...future.seeds_ii       : NULL
[08:25:50.481]  $ ...future.globals.maxSize: NULL
[08:25:50.481]  - attr(*, "where")=List of 5
[08:25:50.481]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.481]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.481]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.481]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.481]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.481]  - attr(*, "resolved")= logi FALSE
[08:25:50.481]  - attr(*, "total_size")= num 993
[08:25:50.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.481]  - attr(*, "already-done")= logi TRUE
[08:25:50.491] - copied ‘...future.FUN’ to environment
[08:25:50.492] - copied ‘MoreArgs’ to environment
[08:25:50.492] - copied ‘...future.elements_ii’ to environment
[08:25:50.492] - copied ‘...future.seeds_ii’ to environment
[08:25:50.492] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.492] assign_globals() ... done
[08:25:50.492] requestCore(): workers = 2
[08:25:50.496] MulticoreFuture started
[08:25:50.496] - Launch lazy future ... done
[08:25:50.496] run() for ‘MulticoreFuture’ ... done
[08:25:50.497] Created future:
[08:25:50.497] plan(): Setting new future strategy stack:
[08:25:50.497] List of future strategies:
[08:25:50.497] 1. sequential:
[08:25:50.497]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.497]    - tweaked: FALSE
[08:25:50.497]    - call: NULL
[08:25:50.498] plan(): nbrOfWorkers() = 1
[08:25:50.501] plan(): Setting new future strategy stack:
[08:25:50.501] List of future strategies:
[08:25:50.501] 1. multicore:
[08:25:50.501]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.501]    - tweaked: FALSE
[08:25:50.501]    - call: plan(strategy)
[08:25:50.504] plan(): nbrOfWorkers() = 2
[08:25:50.497] MulticoreFuture:
[08:25:50.497] Label: ‘future_Map-2’
[08:25:50.497] Expression:
[08:25:50.497] {
[08:25:50.497]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.497]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.497]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.497]         on.exit(options(oopts), add = TRUE)
[08:25:50.497]     }
[08:25:50.497]     {
[08:25:50.497]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.497]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.497]         do.call(mapply, args = args)
[08:25:50.497]     }
[08:25:50.497] }
[08:25:50.497] Lazy evaluation: FALSE
[08:25:50.497] Asynchronous evaluation: TRUE
[08:25:50.497] Local evaluation: TRUE
[08:25:50.497] Environment: R_GlobalEnv
[08:25:50.497] Capture standard output: TRUE
[08:25:50.497] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.497] Globals: 5 objects totaling 993 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 575 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.497] Packages: 1 packages (‘stats’)
[08:25:50.497] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:50.497] Resolved: TRUE
[08:25:50.497] Value: <not collected>
[08:25:50.497] Conditions captured: <none>
[08:25:50.497] Early signaling: FALSE
[08:25:50.497] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.497] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.505] Chunk #2 of 2 ... DONE
[08:25:50.506] Launching 2 futures (chunks) ... DONE
[08:25:50.506] Resolving 2 futures (chunks) ...
[08:25:50.506] resolve() on list ...
[08:25:50.506]  recursive: 0
[08:25:50.506]  length: 2
[08:25:50.506] 
[08:25:50.507] Future #1
[08:25:50.507] result() for MulticoreFuture ...
[08:25:50.508] result() for MulticoreFuture ...
[08:25:50.508] result() for MulticoreFuture ... done
[08:25:50.508] result() for MulticoreFuture ... done
[08:25:50.508] result() for MulticoreFuture ...
[08:25:50.509] result() for MulticoreFuture ... done
[08:25:50.509] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:50.509] - nx: 2
[08:25:50.509] - relay: TRUE
[08:25:50.509] - stdout: TRUE
[08:25:50.509] - signal: TRUE
[08:25:50.509] - resignal: FALSE
[08:25:50.509] - force: TRUE
[08:25:50.510] - relayed: [n=2] FALSE, FALSE
[08:25:50.510] - queued futures: [n=2] FALSE, FALSE
[08:25:50.510]  - until=1
[08:25:50.510]  - relaying element #1
[08:25:50.510] result() for MulticoreFuture ...
[08:25:50.510] result() for MulticoreFuture ... done
[08:25:50.510] result() for MulticoreFuture ...
[08:25:50.511] result() for MulticoreFuture ... done
[08:25:50.511] result() for MulticoreFuture ...
[08:25:50.511] result() for MulticoreFuture ... done
[08:25:50.511] result() for MulticoreFuture ...
[08:25:50.511] result() for MulticoreFuture ... done
[08:25:50.511] - relayed: [n=2] TRUE, FALSE
[08:25:50.511] - queued futures: [n=2] TRUE, FALSE
[08:25:50.511] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:50.512]  length: 1 (resolved future 1)
[08:25:50.512] Future #2
[08:25:50.512] result() for MulticoreFuture ...
[08:25:50.513] result() for MulticoreFuture ...
[08:25:50.513] result() for MulticoreFuture ... done
[08:25:50.513] result() for MulticoreFuture ... done
[08:25:50.513] result() for MulticoreFuture ...
[08:25:50.513] result() for MulticoreFuture ... done
[08:25:50.514] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:50.514] - nx: 2
[08:25:50.514] - relay: TRUE
[08:25:50.514] - stdout: TRUE
[08:25:50.514] - signal: TRUE
[08:25:50.514] - resignal: FALSE
[08:25:50.514] - force: TRUE
[08:25:50.514] - relayed: [n=2] TRUE, FALSE
[08:25:50.515] - queued futures: [n=2] TRUE, FALSE
[08:25:50.515]  - until=2
[08:25:50.515]  - relaying element #2
[08:25:50.515] result() for MulticoreFuture ...
[08:25:50.515] result() for MulticoreFuture ... done
[08:25:50.515] result() for MulticoreFuture ...
[08:25:50.515] result() for MulticoreFuture ... done
[08:25:50.515] result() for MulticoreFuture ...
[08:25:50.516] result() for MulticoreFuture ... done
[08:25:50.516] result() for MulticoreFuture ...
[08:25:50.516] result() for MulticoreFuture ... done
[08:25:50.516] - relayed: [n=2] TRUE, TRUE
[08:25:50.516] - queued futures: [n=2] TRUE, TRUE
[08:25:50.516] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:50.516]  length: 0 (resolved future 2)
[08:25:50.516] Relaying remaining futures
[08:25:50.516] signalConditionsASAP(NULL, pos=0) ...
[08:25:50.517] - nx: 2
[08:25:50.517] - relay: TRUE
[08:25:50.517] - stdout: TRUE
[08:25:50.517] - signal: TRUE
[08:25:50.517] - resignal: FALSE
[08:25:50.517] - force: TRUE
[08:25:50.517] - relayed: [n=2] TRUE, TRUE
[08:25:50.517] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:50.517] - relayed: [n=2] TRUE, TRUE
[08:25:50.517] - queued futures: [n=2] TRUE, TRUE
[08:25:50.518] signalConditionsASAP(NULL, pos=0) ... done
[08:25:50.518] resolve() on list ... DONE
[08:25:50.518] result() for MulticoreFuture ...
[08:25:50.518] result() for MulticoreFuture ... done
[08:25:50.518] result() for MulticoreFuture ...
[08:25:50.518] result() for MulticoreFuture ... done
[08:25:50.518] result() for MulticoreFuture ...
[08:25:50.518] result() for MulticoreFuture ... done
[08:25:50.518] result() for MulticoreFuture ...
[08:25:50.519] result() for MulticoreFuture ... done
[08:25:50.519]  - Number of value chunks collected: 2
[08:25:50.519] Resolving 2 futures (chunks) ... DONE
[08:25:50.519] Reducing values from 2 chunks ...
[08:25:50.519]  - Number of values collected after concatenation: 5
[08:25:50.519]  - Number of values expected: 5
[08:25:50.519] Reducing values from 2 chunks ... DONE
[08:25:50.519] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[08:25:50.522] future_mapply() ...
[08:25:50.524] Number of chunks: 2
[08:25:50.524] getGlobalsAndPackagesXApply() ...
[08:25:50.524]  - future.globals: TRUE
[08:25:50.524] getGlobalsAndPackages() ...
[08:25:50.524] Searching for globals...
[08:25:50.525] - globals found: [1] ‘FUN’
[08:25:50.525] Searching for globals ... DONE
[08:25:50.526] Resolving globals: FALSE
[08:25:50.526] The total size of the 1 globals is 32 bytes (32 bytes)
[08:25:50.526] The total size of the 1 globals exported for future expression (‘FUN()’) is 32 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (32 bytes of class ‘function’)
[08:25:50.526] - globals: [1] ‘FUN’
[08:25:50.527] 
[08:25:50.527] getGlobalsAndPackages() ... DONE
[08:25:50.527]  - globals found/used: [n=1] ‘FUN’
[08:25:50.527]  - needed namespaces: [n=0] 
[08:25:50.527] Finding globals ... DONE
[08:25:50.527] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:50.527] List of 2
[08:25:50.527]  $ ...future.FUN:function (e1, e2)  
[08:25:50.527]  $ MoreArgs     : NULL
[08:25:50.527]  - attr(*, "where")=List of 2
[08:25:50.527]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:50.527]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:50.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.527]  - attr(*, "resolved")= logi FALSE
[08:25:50.527]  - attr(*, "total_size")= num NA
[08:25:50.531] Packages to be attached in all futures: [n=0] 
[08:25:50.531] getGlobalsAndPackagesXApply() ... DONE
[08:25:50.531] Number of futures (= number of chunks): 2
[08:25:50.531] Launching 2 futures (chunks) ...
[08:25:50.531] Chunk #1 of 2 ...
[08:25:50.531]  - Finding globals in '...' for chunk #1 ...
[08:25:50.531] getGlobalsAndPackages() ...
[08:25:50.532] Searching for globals...
[08:25:50.532] 
[08:25:50.532] Searching for globals ... DONE
[08:25:50.532] - globals: [0] <none>
[08:25:50.532] getGlobalsAndPackages() ... DONE
[08:25:50.532]    + additional globals found: [n=0] 
[08:25:50.532]    + additional namespaces needed: [n=0] 
[08:25:50.533]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:50.533]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.533]  - seeds: <none>
[08:25:50.533]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.533] getGlobalsAndPackages() ...
[08:25:50.533] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.533] Resolving globals: FALSE
[08:25:50.534] The total size of the 5 globals is 188 bytes (188 bytes)
[08:25:50.534] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 188 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (75 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:50.534] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.535] 
[08:25:50.535] getGlobalsAndPackages() ... DONE
[08:25:50.535] run() for ‘Future’ ...
[08:25:50.535] - state: ‘created’
[08:25:50.535] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.537] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.537] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.538]   - Field: ‘label’
[08:25:50.538]   - Field: ‘local’
[08:25:50.538]   - Field: ‘owner’
[08:25:50.538]   - Field: ‘envir’
[08:25:50.538]   - Field: ‘workers’
[08:25:50.538]   - Field: ‘packages’
[08:25:50.538]   - Field: ‘gc’
[08:25:50.538]   - Field: ‘job’
[08:25:50.538]   - Field: ‘conditions’
[08:25:50.539]   - Field: ‘expr’
[08:25:50.539]   - Field: ‘uuid’
[08:25:50.539]   - Field: ‘seed’
[08:25:50.539]   - Field: ‘version’
[08:25:50.539]   - Field: ‘result’
[08:25:50.539]   - Field: ‘asynchronous’
[08:25:50.539]   - Field: ‘calls’
[08:25:50.539]   - Field: ‘globals’
[08:25:50.539]   - Field: ‘stdout’
[08:25:50.540]   - Field: ‘earlySignal’
[08:25:50.540]   - Field: ‘lazy’
[08:25:50.540]   - Field: ‘state’
[08:25:50.540] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.540] - Launch lazy future ...
[08:25:50.540] Packages needed by the future expression (n = 0): <none>
[08:25:50.540] Packages needed by future strategies (n = 0): <none>
[08:25:50.541] {
[08:25:50.541]     {
[08:25:50.541]         {
[08:25:50.541]             ...future.startTime <- base::Sys.time()
[08:25:50.541]             {
[08:25:50.541]                 {
[08:25:50.541]                   {
[08:25:50.541]                     {
[08:25:50.541]                       base::local({
[08:25:50.541]                         has_future <- base::requireNamespace("future", 
[08:25:50.541]                           quietly = TRUE)
[08:25:50.541]                         if (has_future) {
[08:25:50.541]                           ns <- base::getNamespace("future")
[08:25:50.541]                           version <- ns[[".package"]][["version"]]
[08:25:50.541]                           if (is.null(version)) 
[08:25:50.541]                             version <- utils::packageVersion("future")
[08:25:50.541]                         }
[08:25:50.541]                         else {
[08:25:50.541]                           version <- NULL
[08:25:50.541]                         }
[08:25:50.541]                         if (!has_future || version < "1.8.0") {
[08:25:50.541]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.541]                             "", base::R.version$version.string), 
[08:25:50.541]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:50.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:50.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.541]                               "release", "version")], collapse = " "), 
[08:25:50.541]                             hostname = base::Sys.info()[["nodename"]])
[08:25:50.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.541]                             info)
[08:25:50.541]                           info <- base::paste(info, collapse = "; ")
[08:25:50.541]                           if (!has_future) {
[08:25:50.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.541]                               info)
[08:25:50.541]                           }
[08:25:50.541]                           else {
[08:25:50.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.541]                               info, version)
[08:25:50.541]                           }
[08:25:50.541]                           base::stop(msg)
[08:25:50.541]                         }
[08:25:50.541]                       })
[08:25:50.541]                     }
[08:25:50.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.541]                     base::options(mc.cores = 1L)
[08:25:50.541]                   }
[08:25:50.541]                   ...future.strategy.old <- future::plan("list")
[08:25:50.541]                   options(future.plan = NULL)
[08:25:50.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.541]                 }
[08:25:50.541]                 ...future.workdir <- getwd()
[08:25:50.541]             }
[08:25:50.541]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.541]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.541]         }
[08:25:50.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.541]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.541]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.541]             base::names(...future.oldOptions))
[08:25:50.541]     }
[08:25:50.541]     if (FALSE) {
[08:25:50.541]     }
[08:25:50.541]     else {
[08:25:50.541]         if (TRUE) {
[08:25:50.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.541]                 open = "w")
[08:25:50.541]         }
[08:25:50.541]         else {
[08:25:50.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.541]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.541]         }
[08:25:50.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.541]             base::sink(type = "output", split = FALSE)
[08:25:50.541]             base::close(...future.stdout)
[08:25:50.541]         }, add = TRUE)
[08:25:50.541]     }
[08:25:50.541]     ...future.frame <- base::sys.nframe()
[08:25:50.541]     ...future.conditions <- base::list()
[08:25:50.541]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.541]     if (FALSE) {
[08:25:50.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.541]     }
[08:25:50.541]     ...future.result <- base::tryCatch({
[08:25:50.541]         base::withCallingHandlers({
[08:25:50.541]             ...future.value <- base::withVisible(base::local({
[08:25:50.541]                 withCallingHandlers({
[08:25:50.541]                   {
[08:25:50.541]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.541]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.541]                       ...future.globals.maxSize)) {
[08:25:50.541]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.541]                       on.exit(options(oopts), add = TRUE)
[08:25:50.541]                     }
[08:25:50.541]                     {
[08:25:50.541]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.541]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.541]                         USE.NAMES = FALSE)
[08:25:50.541]                       do.call(mapply, args = args)
[08:25:50.541]                     }
[08:25:50.541]                   }
[08:25:50.541]                 }, immediateCondition = function(cond) {
[08:25:50.541]                   save_rds <- function (object, pathname, ...) 
[08:25:50.541]                   {
[08:25:50.541]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.541]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.541]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.541]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.541]                         fi_tmp[["mtime"]])
[08:25:50.541]                     }
[08:25:50.541]                     tryCatch({
[08:25:50.541]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.541]                     }, error = function(ex) {
[08:25:50.541]                       msg <- conditionMessage(ex)
[08:25:50.541]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.541]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.541]                         fi_tmp[["mtime"]], msg)
[08:25:50.541]                       ex$message <- msg
[08:25:50.541]                       stop(ex)
[08:25:50.541]                     })
[08:25:50.541]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.541]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.541]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.541]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.541]                       fi <- file.info(pathname)
[08:25:50.541]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.541]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.541]                         fi[["size"]], fi[["mtime"]])
[08:25:50.541]                       stop(msg)
[08:25:50.541]                     }
[08:25:50.541]                     invisible(pathname)
[08:25:50.541]                   }
[08:25:50.541]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.541]                     rootPath = tempdir()) 
[08:25:50.541]                   {
[08:25:50.541]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.541]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.541]                       tmpdir = path, fileext = ".rds")
[08:25:50.541]                     save_rds(obj, file)
[08:25:50.541]                   }
[08:25:50.541]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.541]                   {
[08:25:50.541]                     inherits <- base::inherits
[08:25:50.541]                     invokeRestart <- base::invokeRestart
[08:25:50.541]                     is.null <- base::is.null
[08:25:50.541]                     muffled <- FALSE
[08:25:50.541]                     if (inherits(cond, "message")) {
[08:25:50.541]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.541]                       if (muffled) 
[08:25:50.541]                         invokeRestart("muffleMessage")
[08:25:50.541]                     }
[08:25:50.541]                     else if (inherits(cond, "warning")) {
[08:25:50.541]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.541]                       if (muffled) 
[08:25:50.541]                         invokeRestart("muffleWarning")
[08:25:50.541]                     }
[08:25:50.541]                     else if (inherits(cond, "condition")) {
[08:25:50.541]                       if (!is.null(pattern)) {
[08:25:50.541]                         computeRestarts <- base::computeRestarts
[08:25:50.541]                         grepl <- base::grepl
[08:25:50.541]                         restarts <- computeRestarts(cond)
[08:25:50.541]                         for (restart in restarts) {
[08:25:50.541]                           name <- restart$name
[08:25:50.541]                           if (is.null(name)) 
[08:25:50.541]                             next
[08:25:50.541]                           if (!grepl(pattern, name)) 
[08:25:50.541]                             next
[08:25:50.541]                           invokeRestart(restart)
[08:25:50.541]                           muffled <- TRUE
[08:25:50.541]                           break
[08:25:50.541]                         }
[08:25:50.541]                       }
[08:25:50.541]                     }
[08:25:50.541]                     invisible(muffled)
[08:25:50.541]                   }
[08:25:50.541]                   muffleCondition(cond)
[08:25:50.541]                 })
[08:25:50.541]             }))
[08:25:50.541]             future::FutureResult(value = ...future.value$value, 
[08:25:50.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.541]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.541]                     ...future.globalenv.names))
[08:25:50.541]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.541]         }, condition = base::local({
[08:25:50.541]             c <- base::c
[08:25:50.541]             inherits <- base::inherits
[08:25:50.541]             invokeRestart <- base::invokeRestart
[08:25:50.541]             length <- base::length
[08:25:50.541]             list <- base::list
[08:25:50.541]             seq.int <- base::seq.int
[08:25:50.541]             signalCondition <- base::signalCondition
[08:25:50.541]             sys.calls <- base::sys.calls
[08:25:50.541]             `[[` <- base::`[[`
[08:25:50.541]             `+` <- base::`+`
[08:25:50.541]             `<<-` <- base::`<<-`
[08:25:50.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.541]                   3L)]
[08:25:50.541]             }
[08:25:50.541]             function(cond) {
[08:25:50.541]                 is_error <- inherits(cond, "error")
[08:25:50.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.541]                   NULL)
[08:25:50.541]                 if (is_error) {
[08:25:50.541]                   sessionInformation <- function() {
[08:25:50.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.541]                       search = base::search(), system = base::Sys.info())
[08:25:50.541]                   }
[08:25:50.541]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.541]                     cond$call), session = sessionInformation(), 
[08:25:50.541]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.541]                   signalCondition(cond)
[08:25:50.541]                 }
[08:25:50.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.541]                 "immediateCondition"))) {
[08:25:50.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.541]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.541]                   if (TRUE && !signal) {
[08:25:50.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.541]                     {
[08:25:50.541]                       inherits <- base::inherits
[08:25:50.541]                       invokeRestart <- base::invokeRestart
[08:25:50.541]                       is.null <- base::is.null
[08:25:50.541]                       muffled <- FALSE
[08:25:50.541]                       if (inherits(cond, "message")) {
[08:25:50.541]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.541]                         if (muffled) 
[08:25:50.541]                           invokeRestart("muffleMessage")
[08:25:50.541]                       }
[08:25:50.541]                       else if (inherits(cond, "warning")) {
[08:25:50.541]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.541]                         if (muffled) 
[08:25:50.541]                           invokeRestart("muffleWarning")
[08:25:50.541]                       }
[08:25:50.541]                       else if (inherits(cond, "condition")) {
[08:25:50.541]                         if (!is.null(pattern)) {
[08:25:50.541]                           computeRestarts <- base::computeRestarts
[08:25:50.541]                           grepl <- base::grepl
[08:25:50.541]                           restarts <- computeRestarts(cond)
[08:25:50.541]                           for (restart in restarts) {
[08:25:50.541]                             name <- restart$name
[08:25:50.541]                             if (is.null(name)) 
[08:25:50.541]                               next
[08:25:50.541]                             if (!grepl(pattern, name)) 
[08:25:50.541]                               next
[08:25:50.541]                             invokeRestart(restart)
[08:25:50.541]                             muffled <- TRUE
[08:25:50.541]                             break
[08:25:50.541]                           }
[08:25:50.541]                         }
[08:25:50.541]                       }
[08:25:50.541]                       invisible(muffled)
[08:25:50.541]                     }
[08:25:50.541]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.541]                   }
[08:25:50.541]                 }
[08:25:50.541]                 else {
[08:25:50.541]                   if (TRUE) {
[08:25:50.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.541]                     {
[08:25:50.541]                       inherits <- base::inherits
[08:25:50.541]                       invokeRestart <- base::invokeRestart
[08:25:50.541]                       is.null <- base::is.null
[08:25:50.541]                       muffled <- FALSE
[08:25:50.541]                       if (inherits(cond, "message")) {
[08:25:50.541]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.541]                         if (muffled) 
[08:25:50.541]                           invokeRestart("muffleMessage")
[08:25:50.541]                       }
[08:25:50.541]                       else if (inherits(cond, "warning")) {
[08:25:50.541]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.541]                         if (muffled) 
[08:25:50.541]                           invokeRestart("muffleWarning")
[08:25:50.541]                       }
[08:25:50.541]                       else if (inherits(cond, "condition")) {
[08:25:50.541]                         if (!is.null(pattern)) {
[08:25:50.541]                           computeRestarts <- base::computeRestarts
[08:25:50.541]                           grepl <- base::grepl
[08:25:50.541]                           restarts <- computeRestarts(cond)
[08:25:50.541]                           for (restart in restarts) {
[08:25:50.541]                             name <- restart$name
[08:25:50.541]                             if (is.null(name)) 
[08:25:50.541]                               next
[08:25:50.541]                             if (!grepl(pattern, name)) 
[08:25:50.541]                               next
[08:25:50.541]                             invokeRestart(restart)
[08:25:50.541]                             muffled <- TRUE
[08:25:50.541]                             break
[08:25:50.541]                           }
[08:25:50.541]                         }
[08:25:50.541]                       }
[08:25:50.541]                       invisible(muffled)
[08:25:50.541]                     }
[08:25:50.541]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.541]                   }
[08:25:50.541]                 }
[08:25:50.541]             }
[08:25:50.541]         }))
[08:25:50.541]     }, error = function(ex) {
[08:25:50.541]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.541]                 ...future.rng), started = ...future.startTime, 
[08:25:50.541]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.541]             version = "1.8"), class = "FutureResult")
[08:25:50.541]     }, finally = {
[08:25:50.541]         if (!identical(...future.workdir, getwd())) 
[08:25:50.541]             setwd(...future.workdir)
[08:25:50.541]         {
[08:25:50.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.541]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.541]             }
[08:25:50.541]             base::options(...future.oldOptions)
[08:25:50.541]             if (.Platform$OS.type == "windows") {
[08:25:50.541]                 old_names <- names(...future.oldEnvVars)
[08:25:50.541]                 envs <- base::Sys.getenv()
[08:25:50.541]                 names <- names(envs)
[08:25:50.541]                 common <- intersect(names, old_names)
[08:25:50.541]                 added <- setdiff(names, old_names)
[08:25:50.541]                 removed <- setdiff(old_names, names)
[08:25:50.541]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.541]                   envs[common]]
[08:25:50.541]                 NAMES <- toupper(changed)
[08:25:50.541]                 args <- list()
[08:25:50.541]                 for (kk in seq_along(NAMES)) {
[08:25:50.541]                   name <- changed[[kk]]
[08:25:50.541]                   NAME <- NAMES[[kk]]
[08:25:50.541]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.541]                     next
[08:25:50.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.541]                 }
[08:25:50.541]                 NAMES <- toupper(added)
[08:25:50.541]                 for (kk in seq_along(NAMES)) {
[08:25:50.541]                   name <- added[[kk]]
[08:25:50.541]                   NAME <- NAMES[[kk]]
[08:25:50.541]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.541]                     next
[08:25:50.541]                   args[[name]] <- ""
[08:25:50.541]                 }
[08:25:50.541]                 NAMES <- toupper(removed)
[08:25:50.541]                 for (kk in seq_along(NAMES)) {
[08:25:50.541]                   name <- removed[[kk]]
[08:25:50.541]                   NAME <- NAMES[[kk]]
[08:25:50.541]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.541]                     next
[08:25:50.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.541]                 }
[08:25:50.541]                 if (length(args) > 0) 
[08:25:50.541]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.541]             }
[08:25:50.541]             else {
[08:25:50.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.541]             }
[08:25:50.541]             {
[08:25:50.541]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.541]                   0L) {
[08:25:50.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.541]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.541]                   base::options(opts)
[08:25:50.541]                 }
[08:25:50.541]                 {
[08:25:50.541]                   {
[08:25:50.541]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.541]                     NULL
[08:25:50.541]                   }
[08:25:50.541]                   options(future.plan = NULL)
[08:25:50.541]                   if (is.na(NA_character_)) 
[08:25:50.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.541]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.541]                     .init = FALSE)
[08:25:50.541]                 }
[08:25:50.541]             }
[08:25:50.541]         }
[08:25:50.541]     })
[08:25:50.541]     if (TRUE) {
[08:25:50.541]         base::sink(type = "output", split = FALSE)
[08:25:50.541]         if (TRUE) {
[08:25:50.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.541]         }
[08:25:50.541]         else {
[08:25:50.541]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.541]         }
[08:25:50.541]         base::close(...future.stdout)
[08:25:50.541]         ...future.stdout <- NULL
[08:25:50.541]     }
[08:25:50.541]     ...future.result$conditions <- ...future.conditions
[08:25:50.541]     ...future.result$finished <- base::Sys.time()
[08:25:50.541]     ...future.result
[08:25:50.541] }
[08:25:50.544] assign_globals() ...
[08:25:50.544] List of 5
[08:25:50.544]  $ ...future.FUN            :function (e1, e2)  
[08:25:50.544]  $ MoreArgs                 : NULL
[08:25:50.544]  $ ...future.elements_ii    :List of 2
[08:25:50.544]   ..$ :List of 1
[08:25:50.544]   .. ..$ : num 1
[08:25:50.544]   ..$ :List of 1
[08:25:50.544]   .. ..$ : int 1
[08:25:50.544]  $ ...future.seeds_ii       : NULL
[08:25:50.544]  $ ...future.globals.maxSize: NULL
[08:25:50.544]  - attr(*, "where")=List of 5
[08:25:50.544]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.544]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.544]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.544]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.544]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.544]  - attr(*, "resolved")= logi FALSE
[08:25:50.544]  - attr(*, "total_size")= num 188
[08:25:50.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.544]  - attr(*, "already-done")= logi TRUE
[08:25:50.550] - copied ‘...future.FUN’ to environment
[08:25:50.550] - copied ‘MoreArgs’ to environment
[08:25:50.550] - copied ‘...future.elements_ii’ to environment
[08:25:50.550] - copied ‘...future.seeds_ii’ to environment
[08:25:50.550] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.550] assign_globals() ... done
[08:25:50.551] requestCore(): workers = 2
[08:25:50.553] MulticoreFuture started
[08:25:50.554] - Launch lazy future ... done
[08:25:50.554] run() for ‘MulticoreFuture’ ... done
[08:25:50.554] Created future:
[08:25:50.554] plan(): Setting new future strategy stack:
[08:25:50.555] List of future strategies:
[08:25:50.555] 1. sequential:
[08:25:50.555]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.555]    - tweaked: FALSE
[08:25:50.555]    - call: NULL
[08:25:50.555] plan(): nbrOfWorkers() = 1
[08:25:50.558] plan(): Setting new future strategy stack:
[08:25:50.558] List of future strategies:
[08:25:50.558] 1. multicore:
[08:25:50.558]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.558]    - tweaked: FALSE
[08:25:50.558]    - call: plan(strategy)
[08:25:50.561] plan(): nbrOfWorkers() = 2
[08:25:50.554] MulticoreFuture:
[08:25:50.554] Label: ‘future_Map-1’
[08:25:50.554] Expression:
[08:25:50.554] {
[08:25:50.554]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.554]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.554]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.554]         on.exit(options(oopts), add = TRUE)
[08:25:50.554]     }
[08:25:50.554]     {
[08:25:50.554]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.554]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.554]         do.call(mapply, args = args)
[08:25:50.554]     }
[08:25:50.554] }
[08:25:50.554] Lazy evaluation: FALSE
[08:25:50.554] Asynchronous evaluation: TRUE
[08:25:50.554] Local evaluation: TRUE
[08:25:50.554] Environment: R_GlobalEnv
[08:25:50.554] Capture standard output: TRUE
[08:25:50.554] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.554] Globals: 5 objects totaling 188 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 75 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.554] Packages: <none>
[08:25:50.554] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:50.554] Resolved: TRUE
[08:25:50.554] Value: <not collected>
[08:25:50.554] Conditions captured: <none>
[08:25:50.554] Early signaling: FALSE
[08:25:50.554] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.554] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.562] Chunk #1 of 2 ... DONE
[08:25:50.562] Chunk #2 of 2 ...
[08:25:50.562]  - Finding globals in '...' for chunk #2 ...
[08:25:50.562] getGlobalsAndPackages() ...
[08:25:50.562] Searching for globals...
[08:25:50.563] 
[08:25:50.563] Searching for globals ... DONE
[08:25:50.563] - globals: [0] <none>
[08:25:50.563] getGlobalsAndPackages() ... DONE
[08:25:50.563]    + additional globals found: [n=0] 
[08:25:50.563]    + additional namespaces needed: [n=0] 
[08:25:50.564]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:50.564]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.564]  - seeds: <none>
[08:25:50.564]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.564] getGlobalsAndPackages() ...
[08:25:50.564] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.564] Resolving globals: FALSE
[08:25:50.565] The total size of the 5 globals is 216 bytes (216 bytes)
[08:25:50.566] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 216 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (103 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:50.566] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.566] 
[08:25:50.566] getGlobalsAndPackages() ... DONE
[08:25:50.567] run() for ‘Future’ ...
[08:25:50.567] - state: ‘created’
[08:25:50.567] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.570] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.570]   - Field: ‘label’
[08:25:50.570]   - Field: ‘local’
[08:25:50.570]   - Field: ‘owner’
[08:25:50.570]   - Field: ‘envir’
[08:25:50.571]   - Field: ‘workers’
[08:25:50.571]   - Field: ‘packages’
[08:25:50.571]   - Field: ‘gc’
[08:25:50.571]   - Field: ‘job’
[08:25:50.571]   - Field: ‘conditions’
[08:25:50.571]   - Field: ‘expr’
[08:25:50.571]   - Field: ‘uuid’
[08:25:50.571]   - Field: ‘seed’
[08:25:50.572]   - Field: ‘version’
[08:25:50.572]   - Field: ‘result’
[08:25:50.572]   - Field: ‘asynchronous’
[08:25:50.572]   - Field: ‘calls’
[08:25:50.572]   - Field: ‘globals’
[08:25:50.572]   - Field: ‘stdout’
[08:25:50.572]   - Field: ‘earlySignal’
[08:25:50.572]   - Field: ‘lazy’
[08:25:50.573]   - Field: ‘state’
[08:25:50.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.573] - Launch lazy future ...
[08:25:50.573] Packages needed by the future expression (n = 0): <none>
[08:25:50.573] Packages needed by future strategies (n = 0): <none>
[08:25:50.574] {
[08:25:50.574]     {
[08:25:50.574]         {
[08:25:50.574]             ...future.startTime <- base::Sys.time()
[08:25:50.574]             {
[08:25:50.574]                 {
[08:25:50.574]                   {
[08:25:50.574]                     {
[08:25:50.574]                       base::local({
[08:25:50.574]                         has_future <- base::requireNamespace("future", 
[08:25:50.574]                           quietly = TRUE)
[08:25:50.574]                         if (has_future) {
[08:25:50.574]                           ns <- base::getNamespace("future")
[08:25:50.574]                           version <- ns[[".package"]][["version"]]
[08:25:50.574]                           if (is.null(version)) 
[08:25:50.574]                             version <- utils::packageVersion("future")
[08:25:50.574]                         }
[08:25:50.574]                         else {
[08:25:50.574]                           version <- NULL
[08:25:50.574]                         }
[08:25:50.574]                         if (!has_future || version < "1.8.0") {
[08:25:50.574]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.574]                             "", base::R.version$version.string), 
[08:25:50.574]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:50.574]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:50.574]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.574]                               "release", "version")], collapse = " "), 
[08:25:50.574]                             hostname = base::Sys.info()[["nodename"]])
[08:25:50.574]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.574]                             info)
[08:25:50.574]                           info <- base::paste(info, collapse = "; ")
[08:25:50.574]                           if (!has_future) {
[08:25:50.574]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.574]                               info)
[08:25:50.574]                           }
[08:25:50.574]                           else {
[08:25:50.574]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.574]                               info, version)
[08:25:50.574]                           }
[08:25:50.574]                           base::stop(msg)
[08:25:50.574]                         }
[08:25:50.574]                       })
[08:25:50.574]                     }
[08:25:50.574]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.574]                     base::options(mc.cores = 1L)
[08:25:50.574]                   }
[08:25:50.574]                   ...future.strategy.old <- future::plan("list")
[08:25:50.574]                   options(future.plan = NULL)
[08:25:50.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.574]                 }
[08:25:50.574]                 ...future.workdir <- getwd()
[08:25:50.574]             }
[08:25:50.574]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.574]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.574]         }
[08:25:50.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.574]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.574]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.574]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.574]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.574]             base::names(...future.oldOptions))
[08:25:50.574]     }
[08:25:50.574]     if (FALSE) {
[08:25:50.574]     }
[08:25:50.574]     else {
[08:25:50.574]         if (TRUE) {
[08:25:50.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.574]                 open = "w")
[08:25:50.574]         }
[08:25:50.574]         else {
[08:25:50.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.574]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.574]         }
[08:25:50.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.574]             base::sink(type = "output", split = FALSE)
[08:25:50.574]             base::close(...future.stdout)
[08:25:50.574]         }, add = TRUE)
[08:25:50.574]     }
[08:25:50.574]     ...future.frame <- base::sys.nframe()
[08:25:50.574]     ...future.conditions <- base::list()
[08:25:50.574]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.574]     if (FALSE) {
[08:25:50.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.574]     }
[08:25:50.574]     ...future.result <- base::tryCatch({
[08:25:50.574]         base::withCallingHandlers({
[08:25:50.574]             ...future.value <- base::withVisible(base::local({
[08:25:50.574]                 withCallingHandlers({
[08:25:50.574]                   {
[08:25:50.574]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.574]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.574]                       ...future.globals.maxSize)) {
[08:25:50.574]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.574]                       on.exit(options(oopts), add = TRUE)
[08:25:50.574]                     }
[08:25:50.574]                     {
[08:25:50.574]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.574]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.574]                         USE.NAMES = FALSE)
[08:25:50.574]                       do.call(mapply, args = args)
[08:25:50.574]                     }
[08:25:50.574]                   }
[08:25:50.574]                 }, immediateCondition = function(cond) {
[08:25:50.574]                   save_rds <- function (object, pathname, ...) 
[08:25:50.574]                   {
[08:25:50.574]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.574]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.574]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.574]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.574]                         fi_tmp[["mtime"]])
[08:25:50.574]                     }
[08:25:50.574]                     tryCatch({
[08:25:50.574]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.574]                     }, error = function(ex) {
[08:25:50.574]                       msg <- conditionMessage(ex)
[08:25:50.574]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.574]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.574]                         fi_tmp[["mtime"]], msg)
[08:25:50.574]                       ex$message <- msg
[08:25:50.574]                       stop(ex)
[08:25:50.574]                     })
[08:25:50.574]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.574]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.574]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.574]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.574]                       fi <- file.info(pathname)
[08:25:50.574]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.574]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.574]                         fi[["size"]], fi[["mtime"]])
[08:25:50.574]                       stop(msg)
[08:25:50.574]                     }
[08:25:50.574]                     invisible(pathname)
[08:25:50.574]                   }
[08:25:50.574]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.574]                     rootPath = tempdir()) 
[08:25:50.574]                   {
[08:25:50.574]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.574]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.574]                       tmpdir = path, fileext = ".rds")
[08:25:50.574]                     save_rds(obj, file)
[08:25:50.574]                   }
[08:25:50.574]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.574]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.574]                   {
[08:25:50.574]                     inherits <- base::inherits
[08:25:50.574]                     invokeRestart <- base::invokeRestart
[08:25:50.574]                     is.null <- base::is.null
[08:25:50.574]                     muffled <- FALSE
[08:25:50.574]                     if (inherits(cond, "message")) {
[08:25:50.574]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.574]                       if (muffled) 
[08:25:50.574]                         invokeRestart("muffleMessage")
[08:25:50.574]                     }
[08:25:50.574]                     else if (inherits(cond, "warning")) {
[08:25:50.574]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.574]                       if (muffled) 
[08:25:50.574]                         invokeRestart("muffleWarning")
[08:25:50.574]                     }
[08:25:50.574]                     else if (inherits(cond, "condition")) {
[08:25:50.574]                       if (!is.null(pattern)) {
[08:25:50.574]                         computeRestarts <- base::computeRestarts
[08:25:50.574]                         grepl <- base::grepl
[08:25:50.574]                         restarts <- computeRestarts(cond)
[08:25:50.574]                         for (restart in restarts) {
[08:25:50.574]                           name <- restart$name
[08:25:50.574]                           if (is.null(name)) 
[08:25:50.574]                             next
[08:25:50.574]                           if (!grepl(pattern, name)) 
[08:25:50.574]                             next
[08:25:50.574]                           invokeRestart(restart)
[08:25:50.574]                           muffled <- TRUE
[08:25:50.574]                           break
[08:25:50.574]                         }
[08:25:50.574]                       }
[08:25:50.574]                     }
[08:25:50.574]                     invisible(muffled)
[08:25:50.574]                   }
[08:25:50.574]                   muffleCondition(cond)
[08:25:50.574]                 })
[08:25:50.574]             }))
[08:25:50.574]             future::FutureResult(value = ...future.value$value, 
[08:25:50.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.574]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.574]                     ...future.globalenv.names))
[08:25:50.574]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.574]         }, condition = base::local({
[08:25:50.574]             c <- base::c
[08:25:50.574]             inherits <- base::inherits
[08:25:50.574]             invokeRestart <- base::invokeRestart
[08:25:50.574]             length <- base::length
[08:25:50.574]             list <- base::list
[08:25:50.574]             seq.int <- base::seq.int
[08:25:50.574]             signalCondition <- base::signalCondition
[08:25:50.574]             sys.calls <- base::sys.calls
[08:25:50.574]             `[[` <- base::`[[`
[08:25:50.574]             `+` <- base::`+`
[08:25:50.574]             `<<-` <- base::`<<-`
[08:25:50.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.574]                   3L)]
[08:25:50.574]             }
[08:25:50.574]             function(cond) {
[08:25:50.574]                 is_error <- inherits(cond, "error")
[08:25:50.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.574]                   NULL)
[08:25:50.574]                 if (is_error) {
[08:25:50.574]                   sessionInformation <- function() {
[08:25:50.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.574]                       search = base::search(), system = base::Sys.info())
[08:25:50.574]                   }
[08:25:50.574]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.574]                     cond$call), session = sessionInformation(), 
[08:25:50.574]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.574]                   signalCondition(cond)
[08:25:50.574]                 }
[08:25:50.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.574]                 "immediateCondition"))) {
[08:25:50.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.574]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.574]                   if (TRUE && !signal) {
[08:25:50.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.574]                     {
[08:25:50.574]                       inherits <- base::inherits
[08:25:50.574]                       invokeRestart <- base::invokeRestart
[08:25:50.574]                       is.null <- base::is.null
[08:25:50.574]                       muffled <- FALSE
[08:25:50.574]                       if (inherits(cond, "message")) {
[08:25:50.574]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.574]                         if (muffled) 
[08:25:50.574]                           invokeRestart("muffleMessage")
[08:25:50.574]                       }
[08:25:50.574]                       else if (inherits(cond, "warning")) {
[08:25:50.574]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.574]                         if (muffled) 
[08:25:50.574]                           invokeRestart("muffleWarning")
[08:25:50.574]                       }
[08:25:50.574]                       else if (inherits(cond, "condition")) {
[08:25:50.574]                         if (!is.null(pattern)) {
[08:25:50.574]                           computeRestarts <- base::computeRestarts
[08:25:50.574]                           grepl <- base::grepl
[08:25:50.574]                           restarts <- computeRestarts(cond)
[08:25:50.574]                           for (restart in restarts) {
[08:25:50.574]                             name <- restart$name
[08:25:50.574]                             if (is.null(name)) 
[08:25:50.574]                               next
[08:25:50.574]                             if (!grepl(pattern, name)) 
[08:25:50.574]                               next
[08:25:50.574]                             invokeRestart(restart)
[08:25:50.574]                             muffled <- TRUE
[08:25:50.574]                             break
[08:25:50.574]                           }
[08:25:50.574]                         }
[08:25:50.574]                       }
[08:25:50.574]                       invisible(muffled)
[08:25:50.574]                     }
[08:25:50.574]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.574]                   }
[08:25:50.574]                 }
[08:25:50.574]                 else {
[08:25:50.574]                   if (TRUE) {
[08:25:50.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.574]                     {
[08:25:50.574]                       inherits <- base::inherits
[08:25:50.574]                       invokeRestart <- base::invokeRestart
[08:25:50.574]                       is.null <- base::is.null
[08:25:50.574]                       muffled <- FALSE
[08:25:50.574]                       if (inherits(cond, "message")) {
[08:25:50.574]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.574]                         if (muffled) 
[08:25:50.574]                           invokeRestart("muffleMessage")
[08:25:50.574]                       }
[08:25:50.574]                       else if (inherits(cond, "warning")) {
[08:25:50.574]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.574]                         if (muffled) 
[08:25:50.574]                           invokeRestart("muffleWarning")
[08:25:50.574]                       }
[08:25:50.574]                       else if (inherits(cond, "condition")) {
[08:25:50.574]                         if (!is.null(pattern)) {
[08:25:50.574]                           computeRestarts <- base::computeRestarts
[08:25:50.574]                           grepl <- base::grepl
[08:25:50.574]                           restarts <- computeRestarts(cond)
[08:25:50.574]                           for (restart in restarts) {
[08:25:50.574]                             name <- restart$name
[08:25:50.574]                             if (is.null(name)) 
[08:25:50.574]                               next
[08:25:50.574]                             if (!grepl(pattern, name)) 
[08:25:50.574]                               next
[08:25:50.574]                             invokeRestart(restart)
[08:25:50.574]                             muffled <- TRUE
[08:25:50.574]                             break
[08:25:50.574]                           }
[08:25:50.574]                         }
[08:25:50.574]                       }
[08:25:50.574]                       invisible(muffled)
[08:25:50.574]                     }
[08:25:50.574]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.574]                   }
[08:25:50.574]                 }
[08:25:50.574]             }
[08:25:50.574]         }))
[08:25:50.574]     }, error = function(ex) {
[08:25:50.574]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.574]                 ...future.rng), started = ...future.startTime, 
[08:25:50.574]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.574]             version = "1.8"), class = "FutureResult")
[08:25:50.574]     }, finally = {
[08:25:50.574]         if (!identical(...future.workdir, getwd())) 
[08:25:50.574]             setwd(...future.workdir)
[08:25:50.574]         {
[08:25:50.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.574]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.574]             }
[08:25:50.574]             base::options(...future.oldOptions)
[08:25:50.574]             if (.Platform$OS.type == "windows") {
[08:25:50.574]                 old_names <- names(...future.oldEnvVars)
[08:25:50.574]                 envs <- base::Sys.getenv()
[08:25:50.574]                 names <- names(envs)
[08:25:50.574]                 common <- intersect(names, old_names)
[08:25:50.574]                 added <- setdiff(names, old_names)
[08:25:50.574]                 removed <- setdiff(old_names, names)
[08:25:50.574]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.574]                   envs[common]]
[08:25:50.574]                 NAMES <- toupper(changed)
[08:25:50.574]                 args <- list()
[08:25:50.574]                 for (kk in seq_along(NAMES)) {
[08:25:50.574]                   name <- changed[[kk]]
[08:25:50.574]                   NAME <- NAMES[[kk]]
[08:25:50.574]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.574]                     next
[08:25:50.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.574]                 }
[08:25:50.574]                 NAMES <- toupper(added)
[08:25:50.574]                 for (kk in seq_along(NAMES)) {
[08:25:50.574]                   name <- added[[kk]]
[08:25:50.574]                   NAME <- NAMES[[kk]]
[08:25:50.574]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.574]                     next
[08:25:50.574]                   args[[name]] <- ""
[08:25:50.574]                 }
[08:25:50.574]                 NAMES <- toupper(removed)
[08:25:50.574]                 for (kk in seq_along(NAMES)) {
[08:25:50.574]                   name <- removed[[kk]]
[08:25:50.574]                   NAME <- NAMES[[kk]]
[08:25:50.574]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.574]                     next
[08:25:50.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.574]                 }
[08:25:50.574]                 if (length(args) > 0) 
[08:25:50.574]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.574]             }
[08:25:50.574]             else {
[08:25:50.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.574]             }
[08:25:50.574]             {
[08:25:50.574]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.574]                   0L) {
[08:25:50.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.574]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.574]                   base::options(opts)
[08:25:50.574]                 }
[08:25:50.574]                 {
[08:25:50.574]                   {
[08:25:50.574]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.574]                     NULL
[08:25:50.574]                   }
[08:25:50.574]                   options(future.plan = NULL)
[08:25:50.574]                   if (is.na(NA_character_)) 
[08:25:50.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.574]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.574]                     .init = FALSE)
[08:25:50.574]                 }
[08:25:50.574]             }
[08:25:50.574]         }
[08:25:50.574]     })
[08:25:50.574]     if (TRUE) {
[08:25:50.574]         base::sink(type = "output", split = FALSE)
[08:25:50.574]         if (TRUE) {
[08:25:50.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.574]         }
[08:25:50.574]         else {
[08:25:50.574]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.574]         }
[08:25:50.574]         base::close(...future.stdout)
[08:25:50.574]         ...future.stdout <- NULL
[08:25:50.574]     }
[08:25:50.574]     ...future.result$conditions <- ...future.conditions
[08:25:50.574]     ...future.result$finished <- base::Sys.time()
[08:25:50.574]     ...future.result
[08:25:50.574] }
[08:25:50.577] assign_globals() ...
[08:25:50.577] List of 5
[08:25:50.577]  $ ...future.FUN            :function (e1, e2)  
[08:25:50.577]  $ MoreArgs                 : NULL
[08:25:50.577]  $ ...future.elements_ii    :List of 2
[08:25:50.577]   ..$ :List of 2
[08:25:50.577]   .. ..$ : num 1
[08:25:50.577]   .. ..$ : num 1
[08:25:50.577]   ..$ :List of 2
[08:25:50.577]   .. ..$ : int 2
[08:25:50.577]   .. ..$ : int 3
[08:25:50.577]  $ ...future.seeds_ii       : NULL
[08:25:50.577]  $ ...future.globals.maxSize: NULL
[08:25:50.577]  - attr(*, "where")=List of 5
[08:25:50.577]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.577]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.577]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.577]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.577]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.577]  - attr(*, "resolved")= logi FALSE
[08:25:50.577]  - attr(*, "total_size")= num 216
[08:25:50.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.577]  - attr(*, "already-done")= logi TRUE
[08:25:50.591] - copied ‘...future.FUN’ to environment
[08:25:50.592] - copied ‘MoreArgs’ to environment
[08:25:50.592] - copied ‘...future.elements_ii’ to environment
[08:25:50.592] - copied ‘...future.seeds_ii’ to environment
[08:25:50.592] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.592] assign_globals() ... done
[08:25:50.592] requestCore(): workers = 2
[08:25:50.595] MulticoreFuture started
[08:25:50.596] - Launch lazy future ... done
[08:25:50.596] run() for ‘MulticoreFuture’ ... done
[08:25:50.596] Created future:
[08:25:50.596] plan(): Setting new future strategy stack:
[08:25:50.597] List of future strategies:
[08:25:50.597] 1. sequential:
[08:25:50.597]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.597]    - tweaked: FALSE
[08:25:50.597]    - call: NULL
[08:25:50.598] plan(): nbrOfWorkers() = 1
[08:25:50.600] plan(): Setting new future strategy stack:
[08:25:50.600] List of future strategies:
[08:25:50.600] 1. multicore:
[08:25:50.600]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.600]    - tweaked: FALSE
[08:25:50.600]    - call: plan(strategy)
[08:25:50.603] plan(): nbrOfWorkers() = 2
[08:25:50.596] MulticoreFuture:
[08:25:50.596] Label: ‘future_Map-2’
[08:25:50.596] Expression:
[08:25:50.596] {
[08:25:50.596]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.596]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.596]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.596]         on.exit(options(oopts), add = TRUE)
[08:25:50.596]     }
[08:25:50.596]     {
[08:25:50.596]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.596]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.596]         do.call(mapply, args = args)
[08:25:50.596]     }
[08:25:50.596] }
[08:25:50.596] Lazy evaluation: FALSE
[08:25:50.596] Asynchronous evaluation: TRUE
[08:25:50.596] Local evaluation: TRUE
[08:25:50.596] Environment: R_GlobalEnv
[08:25:50.596] Capture standard output: TRUE
[08:25:50.596] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.596] Globals: 5 objects totaling 216 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.596] Packages: <none>
[08:25:50.596] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:50.596] Resolved: TRUE
[08:25:50.596] Value: <not collected>
[08:25:50.596] Conditions captured: <none>
[08:25:50.596] Early signaling: FALSE
[08:25:50.596] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.596] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.604] Chunk #2 of 2 ... DONE
[08:25:50.604] Launching 2 futures (chunks) ... DONE
[08:25:50.605] Resolving 2 futures (chunks) ...
[08:25:50.605] resolve() on list ...
[08:25:50.605]  recursive: 0
[08:25:50.605]  length: 2
[08:25:50.605] 
[08:25:50.605] Future #1
[08:25:50.606] result() for MulticoreFuture ...
[08:25:50.606] result() for MulticoreFuture ...
[08:25:50.607] result() for MulticoreFuture ... done
[08:25:50.607] result() for MulticoreFuture ... done
[08:25:50.607] result() for MulticoreFuture ...
[08:25:50.607] result() for MulticoreFuture ... done
[08:25:50.607] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:50.607] - nx: 2
[08:25:50.607] - relay: TRUE
[08:25:50.608] - stdout: TRUE
[08:25:50.608] - signal: TRUE
[08:25:50.608] - resignal: FALSE
[08:25:50.608] - force: TRUE
[08:25:50.608] - relayed: [n=2] FALSE, FALSE
[08:25:50.608] - queued futures: [n=2] FALSE, FALSE
[08:25:50.608]  - until=1
[08:25:50.609]  - relaying element #1
[08:25:50.609] result() for MulticoreFuture ...
[08:25:50.609] result() for MulticoreFuture ... done
[08:25:50.609] result() for MulticoreFuture ...
[08:25:50.609] result() for MulticoreFuture ... done
[08:25:50.609] result() for MulticoreFuture ...
[08:25:50.609] result() for MulticoreFuture ... done
[08:25:50.609] result() for MulticoreFuture ...
[08:25:50.610] result() for MulticoreFuture ... done
[08:25:50.610] - relayed: [n=2] TRUE, FALSE
[08:25:50.610] - queued futures: [n=2] TRUE, FALSE
[08:25:50.610] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:50.610]  length: 1 (resolved future 1)
[08:25:50.610] Future #2
[08:25:50.611] result() for MulticoreFuture ...
[08:25:50.611] result() for MulticoreFuture ...
[08:25:50.612] result() for MulticoreFuture ... done
[08:25:50.612] result() for MulticoreFuture ... done
[08:25:50.612] result() for MulticoreFuture ...
[08:25:50.612] result() for MulticoreFuture ... done
[08:25:50.612] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:50.613] - nx: 2
[08:25:50.613] - relay: TRUE
[08:25:50.613] - stdout: TRUE
[08:25:50.613] - signal: TRUE
[08:25:50.613] - resignal: FALSE
[08:25:50.613] - force: TRUE
[08:25:50.614] - relayed: [n=2] TRUE, FALSE
[08:25:50.614] - queued futures: [n=2] TRUE, FALSE
[08:25:50.614]  - until=2
[08:25:50.614]  - relaying element #2
[08:25:50.614] result() for MulticoreFuture ...
[08:25:50.614] result() for MulticoreFuture ... done
[08:25:50.614] result() for MulticoreFuture ...
[08:25:50.615] result() for MulticoreFuture ... done
[08:25:50.615] result() for MulticoreFuture ...
[08:25:50.615] result() for MulticoreFuture ... done
[08:25:50.615] result() for MulticoreFuture ...
[08:25:50.615] result() for MulticoreFuture ... done
[08:25:50.615] - relayed: [n=2] TRUE, TRUE
[08:25:50.615] - queued futures: [n=2] TRUE, TRUE
[08:25:50.616] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:50.616]  length: 0 (resolved future 2)
[08:25:50.616] Relaying remaining futures
[08:25:50.616] signalConditionsASAP(NULL, pos=0) ...
[08:25:50.616] - nx: 2
[08:25:50.616] - relay: TRUE
[08:25:50.616] - stdout: TRUE
[08:25:50.616] - signal: TRUE
[08:25:50.616] - resignal: FALSE
[08:25:50.617] - force: TRUE
[08:25:50.617] - relayed: [n=2] TRUE, TRUE
[08:25:50.617] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:50.617] - relayed: [n=2] TRUE, TRUE
[08:25:50.617] - queued futures: [n=2] TRUE, TRUE
[08:25:50.617] signalConditionsASAP(NULL, pos=0) ... done
[08:25:50.617] resolve() on list ... DONE
[08:25:50.617] result() for MulticoreFuture ...
[08:25:50.617] result() for MulticoreFuture ... done
[08:25:50.618] result() for MulticoreFuture ...
[08:25:50.618] result() for MulticoreFuture ... done
[08:25:50.618] result() for MulticoreFuture ...
[08:25:50.618] result() for MulticoreFuture ... done
[08:25:50.618] result() for MulticoreFuture ...
[08:25:50.618] result() for MulticoreFuture ... done
[08:25:50.618]  - Number of value chunks collected: 2
[08:25:50.618] Resolving 2 futures (chunks) ... DONE
[08:25:50.619] Reducing values from 2 chunks ...
[08:25:50.619]  - Number of values collected after concatenation: 3
[08:25:50.619]  - Number of values expected: 3
[08:25:50.619] Reducing values from 2 chunks ... DONE
[08:25:50.619] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[08:25:50.620] future_mapply() ...
[08:25:50.622] Number of chunks: 2
[08:25:50.622] getGlobalsAndPackagesXApply() ...
[08:25:50.622]  - future.globals: TRUE
[08:25:50.622] getGlobalsAndPackages() ...
[08:25:50.622] Searching for globals...
[08:25:50.624] - globals found: [1] ‘FUN’
[08:25:50.624] Searching for globals ... DONE
[08:25:50.624] Resolving globals: FALSE
[08:25:50.624] The total size of the 1 globals is 185 bytes (185 bytes)
[08:25:50.625] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:25:50.625] - globals: [1] ‘FUN’
[08:25:50.625] 
[08:25:50.625] getGlobalsAndPackages() ... DONE
[08:25:50.625]  - globals found/used: [n=1] ‘FUN’
[08:25:50.626]  - needed namespaces: [n=0] 
[08:25:50.626] Finding globals ... DONE
[08:25:50.626] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:50.626] List of 2
[08:25:50.626]  $ ...future.FUN:function (x)  
[08:25:50.626]  $ MoreArgs     : NULL
[08:25:50.626]  - attr(*, "where")=List of 2
[08:25:50.626]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:50.626]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:50.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.626]  - attr(*, "resolved")= logi FALSE
[08:25:50.626]  - attr(*, "total_size")= num NA
[08:25:50.629] Packages to be attached in all futures: [n=0] 
[08:25:50.629] getGlobalsAndPackagesXApply() ... DONE
[08:25:50.630] Number of futures (= number of chunks): 2
[08:25:50.630] Launching 2 futures (chunks) ...
[08:25:50.630] Chunk #1 of 2 ...
[08:25:50.630]  - Finding globals in '...' for chunk #1 ...
[08:25:50.630] getGlobalsAndPackages() ...
[08:25:50.630] Searching for globals...
[08:25:50.631] 
[08:25:50.631] Searching for globals ... DONE
[08:25:50.631] - globals: [0] <none>
[08:25:50.631] getGlobalsAndPackages() ... DONE
[08:25:50.631]    + additional globals found: [n=0] 
[08:25:50.631]    + additional namespaces needed: [n=0] 
[08:25:50.631]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:50.631]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.632]  - seeds: <none>
[08:25:50.632]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.632] getGlobalsAndPackages() ...
[08:25:50.632] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.632] Resolving globals: FALSE
[08:25:50.633] The total size of the 5 globals is 363 bytes (363 bytes)
[08:25:50.633] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:50.633] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.633] 
[08:25:50.633] getGlobalsAndPackages() ... DONE
[08:25:50.634] run() for ‘Future’ ...
[08:25:50.634] - state: ‘created’
[08:25:50.634] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.636] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.636]   - Field: ‘label’
[08:25:50.636]   - Field: ‘local’
[08:25:50.637]   - Field: ‘owner’
[08:25:50.637]   - Field: ‘envir’
[08:25:50.637]   - Field: ‘workers’
[08:25:50.637]   - Field: ‘packages’
[08:25:50.637]   - Field: ‘gc’
[08:25:50.637]   - Field: ‘job’
[08:25:50.637]   - Field: ‘conditions’
[08:25:50.637]   - Field: ‘expr’
[08:25:50.638]   - Field: ‘uuid’
[08:25:50.638]   - Field: ‘seed’
[08:25:50.638]   - Field: ‘version’
[08:25:50.638]   - Field: ‘result’
[08:25:50.638]   - Field: ‘asynchronous’
[08:25:50.638]   - Field: ‘calls’
[08:25:50.638]   - Field: ‘globals’
[08:25:50.638]   - Field: ‘stdout’
[08:25:50.638]   - Field: ‘earlySignal’
[08:25:50.638]   - Field: ‘lazy’
[08:25:50.639]   - Field: ‘state’
[08:25:50.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.639] - Launch lazy future ...
[08:25:50.639] Packages needed by the future expression (n = 0): <none>
[08:25:50.639] Packages needed by future strategies (n = 0): <none>
[08:25:50.640] {
[08:25:50.640]     {
[08:25:50.640]         {
[08:25:50.640]             ...future.startTime <- base::Sys.time()
[08:25:50.640]             {
[08:25:50.640]                 {
[08:25:50.640]                   {
[08:25:50.640]                     {
[08:25:50.640]                       base::local({
[08:25:50.640]                         has_future <- base::requireNamespace("future", 
[08:25:50.640]                           quietly = TRUE)
[08:25:50.640]                         if (has_future) {
[08:25:50.640]                           ns <- base::getNamespace("future")
[08:25:50.640]                           version <- ns[[".package"]][["version"]]
[08:25:50.640]                           if (is.null(version)) 
[08:25:50.640]                             version <- utils::packageVersion("future")
[08:25:50.640]                         }
[08:25:50.640]                         else {
[08:25:50.640]                           version <- NULL
[08:25:50.640]                         }
[08:25:50.640]                         if (!has_future || version < "1.8.0") {
[08:25:50.640]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.640]                             "", base::R.version$version.string), 
[08:25:50.640]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:50.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:50.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.640]                               "release", "version")], collapse = " "), 
[08:25:50.640]                             hostname = base::Sys.info()[["nodename"]])
[08:25:50.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.640]                             info)
[08:25:50.640]                           info <- base::paste(info, collapse = "; ")
[08:25:50.640]                           if (!has_future) {
[08:25:50.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.640]                               info)
[08:25:50.640]                           }
[08:25:50.640]                           else {
[08:25:50.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.640]                               info, version)
[08:25:50.640]                           }
[08:25:50.640]                           base::stop(msg)
[08:25:50.640]                         }
[08:25:50.640]                       })
[08:25:50.640]                     }
[08:25:50.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.640]                     base::options(mc.cores = 1L)
[08:25:50.640]                   }
[08:25:50.640]                   ...future.strategy.old <- future::plan("list")
[08:25:50.640]                   options(future.plan = NULL)
[08:25:50.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.640]                 }
[08:25:50.640]                 ...future.workdir <- getwd()
[08:25:50.640]             }
[08:25:50.640]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.640]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.640]         }
[08:25:50.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.640]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.640]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.640]             base::names(...future.oldOptions))
[08:25:50.640]     }
[08:25:50.640]     if (FALSE) {
[08:25:50.640]     }
[08:25:50.640]     else {
[08:25:50.640]         if (TRUE) {
[08:25:50.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.640]                 open = "w")
[08:25:50.640]         }
[08:25:50.640]         else {
[08:25:50.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.640]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.640]         }
[08:25:50.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.640]             base::sink(type = "output", split = FALSE)
[08:25:50.640]             base::close(...future.stdout)
[08:25:50.640]         }, add = TRUE)
[08:25:50.640]     }
[08:25:50.640]     ...future.frame <- base::sys.nframe()
[08:25:50.640]     ...future.conditions <- base::list()
[08:25:50.640]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.640]     if (FALSE) {
[08:25:50.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.640]     }
[08:25:50.640]     ...future.result <- base::tryCatch({
[08:25:50.640]         base::withCallingHandlers({
[08:25:50.640]             ...future.value <- base::withVisible(base::local({
[08:25:50.640]                 withCallingHandlers({
[08:25:50.640]                   {
[08:25:50.640]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.640]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.640]                       ...future.globals.maxSize)) {
[08:25:50.640]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.640]                       on.exit(options(oopts), add = TRUE)
[08:25:50.640]                     }
[08:25:50.640]                     {
[08:25:50.640]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.640]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.640]                         USE.NAMES = FALSE)
[08:25:50.640]                       do.call(mapply, args = args)
[08:25:50.640]                     }
[08:25:50.640]                   }
[08:25:50.640]                 }, immediateCondition = function(cond) {
[08:25:50.640]                   save_rds <- function (object, pathname, ...) 
[08:25:50.640]                   {
[08:25:50.640]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.640]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.640]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.640]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.640]                         fi_tmp[["mtime"]])
[08:25:50.640]                     }
[08:25:50.640]                     tryCatch({
[08:25:50.640]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.640]                     }, error = function(ex) {
[08:25:50.640]                       msg <- conditionMessage(ex)
[08:25:50.640]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.640]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.640]                         fi_tmp[["mtime"]], msg)
[08:25:50.640]                       ex$message <- msg
[08:25:50.640]                       stop(ex)
[08:25:50.640]                     })
[08:25:50.640]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.640]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.640]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.640]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.640]                       fi <- file.info(pathname)
[08:25:50.640]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.640]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.640]                         fi[["size"]], fi[["mtime"]])
[08:25:50.640]                       stop(msg)
[08:25:50.640]                     }
[08:25:50.640]                     invisible(pathname)
[08:25:50.640]                   }
[08:25:50.640]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.640]                     rootPath = tempdir()) 
[08:25:50.640]                   {
[08:25:50.640]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.640]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.640]                       tmpdir = path, fileext = ".rds")
[08:25:50.640]                     save_rds(obj, file)
[08:25:50.640]                   }
[08:25:50.640]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.640]                   {
[08:25:50.640]                     inherits <- base::inherits
[08:25:50.640]                     invokeRestart <- base::invokeRestart
[08:25:50.640]                     is.null <- base::is.null
[08:25:50.640]                     muffled <- FALSE
[08:25:50.640]                     if (inherits(cond, "message")) {
[08:25:50.640]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.640]                       if (muffled) 
[08:25:50.640]                         invokeRestart("muffleMessage")
[08:25:50.640]                     }
[08:25:50.640]                     else if (inherits(cond, "warning")) {
[08:25:50.640]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.640]                       if (muffled) 
[08:25:50.640]                         invokeRestart("muffleWarning")
[08:25:50.640]                     }
[08:25:50.640]                     else if (inherits(cond, "condition")) {
[08:25:50.640]                       if (!is.null(pattern)) {
[08:25:50.640]                         computeRestarts <- base::computeRestarts
[08:25:50.640]                         grepl <- base::grepl
[08:25:50.640]                         restarts <- computeRestarts(cond)
[08:25:50.640]                         for (restart in restarts) {
[08:25:50.640]                           name <- restart$name
[08:25:50.640]                           if (is.null(name)) 
[08:25:50.640]                             next
[08:25:50.640]                           if (!grepl(pattern, name)) 
[08:25:50.640]                             next
[08:25:50.640]                           invokeRestart(restart)
[08:25:50.640]                           muffled <- TRUE
[08:25:50.640]                           break
[08:25:50.640]                         }
[08:25:50.640]                       }
[08:25:50.640]                     }
[08:25:50.640]                     invisible(muffled)
[08:25:50.640]                   }
[08:25:50.640]                   muffleCondition(cond)
[08:25:50.640]                 })
[08:25:50.640]             }))
[08:25:50.640]             future::FutureResult(value = ...future.value$value, 
[08:25:50.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.640]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.640]                     ...future.globalenv.names))
[08:25:50.640]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.640]         }, condition = base::local({
[08:25:50.640]             c <- base::c
[08:25:50.640]             inherits <- base::inherits
[08:25:50.640]             invokeRestart <- base::invokeRestart
[08:25:50.640]             length <- base::length
[08:25:50.640]             list <- base::list
[08:25:50.640]             seq.int <- base::seq.int
[08:25:50.640]             signalCondition <- base::signalCondition
[08:25:50.640]             sys.calls <- base::sys.calls
[08:25:50.640]             `[[` <- base::`[[`
[08:25:50.640]             `+` <- base::`+`
[08:25:50.640]             `<<-` <- base::`<<-`
[08:25:50.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.640]                   3L)]
[08:25:50.640]             }
[08:25:50.640]             function(cond) {
[08:25:50.640]                 is_error <- inherits(cond, "error")
[08:25:50.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.640]                   NULL)
[08:25:50.640]                 if (is_error) {
[08:25:50.640]                   sessionInformation <- function() {
[08:25:50.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.640]                       search = base::search(), system = base::Sys.info())
[08:25:50.640]                   }
[08:25:50.640]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.640]                     cond$call), session = sessionInformation(), 
[08:25:50.640]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.640]                   signalCondition(cond)
[08:25:50.640]                 }
[08:25:50.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.640]                 "immediateCondition"))) {
[08:25:50.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.640]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.640]                   if (TRUE && !signal) {
[08:25:50.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.640]                     {
[08:25:50.640]                       inherits <- base::inherits
[08:25:50.640]                       invokeRestart <- base::invokeRestart
[08:25:50.640]                       is.null <- base::is.null
[08:25:50.640]                       muffled <- FALSE
[08:25:50.640]                       if (inherits(cond, "message")) {
[08:25:50.640]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.640]                         if (muffled) 
[08:25:50.640]                           invokeRestart("muffleMessage")
[08:25:50.640]                       }
[08:25:50.640]                       else if (inherits(cond, "warning")) {
[08:25:50.640]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.640]                         if (muffled) 
[08:25:50.640]                           invokeRestart("muffleWarning")
[08:25:50.640]                       }
[08:25:50.640]                       else if (inherits(cond, "condition")) {
[08:25:50.640]                         if (!is.null(pattern)) {
[08:25:50.640]                           computeRestarts <- base::computeRestarts
[08:25:50.640]                           grepl <- base::grepl
[08:25:50.640]                           restarts <- computeRestarts(cond)
[08:25:50.640]                           for (restart in restarts) {
[08:25:50.640]                             name <- restart$name
[08:25:50.640]                             if (is.null(name)) 
[08:25:50.640]                               next
[08:25:50.640]                             if (!grepl(pattern, name)) 
[08:25:50.640]                               next
[08:25:50.640]                             invokeRestart(restart)
[08:25:50.640]                             muffled <- TRUE
[08:25:50.640]                             break
[08:25:50.640]                           }
[08:25:50.640]                         }
[08:25:50.640]                       }
[08:25:50.640]                       invisible(muffled)
[08:25:50.640]                     }
[08:25:50.640]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.640]                   }
[08:25:50.640]                 }
[08:25:50.640]                 else {
[08:25:50.640]                   if (TRUE) {
[08:25:50.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.640]                     {
[08:25:50.640]                       inherits <- base::inherits
[08:25:50.640]                       invokeRestart <- base::invokeRestart
[08:25:50.640]                       is.null <- base::is.null
[08:25:50.640]                       muffled <- FALSE
[08:25:50.640]                       if (inherits(cond, "message")) {
[08:25:50.640]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.640]                         if (muffled) 
[08:25:50.640]                           invokeRestart("muffleMessage")
[08:25:50.640]                       }
[08:25:50.640]                       else if (inherits(cond, "warning")) {
[08:25:50.640]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.640]                         if (muffled) 
[08:25:50.640]                           invokeRestart("muffleWarning")
[08:25:50.640]                       }
[08:25:50.640]                       else if (inherits(cond, "condition")) {
[08:25:50.640]                         if (!is.null(pattern)) {
[08:25:50.640]                           computeRestarts <- base::computeRestarts
[08:25:50.640]                           grepl <- base::grepl
[08:25:50.640]                           restarts <- computeRestarts(cond)
[08:25:50.640]                           for (restart in restarts) {
[08:25:50.640]                             name <- restart$name
[08:25:50.640]                             if (is.null(name)) 
[08:25:50.640]                               next
[08:25:50.640]                             if (!grepl(pattern, name)) 
[08:25:50.640]                               next
[08:25:50.640]                             invokeRestart(restart)
[08:25:50.640]                             muffled <- TRUE
[08:25:50.640]                             break
[08:25:50.640]                           }
[08:25:50.640]                         }
[08:25:50.640]                       }
[08:25:50.640]                       invisible(muffled)
[08:25:50.640]                     }
[08:25:50.640]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.640]                   }
[08:25:50.640]                 }
[08:25:50.640]             }
[08:25:50.640]         }))
[08:25:50.640]     }, error = function(ex) {
[08:25:50.640]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.640]                 ...future.rng), started = ...future.startTime, 
[08:25:50.640]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.640]             version = "1.8"), class = "FutureResult")
[08:25:50.640]     }, finally = {
[08:25:50.640]         if (!identical(...future.workdir, getwd())) 
[08:25:50.640]             setwd(...future.workdir)
[08:25:50.640]         {
[08:25:50.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.640]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.640]             }
[08:25:50.640]             base::options(...future.oldOptions)
[08:25:50.640]             if (.Platform$OS.type == "windows") {
[08:25:50.640]                 old_names <- names(...future.oldEnvVars)
[08:25:50.640]                 envs <- base::Sys.getenv()
[08:25:50.640]                 names <- names(envs)
[08:25:50.640]                 common <- intersect(names, old_names)
[08:25:50.640]                 added <- setdiff(names, old_names)
[08:25:50.640]                 removed <- setdiff(old_names, names)
[08:25:50.640]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.640]                   envs[common]]
[08:25:50.640]                 NAMES <- toupper(changed)
[08:25:50.640]                 args <- list()
[08:25:50.640]                 for (kk in seq_along(NAMES)) {
[08:25:50.640]                   name <- changed[[kk]]
[08:25:50.640]                   NAME <- NAMES[[kk]]
[08:25:50.640]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.640]                     next
[08:25:50.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.640]                 }
[08:25:50.640]                 NAMES <- toupper(added)
[08:25:50.640]                 for (kk in seq_along(NAMES)) {
[08:25:50.640]                   name <- added[[kk]]
[08:25:50.640]                   NAME <- NAMES[[kk]]
[08:25:50.640]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.640]                     next
[08:25:50.640]                   args[[name]] <- ""
[08:25:50.640]                 }
[08:25:50.640]                 NAMES <- toupper(removed)
[08:25:50.640]                 for (kk in seq_along(NAMES)) {
[08:25:50.640]                   name <- removed[[kk]]
[08:25:50.640]                   NAME <- NAMES[[kk]]
[08:25:50.640]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.640]                     next
[08:25:50.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.640]                 }
[08:25:50.640]                 if (length(args) > 0) 
[08:25:50.640]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.640]             }
[08:25:50.640]             else {
[08:25:50.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.640]             }
[08:25:50.640]             {
[08:25:50.640]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.640]                   0L) {
[08:25:50.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.640]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.640]                   base::options(opts)
[08:25:50.640]                 }
[08:25:50.640]                 {
[08:25:50.640]                   {
[08:25:50.640]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.640]                     NULL
[08:25:50.640]                   }
[08:25:50.640]                   options(future.plan = NULL)
[08:25:50.640]                   if (is.na(NA_character_)) 
[08:25:50.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.640]                     .init = FALSE)
[08:25:50.640]                 }
[08:25:50.640]             }
[08:25:50.640]         }
[08:25:50.640]     })
[08:25:50.640]     if (TRUE) {
[08:25:50.640]         base::sink(type = "output", split = FALSE)
[08:25:50.640]         if (TRUE) {
[08:25:50.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.640]         }
[08:25:50.640]         else {
[08:25:50.640]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.640]         }
[08:25:50.640]         base::close(...future.stdout)
[08:25:50.640]         ...future.stdout <- NULL
[08:25:50.640]     }
[08:25:50.640]     ...future.result$conditions <- ...future.conditions
[08:25:50.640]     ...future.result$finished <- base::Sys.time()
[08:25:50.640]     ...future.result
[08:25:50.640] }
[08:25:50.643] assign_globals() ...
[08:25:50.643] List of 5
[08:25:50.643]  $ ...future.FUN            :function (x)  
[08:25:50.643]  $ MoreArgs                 : NULL
[08:25:50.643]  $ ...future.elements_ii    :List of 1
[08:25:50.643]   ..$ :List of 1
[08:25:50.643]   .. ..$ a: num 0
[08:25:50.643]  $ ...future.seeds_ii       : NULL
[08:25:50.643]  $ ...future.globals.maxSize: NULL
[08:25:50.643]  - attr(*, "where")=List of 5
[08:25:50.643]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.643]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.643]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.643]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.643]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.643]  - attr(*, "resolved")= logi FALSE
[08:25:50.643]  - attr(*, "total_size")= num 363
[08:25:50.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.643]  - attr(*, "already-done")= logi TRUE
[08:25:50.648] - copied ‘...future.FUN’ to environment
[08:25:50.648] - copied ‘MoreArgs’ to environment
[08:25:50.648] - copied ‘...future.elements_ii’ to environment
[08:25:50.648] - copied ‘...future.seeds_ii’ to environment
[08:25:50.649] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.649] assign_globals() ... done
[08:25:50.649] requestCore(): workers = 2
[08:25:50.652] MulticoreFuture started
[08:25:50.652] - Launch lazy future ... done
[08:25:50.652] run() for ‘MulticoreFuture’ ... done
[08:25:50.652] Created future:
[08:25:50.653] plan(): Setting new future strategy stack:
[08:25:50.653] List of future strategies:
[08:25:50.653] 1. sequential:
[08:25:50.653]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.653]    - tweaked: FALSE
[08:25:50.653]    - call: NULL
[08:25:50.654] plan(): nbrOfWorkers() = 1
[08:25:50.656] plan(): Setting new future strategy stack:
[08:25:50.656] List of future strategies:
[08:25:50.656] 1. multicore:
[08:25:50.656]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.656]    - tweaked: FALSE
[08:25:50.656]    - call: plan(strategy)
[08:25:50.659] plan(): nbrOfWorkers() = 2
[08:25:50.653] MulticoreFuture:
[08:25:50.653] Label: ‘future_mapply-1’
[08:25:50.653] Expression:
[08:25:50.653] {
[08:25:50.653]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.653]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.653]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.653]         on.exit(options(oopts), add = TRUE)
[08:25:50.653]     }
[08:25:50.653]     {
[08:25:50.653]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.653]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.653]         do.call(mapply, args = args)
[08:25:50.653]     }
[08:25:50.653] }
[08:25:50.653] Lazy evaluation: FALSE
[08:25:50.653] Asynchronous evaluation: TRUE
[08:25:50.653] Local evaluation: TRUE
[08:25:50.653] Environment: R_GlobalEnv
[08:25:50.653] Capture standard output: TRUE
[08:25:50.653] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.653] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.653] Packages: <none>
[08:25:50.653] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:50.653] Resolved: TRUE
[08:25:50.653] Value: <not collected>
[08:25:50.653] Conditions captured: <none>
[08:25:50.653] Early signaling: FALSE
[08:25:50.653] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.653] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.660] Chunk #1 of 2 ... DONE
[08:25:50.661] Chunk #2 of 2 ...
[08:25:50.661]  - Finding globals in '...' for chunk #2 ...
[08:25:50.661] getGlobalsAndPackages() ...
[08:25:50.661] Searching for globals...
[08:25:50.662] 
[08:25:50.662] Searching for globals ... DONE
[08:25:50.662] - globals: [0] <none>
[08:25:50.662] getGlobalsAndPackages() ... DONE
[08:25:50.662]    + additional globals found: [n=0] 
[08:25:50.662]    + additional namespaces needed: [n=0] 
[08:25:50.662]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:50.663]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:50.663]  - seeds: <none>
[08:25:50.663]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.663] getGlobalsAndPackages() ...
[08:25:50.663] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.663] Resolving globals: FALSE
[08:25:50.664] The total size of the 5 globals is 363 bytes (363 bytes)
[08:25:50.665] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:50.665] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:50.665] 
[08:25:50.665] getGlobalsAndPackages() ... DONE
[08:25:50.666] run() for ‘Future’ ...
[08:25:50.666] - state: ‘created’
[08:25:50.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:25:50.669] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.669] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:25:50.669]   - Field: ‘label’
[08:25:50.669]   - Field: ‘local’
[08:25:50.669]   - Field: ‘owner’
[08:25:50.670]   - Field: ‘envir’
[08:25:50.670]   - Field: ‘workers’
[08:25:50.670]   - Field: ‘packages’
[08:25:50.670]   - Field: ‘gc’
[08:25:50.670]   - Field: ‘job’
[08:25:50.670]   - Field: ‘conditions’
[08:25:50.670]   - Field: ‘expr’
[08:25:50.671]   - Field: ‘uuid’
[08:25:50.671]   - Field: ‘seed’
[08:25:50.671]   - Field: ‘version’
[08:25:50.671]   - Field: ‘result’
[08:25:50.671]   - Field: ‘asynchronous’
[08:25:50.671]   - Field: ‘calls’
[08:25:50.671]   - Field: ‘globals’
[08:25:50.671]   - Field: ‘stdout’
[08:25:50.672]   - Field: ‘earlySignal’
[08:25:50.672]   - Field: ‘lazy’
[08:25:50.672]   - Field: ‘state’
[08:25:50.672] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:25:50.672] - Launch lazy future ...
[08:25:50.672] Packages needed by the future expression (n = 0): <none>
[08:25:50.673] Packages needed by future strategies (n = 0): <none>
[08:25:50.673] {
[08:25:50.673]     {
[08:25:50.673]         {
[08:25:50.673]             ...future.startTime <- base::Sys.time()
[08:25:50.673]             {
[08:25:50.673]                 {
[08:25:50.673]                   {
[08:25:50.673]                     {
[08:25:50.673]                       base::local({
[08:25:50.673]                         has_future <- base::requireNamespace("future", 
[08:25:50.673]                           quietly = TRUE)
[08:25:50.673]                         if (has_future) {
[08:25:50.673]                           ns <- base::getNamespace("future")
[08:25:50.673]                           version <- ns[[".package"]][["version"]]
[08:25:50.673]                           if (is.null(version)) 
[08:25:50.673]                             version <- utils::packageVersion("future")
[08:25:50.673]                         }
[08:25:50.673]                         else {
[08:25:50.673]                           version <- NULL
[08:25:50.673]                         }
[08:25:50.673]                         if (!has_future || version < "1.8.0") {
[08:25:50.673]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:50.673]                             "", base::R.version$version.string), 
[08:25:50.673]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:50.673]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:50.673]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:50.673]                               "release", "version")], collapse = " "), 
[08:25:50.673]                             hostname = base::Sys.info()[["nodename"]])
[08:25:50.673]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:50.673]                             info)
[08:25:50.673]                           info <- base::paste(info, collapse = "; ")
[08:25:50.673]                           if (!has_future) {
[08:25:50.673]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:50.673]                               info)
[08:25:50.673]                           }
[08:25:50.673]                           else {
[08:25:50.673]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:50.673]                               info, version)
[08:25:50.673]                           }
[08:25:50.673]                           base::stop(msg)
[08:25:50.673]                         }
[08:25:50.673]                       })
[08:25:50.673]                     }
[08:25:50.673]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:50.673]                     base::options(mc.cores = 1L)
[08:25:50.673]                   }
[08:25:50.673]                   ...future.strategy.old <- future::plan("list")
[08:25:50.673]                   options(future.plan = NULL)
[08:25:50.673]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.673]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:50.673]                 }
[08:25:50.673]                 ...future.workdir <- getwd()
[08:25:50.673]             }
[08:25:50.673]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:50.673]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:50.673]         }
[08:25:50.673]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:50.673]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:50.673]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:50.673]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:50.673]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:50.673]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:50.673]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:50.673]             base::names(...future.oldOptions))
[08:25:50.673]     }
[08:25:50.673]     if (FALSE) {
[08:25:50.673]     }
[08:25:50.673]     else {
[08:25:50.673]         if (TRUE) {
[08:25:50.673]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:50.673]                 open = "w")
[08:25:50.673]         }
[08:25:50.673]         else {
[08:25:50.673]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:50.673]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:50.673]         }
[08:25:50.673]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:50.673]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:50.673]             base::sink(type = "output", split = FALSE)
[08:25:50.673]             base::close(...future.stdout)
[08:25:50.673]         }, add = TRUE)
[08:25:50.673]     }
[08:25:50.673]     ...future.frame <- base::sys.nframe()
[08:25:50.673]     ...future.conditions <- base::list()
[08:25:50.673]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:50.673]     if (FALSE) {
[08:25:50.673]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:50.673]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:50.673]     }
[08:25:50.673]     ...future.result <- base::tryCatch({
[08:25:50.673]         base::withCallingHandlers({
[08:25:50.673]             ...future.value <- base::withVisible(base::local({
[08:25:50.673]                 withCallingHandlers({
[08:25:50.673]                   {
[08:25:50.673]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.673]                     if (!identical(...future.globals.maxSize.org, 
[08:25:50.673]                       ...future.globals.maxSize)) {
[08:25:50.673]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.673]                       on.exit(options(oopts), add = TRUE)
[08:25:50.673]                     }
[08:25:50.673]                     {
[08:25:50.673]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.673]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:50.673]                         USE.NAMES = FALSE)
[08:25:50.673]                       do.call(mapply, args = args)
[08:25:50.673]                     }
[08:25:50.673]                   }
[08:25:50.673]                 }, immediateCondition = function(cond) {
[08:25:50.673]                   save_rds <- function (object, pathname, ...) 
[08:25:50.673]                   {
[08:25:50.673]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:25:50.673]                     if (file_test("-f", pathname_tmp)) {
[08:25:50.673]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.673]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:25:50.673]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.673]                         fi_tmp[["mtime"]])
[08:25:50.673]                     }
[08:25:50.673]                     tryCatch({
[08:25:50.673]                       saveRDS(object, file = pathname_tmp, ...)
[08:25:50.673]                     }, error = function(ex) {
[08:25:50.673]                       msg <- conditionMessage(ex)
[08:25:50.673]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.673]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:25:50.673]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.673]                         fi_tmp[["mtime"]], msg)
[08:25:50.673]                       ex$message <- msg
[08:25:50.673]                       stop(ex)
[08:25:50.673]                     })
[08:25:50.673]                     stopifnot(file_test("-f", pathname_tmp))
[08:25:50.673]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:25:50.673]                     if (!res || file_test("-f", pathname_tmp)) {
[08:25:50.673]                       fi_tmp <- file.info(pathname_tmp)
[08:25:50.673]                       fi <- file.info(pathname)
[08:25:50.673]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:25:50.673]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:25:50.673]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:25:50.673]                         fi[["size"]], fi[["mtime"]])
[08:25:50.673]                       stop(msg)
[08:25:50.673]                     }
[08:25:50.673]                     invisible(pathname)
[08:25:50.673]                   }
[08:25:50.673]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:25:50.673]                     rootPath = tempdir()) 
[08:25:50.673]                   {
[08:25:50.673]                     obj <- list(time = Sys.time(), condition = cond)
[08:25:50.673]                     file <- tempfile(pattern = class(cond)[1], 
[08:25:50.673]                       tmpdir = path, fileext = ".rds")
[08:25:50.673]                     save_rds(obj, file)
[08:25:50.673]                   }
[08:25:50.673]                   saveImmediateCondition(cond, path = "/tmp/RtmpdTFewJ/.future/immediateConditions")
[08:25:50.673]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.673]                   {
[08:25:50.673]                     inherits <- base::inherits
[08:25:50.673]                     invokeRestart <- base::invokeRestart
[08:25:50.673]                     is.null <- base::is.null
[08:25:50.673]                     muffled <- FALSE
[08:25:50.673]                     if (inherits(cond, "message")) {
[08:25:50.673]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:50.673]                       if (muffled) 
[08:25:50.673]                         invokeRestart("muffleMessage")
[08:25:50.673]                     }
[08:25:50.673]                     else if (inherits(cond, "warning")) {
[08:25:50.673]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:50.673]                       if (muffled) 
[08:25:50.673]                         invokeRestart("muffleWarning")
[08:25:50.673]                     }
[08:25:50.673]                     else if (inherits(cond, "condition")) {
[08:25:50.673]                       if (!is.null(pattern)) {
[08:25:50.673]                         computeRestarts <- base::computeRestarts
[08:25:50.673]                         grepl <- base::grepl
[08:25:50.673]                         restarts <- computeRestarts(cond)
[08:25:50.673]                         for (restart in restarts) {
[08:25:50.673]                           name <- restart$name
[08:25:50.673]                           if (is.null(name)) 
[08:25:50.673]                             next
[08:25:50.673]                           if (!grepl(pattern, name)) 
[08:25:50.673]                             next
[08:25:50.673]                           invokeRestart(restart)
[08:25:50.673]                           muffled <- TRUE
[08:25:50.673]                           break
[08:25:50.673]                         }
[08:25:50.673]                       }
[08:25:50.673]                     }
[08:25:50.673]                     invisible(muffled)
[08:25:50.673]                   }
[08:25:50.673]                   muffleCondition(cond)
[08:25:50.673]                 })
[08:25:50.673]             }))
[08:25:50.673]             future::FutureResult(value = ...future.value$value, 
[08:25:50.673]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.673]                   ...future.rng), globalenv = if (FALSE) 
[08:25:50.673]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:50.673]                     ...future.globalenv.names))
[08:25:50.673]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:50.673]         }, condition = base::local({
[08:25:50.673]             c <- base::c
[08:25:50.673]             inherits <- base::inherits
[08:25:50.673]             invokeRestart <- base::invokeRestart
[08:25:50.673]             length <- base::length
[08:25:50.673]             list <- base::list
[08:25:50.673]             seq.int <- base::seq.int
[08:25:50.673]             signalCondition <- base::signalCondition
[08:25:50.673]             sys.calls <- base::sys.calls
[08:25:50.673]             `[[` <- base::`[[`
[08:25:50.673]             `+` <- base::`+`
[08:25:50.673]             `<<-` <- base::`<<-`
[08:25:50.673]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:50.673]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:50.673]                   3L)]
[08:25:50.673]             }
[08:25:50.673]             function(cond) {
[08:25:50.673]                 is_error <- inherits(cond, "error")
[08:25:50.673]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:50.673]                   NULL)
[08:25:50.673]                 if (is_error) {
[08:25:50.673]                   sessionInformation <- function() {
[08:25:50.673]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:50.673]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:50.673]                       search = base::search(), system = base::Sys.info())
[08:25:50.673]                   }
[08:25:50.673]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.673]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:50.673]                     cond$call), session = sessionInformation(), 
[08:25:50.673]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:50.673]                   signalCondition(cond)
[08:25:50.673]                 }
[08:25:50.673]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:50.673]                 "immediateCondition"))) {
[08:25:50.673]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:50.673]                   ...future.conditions[[length(...future.conditions) + 
[08:25:50.673]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:50.673]                   if (TRUE && !signal) {
[08:25:50.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.673]                     {
[08:25:50.673]                       inherits <- base::inherits
[08:25:50.673]                       invokeRestart <- base::invokeRestart
[08:25:50.673]                       is.null <- base::is.null
[08:25:50.673]                       muffled <- FALSE
[08:25:50.673]                       if (inherits(cond, "message")) {
[08:25:50.673]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.673]                         if (muffled) 
[08:25:50.673]                           invokeRestart("muffleMessage")
[08:25:50.673]                       }
[08:25:50.673]                       else if (inherits(cond, "warning")) {
[08:25:50.673]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.673]                         if (muffled) 
[08:25:50.673]                           invokeRestart("muffleWarning")
[08:25:50.673]                       }
[08:25:50.673]                       else if (inherits(cond, "condition")) {
[08:25:50.673]                         if (!is.null(pattern)) {
[08:25:50.673]                           computeRestarts <- base::computeRestarts
[08:25:50.673]                           grepl <- base::grepl
[08:25:50.673]                           restarts <- computeRestarts(cond)
[08:25:50.673]                           for (restart in restarts) {
[08:25:50.673]                             name <- restart$name
[08:25:50.673]                             if (is.null(name)) 
[08:25:50.673]                               next
[08:25:50.673]                             if (!grepl(pattern, name)) 
[08:25:50.673]                               next
[08:25:50.673]                             invokeRestart(restart)
[08:25:50.673]                             muffled <- TRUE
[08:25:50.673]                             break
[08:25:50.673]                           }
[08:25:50.673]                         }
[08:25:50.673]                       }
[08:25:50.673]                       invisible(muffled)
[08:25:50.673]                     }
[08:25:50.673]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.673]                   }
[08:25:50.673]                 }
[08:25:50.673]                 else {
[08:25:50.673]                   if (TRUE) {
[08:25:50.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:50.673]                     {
[08:25:50.673]                       inherits <- base::inherits
[08:25:50.673]                       invokeRestart <- base::invokeRestart
[08:25:50.673]                       is.null <- base::is.null
[08:25:50.673]                       muffled <- FALSE
[08:25:50.673]                       if (inherits(cond, "message")) {
[08:25:50.673]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:50.673]                         if (muffled) 
[08:25:50.673]                           invokeRestart("muffleMessage")
[08:25:50.673]                       }
[08:25:50.673]                       else if (inherits(cond, "warning")) {
[08:25:50.673]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:50.673]                         if (muffled) 
[08:25:50.673]                           invokeRestart("muffleWarning")
[08:25:50.673]                       }
[08:25:50.673]                       else if (inherits(cond, "condition")) {
[08:25:50.673]                         if (!is.null(pattern)) {
[08:25:50.673]                           computeRestarts <- base::computeRestarts
[08:25:50.673]                           grepl <- base::grepl
[08:25:50.673]                           restarts <- computeRestarts(cond)
[08:25:50.673]                           for (restart in restarts) {
[08:25:50.673]                             name <- restart$name
[08:25:50.673]                             if (is.null(name)) 
[08:25:50.673]                               next
[08:25:50.673]                             if (!grepl(pattern, name)) 
[08:25:50.673]                               next
[08:25:50.673]                             invokeRestart(restart)
[08:25:50.673]                             muffled <- TRUE
[08:25:50.673]                             break
[08:25:50.673]                           }
[08:25:50.673]                         }
[08:25:50.673]                       }
[08:25:50.673]                       invisible(muffled)
[08:25:50.673]                     }
[08:25:50.673]                     muffleCondition(cond, pattern = "^muffle")
[08:25:50.673]                   }
[08:25:50.673]                 }
[08:25:50.673]             }
[08:25:50.673]         }))
[08:25:50.673]     }, error = function(ex) {
[08:25:50.673]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:50.673]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:50.673]                 ...future.rng), started = ...future.startTime, 
[08:25:50.673]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:50.673]             version = "1.8"), class = "FutureResult")
[08:25:50.673]     }, finally = {
[08:25:50.673]         if (!identical(...future.workdir, getwd())) 
[08:25:50.673]             setwd(...future.workdir)
[08:25:50.673]         {
[08:25:50.673]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:50.673]                 ...future.oldOptions$nwarnings <- NULL
[08:25:50.673]             }
[08:25:50.673]             base::options(...future.oldOptions)
[08:25:50.673]             if (.Platform$OS.type == "windows") {
[08:25:50.673]                 old_names <- names(...future.oldEnvVars)
[08:25:50.673]                 envs <- base::Sys.getenv()
[08:25:50.673]                 names <- names(envs)
[08:25:50.673]                 common <- intersect(names, old_names)
[08:25:50.673]                 added <- setdiff(names, old_names)
[08:25:50.673]                 removed <- setdiff(old_names, names)
[08:25:50.673]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:50.673]                   envs[common]]
[08:25:50.673]                 NAMES <- toupper(changed)
[08:25:50.673]                 args <- list()
[08:25:50.673]                 for (kk in seq_along(NAMES)) {
[08:25:50.673]                   name <- changed[[kk]]
[08:25:50.673]                   NAME <- NAMES[[kk]]
[08:25:50.673]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.673]                     next
[08:25:50.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.673]                 }
[08:25:50.673]                 NAMES <- toupper(added)
[08:25:50.673]                 for (kk in seq_along(NAMES)) {
[08:25:50.673]                   name <- added[[kk]]
[08:25:50.673]                   NAME <- NAMES[[kk]]
[08:25:50.673]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.673]                     next
[08:25:50.673]                   args[[name]] <- ""
[08:25:50.673]                 }
[08:25:50.673]                 NAMES <- toupper(removed)
[08:25:50.673]                 for (kk in seq_along(NAMES)) {
[08:25:50.673]                   name <- removed[[kk]]
[08:25:50.673]                   NAME <- NAMES[[kk]]
[08:25:50.673]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:50.673]                     next
[08:25:50.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:50.673]                 }
[08:25:50.673]                 if (length(args) > 0) 
[08:25:50.673]                   base::do.call(base::Sys.setenv, args = args)
[08:25:50.673]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:50.673]             }
[08:25:50.673]             else {
[08:25:50.673]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:50.673]             }
[08:25:50.673]             {
[08:25:50.673]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:50.673]                   0L) {
[08:25:50.673]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:50.673]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:50.673]                   base::options(opts)
[08:25:50.673]                 }
[08:25:50.673]                 {
[08:25:50.673]                   {
[08:25:50.673]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:50.673]                     NULL
[08:25:50.673]                   }
[08:25:50.673]                   options(future.plan = NULL)
[08:25:50.673]                   if (is.na(NA_character_)) 
[08:25:50.673]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:50.673]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:50.673]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:50.673]                     .init = FALSE)
[08:25:50.673]                 }
[08:25:50.673]             }
[08:25:50.673]         }
[08:25:50.673]     })
[08:25:50.673]     if (TRUE) {
[08:25:50.673]         base::sink(type = "output", split = FALSE)
[08:25:50.673]         if (TRUE) {
[08:25:50.673]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:50.673]         }
[08:25:50.673]         else {
[08:25:50.673]             ...future.result["stdout"] <- base::list(NULL)
[08:25:50.673]         }
[08:25:50.673]         base::close(...future.stdout)
[08:25:50.673]         ...future.stdout <- NULL
[08:25:50.673]     }
[08:25:50.673]     ...future.result$conditions <- ...future.conditions
[08:25:50.673]     ...future.result$finished <- base::Sys.time()
[08:25:50.673]     ...future.result
[08:25:50.673] }
[08:25:50.677] assign_globals() ...
[08:25:50.677] List of 5
[08:25:50.677]  $ ...future.FUN            :function (x)  
[08:25:50.677]  $ MoreArgs                 : NULL
[08:25:50.677]  $ ...future.elements_ii    :List of 1
[08:25:50.677]   ..$ :List of 1
[08:25:50.677]   .. ..$ b: num 0
[08:25:50.677]  $ ...future.seeds_ii       : NULL
[08:25:50.677]  $ ...future.globals.maxSize: NULL
[08:25:50.677]  - attr(*, "where")=List of 5
[08:25:50.677]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:25:50.677]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:25:50.677]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:25:50.677]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:25:50.677]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:25:50.677]  - attr(*, "resolved")= logi FALSE
[08:25:50.677]  - attr(*, "total_size")= num 363
[08:25:50.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:50.677]  - attr(*, "already-done")= logi TRUE
[08:25:50.684] - copied ‘...future.FUN’ to environment
[08:25:50.684] - copied ‘MoreArgs’ to environment
[08:25:50.684] - copied ‘...future.elements_ii’ to environment
[08:25:50.684] - copied ‘...future.seeds_ii’ to environment
[08:25:50.684] - copied ‘...future.globals.maxSize’ to environment
[08:25:50.684] assign_globals() ... done
[08:25:50.685] requestCore(): workers = 2
[08:25:50.688] MulticoreFuture started
[08:25:50.688] - Launch lazy future ... done
[08:25:50.688] run() for ‘MulticoreFuture’ ... done
[08:25:50.688] Created future:
[08:25:50.689] plan(): Setting new future strategy stack:
[08:25:50.689] List of future strategies:
[08:25:50.689] 1. sequential:
[08:25:50.689]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.689]    - tweaked: FALSE
[08:25:50.689]    - call: NULL
[08:25:50.690] plan(): nbrOfWorkers() = 1
[08:25:50.692] plan(): Setting new future strategy stack:
[08:25:50.693] List of future strategies:
[08:25:50.693] 1. multicore:
[08:25:50.693]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:25:50.693]    - tweaked: FALSE
[08:25:50.693]    - call: plan(strategy)
[08:25:50.696] plan(): nbrOfWorkers() = 2
[08:25:50.689] MulticoreFuture:
[08:25:50.689] Label: ‘future_mapply-2’
[08:25:50.689] Expression:
[08:25:50.689] {
[08:25:50.689]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:50.689]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:50.689]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:50.689]         on.exit(options(oopts), add = TRUE)
[08:25:50.689]     }
[08:25:50.689]     {
[08:25:50.689]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:50.689]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:50.689]         do.call(mapply, args = args)
[08:25:50.689]     }
[08:25:50.689] }
[08:25:50.689] Lazy evaluation: FALSE
[08:25:50.689] Asynchronous evaluation: TRUE
[08:25:50.689] Local evaluation: TRUE
[08:25:50.689] Environment: R_GlobalEnv
[08:25:50.689] Capture standard output: TRUE
[08:25:50.689] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:50.689] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:50.689] Packages: <none>
[08:25:50.689] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:50.689] Resolved: TRUE
[08:25:50.689] Value: <not collected>
[08:25:50.689] Conditions captured: <none>
[08:25:50.689] Early signaling: FALSE
[08:25:50.689] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:50.689] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:50.697] Chunk #2 of 2 ... DONE
[08:25:50.697] Launching 2 futures (chunks) ... DONE
[08:25:50.697] Resolving 2 futures (chunks) ...
[08:25:50.697] resolve() on list ...
[08:25:50.697]  recursive: 0
[08:25:50.697]  length: 2
[08:25:50.698] 
[08:25:50.698] Future #1
[08:25:50.698] result() for MulticoreFuture ...
[08:25:50.699] result() for MulticoreFuture ...
[08:25:50.699] result() for MulticoreFuture ... done
[08:25:50.699] result() for MulticoreFuture ... done
[08:25:50.699] result() for MulticoreFuture ...
[08:25:50.700] result() for MulticoreFuture ... done
[08:25:50.700] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:25:50.700] - nx: 2
[08:25:50.700] - relay: TRUE
[08:25:50.700] - stdout: TRUE
[08:25:50.700] - signal: TRUE
[08:25:50.700] - resignal: FALSE
[08:25:50.700] - force: TRUE
[08:25:50.701] - relayed: [n=2] FALSE, FALSE
[08:25:50.701] - queued futures: [n=2] FALSE, FALSE
[08:25:50.701]  - until=1
[08:25:50.701]  - relaying element #1
[08:25:50.701] result() for MulticoreFuture ...
[08:25:50.701] result() for MulticoreFuture ... done
[08:25:50.701] result() for MulticoreFuture ...
[08:25:50.701] result() for MulticoreFuture ... done
[08:25:50.702] result() for MulticoreFuture ...
[08:25:50.702] result() for MulticoreFuture ... done
[08:25:50.702] result() for MulticoreFuture ...
[08:25:50.702] result() for MulticoreFuture ... done
[08:25:50.702] - relayed: [n=2] TRUE, FALSE
[08:25:50.702] - queued futures: [n=2] TRUE, FALSE
[08:25:50.702] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:25:50.703]  length: 1 (resolved future 1)
[08:25:50.703] Future #2
[08:25:50.703] result() for MulticoreFuture ...
[08:25:50.704] result() for MulticoreFuture ...
[08:25:50.704] result() for MulticoreFuture ... done
[08:25:50.704] result() for MulticoreFuture ... done
[08:25:50.704] result() for MulticoreFuture ...
[08:25:50.704] result() for MulticoreFuture ... done
[08:25:50.705] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:25:50.705] - nx: 2
[08:25:50.705] - relay: TRUE
[08:25:50.705] - stdout: TRUE
[08:25:50.705] - signal: TRUE
[08:25:50.705] - resignal: FALSE
[08:25:50.706] - force: TRUE
[08:25:50.706] - relayed: [n=2] TRUE, FALSE
[08:25:50.706] - queued futures: [n=2] TRUE, FALSE
[08:25:50.706]  - until=2
[08:25:50.706]  - relaying element #2
[08:25:50.706] result() for MulticoreFuture ...
[08:25:50.707] result() for MulticoreFuture ... done
[08:25:50.707] result() for MulticoreFuture ...
[08:25:50.707] result() for MulticoreFuture ... done
[08:25:50.707] result() for MulticoreFuture ...
[08:25:50.707] result() for MulticoreFuture ... done
[08:25:50.708] result() for MulticoreFuture ...
[08:25:50.708] result() for MulticoreFuture ... done
[08:25:50.708] - relayed: [n=2] TRUE, TRUE
[08:25:50.708] - queued futures: [n=2] TRUE, TRUE
[08:25:50.708] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:25:50.708]  length: 0 (resolved future 2)
[08:25:50.708] Relaying remaining futures
[08:25:50.709] signalConditionsASAP(NULL, pos=0) ...
[08:25:50.709] - nx: 2
[08:25:50.709] - relay: TRUE
[08:25:50.709] - stdout: TRUE
[08:25:50.709] - signal: TRUE
[08:25:50.709] - resignal: FALSE
[08:25:50.709] - force: TRUE
[08:25:50.709] - relayed: [n=2] TRUE, TRUE
[08:25:50.709] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:50.710] - relayed: [n=2] TRUE, TRUE
[08:25:50.710] - queued futures: [n=2] TRUE, TRUE
[08:25:50.710] signalConditionsASAP(NULL, pos=0) ... done
[08:25:50.710] resolve() on list ... DONE
[08:25:50.710] result() for MulticoreFuture ...
[08:25:50.710] result() for MulticoreFuture ... done
[08:25:50.710] result() for MulticoreFuture ...
[08:25:50.710] result() for MulticoreFuture ... done
[08:25:50.710] result() for MulticoreFuture ...
[08:25:50.711] result() for MulticoreFuture ... done
[08:25:50.711] result() for MulticoreFuture ...
[08:25:50.711] result() for MulticoreFuture ... done
[08:25:50.711]  - Number of value chunks collected: 2
[08:25:50.711] Resolving 2 futures (chunks) ... DONE
[08:25:50.711] Reducing values from 2 chunks ...
[08:25:50.711]  - Number of values collected after concatenation: 2
[08:25:50.711]  - Number of values expected: 2
[08:25:50.711] Reducing values from 2 chunks ... DONE
[08:25:50.712] future_mapply() ... DONE
[08:25:50.712] plan(): Setting new future strategy stack:
[08:25:50.712] List of future strategies:
[08:25:50.712] 1. sequential:
[08:25:50.712]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:50.712]    - tweaked: FALSE
[08:25:50.712]    - call: plan(sequential)
[08:25:50.713] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[08:25:50.713] plan(): Setting new future strategy stack:
[08:25:50.713] List of future strategies:
[08:25:50.713] 1. multisession:
[08:25:50.713]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:25:50.713]    - tweaked: FALSE
[08:25:50.713]    - call: plan(strategy)
[08:25:50.714] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:25:50.714] multisession:
[08:25:50.714] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:25:50.714] - tweaked: FALSE
[08:25:50.714] - call: plan(strategy)
[08:25:50.718] getGlobalsAndPackages() ...
[08:25:50.718] Not searching for globals
[08:25:50.719] - globals: [0] <none>
[08:25:50.719] getGlobalsAndPackages() ... DONE
[08:25:51.227] Packages needed by the future expression (n = 0): <none>
[08:25:51.227] Packages needed by future strategies (n = 0): <none>
[08:25:51.228] {
[08:25:51.228]     {
[08:25:51.228]         {
[08:25:51.228]             ...future.startTime <- base::Sys.time()
[08:25:51.228]             {
[08:25:51.228]                 {
[08:25:51.228]                   {
[08:25:51.228]                     {
[08:25:51.228]                       base::local({
[08:25:51.228]                         has_future <- base::requireNamespace("future", 
[08:25:51.228]                           quietly = TRUE)
[08:25:51.228]                         if (has_future) {
[08:25:51.228]                           ns <- base::getNamespace("future")
[08:25:51.228]                           version <- ns[[".package"]][["version"]]
[08:25:51.228]                           if (is.null(version)) 
[08:25:51.228]                             version <- utils::packageVersion("future")
[08:25:51.228]                         }
[08:25:51.228]                         else {
[08:25:51.228]                           version <- NULL
[08:25:51.228]                         }
[08:25:51.228]                         if (!has_future || version < "1.8.0") {
[08:25:51.228]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.228]                             "", base::R.version$version.string), 
[08:25:51.228]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.228]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.228]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.228]                               "release", "version")], collapse = " "), 
[08:25:51.228]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.228]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.228]                             info)
[08:25:51.228]                           info <- base::paste(info, collapse = "; ")
[08:25:51.228]                           if (!has_future) {
[08:25:51.228]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.228]                               info)
[08:25:51.228]                           }
[08:25:51.228]                           else {
[08:25:51.228]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.228]                               info, version)
[08:25:51.228]                           }
[08:25:51.228]                           base::stop(msg)
[08:25:51.228]                         }
[08:25:51.228]                       })
[08:25:51.228]                     }
[08:25:51.228]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.228]                     base::options(mc.cores = 1L)
[08:25:51.228]                   }
[08:25:51.228]                   ...future.strategy.old <- future::plan("list")
[08:25:51.228]                   options(future.plan = NULL)
[08:25:51.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.228]                 }
[08:25:51.228]                 ...future.workdir <- getwd()
[08:25:51.228]             }
[08:25:51.228]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.228]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.228]         }
[08:25:51.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:51.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.228]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.228]             base::names(...future.oldOptions))
[08:25:51.228]     }
[08:25:51.228]     if (FALSE) {
[08:25:51.228]     }
[08:25:51.228]     else {
[08:25:51.228]         if (TRUE) {
[08:25:51.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.228]                 open = "w")
[08:25:51.228]         }
[08:25:51.228]         else {
[08:25:51.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.228]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.228]         }
[08:25:51.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.228]             base::sink(type = "output", split = FALSE)
[08:25:51.228]             base::close(...future.stdout)
[08:25:51.228]         }, add = TRUE)
[08:25:51.228]     }
[08:25:51.228]     ...future.frame <- base::sys.nframe()
[08:25:51.228]     ...future.conditions <- base::list()
[08:25:51.228]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.228]     if (FALSE) {
[08:25:51.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.228]     }
[08:25:51.228]     ...future.result <- base::tryCatch({
[08:25:51.228]         base::withCallingHandlers({
[08:25:51.228]             ...future.value <- base::withVisible(base::local({
[08:25:51.228]                 ...future.makeSendCondition <- base::local({
[08:25:51.228]                   sendCondition <- NULL
[08:25:51.228]                   function(frame = 1L) {
[08:25:51.228]                     if (is.function(sendCondition)) 
[08:25:51.228]                       return(sendCondition)
[08:25:51.228]                     ns <- getNamespace("parallel")
[08:25:51.228]                     if (exists("sendData", mode = "function", 
[08:25:51.228]                       envir = ns)) {
[08:25:51.228]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.228]                         envir = ns)
[08:25:51.228]                       envir <- sys.frame(frame)
[08:25:51.228]                       master <- NULL
[08:25:51.228]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.228]                         !identical(envir, emptyenv())) {
[08:25:51.228]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.228]                           inherits = FALSE)) {
[08:25:51.228]                           master <- get("master", mode = "list", 
[08:25:51.228]                             envir = envir, inherits = FALSE)
[08:25:51.228]                           if (inherits(master, c("SOCKnode", 
[08:25:51.228]                             "SOCK0node"))) {
[08:25:51.228]                             sendCondition <<- function(cond) {
[08:25:51.228]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.228]                                 success = TRUE)
[08:25:51.228]                               parallel_sendData(master, data)
[08:25:51.228]                             }
[08:25:51.228]                             return(sendCondition)
[08:25:51.228]                           }
[08:25:51.228]                         }
[08:25:51.228]                         frame <- frame + 1L
[08:25:51.228]                         envir <- sys.frame(frame)
[08:25:51.228]                       }
[08:25:51.228]                     }
[08:25:51.228]                     sendCondition <<- function(cond) NULL
[08:25:51.228]                   }
[08:25:51.228]                 })
[08:25:51.228]                 withCallingHandlers({
[08:25:51.228]                   NA
[08:25:51.228]                 }, immediateCondition = function(cond) {
[08:25:51.228]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.228]                   sendCondition(cond)
[08:25:51.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.228]                   {
[08:25:51.228]                     inherits <- base::inherits
[08:25:51.228]                     invokeRestart <- base::invokeRestart
[08:25:51.228]                     is.null <- base::is.null
[08:25:51.228]                     muffled <- FALSE
[08:25:51.228]                     if (inherits(cond, "message")) {
[08:25:51.228]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.228]                       if (muffled) 
[08:25:51.228]                         invokeRestart("muffleMessage")
[08:25:51.228]                     }
[08:25:51.228]                     else if (inherits(cond, "warning")) {
[08:25:51.228]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.228]                       if (muffled) 
[08:25:51.228]                         invokeRestart("muffleWarning")
[08:25:51.228]                     }
[08:25:51.228]                     else if (inherits(cond, "condition")) {
[08:25:51.228]                       if (!is.null(pattern)) {
[08:25:51.228]                         computeRestarts <- base::computeRestarts
[08:25:51.228]                         grepl <- base::grepl
[08:25:51.228]                         restarts <- computeRestarts(cond)
[08:25:51.228]                         for (restart in restarts) {
[08:25:51.228]                           name <- restart$name
[08:25:51.228]                           if (is.null(name)) 
[08:25:51.228]                             next
[08:25:51.228]                           if (!grepl(pattern, name)) 
[08:25:51.228]                             next
[08:25:51.228]                           invokeRestart(restart)
[08:25:51.228]                           muffled <- TRUE
[08:25:51.228]                           break
[08:25:51.228]                         }
[08:25:51.228]                       }
[08:25:51.228]                     }
[08:25:51.228]                     invisible(muffled)
[08:25:51.228]                   }
[08:25:51.228]                   muffleCondition(cond)
[08:25:51.228]                 })
[08:25:51.228]             }))
[08:25:51.228]             future::FutureResult(value = ...future.value$value, 
[08:25:51.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.228]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.228]                     ...future.globalenv.names))
[08:25:51.228]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.228]         }, condition = base::local({
[08:25:51.228]             c <- base::c
[08:25:51.228]             inherits <- base::inherits
[08:25:51.228]             invokeRestart <- base::invokeRestart
[08:25:51.228]             length <- base::length
[08:25:51.228]             list <- base::list
[08:25:51.228]             seq.int <- base::seq.int
[08:25:51.228]             signalCondition <- base::signalCondition
[08:25:51.228]             sys.calls <- base::sys.calls
[08:25:51.228]             `[[` <- base::`[[`
[08:25:51.228]             `+` <- base::`+`
[08:25:51.228]             `<<-` <- base::`<<-`
[08:25:51.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.228]                   3L)]
[08:25:51.228]             }
[08:25:51.228]             function(cond) {
[08:25:51.228]                 is_error <- inherits(cond, "error")
[08:25:51.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.228]                   NULL)
[08:25:51.228]                 if (is_error) {
[08:25:51.228]                   sessionInformation <- function() {
[08:25:51.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.228]                       search = base::search(), system = base::Sys.info())
[08:25:51.228]                   }
[08:25:51.228]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.228]                     cond$call), session = sessionInformation(), 
[08:25:51.228]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.228]                   signalCondition(cond)
[08:25:51.228]                 }
[08:25:51.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.228]                 "immediateCondition"))) {
[08:25:51.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.228]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.228]                   if (TRUE && !signal) {
[08:25:51.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.228]                     {
[08:25:51.228]                       inherits <- base::inherits
[08:25:51.228]                       invokeRestart <- base::invokeRestart
[08:25:51.228]                       is.null <- base::is.null
[08:25:51.228]                       muffled <- FALSE
[08:25:51.228]                       if (inherits(cond, "message")) {
[08:25:51.228]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.228]                         if (muffled) 
[08:25:51.228]                           invokeRestart("muffleMessage")
[08:25:51.228]                       }
[08:25:51.228]                       else if (inherits(cond, "warning")) {
[08:25:51.228]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.228]                         if (muffled) 
[08:25:51.228]                           invokeRestart("muffleWarning")
[08:25:51.228]                       }
[08:25:51.228]                       else if (inherits(cond, "condition")) {
[08:25:51.228]                         if (!is.null(pattern)) {
[08:25:51.228]                           computeRestarts <- base::computeRestarts
[08:25:51.228]                           grepl <- base::grepl
[08:25:51.228]                           restarts <- computeRestarts(cond)
[08:25:51.228]                           for (restart in restarts) {
[08:25:51.228]                             name <- restart$name
[08:25:51.228]                             if (is.null(name)) 
[08:25:51.228]                               next
[08:25:51.228]                             if (!grepl(pattern, name)) 
[08:25:51.228]                               next
[08:25:51.228]                             invokeRestart(restart)
[08:25:51.228]                             muffled <- TRUE
[08:25:51.228]                             break
[08:25:51.228]                           }
[08:25:51.228]                         }
[08:25:51.228]                       }
[08:25:51.228]                       invisible(muffled)
[08:25:51.228]                     }
[08:25:51.228]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.228]                   }
[08:25:51.228]                 }
[08:25:51.228]                 else {
[08:25:51.228]                   if (TRUE) {
[08:25:51.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.228]                     {
[08:25:51.228]                       inherits <- base::inherits
[08:25:51.228]                       invokeRestart <- base::invokeRestart
[08:25:51.228]                       is.null <- base::is.null
[08:25:51.228]                       muffled <- FALSE
[08:25:51.228]                       if (inherits(cond, "message")) {
[08:25:51.228]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.228]                         if (muffled) 
[08:25:51.228]                           invokeRestart("muffleMessage")
[08:25:51.228]                       }
[08:25:51.228]                       else if (inherits(cond, "warning")) {
[08:25:51.228]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.228]                         if (muffled) 
[08:25:51.228]                           invokeRestart("muffleWarning")
[08:25:51.228]                       }
[08:25:51.228]                       else if (inherits(cond, "condition")) {
[08:25:51.228]                         if (!is.null(pattern)) {
[08:25:51.228]                           computeRestarts <- base::computeRestarts
[08:25:51.228]                           grepl <- base::grepl
[08:25:51.228]                           restarts <- computeRestarts(cond)
[08:25:51.228]                           for (restart in restarts) {
[08:25:51.228]                             name <- restart$name
[08:25:51.228]                             if (is.null(name)) 
[08:25:51.228]                               next
[08:25:51.228]                             if (!grepl(pattern, name)) 
[08:25:51.228]                               next
[08:25:51.228]                             invokeRestart(restart)
[08:25:51.228]                             muffled <- TRUE
[08:25:51.228]                             break
[08:25:51.228]                           }
[08:25:51.228]                         }
[08:25:51.228]                       }
[08:25:51.228]                       invisible(muffled)
[08:25:51.228]                     }
[08:25:51.228]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.228]                   }
[08:25:51.228]                 }
[08:25:51.228]             }
[08:25:51.228]         }))
[08:25:51.228]     }, error = function(ex) {
[08:25:51.228]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.228]                 ...future.rng), started = ...future.startTime, 
[08:25:51.228]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.228]             version = "1.8"), class = "FutureResult")
[08:25:51.228]     }, finally = {
[08:25:51.228]         if (!identical(...future.workdir, getwd())) 
[08:25:51.228]             setwd(...future.workdir)
[08:25:51.228]         {
[08:25:51.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.228]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.228]             }
[08:25:51.228]             base::options(...future.oldOptions)
[08:25:51.228]             if (.Platform$OS.type == "windows") {
[08:25:51.228]                 old_names <- names(...future.oldEnvVars)
[08:25:51.228]                 envs <- base::Sys.getenv()
[08:25:51.228]                 names <- names(envs)
[08:25:51.228]                 common <- intersect(names, old_names)
[08:25:51.228]                 added <- setdiff(names, old_names)
[08:25:51.228]                 removed <- setdiff(old_names, names)
[08:25:51.228]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.228]                   envs[common]]
[08:25:51.228]                 NAMES <- toupper(changed)
[08:25:51.228]                 args <- list()
[08:25:51.228]                 for (kk in seq_along(NAMES)) {
[08:25:51.228]                   name <- changed[[kk]]
[08:25:51.228]                   NAME <- NAMES[[kk]]
[08:25:51.228]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.228]                     next
[08:25:51.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.228]                 }
[08:25:51.228]                 NAMES <- toupper(added)
[08:25:51.228]                 for (kk in seq_along(NAMES)) {
[08:25:51.228]                   name <- added[[kk]]
[08:25:51.228]                   NAME <- NAMES[[kk]]
[08:25:51.228]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.228]                     next
[08:25:51.228]                   args[[name]] <- ""
[08:25:51.228]                 }
[08:25:51.228]                 NAMES <- toupper(removed)
[08:25:51.228]                 for (kk in seq_along(NAMES)) {
[08:25:51.228]                   name <- removed[[kk]]
[08:25:51.228]                   NAME <- NAMES[[kk]]
[08:25:51.228]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.228]                     next
[08:25:51.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.228]                 }
[08:25:51.228]                 if (length(args) > 0) 
[08:25:51.228]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.228]             }
[08:25:51.228]             else {
[08:25:51.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.228]             }
[08:25:51.228]             {
[08:25:51.228]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.228]                   0L) {
[08:25:51.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.228]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.228]                   base::options(opts)
[08:25:51.228]                 }
[08:25:51.228]                 {
[08:25:51.228]                   {
[08:25:51.228]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.228]                     NULL
[08:25:51.228]                   }
[08:25:51.228]                   options(future.plan = NULL)
[08:25:51.228]                   if (is.na(NA_character_)) 
[08:25:51.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.228]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.228]                     .init = FALSE)
[08:25:51.228]                 }
[08:25:51.228]             }
[08:25:51.228]         }
[08:25:51.228]     })
[08:25:51.228]     if (TRUE) {
[08:25:51.228]         base::sink(type = "output", split = FALSE)
[08:25:51.228]         if (TRUE) {
[08:25:51.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.228]         }
[08:25:51.228]         else {
[08:25:51.228]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.228]         }
[08:25:51.228]         base::close(...future.stdout)
[08:25:51.228]         ...future.stdout <- NULL
[08:25:51.228]     }
[08:25:51.228]     ...future.result$conditions <- ...future.conditions
[08:25:51.228]     ...future.result$finished <- base::Sys.time()
[08:25:51.228]     ...future.result
[08:25:51.228] }
[08:25:51.282] MultisessionFuture started
[08:25:51.283] result() for ClusterFuture ...
[08:25:51.283] receiveMessageFromWorker() for ClusterFuture ...
[08:25:51.283] - Validating connection of MultisessionFuture
[08:25:51.315] - received message: FutureResult
[08:25:51.315] - Received FutureResult
[08:25:51.315] - Erased future from FutureRegistry
[08:25:51.315] result() for ClusterFuture ...
[08:25:51.315] - result already collected: FutureResult
[08:25:51.316] result() for ClusterFuture ... done
[08:25:51.316] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:51.316] result() for ClusterFuture ... done
[08:25:51.316] result() for ClusterFuture ...
[08:25:51.316] - result already collected: FutureResult
[08:25:51.316] result() for ClusterFuture ... done
[08:25:51.316] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:25:51.318] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[08:25:51.318] future_mapply() ...
[08:25:51.320] Number of chunks: 2
[08:25:51.320] getGlobalsAndPackagesXApply() ...
[08:25:51.320]  - future.globals: TRUE
[08:25:51.320] getGlobalsAndPackages() ...
[08:25:51.320] Searching for globals...
[08:25:51.321] - globals found: [1] ‘FUN’
[08:25:51.321] Searching for globals ... DONE
[08:25:51.321] Resolving globals: FALSE
[08:25:51.321] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:51.321] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:51.322] - globals: [1] ‘FUN’
[08:25:51.322] 
[08:25:51.322] getGlobalsAndPackages() ... DONE
[08:25:51.322]  - globals found/used: [n=1] ‘FUN’
[08:25:51.322]  - needed namespaces: [n=0] 
[08:25:51.322] Finding globals ... DONE
[08:25:51.322] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:51.322] List of 2
[08:25:51.322]  $ ...future.FUN:function (x, ...)  
[08:25:51.322]  $ MoreArgs     : NULL
[08:25:51.322]  - attr(*, "where")=List of 2
[08:25:51.322]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:51.322]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:51.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:51.322]  - attr(*, "resolved")= logi FALSE
[08:25:51.322]  - attr(*, "total_size")= num NA
[08:25:51.325] Packages to be attached in all futures: [n=0] 
[08:25:51.325] getGlobalsAndPackagesXApply() ... DONE
[08:25:51.325] Number of futures (= number of chunks): 2
[08:25:51.325] Launching 2 futures (chunks) ...
[08:25:51.325] Chunk #1 of 2 ...
[08:25:51.325]  - Finding globals in '...' for chunk #1 ...
[08:25:51.325] getGlobalsAndPackages() ...
[08:25:51.326] Searching for globals...
[08:25:51.326] 
[08:25:51.326] Searching for globals ... DONE
[08:25:51.326] - globals: [0] <none>
[08:25:51.326] getGlobalsAndPackages() ... DONE
[08:25:51.326]    + additional globals found: [n=0] 
[08:25:51.326]    + additional namespaces needed: [n=0] 
[08:25:51.326]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:51.326]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:51.327]  - seeds: <none>
[08:25:51.327]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.327] getGlobalsAndPackages() ...
[08:25:51.327] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.327] Resolving globals: FALSE
[08:25:51.327] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:51.328] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:51.328] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.328] 
[08:25:51.328] getGlobalsAndPackages() ... DONE
[08:25:51.328] run() for ‘Future’ ...
[08:25:51.328] - state: ‘created’
[08:25:51.329] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:51.342] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.342] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:51.342]   - Field: ‘node’
[08:25:51.342]   - Field: ‘label’
[08:25:51.342]   - Field: ‘local’
[08:25:51.343]   - Field: ‘owner’
[08:25:51.343]   - Field: ‘envir’
[08:25:51.343]   - Field: ‘workers’
[08:25:51.343]   - Field: ‘packages’
[08:25:51.343]   - Field: ‘gc’
[08:25:51.343]   - Field: ‘conditions’
[08:25:51.343]   - Field: ‘persistent’
[08:25:51.343]   - Field: ‘expr’
[08:25:51.343]   - Field: ‘uuid’
[08:25:51.343]   - Field: ‘seed’
[08:25:51.343]   - Field: ‘version’
[08:25:51.343]   - Field: ‘result’
[08:25:51.344]   - Field: ‘asynchronous’
[08:25:51.344]   - Field: ‘calls’
[08:25:51.344]   - Field: ‘globals’
[08:25:51.344]   - Field: ‘stdout’
[08:25:51.344]   - Field: ‘earlySignal’
[08:25:51.344]   - Field: ‘lazy’
[08:25:51.344]   - Field: ‘state’
[08:25:51.344] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:51.344] - Launch lazy future ...
[08:25:51.345] Packages needed by the future expression (n = 0): <none>
[08:25:51.345] Packages needed by future strategies (n = 0): <none>
[08:25:51.345] {
[08:25:51.345]     {
[08:25:51.345]         {
[08:25:51.345]             ...future.startTime <- base::Sys.time()
[08:25:51.345]             {
[08:25:51.345]                 {
[08:25:51.345]                   {
[08:25:51.345]                     {
[08:25:51.345]                       base::local({
[08:25:51.345]                         has_future <- base::requireNamespace("future", 
[08:25:51.345]                           quietly = TRUE)
[08:25:51.345]                         if (has_future) {
[08:25:51.345]                           ns <- base::getNamespace("future")
[08:25:51.345]                           version <- ns[[".package"]][["version"]]
[08:25:51.345]                           if (is.null(version)) 
[08:25:51.345]                             version <- utils::packageVersion("future")
[08:25:51.345]                         }
[08:25:51.345]                         else {
[08:25:51.345]                           version <- NULL
[08:25:51.345]                         }
[08:25:51.345]                         if (!has_future || version < "1.8.0") {
[08:25:51.345]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.345]                             "", base::R.version$version.string), 
[08:25:51.345]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.345]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.345]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.345]                               "release", "version")], collapse = " "), 
[08:25:51.345]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.345]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.345]                             info)
[08:25:51.345]                           info <- base::paste(info, collapse = "; ")
[08:25:51.345]                           if (!has_future) {
[08:25:51.345]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.345]                               info)
[08:25:51.345]                           }
[08:25:51.345]                           else {
[08:25:51.345]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.345]                               info, version)
[08:25:51.345]                           }
[08:25:51.345]                           base::stop(msg)
[08:25:51.345]                         }
[08:25:51.345]                       })
[08:25:51.345]                     }
[08:25:51.345]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.345]                     base::options(mc.cores = 1L)
[08:25:51.345]                   }
[08:25:51.345]                   ...future.strategy.old <- future::plan("list")
[08:25:51.345]                   options(future.plan = NULL)
[08:25:51.345]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.345]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.345]                 }
[08:25:51.345]                 ...future.workdir <- getwd()
[08:25:51.345]             }
[08:25:51.345]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.345]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.345]         }
[08:25:51.345]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.345]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:51.345]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.345]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.345]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.345]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.345]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.345]             base::names(...future.oldOptions))
[08:25:51.345]     }
[08:25:51.345]     if (FALSE) {
[08:25:51.345]     }
[08:25:51.345]     else {
[08:25:51.345]         if (TRUE) {
[08:25:51.345]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.345]                 open = "w")
[08:25:51.345]         }
[08:25:51.345]         else {
[08:25:51.345]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.345]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.345]         }
[08:25:51.345]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.345]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.345]             base::sink(type = "output", split = FALSE)
[08:25:51.345]             base::close(...future.stdout)
[08:25:51.345]         }, add = TRUE)
[08:25:51.345]     }
[08:25:51.345]     ...future.frame <- base::sys.nframe()
[08:25:51.345]     ...future.conditions <- base::list()
[08:25:51.345]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.345]     if (FALSE) {
[08:25:51.345]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.345]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.345]     }
[08:25:51.345]     ...future.result <- base::tryCatch({
[08:25:51.345]         base::withCallingHandlers({
[08:25:51.345]             ...future.value <- base::withVisible(base::local({
[08:25:51.345]                 ...future.makeSendCondition <- base::local({
[08:25:51.345]                   sendCondition <- NULL
[08:25:51.345]                   function(frame = 1L) {
[08:25:51.345]                     if (is.function(sendCondition)) 
[08:25:51.345]                       return(sendCondition)
[08:25:51.345]                     ns <- getNamespace("parallel")
[08:25:51.345]                     if (exists("sendData", mode = "function", 
[08:25:51.345]                       envir = ns)) {
[08:25:51.345]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.345]                         envir = ns)
[08:25:51.345]                       envir <- sys.frame(frame)
[08:25:51.345]                       master <- NULL
[08:25:51.345]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.345]                         !identical(envir, emptyenv())) {
[08:25:51.345]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.345]                           inherits = FALSE)) {
[08:25:51.345]                           master <- get("master", mode = "list", 
[08:25:51.345]                             envir = envir, inherits = FALSE)
[08:25:51.345]                           if (inherits(master, c("SOCKnode", 
[08:25:51.345]                             "SOCK0node"))) {
[08:25:51.345]                             sendCondition <<- function(cond) {
[08:25:51.345]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.345]                                 success = TRUE)
[08:25:51.345]                               parallel_sendData(master, data)
[08:25:51.345]                             }
[08:25:51.345]                             return(sendCondition)
[08:25:51.345]                           }
[08:25:51.345]                         }
[08:25:51.345]                         frame <- frame + 1L
[08:25:51.345]                         envir <- sys.frame(frame)
[08:25:51.345]                       }
[08:25:51.345]                     }
[08:25:51.345]                     sendCondition <<- function(cond) NULL
[08:25:51.345]                   }
[08:25:51.345]                 })
[08:25:51.345]                 withCallingHandlers({
[08:25:51.345]                   {
[08:25:51.345]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.345]                     if (!identical(...future.globals.maxSize.org, 
[08:25:51.345]                       ...future.globals.maxSize)) {
[08:25:51.345]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.345]                       on.exit(options(oopts), add = TRUE)
[08:25:51.345]                     }
[08:25:51.345]                     {
[08:25:51.345]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.345]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:51.345]                         USE.NAMES = FALSE)
[08:25:51.345]                       do.call(mapply, args = args)
[08:25:51.345]                     }
[08:25:51.345]                   }
[08:25:51.345]                 }, immediateCondition = function(cond) {
[08:25:51.345]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.345]                   sendCondition(cond)
[08:25:51.345]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.345]                   {
[08:25:51.345]                     inherits <- base::inherits
[08:25:51.345]                     invokeRestart <- base::invokeRestart
[08:25:51.345]                     is.null <- base::is.null
[08:25:51.345]                     muffled <- FALSE
[08:25:51.345]                     if (inherits(cond, "message")) {
[08:25:51.345]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.345]                       if (muffled) 
[08:25:51.345]                         invokeRestart("muffleMessage")
[08:25:51.345]                     }
[08:25:51.345]                     else if (inherits(cond, "warning")) {
[08:25:51.345]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.345]                       if (muffled) 
[08:25:51.345]                         invokeRestart("muffleWarning")
[08:25:51.345]                     }
[08:25:51.345]                     else if (inherits(cond, "condition")) {
[08:25:51.345]                       if (!is.null(pattern)) {
[08:25:51.345]                         computeRestarts <- base::computeRestarts
[08:25:51.345]                         grepl <- base::grepl
[08:25:51.345]                         restarts <- computeRestarts(cond)
[08:25:51.345]                         for (restart in restarts) {
[08:25:51.345]                           name <- restart$name
[08:25:51.345]                           if (is.null(name)) 
[08:25:51.345]                             next
[08:25:51.345]                           if (!grepl(pattern, name)) 
[08:25:51.345]                             next
[08:25:51.345]                           invokeRestart(restart)
[08:25:51.345]                           muffled <- TRUE
[08:25:51.345]                           break
[08:25:51.345]                         }
[08:25:51.345]                       }
[08:25:51.345]                     }
[08:25:51.345]                     invisible(muffled)
[08:25:51.345]                   }
[08:25:51.345]                   muffleCondition(cond)
[08:25:51.345]                 })
[08:25:51.345]             }))
[08:25:51.345]             future::FutureResult(value = ...future.value$value, 
[08:25:51.345]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.345]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.345]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.345]                     ...future.globalenv.names))
[08:25:51.345]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.345]         }, condition = base::local({
[08:25:51.345]             c <- base::c
[08:25:51.345]             inherits <- base::inherits
[08:25:51.345]             invokeRestart <- base::invokeRestart
[08:25:51.345]             length <- base::length
[08:25:51.345]             list <- base::list
[08:25:51.345]             seq.int <- base::seq.int
[08:25:51.345]             signalCondition <- base::signalCondition
[08:25:51.345]             sys.calls <- base::sys.calls
[08:25:51.345]             `[[` <- base::`[[`
[08:25:51.345]             `+` <- base::`+`
[08:25:51.345]             `<<-` <- base::`<<-`
[08:25:51.345]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.345]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.345]                   3L)]
[08:25:51.345]             }
[08:25:51.345]             function(cond) {
[08:25:51.345]                 is_error <- inherits(cond, "error")
[08:25:51.345]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.345]                   NULL)
[08:25:51.345]                 if (is_error) {
[08:25:51.345]                   sessionInformation <- function() {
[08:25:51.345]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.345]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.345]                       search = base::search(), system = base::Sys.info())
[08:25:51.345]                   }
[08:25:51.345]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.345]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.345]                     cond$call), session = sessionInformation(), 
[08:25:51.345]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.345]                   signalCondition(cond)
[08:25:51.345]                 }
[08:25:51.345]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.345]                 "immediateCondition"))) {
[08:25:51.345]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.345]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.345]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.345]                   if (TRUE && !signal) {
[08:25:51.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.345]                     {
[08:25:51.345]                       inherits <- base::inherits
[08:25:51.345]                       invokeRestart <- base::invokeRestart
[08:25:51.345]                       is.null <- base::is.null
[08:25:51.345]                       muffled <- FALSE
[08:25:51.345]                       if (inherits(cond, "message")) {
[08:25:51.345]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.345]                         if (muffled) 
[08:25:51.345]                           invokeRestart("muffleMessage")
[08:25:51.345]                       }
[08:25:51.345]                       else if (inherits(cond, "warning")) {
[08:25:51.345]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.345]                         if (muffled) 
[08:25:51.345]                           invokeRestart("muffleWarning")
[08:25:51.345]                       }
[08:25:51.345]                       else if (inherits(cond, "condition")) {
[08:25:51.345]                         if (!is.null(pattern)) {
[08:25:51.345]                           computeRestarts <- base::computeRestarts
[08:25:51.345]                           grepl <- base::grepl
[08:25:51.345]                           restarts <- computeRestarts(cond)
[08:25:51.345]                           for (restart in restarts) {
[08:25:51.345]                             name <- restart$name
[08:25:51.345]                             if (is.null(name)) 
[08:25:51.345]                               next
[08:25:51.345]                             if (!grepl(pattern, name)) 
[08:25:51.345]                               next
[08:25:51.345]                             invokeRestart(restart)
[08:25:51.345]                             muffled <- TRUE
[08:25:51.345]                             break
[08:25:51.345]                           }
[08:25:51.345]                         }
[08:25:51.345]                       }
[08:25:51.345]                       invisible(muffled)
[08:25:51.345]                     }
[08:25:51.345]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.345]                   }
[08:25:51.345]                 }
[08:25:51.345]                 else {
[08:25:51.345]                   if (TRUE) {
[08:25:51.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.345]                     {
[08:25:51.345]                       inherits <- base::inherits
[08:25:51.345]                       invokeRestart <- base::invokeRestart
[08:25:51.345]                       is.null <- base::is.null
[08:25:51.345]                       muffled <- FALSE
[08:25:51.345]                       if (inherits(cond, "message")) {
[08:25:51.345]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.345]                         if (muffled) 
[08:25:51.345]                           invokeRestart("muffleMessage")
[08:25:51.345]                       }
[08:25:51.345]                       else if (inherits(cond, "warning")) {
[08:25:51.345]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.345]                         if (muffled) 
[08:25:51.345]                           invokeRestart("muffleWarning")
[08:25:51.345]                       }
[08:25:51.345]                       else if (inherits(cond, "condition")) {
[08:25:51.345]                         if (!is.null(pattern)) {
[08:25:51.345]                           computeRestarts <- base::computeRestarts
[08:25:51.345]                           grepl <- base::grepl
[08:25:51.345]                           restarts <- computeRestarts(cond)
[08:25:51.345]                           for (restart in restarts) {
[08:25:51.345]                             name <- restart$name
[08:25:51.345]                             if (is.null(name)) 
[08:25:51.345]                               next
[08:25:51.345]                             if (!grepl(pattern, name)) 
[08:25:51.345]                               next
[08:25:51.345]                             invokeRestart(restart)
[08:25:51.345]                             muffled <- TRUE
[08:25:51.345]                             break
[08:25:51.345]                           }
[08:25:51.345]                         }
[08:25:51.345]                       }
[08:25:51.345]                       invisible(muffled)
[08:25:51.345]                     }
[08:25:51.345]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.345]                   }
[08:25:51.345]                 }
[08:25:51.345]             }
[08:25:51.345]         }))
[08:25:51.345]     }, error = function(ex) {
[08:25:51.345]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.345]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.345]                 ...future.rng), started = ...future.startTime, 
[08:25:51.345]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.345]             version = "1.8"), class = "FutureResult")
[08:25:51.345]     }, finally = {
[08:25:51.345]         if (!identical(...future.workdir, getwd())) 
[08:25:51.345]             setwd(...future.workdir)
[08:25:51.345]         {
[08:25:51.345]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.345]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.345]             }
[08:25:51.345]             base::options(...future.oldOptions)
[08:25:51.345]             if (.Platform$OS.type == "windows") {
[08:25:51.345]                 old_names <- names(...future.oldEnvVars)
[08:25:51.345]                 envs <- base::Sys.getenv()
[08:25:51.345]                 names <- names(envs)
[08:25:51.345]                 common <- intersect(names, old_names)
[08:25:51.345]                 added <- setdiff(names, old_names)
[08:25:51.345]                 removed <- setdiff(old_names, names)
[08:25:51.345]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.345]                   envs[common]]
[08:25:51.345]                 NAMES <- toupper(changed)
[08:25:51.345]                 args <- list()
[08:25:51.345]                 for (kk in seq_along(NAMES)) {
[08:25:51.345]                   name <- changed[[kk]]
[08:25:51.345]                   NAME <- NAMES[[kk]]
[08:25:51.345]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.345]                     next
[08:25:51.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.345]                 }
[08:25:51.345]                 NAMES <- toupper(added)
[08:25:51.345]                 for (kk in seq_along(NAMES)) {
[08:25:51.345]                   name <- added[[kk]]
[08:25:51.345]                   NAME <- NAMES[[kk]]
[08:25:51.345]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.345]                     next
[08:25:51.345]                   args[[name]] <- ""
[08:25:51.345]                 }
[08:25:51.345]                 NAMES <- toupper(removed)
[08:25:51.345]                 for (kk in seq_along(NAMES)) {
[08:25:51.345]                   name <- removed[[kk]]
[08:25:51.345]                   NAME <- NAMES[[kk]]
[08:25:51.345]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.345]                     next
[08:25:51.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.345]                 }
[08:25:51.345]                 if (length(args) > 0) 
[08:25:51.345]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.345]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.345]             }
[08:25:51.345]             else {
[08:25:51.345]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.345]             }
[08:25:51.345]             {
[08:25:51.345]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.345]                   0L) {
[08:25:51.345]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.345]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.345]                   base::options(opts)
[08:25:51.345]                 }
[08:25:51.345]                 {
[08:25:51.345]                   {
[08:25:51.345]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.345]                     NULL
[08:25:51.345]                   }
[08:25:51.345]                   options(future.plan = NULL)
[08:25:51.345]                   if (is.na(NA_character_)) 
[08:25:51.345]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.345]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.345]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.345]                     .init = FALSE)
[08:25:51.345]                 }
[08:25:51.345]             }
[08:25:51.345]         }
[08:25:51.345]     })
[08:25:51.345]     if (TRUE) {
[08:25:51.345]         base::sink(type = "output", split = FALSE)
[08:25:51.345]         if (TRUE) {
[08:25:51.345]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.345]         }
[08:25:51.345]         else {
[08:25:51.345]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.345]         }
[08:25:51.345]         base::close(...future.stdout)
[08:25:51.345]         ...future.stdout <- NULL
[08:25:51.345]     }
[08:25:51.345]     ...future.result$conditions <- ...future.conditions
[08:25:51.345]     ...future.result$finished <- base::Sys.time()
[08:25:51.345]     ...future.result
[08:25:51.345] }
[08:25:51.348] Exporting 5 global objects (673 bytes) to cluster node #1 ...
[08:25:51.348] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[08:25:51.348] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[08:25:51.349] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:51.349] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.349] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ...
[08:25:51.349] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ... DONE
[08:25:51.349] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:51.350] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.350] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:51.350] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.350] Exporting 5 global objects (673 bytes) to cluster node #1 ... DONE
[08:25:51.351] MultisessionFuture started
[08:25:51.351] - Launch lazy future ... done
[08:25:51.351] run() for ‘MultisessionFuture’ ... done
[08:25:51.351] Created future:
[08:25:51.351] MultisessionFuture:
[08:25:51.351] Label: ‘future_mapply-1’
[08:25:51.351] Expression:
[08:25:51.351] {
[08:25:51.351]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.351]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:51.351]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.351]         on.exit(options(oopts), add = TRUE)
[08:25:51.351]     }
[08:25:51.351]     {
[08:25:51.351]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.351]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:51.351]         do.call(mapply, args = args)
[08:25:51.351]     }
[08:25:51.351] }
[08:25:51.351] Lazy evaluation: FALSE
[08:25:51.351] Asynchronous evaluation: TRUE
[08:25:51.351] Local evaluation: TRUE
[08:25:51.351] Environment: R_GlobalEnv
[08:25:51.351] Capture standard output: TRUE
[08:25:51.351] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:51.351] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:51.351] Packages: <none>
[08:25:51.351] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:51.351] Resolved: FALSE
[08:25:51.351] Value: <not collected>
[08:25:51.351] Conditions captured: <none>
[08:25:51.351] Early signaling: FALSE
[08:25:51.351] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:51.351] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.363] Chunk #1 of 2 ... DONE
[08:25:51.363] Chunk #2 of 2 ...
[08:25:51.363]  - Finding globals in '...' for chunk #2 ...
[08:25:51.363] getGlobalsAndPackages() ...
[08:25:51.363] Searching for globals...
[08:25:51.363] 
[08:25:51.364] Searching for globals ... DONE
[08:25:51.364] - globals: [0] <none>
[08:25:51.364] getGlobalsAndPackages() ... DONE
[08:25:51.364]    + additional globals found: [n=0] 
[08:25:51.364]    + additional namespaces needed: [n=0] 
[08:25:51.364]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:51.364]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:51.364]  - seeds: <none>
[08:25:51.364]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.364] getGlobalsAndPackages() ...
[08:25:51.364] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.365] Resolving globals: FALSE
[08:25:51.365] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:51.365] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:51.366] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.366] 
[08:25:51.366] getGlobalsAndPackages() ... DONE
[08:25:51.366] run() for ‘Future’ ...
[08:25:51.366] - state: ‘created’
[08:25:51.366] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:51.380] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:51.380]   - Field: ‘node’
[08:25:51.380]   - Field: ‘label’
[08:25:51.381]   - Field: ‘local’
[08:25:51.381]   - Field: ‘owner’
[08:25:51.381]   - Field: ‘envir’
[08:25:51.381]   - Field: ‘workers’
[08:25:51.381]   - Field: ‘packages’
[08:25:51.381]   - Field: ‘gc’
[08:25:51.381]   - Field: ‘conditions’
[08:25:51.381]   - Field: ‘persistent’
[08:25:51.381]   - Field: ‘expr’
[08:25:51.381]   - Field: ‘uuid’
[08:25:51.381]   - Field: ‘seed’
[08:25:51.381]   - Field: ‘version’
[08:25:51.382]   - Field: ‘result’
[08:25:51.382]   - Field: ‘asynchronous’
[08:25:51.382]   - Field: ‘calls’
[08:25:51.382]   - Field: ‘globals’
[08:25:51.382]   - Field: ‘stdout’
[08:25:51.382]   - Field: ‘earlySignal’
[08:25:51.382]   - Field: ‘lazy’
[08:25:51.382]   - Field: ‘state’
[08:25:51.382] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:51.382] - Launch lazy future ...
[08:25:51.383] Packages needed by the future expression (n = 0): <none>
[08:25:51.383] Packages needed by future strategies (n = 0): <none>
[08:25:51.383] {
[08:25:51.383]     {
[08:25:51.383]         {
[08:25:51.383]             ...future.startTime <- base::Sys.time()
[08:25:51.383]             {
[08:25:51.383]                 {
[08:25:51.383]                   {
[08:25:51.383]                     {
[08:25:51.383]                       base::local({
[08:25:51.383]                         has_future <- base::requireNamespace("future", 
[08:25:51.383]                           quietly = TRUE)
[08:25:51.383]                         if (has_future) {
[08:25:51.383]                           ns <- base::getNamespace("future")
[08:25:51.383]                           version <- ns[[".package"]][["version"]]
[08:25:51.383]                           if (is.null(version)) 
[08:25:51.383]                             version <- utils::packageVersion("future")
[08:25:51.383]                         }
[08:25:51.383]                         else {
[08:25:51.383]                           version <- NULL
[08:25:51.383]                         }
[08:25:51.383]                         if (!has_future || version < "1.8.0") {
[08:25:51.383]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.383]                             "", base::R.version$version.string), 
[08:25:51.383]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.383]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.383]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.383]                               "release", "version")], collapse = " "), 
[08:25:51.383]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.383]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.383]                             info)
[08:25:51.383]                           info <- base::paste(info, collapse = "; ")
[08:25:51.383]                           if (!has_future) {
[08:25:51.383]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.383]                               info)
[08:25:51.383]                           }
[08:25:51.383]                           else {
[08:25:51.383]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.383]                               info, version)
[08:25:51.383]                           }
[08:25:51.383]                           base::stop(msg)
[08:25:51.383]                         }
[08:25:51.383]                       })
[08:25:51.383]                     }
[08:25:51.383]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.383]                     base::options(mc.cores = 1L)
[08:25:51.383]                   }
[08:25:51.383]                   ...future.strategy.old <- future::plan("list")
[08:25:51.383]                   options(future.plan = NULL)
[08:25:51.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.383]                 }
[08:25:51.383]                 ...future.workdir <- getwd()
[08:25:51.383]             }
[08:25:51.383]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.383]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.383]         }
[08:25:51.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.383]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:51.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.383]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.383]             base::names(...future.oldOptions))
[08:25:51.383]     }
[08:25:51.383]     if (FALSE) {
[08:25:51.383]     }
[08:25:51.383]     else {
[08:25:51.383]         if (TRUE) {
[08:25:51.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.383]                 open = "w")
[08:25:51.383]         }
[08:25:51.383]         else {
[08:25:51.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.383]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.383]         }
[08:25:51.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.383]             base::sink(type = "output", split = FALSE)
[08:25:51.383]             base::close(...future.stdout)
[08:25:51.383]         }, add = TRUE)
[08:25:51.383]     }
[08:25:51.383]     ...future.frame <- base::sys.nframe()
[08:25:51.383]     ...future.conditions <- base::list()
[08:25:51.383]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.383]     if (FALSE) {
[08:25:51.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.383]     }
[08:25:51.383]     ...future.result <- base::tryCatch({
[08:25:51.383]         base::withCallingHandlers({
[08:25:51.383]             ...future.value <- base::withVisible(base::local({
[08:25:51.383]                 ...future.makeSendCondition <- base::local({
[08:25:51.383]                   sendCondition <- NULL
[08:25:51.383]                   function(frame = 1L) {
[08:25:51.383]                     if (is.function(sendCondition)) 
[08:25:51.383]                       return(sendCondition)
[08:25:51.383]                     ns <- getNamespace("parallel")
[08:25:51.383]                     if (exists("sendData", mode = "function", 
[08:25:51.383]                       envir = ns)) {
[08:25:51.383]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.383]                         envir = ns)
[08:25:51.383]                       envir <- sys.frame(frame)
[08:25:51.383]                       master <- NULL
[08:25:51.383]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.383]                         !identical(envir, emptyenv())) {
[08:25:51.383]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.383]                           inherits = FALSE)) {
[08:25:51.383]                           master <- get("master", mode = "list", 
[08:25:51.383]                             envir = envir, inherits = FALSE)
[08:25:51.383]                           if (inherits(master, c("SOCKnode", 
[08:25:51.383]                             "SOCK0node"))) {
[08:25:51.383]                             sendCondition <<- function(cond) {
[08:25:51.383]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.383]                                 success = TRUE)
[08:25:51.383]                               parallel_sendData(master, data)
[08:25:51.383]                             }
[08:25:51.383]                             return(sendCondition)
[08:25:51.383]                           }
[08:25:51.383]                         }
[08:25:51.383]                         frame <- frame + 1L
[08:25:51.383]                         envir <- sys.frame(frame)
[08:25:51.383]                       }
[08:25:51.383]                     }
[08:25:51.383]                     sendCondition <<- function(cond) NULL
[08:25:51.383]                   }
[08:25:51.383]                 })
[08:25:51.383]                 withCallingHandlers({
[08:25:51.383]                   {
[08:25:51.383]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.383]                     if (!identical(...future.globals.maxSize.org, 
[08:25:51.383]                       ...future.globals.maxSize)) {
[08:25:51.383]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.383]                       on.exit(options(oopts), add = TRUE)
[08:25:51.383]                     }
[08:25:51.383]                     {
[08:25:51.383]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.383]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:51.383]                         USE.NAMES = FALSE)
[08:25:51.383]                       do.call(mapply, args = args)
[08:25:51.383]                     }
[08:25:51.383]                   }
[08:25:51.383]                 }, immediateCondition = function(cond) {
[08:25:51.383]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.383]                   sendCondition(cond)
[08:25:51.383]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.383]                   {
[08:25:51.383]                     inherits <- base::inherits
[08:25:51.383]                     invokeRestart <- base::invokeRestart
[08:25:51.383]                     is.null <- base::is.null
[08:25:51.383]                     muffled <- FALSE
[08:25:51.383]                     if (inherits(cond, "message")) {
[08:25:51.383]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.383]                       if (muffled) 
[08:25:51.383]                         invokeRestart("muffleMessage")
[08:25:51.383]                     }
[08:25:51.383]                     else if (inherits(cond, "warning")) {
[08:25:51.383]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.383]                       if (muffled) 
[08:25:51.383]                         invokeRestart("muffleWarning")
[08:25:51.383]                     }
[08:25:51.383]                     else if (inherits(cond, "condition")) {
[08:25:51.383]                       if (!is.null(pattern)) {
[08:25:51.383]                         computeRestarts <- base::computeRestarts
[08:25:51.383]                         grepl <- base::grepl
[08:25:51.383]                         restarts <- computeRestarts(cond)
[08:25:51.383]                         for (restart in restarts) {
[08:25:51.383]                           name <- restart$name
[08:25:51.383]                           if (is.null(name)) 
[08:25:51.383]                             next
[08:25:51.383]                           if (!grepl(pattern, name)) 
[08:25:51.383]                             next
[08:25:51.383]                           invokeRestart(restart)
[08:25:51.383]                           muffled <- TRUE
[08:25:51.383]                           break
[08:25:51.383]                         }
[08:25:51.383]                       }
[08:25:51.383]                     }
[08:25:51.383]                     invisible(muffled)
[08:25:51.383]                   }
[08:25:51.383]                   muffleCondition(cond)
[08:25:51.383]                 })
[08:25:51.383]             }))
[08:25:51.383]             future::FutureResult(value = ...future.value$value, 
[08:25:51.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.383]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.383]                     ...future.globalenv.names))
[08:25:51.383]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.383]         }, condition = base::local({
[08:25:51.383]             c <- base::c
[08:25:51.383]             inherits <- base::inherits
[08:25:51.383]             invokeRestart <- base::invokeRestart
[08:25:51.383]             length <- base::length
[08:25:51.383]             list <- base::list
[08:25:51.383]             seq.int <- base::seq.int
[08:25:51.383]             signalCondition <- base::signalCondition
[08:25:51.383]             sys.calls <- base::sys.calls
[08:25:51.383]             `[[` <- base::`[[`
[08:25:51.383]             `+` <- base::`+`
[08:25:51.383]             `<<-` <- base::`<<-`
[08:25:51.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.383]                   3L)]
[08:25:51.383]             }
[08:25:51.383]             function(cond) {
[08:25:51.383]                 is_error <- inherits(cond, "error")
[08:25:51.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.383]                   NULL)
[08:25:51.383]                 if (is_error) {
[08:25:51.383]                   sessionInformation <- function() {
[08:25:51.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.383]                       search = base::search(), system = base::Sys.info())
[08:25:51.383]                   }
[08:25:51.383]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.383]                     cond$call), session = sessionInformation(), 
[08:25:51.383]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.383]                   signalCondition(cond)
[08:25:51.383]                 }
[08:25:51.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.383]                 "immediateCondition"))) {
[08:25:51.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.383]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.383]                   if (TRUE && !signal) {
[08:25:51.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.383]                     {
[08:25:51.383]                       inherits <- base::inherits
[08:25:51.383]                       invokeRestart <- base::invokeRestart
[08:25:51.383]                       is.null <- base::is.null
[08:25:51.383]                       muffled <- FALSE
[08:25:51.383]                       if (inherits(cond, "message")) {
[08:25:51.383]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.383]                         if (muffled) 
[08:25:51.383]                           invokeRestart("muffleMessage")
[08:25:51.383]                       }
[08:25:51.383]                       else if (inherits(cond, "warning")) {
[08:25:51.383]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.383]                         if (muffled) 
[08:25:51.383]                           invokeRestart("muffleWarning")
[08:25:51.383]                       }
[08:25:51.383]                       else if (inherits(cond, "condition")) {
[08:25:51.383]                         if (!is.null(pattern)) {
[08:25:51.383]                           computeRestarts <- base::computeRestarts
[08:25:51.383]                           grepl <- base::grepl
[08:25:51.383]                           restarts <- computeRestarts(cond)
[08:25:51.383]                           for (restart in restarts) {
[08:25:51.383]                             name <- restart$name
[08:25:51.383]                             if (is.null(name)) 
[08:25:51.383]                               next
[08:25:51.383]                             if (!grepl(pattern, name)) 
[08:25:51.383]                               next
[08:25:51.383]                             invokeRestart(restart)
[08:25:51.383]                             muffled <- TRUE
[08:25:51.383]                             break
[08:25:51.383]                           }
[08:25:51.383]                         }
[08:25:51.383]                       }
[08:25:51.383]                       invisible(muffled)
[08:25:51.383]                     }
[08:25:51.383]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.383]                   }
[08:25:51.383]                 }
[08:25:51.383]                 else {
[08:25:51.383]                   if (TRUE) {
[08:25:51.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.383]                     {
[08:25:51.383]                       inherits <- base::inherits
[08:25:51.383]                       invokeRestart <- base::invokeRestart
[08:25:51.383]                       is.null <- base::is.null
[08:25:51.383]                       muffled <- FALSE
[08:25:51.383]                       if (inherits(cond, "message")) {
[08:25:51.383]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.383]                         if (muffled) 
[08:25:51.383]                           invokeRestart("muffleMessage")
[08:25:51.383]                       }
[08:25:51.383]                       else if (inherits(cond, "warning")) {
[08:25:51.383]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.383]                         if (muffled) 
[08:25:51.383]                           invokeRestart("muffleWarning")
[08:25:51.383]                       }
[08:25:51.383]                       else if (inherits(cond, "condition")) {
[08:25:51.383]                         if (!is.null(pattern)) {
[08:25:51.383]                           computeRestarts <- base::computeRestarts
[08:25:51.383]                           grepl <- base::grepl
[08:25:51.383]                           restarts <- computeRestarts(cond)
[08:25:51.383]                           for (restart in restarts) {
[08:25:51.383]                             name <- restart$name
[08:25:51.383]                             if (is.null(name)) 
[08:25:51.383]                               next
[08:25:51.383]                             if (!grepl(pattern, name)) 
[08:25:51.383]                               next
[08:25:51.383]                             invokeRestart(restart)
[08:25:51.383]                             muffled <- TRUE
[08:25:51.383]                             break
[08:25:51.383]                           }
[08:25:51.383]                         }
[08:25:51.383]                       }
[08:25:51.383]                       invisible(muffled)
[08:25:51.383]                     }
[08:25:51.383]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.383]                   }
[08:25:51.383]                 }
[08:25:51.383]             }
[08:25:51.383]         }))
[08:25:51.383]     }, error = function(ex) {
[08:25:51.383]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.383]                 ...future.rng), started = ...future.startTime, 
[08:25:51.383]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.383]             version = "1.8"), class = "FutureResult")
[08:25:51.383]     }, finally = {
[08:25:51.383]         if (!identical(...future.workdir, getwd())) 
[08:25:51.383]             setwd(...future.workdir)
[08:25:51.383]         {
[08:25:51.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.383]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.383]             }
[08:25:51.383]             base::options(...future.oldOptions)
[08:25:51.383]             if (.Platform$OS.type == "windows") {
[08:25:51.383]                 old_names <- names(...future.oldEnvVars)
[08:25:51.383]                 envs <- base::Sys.getenv()
[08:25:51.383]                 names <- names(envs)
[08:25:51.383]                 common <- intersect(names, old_names)
[08:25:51.383]                 added <- setdiff(names, old_names)
[08:25:51.383]                 removed <- setdiff(old_names, names)
[08:25:51.383]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.383]                   envs[common]]
[08:25:51.383]                 NAMES <- toupper(changed)
[08:25:51.383]                 args <- list()
[08:25:51.383]                 for (kk in seq_along(NAMES)) {
[08:25:51.383]                   name <- changed[[kk]]
[08:25:51.383]                   NAME <- NAMES[[kk]]
[08:25:51.383]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.383]                     next
[08:25:51.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.383]                 }
[08:25:51.383]                 NAMES <- toupper(added)
[08:25:51.383]                 for (kk in seq_along(NAMES)) {
[08:25:51.383]                   name <- added[[kk]]
[08:25:51.383]                   NAME <- NAMES[[kk]]
[08:25:51.383]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.383]                     next
[08:25:51.383]                   args[[name]] <- ""
[08:25:51.383]                 }
[08:25:51.383]                 NAMES <- toupper(removed)
[08:25:51.383]                 for (kk in seq_along(NAMES)) {
[08:25:51.383]                   name <- removed[[kk]]
[08:25:51.383]                   NAME <- NAMES[[kk]]
[08:25:51.383]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.383]                     next
[08:25:51.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.383]                 }
[08:25:51.383]                 if (length(args) > 0) 
[08:25:51.383]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.383]             }
[08:25:51.383]             else {
[08:25:51.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.383]             }
[08:25:51.383]             {
[08:25:51.383]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.383]                   0L) {
[08:25:51.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.383]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.383]                   base::options(opts)
[08:25:51.383]                 }
[08:25:51.383]                 {
[08:25:51.383]                   {
[08:25:51.383]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.383]                     NULL
[08:25:51.383]                   }
[08:25:51.383]                   options(future.plan = NULL)
[08:25:51.383]                   if (is.na(NA_character_)) 
[08:25:51.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.383]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.383]                     .init = FALSE)
[08:25:51.383]                 }
[08:25:51.383]             }
[08:25:51.383]         }
[08:25:51.383]     })
[08:25:51.383]     if (TRUE) {
[08:25:51.383]         base::sink(type = "output", split = FALSE)
[08:25:51.383]         if (TRUE) {
[08:25:51.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.383]         }
[08:25:51.383]         else {
[08:25:51.383]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.383]         }
[08:25:51.383]         base::close(...future.stdout)
[08:25:51.383]         ...future.stdout <- NULL
[08:25:51.383]     }
[08:25:51.383]     ...future.result$conditions <- ...future.conditions
[08:25:51.383]     ...future.result$finished <- base::Sys.time()
[08:25:51.383]     ...future.result
[08:25:51.383] }
[08:25:51.437] Exporting 5 global objects (673 bytes) to cluster node #2 ...
[08:25:51.437] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[08:25:51.438] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[08:25:51.438] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:51.438] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.439] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ...
[08:25:51.439] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ... DONE
[08:25:51.439] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:51.440] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.440] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:51.440] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.440] Exporting 5 global objects (673 bytes) to cluster node #2 ... DONE
[08:25:51.441] MultisessionFuture started
[08:25:51.441] - Launch lazy future ... done
[08:25:51.441] run() for ‘MultisessionFuture’ ... done
[08:25:51.441] Created future:
[08:25:51.441] MultisessionFuture:
[08:25:51.441] Label: ‘future_mapply-2’
[08:25:51.441] Expression:
[08:25:51.441] {
[08:25:51.441]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.441]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:51.441]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.441]         on.exit(options(oopts), add = TRUE)
[08:25:51.441]     }
[08:25:51.441]     {
[08:25:51.441]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.441]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:51.441]         do.call(mapply, args = args)
[08:25:51.441]     }
[08:25:51.441] }
[08:25:51.441] Lazy evaluation: FALSE
[08:25:51.441] Asynchronous evaluation: TRUE
[08:25:51.441] Local evaluation: TRUE
[08:25:51.441] Environment: R_GlobalEnv
[08:25:51.441] Capture standard output: TRUE
[08:25:51.441] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:51.441] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:51.441] Packages: <none>
[08:25:51.441] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:51.441] Resolved: FALSE
[08:25:51.441] Value: <not collected>
[08:25:51.441] Conditions captured: <none>
[08:25:51.441] Early signaling: FALSE
[08:25:51.441] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:51.441] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.453] Chunk #2 of 2 ... DONE
[08:25:51.453] Launching 2 futures (chunks) ... DONE
[08:25:51.453] Resolving 2 futures (chunks) ...
[08:25:51.453] resolve() on list ...
[08:25:51.453]  recursive: 0
[08:25:51.453]  length: 2
[08:25:51.453] 
[08:25:51.454] receiveMessageFromWorker() for ClusterFuture ...
[08:25:51.454] - Validating connection of MultisessionFuture
[08:25:51.454] - received message: FutureResult
[08:25:51.454] - Received FutureResult
[08:25:51.454] - Erased future from FutureRegistry
[08:25:51.454] result() for ClusterFuture ...
[08:25:51.454] - result already collected: FutureResult
[08:25:51.455] result() for ClusterFuture ... done
[08:25:51.455] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:51.455] Future #1
[08:25:51.455] result() for ClusterFuture ...
[08:25:51.455] - result already collected: FutureResult
[08:25:51.455] result() for ClusterFuture ... done
[08:25:51.455] result() for ClusterFuture ...
[08:25:51.455] - result already collected: FutureResult
[08:25:51.455] result() for ClusterFuture ... done
[08:25:51.455] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:51.455] - nx: 2
[08:25:51.456] - relay: TRUE
[08:25:51.456] - stdout: TRUE
[08:25:51.456] - signal: TRUE
[08:25:51.456] - resignal: FALSE
[08:25:51.456] - force: TRUE
[08:25:51.456] - relayed: [n=2] FALSE, FALSE
[08:25:51.456] - queued futures: [n=2] FALSE, FALSE
[08:25:51.456]  - until=1
[08:25:51.456]  - relaying element #1
[08:25:51.456] result() for ClusterFuture ...
[08:25:51.456] - result already collected: FutureResult
[08:25:51.456] result() for ClusterFuture ... done
[08:25:51.456] result() for ClusterFuture ...
[08:25:51.457] - result already collected: FutureResult
[08:25:51.457] result() for ClusterFuture ... done
[08:25:51.457] result() for ClusterFuture ...
[08:25:51.457] - result already collected: FutureResult
[08:25:51.457] result() for ClusterFuture ... done
[08:25:51.457] result() for ClusterFuture ...
[08:25:51.457] - result already collected: FutureResult
[08:25:51.457] result() for ClusterFuture ... done
[08:25:51.457] - relayed: [n=2] TRUE, FALSE
[08:25:51.457] - queued futures: [n=2] TRUE, FALSE
[08:25:51.457] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:51.458]  length: 1 (resolved future 1)
[08:25:51.521] receiveMessageFromWorker() for ClusterFuture ...
[08:25:51.521] - Validating connection of MultisessionFuture
[08:25:51.521] - received message: FutureResult
[08:25:51.521] - Received FutureResult
[08:25:51.521] - Erased future from FutureRegistry
[08:25:51.521] result() for ClusterFuture ...
[08:25:51.521] - result already collected: FutureResult
[08:25:51.521] result() for ClusterFuture ... done
[08:25:51.522] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:51.522] Future #2
[08:25:51.522] result() for ClusterFuture ...
[08:25:51.522] - result already collected: FutureResult
[08:25:51.522] result() for ClusterFuture ... done
[08:25:51.522] result() for ClusterFuture ...
[08:25:51.522] - result already collected: FutureResult
[08:25:51.522] result() for ClusterFuture ... done
[08:25:51.522] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:51.522] - nx: 2
[08:25:51.522] - relay: TRUE
[08:25:51.522] - stdout: TRUE
[08:25:51.523] - signal: TRUE
[08:25:51.523] - resignal: FALSE
[08:25:51.523] - force: TRUE
[08:25:51.523] - relayed: [n=2] TRUE, FALSE
[08:25:51.523] - queued futures: [n=2] TRUE, FALSE
[08:25:51.523]  - until=2
[08:25:51.523]  - relaying element #2
[08:25:51.523] result() for ClusterFuture ...
[08:25:51.523] - result already collected: FutureResult
[08:25:51.523] result() for ClusterFuture ... done
[08:25:51.523] result() for ClusterFuture ...
[08:25:51.523] - result already collected: FutureResult
[08:25:51.524] result() for ClusterFuture ... done
[08:25:51.524] result() for ClusterFuture ...
[08:25:51.524] - result already collected: FutureResult
[08:25:51.524] result() for ClusterFuture ... done
[08:25:51.524] result() for ClusterFuture ...
[08:25:51.524] - result already collected: FutureResult
[08:25:51.524] result() for ClusterFuture ... done
[08:25:51.524] - relayed: [n=2] TRUE, TRUE
[08:25:51.524] - queued futures: [n=2] TRUE, TRUE
[08:25:51.524] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:51.524]  length: 0 (resolved future 2)
[08:25:51.525] Relaying remaining futures
[08:25:51.525] signalConditionsASAP(NULL, pos=0) ...
[08:25:51.525] - nx: 2
[08:25:51.525] - relay: TRUE
[08:25:51.525] - stdout: TRUE
[08:25:51.525] - signal: TRUE
[08:25:51.525] - resignal: FALSE
[08:25:51.525] - force: TRUE
[08:25:51.525] - relayed: [n=2] TRUE, TRUE
[08:25:51.525] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:51.525] - relayed: [n=2] TRUE, TRUE
[08:25:51.525] - queued futures: [n=2] TRUE, TRUE
[08:25:51.526] signalConditionsASAP(NULL, pos=0) ... done
[08:25:51.526] resolve() on list ... DONE
[08:25:51.526] result() for ClusterFuture ...
[08:25:51.526] - result already collected: FutureResult
[08:25:51.526] result() for ClusterFuture ... done
[08:25:51.526] result() for ClusterFuture ...
[08:25:51.526] - result already collected: FutureResult
[08:25:51.526] result() for ClusterFuture ... done
[08:25:51.526] result() for ClusterFuture ...
[08:25:51.526] - result already collected: FutureResult
[08:25:51.526] result() for ClusterFuture ... done
[08:25:51.526] result() for ClusterFuture ...
[08:25:51.527] - result already collected: FutureResult
[08:25:51.527] result() for ClusterFuture ... done
[08:25:51.527]  - Number of value chunks collected: 2
[08:25:51.527] Resolving 2 futures (chunks) ... DONE
[08:25:51.527] Reducing values from 2 chunks ...
[08:25:51.527]  - Number of values collected after concatenation: 4
[08:25:51.527]  - Number of values expected: 4
[08:25:51.527] Reducing values from 2 chunks ... DONE
[08:25:51.527] future_mapply() ... DONE
[08:25:51.527] future_mapply() ...
[08:25:51.529] Number of chunks: 2
[08:25:51.529] getGlobalsAndPackagesXApply() ...
[08:25:51.529]  - future.globals: TRUE
[08:25:51.529] getGlobalsAndPackages() ...
[08:25:51.530] Searching for globals...
[08:25:51.530] - globals found: [1] ‘FUN’
[08:25:51.530] Searching for globals ... DONE
[08:25:51.530] Resolving globals: FALSE
[08:25:51.531] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:51.531] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:51.531] - globals: [1] ‘FUN’
[08:25:51.531] 
[08:25:51.531] getGlobalsAndPackages() ... DONE
[08:25:51.531]  - globals found/used: [n=1] ‘FUN’
[08:25:51.532]  - needed namespaces: [n=0] 
[08:25:51.532] Finding globals ... DONE
[08:25:51.532] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:51.532] List of 2
[08:25:51.532]  $ ...future.FUN:function (x, ...)  
[08:25:51.532]  $ MoreArgs     : NULL
[08:25:51.532]  - attr(*, "where")=List of 2
[08:25:51.532]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:51.532]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:51.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:51.532]  - attr(*, "resolved")= logi FALSE
[08:25:51.532]  - attr(*, "total_size")= num NA
[08:25:51.534] Packages to be attached in all futures: [n=0] 
[08:25:51.534] getGlobalsAndPackagesXApply() ... DONE
[08:25:51.535] Number of futures (= number of chunks): 2
[08:25:51.535] Launching 2 futures (chunks) ...
[08:25:51.535] Chunk #1 of 2 ...
[08:25:51.535]  - Finding globals in '...' for chunk #1 ...
[08:25:51.535] getGlobalsAndPackages() ...
[08:25:51.535] Searching for globals...
[08:25:51.535] 
[08:25:51.536] Searching for globals ... DONE
[08:25:51.536] - globals: [0] <none>
[08:25:51.536] getGlobalsAndPackages() ... DONE
[08:25:51.536]    + additional globals found: [n=0] 
[08:25:51.536]    + additional namespaces needed: [n=0] 
[08:25:51.536]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:51.536]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:51.536]  - seeds: <none>
[08:25:51.536]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.536] getGlobalsAndPackages() ...
[08:25:51.536] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.537] Resolving globals: FALSE
[08:25:51.537] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:51.537] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:51.538] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.538] 
[08:25:51.538] getGlobalsAndPackages() ... DONE
[08:25:51.538] run() for ‘Future’ ...
[08:25:51.538] - state: ‘created’
[08:25:51.538] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:51.553] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:51.553]   - Field: ‘node’
[08:25:51.553]   - Field: ‘label’
[08:25:51.553]   - Field: ‘local’
[08:25:51.553]   - Field: ‘owner’
[08:25:51.554]   - Field: ‘envir’
[08:25:51.554]   - Field: ‘workers’
[08:25:51.554]   - Field: ‘packages’
[08:25:51.554]   - Field: ‘gc’
[08:25:51.554]   - Field: ‘conditions’
[08:25:51.554]   - Field: ‘persistent’
[08:25:51.554]   - Field: ‘expr’
[08:25:51.554]   - Field: ‘uuid’
[08:25:51.554]   - Field: ‘seed’
[08:25:51.554]   - Field: ‘version’
[08:25:51.554]   - Field: ‘result’
[08:25:51.555]   - Field: ‘asynchronous’
[08:25:51.555]   - Field: ‘calls’
[08:25:51.555]   - Field: ‘globals’
[08:25:51.555]   - Field: ‘stdout’
[08:25:51.555]   - Field: ‘earlySignal’
[08:25:51.555]   - Field: ‘lazy’
[08:25:51.555]   - Field: ‘state’
[08:25:51.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:51.555] - Launch lazy future ...
[08:25:51.556] Packages needed by the future expression (n = 0): <none>
[08:25:51.556] Packages needed by future strategies (n = 0): <none>
[08:25:51.558] {
[08:25:51.558]     {
[08:25:51.558]         {
[08:25:51.558]             ...future.startTime <- base::Sys.time()
[08:25:51.558]             {
[08:25:51.558]                 {
[08:25:51.558]                   {
[08:25:51.558]                     {
[08:25:51.558]                       base::local({
[08:25:51.558]                         has_future <- base::requireNamespace("future", 
[08:25:51.558]                           quietly = TRUE)
[08:25:51.558]                         if (has_future) {
[08:25:51.558]                           ns <- base::getNamespace("future")
[08:25:51.558]                           version <- ns[[".package"]][["version"]]
[08:25:51.558]                           if (is.null(version)) 
[08:25:51.558]                             version <- utils::packageVersion("future")
[08:25:51.558]                         }
[08:25:51.558]                         else {
[08:25:51.558]                           version <- NULL
[08:25:51.558]                         }
[08:25:51.558]                         if (!has_future || version < "1.8.0") {
[08:25:51.558]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.558]                             "", base::R.version$version.string), 
[08:25:51.558]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.558]                               "release", "version")], collapse = " "), 
[08:25:51.558]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.558]                             info)
[08:25:51.558]                           info <- base::paste(info, collapse = "; ")
[08:25:51.558]                           if (!has_future) {
[08:25:51.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.558]                               info)
[08:25:51.558]                           }
[08:25:51.558]                           else {
[08:25:51.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.558]                               info, version)
[08:25:51.558]                           }
[08:25:51.558]                           base::stop(msg)
[08:25:51.558]                         }
[08:25:51.558]                       })
[08:25:51.558]                     }
[08:25:51.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.558]                     base::options(mc.cores = 1L)
[08:25:51.558]                   }
[08:25:51.558]                   ...future.strategy.old <- future::plan("list")
[08:25:51.558]                   options(future.plan = NULL)
[08:25:51.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.558]                 }
[08:25:51.558]                 ...future.workdir <- getwd()
[08:25:51.558]             }
[08:25:51.558]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.558]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.558]         }
[08:25:51.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:51.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.558]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.558]             base::names(...future.oldOptions))
[08:25:51.558]     }
[08:25:51.558]     if (FALSE) {
[08:25:51.558]     }
[08:25:51.558]     else {
[08:25:51.558]         if (TRUE) {
[08:25:51.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.558]                 open = "w")
[08:25:51.558]         }
[08:25:51.558]         else {
[08:25:51.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.558]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.558]         }
[08:25:51.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.558]             base::sink(type = "output", split = FALSE)
[08:25:51.558]             base::close(...future.stdout)
[08:25:51.558]         }, add = TRUE)
[08:25:51.558]     }
[08:25:51.558]     ...future.frame <- base::sys.nframe()
[08:25:51.558]     ...future.conditions <- base::list()
[08:25:51.558]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.558]     if (FALSE) {
[08:25:51.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.558]     }
[08:25:51.558]     ...future.result <- base::tryCatch({
[08:25:51.558]         base::withCallingHandlers({
[08:25:51.558]             ...future.value <- base::withVisible(base::local({
[08:25:51.558]                 ...future.makeSendCondition <- base::local({
[08:25:51.558]                   sendCondition <- NULL
[08:25:51.558]                   function(frame = 1L) {
[08:25:51.558]                     if (is.function(sendCondition)) 
[08:25:51.558]                       return(sendCondition)
[08:25:51.558]                     ns <- getNamespace("parallel")
[08:25:51.558]                     if (exists("sendData", mode = "function", 
[08:25:51.558]                       envir = ns)) {
[08:25:51.558]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.558]                         envir = ns)
[08:25:51.558]                       envir <- sys.frame(frame)
[08:25:51.558]                       master <- NULL
[08:25:51.558]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.558]                         !identical(envir, emptyenv())) {
[08:25:51.558]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.558]                           inherits = FALSE)) {
[08:25:51.558]                           master <- get("master", mode = "list", 
[08:25:51.558]                             envir = envir, inherits = FALSE)
[08:25:51.558]                           if (inherits(master, c("SOCKnode", 
[08:25:51.558]                             "SOCK0node"))) {
[08:25:51.558]                             sendCondition <<- function(cond) {
[08:25:51.558]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.558]                                 success = TRUE)
[08:25:51.558]                               parallel_sendData(master, data)
[08:25:51.558]                             }
[08:25:51.558]                             return(sendCondition)
[08:25:51.558]                           }
[08:25:51.558]                         }
[08:25:51.558]                         frame <- frame + 1L
[08:25:51.558]                         envir <- sys.frame(frame)
[08:25:51.558]                       }
[08:25:51.558]                     }
[08:25:51.558]                     sendCondition <<- function(cond) NULL
[08:25:51.558]                   }
[08:25:51.558]                 })
[08:25:51.558]                 withCallingHandlers({
[08:25:51.558]                   {
[08:25:51.558]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.558]                     if (!identical(...future.globals.maxSize.org, 
[08:25:51.558]                       ...future.globals.maxSize)) {
[08:25:51.558]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.558]                       on.exit(options(oopts), add = TRUE)
[08:25:51.558]                     }
[08:25:51.558]                     {
[08:25:51.558]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.558]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:51.558]                         USE.NAMES = FALSE)
[08:25:51.558]                       do.call(mapply, args = args)
[08:25:51.558]                     }
[08:25:51.558]                   }
[08:25:51.558]                 }, immediateCondition = function(cond) {
[08:25:51.558]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.558]                   sendCondition(cond)
[08:25:51.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.558]                   {
[08:25:51.558]                     inherits <- base::inherits
[08:25:51.558]                     invokeRestart <- base::invokeRestart
[08:25:51.558]                     is.null <- base::is.null
[08:25:51.558]                     muffled <- FALSE
[08:25:51.558]                     if (inherits(cond, "message")) {
[08:25:51.558]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.558]                       if (muffled) 
[08:25:51.558]                         invokeRestart("muffleMessage")
[08:25:51.558]                     }
[08:25:51.558]                     else if (inherits(cond, "warning")) {
[08:25:51.558]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.558]                       if (muffled) 
[08:25:51.558]                         invokeRestart("muffleWarning")
[08:25:51.558]                     }
[08:25:51.558]                     else if (inherits(cond, "condition")) {
[08:25:51.558]                       if (!is.null(pattern)) {
[08:25:51.558]                         computeRestarts <- base::computeRestarts
[08:25:51.558]                         grepl <- base::grepl
[08:25:51.558]                         restarts <- computeRestarts(cond)
[08:25:51.558]                         for (restart in restarts) {
[08:25:51.558]                           name <- restart$name
[08:25:51.558]                           if (is.null(name)) 
[08:25:51.558]                             next
[08:25:51.558]                           if (!grepl(pattern, name)) 
[08:25:51.558]                             next
[08:25:51.558]                           invokeRestart(restart)
[08:25:51.558]                           muffled <- TRUE
[08:25:51.558]                           break
[08:25:51.558]                         }
[08:25:51.558]                       }
[08:25:51.558]                     }
[08:25:51.558]                     invisible(muffled)
[08:25:51.558]                   }
[08:25:51.558]                   muffleCondition(cond)
[08:25:51.558]                 })
[08:25:51.558]             }))
[08:25:51.558]             future::FutureResult(value = ...future.value$value, 
[08:25:51.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.558]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.558]                     ...future.globalenv.names))
[08:25:51.558]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.558]         }, condition = base::local({
[08:25:51.558]             c <- base::c
[08:25:51.558]             inherits <- base::inherits
[08:25:51.558]             invokeRestart <- base::invokeRestart
[08:25:51.558]             length <- base::length
[08:25:51.558]             list <- base::list
[08:25:51.558]             seq.int <- base::seq.int
[08:25:51.558]             signalCondition <- base::signalCondition
[08:25:51.558]             sys.calls <- base::sys.calls
[08:25:51.558]             `[[` <- base::`[[`
[08:25:51.558]             `+` <- base::`+`
[08:25:51.558]             `<<-` <- base::`<<-`
[08:25:51.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.558]                   3L)]
[08:25:51.558]             }
[08:25:51.558]             function(cond) {
[08:25:51.558]                 is_error <- inherits(cond, "error")
[08:25:51.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.558]                   NULL)
[08:25:51.558]                 if (is_error) {
[08:25:51.558]                   sessionInformation <- function() {
[08:25:51.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.558]                       search = base::search(), system = base::Sys.info())
[08:25:51.558]                   }
[08:25:51.558]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.558]                     cond$call), session = sessionInformation(), 
[08:25:51.558]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.558]                   signalCondition(cond)
[08:25:51.558]                 }
[08:25:51.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.558]                 "immediateCondition"))) {
[08:25:51.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.558]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.558]                   if (TRUE && !signal) {
[08:25:51.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.558]                     {
[08:25:51.558]                       inherits <- base::inherits
[08:25:51.558]                       invokeRestart <- base::invokeRestart
[08:25:51.558]                       is.null <- base::is.null
[08:25:51.558]                       muffled <- FALSE
[08:25:51.558]                       if (inherits(cond, "message")) {
[08:25:51.558]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.558]                         if (muffled) 
[08:25:51.558]                           invokeRestart("muffleMessage")
[08:25:51.558]                       }
[08:25:51.558]                       else if (inherits(cond, "warning")) {
[08:25:51.558]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.558]                         if (muffled) 
[08:25:51.558]                           invokeRestart("muffleWarning")
[08:25:51.558]                       }
[08:25:51.558]                       else if (inherits(cond, "condition")) {
[08:25:51.558]                         if (!is.null(pattern)) {
[08:25:51.558]                           computeRestarts <- base::computeRestarts
[08:25:51.558]                           grepl <- base::grepl
[08:25:51.558]                           restarts <- computeRestarts(cond)
[08:25:51.558]                           for (restart in restarts) {
[08:25:51.558]                             name <- restart$name
[08:25:51.558]                             if (is.null(name)) 
[08:25:51.558]                               next
[08:25:51.558]                             if (!grepl(pattern, name)) 
[08:25:51.558]                               next
[08:25:51.558]                             invokeRestart(restart)
[08:25:51.558]                             muffled <- TRUE
[08:25:51.558]                             break
[08:25:51.558]                           }
[08:25:51.558]                         }
[08:25:51.558]                       }
[08:25:51.558]                       invisible(muffled)
[08:25:51.558]                     }
[08:25:51.558]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.558]                   }
[08:25:51.558]                 }
[08:25:51.558]                 else {
[08:25:51.558]                   if (TRUE) {
[08:25:51.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.558]                     {
[08:25:51.558]                       inherits <- base::inherits
[08:25:51.558]                       invokeRestart <- base::invokeRestart
[08:25:51.558]                       is.null <- base::is.null
[08:25:51.558]                       muffled <- FALSE
[08:25:51.558]                       if (inherits(cond, "message")) {
[08:25:51.558]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.558]                         if (muffled) 
[08:25:51.558]                           invokeRestart("muffleMessage")
[08:25:51.558]                       }
[08:25:51.558]                       else if (inherits(cond, "warning")) {
[08:25:51.558]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.558]                         if (muffled) 
[08:25:51.558]                           invokeRestart("muffleWarning")
[08:25:51.558]                       }
[08:25:51.558]                       else if (inherits(cond, "condition")) {
[08:25:51.558]                         if (!is.null(pattern)) {
[08:25:51.558]                           computeRestarts <- base::computeRestarts
[08:25:51.558]                           grepl <- base::grepl
[08:25:51.558]                           restarts <- computeRestarts(cond)
[08:25:51.558]                           for (restart in restarts) {
[08:25:51.558]                             name <- restart$name
[08:25:51.558]                             if (is.null(name)) 
[08:25:51.558]                               next
[08:25:51.558]                             if (!grepl(pattern, name)) 
[08:25:51.558]                               next
[08:25:51.558]                             invokeRestart(restart)
[08:25:51.558]                             muffled <- TRUE
[08:25:51.558]                             break
[08:25:51.558]                           }
[08:25:51.558]                         }
[08:25:51.558]                       }
[08:25:51.558]                       invisible(muffled)
[08:25:51.558]                     }
[08:25:51.558]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.558]                   }
[08:25:51.558]                 }
[08:25:51.558]             }
[08:25:51.558]         }))
[08:25:51.558]     }, error = function(ex) {
[08:25:51.558]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.558]                 ...future.rng), started = ...future.startTime, 
[08:25:51.558]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.558]             version = "1.8"), class = "FutureResult")
[08:25:51.558]     }, finally = {
[08:25:51.558]         if (!identical(...future.workdir, getwd())) 
[08:25:51.558]             setwd(...future.workdir)
[08:25:51.558]         {
[08:25:51.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.558]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.558]             }
[08:25:51.558]             base::options(...future.oldOptions)
[08:25:51.558]             if (.Platform$OS.type == "windows") {
[08:25:51.558]                 old_names <- names(...future.oldEnvVars)
[08:25:51.558]                 envs <- base::Sys.getenv()
[08:25:51.558]                 names <- names(envs)
[08:25:51.558]                 common <- intersect(names, old_names)
[08:25:51.558]                 added <- setdiff(names, old_names)
[08:25:51.558]                 removed <- setdiff(old_names, names)
[08:25:51.558]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.558]                   envs[common]]
[08:25:51.558]                 NAMES <- toupper(changed)
[08:25:51.558]                 args <- list()
[08:25:51.558]                 for (kk in seq_along(NAMES)) {
[08:25:51.558]                   name <- changed[[kk]]
[08:25:51.558]                   NAME <- NAMES[[kk]]
[08:25:51.558]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.558]                     next
[08:25:51.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.558]                 }
[08:25:51.558]                 NAMES <- toupper(added)
[08:25:51.558]                 for (kk in seq_along(NAMES)) {
[08:25:51.558]                   name <- added[[kk]]
[08:25:51.558]                   NAME <- NAMES[[kk]]
[08:25:51.558]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.558]                     next
[08:25:51.558]                   args[[name]] <- ""
[08:25:51.558]                 }
[08:25:51.558]                 NAMES <- toupper(removed)
[08:25:51.558]                 for (kk in seq_along(NAMES)) {
[08:25:51.558]                   name <- removed[[kk]]
[08:25:51.558]                   NAME <- NAMES[[kk]]
[08:25:51.558]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.558]                     next
[08:25:51.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.558]                 }
[08:25:51.558]                 if (length(args) > 0) 
[08:25:51.558]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.558]             }
[08:25:51.558]             else {
[08:25:51.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.558]             }
[08:25:51.558]             {
[08:25:51.558]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.558]                   0L) {
[08:25:51.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.558]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.558]                   base::options(opts)
[08:25:51.558]                 }
[08:25:51.558]                 {
[08:25:51.558]                   {
[08:25:51.558]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.558]                     NULL
[08:25:51.558]                   }
[08:25:51.558]                   options(future.plan = NULL)
[08:25:51.558]                   if (is.na(NA_character_)) 
[08:25:51.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.558]                     .init = FALSE)
[08:25:51.558]                 }
[08:25:51.558]             }
[08:25:51.558]         }
[08:25:51.558]     })
[08:25:51.558]     if (TRUE) {
[08:25:51.558]         base::sink(type = "output", split = FALSE)
[08:25:51.558]         if (TRUE) {
[08:25:51.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.558]         }
[08:25:51.558]         else {
[08:25:51.558]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.558]         }
[08:25:51.558]         base::close(...future.stdout)
[08:25:51.558]         ...future.stdout <- NULL
[08:25:51.558]     }
[08:25:51.558]     ...future.result$conditions <- ...future.conditions
[08:25:51.558]     ...future.result$finished <- base::Sys.time()
[08:25:51.558]     ...future.result
[08:25:51.558] }
[08:25:51.561] Exporting 5 global objects (673 bytes) to cluster node #1 ...
[08:25:51.561] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[08:25:51.562] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[08:25:51.562] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:51.562] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.562] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ...
[08:25:51.563] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ... DONE
[08:25:51.563] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:51.563] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.563] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:51.564] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.564] Exporting 5 global objects (673 bytes) to cluster node #1 ... DONE
[08:25:51.564] MultisessionFuture started
[08:25:51.564] - Launch lazy future ... done
[08:25:51.564] run() for ‘MultisessionFuture’ ... done
[08:25:51.564] Created future:
[08:25:51.564] MultisessionFuture:
[08:25:51.564] Label: ‘future_mapply-1’
[08:25:51.564] Expression:
[08:25:51.564] {
[08:25:51.564]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.564]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:51.564]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.564]         on.exit(options(oopts), add = TRUE)
[08:25:51.564]     }
[08:25:51.564]     {
[08:25:51.564]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.564]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:51.564]         do.call(mapply, args = args)
[08:25:51.564]     }
[08:25:51.564] }
[08:25:51.564] Lazy evaluation: FALSE
[08:25:51.564] Asynchronous evaluation: TRUE
[08:25:51.564] Local evaluation: TRUE
[08:25:51.564] Environment: R_GlobalEnv
[08:25:51.564] Capture standard output: TRUE
[08:25:51.564] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:51.564] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:51.564] Packages: <none>
[08:25:51.564] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:51.564] Resolved: FALSE
[08:25:51.564] Value: <not collected>
[08:25:51.564] Conditions captured: <none>
[08:25:51.564] Early signaling: FALSE
[08:25:51.564] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:51.564] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.576] Chunk #1 of 2 ... DONE
[08:25:51.576] Chunk #2 of 2 ...
[08:25:51.576]  - Finding globals in '...' for chunk #2 ...
[08:25:51.576] getGlobalsAndPackages() ...
[08:25:51.576] Searching for globals...
[08:25:51.577] 
[08:25:51.577] Searching for globals ... DONE
[08:25:51.577] - globals: [0] <none>
[08:25:51.577] getGlobalsAndPackages() ... DONE
[08:25:51.577]    + additional globals found: [n=0] 
[08:25:51.577]    + additional namespaces needed: [n=0] 
[08:25:51.577]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:51.577]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:51.577]  - seeds: <none>
[08:25:51.577]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.578] getGlobalsAndPackages() ...
[08:25:51.578] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.578] Resolving globals: FALSE
[08:25:51.578] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:51.579] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:51.579] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.579] 
[08:25:51.579] getGlobalsAndPackages() ... DONE
[08:25:51.579] run() for ‘Future’ ...
[08:25:51.579] - state: ‘created’
[08:25:51.579] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:51.593] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:51.593]   - Field: ‘node’
[08:25:51.593]   - Field: ‘label’
[08:25:51.593]   - Field: ‘local’
[08:25:51.593]   - Field: ‘owner’
[08:25:51.594]   - Field: ‘envir’
[08:25:51.594]   - Field: ‘workers’
[08:25:51.594]   - Field: ‘packages’
[08:25:51.594]   - Field: ‘gc’
[08:25:51.594]   - Field: ‘conditions’
[08:25:51.594]   - Field: ‘persistent’
[08:25:51.594]   - Field: ‘expr’
[08:25:51.594]   - Field: ‘uuid’
[08:25:51.594]   - Field: ‘seed’
[08:25:51.594]   - Field: ‘version’
[08:25:51.594]   - Field: ‘result’
[08:25:51.595]   - Field: ‘asynchronous’
[08:25:51.595]   - Field: ‘calls’
[08:25:51.595]   - Field: ‘globals’
[08:25:51.595]   - Field: ‘stdout’
[08:25:51.595]   - Field: ‘earlySignal’
[08:25:51.595]   - Field: ‘lazy’
[08:25:51.595]   - Field: ‘state’
[08:25:51.595] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:51.595] - Launch lazy future ...
[08:25:51.595] Packages needed by the future expression (n = 0): <none>
[08:25:51.596] Packages needed by future strategies (n = 0): <none>
[08:25:51.596] {
[08:25:51.596]     {
[08:25:51.596]         {
[08:25:51.596]             ...future.startTime <- base::Sys.time()
[08:25:51.596]             {
[08:25:51.596]                 {
[08:25:51.596]                   {
[08:25:51.596]                     {
[08:25:51.596]                       base::local({
[08:25:51.596]                         has_future <- base::requireNamespace("future", 
[08:25:51.596]                           quietly = TRUE)
[08:25:51.596]                         if (has_future) {
[08:25:51.596]                           ns <- base::getNamespace("future")
[08:25:51.596]                           version <- ns[[".package"]][["version"]]
[08:25:51.596]                           if (is.null(version)) 
[08:25:51.596]                             version <- utils::packageVersion("future")
[08:25:51.596]                         }
[08:25:51.596]                         else {
[08:25:51.596]                           version <- NULL
[08:25:51.596]                         }
[08:25:51.596]                         if (!has_future || version < "1.8.0") {
[08:25:51.596]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.596]                             "", base::R.version$version.string), 
[08:25:51.596]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.596]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.596]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.596]                               "release", "version")], collapse = " "), 
[08:25:51.596]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.596]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.596]                             info)
[08:25:51.596]                           info <- base::paste(info, collapse = "; ")
[08:25:51.596]                           if (!has_future) {
[08:25:51.596]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.596]                               info)
[08:25:51.596]                           }
[08:25:51.596]                           else {
[08:25:51.596]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.596]                               info, version)
[08:25:51.596]                           }
[08:25:51.596]                           base::stop(msg)
[08:25:51.596]                         }
[08:25:51.596]                       })
[08:25:51.596]                     }
[08:25:51.596]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.596]                     base::options(mc.cores = 1L)
[08:25:51.596]                   }
[08:25:51.596]                   ...future.strategy.old <- future::plan("list")
[08:25:51.596]                   options(future.plan = NULL)
[08:25:51.596]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.596]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.596]                 }
[08:25:51.596]                 ...future.workdir <- getwd()
[08:25:51.596]             }
[08:25:51.596]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.596]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.596]         }
[08:25:51.596]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.596]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:51.596]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.596]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.596]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.596]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.596]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.596]             base::names(...future.oldOptions))
[08:25:51.596]     }
[08:25:51.596]     if (FALSE) {
[08:25:51.596]     }
[08:25:51.596]     else {
[08:25:51.596]         if (TRUE) {
[08:25:51.596]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.596]                 open = "w")
[08:25:51.596]         }
[08:25:51.596]         else {
[08:25:51.596]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.596]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.596]         }
[08:25:51.596]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.596]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.596]             base::sink(type = "output", split = FALSE)
[08:25:51.596]             base::close(...future.stdout)
[08:25:51.596]         }, add = TRUE)
[08:25:51.596]     }
[08:25:51.596]     ...future.frame <- base::sys.nframe()
[08:25:51.596]     ...future.conditions <- base::list()
[08:25:51.596]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.596]     if (FALSE) {
[08:25:51.596]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.596]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.596]     }
[08:25:51.596]     ...future.result <- base::tryCatch({
[08:25:51.596]         base::withCallingHandlers({
[08:25:51.596]             ...future.value <- base::withVisible(base::local({
[08:25:51.596]                 ...future.makeSendCondition <- base::local({
[08:25:51.596]                   sendCondition <- NULL
[08:25:51.596]                   function(frame = 1L) {
[08:25:51.596]                     if (is.function(sendCondition)) 
[08:25:51.596]                       return(sendCondition)
[08:25:51.596]                     ns <- getNamespace("parallel")
[08:25:51.596]                     if (exists("sendData", mode = "function", 
[08:25:51.596]                       envir = ns)) {
[08:25:51.596]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.596]                         envir = ns)
[08:25:51.596]                       envir <- sys.frame(frame)
[08:25:51.596]                       master <- NULL
[08:25:51.596]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.596]                         !identical(envir, emptyenv())) {
[08:25:51.596]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.596]                           inherits = FALSE)) {
[08:25:51.596]                           master <- get("master", mode = "list", 
[08:25:51.596]                             envir = envir, inherits = FALSE)
[08:25:51.596]                           if (inherits(master, c("SOCKnode", 
[08:25:51.596]                             "SOCK0node"))) {
[08:25:51.596]                             sendCondition <<- function(cond) {
[08:25:51.596]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.596]                                 success = TRUE)
[08:25:51.596]                               parallel_sendData(master, data)
[08:25:51.596]                             }
[08:25:51.596]                             return(sendCondition)
[08:25:51.596]                           }
[08:25:51.596]                         }
[08:25:51.596]                         frame <- frame + 1L
[08:25:51.596]                         envir <- sys.frame(frame)
[08:25:51.596]                       }
[08:25:51.596]                     }
[08:25:51.596]                     sendCondition <<- function(cond) NULL
[08:25:51.596]                   }
[08:25:51.596]                 })
[08:25:51.596]                 withCallingHandlers({
[08:25:51.596]                   {
[08:25:51.596]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.596]                     if (!identical(...future.globals.maxSize.org, 
[08:25:51.596]                       ...future.globals.maxSize)) {
[08:25:51.596]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.596]                       on.exit(options(oopts), add = TRUE)
[08:25:51.596]                     }
[08:25:51.596]                     {
[08:25:51.596]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.596]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:51.596]                         USE.NAMES = FALSE)
[08:25:51.596]                       do.call(mapply, args = args)
[08:25:51.596]                     }
[08:25:51.596]                   }
[08:25:51.596]                 }, immediateCondition = function(cond) {
[08:25:51.596]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.596]                   sendCondition(cond)
[08:25:51.596]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.596]                   {
[08:25:51.596]                     inherits <- base::inherits
[08:25:51.596]                     invokeRestart <- base::invokeRestart
[08:25:51.596]                     is.null <- base::is.null
[08:25:51.596]                     muffled <- FALSE
[08:25:51.596]                     if (inherits(cond, "message")) {
[08:25:51.596]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.596]                       if (muffled) 
[08:25:51.596]                         invokeRestart("muffleMessage")
[08:25:51.596]                     }
[08:25:51.596]                     else if (inherits(cond, "warning")) {
[08:25:51.596]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.596]                       if (muffled) 
[08:25:51.596]                         invokeRestart("muffleWarning")
[08:25:51.596]                     }
[08:25:51.596]                     else if (inherits(cond, "condition")) {
[08:25:51.596]                       if (!is.null(pattern)) {
[08:25:51.596]                         computeRestarts <- base::computeRestarts
[08:25:51.596]                         grepl <- base::grepl
[08:25:51.596]                         restarts <- computeRestarts(cond)
[08:25:51.596]                         for (restart in restarts) {
[08:25:51.596]                           name <- restart$name
[08:25:51.596]                           if (is.null(name)) 
[08:25:51.596]                             next
[08:25:51.596]                           if (!grepl(pattern, name)) 
[08:25:51.596]                             next
[08:25:51.596]                           invokeRestart(restart)
[08:25:51.596]                           muffled <- TRUE
[08:25:51.596]                           break
[08:25:51.596]                         }
[08:25:51.596]                       }
[08:25:51.596]                     }
[08:25:51.596]                     invisible(muffled)
[08:25:51.596]                   }
[08:25:51.596]                   muffleCondition(cond)
[08:25:51.596]                 })
[08:25:51.596]             }))
[08:25:51.596]             future::FutureResult(value = ...future.value$value, 
[08:25:51.596]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.596]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.596]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.596]                     ...future.globalenv.names))
[08:25:51.596]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.596]         }, condition = base::local({
[08:25:51.596]             c <- base::c
[08:25:51.596]             inherits <- base::inherits
[08:25:51.596]             invokeRestart <- base::invokeRestart
[08:25:51.596]             length <- base::length
[08:25:51.596]             list <- base::list
[08:25:51.596]             seq.int <- base::seq.int
[08:25:51.596]             signalCondition <- base::signalCondition
[08:25:51.596]             sys.calls <- base::sys.calls
[08:25:51.596]             `[[` <- base::`[[`
[08:25:51.596]             `+` <- base::`+`
[08:25:51.596]             `<<-` <- base::`<<-`
[08:25:51.596]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.596]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.596]                   3L)]
[08:25:51.596]             }
[08:25:51.596]             function(cond) {
[08:25:51.596]                 is_error <- inherits(cond, "error")
[08:25:51.596]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.596]                   NULL)
[08:25:51.596]                 if (is_error) {
[08:25:51.596]                   sessionInformation <- function() {
[08:25:51.596]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.596]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.596]                       search = base::search(), system = base::Sys.info())
[08:25:51.596]                   }
[08:25:51.596]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.596]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.596]                     cond$call), session = sessionInformation(), 
[08:25:51.596]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.596]                   signalCondition(cond)
[08:25:51.596]                 }
[08:25:51.596]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.596]                 "immediateCondition"))) {
[08:25:51.596]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.596]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.596]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.596]                   if (TRUE && !signal) {
[08:25:51.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.596]                     {
[08:25:51.596]                       inherits <- base::inherits
[08:25:51.596]                       invokeRestart <- base::invokeRestart
[08:25:51.596]                       is.null <- base::is.null
[08:25:51.596]                       muffled <- FALSE
[08:25:51.596]                       if (inherits(cond, "message")) {
[08:25:51.596]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.596]                         if (muffled) 
[08:25:51.596]                           invokeRestart("muffleMessage")
[08:25:51.596]                       }
[08:25:51.596]                       else if (inherits(cond, "warning")) {
[08:25:51.596]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.596]                         if (muffled) 
[08:25:51.596]                           invokeRestart("muffleWarning")
[08:25:51.596]                       }
[08:25:51.596]                       else if (inherits(cond, "condition")) {
[08:25:51.596]                         if (!is.null(pattern)) {
[08:25:51.596]                           computeRestarts <- base::computeRestarts
[08:25:51.596]                           grepl <- base::grepl
[08:25:51.596]                           restarts <- computeRestarts(cond)
[08:25:51.596]                           for (restart in restarts) {
[08:25:51.596]                             name <- restart$name
[08:25:51.596]                             if (is.null(name)) 
[08:25:51.596]                               next
[08:25:51.596]                             if (!grepl(pattern, name)) 
[08:25:51.596]                               next
[08:25:51.596]                             invokeRestart(restart)
[08:25:51.596]                             muffled <- TRUE
[08:25:51.596]                             break
[08:25:51.596]                           }
[08:25:51.596]                         }
[08:25:51.596]                       }
[08:25:51.596]                       invisible(muffled)
[08:25:51.596]                     }
[08:25:51.596]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.596]                   }
[08:25:51.596]                 }
[08:25:51.596]                 else {
[08:25:51.596]                   if (TRUE) {
[08:25:51.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.596]                     {
[08:25:51.596]                       inherits <- base::inherits
[08:25:51.596]                       invokeRestart <- base::invokeRestart
[08:25:51.596]                       is.null <- base::is.null
[08:25:51.596]                       muffled <- FALSE
[08:25:51.596]                       if (inherits(cond, "message")) {
[08:25:51.596]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.596]                         if (muffled) 
[08:25:51.596]                           invokeRestart("muffleMessage")
[08:25:51.596]                       }
[08:25:51.596]                       else if (inherits(cond, "warning")) {
[08:25:51.596]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.596]                         if (muffled) 
[08:25:51.596]                           invokeRestart("muffleWarning")
[08:25:51.596]                       }
[08:25:51.596]                       else if (inherits(cond, "condition")) {
[08:25:51.596]                         if (!is.null(pattern)) {
[08:25:51.596]                           computeRestarts <- base::computeRestarts
[08:25:51.596]                           grepl <- base::grepl
[08:25:51.596]                           restarts <- computeRestarts(cond)
[08:25:51.596]                           for (restart in restarts) {
[08:25:51.596]                             name <- restart$name
[08:25:51.596]                             if (is.null(name)) 
[08:25:51.596]                               next
[08:25:51.596]                             if (!grepl(pattern, name)) 
[08:25:51.596]                               next
[08:25:51.596]                             invokeRestart(restart)
[08:25:51.596]                             muffled <- TRUE
[08:25:51.596]                             break
[08:25:51.596]                           }
[08:25:51.596]                         }
[08:25:51.596]                       }
[08:25:51.596]                       invisible(muffled)
[08:25:51.596]                     }
[08:25:51.596]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.596]                   }
[08:25:51.596]                 }
[08:25:51.596]             }
[08:25:51.596]         }))
[08:25:51.596]     }, error = function(ex) {
[08:25:51.596]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.596]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.596]                 ...future.rng), started = ...future.startTime, 
[08:25:51.596]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.596]             version = "1.8"), class = "FutureResult")
[08:25:51.596]     }, finally = {
[08:25:51.596]         if (!identical(...future.workdir, getwd())) 
[08:25:51.596]             setwd(...future.workdir)
[08:25:51.596]         {
[08:25:51.596]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.596]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.596]             }
[08:25:51.596]             base::options(...future.oldOptions)
[08:25:51.596]             if (.Platform$OS.type == "windows") {
[08:25:51.596]                 old_names <- names(...future.oldEnvVars)
[08:25:51.596]                 envs <- base::Sys.getenv()
[08:25:51.596]                 names <- names(envs)
[08:25:51.596]                 common <- intersect(names, old_names)
[08:25:51.596]                 added <- setdiff(names, old_names)
[08:25:51.596]                 removed <- setdiff(old_names, names)
[08:25:51.596]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.596]                   envs[common]]
[08:25:51.596]                 NAMES <- toupper(changed)
[08:25:51.596]                 args <- list()
[08:25:51.596]                 for (kk in seq_along(NAMES)) {
[08:25:51.596]                   name <- changed[[kk]]
[08:25:51.596]                   NAME <- NAMES[[kk]]
[08:25:51.596]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.596]                     next
[08:25:51.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.596]                 }
[08:25:51.596]                 NAMES <- toupper(added)
[08:25:51.596]                 for (kk in seq_along(NAMES)) {
[08:25:51.596]                   name <- added[[kk]]
[08:25:51.596]                   NAME <- NAMES[[kk]]
[08:25:51.596]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.596]                     next
[08:25:51.596]                   args[[name]] <- ""
[08:25:51.596]                 }
[08:25:51.596]                 NAMES <- toupper(removed)
[08:25:51.596]                 for (kk in seq_along(NAMES)) {
[08:25:51.596]                   name <- removed[[kk]]
[08:25:51.596]                   NAME <- NAMES[[kk]]
[08:25:51.596]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.596]                     next
[08:25:51.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.596]                 }
[08:25:51.596]                 if (length(args) > 0) 
[08:25:51.596]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.596]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.596]             }
[08:25:51.596]             else {
[08:25:51.596]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.596]             }
[08:25:51.596]             {
[08:25:51.596]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.596]                   0L) {
[08:25:51.596]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.596]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.596]                   base::options(opts)
[08:25:51.596]                 }
[08:25:51.596]                 {
[08:25:51.596]                   {
[08:25:51.596]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.596]                     NULL
[08:25:51.596]                   }
[08:25:51.596]                   options(future.plan = NULL)
[08:25:51.596]                   if (is.na(NA_character_)) 
[08:25:51.596]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.596]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.596]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.596]                     .init = FALSE)
[08:25:51.596]                 }
[08:25:51.596]             }
[08:25:51.596]         }
[08:25:51.596]     })
[08:25:51.596]     if (TRUE) {
[08:25:51.596]         base::sink(type = "output", split = FALSE)
[08:25:51.596]         if (TRUE) {
[08:25:51.596]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.596]         }
[08:25:51.596]         else {
[08:25:51.596]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.596]         }
[08:25:51.596]         base::close(...future.stdout)
[08:25:51.596]         ...future.stdout <- NULL
[08:25:51.596]     }
[08:25:51.596]     ...future.result$conditions <- ...future.conditions
[08:25:51.596]     ...future.result$finished <- base::Sys.time()
[08:25:51.596]     ...future.result
[08:25:51.596] }
[08:25:51.599] Exporting 5 global objects (673 bytes) to cluster node #2 ...
[08:25:51.599] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[08:25:51.599] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[08:25:51.600] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:51.600] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.600] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ...
[08:25:51.600] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ... DONE
[08:25:51.601] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:51.601] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.601] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:51.601] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.601] Exporting 5 global objects (673 bytes) to cluster node #2 ... DONE
[08:25:51.602] MultisessionFuture started
[08:25:51.602] - Launch lazy future ... done
[08:25:51.602] run() for ‘MultisessionFuture’ ... done
[08:25:51.602] Created future:
[08:25:51.602] MultisessionFuture:
[08:25:51.602] Label: ‘future_mapply-2’
[08:25:51.602] Expression:
[08:25:51.602] {
[08:25:51.602]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.602]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:51.602]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.602]         on.exit(options(oopts), add = TRUE)
[08:25:51.602]     }
[08:25:51.602]     {
[08:25:51.602]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.602]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:51.602]         do.call(mapply, args = args)
[08:25:51.602]     }
[08:25:51.602] }
[08:25:51.602] Lazy evaluation: FALSE
[08:25:51.602] Asynchronous evaluation: TRUE
[08:25:51.602] Local evaluation: TRUE
[08:25:51.602] Environment: R_GlobalEnv
[08:25:51.602] Capture standard output: TRUE
[08:25:51.602] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:51.602] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:51.602] Packages: <none>
[08:25:51.602] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:51.602] Resolved: FALSE
[08:25:51.602] Value: <not collected>
[08:25:51.602] Conditions captured: <none>
[08:25:51.602] Early signaling: FALSE
[08:25:51.602] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:51.602] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.614] Chunk #2 of 2 ... DONE
[08:25:51.614] Launching 2 futures (chunks) ... DONE
[08:25:51.614] Resolving 2 futures (chunks) ...
[08:25:51.614] resolve() on list ...
[08:25:51.614]  recursive: 0
[08:25:51.614]  length: 2
[08:25:51.614] 
[08:25:51.615] receiveMessageFromWorker() for ClusterFuture ...
[08:25:51.615] - Validating connection of MultisessionFuture
[08:25:51.615] - received message: FutureResult
[08:25:51.615] - Received FutureResult
[08:25:51.615] - Erased future from FutureRegistry
[08:25:51.616] result() for ClusterFuture ...
[08:25:51.616] - result already collected: FutureResult
[08:25:51.616] result() for ClusterFuture ... done
[08:25:51.616] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:51.616] Future #1
[08:25:51.616] result() for ClusterFuture ...
[08:25:51.616] - result already collected: FutureResult
[08:25:51.616] result() for ClusterFuture ... done
[08:25:51.616] result() for ClusterFuture ...
[08:25:51.616] - result already collected: FutureResult
[08:25:51.616] result() for ClusterFuture ... done
[08:25:51.617] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:51.617] - nx: 2
[08:25:51.617] - relay: TRUE
[08:25:51.617] - stdout: TRUE
[08:25:51.617] - signal: TRUE
[08:25:51.617] - resignal: FALSE
[08:25:51.617] - force: TRUE
[08:25:51.617] - relayed: [n=2] FALSE, FALSE
[08:25:51.617] - queued futures: [n=2] FALSE, FALSE
[08:25:51.617]  - until=1
[08:25:51.617]  - relaying element #1
[08:25:51.617] result() for ClusterFuture ...
[08:25:51.617] - result already collected: FutureResult
[08:25:51.618] result() for ClusterFuture ... done
[08:25:51.618] result() for ClusterFuture ...
[08:25:51.618] - result already collected: FutureResult
[08:25:51.618] result() for ClusterFuture ... done
[08:25:51.618] result() for ClusterFuture ...
[08:25:51.618] - result already collected: FutureResult
[08:25:51.618] result() for ClusterFuture ... done
[08:25:51.618] result() for ClusterFuture ...
[08:25:51.618] - result already collected: FutureResult
[08:25:51.618] result() for ClusterFuture ... done
[08:25:51.618] - relayed: [n=2] TRUE, FALSE
[08:25:51.618] - queued futures: [n=2] TRUE, FALSE
[08:25:51.619] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:51.619]  length: 1 (resolved future 1)
[08:25:51.648] receiveMessageFromWorker() for ClusterFuture ...
[08:25:51.648] - Validating connection of MultisessionFuture
[08:25:51.648] - received message: FutureResult
[08:25:51.648] - Received FutureResult
[08:25:51.649] - Erased future from FutureRegistry
[08:25:51.649] result() for ClusterFuture ...
[08:25:51.649] - result already collected: FutureResult
[08:25:51.649] result() for ClusterFuture ... done
[08:25:51.649] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:51.649] Future #2
[08:25:51.649] result() for ClusterFuture ...
[08:25:51.649] - result already collected: FutureResult
[08:25:51.649] result() for ClusterFuture ... done
[08:25:51.649] result() for ClusterFuture ...
[08:25:51.649] - result already collected: FutureResult
[08:25:51.650] result() for ClusterFuture ... done
[08:25:51.650] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:51.650] - nx: 2
[08:25:51.650] - relay: TRUE
[08:25:51.650] - stdout: TRUE
[08:25:51.650] - signal: TRUE
[08:25:51.650] - resignal: FALSE
[08:25:51.650] - force: TRUE
[08:25:51.650] - relayed: [n=2] TRUE, FALSE
[08:25:51.650] - queued futures: [n=2] TRUE, FALSE
[08:25:51.650]  - until=2
[08:25:51.650]  - relaying element #2
[08:25:51.651] result() for ClusterFuture ...
[08:25:51.651] - result already collected: FutureResult
[08:25:51.651] result() for ClusterFuture ... done
[08:25:51.651] result() for ClusterFuture ...
[08:25:51.651] - result already collected: FutureResult
[08:25:51.651] result() for ClusterFuture ... done
[08:25:51.651] result() for ClusterFuture ...
[08:25:51.651] - result already collected: FutureResult
[08:25:51.651] result() for ClusterFuture ... done
[08:25:51.651] result() for ClusterFuture ...
[08:25:51.651] - result already collected: FutureResult
[08:25:51.651] result() for ClusterFuture ... done
[08:25:51.652] - relayed: [n=2] TRUE, TRUE
[08:25:51.652] - queued futures: [n=2] TRUE, TRUE
[08:25:51.652] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:51.652]  length: 0 (resolved future 2)
[08:25:51.652] Relaying remaining futures
[08:25:51.652] signalConditionsASAP(NULL, pos=0) ...
[08:25:51.652] - nx: 2
[08:25:51.652] - relay: TRUE
[08:25:51.652] - stdout: TRUE
[08:25:51.652] - signal: TRUE
[08:25:51.652] - resignal: FALSE
[08:25:51.652] - force: TRUE
[08:25:51.653] - relayed: [n=2] TRUE, TRUE
[08:25:51.653] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:51.653] - relayed: [n=2] TRUE, TRUE
[08:25:51.653] - queued futures: [n=2] TRUE, TRUE
[08:25:51.653] signalConditionsASAP(NULL, pos=0) ... done
[08:25:51.653] resolve() on list ... DONE
[08:25:51.653] result() for ClusterFuture ...
[08:25:51.653] - result already collected: FutureResult
[08:25:51.653] result() for ClusterFuture ... done
[08:25:51.653] result() for ClusterFuture ...
[08:25:51.653] - result already collected: FutureResult
[08:25:51.654] result() for ClusterFuture ... done
[08:25:51.654] result() for ClusterFuture ...
[08:25:51.654] - result already collected: FutureResult
[08:25:51.654] result() for ClusterFuture ... done
[08:25:51.654] result() for ClusterFuture ...
[08:25:51.654] - result already collected: FutureResult
[08:25:51.654] result() for ClusterFuture ... done
[08:25:51.654]  - Number of value chunks collected: 2
[08:25:51.654] Resolving 2 futures (chunks) ... DONE
[08:25:51.654] Reducing values from 2 chunks ...
[08:25:51.654]  - Number of values collected after concatenation: 4
[08:25:51.654]  - Number of values expected: 4
[08:25:51.655] Reducing values from 2 chunks ... DONE
[08:25:51.655] future_mapply() ... DONE
[08:25:51.655] future_mapply() ...
[08:25:51.657] Number of chunks: 2
[08:25:51.657] getGlobalsAndPackagesXApply() ...
[08:25:51.657]  - future.globals: TRUE
[08:25:51.657] getGlobalsAndPackages() ...
[08:25:51.657] Searching for globals...
[08:25:51.658] - globals found: [1] ‘FUN’
[08:25:51.658] Searching for globals ... DONE
[08:25:51.658] Resolving globals: FALSE
[08:25:51.658] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:51.658] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:51.659] - globals: [1] ‘FUN’
[08:25:51.659] 
[08:25:51.659] getGlobalsAndPackages() ... DONE
[08:25:51.659]  - globals found/used: [n=1] ‘FUN’
[08:25:51.659]  - needed namespaces: [n=0] 
[08:25:51.659] Finding globals ... DONE
[08:25:51.659] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:51.659] List of 2
[08:25:51.659]  $ ...future.FUN:function (x, ...)  
[08:25:51.659]  $ MoreArgs     : NULL
[08:25:51.659]  - attr(*, "where")=List of 2
[08:25:51.659]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:51.659]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:51.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:51.659]  - attr(*, "resolved")= logi FALSE
[08:25:51.659]  - attr(*, "total_size")= num NA
[08:25:51.662] Packages to be attached in all futures: [n=0] 
[08:25:51.662] getGlobalsAndPackagesXApply() ... DONE
[08:25:51.662] Number of futures (= number of chunks): 2
[08:25:51.662] Launching 2 futures (chunks) ...
[08:25:51.662] Chunk #1 of 2 ...
[08:25:51.662]  - Finding globals in '...' for chunk #1 ...
[08:25:51.662] getGlobalsAndPackages() ...
[08:25:51.663] Searching for globals...
[08:25:51.663] 
[08:25:51.663] Searching for globals ... DONE
[08:25:51.663] - globals: [0] <none>
[08:25:51.663] getGlobalsAndPackages() ... DONE
[08:25:51.663]    + additional globals found: [n=0] 
[08:25:51.663]    + additional namespaces needed: [n=0] 
[08:25:51.663]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:51.663]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:51.664]  - seeds: <none>
[08:25:51.664]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.664] getGlobalsAndPackages() ...
[08:25:51.664] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.664] Resolving globals: FALSE
[08:25:51.664] The total size of the 5 globals is 265 bytes (265 bytes)
[08:25:51.665] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:51.665] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.665] 
[08:25:51.665] getGlobalsAndPackages() ... DONE
[08:25:51.665] run() for ‘Future’ ...
[08:25:51.665] - state: ‘created’
[08:25:51.666] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:51.679] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:51.679]   - Field: ‘node’
[08:25:51.679]   - Field: ‘label’
[08:25:51.679]   - Field: ‘local’
[08:25:51.680]   - Field: ‘owner’
[08:25:51.680]   - Field: ‘envir’
[08:25:51.680]   - Field: ‘workers’
[08:25:51.680]   - Field: ‘packages’
[08:25:51.680]   - Field: ‘gc’
[08:25:51.680]   - Field: ‘conditions’
[08:25:51.680]   - Field: ‘persistent’
[08:25:51.680]   - Field: ‘expr’
[08:25:51.680]   - Field: ‘uuid’
[08:25:51.680]   - Field: ‘seed’
[08:25:51.680]   - Field: ‘version’
[08:25:51.680]   - Field: ‘result’
[08:25:51.681]   - Field: ‘asynchronous’
[08:25:51.681]   - Field: ‘calls’
[08:25:51.681]   - Field: ‘globals’
[08:25:51.681]   - Field: ‘stdout’
[08:25:51.681]   - Field: ‘earlySignal’
[08:25:51.681]   - Field: ‘lazy’
[08:25:51.681]   - Field: ‘state’
[08:25:51.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:51.681] - Launch lazy future ...
[08:25:51.681] Packages needed by the future expression (n = 0): <none>
[08:25:51.682] Packages needed by future strategies (n = 0): <none>
[08:25:51.682] {
[08:25:51.682]     {
[08:25:51.682]         {
[08:25:51.682]             ...future.startTime <- base::Sys.time()
[08:25:51.682]             {
[08:25:51.682]                 {
[08:25:51.682]                   {
[08:25:51.682]                     {
[08:25:51.682]                       base::local({
[08:25:51.682]                         has_future <- base::requireNamespace("future", 
[08:25:51.682]                           quietly = TRUE)
[08:25:51.682]                         if (has_future) {
[08:25:51.682]                           ns <- base::getNamespace("future")
[08:25:51.682]                           version <- ns[[".package"]][["version"]]
[08:25:51.682]                           if (is.null(version)) 
[08:25:51.682]                             version <- utils::packageVersion("future")
[08:25:51.682]                         }
[08:25:51.682]                         else {
[08:25:51.682]                           version <- NULL
[08:25:51.682]                         }
[08:25:51.682]                         if (!has_future || version < "1.8.0") {
[08:25:51.682]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.682]                             "", base::R.version$version.string), 
[08:25:51.682]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.682]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.682]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.682]                               "release", "version")], collapse = " "), 
[08:25:51.682]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.682]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.682]                             info)
[08:25:51.682]                           info <- base::paste(info, collapse = "; ")
[08:25:51.682]                           if (!has_future) {
[08:25:51.682]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.682]                               info)
[08:25:51.682]                           }
[08:25:51.682]                           else {
[08:25:51.682]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.682]                               info, version)
[08:25:51.682]                           }
[08:25:51.682]                           base::stop(msg)
[08:25:51.682]                         }
[08:25:51.682]                       })
[08:25:51.682]                     }
[08:25:51.682]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.682]                     base::options(mc.cores = 1L)
[08:25:51.682]                   }
[08:25:51.682]                   ...future.strategy.old <- future::plan("list")
[08:25:51.682]                   options(future.plan = NULL)
[08:25:51.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.682]                 }
[08:25:51.682]                 ...future.workdir <- getwd()
[08:25:51.682]             }
[08:25:51.682]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.682]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.682]         }
[08:25:51.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.682]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:51.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.682]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.682]             base::names(...future.oldOptions))
[08:25:51.682]     }
[08:25:51.682]     if (FALSE) {
[08:25:51.682]     }
[08:25:51.682]     else {
[08:25:51.682]         if (TRUE) {
[08:25:51.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.682]                 open = "w")
[08:25:51.682]         }
[08:25:51.682]         else {
[08:25:51.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.682]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.682]         }
[08:25:51.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.682]             base::sink(type = "output", split = FALSE)
[08:25:51.682]             base::close(...future.stdout)
[08:25:51.682]         }, add = TRUE)
[08:25:51.682]     }
[08:25:51.682]     ...future.frame <- base::sys.nframe()
[08:25:51.682]     ...future.conditions <- base::list()
[08:25:51.682]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.682]     if (FALSE) {
[08:25:51.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.682]     }
[08:25:51.682]     ...future.result <- base::tryCatch({
[08:25:51.682]         base::withCallingHandlers({
[08:25:51.682]             ...future.value <- base::withVisible(base::local({
[08:25:51.682]                 ...future.makeSendCondition <- base::local({
[08:25:51.682]                   sendCondition <- NULL
[08:25:51.682]                   function(frame = 1L) {
[08:25:51.682]                     if (is.function(sendCondition)) 
[08:25:51.682]                       return(sendCondition)
[08:25:51.682]                     ns <- getNamespace("parallel")
[08:25:51.682]                     if (exists("sendData", mode = "function", 
[08:25:51.682]                       envir = ns)) {
[08:25:51.682]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.682]                         envir = ns)
[08:25:51.682]                       envir <- sys.frame(frame)
[08:25:51.682]                       master <- NULL
[08:25:51.682]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.682]                         !identical(envir, emptyenv())) {
[08:25:51.682]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.682]                           inherits = FALSE)) {
[08:25:51.682]                           master <- get("master", mode = "list", 
[08:25:51.682]                             envir = envir, inherits = FALSE)
[08:25:51.682]                           if (inherits(master, c("SOCKnode", 
[08:25:51.682]                             "SOCK0node"))) {
[08:25:51.682]                             sendCondition <<- function(cond) {
[08:25:51.682]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.682]                                 success = TRUE)
[08:25:51.682]                               parallel_sendData(master, data)
[08:25:51.682]                             }
[08:25:51.682]                             return(sendCondition)
[08:25:51.682]                           }
[08:25:51.682]                         }
[08:25:51.682]                         frame <- frame + 1L
[08:25:51.682]                         envir <- sys.frame(frame)
[08:25:51.682]                       }
[08:25:51.682]                     }
[08:25:51.682]                     sendCondition <<- function(cond) NULL
[08:25:51.682]                   }
[08:25:51.682]                 })
[08:25:51.682]                 withCallingHandlers({
[08:25:51.682]                   {
[08:25:51.682]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.682]                     if (!identical(...future.globals.maxSize.org, 
[08:25:51.682]                       ...future.globals.maxSize)) {
[08:25:51.682]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.682]                       on.exit(options(oopts), add = TRUE)
[08:25:51.682]                     }
[08:25:51.682]                     {
[08:25:51.682]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.682]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:51.682]                         USE.NAMES = FALSE)
[08:25:51.682]                       do.call(mapply, args = args)
[08:25:51.682]                     }
[08:25:51.682]                   }
[08:25:51.682]                 }, immediateCondition = function(cond) {
[08:25:51.682]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.682]                   sendCondition(cond)
[08:25:51.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.682]                   {
[08:25:51.682]                     inherits <- base::inherits
[08:25:51.682]                     invokeRestart <- base::invokeRestart
[08:25:51.682]                     is.null <- base::is.null
[08:25:51.682]                     muffled <- FALSE
[08:25:51.682]                     if (inherits(cond, "message")) {
[08:25:51.682]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.682]                       if (muffled) 
[08:25:51.682]                         invokeRestart("muffleMessage")
[08:25:51.682]                     }
[08:25:51.682]                     else if (inherits(cond, "warning")) {
[08:25:51.682]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.682]                       if (muffled) 
[08:25:51.682]                         invokeRestart("muffleWarning")
[08:25:51.682]                     }
[08:25:51.682]                     else if (inherits(cond, "condition")) {
[08:25:51.682]                       if (!is.null(pattern)) {
[08:25:51.682]                         computeRestarts <- base::computeRestarts
[08:25:51.682]                         grepl <- base::grepl
[08:25:51.682]                         restarts <- computeRestarts(cond)
[08:25:51.682]                         for (restart in restarts) {
[08:25:51.682]                           name <- restart$name
[08:25:51.682]                           if (is.null(name)) 
[08:25:51.682]                             next
[08:25:51.682]                           if (!grepl(pattern, name)) 
[08:25:51.682]                             next
[08:25:51.682]                           invokeRestart(restart)
[08:25:51.682]                           muffled <- TRUE
[08:25:51.682]                           break
[08:25:51.682]                         }
[08:25:51.682]                       }
[08:25:51.682]                     }
[08:25:51.682]                     invisible(muffled)
[08:25:51.682]                   }
[08:25:51.682]                   muffleCondition(cond)
[08:25:51.682]                 })
[08:25:51.682]             }))
[08:25:51.682]             future::FutureResult(value = ...future.value$value, 
[08:25:51.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.682]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.682]                     ...future.globalenv.names))
[08:25:51.682]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.682]         }, condition = base::local({
[08:25:51.682]             c <- base::c
[08:25:51.682]             inherits <- base::inherits
[08:25:51.682]             invokeRestart <- base::invokeRestart
[08:25:51.682]             length <- base::length
[08:25:51.682]             list <- base::list
[08:25:51.682]             seq.int <- base::seq.int
[08:25:51.682]             signalCondition <- base::signalCondition
[08:25:51.682]             sys.calls <- base::sys.calls
[08:25:51.682]             `[[` <- base::`[[`
[08:25:51.682]             `+` <- base::`+`
[08:25:51.682]             `<<-` <- base::`<<-`
[08:25:51.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.682]                   3L)]
[08:25:51.682]             }
[08:25:51.682]             function(cond) {
[08:25:51.682]                 is_error <- inherits(cond, "error")
[08:25:51.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.682]                   NULL)
[08:25:51.682]                 if (is_error) {
[08:25:51.682]                   sessionInformation <- function() {
[08:25:51.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.682]                       search = base::search(), system = base::Sys.info())
[08:25:51.682]                   }
[08:25:51.682]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.682]                     cond$call), session = sessionInformation(), 
[08:25:51.682]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.682]                   signalCondition(cond)
[08:25:51.682]                 }
[08:25:51.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.682]                 "immediateCondition"))) {
[08:25:51.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.682]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.682]                   if (TRUE && !signal) {
[08:25:51.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.682]                     {
[08:25:51.682]                       inherits <- base::inherits
[08:25:51.682]                       invokeRestart <- base::invokeRestart
[08:25:51.682]                       is.null <- base::is.null
[08:25:51.682]                       muffled <- FALSE
[08:25:51.682]                       if (inherits(cond, "message")) {
[08:25:51.682]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.682]                         if (muffled) 
[08:25:51.682]                           invokeRestart("muffleMessage")
[08:25:51.682]                       }
[08:25:51.682]                       else if (inherits(cond, "warning")) {
[08:25:51.682]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.682]                         if (muffled) 
[08:25:51.682]                           invokeRestart("muffleWarning")
[08:25:51.682]                       }
[08:25:51.682]                       else if (inherits(cond, "condition")) {
[08:25:51.682]                         if (!is.null(pattern)) {
[08:25:51.682]                           computeRestarts <- base::computeRestarts
[08:25:51.682]                           grepl <- base::grepl
[08:25:51.682]                           restarts <- computeRestarts(cond)
[08:25:51.682]                           for (restart in restarts) {
[08:25:51.682]                             name <- restart$name
[08:25:51.682]                             if (is.null(name)) 
[08:25:51.682]                               next
[08:25:51.682]                             if (!grepl(pattern, name)) 
[08:25:51.682]                               next
[08:25:51.682]                             invokeRestart(restart)
[08:25:51.682]                             muffled <- TRUE
[08:25:51.682]                             break
[08:25:51.682]                           }
[08:25:51.682]                         }
[08:25:51.682]                       }
[08:25:51.682]                       invisible(muffled)
[08:25:51.682]                     }
[08:25:51.682]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.682]                   }
[08:25:51.682]                 }
[08:25:51.682]                 else {
[08:25:51.682]                   if (TRUE) {
[08:25:51.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.682]                     {
[08:25:51.682]                       inherits <- base::inherits
[08:25:51.682]                       invokeRestart <- base::invokeRestart
[08:25:51.682]                       is.null <- base::is.null
[08:25:51.682]                       muffled <- FALSE
[08:25:51.682]                       if (inherits(cond, "message")) {
[08:25:51.682]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.682]                         if (muffled) 
[08:25:51.682]                           invokeRestart("muffleMessage")
[08:25:51.682]                       }
[08:25:51.682]                       else if (inherits(cond, "warning")) {
[08:25:51.682]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.682]                         if (muffled) 
[08:25:51.682]                           invokeRestart("muffleWarning")
[08:25:51.682]                       }
[08:25:51.682]                       else if (inherits(cond, "condition")) {
[08:25:51.682]                         if (!is.null(pattern)) {
[08:25:51.682]                           computeRestarts <- base::computeRestarts
[08:25:51.682]                           grepl <- base::grepl
[08:25:51.682]                           restarts <- computeRestarts(cond)
[08:25:51.682]                           for (restart in restarts) {
[08:25:51.682]                             name <- restart$name
[08:25:51.682]                             if (is.null(name)) 
[08:25:51.682]                               next
[08:25:51.682]                             if (!grepl(pattern, name)) 
[08:25:51.682]                               next
[08:25:51.682]                             invokeRestart(restart)
[08:25:51.682]                             muffled <- TRUE
[08:25:51.682]                             break
[08:25:51.682]                           }
[08:25:51.682]                         }
[08:25:51.682]                       }
[08:25:51.682]                       invisible(muffled)
[08:25:51.682]                     }
[08:25:51.682]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.682]                   }
[08:25:51.682]                 }
[08:25:51.682]             }
[08:25:51.682]         }))
[08:25:51.682]     }, error = function(ex) {
[08:25:51.682]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.682]                 ...future.rng), started = ...future.startTime, 
[08:25:51.682]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.682]             version = "1.8"), class = "FutureResult")
[08:25:51.682]     }, finally = {
[08:25:51.682]         if (!identical(...future.workdir, getwd())) 
[08:25:51.682]             setwd(...future.workdir)
[08:25:51.682]         {
[08:25:51.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.682]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.682]             }
[08:25:51.682]             base::options(...future.oldOptions)
[08:25:51.682]             if (.Platform$OS.type == "windows") {
[08:25:51.682]                 old_names <- names(...future.oldEnvVars)
[08:25:51.682]                 envs <- base::Sys.getenv()
[08:25:51.682]                 names <- names(envs)
[08:25:51.682]                 common <- intersect(names, old_names)
[08:25:51.682]                 added <- setdiff(names, old_names)
[08:25:51.682]                 removed <- setdiff(old_names, names)
[08:25:51.682]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.682]                   envs[common]]
[08:25:51.682]                 NAMES <- toupper(changed)
[08:25:51.682]                 args <- list()
[08:25:51.682]                 for (kk in seq_along(NAMES)) {
[08:25:51.682]                   name <- changed[[kk]]
[08:25:51.682]                   NAME <- NAMES[[kk]]
[08:25:51.682]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.682]                     next
[08:25:51.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.682]                 }
[08:25:51.682]                 NAMES <- toupper(added)
[08:25:51.682]                 for (kk in seq_along(NAMES)) {
[08:25:51.682]                   name <- added[[kk]]
[08:25:51.682]                   NAME <- NAMES[[kk]]
[08:25:51.682]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.682]                     next
[08:25:51.682]                   args[[name]] <- ""
[08:25:51.682]                 }
[08:25:51.682]                 NAMES <- toupper(removed)
[08:25:51.682]                 for (kk in seq_along(NAMES)) {
[08:25:51.682]                   name <- removed[[kk]]
[08:25:51.682]                   NAME <- NAMES[[kk]]
[08:25:51.682]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.682]                     next
[08:25:51.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.682]                 }
[08:25:51.682]                 if (length(args) > 0) 
[08:25:51.682]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.682]             }
[08:25:51.682]             else {
[08:25:51.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.682]             }
[08:25:51.682]             {
[08:25:51.682]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.682]                   0L) {
[08:25:51.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.682]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.682]                   base::options(opts)
[08:25:51.682]                 }
[08:25:51.682]                 {
[08:25:51.682]                   {
[08:25:51.682]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.682]                     NULL
[08:25:51.682]                   }
[08:25:51.682]                   options(future.plan = NULL)
[08:25:51.682]                   if (is.na(NA_character_)) 
[08:25:51.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.682]                     .init = FALSE)
[08:25:51.682]                 }
[08:25:51.682]             }
[08:25:51.682]         }
[08:25:51.682]     })
[08:25:51.682]     if (TRUE) {
[08:25:51.682]         base::sink(type = "output", split = FALSE)
[08:25:51.682]         if (TRUE) {
[08:25:51.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.682]         }
[08:25:51.682]         else {
[08:25:51.682]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.682]         }
[08:25:51.682]         base::close(...future.stdout)
[08:25:51.682]         ...future.stdout <- NULL
[08:25:51.682]     }
[08:25:51.682]     ...future.result$conditions <- ...future.conditions
[08:25:51.682]     ...future.result$finished <- base::Sys.time()
[08:25:51.682]     ...future.result
[08:25:51.682] }
[08:25:51.685] Exporting 5 global objects (715 bytes) to cluster node #1 ...
[08:25:51.685] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[08:25:51.686] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[08:25:51.686] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:51.686] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.686] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ...
[08:25:51.687] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ... DONE
[08:25:51.687] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:51.687] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.687] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:51.687] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.688] Exporting 5 global objects (715 bytes) to cluster node #1 ... DONE
[08:25:51.688] MultisessionFuture started
[08:25:51.688] - Launch lazy future ... done
[08:25:51.688] run() for ‘MultisessionFuture’ ... done
[08:25:51.688] Created future:
[08:25:51.688] MultisessionFuture:
[08:25:51.688] Label: ‘future_mapply-1’
[08:25:51.688] Expression:
[08:25:51.688] {
[08:25:51.688]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.688]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:51.688]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.688]         on.exit(options(oopts), add = TRUE)
[08:25:51.688]     }
[08:25:51.688]     {
[08:25:51.688]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.688]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:51.688]         do.call(mapply, args = args)
[08:25:51.688]     }
[08:25:51.688] }
[08:25:51.688] Lazy evaluation: FALSE
[08:25:51.688] Asynchronous evaluation: TRUE
[08:25:51.688] Local evaluation: TRUE
[08:25:51.688] Environment: R_GlobalEnv
[08:25:51.688] Capture standard output: TRUE
[08:25:51.688] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:51.688] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:51.688] Packages: <none>
[08:25:51.688] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:51.688] Resolved: FALSE
[08:25:51.688] Value: <not collected>
[08:25:51.688] Conditions captured: <none>
[08:25:51.688] Early signaling: FALSE
[08:25:51.688] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:51.688] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.700] Chunk #1 of 2 ... DONE
[08:25:51.700] Chunk #2 of 2 ...
[08:25:51.700]  - Finding globals in '...' for chunk #2 ...
[08:25:51.700] getGlobalsAndPackages() ...
[08:25:51.700] Searching for globals...
[08:25:51.701] 
[08:25:51.701] Searching for globals ... DONE
[08:25:51.701] - globals: [0] <none>
[08:25:51.701] getGlobalsAndPackages() ... DONE
[08:25:51.701]    + additional globals found: [n=0] 
[08:25:51.701]    + additional namespaces needed: [n=0] 
[08:25:51.701]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:51.701]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:51.702]  - seeds: <none>
[08:25:51.702]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.702] getGlobalsAndPackages() ...
[08:25:51.702] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.702] Resolving globals: FALSE
[08:25:51.702] The total size of the 5 globals is 265 bytes (265 bytes)
[08:25:51.703] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 265 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (150 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:51.703] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.703] 
[08:25:51.703] getGlobalsAndPackages() ... DONE
[08:25:51.703] run() for ‘Future’ ...
[08:25:51.704] - state: ‘created’
[08:25:51.704] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:51.718] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:51.718]   - Field: ‘node’
[08:25:51.718]   - Field: ‘label’
[08:25:51.718]   - Field: ‘local’
[08:25:51.718]   - Field: ‘owner’
[08:25:51.718]   - Field: ‘envir’
[08:25:51.718]   - Field: ‘workers’
[08:25:51.718]   - Field: ‘packages’
[08:25:51.719]   - Field: ‘gc’
[08:25:51.719]   - Field: ‘conditions’
[08:25:51.719]   - Field: ‘persistent’
[08:25:51.719]   - Field: ‘expr’
[08:25:51.719]   - Field: ‘uuid’
[08:25:51.719]   - Field: ‘seed’
[08:25:51.719]   - Field: ‘version’
[08:25:51.719]   - Field: ‘result’
[08:25:51.719]   - Field: ‘asynchronous’
[08:25:51.719]   - Field: ‘calls’
[08:25:51.719]   - Field: ‘globals’
[08:25:51.719]   - Field: ‘stdout’
[08:25:51.720]   - Field: ‘earlySignal’
[08:25:51.720]   - Field: ‘lazy’
[08:25:51.720]   - Field: ‘state’
[08:25:51.720] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:51.720] - Launch lazy future ...
[08:25:51.720] Packages needed by the future expression (n = 0): <none>
[08:25:51.720] Packages needed by future strategies (n = 0): <none>
[08:25:51.721] {
[08:25:51.721]     {
[08:25:51.721]         {
[08:25:51.721]             ...future.startTime <- base::Sys.time()
[08:25:51.721]             {
[08:25:51.721]                 {
[08:25:51.721]                   {
[08:25:51.721]                     {
[08:25:51.721]                       base::local({
[08:25:51.721]                         has_future <- base::requireNamespace("future", 
[08:25:51.721]                           quietly = TRUE)
[08:25:51.721]                         if (has_future) {
[08:25:51.721]                           ns <- base::getNamespace("future")
[08:25:51.721]                           version <- ns[[".package"]][["version"]]
[08:25:51.721]                           if (is.null(version)) 
[08:25:51.721]                             version <- utils::packageVersion("future")
[08:25:51.721]                         }
[08:25:51.721]                         else {
[08:25:51.721]                           version <- NULL
[08:25:51.721]                         }
[08:25:51.721]                         if (!has_future || version < "1.8.0") {
[08:25:51.721]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.721]                             "", base::R.version$version.string), 
[08:25:51.721]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.721]                               "release", "version")], collapse = " "), 
[08:25:51.721]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.721]                             info)
[08:25:51.721]                           info <- base::paste(info, collapse = "; ")
[08:25:51.721]                           if (!has_future) {
[08:25:51.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.721]                               info)
[08:25:51.721]                           }
[08:25:51.721]                           else {
[08:25:51.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.721]                               info, version)
[08:25:51.721]                           }
[08:25:51.721]                           base::stop(msg)
[08:25:51.721]                         }
[08:25:51.721]                       })
[08:25:51.721]                     }
[08:25:51.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.721]                     base::options(mc.cores = 1L)
[08:25:51.721]                   }
[08:25:51.721]                   ...future.strategy.old <- future::plan("list")
[08:25:51.721]                   options(future.plan = NULL)
[08:25:51.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.721]                 }
[08:25:51.721]                 ...future.workdir <- getwd()
[08:25:51.721]             }
[08:25:51.721]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.721]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.721]         }
[08:25:51.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.721]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:51.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.721]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.721]             base::names(...future.oldOptions))
[08:25:51.721]     }
[08:25:51.721]     if (FALSE) {
[08:25:51.721]     }
[08:25:51.721]     else {
[08:25:51.721]         if (TRUE) {
[08:25:51.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.721]                 open = "w")
[08:25:51.721]         }
[08:25:51.721]         else {
[08:25:51.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.721]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.721]         }
[08:25:51.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.721]             base::sink(type = "output", split = FALSE)
[08:25:51.721]             base::close(...future.stdout)
[08:25:51.721]         }, add = TRUE)
[08:25:51.721]     }
[08:25:51.721]     ...future.frame <- base::sys.nframe()
[08:25:51.721]     ...future.conditions <- base::list()
[08:25:51.721]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.721]     if (FALSE) {
[08:25:51.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.721]     }
[08:25:51.721]     ...future.result <- base::tryCatch({
[08:25:51.721]         base::withCallingHandlers({
[08:25:51.721]             ...future.value <- base::withVisible(base::local({
[08:25:51.721]                 ...future.makeSendCondition <- base::local({
[08:25:51.721]                   sendCondition <- NULL
[08:25:51.721]                   function(frame = 1L) {
[08:25:51.721]                     if (is.function(sendCondition)) 
[08:25:51.721]                       return(sendCondition)
[08:25:51.721]                     ns <- getNamespace("parallel")
[08:25:51.721]                     if (exists("sendData", mode = "function", 
[08:25:51.721]                       envir = ns)) {
[08:25:51.721]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.721]                         envir = ns)
[08:25:51.721]                       envir <- sys.frame(frame)
[08:25:51.721]                       master <- NULL
[08:25:51.721]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.721]                         !identical(envir, emptyenv())) {
[08:25:51.721]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.721]                           inherits = FALSE)) {
[08:25:51.721]                           master <- get("master", mode = "list", 
[08:25:51.721]                             envir = envir, inherits = FALSE)
[08:25:51.721]                           if (inherits(master, c("SOCKnode", 
[08:25:51.721]                             "SOCK0node"))) {
[08:25:51.721]                             sendCondition <<- function(cond) {
[08:25:51.721]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.721]                                 success = TRUE)
[08:25:51.721]                               parallel_sendData(master, data)
[08:25:51.721]                             }
[08:25:51.721]                             return(sendCondition)
[08:25:51.721]                           }
[08:25:51.721]                         }
[08:25:51.721]                         frame <- frame + 1L
[08:25:51.721]                         envir <- sys.frame(frame)
[08:25:51.721]                       }
[08:25:51.721]                     }
[08:25:51.721]                     sendCondition <<- function(cond) NULL
[08:25:51.721]                   }
[08:25:51.721]                 })
[08:25:51.721]                 withCallingHandlers({
[08:25:51.721]                   {
[08:25:51.721]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.721]                     if (!identical(...future.globals.maxSize.org, 
[08:25:51.721]                       ...future.globals.maxSize)) {
[08:25:51.721]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.721]                       on.exit(options(oopts), add = TRUE)
[08:25:51.721]                     }
[08:25:51.721]                     {
[08:25:51.721]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.721]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:51.721]                         USE.NAMES = FALSE)
[08:25:51.721]                       do.call(mapply, args = args)
[08:25:51.721]                     }
[08:25:51.721]                   }
[08:25:51.721]                 }, immediateCondition = function(cond) {
[08:25:51.721]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.721]                   sendCondition(cond)
[08:25:51.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.721]                   {
[08:25:51.721]                     inherits <- base::inherits
[08:25:51.721]                     invokeRestart <- base::invokeRestart
[08:25:51.721]                     is.null <- base::is.null
[08:25:51.721]                     muffled <- FALSE
[08:25:51.721]                     if (inherits(cond, "message")) {
[08:25:51.721]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.721]                       if (muffled) 
[08:25:51.721]                         invokeRestart("muffleMessage")
[08:25:51.721]                     }
[08:25:51.721]                     else if (inherits(cond, "warning")) {
[08:25:51.721]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.721]                       if (muffled) 
[08:25:51.721]                         invokeRestart("muffleWarning")
[08:25:51.721]                     }
[08:25:51.721]                     else if (inherits(cond, "condition")) {
[08:25:51.721]                       if (!is.null(pattern)) {
[08:25:51.721]                         computeRestarts <- base::computeRestarts
[08:25:51.721]                         grepl <- base::grepl
[08:25:51.721]                         restarts <- computeRestarts(cond)
[08:25:51.721]                         for (restart in restarts) {
[08:25:51.721]                           name <- restart$name
[08:25:51.721]                           if (is.null(name)) 
[08:25:51.721]                             next
[08:25:51.721]                           if (!grepl(pattern, name)) 
[08:25:51.721]                             next
[08:25:51.721]                           invokeRestart(restart)
[08:25:51.721]                           muffled <- TRUE
[08:25:51.721]                           break
[08:25:51.721]                         }
[08:25:51.721]                       }
[08:25:51.721]                     }
[08:25:51.721]                     invisible(muffled)
[08:25:51.721]                   }
[08:25:51.721]                   muffleCondition(cond)
[08:25:51.721]                 })
[08:25:51.721]             }))
[08:25:51.721]             future::FutureResult(value = ...future.value$value, 
[08:25:51.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.721]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.721]                     ...future.globalenv.names))
[08:25:51.721]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.721]         }, condition = base::local({
[08:25:51.721]             c <- base::c
[08:25:51.721]             inherits <- base::inherits
[08:25:51.721]             invokeRestart <- base::invokeRestart
[08:25:51.721]             length <- base::length
[08:25:51.721]             list <- base::list
[08:25:51.721]             seq.int <- base::seq.int
[08:25:51.721]             signalCondition <- base::signalCondition
[08:25:51.721]             sys.calls <- base::sys.calls
[08:25:51.721]             `[[` <- base::`[[`
[08:25:51.721]             `+` <- base::`+`
[08:25:51.721]             `<<-` <- base::`<<-`
[08:25:51.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.721]                   3L)]
[08:25:51.721]             }
[08:25:51.721]             function(cond) {
[08:25:51.721]                 is_error <- inherits(cond, "error")
[08:25:51.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.721]                   NULL)
[08:25:51.721]                 if (is_error) {
[08:25:51.721]                   sessionInformation <- function() {
[08:25:51.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.721]                       search = base::search(), system = base::Sys.info())
[08:25:51.721]                   }
[08:25:51.721]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.721]                     cond$call), session = sessionInformation(), 
[08:25:51.721]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.721]                   signalCondition(cond)
[08:25:51.721]                 }
[08:25:51.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.721]                 "immediateCondition"))) {
[08:25:51.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.721]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.721]                   if (TRUE && !signal) {
[08:25:51.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.721]                     {
[08:25:51.721]                       inherits <- base::inherits
[08:25:51.721]                       invokeRestart <- base::invokeRestart
[08:25:51.721]                       is.null <- base::is.null
[08:25:51.721]                       muffled <- FALSE
[08:25:51.721]                       if (inherits(cond, "message")) {
[08:25:51.721]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.721]                         if (muffled) 
[08:25:51.721]                           invokeRestart("muffleMessage")
[08:25:51.721]                       }
[08:25:51.721]                       else if (inherits(cond, "warning")) {
[08:25:51.721]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.721]                         if (muffled) 
[08:25:51.721]                           invokeRestart("muffleWarning")
[08:25:51.721]                       }
[08:25:51.721]                       else if (inherits(cond, "condition")) {
[08:25:51.721]                         if (!is.null(pattern)) {
[08:25:51.721]                           computeRestarts <- base::computeRestarts
[08:25:51.721]                           grepl <- base::grepl
[08:25:51.721]                           restarts <- computeRestarts(cond)
[08:25:51.721]                           for (restart in restarts) {
[08:25:51.721]                             name <- restart$name
[08:25:51.721]                             if (is.null(name)) 
[08:25:51.721]                               next
[08:25:51.721]                             if (!grepl(pattern, name)) 
[08:25:51.721]                               next
[08:25:51.721]                             invokeRestart(restart)
[08:25:51.721]                             muffled <- TRUE
[08:25:51.721]                             break
[08:25:51.721]                           }
[08:25:51.721]                         }
[08:25:51.721]                       }
[08:25:51.721]                       invisible(muffled)
[08:25:51.721]                     }
[08:25:51.721]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.721]                   }
[08:25:51.721]                 }
[08:25:51.721]                 else {
[08:25:51.721]                   if (TRUE) {
[08:25:51.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.721]                     {
[08:25:51.721]                       inherits <- base::inherits
[08:25:51.721]                       invokeRestart <- base::invokeRestart
[08:25:51.721]                       is.null <- base::is.null
[08:25:51.721]                       muffled <- FALSE
[08:25:51.721]                       if (inherits(cond, "message")) {
[08:25:51.721]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.721]                         if (muffled) 
[08:25:51.721]                           invokeRestart("muffleMessage")
[08:25:51.721]                       }
[08:25:51.721]                       else if (inherits(cond, "warning")) {
[08:25:51.721]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.721]                         if (muffled) 
[08:25:51.721]                           invokeRestart("muffleWarning")
[08:25:51.721]                       }
[08:25:51.721]                       else if (inherits(cond, "condition")) {
[08:25:51.721]                         if (!is.null(pattern)) {
[08:25:51.721]                           computeRestarts <- base::computeRestarts
[08:25:51.721]                           grepl <- base::grepl
[08:25:51.721]                           restarts <- computeRestarts(cond)
[08:25:51.721]                           for (restart in restarts) {
[08:25:51.721]                             name <- restart$name
[08:25:51.721]                             if (is.null(name)) 
[08:25:51.721]                               next
[08:25:51.721]                             if (!grepl(pattern, name)) 
[08:25:51.721]                               next
[08:25:51.721]                             invokeRestart(restart)
[08:25:51.721]                             muffled <- TRUE
[08:25:51.721]                             break
[08:25:51.721]                           }
[08:25:51.721]                         }
[08:25:51.721]                       }
[08:25:51.721]                       invisible(muffled)
[08:25:51.721]                     }
[08:25:51.721]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.721]                   }
[08:25:51.721]                 }
[08:25:51.721]             }
[08:25:51.721]         }))
[08:25:51.721]     }, error = function(ex) {
[08:25:51.721]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.721]                 ...future.rng), started = ...future.startTime, 
[08:25:51.721]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.721]             version = "1.8"), class = "FutureResult")
[08:25:51.721]     }, finally = {
[08:25:51.721]         if (!identical(...future.workdir, getwd())) 
[08:25:51.721]             setwd(...future.workdir)
[08:25:51.721]         {
[08:25:51.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.721]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.721]             }
[08:25:51.721]             base::options(...future.oldOptions)
[08:25:51.721]             if (.Platform$OS.type == "windows") {
[08:25:51.721]                 old_names <- names(...future.oldEnvVars)
[08:25:51.721]                 envs <- base::Sys.getenv()
[08:25:51.721]                 names <- names(envs)
[08:25:51.721]                 common <- intersect(names, old_names)
[08:25:51.721]                 added <- setdiff(names, old_names)
[08:25:51.721]                 removed <- setdiff(old_names, names)
[08:25:51.721]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.721]                   envs[common]]
[08:25:51.721]                 NAMES <- toupper(changed)
[08:25:51.721]                 args <- list()
[08:25:51.721]                 for (kk in seq_along(NAMES)) {
[08:25:51.721]                   name <- changed[[kk]]
[08:25:51.721]                   NAME <- NAMES[[kk]]
[08:25:51.721]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.721]                     next
[08:25:51.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.721]                 }
[08:25:51.721]                 NAMES <- toupper(added)
[08:25:51.721]                 for (kk in seq_along(NAMES)) {
[08:25:51.721]                   name <- added[[kk]]
[08:25:51.721]                   NAME <- NAMES[[kk]]
[08:25:51.721]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.721]                     next
[08:25:51.721]                   args[[name]] <- ""
[08:25:51.721]                 }
[08:25:51.721]                 NAMES <- toupper(removed)
[08:25:51.721]                 for (kk in seq_along(NAMES)) {
[08:25:51.721]                   name <- removed[[kk]]
[08:25:51.721]                   NAME <- NAMES[[kk]]
[08:25:51.721]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.721]                     next
[08:25:51.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.721]                 }
[08:25:51.721]                 if (length(args) > 0) 
[08:25:51.721]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.721]             }
[08:25:51.721]             else {
[08:25:51.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.721]             }
[08:25:51.721]             {
[08:25:51.721]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.721]                   0L) {
[08:25:51.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.721]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.721]                   base::options(opts)
[08:25:51.721]                 }
[08:25:51.721]                 {
[08:25:51.721]                   {
[08:25:51.721]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.721]                     NULL
[08:25:51.721]                   }
[08:25:51.721]                   options(future.plan = NULL)
[08:25:51.721]                   if (is.na(NA_character_)) 
[08:25:51.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.721]                     .init = FALSE)
[08:25:51.721]                 }
[08:25:51.721]             }
[08:25:51.721]         }
[08:25:51.721]     })
[08:25:51.721]     if (TRUE) {
[08:25:51.721]         base::sink(type = "output", split = FALSE)
[08:25:51.721]         if (TRUE) {
[08:25:51.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.721]         }
[08:25:51.721]         else {
[08:25:51.721]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.721]         }
[08:25:51.721]         base::close(...future.stdout)
[08:25:51.721]         ...future.stdout <- NULL
[08:25:51.721]     }
[08:25:51.721]     ...future.result$conditions <- ...future.conditions
[08:25:51.721]     ...future.result$finished <- base::Sys.time()
[08:25:51.721]     ...future.result
[08:25:51.721] }
[08:25:51.724] Exporting 5 global objects (715 bytes) to cluster node #2 ...
[08:25:51.724] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[08:25:51.724] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[08:25:51.724] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:51.725] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.725] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #2 ...
[08:25:51.725] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #2 ... DONE
[08:25:51.725] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:51.726] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.726] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:51.726] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.726] Exporting 5 global objects (715 bytes) to cluster node #2 ... DONE
[08:25:51.727] MultisessionFuture started
[08:25:51.727] - Launch lazy future ... done
[08:25:51.727] run() for ‘MultisessionFuture’ ... done
[08:25:51.727] Created future:
[08:25:51.727] MultisessionFuture:
[08:25:51.727] Label: ‘future_mapply-2’
[08:25:51.727] Expression:
[08:25:51.727] {
[08:25:51.727]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.727]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:51.727]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.727]         on.exit(options(oopts), add = TRUE)
[08:25:51.727]     }
[08:25:51.727]     {
[08:25:51.727]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.727]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:51.727]         do.call(mapply, args = args)
[08:25:51.727]     }
[08:25:51.727] }
[08:25:51.727] Lazy evaluation: FALSE
[08:25:51.727] Asynchronous evaluation: TRUE
[08:25:51.727] Local evaluation: TRUE
[08:25:51.727] Environment: R_GlobalEnv
[08:25:51.727] Capture standard output: TRUE
[08:25:51.727] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:51.727] Globals: 5 objects totaling 265 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:51.727] Packages: <none>
[08:25:51.727] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:51.727] Resolved: FALSE
[08:25:51.727] Value: <not collected>
[08:25:51.727] Conditions captured: <none>
[08:25:51.727] Early signaling: FALSE
[08:25:51.727] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:51.727] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.739] Chunk #2 of 2 ... DONE
[08:25:51.739] Launching 2 futures (chunks) ... DONE
[08:25:51.739] Resolving 2 futures (chunks) ...
[08:25:51.739] resolve() on list ...
[08:25:51.739]  recursive: 0
[08:25:51.739]  length: 2
[08:25:51.739] 
[08:25:51.740] receiveMessageFromWorker() for ClusterFuture ...
[08:25:51.740] - Validating connection of MultisessionFuture
[08:25:51.740] - received message: FutureResult
[08:25:51.740] - Received FutureResult
[08:25:51.740] - Erased future from FutureRegistry
[08:25:51.741] result() for ClusterFuture ...
[08:25:51.741] - result already collected: FutureResult
[08:25:51.741] result() for ClusterFuture ... done
[08:25:51.741] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:51.741] Future #1
[08:25:51.741] result() for ClusterFuture ...
[08:25:51.741] - result already collected: FutureResult
[08:25:51.741] result() for ClusterFuture ... done
[08:25:51.741] result() for ClusterFuture ...
[08:25:51.741] - result already collected: FutureResult
[08:25:51.741] result() for ClusterFuture ... done
[08:25:51.742] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:51.742] - nx: 2
[08:25:51.742] - relay: TRUE
[08:25:51.742] - stdout: TRUE
[08:25:51.742] - signal: TRUE
[08:25:51.742] - resignal: FALSE
[08:25:51.742] - force: TRUE
[08:25:51.742] - relayed: [n=2] FALSE, FALSE
[08:25:51.742] - queued futures: [n=2] FALSE, FALSE
[08:25:51.742]  - until=1
[08:25:51.742]  - relaying element #1
[08:25:51.742] result() for ClusterFuture ...
[08:25:51.743] - result already collected: FutureResult
[08:25:51.743] result() for ClusterFuture ... done
[08:25:51.743] result() for ClusterFuture ...
[08:25:51.743] - result already collected: FutureResult
[08:25:51.743] result() for ClusterFuture ... done
[08:25:51.743] result() for ClusterFuture ...
[08:25:51.743] - result already collected: FutureResult
[08:25:51.743] result() for ClusterFuture ... done
[08:25:51.743] result() for ClusterFuture ...
[08:25:51.743] - result already collected: FutureResult
[08:25:51.743] result() for ClusterFuture ... done
[08:25:51.744] - relayed: [n=2] TRUE, FALSE
[08:25:51.744] - queued futures: [n=2] TRUE, FALSE
[08:25:51.744] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:51.744]  length: 1 (resolved future 1)
[08:25:51.769] receiveMessageFromWorker() for ClusterFuture ...
[08:25:51.769] - Validating connection of MultisessionFuture
[08:25:51.770] - received message: FutureResult
[08:25:51.770] - Received FutureResult
[08:25:51.770] - Erased future from FutureRegistry
[08:25:51.770] result() for ClusterFuture ...
[08:25:51.770] - result already collected: FutureResult
[08:25:51.770] result() for ClusterFuture ... done
[08:25:51.770] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:51.770] Future #2
[08:25:51.770] result() for ClusterFuture ...
[08:25:51.770] - result already collected: FutureResult
[08:25:51.771] result() for ClusterFuture ... done
[08:25:51.771] result() for ClusterFuture ...
[08:25:51.771] - result already collected: FutureResult
[08:25:51.771] result() for ClusterFuture ... done
[08:25:51.771] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:51.771] - nx: 2
[08:25:51.771] - relay: TRUE
[08:25:51.771] - stdout: TRUE
[08:25:51.771] - signal: TRUE
[08:25:51.771] - resignal: FALSE
[08:25:51.771] - force: TRUE
[08:25:51.771] - relayed: [n=2] TRUE, FALSE
[08:25:51.772] - queued futures: [n=2] TRUE, FALSE
[08:25:51.772]  - until=2
[08:25:51.772]  - relaying element #2
[08:25:51.772] result() for ClusterFuture ...
[08:25:51.772] - result already collected: FutureResult
[08:25:51.772] result() for ClusterFuture ... done
[08:25:51.772] result() for ClusterFuture ...
[08:25:51.772] - result already collected: FutureResult
[08:25:51.772] result() for ClusterFuture ... done
[08:25:51.772] result() for ClusterFuture ...
[08:25:51.773] - result already collected: FutureResult
[08:25:51.773] result() for ClusterFuture ... done
[08:25:51.773] result() for ClusterFuture ...
[08:25:51.773] - result already collected: FutureResult
[08:25:51.773] result() for ClusterFuture ... done
[08:25:51.773] - relayed: [n=2] TRUE, TRUE
[08:25:51.773] - queued futures: [n=2] TRUE, TRUE
[08:25:51.775] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:51.775]  length: 0 (resolved future 2)
[08:25:51.775] Relaying remaining futures
[08:25:51.775] signalConditionsASAP(NULL, pos=0) ...
[08:25:51.775] - nx: 2
[08:25:51.776] - relay: TRUE
[08:25:51.776] - stdout: TRUE
[08:25:51.776] - signal: TRUE
[08:25:51.776] - resignal: FALSE
[08:25:51.776] - force: TRUE
[08:25:51.776] - relayed: [n=2] TRUE, TRUE
[08:25:51.776] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:51.776] - relayed: [n=2] TRUE, TRUE
[08:25:51.776] - queued futures: [n=2] TRUE, TRUE
[08:25:51.776] signalConditionsASAP(NULL, pos=0) ... done
[08:25:51.776] resolve() on list ... DONE
[08:25:51.776] result() for ClusterFuture ...
[08:25:51.777] - result already collected: FutureResult
[08:25:51.777] result() for ClusterFuture ... done
[08:25:51.777] result() for ClusterFuture ...
[08:25:51.777] - result already collected: FutureResult
[08:25:51.777] result() for ClusterFuture ... done
[08:25:51.777] result() for ClusterFuture ...
[08:25:51.777] - result already collected: FutureResult
[08:25:51.777] result() for ClusterFuture ... done
[08:25:51.777] result() for ClusterFuture ...
[08:25:51.777] - result already collected: FutureResult
[08:25:51.777] result() for ClusterFuture ... done
[08:25:51.778]  - Number of value chunks collected: 2
[08:25:51.778] Resolving 2 futures (chunks) ... DONE
[08:25:51.778] Reducing values from 2 chunks ...
[08:25:51.778]  - Number of values collected after concatenation: 4
[08:25:51.778]  - Number of values expected: 4
[08:25:51.778] Reducing values from 2 chunks ... DONE
[08:25:51.778] future_mapply() ... DONE
[08:25:51.778] future_mapply() ...
[08:25:51.780] Number of chunks: 2
[08:25:51.780] getGlobalsAndPackagesXApply() ...
[08:25:51.780]  - future.globals: TRUE
[08:25:51.780] getGlobalsAndPackages() ...
[08:25:51.780] Searching for globals...
[08:25:51.781] - globals found: [1] ‘FUN’
[08:25:51.781] Searching for globals ... DONE
[08:25:51.781] Resolving globals: FALSE
[08:25:51.781] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:51.782] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:51.782] - globals: [1] ‘FUN’
[08:25:51.782] 
[08:25:51.782] getGlobalsAndPackages() ... DONE
[08:25:51.782]  - globals found/used: [n=1] ‘FUN’
[08:25:51.782]  - needed namespaces: [n=0] 
[08:25:51.782] Finding globals ... DONE
[08:25:51.783] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:51.783] List of 2
[08:25:51.783]  $ ...future.FUN:function (x, ...)  
[08:25:51.783]  $ MoreArgs     :List of 1
[08:25:51.783]   ..$ x: num 42
[08:25:51.783]  - attr(*, "where")=List of 2
[08:25:51.783]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:51.783]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:51.783]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:51.783]  - attr(*, "resolved")= logi FALSE
[08:25:51.783]  - attr(*, "total_size")= num NA
[08:25:51.785] Packages to be attached in all futures: [n=0] 
[08:25:51.785] getGlobalsAndPackagesXApply() ... DONE
[08:25:51.786] Number of futures (= number of chunks): 2
[08:25:51.786] Launching 2 futures (chunks) ...
[08:25:51.786] Chunk #1 of 2 ...
[08:25:51.786]  - Finding globals in '...' for chunk #1 ...
[08:25:51.786] getGlobalsAndPackages() ...
[08:25:51.786] Searching for globals...
[08:25:51.786] 
[08:25:51.787] Searching for globals ... DONE
[08:25:51.787] - globals: [0] <none>
[08:25:51.787] getGlobalsAndPackages() ... DONE
[08:25:51.787]    + additional globals found: [n=0] 
[08:25:51.787]    + additional namespaces needed: [n=0] 
[08:25:51.787]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:51.787]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:51.787]  - seeds: <none>
[08:25:51.787]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.787] getGlobalsAndPackages() ...
[08:25:51.787] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.788] Resolving globals: FALSE
[08:25:51.788] The total size of the 5 globals is 286 bytes (286 bytes)
[08:25:51.788] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[08:25:51.788] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.789] 
[08:25:51.789] getGlobalsAndPackages() ... DONE
[08:25:51.789] run() for ‘Future’ ...
[08:25:51.789] - state: ‘created’
[08:25:51.789] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:51.803] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:51.803]   - Field: ‘node’
[08:25:51.803]   - Field: ‘label’
[08:25:51.803]   - Field: ‘local’
[08:25:51.803]   - Field: ‘owner’
[08:25:51.803]   - Field: ‘envir’
[08:25:51.803]   - Field: ‘workers’
[08:25:51.803]   - Field: ‘packages’
[08:25:51.803]   - Field: ‘gc’
[08:25:51.804]   - Field: ‘conditions’
[08:25:51.804]   - Field: ‘persistent’
[08:25:51.804]   - Field: ‘expr’
[08:25:51.804]   - Field: ‘uuid’
[08:25:51.804]   - Field: ‘seed’
[08:25:51.804]   - Field: ‘version’
[08:25:51.804]   - Field: ‘result’
[08:25:51.804]   - Field: ‘asynchronous’
[08:25:51.804]   - Field: ‘calls’
[08:25:51.804]   - Field: ‘globals’
[08:25:51.804]   - Field: ‘stdout’
[08:25:51.804]   - Field: ‘earlySignal’
[08:25:51.805]   - Field: ‘lazy’
[08:25:51.805]   - Field: ‘state’
[08:25:51.805] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:51.805] - Launch lazy future ...
[08:25:51.805] Packages needed by the future expression (n = 0): <none>
[08:25:51.805] Packages needed by future strategies (n = 0): <none>
[08:25:51.806] {
[08:25:51.806]     {
[08:25:51.806]         {
[08:25:51.806]             ...future.startTime <- base::Sys.time()
[08:25:51.806]             {
[08:25:51.806]                 {
[08:25:51.806]                   {
[08:25:51.806]                     {
[08:25:51.806]                       base::local({
[08:25:51.806]                         has_future <- base::requireNamespace("future", 
[08:25:51.806]                           quietly = TRUE)
[08:25:51.806]                         if (has_future) {
[08:25:51.806]                           ns <- base::getNamespace("future")
[08:25:51.806]                           version <- ns[[".package"]][["version"]]
[08:25:51.806]                           if (is.null(version)) 
[08:25:51.806]                             version <- utils::packageVersion("future")
[08:25:51.806]                         }
[08:25:51.806]                         else {
[08:25:51.806]                           version <- NULL
[08:25:51.806]                         }
[08:25:51.806]                         if (!has_future || version < "1.8.0") {
[08:25:51.806]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.806]                             "", base::R.version$version.string), 
[08:25:51.806]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.806]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.806]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.806]                               "release", "version")], collapse = " "), 
[08:25:51.806]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.806]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.806]                             info)
[08:25:51.806]                           info <- base::paste(info, collapse = "; ")
[08:25:51.806]                           if (!has_future) {
[08:25:51.806]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.806]                               info)
[08:25:51.806]                           }
[08:25:51.806]                           else {
[08:25:51.806]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.806]                               info, version)
[08:25:51.806]                           }
[08:25:51.806]                           base::stop(msg)
[08:25:51.806]                         }
[08:25:51.806]                       })
[08:25:51.806]                     }
[08:25:51.806]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.806]                     base::options(mc.cores = 1L)
[08:25:51.806]                   }
[08:25:51.806]                   ...future.strategy.old <- future::plan("list")
[08:25:51.806]                   options(future.plan = NULL)
[08:25:51.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.806]                 }
[08:25:51.806]                 ...future.workdir <- getwd()
[08:25:51.806]             }
[08:25:51.806]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.806]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.806]         }
[08:25:51.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.806]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:51.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.806]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.806]             base::names(...future.oldOptions))
[08:25:51.806]     }
[08:25:51.806]     if (FALSE) {
[08:25:51.806]     }
[08:25:51.806]     else {
[08:25:51.806]         if (TRUE) {
[08:25:51.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.806]                 open = "w")
[08:25:51.806]         }
[08:25:51.806]         else {
[08:25:51.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.806]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.806]         }
[08:25:51.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.806]             base::sink(type = "output", split = FALSE)
[08:25:51.806]             base::close(...future.stdout)
[08:25:51.806]         }, add = TRUE)
[08:25:51.806]     }
[08:25:51.806]     ...future.frame <- base::sys.nframe()
[08:25:51.806]     ...future.conditions <- base::list()
[08:25:51.806]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.806]     if (FALSE) {
[08:25:51.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.806]     }
[08:25:51.806]     ...future.result <- base::tryCatch({
[08:25:51.806]         base::withCallingHandlers({
[08:25:51.806]             ...future.value <- base::withVisible(base::local({
[08:25:51.806]                 ...future.makeSendCondition <- base::local({
[08:25:51.806]                   sendCondition <- NULL
[08:25:51.806]                   function(frame = 1L) {
[08:25:51.806]                     if (is.function(sendCondition)) 
[08:25:51.806]                       return(sendCondition)
[08:25:51.806]                     ns <- getNamespace("parallel")
[08:25:51.806]                     if (exists("sendData", mode = "function", 
[08:25:51.806]                       envir = ns)) {
[08:25:51.806]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.806]                         envir = ns)
[08:25:51.806]                       envir <- sys.frame(frame)
[08:25:51.806]                       master <- NULL
[08:25:51.806]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.806]                         !identical(envir, emptyenv())) {
[08:25:51.806]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.806]                           inherits = FALSE)) {
[08:25:51.806]                           master <- get("master", mode = "list", 
[08:25:51.806]                             envir = envir, inherits = FALSE)
[08:25:51.806]                           if (inherits(master, c("SOCKnode", 
[08:25:51.806]                             "SOCK0node"))) {
[08:25:51.806]                             sendCondition <<- function(cond) {
[08:25:51.806]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.806]                                 success = TRUE)
[08:25:51.806]                               parallel_sendData(master, data)
[08:25:51.806]                             }
[08:25:51.806]                             return(sendCondition)
[08:25:51.806]                           }
[08:25:51.806]                         }
[08:25:51.806]                         frame <- frame + 1L
[08:25:51.806]                         envir <- sys.frame(frame)
[08:25:51.806]                       }
[08:25:51.806]                     }
[08:25:51.806]                     sendCondition <<- function(cond) NULL
[08:25:51.806]                   }
[08:25:51.806]                 })
[08:25:51.806]                 withCallingHandlers({
[08:25:51.806]                   {
[08:25:51.806]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.806]                     if (!identical(...future.globals.maxSize.org, 
[08:25:51.806]                       ...future.globals.maxSize)) {
[08:25:51.806]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.806]                       on.exit(options(oopts), add = TRUE)
[08:25:51.806]                     }
[08:25:51.806]                     {
[08:25:51.806]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.806]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:51.806]                         USE.NAMES = FALSE)
[08:25:51.806]                       do.call(mapply, args = args)
[08:25:51.806]                     }
[08:25:51.806]                   }
[08:25:51.806]                 }, immediateCondition = function(cond) {
[08:25:51.806]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.806]                   sendCondition(cond)
[08:25:51.806]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.806]                   {
[08:25:51.806]                     inherits <- base::inherits
[08:25:51.806]                     invokeRestart <- base::invokeRestart
[08:25:51.806]                     is.null <- base::is.null
[08:25:51.806]                     muffled <- FALSE
[08:25:51.806]                     if (inherits(cond, "message")) {
[08:25:51.806]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.806]                       if (muffled) 
[08:25:51.806]                         invokeRestart("muffleMessage")
[08:25:51.806]                     }
[08:25:51.806]                     else if (inherits(cond, "warning")) {
[08:25:51.806]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.806]                       if (muffled) 
[08:25:51.806]                         invokeRestart("muffleWarning")
[08:25:51.806]                     }
[08:25:51.806]                     else if (inherits(cond, "condition")) {
[08:25:51.806]                       if (!is.null(pattern)) {
[08:25:51.806]                         computeRestarts <- base::computeRestarts
[08:25:51.806]                         grepl <- base::grepl
[08:25:51.806]                         restarts <- computeRestarts(cond)
[08:25:51.806]                         for (restart in restarts) {
[08:25:51.806]                           name <- restart$name
[08:25:51.806]                           if (is.null(name)) 
[08:25:51.806]                             next
[08:25:51.806]                           if (!grepl(pattern, name)) 
[08:25:51.806]                             next
[08:25:51.806]                           invokeRestart(restart)
[08:25:51.806]                           muffled <- TRUE
[08:25:51.806]                           break
[08:25:51.806]                         }
[08:25:51.806]                       }
[08:25:51.806]                     }
[08:25:51.806]                     invisible(muffled)
[08:25:51.806]                   }
[08:25:51.806]                   muffleCondition(cond)
[08:25:51.806]                 })
[08:25:51.806]             }))
[08:25:51.806]             future::FutureResult(value = ...future.value$value, 
[08:25:51.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.806]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.806]                     ...future.globalenv.names))
[08:25:51.806]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.806]         }, condition = base::local({
[08:25:51.806]             c <- base::c
[08:25:51.806]             inherits <- base::inherits
[08:25:51.806]             invokeRestart <- base::invokeRestart
[08:25:51.806]             length <- base::length
[08:25:51.806]             list <- base::list
[08:25:51.806]             seq.int <- base::seq.int
[08:25:51.806]             signalCondition <- base::signalCondition
[08:25:51.806]             sys.calls <- base::sys.calls
[08:25:51.806]             `[[` <- base::`[[`
[08:25:51.806]             `+` <- base::`+`
[08:25:51.806]             `<<-` <- base::`<<-`
[08:25:51.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.806]                   3L)]
[08:25:51.806]             }
[08:25:51.806]             function(cond) {
[08:25:51.806]                 is_error <- inherits(cond, "error")
[08:25:51.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.806]                   NULL)
[08:25:51.806]                 if (is_error) {
[08:25:51.806]                   sessionInformation <- function() {
[08:25:51.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.806]                       search = base::search(), system = base::Sys.info())
[08:25:51.806]                   }
[08:25:51.806]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.806]                     cond$call), session = sessionInformation(), 
[08:25:51.806]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.806]                   signalCondition(cond)
[08:25:51.806]                 }
[08:25:51.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.806]                 "immediateCondition"))) {
[08:25:51.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.806]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.806]                   if (TRUE && !signal) {
[08:25:51.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.806]                     {
[08:25:51.806]                       inherits <- base::inherits
[08:25:51.806]                       invokeRestart <- base::invokeRestart
[08:25:51.806]                       is.null <- base::is.null
[08:25:51.806]                       muffled <- FALSE
[08:25:51.806]                       if (inherits(cond, "message")) {
[08:25:51.806]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.806]                         if (muffled) 
[08:25:51.806]                           invokeRestart("muffleMessage")
[08:25:51.806]                       }
[08:25:51.806]                       else if (inherits(cond, "warning")) {
[08:25:51.806]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.806]                         if (muffled) 
[08:25:51.806]                           invokeRestart("muffleWarning")
[08:25:51.806]                       }
[08:25:51.806]                       else if (inherits(cond, "condition")) {
[08:25:51.806]                         if (!is.null(pattern)) {
[08:25:51.806]                           computeRestarts <- base::computeRestarts
[08:25:51.806]                           grepl <- base::grepl
[08:25:51.806]                           restarts <- computeRestarts(cond)
[08:25:51.806]                           for (restart in restarts) {
[08:25:51.806]                             name <- restart$name
[08:25:51.806]                             if (is.null(name)) 
[08:25:51.806]                               next
[08:25:51.806]                             if (!grepl(pattern, name)) 
[08:25:51.806]                               next
[08:25:51.806]                             invokeRestart(restart)
[08:25:51.806]                             muffled <- TRUE
[08:25:51.806]                             break
[08:25:51.806]                           }
[08:25:51.806]                         }
[08:25:51.806]                       }
[08:25:51.806]                       invisible(muffled)
[08:25:51.806]                     }
[08:25:51.806]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.806]                   }
[08:25:51.806]                 }
[08:25:51.806]                 else {
[08:25:51.806]                   if (TRUE) {
[08:25:51.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.806]                     {
[08:25:51.806]                       inherits <- base::inherits
[08:25:51.806]                       invokeRestart <- base::invokeRestart
[08:25:51.806]                       is.null <- base::is.null
[08:25:51.806]                       muffled <- FALSE
[08:25:51.806]                       if (inherits(cond, "message")) {
[08:25:51.806]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.806]                         if (muffled) 
[08:25:51.806]                           invokeRestart("muffleMessage")
[08:25:51.806]                       }
[08:25:51.806]                       else if (inherits(cond, "warning")) {
[08:25:51.806]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.806]                         if (muffled) 
[08:25:51.806]                           invokeRestart("muffleWarning")
[08:25:51.806]                       }
[08:25:51.806]                       else if (inherits(cond, "condition")) {
[08:25:51.806]                         if (!is.null(pattern)) {
[08:25:51.806]                           computeRestarts <- base::computeRestarts
[08:25:51.806]                           grepl <- base::grepl
[08:25:51.806]                           restarts <- computeRestarts(cond)
[08:25:51.806]                           for (restart in restarts) {
[08:25:51.806]                             name <- restart$name
[08:25:51.806]                             if (is.null(name)) 
[08:25:51.806]                               next
[08:25:51.806]                             if (!grepl(pattern, name)) 
[08:25:51.806]                               next
[08:25:51.806]                             invokeRestart(restart)
[08:25:51.806]                             muffled <- TRUE
[08:25:51.806]                             break
[08:25:51.806]                           }
[08:25:51.806]                         }
[08:25:51.806]                       }
[08:25:51.806]                       invisible(muffled)
[08:25:51.806]                     }
[08:25:51.806]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.806]                   }
[08:25:51.806]                 }
[08:25:51.806]             }
[08:25:51.806]         }))
[08:25:51.806]     }, error = function(ex) {
[08:25:51.806]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.806]                 ...future.rng), started = ...future.startTime, 
[08:25:51.806]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.806]             version = "1.8"), class = "FutureResult")
[08:25:51.806]     }, finally = {
[08:25:51.806]         if (!identical(...future.workdir, getwd())) 
[08:25:51.806]             setwd(...future.workdir)
[08:25:51.806]         {
[08:25:51.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.806]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.806]             }
[08:25:51.806]             base::options(...future.oldOptions)
[08:25:51.806]             if (.Platform$OS.type == "windows") {
[08:25:51.806]                 old_names <- names(...future.oldEnvVars)
[08:25:51.806]                 envs <- base::Sys.getenv()
[08:25:51.806]                 names <- names(envs)
[08:25:51.806]                 common <- intersect(names, old_names)
[08:25:51.806]                 added <- setdiff(names, old_names)
[08:25:51.806]                 removed <- setdiff(old_names, names)
[08:25:51.806]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.806]                   envs[common]]
[08:25:51.806]                 NAMES <- toupper(changed)
[08:25:51.806]                 args <- list()
[08:25:51.806]                 for (kk in seq_along(NAMES)) {
[08:25:51.806]                   name <- changed[[kk]]
[08:25:51.806]                   NAME <- NAMES[[kk]]
[08:25:51.806]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.806]                     next
[08:25:51.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.806]                 }
[08:25:51.806]                 NAMES <- toupper(added)
[08:25:51.806]                 for (kk in seq_along(NAMES)) {
[08:25:51.806]                   name <- added[[kk]]
[08:25:51.806]                   NAME <- NAMES[[kk]]
[08:25:51.806]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.806]                     next
[08:25:51.806]                   args[[name]] <- ""
[08:25:51.806]                 }
[08:25:51.806]                 NAMES <- toupper(removed)
[08:25:51.806]                 for (kk in seq_along(NAMES)) {
[08:25:51.806]                   name <- removed[[kk]]
[08:25:51.806]                   NAME <- NAMES[[kk]]
[08:25:51.806]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.806]                     next
[08:25:51.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.806]                 }
[08:25:51.806]                 if (length(args) > 0) 
[08:25:51.806]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.806]             }
[08:25:51.806]             else {
[08:25:51.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.806]             }
[08:25:51.806]             {
[08:25:51.806]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.806]                   0L) {
[08:25:51.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.806]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.806]                   base::options(opts)
[08:25:51.806]                 }
[08:25:51.806]                 {
[08:25:51.806]                   {
[08:25:51.806]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.806]                     NULL
[08:25:51.806]                   }
[08:25:51.806]                   options(future.plan = NULL)
[08:25:51.806]                   if (is.na(NA_character_)) 
[08:25:51.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.806]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.806]                     .init = FALSE)
[08:25:51.806]                 }
[08:25:51.806]             }
[08:25:51.806]         }
[08:25:51.806]     })
[08:25:51.806]     if (TRUE) {
[08:25:51.806]         base::sink(type = "output", split = FALSE)
[08:25:51.806]         if (TRUE) {
[08:25:51.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.806]         }
[08:25:51.806]         else {
[08:25:51.806]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.806]         }
[08:25:51.806]         base::close(...future.stdout)
[08:25:51.806]         ...future.stdout <- NULL
[08:25:51.806]     }
[08:25:51.806]     ...future.result$conditions <- ...future.conditions
[08:25:51.806]     ...future.result$finished <- base::Sys.time()
[08:25:51.806]     ...future.result
[08:25:51.806] }
[08:25:51.809] Exporting 5 global objects (723 bytes) to cluster node #1 ...
[08:25:51.809] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[08:25:51.809] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[08:25:51.809] Exporting ‘MoreArgs’ (89 bytes) to cluster node #1 ...
[08:25:51.810] Exporting ‘MoreArgs’ (89 bytes) to cluster node #1 ... DONE
[08:25:51.810] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #1 ...
[08:25:51.810] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #1 ... DONE
[08:25:51.810] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:51.811] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.811] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:51.811] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.811] Exporting 5 global objects (723 bytes) to cluster node #1 ... DONE
[08:25:51.812] MultisessionFuture started
[08:25:51.812] - Launch lazy future ... done
[08:25:51.812] run() for ‘MultisessionFuture’ ... done
[08:25:51.812] Created future:
[08:25:51.812] MultisessionFuture:
[08:25:51.812] Label: ‘future_mapply-1’
[08:25:51.812] Expression:
[08:25:51.812] {
[08:25:51.812]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.812]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:51.812]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.812]         on.exit(options(oopts), add = TRUE)
[08:25:51.812]     }
[08:25:51.812]     {
[08:25:51.812]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.812]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:51.812]         do.call(mapply, args = args)
[08:25:51.812]     }
[08:25:51.812] }
[08:25:51.812] Lazy evaluation: FALSE
[08:25:51.812] Asynchronous evaluation: TRUE
[08:25:51.812] Local evaluation: TRUE
[08:25:51.812] Environment: R_GlobalEnv
[08:25:51.812] Capture standard output: TRUE
[08:25:51.812] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:51.812] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:51.812] Packages: <none>
[08:25:51.812] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:51.812] Resolved: FALSE
[08:25:51.812] Value: <not collected>
[08:25:51.812] Conditions captured: <none>
[08:25:51.812] Early signaling: FALSE
[08:25:51.812] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:51.812] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.823] Chunk #1 of 2 ... DONE
[08:25:51.823] Chunk #2 of 2 ...
[08:25:51.824]  - Finding globals in '...' for chunk #2 ...
[08:25:51.824] getGlobalsAndPackages() ...
[08:25:51.824] Searching for globals...
[08:25:51.824] 
[08:25:51.824] Searching for globals ... DONE
[08:25:51.824] - globals: [0] <none>
[08:25:51.824] getGlobalsAndPackages() ... DONE
[08:25:51.825]    + additional globals found: [n=0] 
[08:25:51.825]    + additional namespaces needed: [n=0] 
[08:25:51.825]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:51.825]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:51.825]  - seeds: <none>
[08:25:51.825]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.825] getGlobalsAndPackages() ...
[08:25:51.825] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.825] Resolving globals: FALSE
[08:25:51.826] The total size of the 5 globals is 286 bytes (286 bytes)
[08:25:51.826] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 286 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (109 bytes of class ‘list’), ‘MoreArgs’ (89 bytes of class ‘list’) and ‘...future.FUN’ (34 bytes of class ‘function’)
[08:25:51.826] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.826] 
[08:25:51.826] getGlobalsAndPackages() ... DONE
[08:25:51.827] run() for ‘Future’ ...
[08:25:51.827] - state: ‘created’
[08:25:51.827] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:51.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.841] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:51.841]   - Field: ‘node’
[08:25:51.841]   - Field: ‘label’
[08:25:51.841]   - Field: ‘local’
[08:25:51.841]   - Field: ‘owner’
[08:25:51.841]   - Field: ‘envir’
[08:25:51.841]   - Field: ‘workers’
[08:25:51.841]   - Field: ‘packages’
[08:25:51.841]   - Field: ‘gc’
[08:25:51.841]   - Field: ‘conditions’
[08:25:51.841]   - Field: ‘persistent’
[08:25:51.842]   - Field: ‘expr’
[08:25:51.842]   - Field: ‘uuid’
[08:25:51.842]   - Field: ‘seed’
[08:25:51.842]   - Field: ‘version’
[08:25:51.842]   - Field: ‘result’
[08:25:51.842]   - Field: ‘asynchronous’
[08:25:51.842]   - Field: ‘calls’
[08:25:51.842]   - Field: ‘globals’
[08:25:51.842]   - Field: ‘stdout’
[08:25:51.842]   - Field: ‘earlySignal’
[08:25:51.842]   - Field: ‘lazy’
[08:25:51.842]   - Field: ‘state’
[08:25:51.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:51.843] - Launch lazy future ...
[08:25:51.843] Packages needed by the future expression (n = 0): <none>
[08:25:51.843] Packages needed by future strategies (n = 0): <none>
[08:25:51.843] {
[08:25:51.843]     {
[08:25:51.843]         {
[08:25:51.843]             ...future.startTime <- base::Sys.time()
[08:25:51.843]             {
[08:25:51.843]                 {
[08:25:51.843]                   {
[08:25:51.843]                     {
[08:25:51.843]                       base::local({
[08:25:51.843]                         has_future <- base::requireNamespace("future", 
[08:25:51.843]                           quietly = TRUE)
[08:25:51.843]                         if (has_future) {
[08:25:51.843]                           ns <- base::getNamespace("future")
[08:25:51.843]                           version <- ns[[".package"]][["version"]]
[08:25:51.843]                           if (is.null(version)) 
[08:25:51.843]                             version <- utils::packageVersion("future")
[08:25:51.843]                         }
[08:25:51.843]                         else {
[08:25:51.843]                           version <- NULL
[08:25:51.843]                         }
[08:25:51.843]                         if (!has_future || version < "1.8.0") {
[08:25:51.843]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.843]                             "", base::R.version$version.string), 
[08:25:51.843]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.843]                               "release", "version")], collapse = " "), 
[08:25:51.843]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.843]                             info)
[08:25:51.843]                           info <- base::paste(info, collapse = "; ")
[08:25:51.843]                           if (!has_future) {
[08:25:51.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.843]                               info)
[08:25:51.843]                           }
[08:25:51.843]                           else {
[08:25:51.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.843]                               info, version)
[08:25:51.843]                           }
[08:25:51.843]                           base::stop(msg)
[08:25:51.843]                         }
[08:25:51.843]                       })
[08:25:51.843]                     }
[08:25:51.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.843]                     base::options(mc.cores = 1L)
[08:25:51.843]                   }
[08:25:51.843]                   ...future.strategy.old <- future::plan("list")
[08:25:51.843]                   options(future.plan = NULL)
[08:25:51.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.843]                 }
[08:25:51.843]                 ...future.workdir <- getwd()
[08:25:51.843]             }
[08:25:51.843]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.843]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.843]         }
[08:25:51.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.843]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:51.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.843]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.843]             base::names(...future.oldOptions))
[08:25:51.843]     }
[08:25:51.843]     if (FALSE) {
[08:25:51.843]     }
[08:25:51.843]     else {
[08:25:51.843]         if (TRUE) {
[08:25:51.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.843]                 open = "w")
[08:25:51.843]         }
[08:25:51.843]         else {
[08:25:51.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.843]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.843]         }
[08:25:51.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.843]             base::sink(type = "output", split = FALSE)
[08:25:51.843]             base::close(...future.stdout)
[08:25:51.843]         }, add = TRUE)
[08:25:51.843]     }
[08:25:51.843]     ...future.frame <- base::sys.nframe()
[08:25:51.843]     ...future.conditions <- base::list()
[08:25:51.843]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.843]     if (FALSE) {
[08:25:51.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.843]     }
[08:25:51.843]     ...future.result <- base::tryCatch({
[08:25:51.843]         base::withCallingHandlers({
[08:25:51.843]             ...future.value <- base::withVisible(base::local({
[08:25:51.843]                 ...future.makeSendCondition <- base::local({
[08:25:51.843]                   sendCondition <- NULL
[08:25:51.843]                   function(frame = 1L) {
[08:25:51.843]                     if (is.function(sendCondition)) 
[08:25:51.843]                       return(sendCondition)
[08:25:51.843]                     ns <- getNamespace("parallel")
[08:25:51.843]                     if (exists("sendData", mode = "function", 
[08:25:51.843]                       envir = ns)) {
[08:25:51.843]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.843]                         envir = ns)
[08:25:51.843]                       envir <- sys.frame(frame)
[08:25:51.843]                       master <- NULL
[08:25:51.843]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.843]                         !identical(envir, emptyenv())) {
[08:25:51.843]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.843]                           inherits = FALSE)) {
[08:25:51.843]                           master <- get("master", mode = "list", 
[08:25:51.843]                             envir = envir, inherits = FALSE)
[08:25:51.843]                           if (inherits(master, c("SOCKnode", 
[08:25:51.843]                             "SOCK0node"))) {
[08:25:51.843]                             sendCondition <<- function(cond) {
[08:25:51.843]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.843]                                 success = TRUE)
[08:25:51.843]                               parallel_sendData(master, data)
[08:25:51.843]                             }
[08:25:51.843]                             return(sendCondition)
[08:25:51.843]                           }
[08:25:51.843]                         }
[08:25:51.843]                         frame <- frame + 1L
[08:25:51.843]                         envir <- sys.frame(frame)
[08:25:51.843]                       }
[08:25:51.843]                     }
[08:25:51.843]                     sendCondition <<- function(cond) NULL
[08:25:51.843]                   }
[08:25:51.843]                 })
[08:25:51.843]                 withCallingHandlers({
[08:25:51.843]                   {
[08:25:51.843]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.843]                     if (!identical(...future.globals.maxSize.org, 
[08:25:51.843]                       ...future.globals.maxSize)) {
[08:25:51.843]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.843]                       on.exit(options(oopts), add = TRUE)
[08:25:51.843]                     }
[08:25:51.843]                     {
[08:25:51.843]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.843]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:51.843]                         USE.NAMES = FALSE)
[08:25:51.843]                       do.call(mapply, args = args)
[08:25:51.843]                     }
[08:25:51.843]                   }
[08:25:51.843]                 }, immediateCondition = function(cond) {
[08:25:51.843]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.843]                   sendCondition(cond)
[08:25:51.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.843]                   {
[08:25:51.843]                     inherits <- base::inherits
[08:25:51.843]                     invokeRestart <- base::invokeRestart
[08:25:51.843]                     is.null <- base::is.null
[08:25:51.843]                     muffled <- FALSE
[08:25:51.843]                     if (inherits(cond, "message")) {
[08:25:51.843]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.843]                       if (muffled) 
[08:25:51.843]                         invokeRestart("muffleMessage")
[08:25:51.843]                     }
[08:25:51.843]                     else if (inherits(cond, "warning")) {
[08:25:51.843]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.843]                       if (muffled) 
[08:25:51.843]                         invokeRestart("muffleWarning")
[08:25:51.843]                     }
[08:25:51.843]                     else if (inherits(cond, "condition")) {
[08:25:51.843]                       if (!is.null(pattern)) {
[08:25:51.843]                         computeRestarts <- base::computeRestarts
[08:25:51.843]                         grepl <- base::grepl
[08:25:51.843]                         restarts <- computeRestarts(cond)
[08:25:51.843]                         for (restart in restarts) {
[08:25:51.843]                           name <- restart$name
[08:25:51.843]                           if (is.null(name)) 
[08:25:51.843]                             next
[08:25:51.843]                           if (!grepl(pattern, name)) 
[08:25:51.843]                             next
[08:25:51.843]                           invokeRestart(restart)
[08:25:51.843]                           muffled <- TRUE
[08:25:51.843]                           break
[08:25:51.843]                         }
[08:25:51.843]                       }
[08:25:51.843]                     }
[08:25:51.843]                     invisible(muffled)
[08:25:51.843]                   }
[08:25:51.843]                   muffleCondition(cond)
[08:25:51.843]                 })
[08:25:51.843]             }))
[08:25:51.843]             future::FutureResult(value = ...future.value$value, 
[08:25:51.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.843]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.843]                     ...future.globalenv.names))
[08:25:51.843]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.843]         }, condition = base::local({
[08:25:51.843]             c <- base::c
[08:25:51.843]             inherits <- base::inherits
[08:25:51.843]             invokeRestart <- base::invokeRestart
[08:25:51.843]             length <- base::length
[08:25:51.843]             list <- base::list
[08:25:51.843]             seq.int <- base::seq.int
[08:25:51.843]             signalCondition <- base::signalCondition
[08:25:51.843]             sys.calls <- base::sys.calls
[08:25:51.843]             `[[` <- base::`[[`
[08:25:51.843]             `+` <- base::`+`
[08:25:51.843]             `<<-` <- base::`<<-`
[08:25:51.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.843]                   3L)]
[08:25:51.843]             }
[08:25:51.843]             function(cond) {
[08:25:51.843]                 is_error <- inherits(cond, "error")
[08:25:51.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.843]                   NULL)
[08:25:51.843]                 if (is_error) {
[08:25:51.843]                   sessionInformation <- function() {
[08:25:51.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.843]                       search = base::search(), system = base::Sys.info())
[08:25:51.843]                   }
[08:25:51.843]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.843]                     cond$call), session = sessionInformation(), 
[08:25:51.843]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.843]                   signalCondition(cond)
[08:25:51.843]                 }
[08:25:51.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.843]                 "immediateCondition"))) {
[08:25:51.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.843]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.843]                   if (TRUE && !signal) {
[08:25:51.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.843]                     {
[08:25:51.843]                       inherits <- base::inherits
[08:25:51.843]                       invokeRestart <- base::invokeRestart
[08:25:51.843]                       is.null <- base::is.null
[08:25:51.843]                       muffled <- FALSE
[08:25:51.843]                       if (inherits(cond, "message")) {
[08:25:51.843]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.843]                         if (muffled) 
[08:25:51.843]                           invokeRestart("muffleMessage")
[08:25:51.843]                       }
[08:25:51.843]                       else if (inherits(cond, "warning")) {
[08:25:51.843]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.843]                         if (muffled) 
[08:25:51.843]                           invokeRestart("muffleWarning")
[08:25:51.843]                       }
[08:25:51.843]                       else if (inherits(cond, "condition")) {
[08:25:51.843]                         if (!is.null(pattern)) {
[08:25:51.843]                           computeRestarts <- base::computeRestarts
[08:25:51.843]                           grepl <- base::grepl
[08:25:51.843]                           restarts <- computeRestarts(cond)
[08:25:51.843]                           for (restart in restarts) {
[08:25:51.843]                             name <- restart$name
[08:25:51.843]                             if (is.null(name)) 
[08:25:51.843]                               next
[08:25:51.843]                             if (!grepl(pattern, name)) 
[08:25:51.843]                               next
[08:25:51.843]                             invokeRestart(restart)
[08:25:51.843]                             muffled <- TRUE
[08:25:51.843]                             break
[08:25:51.843]                           }
[08:25:51.843]                         }
[08:25:51.843]                       }
[08:25:51.843]                       invisible(muffled)
[08:25:51.843]                     }
[08:25:51.843]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.843]                   }
[08:25:51.843]                 }
[08:25:51.843]                 else {
[08:25:51.843]                   if (TRUE) {
[08:25:51.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.843]                     {
[08:25:51.843]                       inherits <- base::inherits
[08:25:51.843]                       invokeRestart <- base::invokeRestart
[08:25:51.843]                       is.null <- base::is.null
[08:25:51.843]                       muffled <- FALSE
[08:25:51.843]                       if (inherits(cond, "message")) {
[08:25:51.843]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.843]                         if (muffled) 
[08:25:51.843]                           invokeRestart("muffleMessage")
[08:25:51.843]                       }
[08:25:51.843]                       else if (inherits(cond, "warning")) {
[08:25:51.843]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.843]                         if (muffled) 
[08:25:51.843]                           invokeRestart("muffleWarning")
[08:25:51.843]                       }
[08:25:51.843]                       else if (inherits(cond, "condition")) {
[08:25:51.843]                         if (!is.null(pattern)) {
[08:25:51.843]                           computeRestarts <- base::computeRestarts
[08:25:51.843]                           grepl <- base::grepl
[08:25:51.843]                           restarts <- computeRestarts(cond)
[08:25:51.843]                           for (restart in restarts) {
[08:25:51.843]                             name <- restart$name
[08:25:51.843]                             if (is.null(name)) 
[08:25:51.843]                               next
[08:25:51.843]                             if (!grepl(pattern, name)) 
[08:25:51.843]                               next
[08:25:51.843]                             invokeRestart(restart)
[08:25:51.843]                             muffled <- TRUE
[08:25:51.843]                             break
[08:25:51.843]                           }
[08:25:51.843]                         }
[08:25:51.843]                       }
[08:25:51.843]                       invisible(muffled)
[08:25:51.843]                     }
[08:25:51.843]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.843]                   }
[08:25:51.843]                 }
[08:25:51.843]             }
[08:25:51.843]         }))
[08:25:51.843]     }, error = function(ex) {
[08:25:51.843]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.843]                 ...future.rng), started = ...future.startTime, 
[08:25:51.843]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.843]             version = "1.8"), class = "FutureResult")
[08:25:51.843]     }, finally = {
[08:25:51.843]         if (!identical(...future.workdir, getwd())) 
[08:25:51.843]             setwd(...future.workdir)
[08:25:51.843]         {
[08:25:51.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.843]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.843]             }
[08:25:51.843]             base::options(...future.oldOptions)
[08:25:51.843]             if (.Platform$OS.type == "windows") {
[08:25:51.843]                 old_names <- names(...future.oldEnvVars)
[08:25:51.843]                 envs <- base::Sys.getenv()
[08:25:51.843]                 names <- names(envs)
[08:25:51.843]                 common <- intersect(names, old_names)
[08:25:51.843]                 added <- setdiff(names, old_names)
[08:25:51.843]                 removed <- setdiff(old_names, names)
[08:25:51.843]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.843]                   envs[common]]
[08:25:51.843]                 NAMES <- toupper(changed)
[08:25:51.843]                 args <- list()
[08:25:51.843]                 for (kk in seq_along(NAMES)) {
[08:25:51.843]                   name <- changed[[kk]]
[08:25:51.843]                   NAME <- NAMES[[kk]]
[08:25:51.843]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.843]                     next
[08:25:51.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.843]                 }
[08:25:51.843]                 NAMES <- toupper(added)
[08:25:51.843]                 for (kk in seq_along(NAMES)) {
[08:25:51.843]                   name <- added[[kk]]
[08:25:51.843]                   NAME <- NAMES[[kk]]
[08:25:51.843]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.843]                     next
[08:25:51.843]                   args[[name]] <- ""
[08:25:51.843]                 }
[08:25:51.843]                 NAMES <- toupper(removed)
[08:25:51.843]                 for (kk in seq_along(NAMES)) {
[08:25:51.843]                   name <- removed[[kk]]
[08:25:51.843]                   NAME <- NAMES[[kk]]
[08:25:51.843]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.843]                     next
[08:25:51.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.843]                 }
[08:25:51.843]                 if (length(args) > 0) 
[08:25:51.843]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.843]             }
[08:25:51.843]             else {
[08:25:51.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.843]             }
[08:25:51.843]             {
[08:25:51.843]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.843]                   0L) {
[08:25:51.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.843]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.843]                   base::options(opts)
[08:25:51.843]                 }
[08:25:51.843]                 {
[08:25:51.843]                   {
[08:25:51.843]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.843]                     NULL
[08:25:51.843]                   }
[08:25:51.843]                   options(future.plan = NULL)
[08:25:51.843]                   if (is.na(NA_character_)) 
[08:25:51.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.843]                     .init = FALSE)
[08:25:51.843]                 }
[08:25:51.843]             }
[08:25:51.843]         }
[08:25:51.843]     })
[08:25:51.843]     if (TRUE) {
[08:25:51.843]         base::sink(type = "output", split = FALSE)
[08:25:51.843]         if (TRUE) {
[08:25:51.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.843]         }
[08:25:51.843]         else {
[08:25:51.843]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.843]         }
[08:25:51.843]         base::close(...future.stdout)
[08:25:51.843]         ...future.stdout <- NULL
[08:25:51.843]     }
[08:25:51.843]     ...future.result$conditions <- ...future.conditions
[08:25:51.843]     ...future.result$finished <- base::Sys.time()
[08:25:51.843]     ...future.result
[08:25:51.843] }
[08:25:51.846] Exporting 5 global objects (723 bytes) to cluster node #2 ...
[08:25:51.846] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[08:25:51.847] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[08:25:51.847] Exporting ‘MoreArgs’ (89 bytes) to cluster node #2 ...
[08:25:51.847] Exporting ‘MoreArgs’ (89 bytes) to cluster node #2 ... DONE
[08:25:51.847] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #2 ...
[08:25:51.848] Exporting ‘...future.elements_ii’ (109 bytes) to cluster node #2 ... DONE
[08:25:51.848] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:51.848] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.848] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:51.849] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.849] Exporting 5 global objects (723 bytes) to cluster node #2 ... DONE
[08:25:51.849] MultisessionFuture started
[08:25:51.850] - Launch lazy future ... done
[08:25:51.850] run() for ‘MultisessionFuture’ ... done
[08:25:51.850] Created future:
[08:25:51.850] MultisessionFuture:
[08:25:51.850] Label: ‘future_mapply-2’
[08:25:51.850] Expression:
[08:25:51.850] {
[08:25:51.850]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.850]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:51.850]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.850]         on.exit(options(oopts), add = TRUE)
[08:25:51.850]     }
[08:25:51.850]     {
[08:25:51.850]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.850]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:51.850]         do.call(mapply, args = args)
[08:25:51.850]     }
[08:25:51.850] }
[08:25:51.850] Lazy evaluation: FALSE
[08:25:51.850] Asynchronous evaluation: TRUE
[08:25:51.850] Local evaluation: TRUE
[08:25:51.850] Environment: R_GlobalEnv
[08:25:51.850] Capture standard output: TRUE
[08:25:51.850] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:51.850] Globals: 5 objects totaling 286 bytes (function ‘...future.FUN’ of 34 bytes, list ‘MoreArgs’ of 89 bytes, list ‘...future.elements_ii’ of 109 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:51.850] Packages: <none>
[08:25:51.850] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:51.850] Resolved: FALSE
[08:25:51.850] Value: <not collected>
[08:25:51.850] Conditions captured: <none>
[08:25:51.850] Early signaling: FALSE
[08:25:51.850] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:51.850] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.861] Chunk #2 of 2 ... DONE
[08:25:51.861] Launching 2 futures (chunks) ... DONE
[08:25:51.861] Resolving 2 futures (chunks) ...
[08:25:51.862] resolve() on list ...
[08:25:51.862]  recursive: 0
[08:25:51.862]  length: 2
[08:25:51.862] 
[08:25:51.862] receiveMessageFromWorker() for ClusterFuture ...
[08:25:51.863] - Validating connection of MultisessionFuture
[08:25:51.863] - received message: FutureResult
[08:25:51.863] - Received FutureResult
[08:25:51.863] - Erased future from FutureRegistry
[08:25:51.863] result() for ClusterFuture ...
[08:25:51.863] - result already collected: FutureResult
[08:25:51.863] result() for ClusterFuture ... done
[08:25:51.863] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:51.863] Future #1
[08:25:51.863] result() for ClusterFuture ...
[08:25:51.864] - result already collected: FutureResult
[08:25:51.864] result() for ClusterFuture ... done
[08:25:51.864] result() for ClusterFuture ...
[08:25:51.864] - result already collected: FutureResult
[08:25:51.864] result() for ClusterFuture ... done
[08:25:51.864] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:51.864] - nx: 2
[08:25:51.864] - relay: TRUE
[08:25:51.864] - stdout: TRUE
[08:25:51.864] - signal: TRUE
[08:25:51.864] - resignal: FALSE
[08:25:51.864] - force: TRUE
[08:25:51.864] - relayed: [n=2] FALSE, FALSE
[08:25:51.865] - queued futures: [n=2] FALSE, FALSE
[08:25:51.865]  - until=1
[08:25:51.865]  - relaying element #1
[08:25:51.865] result() for ClusterFuture ...
[08:25:51.865] - result already collected: FutureResult
[08:25:51.865] result() for ClusterFuture ... done
[08:25:51.865] result() for ClusterFuture ...
[08:25:51.865] - result already collected: FutureResult
[08:25:51.865] result() for ClusterFuture ... done
[08:25:51.865] result() for ClusterFuture ...
[08:25:51.865] - result already collected: FutureResult
[08:25:51.866] result() for ClusterFuture ... done
[08:25:51.866] result() for ClusterFuture ...
[08:25:51.866] - result already collected: FutureResult
[08:25:51.866] result() for ClusterFuture ... done
[08:25:51.866] - relayed: [n=2] TRUE, FALSE
[08:25:51.866] - queued futures: [n=2] TRUE, FALSE
[08:25:51.866] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:51.866]  length: 1 (resolved future 1)
[08:25:51.891] receiveMessageFromWorker() for ClusterFuture ...
[08:25:51.891] - Validating connection of MultisessionFuture
[08:25:51.892] - received message: FutureResult
[08:25:51.892] - Received FutureResult
[08:25:51.892] - Erased future from FutureRegistry
[08:25:51.892] result() for ClusterFuture ...
[08:25:51.892] - result already collected: FutureResult
[08:25:51.892] result() for ClusterFuture ... done
[08:25:51.892] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:51.892] Future #2
[08:25:51.892] result() for ClusterFuture ...
[08:25:51.893] - result already collected: FutureResult
[08:25:51.893] result() for ClusterFuture ... done
[08:25:51.893] result() for ClusterFuture ...
[08:25:51.893] - result already collected: FutureResult
[08:25:51.893] result() for ClusterFuture ... done
[08:25:51.893] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:51.893] - nx: 2
[08:25:51.893] - relay: TRUE
[08:25:51.893] - stdout: TRUE
[08:25:51.893] - signal: TRUE
[08:25:51.893] - resignal: FALSE
[08:25:51.893] - force: TRUE
[08:25:51.894] - relayed: [n=2] TRUE, FALSE
[08:25:51.894] - queued futures: [n=2] TRUE, FALSE
[08:25:51.894]  - until=2
[08:25:51.894]  - relaying element #2
[08:25:51.894] result() for ClusterFuture ...
[08:25:51.894] - result already collected: FutureResult
[08:25:51.894] result() for ClusterFuture ... done
[08:25:51.894] result() for ClusterFuture ...
[08:25:51.894] - result already collected: FutureResult
[08:25:51.894] result() for ClusterFuture ... done
[08:25:51.894] result() for ClusterFuture ...
[08:25:51.894] - result already collected: FutureResult
[08:25:51.895] result() for ClusterFuture ... done
[08:25:51.895] result() for ClusterFuture ...
[08:25:51.895] - result already collected: FutureResult
[08:25:51.895] result() for ClusterFuture ... done
[08:25:51.895] - relayed: [n=2] TRUE, TRUE
[08:25:51.895] - queued futures: [n=2] TRUE, TRUE
[08:25:51.895] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:51.895]  length: 0 (resolved future 2)
[08:25:51.895] Relaying remaining futures
[08:25:51.895] signalConditionsASAP(NULL, pos=0) ...
[08:25:51.895] - nx: 2
[08:25:51.895] - relay: TRUE
[08:25:51.896] - stdout: TRUE
[08:25:51.896] - signal: TRUE
[08:25:51.896] - resignal: FALSE
[08:25:51.896] - force: TRUE
[08:25:51.896] - relayed: [n=2] TRUE, TRUE
[08:25:51.896] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:51.896] - relayed: [n=2] TRUE, TRUE
[08:25:51.896] - queued futures: [n=2] TRUE, TRUE
[08:25:51.896] signalConditionsASAP(NULL, pos=0) ... done
[08:25:51.896] resolve() on list ... DONE
[08:25:51.896] result() for ClusterFuture ...
[08:25:51.896] - result already collected: FutureResult
[08:25:51.897] result() for ClusterFuture ... done
[08:25:51.897] result() for ClusterFuture ...
[08:25:51.897] - result already collected: FutureResult
[08:25:51.897] result() for ClusterFuture ... done
[08:25:51.897] result() for ClusterFuture ...
[08:25:51.897] - result already collected: FutureResult
[08:25:51.897] result() for ClusterFuture ... done
[08:25:51.897] result() for ClusterFuture ...
[08:25:51.897] - result already collected: FutureResult
[08:25:51.897] result() for ClusterFuture ... done
[08:25:51.897]  - Number of value chunks collected: 2
[08:25:51.898] Resolving 2 futures (chunks) ... DONE
[08:25:51.898] Reducing values from 2 chunks ...
[08:25:51.898]  - Number of values collected after concatenation: 4
[08:25:51.898]  - Number of values expected: 4
[08:25:51.898] Reducing values from 2 chunks ... DONE
[08:25:51.898] future_mapply() ... DONE
[08:25:51.898] future_mapply() ...
[08:25:51.900] Number of chunks: 2
[08:25:51.900] getGlobalsAndPackagesXApply() ...
[08:25:51.900]  - future.globals: TRUE
[08:25:51.900] getGlobalsAndPackages() ...
[08:25:51.900] Searching for globals...
[08:25:51.902] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[08:25:51.902] Searching for globals ... DONE
[08:25:51.902] Resolving globals: FALSE
[08:25:51.902] The total size of the 1 globals is 414 bytes (414 bytes)
[08:25:51.903] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[08:25:51.903] - globals: [1] ‘FUN’
[08:25:51.903] 
[08:25:51.903] getGlobalsAndPackages() ... DONE
[08:25:51.903]  - globals found/used: [n=1] ‘FUN’
[08:25:51.903]  - needed namespaces: [n=0] 
[08:25:51.903] Finding globals ... DONE
[08:25:51.903] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:51.904] List of 2
[08:25:51.904]  $ ...future.FUN:function (x, y)  
[08:25:51.904]  $ MoreArgs     : NULL
[08:25:51.904]  - attr(*, "where")=List of 2
[08:25:51.904]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:51.904]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:51.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:51.904]  - attr(*, "resolved")= logi FALSE
[08:25:51.904]  - attr(*, "total_size")= num NA
[08:25:51.906] Packages to be attached in all futures: [n=0] 
[08:25:51.906] getGlobalsAndPackagesXApply() ... DONE
[08:25:51.906] Number of futures (= number of chunks): 2
[08:25:51.906] Launching 2 futures (chunks) ...
[08:25:51.906] Chunk #1 of 2 ...
[08:25:51.907]  - Finding globals in '...' for chunk #1 ...
[08:25:51.907] getGlobalsAndPackages() ...
[08:25:51.907] Searching for globals...
[08:25:51.907] 
[08:25:51.907] Searching for globals ... DONE
[08:25:51.907] - globals: [0] <none>
[08:25:51.907] getGlobalsAndPackages() ... DONE
[08:25:51.907]    + additional globals found: [n=0] 
[08:25:51.908]    + additional namespaces needed: [n=0] 
[08:25:51.908]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:51.908]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:51.908]  - seeds: <none>
[08:25:51.908]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.908] getGlobalsAndPackages() ...
[08:25:51.908] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.908] Resolving globals: FALSE
[08:25:51.909] The total size of the 5 globals is 645 bytes (645 bytes)
[08:25:51.909] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 645 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:51.909] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.909] 
[08:25:51.909] getGlobalsAndPackages() ... DONE
[08:25:51.910] run() for ‘Future’ ...
[08:25:51.910] - state: ‘created’
[08:25:51.910] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:51.924] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:51.924]   - Field: ‘node’
[08:25:51.925]   - Field: ‘label’
[08:25:51.925]   - Field: ‘local’
[08:25:51.925]   - Field: ‘owner’
[08:25:51.925]   - Field: ‘envir’
[08:25:51.925]   - Field: ‘workers’
[08:25:51.925]   - Field: ‘packages’
[08:25:51.925]   - Field: ‘gc’
[08:25:51.925]   - Field: ‘conditions’
[08:25:51.925]   - Field: ‘persistent’
[08:25:51.925]   - Field: ‘expr’
[08:25:51.925]   - Field: ‘uuid’
[08:25:51.926]   - Field: ‘seed’
[08:25:51.926]   - Field: ‘version’
[08:25:51.926]   - Field: ‘result’
[08:25:51.926]   - Field: ‘asynchronous’
[08:25:51.926]   - Field: ‘calls’
[08:25:51.926]   - Field: ‘globals’
[08:25:51.926]   - Field: ‘stdout’
[08:25:51.926]   - Field: ‘earlySignal’
[08:25:51.926]   - Field: ‘lazy’
[08:25:51.926]   - Field: ‘state’
[08:25:51.926] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:51.927] - Launch lazy future ...
[08:25:51.927] Packages needed by the future expression (n = 0): <none>
[08:25:51.927] Packages needed by future strategies (n = 0): <none>
[08:25:51.927] {
[08:25:51.927]     {
[08:25:51.927]         {
[08:25:51.927]             ...future.startTime <- base::Sys.time()
[08:25:51.927]             {
[08:25:51.927]                 {
[08:25:51.927]                   {
[08:25:51.927]                     {
[08:25:51.927]                       base::local({
[08:25:51.927]                         has_future <- base::requireNamespace("future", 
[08:25:51.927]                           quietly = TRUE)
[08:25:51.927]                         if (has_future) {
[08:25:51.927]                           ns <- base::getNamespace("future")
[08:25:51.927]                           version <- ns[[".package"]][["version"]]
[08:25:51.927]                           if (is.null(version)) 
[08:25:51.927]                             version <- utils::packageVersion("future")
[08:25:51.927]                         }
[08:25:51.927]                         else {
[08:25:51.927]                           version <- NULL
[08:25:51.927]                         }
[08:25:51.927]                         if (!has_future || version < "1.8.0") {
[08:25:51.927]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.927]                             "", base::R.version$version.string), 
[08:25:51.927]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.927]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.927]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.927]                               "release", "version")], collapse = " "), 
[08:25:51.927]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.927]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.927]                             info)
[08:25:51.927]                           info <- base::paste(info, collapse = "; ")
[08:25:51.927]                           if (!has_future) {
[08:25:51.927]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.927]                               info)
[08:25:51.927]                           }
[08:25:51.927]                           else {
[08:25:51.927]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.927]                               info, version)
[08:25:51.927]                           }
[08:25:51.927]                           base::stop(msg)
[08:25:51.927]                         }
[08:25:51.927]                       })
[08:25:51.927]                     }
[08:25:51.927]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.927]                     base::options(mc.cores = 1L)
[08:25:51.927]                   }
[08:25:51.927]                   ...future.strategy.old <- future::plan("list")
[08:25:51.927]                   options(future.plan = NULL)
[08:25:51.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.927]                 }
[08:25:51.927]                 ...future.workdir <- getwd()
[08:25:51.927]             }
[08:25:51.927]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.927]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.927]         }
[08:25:51.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.927]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:51.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.927]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.927]             base::names(...future.oldOptions))
[08:25:51.927]     }
[08:25:51.927]     if (FALSE) {
[08:25:51.927]     }
[08:25:51.927]     else {
[08:25:51.927]         if (TRUE) {
[08:25:51.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.927]                 open = "w")
[08:25:51.927]         }
[08:25:51.927]         else {
[08:25:51.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.927]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.927]         }
[08:25:51.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.927]             base::sink(type = "output", split = FALSE)
[08:25:51.927]             base::close(...future.stdout)
[08:25:51.927]         }, add = TRUE)
[08:25:51.927]     }
[08:25:51.927]     ...future.frame <- base::sys.nframe()
[08:25:51.927]     ...future.conditions <- base::list()
[08:25:51.927]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.927]     if (FALSE) {
[08:25:51.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.927]     }
[08:25:51.927]     ...future.result <- base::tryCatch({
[08:25:51.927]         base::withCallingHandlers({
[08:25:51.927]             ...future.value <- base::withVisible(base::local({
[08:25:51.927]                 ...future.makeSendCondition <- base::local({
[08:25:51.927]                   sendCondition <- NULL
[08:25:51.927]                   function(frame = 1L) {
[08:25:51.927]                     if (is.function(sendCondition)) 
[08:25:51.927]                       return(sendCondition)
[08:25:51.927]                     ns <- getNamespace("parallel")
[08:25:51.927]                     if (exists("sendData", mode = "function", 
[08:25:51.927]                       envir = ns)) {
[08:25:51.927]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.927]                         envir = ns)
[08:25:51.927]                       envir <- sys.frame(frame)
[08:25:51.927]                       master <- NULL
[08:25:51.927]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.927]                         !identical(envir, emptyenv())) {
[08:25:51.927]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.927]                           inherits = FALSE)) {
[08:25:51.927]                           master <- get("master", mode = "list", 
[08:25:51.927]                             envir = envir, inherits = FALSE)
[08:25:51.927]                           if (inherits(master, c("SOCKnode", 
[08:25:51.927]                             "SOCK0node"))) {
[08:25:51.927]                             sendCondition <<- function(cond) {
[08:25:51.927]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.927]                                 success = TRUE)
[08:25:51.927]                               parallel_sendData(master, data)
[08:25:51.927]                             }
[08:25:51.927]                             return(sendCondition)
[08:25:51.927]                           }
[08:25:51.927]                         }
[08:25:51.927]                         frame <- frame + 1L
[08:25:51.927]                         envir <- sys.frame(frame)
[08:25:51.927]                       }
[08:25:51.927]                     }
[08:25:51.927]                     sendCondition <<- function(cond) NULL
[08:25:51.927]                   }
[08:25:51.927]                 })
[08:25:51.927]                 withCallingHandlers({
[08:25:51.927]                   {
[08:25:51.927]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.927]                     if (!identical(...future.globals.maxSize.org, 
[08:25:51.927]                       ...future.globals.maxSize)) {
[08:25:51.927]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.927]                       on.exit(options(oopts), add = TRUE)
[08:25:51.927]                     }
[08:25:51.927]                     {
[08:25:51.927]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.927]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:51.927]                         USE.NAMES = FALSE)
[08:25:51.927]                       do.call(mapply, args = args)
[08:25:51.927]                     }
[08:25:51.927]                   }
[08:25:51.927]                 }, immediateCondition = function(cond) {
[08:25:51.927]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.927]                   sendCondition(cond)
[08:25:51.927]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.927]                   {
[08:25:51.927]                     inherits <- base::inherits
[08:25:51.927]                     invokeRestart <- base::invokeRestart
[08:25:51.927]                     is.null <- base::is.null
[08:25:51.927]                     muffled <- FALSE
[08:25:51.927]                     if (inherits(cond, "message")) {
[08:25:51.927]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.927]                       if (muffled) 
[08:25:51.927]                         invokeRestart("muffleMessage")
[08:25:51.927]                     }
[08:25:51.927]                     else if (inherits(cond, "warning")) {
[08:25:51.927]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.927]                       if (muffled) 
[08:25:51.927]                         invokeRestart("muffleWarning")
[08:25:51.927]                     }
[08:25:51.927]                     else if (inherits(cond, "condition")) {
[08:25:51.927]                       if (!is.null(pattern)) {
[08:25:51.927]                         computeRestarts <- base::computeRestarts
[08:25:51.927]                         grepl <- base::grepl
[08:25:51.927]                         restarts <- computeRestarts(cond)
[08:25:51.927]                         for (restart in restarts) {
[08:25:51.927]                           name <- restart$name
[08:25:51.927]                           if (is.null(name)) 
[08:25:51.927]                             next
[08:25:51.927]                           if (!grepl(pattern, name)) 
[08:25:51.927]                             next
[08:25:51.927]                           invokeRestart(restart)
[08:25:51.927]                           muffled <- TRUE
[08:25:51.927]                           break
[08:25:51.927]                         }
[08:25:51.927]                       }
[08:25:51.927]                     }
[08:25:51.927]                     invisible(muffled)
[08:25:51.927]                   }
[08:25:51.927]                   muffleCondition(cond)
[08:25:51.927]                 })
[08:25:51.927]             }))
[08:25:51.927]             future::FutureResult(value = ...future.value$value, 
[08:25:51.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.927]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.927]                     ...future.globalenv.names))
[08:25:51.927]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.927]         }, condition = base::local({
[08:25:51.927]             c <- base::c
[08:25:51.927]             inherits <- base::inherits
[08:25:51.927]             invokeRestart <- base::invokeRestart
[08:25:51.927]             length <- base::length
[08:25:51.927]             list <- base::list
[08:25:51.927]             seq.int <- base::seq.int
[08:25:51.927]             signalCondition <- base::signalCondition
[08:25:51.927]             sys.calls <- base::sys.calls
[08:25:51.927]             `[[` <- base::`[[`
[08:25:51.927]             `+` <- base::`+`
[08:25:51.927]             `<<-` <- base::`<<-`
[08:25:51.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.927]                   3L)]
[08:25:51.927]             }
[08:25:51.927]             function(cond) {
[08:25:51.927]                 is_error <- inherits(cond, "error")
[08:25:51.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.927]                   NULL)
[08:25:51.927]                 if (is_error) {
[08:25:51.927]                   sessionInformation <- function() {
[08:25:51.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.927]                       search = base::search(), system = base::Sys.info())
[08:25:51.927]                   }
[08:25:51.927]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.927]                     cond$call), session = sessionInformation(), 
[08:25:51.927]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.927]                   signalCondition(cond)
[08:25:51.927]                 }
[08:25:51.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.927]                 "immediateCondition"))) {
[08:25:51.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.927]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.927]                   if (TRUE && !signal) {
[08:25:51.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.927]                     {
[08:25:51.927]                       inherits <- base::inherits
[08:25:51.927]                       invokeRestart <- base::invokeRestart
[08:25:51.927]                       is.null <- base::is.null
[08:25:51.927]                       muffled <- FALSE
[08:25:51.927]                       if (inherits(cond, "message")) {
[08:25:51.927]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.927]                         if (muffled) 
[08:25:51.927]                           invokeRestart("muffleMessage")
[08:25:51.927]                       }
[08:25:51.927]                       else if (inherits(cond, "warning")) {
[08:25:51.927]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.927]                         if (muffled) 
[08:25:51.927]                           invokeRestart("muffleWarning")
[08:25:51.927]                       }
[08:25:51.927]                       else if (inherits(cond, "condition")) {
[08:25:51.927]                         if (!is.null(pattern)) {
[08:25:51.927]                           computeRestarts <- base::computeRestarts
[08:25:51.927]                           grepl <- base::grepl
[08:25:51.927]                           restarts <- computeRestarts(cond)
[08:25:51.927]                           for (restart in restarts) {
[08:25:51.927]                             name <- restart$name
[08:25:51.927]                             if (is.null(name)) 
[08:25:51.927]                               next
[08:25:51.927]                             if (!grepl(pattern, name)) 
[08:25:51.927]                               next
[08:25:51.927]                             invokeRestart(restart)
[08:25:51.927]                             muffled <- TRUE
[08:25:51.927]                             break
[08:25:51.927]                           }
[08:25:51.927]                         }
[08:25:51.927]                       }
[08:25:51.927]                       invisible(muffled)
[08:25:51.927]                     }
[08:25:51.927]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.927]                   }
[08:25:51.927]                 }
[08:25:51.927]                 else {
[08:25:51.927]                   if (TRUE) {
[08:25:51.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.927]                     {
[08:25:51.927]                       inherits <- base::inherits
[08:25:51.927]                       invokeRestart <- base::invokeRestart
[08:25:51.927]                       is.null <- base::is.null
[08:25:51.927]                       muffled <- FALSE
[08:25:51.927]                       if (inherits(cond, "message")) {
[08:25:51.927]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.927]                         if (muffled) 
[08:25:51.927]                           invokeRestart("muffleMessage")
[08:25:51.927]                       }
[08:25:51.927]                       else if (inherits(cond, "warning")) {
[08:25:51.927]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.927]                         if (muffled) 
[08:25:51.927]                           invokeRestart("muffleWarning")
[08:25:51.927]                       }
[08:25:51.927]                       else if (inherits(cond, "condition")) {
[08:25:51.927]                         if (!is.null(pattern)) {
[08:25:51.927]                           computeRestarts <- base::computeRestarts
[08:25:51.927]                           grepl <- base::grepl
[08:25:51.927]                           restarts <- computeRestarts(cond)
[08:25:51.927]                           for (restart in restarts) {
[08:25:51.927]                             name <- restart$name
[08:25:51.927]                             if (is.null(name)) 
[08:25:51.927]                               next
[08:25:51.927]                             if (!grepl(pattern, name)) 
[08:25:51.927]                               next
[08:25:51.927]                             invokeRestart(restart)
[08:25:51.927]                             muffled <- TRUE
[08:25:51.927]                             break
[08:25:51.927]                           }
[08:25:51.927]                         }
[08:25:51.927]                       }
[08:25:51.927]                       invisible(muffled)
[08:25:51.927]                     }
[08:25:51.927]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.927]                   }
[08:25:51.927]                 }
[08:25:51.927]             }
[08:25:51.927]         }))
[08:25:51.927]     }, error = function(ex) {
[08:25:51.927]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.927]                 ...future.rng), started = ...future.startTime, 
[08:25:51.927]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.927]             version = "1.8"), class = "FutureResult")
[08:25:51.927]     }, finally = {
[08:25:51.927]         if (!identical(...future.workdir, getwd())) 
[08:25:51.927]             setwd(...future.workdir)
[08:25:51.927]         {
[08:25:51.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.927]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.927]             }
[08:25:51.927]             base::options(...future.oldOptions)
[08:25:51.927]             if (.Platform$OS.type == "windows") {
[08:25:51.927]                 old_names <- names(...future.oldEnvVars)
[08:25:51.927]                 envs <- base::Sys.getenv()
[08:25:51.927]                 names <- names(envs)
[08:25:51.927]                 common <- intersect(names, old_names)
[08:25:51.927]                 added <- setdiff(names, old_names)
[08:25:51.927]                 removed <- setdiff(old_names, names)
[08:25:51.927]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.927]                   envs[common]]
[08:25:51.927]                 NAMES <- toupper(changed)
[08:25:51.927]                 args <- list()
[08:25:51.927]                 for (kk in seq_along(NAMES)) {
[08:25:51.927]                   name <- changed[[kk]]
[08:25:51.927]                   NAME <- NAMES[[kk]]
[08:25:51.927]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.927]                     next
[08:25:51.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.927]                 }
[08:25:51.927]                 NAMES <- toupper(added)
[08:25:51.927]                 for (kk in seq_along(NAMES)) {
[08:25:51.927]                   name <- added[[kk]]
[08:25:51.927]                   NAME <- NAMES[[kk]]
[08:25:51.927]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.927]                     next
[08:25:51.927]                   args[[name]] <- ""
[08:25:51.927]                 }
[08:25:51.927]                 NAMES <- toupper(removed)
[08:25:51.927]                 for (kk in seq_along(NAMES)) {
[08:25:51.927]                   name <- removed[[kk]]
[08:25:51.927]                   NAME <- NAMES[[kk]]
[08:25:51.927]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.927]                     next
[08:25:51.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.927]                 }
[08:25:51.927]                 if (length(args) > 0) 
[08:25:51.927]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.927]             }
[08:25:51.927]             else {
[08:25:51.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.927]             }
[08:25:51.927]             {
[08:25:51.927]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.927]                   0L) {
[08:25:51.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.927]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.927]                   base::options(opts)
[08:25:51.927]                 }
[08:25:51.927]                 {
[08:25:51.927]                   {
[08:25:51.927]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.927]                     NULL
[08:25:51.927]                   }
[08:25:51.927]                   options(future.plan = NULL)
[08:25:51.927]                   if (is.na(NA_character_)) 
[08:25:51.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.927]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.927]                     .init = FALSE)
[08:25:51.927]                 }
[08:25:51.927]             }
[08:25:51.927]         }
[08:25:51.927]     })
[08:25:51.927]     if (TRUE) {
[08:25:51.927]         base::sink(type = "output", split = FALSE)
[08:25:51.927]         if (TRUE) {
[08:25:51.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.927]         }
[08:25:51.927]         else {
[08:25:51.927]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.927]         }
[08:25:51.927]         base::close(...future.stdout)
[08:25:51.927]         ...future.stdout <- NULL
[08:25:51.927]     }
[08:25:51.927]     ...future.result$conditions <- ...future.conditions
[08:25:51.927]     ...future.result$finished <- base::Sys.time()
[08:25:51.927]     ...future.result
[08:25:51.927] }
[08:25:51.930] Exporting 5 global objects (1.06 KiB) to cluster node #1 ...
[08:25:51.930] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ...
[08:25:51.931] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ... DONE
[08:25:51.931] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:51.931] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.932] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ...
[08:25:51.932] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ... DONE
[08:25:51.932] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:51.932] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.933] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:51.933] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:51.933] Exporting 5 global objects (1.06 KiB) to cluster node #1 ... DONE
[08:25:51.933] MultisessionFuture started
[08:25:51.934] - Launch lazy future ... done
[08:25:51.934] run() for ‘MultisessionFuture’ ... done
[08:25:51.934] Created future:
[08:25:51.934] MultisessionFuture:
[08:25:51.934] Label: ‘future_mapply-1’
[08:25:51.934] Expression:
[08:25:51.934] {
[08:25:51.934]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.934]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:51.934]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.934]         on.exit(options(oopts), add = TRUE)
[08:25:51.934]     }
[08:25:51.934]     {
[08:25:51.934]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.934]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:51.934]         do.call(mapply, args = args)
[08:25:51.934]     }
[08:25:51.934] }
[08:25:51.934] Lazy evaluation: FALSE
[08:25:51.934] Asynchronous evaluation: TRUE
[08:25:51.934] Local evaluation: TRUE
[08:25:51.934] Environment: R_GlobalEnv
[08:25:51.934] Capture standard output: TRUE
[08:25:51.934] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:51.934] Globals: 5 objects totaling 645 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:51.934] Packages: <none>
[08:25:51.934] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:51.934] Resolved: FALSE
[08:25:51.934] Value: <not collected>
[08:25:51.934] Conditions captured: <none>
[08:25:51.934] Early signaling: FALSE
[08:25:51.934] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:51.934] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.945] Chunk #1 of 2 ... DONE
[08:25:51.945] Chunk #2 of 2 ...
[08:25:51.946]  - Finding globals in '...' for chunk #2 ...
[08:25:51.946] getGlobalsAndPackages() ...
[08:25:51.946] Searching for globals...
[08:25:51.946] 
[08:25:51.946] Searching for globals ... DONE
[08:25:51.946] - globals: [0] <none>
[08:25:51.947] getGlobalsAndPackages() ... DONE
[08:25:51.947]    + additional globals found: [n=0] 
[08:25:51.947]    + additional namespaces needed: [n=0] 
[08:25:51.947]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:51.947]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:51.947]  - seeds: <none>
[08:25:51.947]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.947] getGlobalsAndPackages() ...
[08:25:51.949] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.949] Resolving globals: FALSE
[08:25:51.950] The total size of the 5 globals is 695 bytes (695 bytes)
[08:25:51.950] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 695 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:51.950] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:51.951] 
[08:25:51.951] getGlobalsAndPackages() ... DONE
[08:25:51.951] run() for ‘Future’ ...
[08:25:51.951] - state: ‘created’
[08:25:51.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:51.965] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:51.965]   - Field: ‘node’
[08:25:51.965]   - Field: ‘label’
[08:25:51.965]   - Field: ‘local’
[08:25:51.966]   - Field: ‘owner’
[08:25:51.966]   - Field: ‘envir’
[08:25:51.966]   - Field: ‘workers’
[08:25:51.966]   - Field: ‘packages’
[08:25:51.966]   - Field: ‘gc’
[08:25:51.966]   - Field: ‘conditions’
[08:25:51.966]   - Field: ‘persistent’
[08:25:51.966]   - Field: ‘expr’
[08:25:51.966]   - Field: ‘uuid’
[08:25:51.966]   - Field: ‘seed’
[08:25:51.966]   - Field: ‘version’
[08:25:51.966]   - Field: ‘result’
[08:25:51.967]   - Field: ‘asynchronous’
[08:25:51.967]   - Field: ‘calls’
[08:25:51.967]   - Field: ‘globals’
[08:25:51.967]   - Field: ‘stdout’
[08:25:51.967]   - Field: ‘earlySignal’
[08:25:51.967]   - Field: ‘lazy’
[08:25:51.967]   - Field: ‘state’
[08:25:51.967] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:51.967] - Launch lazy future ...
[08:25:51.967] Packages needed by the future expression (n = 0): <none>
[08:25:51.968] Packages needed by future strategies (n = 0): <none>
[08:25:51.968] {
[08:25:51.968]     {
[08:25:51.968]         {
[08:25:51.968]             ...future.startTime <- base::Sys.time()
[08:25:51.968]             {
[08:25:51.968]                 {
[08:25:51.968]                   {
[08:25:51.968]                     {
[08:25:51.968]                       base::local({
[08:25:51.968]                         has_future <- base::requireNamespace("future", 
[08:25:51.968]                           quietly = TRUE)
[08:25:51.968]                         if (has_future) {
[08:25:51.968]                           ns <- base::getNamespace("future")
[08:25:51.968]                           version <- ns[[".package"]][["version"]]
[08:25:51.968]                           if (is.null(version)) 
[08:25:51.968]                             version <- utils::packageVersion("future")
[08:25:51.968]                         }
[08:25:51.968]                         else {
[08:25:51.968]                           version <- NULL
[08:25:51.968]                         }
[08:25:51.968]                         if (!has_future || version < "1.8.0") {
[08:25:51.968]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:51.968]                             "", base::R.version$version.string), 
[08:25:51.968]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:51.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:51.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:51.968]                               "release", "version")], collapse = " "), 
[08:25:51.968]                             hostname = base::Sys.info()[["nodename"]])
[08:25:51.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:51.968]                             info)
[08:25:51.968]                           info <- base::paste(info, collapse = "; ")
[08:25:51.968]                           if (!has_future) {
[08:25:51.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:51.968]                               info)
[08:25:51.968]                           }
[08:25:51.968]                           else {
[08:25:51.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:51.968]                               info, version)
[08:25:51.968]                           }
[08:25:51.968]                           base::stop(msg)
[08:25:51.968]                         }
[08:25:51.968]                       })
[08:25:51.968]                     }
[08:25:51.968]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:51.968]                     base::options(mc.cores = 1L)
[08:25:51.968]                   }
[08:25:51.968]                   ...future.strategy.old <- future::plan("list")
[08:25:51.968]                   options(future.plan = NULL)
[08:25:51.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:51.968]                 }
[08:25:51.968]                 ...future.workdir <- getwd()
[08:25:51.968]             }
[08:25:51.968]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:51.968]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:51.968]         }
[08:25:51.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:51.968]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:51.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:51.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:51.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:51.968]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:51.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:51.968]             base::names(...future.oldOptions))
[08:25:51.968]     }
[08:25:51.968]     if (FALSE) {
[08:25:51.968]     }
[08:25:51.968]     else {
[08:25:51.968]         if (TRUE) {
[08:25:51.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:51.968]                 open = "w")
[08:25:51.968]         }
[08:25:51.968]         else {
[08:25:51.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:51.968]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:51.968]         }
[08:25:51.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:51.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:51.968]             base::sink(type = "output", split = FALSE)
[08:25:51.968]             base::close(...future.stdout)
[08:25:51.968]         }, add = TRUE)
[08:25:51.968]     }
[08:25:51.968]     ...future.frame <- base::sys.nframe()
[08:25:51.968]     ...future.conditions <- base::list()
[08:25:51.968]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:51.968]     if (FALSE) {
[08:25:51.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:51.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:51.968]     }
[08:25:51.968]     ...future.result <- base::tryCatch({
[08:25:51.968]         base::withCallingHandlers({
[08:25:51.968]             ...future.value <- base::withVisible(base::local({
[08:25:51.968]                 ...future.makeSendCondition <- base::local({
[08:25:51.968]                   sendCondition <- NULL
[08:25:51.968]                   function(frame = 1L) {
[08:25:51.968]                     if (is.function(sendCondition)) 
[08:25:51.968]                       return(sendCondition)
[08:25:51.968]                     ns <- getNamespace("parallel")
[08:25:51.968]                     if (exists("sendData", mode = "function", 
[08:25:51.968]                       envir = ns)) {
[08:25:51.968]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:51.968]                         envir = ns)
[08:25:51.968]                       envir <- sys.frame(frame)
[08:25:51.968]                       master <- NULL
[08:25:51.968]                       while (!identical(envir, .GlobalEnv) && 
[08:25:51.968]                         !identical(envir, emptyenv())) {
[08:25:51.968]                         if (exists("master", mode = "list", envir = envir, 
[08:25:51.968]                           inherits = FALSE)) {
[08:25:51.968]                           master <- get("master", mode = "list", 
[08:25:51.968]                             envir = envir, inherits = FALSE)
[08:25:51.968]                           if (inherits(master, c("SOCKnode", 
[08:25:51.968]                             "SOCK0node"))) {
[08:25:51.968]                             sendCondition <<- function(cond) {
[08:25:51.968]                               data <- list(type = "VALUE", value = cond, 
[08:25:51.968]                                 success = TRUE)
[08:25:51.968]                               parallel_sendData(master, data)
[08:25:51.968]                             }
[08:25:51.968]                             return(sendCondition)
[08:25:51.968]                           }
[08:25:51.968]                         }
[08:25:51.968]                         frame <- frame + 1L
[08:25:51.968]                         envir <- sys.frame(frame)
[08:25:51.968]                       }
[08:25:51.968]                     }
[08:25:51.968]                     sendCondition <<- function(cond) NULL
[08:25:51.968]                   }
[08:25:51.968]                 })
[08:25:51.968]                 withCallingHandlers({
[08:25:51.968]                   {
[08:25:51.968]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.968]                     if (!identical(...future.globals.maxSize.org, 
[08:25:51.968]                       ...future.globals.maxSize)) {
[08:25:51.968]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.968]                       on.exit(options(oopts), add = TRUE)
[08:25:51.968]                     }
[08:25:51.968]                     {
[08:25:51.968]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.968]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:51.968]                         USE.NAMES = FALSE)
[08:25:51.968]                       do.call(mapply, args = args)
[08:25:51.968]                     }
[08:25:51.968]                   }
[08:25:51.968]                 }, immediateCondition = function(cond) {
[08:25:51.968]                   sendCondition <- ...future.makeSendCondition()
[08:25:51.968]                   sendCondition(cond)
[08:25:51.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.968]                   {
[08:25:51.968]                     inherits <- base::inherits
[08:25:51.968]                     invokeRestart <- base::invokeRestart
[08:25:51.968]                     is.null <- base::is.null
[08:25:51.968]                     muffled <- FALSE
[08:25:51.968]                     if (inherits(cond, "message")) {
[08:25:51.968]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:51.968]                       if (muffled) 
[08:25:51.968]                         invokeRestart("muffleMessage")
[08:25:51.968]                     }
[08:25:51.968]                     else if (inherits(cond, "warning")) {
[08:25:51.968]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:51.968]                       if (muffled) 
[08:25:51.968]                         invokeRestart("muffleWarning")
[08:25:51.968]                     }
[08:25:51.968]                     else if (inherits(cond, "condition")) {
[08:25:51.968]                       if (!is.null(pattern)) {
[08:25:51.968]                         computeRestarts <- base::computeRestarts
[08:25:51.968]                         grepl <- base::grepl
[08:25:51.968]                         restarts <- computeRestarts(cond)
[08:25:51.968]                         for (restart in restarts) {
[08:25:51.968]                           name <- restart$name
[08:25:51.968]                           if (is.null(name)) 
[08:25:51.968]                             next
[08:25:51.968]                           if (!grepl(pattern, name)) 
[08:25:51.968]                             next
[08:25:51.968]                           invokeRestart(restart)
[08:25:51.968]                           muffled <- TRUE
[08:25:51.968]                           break
[08:25:51.968]                         }
[08:25:51.968]                       }
[08:25:51.968]                     }
[08:25:51.968]                     invisible(muffled)
[08:25:51.968]                   }
[08:25:51.968]                   muffleCondition(cond)
[08:25:51.968]                 })
[08:25:51.968]             }))
[08:25:51.968]             future::FutureResult(value = ...future.value$value, 
[08:25:51.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.968]                   ...future.rng), globalenv = if (FALSE) 
[08:25:51.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:51.968]                     ...future.globalenv.names))
[08:25:51.968]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:51.968]         }, condition = base::local({
[08:25:51.968]             c <- base::c
[08:25:51.968]             inherits <- base::inherits
[08:25:51.968]             invokeRestart <- base::invokeRestart
[08:25:51.968]             length <- base::length
[08:25:51.968]             list <- base::list
[08:25:51.968]             seq.int <- base::seq.int
[08:25:51.968]             signalCondition <- base::signalCondition
[08:25:51.968]             sys.calls <- base::sys.calls
[08:25:51.968]             `[[` <- base::`[[`
[08:25:51.968]             `+` <- base::`+`
[08:25:51.968]             `<<-` <- base::`<<-`
[08:25:51.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:51.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:51.968]                   3L)]
[08:25:51.968]             }
[08:25:51.968]             function(cond) {
[08:25:51.968]                 is_error <- inherits(cond, "error")
[08:25:51.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:51.968]                   NULL)
[08:25:51.968]                 if (is_error) {
[08:25:51.968]                   sessionInformation <- function() {
[08:25:51.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:51.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:51.968]                       search = base::search(), system = base::Sys.info())
[08:25:51.968]                   }
[08:25:51.968]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:51.968]                     cond$call), session = sessionInformation(), 
[08:25:51.968]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:51.968]                   signalCondition(cond)
[08:25:51.968]                 }
[08:25:51.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:51.968]                 "immediateCondition"))) {
[08:25:51.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:51.968]                   ...future.conditions[[length(...future.conditions) + 
[08:25:51.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:51.968]                   if (TRUE && !signal) {
[08:25:51.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.968]                     {
[08:25:51.968]                       inherits <- base::inherits
[08:25:51.968]                       invokeRestart <- base::invokeRestart
[08:25:51.968]                       is.null <- base::is.null
[08:25:51.968]                       muffled <- FALSE
[08:25:51.968]                       if (inherits(cond, "message")) {
[08:25:51.968]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.968]                         if (muffled) 
[08:25:51.968]                           invokeRestart("muffleMessage")
[08:25:51.968]                       }
[08:25:51.968]                       else if (inherits(cond, "warning")) {
[08:25:51.968]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.968]                         if (muffled) 
[08:25:51.968]                           invokeRestart("muffleWarning")
[08:25:51.968]                       }
[08:25:51.968]                       else if (inherits(cond, "condition")) {
[08:25:51.968]                         if (!is.null(pattern)) {
[08:25:51.968]                           computeRestarts <- base::computeRestarts
[08:25:51.968]                           grepl <- base::grepl
[08:25:51.968]                           restarts <- computeRestarts(cond)
[08:25:51.968]                           for (restart in restarts) {
[08:25:51.968]                             name <- restart$name
[08:25:51.968]                             if (is.null(name)) 
[08:25:51.968]                               next
[08:25:51.968]                             if (!grepl(pattern, name)) 
[08:25:51.968]                               next
[08:25:51.968]                             invokeRestart(restart)
[08:25:51.968]                             muffled <- TRUE
[08:25:51.968]                             break
[08:25:51.968]                           }
[08:25:51.968]                         }
[08:25:51.968]                       }
[08:25:51.968]                       invisible(muffled)
[08:25:51.968]                     }
[08:25:51.968]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.968]                   }
[08:25:51.968]                 }
[08:25:51.968]                 else {
[08:25:51.968]                   if (TRUE) {
[08:25:51.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:51.968]                     {
[08:25:51.968]                       inherits <- base::inherits
[08:25:51.968]                       invokeRestart <- base::invokeRestart
[08:25:51.968]                       is.null <- base::is.null
[08:25:51.968]                       muffled <- FALSE
[08:25:51.968]                       if (inherits(cond, "message")) {
[08:25:51.968]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:51.968]                         if (muffled) 
[08:25:51.968]                           invokeRestart("muffleMessage")
[08:25:51.968]                       }
[08:25:51.968]                       else if (inherits(cond, "warning")) {
[08:25:51.968]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:51.968]                         if (muffled) 
[08:25:51.968]                           invokeRestart("muffleWarning")
[08:25:51.968]                       }
[08:25:51.968]                       else if (inherits(cond, "condition")) {
[08:25:51.968]                         if (!is.null(pattern)) {
[08:25:51.968]                           computeRestarts <- base::computeRestarts
[08:25:51.968]                           grepl <- base::grepl
[08:25:51.968]                           restarts <- computeRestarts(cond)
[08:25:51.968]                           for (restart in restarts) {
[08:25:51.968]                             name <- restart$name
[08:25:51.968]                             if (is.null(name)) 
[08:25:51.968]                               next
[08:25:51.968]                             if (!grepl(pattern, name)) 
[08:25:51.968]                               next
[08:25:51.968]                             invokeRestart(restart)
[08:25:51.968]                             muffled <- TRUE
[08:25:51.968]                             break
[08:25:51.968]                           }
[08:25:51.968]                         }
[08:25:51.968]                       }
[08:25:51.968]                       invisible(muffled)
[08:25:51.968]                     }
[08:25:51.968]                     muffleCondition(cond, pattern = "^muffle")
[08:25:51.968]                   }
[08:25:51.968]                 }
[08:25:51.968]             }
[08:25:51.968]         }))
[08:25:51.968]     }, error = function(ex) {
[08:25:51.968]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:51.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:51.968]                 ...future.rng), started = ...future.startTime, 
[08:25:51.968]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:51.968]             version = "1.8"), class = "FutureResult")
[08:25:51.968]     }, finally = {
[08:25:51.968]         if (!identical(...future.workdir, getwd())) 
[08:25:51.968]             setwd(...future.workdir)
[08:25:51.968]         {
[08:25:51.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:51.968]                 ...future.oldOptions$nwarnings <- NULL
[08:25:51.968]             }
[08:25:51.968]             base::options(...future.oldOptions)
[08:25:51.968]             if (.Platform$OS.type == "windows") {
[08:25:51.968]                 old_names <- names(...future.oldEnvVars)
[08:25:51.968]                 envs <- base::Sys.getenv()
[08:25:51.968]                 names <- names(envs)
[08:25:51.968]                 common <- intersect(names, old_names)
[08:25:51.968]                 added <- setdiff(names, old_names)
[08:25:51.968]                 removed <- setdiff(old_names, names)
[08:25:51.968]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:51.968]                   envs[common]]
[08:25:51.968]                 NAMES <- toupper(changed)
[08:25:51.968]                 args <- list()
[08:25:51.968]                 for (kk in seq_along(NAMES)) {
[08:25:51.968]                   name <- changed[[kk]]
[08:25:51.968]                   NAME <- NAMES[[kk]]
[08:25:51.968]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.968]                     next
[08:25:51.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.968]                 }
[08:25:51.968]                 NAMES <- toupper(added)
[08:25:51.968]                 for (kk in seq_along(NAMES)) {
[08:25:51.968]                   name <- added[[kk]]
[08:25:51.968]                   NAME <- NAMES[[kk]]
[08:25:51.968]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.968]                     next
[08:25:51.968]                   args[[name]] <- ""
[08:25:51.968]                 }
[08:25:51.968]                 NAMES <- toupper(removed)
[08:25:51.968]                 for (kk in seq_along(NAMES)) {
[08:25:51.968]                   name <- removed[[kk]]
[08:25:51.968]                   NAME <- NAMES[[kk]]
[08:25:51.968]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:51.968]                     next
[08:25:51.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:51.968]                 }
[08:25:51.968]                 if (length(args) > 0) 
[08:25:51.968]                   base::do.call(base::Sys.setenv, args = args)
[08:25:51.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:51.968]             }
[08:25:51.968]             else {
[08:25:51.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:51.968]             }
[08:25:51.968]             {
[08:25:51.968]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:51.968]                   0L) {
[08:25:51.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:51.968]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:51.968]                   base::options(opts)
[08:25:51.968]                 }
[08:25:51.968]                 {
[08:25:51.968]                   {
[08:25:51.968]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:51.968]                     NULL
[08:25:51.968]                   }
[08:25:51.968]                   options(future.plan = NULL)
[08:25:51.968]                   if (is.na(NA_character_)) 
[08:25:51.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:51.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:51.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:51.968]                     .init = FALSE)
[08:25:51.968]                 }
[08:25:51.968]             }
[08:25:51.968]         }
[08:25:51.968]     })
[08:25:51.968]     if (TRUE) {
[08:25:51.968]         base::sink(type = "output", split = FALSE)
[08:25:51.968]         if (TRUE) {
[08:25:51.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:51.968]         }
[08:25:51.968]         else {
[08:25:51.968]             ...future.result["stdout"] <- base::list(NULL)
[08:25:51.968]         }
[08:25:51.968]         base::close(...future.stdout)
[08:25:51.968]         ...future.stdout <- NULL
[08:25:51.968]     }
[08:25:51.968]     ...future.result$conditions <- ...future.conditions
[08:25:51.968]     ...future.result$finished <- base::Sys.time()
[08:25:51.968]     ...future.result
[08:25:51.968] }
[08:25:51.971] Exporting 5 global objects (1.11 KiB) to cluster node #2 ...
[08:25:51.971] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ...
[08:25:51.972] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ... DONE
[08:25:51.972] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:51.972] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.972] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ...
[08:25:51.973] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ... DONE
[08:25:51.973] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:51.973] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.973] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:51.974] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:51.974] Exporting 5 global objects (1.11 KiB) to cluster node #2 ... DONE
[08:25:51.974] MultisessionFuture started
[08:25:51.974] - Launch lazy future ... done
[08:25:51.974] run() for ‘MultisessionFuture’ ... done
[08:25:51.974] Created future:
[08:25:51.975] MultisessionFuture:
[08:25:51.975] Label: ‘future_mapply-2’
[08:25:51.975] Expression:
[08:25:51.975] {
[08:25:51.975]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:51.975]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:51.975]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:51.975]         on.exit(options(oopts), add = TRUE)
[08:25:51.975]     }
[08:25:51.975]     {
[08:25:51.975]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:51.975]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:51.975]         do.call(mapply, args = args)
[08:25:51.975]     }
[08:25:51.975] }
[08:25:51.975] Lazy evaluation: FALSE
[08:25:51.975] Asynchronous evaluation: TRUE
[08:25:51.975] Local evaluation: TRUE
[08:25:51.975] Environment: R_GlobalEnv
[08:25:51.975] Capture standard output: TRUE
[08:25:51.975] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:51.975] Globals: 5 objects totaling 695 bytes (function ‘...future.FUN’ of 414 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:51.975] Packages: <none>
[08:25:51.975] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:51.975] Resolved: FALSE
[08:25:51.975] Value: <not collected>
[08:25:51.975] Conditions captured: <none>
[08:25:51.975] Early signaling: FALSE
[08:25:51.975] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:51.975] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:51.986] Chunk #2 of 2 ... DONE
[08:25:51.986] Launching 2 futures (chunks) ... DONE
[08:25:51.986] Resolving 2 futures (chunks) ...
[08:25:51.986] resolve() on list ...
[08:25:51.986]  recursive: 0
[08:25:51.987]  length: 2
[08:25:51.987] 
[08:25:51.987] receiveMessageFromWorker() for ClusterFuture ...
[08:25:51.987] - Validating connection of MultisessionFuture
[08:25:51.987] - received message: FutureResult
[08:25:51.988] - Received FutureResult
[08:25:51.988] - Erased future from FutureRegistry
[08:25:51.988] result() for ClusterFuture ...
[08:25:51.988] - result already collected: FutureResult
[08:25:51.988] result() for ClusterFuture ... done
[08:25:51.988] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:51.988] Future #1
[08:25:51.988] result() for ClusterFuture ...
[08:25:51.988] - result already collected: FutureResult
[08:25:51.988] result() for ClusterFuture ... done
[08:25:51.988] result() for ClusterFuture ...
[08:25:51.988] - result already collected: FutureResult
[08:25:51.989] result() for ClusterFuture ... done
[08:25:51.989] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:51.989] - nx: 2
[08:25:51.989] - relay: TRUE
[08:25:51.989] - stdout: TRUE
[08:25:51.989] - signal: TRUE
[08:25:51.989] - resignal: FALSE
[08:25:51.989] - force: TRUE
[08:25:51.989] - relayed: [n=2] FALSE, FALSE
[08:25:51.989] - queued futures: [n=2] FALSE, FALSE
[08:25:51.989]  - until=1
[08:25:51.989]  - relaying element #1
[08:25:51.990] result() for ClusterFuture ...
[08:25:51.990] - result already collected: FutureResult
[08:25:51.990] result() for ClusterFuture ... done
[08:25:51.990] result() for ClusterFuture ...
[08:25:51.990] - result already collected: FutureResult
[08:25:51.990] result() for ClusterFuture ... done
[08:25:51.990] result() for ClusterFuture ...
[08:25:51.990] - result already collected: FutureResult
[08:25:51.990] result() for ClusterFuture ... done
[08:25:51.990] result() for ClusterFuture ...
[08:25:51.990] - result already collected: FutureResult
[08:25:51.990] result() for ClusterFuture ... done
[08:25:51.991] - relayed: [n=2] TRUE, FALSE
[08:25:51.991] - queued futures: [n=2] TRUE, FALSE
[08:25:51.991] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:51.991]  length: 1 (resolved future 1)
[08:25:52.016] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.017] - Validating connection of MultisessionFuture
[08:25:52.017] - received message: FutureResult
[08:25:52.017] - Received FutureResult
[08:25:52.017] - Erased future from FutureRegistry
[08:25:52.017] result() for ClusterFuture ...
[08:25:52.017] - result already collected: FutureResult
[08:25:52.017] result() for ClusterFuture ... done
[08:25:52.017] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.017] Future #2
[08:25:52.018] result() for ClusterFuture ...
[08:25:52.018] - result already collected: FutureResult
[08:25:52.018] result() for ClusterFuture ... done
[08:25:52.018] result() for ClusterFuture ...
[08:25:52.018] - result already collected: FutureResult
[08:25:52.018] result() for ClusterFuture ... done
[08:25:52.018] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:52.018] - nx: 2
[08:25:52.018] - relay: TRUE
[08:25:52.018] - stdout: TRUE
[08:25:52.018] - signal: TRUE
[08:25:52.019] - resignal: FALSE
[08:25:52.019] - force: TRUE
[08:25:52.019] - relayed: [n=2] TRUE, FALSE
[08:25:52.019] - queued futures: [n=2] TRUE, FALSE
[08:25:52.019]  - until=2
[08:25:52.019]  - relaying element #2
[08:25:52.019] result() for ClusterFuture ...
[08:25:52.019] - result already collected: FutureResult
[08:25:52.019] result() for ClusterFuture ... done
[08:25:52.019] result() for ClusterFuture ...
[08:25:52.019] - result already collected: FutureResult
[08:25:52.019] result() for ClusterFuture ... done
[08:25:52.020] result() for ClusterFuture ...
[08:25:52.020] - result already collected: FutureResult
[08:25:52.020] result() for ClusterFuture ... done
[08:25:52.020] result() for ClusterFuture ...
[08:25:52.020] - result already collected: FutureResult
[08:25:52.020] result() for ClusterFuture ... done
[08:25:52.020] - relayed: [n=2] TRUE, TRUE
[08:25:52.020] - queued futures: [n=2] TRUE, TRUE
[08:25:52.020] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:52.020]  length: 0 (resolved future 2)
[08:25:52.020] Relaying remaining futures
[08:25:52.020] signalConditionsASAP(NULL, pos=0) ...
[08:25:52.021] - nx: 2
[08:25:52.021] - relay: TRUE
[08:25:52.021] - stdout: TRUE
[08:25:52.021] - signal: TRUE
[08:25:52.021] - resignal: FALSE
[08:25:52.021] - force: TRUE
[08:25:52.021] - relayed: [n=2] TRUE, TRUE
[08:25:52.021] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:52.021] - relayed: [n=2] TRUE, TRUE
[08:25:52.021] - queued futures: [n=2] TRUE, TRUE
[08:25:52.021] signalConditionsASAP(NULL, pos=0) ... done
[08:25:52.021] resolve() on list ... DONE
[08:25:52.022] result() for ClusterFuture ...
[08:25:52.022] - result already collected: FutureResult
[08:25:52.022] result() for ClusterFuture ... done
[08:25:52.022] result() for ClusterFuture ...
[08:25:52.022] - result already collected: FutureResult
[08:25:52.022] result() for ClusterFuture ... done
[08:25:52.022] result() for ClusterFuture ...
[08:25:52.022] - result already collected: FutureResult
[08:25:52.022] result() for ClusterFuture ... done
[08:25:52.022] result() for ClusterFuture ...
[08:25:52.022] - result already collected: FutureResult
[08:25:52.022] result() for ClusterFuture ... done
[08:25:52.023]  - Number of value chunks collected: 2
[08:25:52.023] Resolving 2 futures (chunks) ... DONE
[08:25:52.023] Reducing values from 2 chunks ...
[08:25:52.023]  - Number of values collected after concatenation: 3
[08:25:52.023]  - Number of values expected: 3
[08:25:52.023] Reducing values from 2 chunks ... DONE
[08:25:52.023] future_mapply() ... DONE
- future_.mapply()
[08:25:52.023] future_mapply() ...
[08:25:52.025] Number of chunks: 2
[08:25:52.025] getGlobalsAndPackagesXApply() ...
[08:25:52.025]  - future.globals: TRUE
[08:25:52.025] getGlobalsAndPackages() ...
[08:25:52.026] Searching for globals...
[08:25:52.027] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[08:25:52.027] Searching for globals ... DONE
[08:25:52.027] Resolving globals: FALSE
[08:25:52.027] The total size of the 1 globals is 414 bytes (414 bytes)
[08:25:52.028] The total size of the 1 globals exported for future expression (‘FUN()’) is 414 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (414 bytes of class ‘function’)
[08:25:52.028] - globals: [1] ‘FUN’
[08:25:52.028] 
[08:25:52.028] getGlobalsAndPackages() ... DONE
[08:25:52.028]  - globals found/used: [n=1] ‘FUN’
[08:25:52.028]  - needed namespaces: [n=0] 
[08:25:52.028] Finding globals ... DONE
[08:25:52.028] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:52.029] List of 2
[08:25:52.029]  $ ...future.FUN:function (x, y)  
[08:25:52.029]  $ MoreArgs     : list()
[08:25:52.029]  - attr(*, "where")=List of 2
[08:25:52.029]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:52.029]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:52.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:52.029]  - attr(*, "resolved")= logi FALSE
[08:25:52.029]  - attr(*, "total_size")= num NA
[08:25:52.031] Packages to be attached in all futures: [n=0] 
[08:25:52.031] getGlobalsAndPackagesXApply() ... DONE
[08:25:52.031] Number of futures (= number of chunks): 2
[08:25:52.031] Launching 2 futures (chunks) ...
[08:25:52.032] Chunk #1 of 2 ...
[08:25:52.032]  - Finding globals in '...' for chunk #1 ...
[08:25:52.032] getGlobalsAndPackages() ...
[08:25:52.032] Searching for globals...
[08:25:52.032] 
[08:25:52.032] Searching for globals ... DONE
[08:25:52.032] - globals: [0] <none>
[08:25:52.032] getGlobalsAndPackages() ... DONE
[08:25:52.032]    + additional globals found: [n=0] 
[08:25:52.033]    + additional namespaces needed: [n=0] 
[08:25:52.033]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:52.033]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:52.033]  - seeds: <none>
[08:25:52.033]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.033] getGlobalsAndPackages() ...
[08:25:52.033] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.033] Resolving globals: FALSE
[08:25:52.034] The total size of the 5 globals is 649 bytes (649 bytes)
[08:25:52.034] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 649 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (150 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:52.034] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.034] 
[08:25:52.034] getGlobalsAndPackages() ... DONE
[08:25:52.035] run() for ‘Future’ ...
[08:25:52.035] - state: ‘created’
[08:25:52.035] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.048] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.049]   - Field: ‘node’
[08:25:52.049]   - Field: ‘label’
[08:25:52.049]   - Field: ‘local’
[08:25:52.049]   - Field: ‘owner’
[08:25:52.049]   - Field: ‘envir’
[08:25:52.049]   - Field: ‘workers’
[08:25:52.049]   - Field: ‘packages’
[08:25:52.049]   - Field: ‘gc’
[08:25:52.049]   - Field: ‘conditions’
[08:25:52.049]   - Field: ‘persistent’
[08:25:52.050]   - Field: ‘expr’
[08:25:52.050]   - Field: ‘uuid’
[08:25:52.050]   - Field: ‘seed’
[08:25:52.050]   - Field: ‘version’
[08:25:52.050]   - Field: ‘result’
[08:25:52.050]   - Field: ‘asynchronous’
[08:25:52.050]   - Field: ‘calls’
[08:25:52.050]   - Field: ‘globals’
[08:25:52.050]   - Field: ‘stdout’
[08:25:52.050]   - Field: ‘earlySignal’
[08:25:52.050]   - Field: ‘lazy’
[08:25:52.051]   - Field: ‘state’
[08:25:52.051] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.051] - Launch lazy future ...
[08:25:52.051] Packages needed by the future expression (n = 0): <none>
[08:25:52.051] Packages needed by future strategies (n = 0): <none>
[08:25:52.052] {
[08:25:52.052]     {
[08:25:52.052]         {
[08:25:52.052]             ...future.startTime <- base::Sys.time()
[08:25:52.052]             {
[08:25:52.052]                 {
[08:25:52.052]                   {
[08:25:52.052]                     {
[08:25:52.052]                       base::local({
[08:25:52.052]                         has_future <- base::requireNamespace("future", 
[08:25:52.052]                           quietly = TRUE)
[08:25:52.052]                         if (has_future) {
[08:25:52.052]                           ns <- base::getNamespace("future")
[08:25:52.052]                           version <- ns[[".package"]][["version"]]
[08:25:52.052]                           if (is.null(version)) 
[08:25:52.052]                             version <- utils::packageVersion("future")
[08:25:52.052]                         }
[08:25:52.052]                         else {
[08:25:52.052]                           version <- NULL
[08:25:52.052]                         }
[08:25:52.052]                         if (!has_future || version < "1.8.0") {
[08:25:52.052]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.052]                             "", base::R.version$version.string), 
[08:25:52.052]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.052]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.052]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.052]                               "release", "version")], collapse = " "), 
[08:25:52.052]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.052]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.052]                             info)
[08:25:52.052]                           info <- base::paste(info, collapse = "; ")
[08:25:52.052]                           if (!has_future) {
[08:25:52.052]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.052]                               info)
[08:25:52.052]                           }
[08:25:52.052]                           else {
[08:25:52.052]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.052]                               info, version)
[08:25:52.052]                           }
[08:25:52.052]                           base::stop(msg)
[08:25:52.052]                         }
[08:25:52.052]                       })
[08:25:52.052]                     }
[08:25:52.052]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.052]                     base::options(mc.cores = 1L)
[08:25:52.052]                   }
[08:25:52.052]                   ...future.strategy.old <- future::plan("list")
[08:25:52.052]                   options(future.plan = NULL)
[08:25:52.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.052]                 }
[08:25:52.052]                 ...future.workdir <- getwd()
[08:25:52.052]             }
[08:25:52.052]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.052]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.052]         }
[08:25:52.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.052]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:52.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.052]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.052]             base::names(...future.oldOptions))
[08:25:52.052]     }
[08:25:52.052]     if (FALSE) {
[08:25:52.052]     }
[08:25:52.052]     else {
[08:25:52.052]         if (TRUE) {
[08:25:52.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.052]                 open = "w")
[08:25:52.052]         }
[08:25:52.052]         else {
[08:25:52.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.052]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.052]         }
[08:25:52.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.052]             base::sink(type = "output", split = FALSE)
[08:25:52.052]             base::close(...future.stdout)
[08:25:52.052]         }, add = TRUE)
[08:25:52.052]     }
[08:25:52.052]     ...future.frame <- base::sys.nframe()
[08:25:52.052]     ...future.conditions <- base::list()
[08:25:52.052]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.052]     if (FALSE) {
[08:25:52.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.052]     }
[08:25:52.052]     ...future.result <- base::tryCatch({
[08:25:52.052]         base::withCallingHandlers({
[08:25:52.052]             ...future.value <- base::withVisible(base::local({
[08:25:52.052]                 ...future.makeSendCondition <- base::local({
[08:25:52.052]                   sendCondition <- NULL
[08:25:52.052]                   function(frame = 1L) {
[08:25:52.052]                     if (is.function(sendCondition)) 
[08:25:52.052]                       return(sendCondition)
[08:25:52.052]                     ns <- getNamespace("parallel")
[08:25:52.052]                     if (exists("sendData", mode = "function", 
[08:25:52.052]                       envir = ns)) {
[08:25:52.052]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.052]                         envir = ns)
[08:25:52.052]                       envir <- sys.frame(frame)
[08:25:52.052]                       master <- NULL
[08:25:52.052]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.052]                         !identical(envir, emptyenv())) {
[08:25:52.052]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.052]                           inherits = FALSE)) {
[08:25:52.052]                           master <- get("master", mode = "list", 
[08:25:52.052]                             envir = envir, inherits = FALSE)
[08:25:52.052]                           if (inherits(master, c("SOCKnode", 
[08:25:52.052]                             "SOCK0node"))) {
[08:25:52.052]                             sendCondition <<- function(cond) {
[08:25:52.052]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.052]                                 success = TRUE)
[08:25:52.052]                               parallel_sendData(master, data)
[08:25:52.052]                             }
[08:25:52.052]                             return(sendCondition)
[08:25:52.052]                           }
[08:25:52.052]                         }
[08:25:52.052]                         frame <- frame + 1L
[08:25:52.052]                         envir <- sys.frame(frame)
[08:25:52.052]                       }
[08:25:52.052]                     }
[08:25:52.052]                     sendCondition <<- function(cond) NULL
[08:25:52.052]                   }
[08:25:52.052]                 })
[08:25:52.052]                 withCallingHandlers({
[08:25:52.052]                   {
[08:25:52.052]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.052]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.052]                       ...future.globals.maxSize)) {
[08:25:52.052]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.052]                       on.exit(options(oopts), add = TRUE)
[08:25:52.052]                     }
[08:25:52.052]                     {
[08:25:52.052]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.052]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.052]                         USE.NAMES = FALSE)
[08:25:52.052]                       do.call(mapply, args = args)
[08:25:52.052]                     }
[08:25:52.052]                   }
[08:25:52.052]                 }, immediateCondition = function(cond) {
[08:25:52.052]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.052]                   sendCondition(cond)
[08:25:52.052]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.052]                   {
[08:25:52.052]                     inherits <- base::inherits
[08:25:52.052]                     invokeRestart <- base::invokeRestart
[08:25:52.052]                     is.null <- base::is.null
[08:25:52.052]                     muffled <- FALSE
[08:25:52.052]                     if (inherits(cond, "message")) {
[08:25:52.052]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.052]                       if (muffled) 
[08:25:52.052]                         invokeRestart("muffleMessage")
[08:25:52.052]                     }
[08:25:52.052]                     else if (inherits(cond, "warning")) {
[08:25:52.052]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.052]                       if (muffled) 
[08:25:52.052]                         invokeRestart("muffleWarning")
[08:25:52.052]                     }
[08:25:52.052]                     else if (inherits(cond, "condition")) {
[08:25:52.052]                       if (!is.null(pattern)) {
[08:25:52.052]                         computeRestarts <- base::computeRestarts
[08:25:52.052]                         grepl <- base::grepl
[08:25:52.052]                         restarts <- computeRestarts(cond)
[08:25:52.052]                         for (restart in restarts) {
[08:25:52.052]                           name <- restart$name
[08:25:52.052]                           if (is.null(name)) 
[08:25:52.052]                             next
[08:25:52.052]                           if (!grepl(pattern, name)) 
[08:25:52.052]                             next
[08:25:52.052]                           invokeRestart(restart)
[08:25:52.052]                           muffled <- TRUE
[08:25:52.052]                           break
[08:25:52.052]                         }
[08:25:52.052]                       }
[08:25:52.052]                     }
[08:25:52.052]                     invisible(muffled)
[08:25:52.052]                   }
[08:25:52.052]                   muffleCondition(cond)
[08:25:52.052]                 })
[08:25:52.052]             }))
[08:25:52.052]             future::FutureResult(value = ...future.value$value, 
[08:25:52.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.052]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.052]                     ...future.globalenv.names))
[08:25:52.052]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.052]         }, condition = base::local({
[08:25:52.052]             c <- base::c
[08:25:52.052]             inherits <- base::inherits
[08:25:52.052]             invokeRestart <- base::invokeRestart
[08:25:52.052]             length <- base::length
[08:25:52.052]             list <- base::list
[08:25:52.052]             seq.int <- base::seq.int
[08:25:52.052]             signalCondition <- base::signalCondition
[08:25:52.052]             sys.calls <- base::sys.calls
[08:25:52.052]             `[[` <- base::`[[`
[08:25:52.052]             `+` <- base::`+`
[08:25:52.052]             `<<-` <- base::`<<-`
[08:25:52.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.052]                   3L)]
[08:25:52.052]             }
[08:25:52.052]             function(cond) {
[08:25:52.052]                 is_error <- inherits(cond, "error")
[08:25:52.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.052]                   NULL)
[08:25:52.052]                 if (is_error) {
[08:25:52.052]                   sessionInformation <- function() {
[08:25:52.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.052]                       search = base::search(), system = base::Sys.info())
[08:25:52.052]                   }
[08:25:52.052]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.052]                     cond$call), session = sessionInformation(), 
[08:25:52.052]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.052]                   signalCondition(cond)
[08:25:52.052]                 }
[08:25:52.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.052]                 "immediateCondition"))) {
[08:25:52.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.052]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.052]                   if (TRUE && !signal) {
[08:25:52.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.052]                     {
[08:25:52.052]                       inherits <- base::inherits
[08:25:52.052]                       invokeRestart <- base::invokeRestart
[08:25:52.052]                       is.null <- base::is.null
[08:25:52.052]                       muffled <- FALSE
[08:25:52.052]                       if (inherits(cond, "message")) {
[08:25:52.052]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.052]                         if (muffled) 
[08:25:52.052]                           invokeRestart("muffleMessage")
[08:25:52.052]                       }
[08:25:52.052]                       else if (inherits(cond, "warning")) {
[08:25:52.052]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.052]                         if (muffled) 
[08:25:52.052]                           invokeRestart("muffleWarning")
[08:25:52.052]                       }
[08:25:52.052]                       else if (inherits(cond, "condition")) {
[08:25:52.052]                         if (!is.null(pattern)) {
[08:25:52.052]                           computeRestarts <- base::computeRestarts
[08:25:52.052]                           grepl <- base::grepl
[08:25:52.052]                           restarts <- computeRestarts(cond)
[08:25:52.052]                           for (restart in restarts) {
[08:25:52.052]                             name <- restart$name
[08:25:52.052]                             if (is.null(name)) 
[08:25:52.052]                               next
[08:25:52.052]                             if (!grepl(pattern, name)) 
[08:25:52.052]                               next
[08:25:52.052]                             invokeRestart(restart)
[08:25:52.052]                             muffled <- TRUE
[08:25:52.052]                             break
[08:25:52.052]                           }
[08:25:52.052]                         }
[08:25:52.052]                       }
[08:25:52.052]                       invisible(muffled)
[08:25:52.052]                     }
[08:25:52.052]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.052]                   }
[08:25:52.052]                 }
[08:25:52.052]                 else {
[08:25:52.052]                   if (TRUE) {
[08:25:52.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.052]                     {
[08:25:52.052]                       inherits <- base::inherits
[08:25:52.052]                       invokeRestart <- base::invokeRestart
[08:25:52.052]                       is.null <- base::is.null
[08:25:52.052]                       muffled <- FALSE
[08:25:52.052]                       if (inherits(cond, "message")) {
[08:25:52.052]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.052]                         if (muffled) 
[08:25:52.052]                           invokeRestart("muffleMessage")
[08:25:52.052]                       }
[08:25:52.052]                       else if (inherits(cond, "warning")) {
[08:25:52.052]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.052]                         if (muffled) 
[08:25:52.052]                           invokeRestart("muffleWarning")
[08:25:52.052]                       }
[08:25:52.052]                       else if (inherits(cond, "condition")) {
[08:25:52.052]                         if (!is.null(pattern)) {
[08:25:52.052]                           computeRestarts <- base::computeRestarts
[08:25:52.052]                           grepl <- base::grepl
[08:25:52.052]                           restarts <- computeRestarts(cond)
[08:25:52.052]                           for (restart in restarts) {
[08:25:52.052]                             name <- restart$name
[08:25:52.052]                             if (is.null(name)) 
[08:25:52.052]                               next
[08:25:52.052]                             if (!grepl(pattern, name)) 
[08:25:52.052]                               next
[08:25:52.052]                             invokeRestart(restart)
[08:25:52.052]                             muffled <- TRUE
[08:25:52.052]                             break
[08:25:52.052]                           }
[08:25:52.052]                         }
[08:25:52.052]                       }
[08:25:52.052]                       invisible(muffled)
[08:25:52.052]                     }
[08:25:52.052]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.052]                   }
[08:25:52.052]                 }
[08:25:52.052]             }
[08:25:52.052]         }))
[08:25:52.052]     }, error = function(ex) {
[08:25:52.052]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.052]                 ...future.rng), started = ...future.startTime, 
[08:25:52.052]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.052]             version = "1.8"), class = "FutureResult")
[08:25:52.052]     }, finally = {
[08:25:52.052]         if (!identical(...future.workdir, getwd())) 
[08:25:52.052]             setwd(...future.workdir)
[08:25:52.052]         {
[08:25:52.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.052]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.052]             }
[08:25:52.052]             base::options(...future.oldOptions)
[08:25:52.052]             if (.Platform$OS.type == "windows") {
[08:25:52.052]                 old_names <- names(...future.oldEnvVars)
[08:25:52.052]                 envs <- base::Sys.getenv()
[08:25:52.052]                 names <- names(envs)
[08:25:52.052]                 common <- intersect(names, old_names)
[08:25:52.052]                 added <- setdiff(names, old_names)
[08:25:52.052]                 removed <- setdiff(old_names, names)
[08:25:52.052]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.052]                   envs[common]]
[08:25:52.052]                 NAMES <- toupper(changed)
[08:25:52.052]                 args <- list()
[08:25:52.052]                 for (kk in seq_along(NAMES)) {
[08:25:52.052]                   name <- changed[[kk]]
[08:25:52.052]                   NAME <- NAMES[[kk]]
[08:25:52.052]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.052]                     next
[08:25:52.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.052]                 }
[08:25:52.052]                 NAMES <- toupper(added)
[08:25:52.052]                 for (kk in seq_along(NAMES)) {
[08:25:52.052]                   name <- added[[kk]]
[08:25:52.052]                   NAME <- NAMES[[kk]]
[08:25:52.052]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.052]                     next
[08:25:52.052]                   args[[name]] <- ""
[08:25:52.052]                 }
[08:25:52.052]                 NAMES <- toupper(removed)
[08:25:52.052]                 for (kk in seq_along(NAMES)) {
[08:25:52.052]                   name <- removed[[kk]]
[08:25:52.052]                   NAME <- NAMES[[kk]]
[08:25:52.052]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.052]                     next
[08:25:52.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.052]                 }
[08:25:52.052]                 if (length(args) > 0) 
[08:25:52.052]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.052]             }
[08:25:52.052]             else {
[08:25:52.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.052]             }
[08:25:52.052]             {
[08:25:52.052]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.052]                   0L) {
[08:25:52.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.052]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.052]                   base::options(opts)
[08:25:52.052]                 }
[08:25:52.052]                 {
[08:25:52.052]                   {
[08:25:52.052]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.052]                     NULL
[08:25:52.052]                   }
[08:25:52.052]                   options(future.plan = NULL)
[08:25:52.052]                   if (is.na(NA_character_)) 
[08:25:52.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.052]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.052]                     .init = FALSE)
[08:25:52.052]                 }
[08:25:52.052]             }
[08:25:52.052]         }
[08:25:52.052]     })
[08:25:52.052]     if (TRUE) {
[08:25:52.052]         base::sink(type = "output", split = FALSE)
[08:25:52.052]         if (TRUE) {
[08:25:52.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.052]         }
[08:25:52.052]         else {
[08:25:52.052]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.052]         }
[08:25:52.052]         base::close(...future.stdout)
[08:25:52.052]         ...future.stdout <- NULL
[08:25:52.052]     }
[08:25:52.052]     ...future.result$conditions <- ...future.conditions
[08:25:52.052]     ...future.result$finished <- base::Sys.time()
[08:25:52.052]     ...future.result
[08:25:52.052] }
[08:25:52.055] Exporting 5 global objects (1.06 KiB) to cluster node #1 ...
[08:25:52.055] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ...
[08:25:52.055] Exporting ‘...future.FUN’ (414 bytes) to cluster node #1 ... DONE
[08:25:52.055] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[08:25:52.056] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[08:25:52.056] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ...
[08:25:52.056] Exporting ‘...future.elements_ii’ (150 bytes) to cluster node #1 ... DONE
[08:25:52.056] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:52.057] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.057] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:52.057] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.057] Exporting 5 global objects (1.06 KiB) to cluster node #1 ... DONE
[08:25:52.058] MultisessionFuture started
[08:25:52.058] - Launch lazy future ... done
[08:25:52.058] run() for ‘MultisessionFuture’ ... done
[08:25:52.058] Created future:
[08:25:52.058] MultisessionFuture:
[08:25:52.058] Label: ‘future_.mapply-1’
[08:25:52.058] Expression:
[08:25:52.058] {
[08:25:52.058]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.058]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.058]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.058]         on.exit(options(oopts), add = TRUE)
[08:25:52.058]     }
[08:25:52.058]     {
[08:25:52.058]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.058]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.058]         do.call(mapply, args = args)
[08:25:52.058]     }
[08:25:52.058] }
[08:25:52.058] Lazy evaluation: FALSE
[08:25:52.058] Asynchronous evaluation: TRUE
[08:25:52.058] Local evaluation: TRUE
[08:25:52.058] Environment: R_GlobalEnv
[08:25:52.058] Capture standard output: TRUE
[08:25:52.058] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.058] Globals: 5 objects totaling 649 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 150 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.058] Packages: <none>
[08:25:52.058] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.058] Resolved: FALSE
[08:25:52.058] Value: <not collected>
[08:25:52.058] Conditions captured: <none>
[08:25:52.058] Early signaling: FALSE
[08:25:52.058] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.058] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.069] Chunk #1 of 2 ... DONE
[08:25:52.070] Chunk #2 of 2 ...
[08:25:52.070]  - Finding globals in '...' for chunk #2 ...
[08:25:52.070] getGlobalsAndPackages() ...
[08:25:52.070] Searching for globals...
[08:25:52.070] 
[08:25:52.071] Searching for globals ... DONE
[08:25:52.071] - globals: [0] <none>
[08:25:52.071] getGlobalsAndPackages() ... DONE
[08:25:52.071]    + additional globals found: [n=0] 
[08:25:52.071]    + additional namespaces needed: [n=0] 
[08:25:52.071]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:52.071]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:52.071]  - seeds: <none>
[08:25:52.071]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.071] getGlobalsAndPackages() ...
[08:25:52.071] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.072] Resolving globals: FALSE
[08:25:52.072] The total size of the 5 globals is 699 bytes (699 bytes)
[08:25:52.072] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 699 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (414 bytes of class ‘function’), ‘...future.elements_ii’ (200 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:52.073] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.073] 
[08:25:52.073] getGlobalsAndPackages() ... DONE
[08:25:52.073] run() for ‘Future’ ...
[08:25:52.073] - state: ‘created’
[08:25:52.073] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.087] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.087]   - Field: ‘node’
[08:25:52.087]   - Field: ‘label’
[08:25:52.087]   - Field: ‘local’
[08:25:52.088]   - Field: ‘owner’
[08:25:52.088]   - Field: ‘envir’
[08:25:52.088]   - Field: ‘workers’
[08:25:52.088]   - Field: ‘packages’
[08:25:52.088]   - Field: ‘gc’
[08:25:52.088]   - Field: ‘conditions’
[08:25:52.088]   - Field: ‘persistent’
[08:25:52.088]   - Field: ‘expr’
[08:25:52.088]   - Field: ‘uuid’
[08:25:52.088]   - Field: ‘seed’
[08:25:52.088]   - Field: ‘version’
[08:25:52.089]   - Field: ‘result’
[08:25:52.089]   - Field: ‘asynchronous’
[08:25:52.089]   - Field: ‘calls’
[08:25:52.089]   - Field: ‘globals’
[08:25:52.089]   - Field: ‘stdout’
[08:25:52.089]   - Field: ‘earlySignal’
[08:25:52.089]   - Field: ‘lazy’
[08:25:52.089]   - Field: ‘state’
[08:25:52.089] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.089] - Launch lazy future ...
[08:25:52.090] Packages needed by the future expression (n = 0): <none>
[08:25:52.090] Packages needed by future strategies (n = 0): <none>
[08:25:52.090] {
[08:25:52.090]     {
[08:25:52.090]         {
[08:25:52.090]             ...future.startTime <- base::Sys.time()
[08:25:52.090]             {
[08:25:52.090]                 {
[08:25:52.090]                   {
[08:25:52.090]                     {
[08:25:52.090]                       base::local({
[08:25:52.090]                         has_future <- base::requireNamespace("future", 
[08:25:52.090]                           quietly = TRUE)
[08:25:52.090]                         if (has_future) {
[08:25:52.090]                           ns <- base::getNamespace("future")
[08:25:52.090]                           version <- ns[[".package"]][["version"]]
[08:25:52.090]                           if (is.null(version)) 
[08:25:52.090]                             version <- utils::packageVersion("future")
[08:25:52.090]                         }
[08:25:52.090]                         else {
[08:25:52.090]                           version <- NULL
[08:25:52.090]                         }
[08:25:52.090]                         if (!has_future || version < "1.8.0") {
[08:25:52.090]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.090]                             "", base::R.version$version.string), 
[08:25:52.090]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.090]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.090]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.090]                               "release", "version")], collapse = " "), 
[08:25:52.090]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.090]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.090]                             info)
[08:25:52.090]                           info <- base::paste(info, collapse = "; ")
[08:25:52.090]                           if (!has_future) {
[08:25:52.090]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.090]                               info)
[08:25:52.090]                           }
[08:25:52.090]                           else {
[08:25:52.090]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.090]                               info, version)
[08:25:52.090]                           }
[08:25:52.090]                           base::stop(msg)
[08:25:52.090]                         }
[08:25:52.090]                       })
[08:25:52.090]                     }
[08:25:52.090]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.090]                     base::options(mc.cores = 1L)
[08:25:52.090]                   }
[08:25:52.090]                   ...future.strategy.old <- future::plan("list")
[08:25:52.090]                   options(future.plan = NULL)
[08:25:52.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.090]                 }
[08:25:52.090]                 ...future.workdir <- getwd()
[08:25:52.090]             }
[08:25:52.090]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.090]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.090]         }
[08:25:52.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.090]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:52.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.090]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.090]             base::names(...future.oldOptions))
[08:25:52.090]     }
[08:25:52.090]     if (FALSE) {
[08:25:52.090]     }
[08:25:52.090]     else {
[08:25:52.090]         if (TRUE) {
[08:25:52.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.090]                 open = "w")
[08:25:52.090]         }
[08:25:52.090]         else {
[08:25:52.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.090]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.090]         }
[08:25:52.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.090]             base::sink(type = "output", split = FALSE)
[08:25:52.090]             base::close(...future.stdout)
[08:25:52.090]         }, add = TRUE)
[08:25:52.090]     }
[08:25:52.090]     ...future.frame <- base::sys.nframe()
[08:25:52.090]     ...future.conditions <- base::list()
[08:25:52.090]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.090]     if (FALSE) {
[08:25:52.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.090]     }
[08:25:52.090]     ...future.result <- base::tryCatch({
[08:25:52.090]         base::withCallingHandlers({
[08:25:52.090]             ...future.value <- base::withVisible(base::local({
[08:25:52.090]                 ...future.makeSendCondition <- base::local({
[08:25:52.090]                   sendCondition <- NULL
[08:25:52.090]                   function(frame = 1L) {
[08:25:52.090]                     if (is.function(sendCondition)) 
[08:25:52.090]                       return(sendCondition)
[08:25:52.090]                     ns <- getNamespace("parallel")
[08:25:52.090]                     if (exists("sendData", mode = "function", 
[08:25:52.090]                       envir = ns)) {
[08:25:52.090]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.090]                         envir = ns)
[08:25:52.090]                       envir <- sys.frame(frame)
[08:25:52.090]                       master <- NULL
[08:25:52.090]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.090]                         !identical(envir, emptyenv())) {
[08:25:52.090]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.090]                           inherits = FALSE)) {
[08:25:52.090]                           master <- get("master", mode = "list", 
[08:25:52.090]                             envir = envir, inherits = FALSE)
[08:25:52.090]                           if (inherits(master, c("SOCKnode", 
[08:25:52.090]                             "SOCK0node"))) {
[08:25:52.090]                             sendCondition <<- function(cond) {
[08:25:52.090]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.090]                                 success = TRUE)
[08:25:52.090]                               parallel_sendData(master, data)
[08:25:52.090]                             }
[08:25:52.090]                             return(sendCondition)
[08:25:52.090]                           }
[08:25:52.090]                         }
[08:25:52.090]                         frame <- frame + 1L
[08:25:52.090]                         envir <- sys.frame(frame)
[08:25:52.090]                       }
[08:25:52.090]                     }
[08:25:52.090]                     sendCondition <<- function(cond) NULL
[08:25:52.090]                   }
[08:25:52.090]                 })
[08:25:52.090]                 withCallingHandlers({
[08:25:52.090]                   {
[08:25:52.090]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.090]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.090]                       ...future.globals.maxSize)) {
[08:25:52.090]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.090]                       on.exit(options(oopts), add = TRUE)
[08:25:52.090]                     }
[08:25:52.090]                     {
[08:25:52.090]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.090]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.090]                         USE.NAMES = FALSE)
[08:25:52.090]                       do.call(mapply, args = args)
[08:25:52.090]                     }
[08:25:52.090]                   }
[08:25:52.090]                 }, immediateCondition = function(cond) {
[08:25:52.090]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.090]                   sendCondition(cond)
[08:25:52.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.090]                   {
[08:25:52.090]                     inherits <- base::inherits
[08:25:52.090]                     invokeRestart <- base::invokeRestart
[08:25:52.090]                     is.null <- base::is.null
[08:25:52.090]                     muffled <- FALSE
[08:25:52.090]                     if (inherits(cond, "message")) {
[08:25:52.090]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.090]                       if (muffled) 
[08:25:52.090]                         invokeRestart("muffleMessage")
[08:25:52.090]                     }
[08:25:52.090]                     else if (inherits(cond, "warning")) {
[08:25:52.090]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.090]                       if (muffled) 
[08:25:52.090]                         invokeRestart("muffleWarning")
[08:25:52.090]                     }
[08:25:52.090]                     else if (inherits(cond, "condition")) {
[08:25:52.090]                       if (!is.null(pattern)) {
[08:25:52.090]                         computeRestarts <- base::computeRestarts
[08:25:52.090]                         grepl <- base::grepl
[08:25:52.090]                         restarts <- computeRestarts(cond)
[08:25:52.090]                         for (restart in restarts) {
[08:25:52.090]                           name <- restart$name
[08:25:52.090]                           if (is.null(name)) 
[08:25:52.090]                             next
[08:25:52.090]                           if (!grepl(pattern, name)) 
[08:25:52.090]                             next
[08:25:52.090]                           invokeRestart(restart)
[08:25:52.090]                           muffled <- TRUE
[08:25:52.090]                           break
[08:25:52.090]                         }
[08:25:52.090]                       }
[08:25:52.090]                     }
[08:25:52.090]                     invisible(muffled)
[08:25:52.090]                   }
[08:25:52.090]                   muffleCondition(cond)
[08:25:52.090]                 })
[08:25:52.090]             }))
[08:25:52.090]             future::FutureResult(value = ...future.value$value, 
[08:25:52.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.090]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.090]                     ...future.globalenv.names))
[08:25:52.090]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.090]         }, condition = base::local({
[08:25:52.090]             c <- base::c
[08:25:52.090]             inherits <- base::inherits
[08:25:52.090]             invokeRestart <- base::invokeRestart
[08:25:52.090]             length <- base::length
[08:25:52.090]             list <- base::list
[08:25:52.090]             seq.int <- base::seq.int
[08:25:52.090]             signalCondition <- base::signalCondition
[08:25:52.090]             sys.calls <- base::sys.calls
[08:25:52.090]             `[[` <- base::`[[`
[08:25:52.090]             `+` <- base::`+`
[08:25:52.090]             `<<-` <- base::`<<-`
[08:25:52.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.090]                   3L)]
[08:25:52.090]             }
[08:25:52.090]             function(cond) {
[08:25:52.090]                 is_error <- inherits(cond, "error")
[08:25:52.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.090]                   NULL)
[08:25:52.090]                 if (is_error) {
[08:25:52.090]                   sessionInformation <- function() {
[08:25:52.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.090]                       search = base::search(), system = base::Sys.info())
[08:25:52.090]                   }
[08:25:52.090]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.090]                     cond$call), session = sessionInformation(), 
[08:25:52.090]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.090]                   signalCondition(cond)
[08:25:52.090]                 }
[08:25:52.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.090]                 "immediateCondition"))) {
[08:25:52.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.090]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.090]                   if (TRUE && !signal) {
[08:25:52.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.090]                     {
[08:25:52.090]                       inherits <- base::inherits
[08:25:52.090]                       invokeRestart <- base::invokeRestart
[08:25:52.090]                       is.null <- base::is.null
[08:25:52.090]                       muffled <- FALSE
[08:25:52.090]                       if (inherits(cond, "message")) {
[08:25:52.090]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.090]                         if (muffled) 
[08:25:52.090]                           invokeRestart("muffleMessage")
[08:25:52.090]                       }
[08:25:52.090]                       else if (inherits(cond, "warning")) {
[08:25:52.090]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.090]                         if (muffled) 
[08:25:52.090]                           invokeRestart("muffleWarning")
[08:25:52.090]                       }
[08:25:52.090]                       else if (inherits(cond, "condition")) {
[08:25:52.090]                         if (!is.null(pattern)) {
[08:25:52.090]                           computeRestarts <- base::computeRestarts
[08:25:52.090]                           grepl <- base::grepl
[08:25:52.090]                           restarts <- computeRestarts(cond)
[08:25:52.090]                           for (restart in restarts) {
[08:25:52.090]                             name <- restart$name
[08:25:52.090]                             if (is.null(name)) 
[08:25:52.090]                               next
[08:25:52.090]                             if (!grepl(pattern, name)) 
[08:25:52.090]                               next
[08:25:52.090]                             invokeRestart(restart)
[08:25:52.090]                             muffled <- TRUE
[08:25:52.090]                             break
[08:25:52.090]                           }
[08:25:52.090]                         }
[08:25:52.090]                       }
[08:25:52.090]                       invisible(muffled)
[08:25:52.090]                     }
[08:25:52.090]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.090]                   }
[08:25:52.090]                 }
[08:25:52.090]                 else {
[08:25:52.090]                   if (TRUE) {
[08:25:52.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.090]                     {
[08:25:52.090]                       inherits <- base::inherits
[08:25:52.090]                       invokeRestart <- base::invokeRestart
[08:25:52.090]                       is.null <- base::is.null
[08:25:52.090]                       muffled <- FALSE
[08:25:52.090]                       if (inherits(cond, "message")) {
[08:25:52.090]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.090]                         if (muffled) 
[08:25:52.090]                           invokeRestart("muffleMessage")
[08:25:52.090]                       }
[08:25:52.090]                       else if (inherits(cond, "warning")) {
[08:25:52.090]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.090]                         if (muffled) 
[08:25:52.090]                           invokeRestart("muffleWarning")
[08:25:52.090]                       }
[08:25:52.090]                       else if (inherits(cond, "condition")) {
[08:25:52.090]                         if (!is.null(pattern)) {
[08:25:52.090]                           computeRestarts <- base::computeRestarts
[08:25:52.090]                           grepl <- base::grepl
[08:25:52.090]                           restarts <- computeRestarts(cond)
[08:25:52.090]                           for (restart in restarts) {
[08:25:52.090]                             name <- restart$name
[08:25:52.090]                             if (is.null(name)) 
[08:25:52.090]                               next
[08:25:52.090]                             if (!grepl(pattern, name)) 
[08:25:52.090]                               next
[08:25:52.090]                             invokeRestart(restart)
[08:25:52.090]                             muffled <- TRUE
[08:25:52.090]                             break
[08:25:52.090]                           }
[08:25:52.090]                         }
[08:25:52.090]                       }
[08:25:52.090]                       invisible(muffled)
[08:25:52.090]                     }
[08:25:52.090]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.090]                   }
[08:25:52.090]                 }
[08:25:52.090]             }
[08:25:52.090]         }))
[08:25:52.090]     }, error = function(ex) {
[08:25:52.090]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.090]                 ...future.rng), started = ...future.startTime, 
[08:25:52.090]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.090]             version = "1.8"), class = "FutureResult")
[08:25:52.090]     }, finally = {
[08:25:52.090]         if (!identical(...future.workdir, getwd())) 
[08:25:52.090]             setwd(...future.workdir)
[08:25:52.090]         {
[08:25:52.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.090]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.090]             }
[08:25:52.090]             base::options(...future.oldOptions)
[08:25:52.090]             if (.Platform$OS.type == "windows") {
[08:25:52.090]                 old_names <- names(...future.oldEnvVars)
[08:25:52.090]                 envs <- base::Sys.getenv()
[08:25:52.090]                 names <- names(envs)
[08:25:52.090]                 common <- intersect(names, old_names)
[08:25:52.090]                 added <- setdiff(names, old_names)
[08:25:52.090]                 removed <- setdiff(old_names, names)
[08:25:52.090]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.090]                   envs[common]]
[08:25:52.090]                 NAMES <- toupper(changed)
[08:25:52.090]                 args <- list()
[08:25:52.090]                 for (kk in seq_along(NAMES)) {
[08:25:52.090]                   name <- changed[[kk]]
[08:25:52.090]                   NAME <- NAMES[[kk]]
[08:25:52.090]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.090]                     next
[08:25:52.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.090]                 }
[08:25:52.090]                 NAMES <- toupper(added)
[08:25:52.090]                 for (kk in seq_along(NAMES)) {
[08:25:52.090]                   name <- added[[kk]]
[08:25:52.090]                   NAME <- NAMES[[kk]]
[08:25:52.090]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.090]                     next
[08:25:52.090]                   args[[name]] <- ""
[08:25:52.090]                 }
[08:25:52.090]                 NAMES <- toupper(removed)
[08:25:52.090]                 for (kk in seq_along(NAMES)) {
[08:25:52.090]                   name <- removed[[kk]]
[08:25:52.090]                   NAME <- NAMES[[kk]]
[08:25:52.090]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.090]                     next
[08:25:52.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.090]                 }
[08:25:52.090]                 if (length(args) > 0) 
[08:25:52.090]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.090]             }
[08:25:52.090]             else {
[08:25:52.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.090]             }
[08:25:52.090]             {
[08:25:52.090]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.090]                   0L) {
[08:25:52.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.090]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.090]                   base::options(opts)
[08:25:52.090]                 }
[08:25:52.090]                 {
[08:25:52.090]                   {
[08:25:52.090]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.090]                     NULL
[08:25:52.090]                   }
[08:25:52.090]                   options(future.plan = NULL)
[08:25:52.090]                   if (is.na(NA_character_)) 
[08:25:52.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.090]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.090]                     .init = FALSE)
[08:25:52.090]                 }
[08:25:52.090]             }
[08:25:52.090]         }
[08:25:52.090]     })
[08:25:52.090]     if (TRUE) {
[08:25:52.090]         base::sink(type = "output", split = FALSE)
[08:25:52.090]         if (TRUE) {
[08:25:52.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.090]         }
[08:25:52.090]         else {
[08:25:52.090]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.090]         }
[08:25:52.090]         base::close(...future.stdout)
[08:25:52.090]         ...future.stdout <- NULL
[08:25:52.090]     }
[08:25:52.090]     ...future.result$conditions <- ...future.conditions
[08:25:52.090]     ...future.result$finished <- base::Sys.time()
[08:25:52.090]     ...future.result
[08:25:52.090] }
[08:25:52.093] Exporting 5 global objects (1.11 KiB) to cluster node #2 ...
[08:25:52.093] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ...
[08:25:52.094] Exporting ‘...future.FUN’ (414 bytes) to cluster node #2 ... DONE
[08:25:52.094] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[08:25:52.094] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[08:25:52.094] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ...
[08:25:52.095] Exporting ‘...future.elements_ii’ (200 bytes) to cluster node #2 ... DONE
[08:25:52.095] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:52.095] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.095] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:52.096] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.096] Exporting 5 global objects (1.11 KiB) to cluster node #2 ... DONE
[08:25:52.096] MultisessionFuture started
[08:25:52.096] - Launch lazy future ... done
[08:25:52.096] run() for ‘MultisessionFuture’ ... done
[08:25:52.097] Created future:
[08:25:52.097] MultisessionFuture:
[08:25:52.097] Label: ‘future_.mapply-2’
[08:25:52.097] Expression:
[08:25:52.097] {
[08:25:52.097]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.097]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.097]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.097]         on.exit(options(oopts), add = TRUE)
[08:25:52.097]     }
[08:25:52.097]     {
[08:25:52.097]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.097]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.097]         do.call(mapply, args = args)
[08:25:52.097]     }
[08:25:52.097] }
[08:25:52.097] Lazy evaluation: FALSE
[08:25:52.097] Asynchronous evaluation: TRUE
[08:25:52.097] Local evaluation: TRUE
[08:25:52.097] Environment: R_GlobalEnv
[08:25:52.097] Capture standard output: TRUE
[08:25:52.097] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.097] Globals: 5 objects totaling 699 bytes (function ‘...future.FUN’ of 414 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 200 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.097] Packages: <none>
[08:25:52.097] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.097] Resolved: FALSE
[08:25:52.097] Value: <not collected>
[08:25:52.097] Conditions captured: <none>
[08:25:52.097] Early signaling: FALSE
[08:25:52.097] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.097] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.108] Chunk #2 of 2 ... DONE
[08:25:52.108] Launching 2 futures (chunks) ... DONE
[08:25:52.108] Resolving 2 futures (chunks) ...
[08:25:52.109] resolve() on list ...
[08:25:52.109]  recursive: 0
[08:25:52.109]  length: 2
[08:25:52.109] 
[08:25:52.109] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.109] - Validating connection of MultisessionFuture
[08:25:52.110] - received message: FutureResult
[08:25:52.110] - Received FutureResult
[08:25:52.110] - Erased future from FutureRegistry
[08:25:52.110] result() for ClusterFuture ...
[08:25:52.110] - result already collected: FutureResult
[08:25:52.110] result() for ClusterFuture ... done
[08:25:52.110] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.110] Future #1
[08:25:52.110] result() for ClusterFuture ...
[08:25:52.110] - result already collected: FutureResult
[08:25:52.110] result() for ClusterFuture ... done
[08:25:52.111] result() for ClusterFuture ...
[08:25:52.111] - result already collected: FutureResult
[08:25:52.111] result() for ClusterFuture ... done
[08:25:52.111] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:52.111] - nx: 2
[08:25:52.111] - relay: TRUE
[08:25:52.111] - stdout: TRUE
[08:25:52.111] - signal: TRUE
[08:25:52.111] - resignal: FALSE
[08:25:52.111] - force: TRUE
[08:25:52.111] - relayed: [n=2] FALSE, FALSE
[08:25:52.112] - queued futures: [n=2] FALSE, FALSE
[08:25:52.112]  - until=1
[08:25:52.112]  - relaying element #1
[08:25:52.112] result() for ClusterFuture ...
[08:25:52.112] - result already collected: FutureResult
[08:25:52.112] result() for ClusterFuture ... done
[08:25:52.112] result() for ClusterFuture ...
[08:25:52.112] - result already collected: FutureResult
[08:25:52.112] result() for ClusterFuture ... done
[08:25:52.112] result() for ClusterFuture ...
[08:25:52.112] - result already collected: FutureResult
[08:25:52.112] result() for ClusterFuture ... done
[08:25:52.113] result() for ClusterFuture ...
[08:25:52.113] - result already collected: FutureResult
[08:25:52.113] result() for ClusterFuture ... done
[08:25:52.113] - relayed: [n=2] TRUE, FALSE
[08:25:52.113] - queued futures: [n=2] TRUE, FALSE
[08:25:52.113] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:52.113]  length: 1 (resolved future 1)
[08:25:52.138] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.138] - Validating connection of MultisessionFuture
[08:25:52.139] - received message: FutureResult
[08:25:52.139] - Received FutureResult
[08:25:52.139] - Erased future from FutureRegistry
[08:25:52.139] result() for ClusterFuture ...
[08:25:52.139] - result already collected: FutureResult
[08:25:52.139] result() for ClusterFuture ... done
[08:25:52.139] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.139] Future #2
[08:25:52.139] result() for ClusterFuture ...
[08:25:52.139] - result already collected: FutureResult
[08:25:52.140] result() for ClusterFuture ... done
[08:25:52.140] result() for ClusterFuture ...
[08:25:52.140] - result already collected: FutureResult
[08:25:52.140] result() for ClusterFuture ... done
[08:25:52.140] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:52.140] - nx: 2
[08:25:52.140] - relay: TRUE
[08:25:52.140] - stdout: TRUE
[08:25:52.140] - signal: TRUE
[08:25:52.140] - resignal: FALSE
[08:25:52.140] - force: TRUE
[08:25:52.141] - relayed: [n=2] TRUE, FALSE
[08:25:52.141] - queued futures: [n=2] TRUE, FALSE
[08:25:52.141]  - until=2
[08:25:52.141]  - relaying element #2
[08:25:52.141] result() for ClusterFuture ...
[08:25:52.141] - result already collected: FutureResult
[08:25:52.141] result() for ClusterFuture ... done
[08:25:52.141] result() for ClusterFuture ...
[08:25:52.141] - result already collected: FutureResult
[08:25:52.141] result() for ClusterFuture ... done
[08:25:52.141] result() for ClusterFuture ...
[08:25:52.142] - result already collected: FutureResult
[08:25:52.142] result() for ClusterFuture ... done
[08:25:52.142] result() for ClusterFuture ...
[08:25:52.142] - result already collected: FutureResult
[08:25:52.142] result() for ClusterFuture ... done
[08:25:52.142] - relayed: [n=2] TRUE, TRUE
[08:25:52.142] - queued futures: [n=2] TRUE, TRUE
[08:25:52.142] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:52.142]  length: 0 (resolved future 2)
[08:25:52.142] Relaying remaining futures
[08:25:52.142] signalConditionsASAP(NULL, pos=0) ...
[08:25:52.142] - nx: 2
[08:25:52.143] - relay: TRUE
[08:25:52.143] - stdout: TRUE
[08:25:52.143] - signal: TRUE
[08:25:52.143] - resignal: FALSE
[08:25:52.143] - force: TRUE
[08:25:52.143] - relayed: [n=2] TRUE, TRUE
[08:25:52.143] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:52.143] - relayed: [n=2] TRUE, TRUE
[08:25:52.143] - queued futures: [n=2] TRUE, TRUE
[08:25:52.143] signalConditionsASAP(NULL, pos=0) ... done
[08:25:52.143] resolve() on list ... DONE
[08:25:52.144] result() for ClusterFuture ...
[08:25:52.144] - result already collected: FutureResult
[08:25:52.144] result() for ClusterFuture ... done
[08:25:52.144] result() for ClusterFuture ...
[08:25:52.144] - result already collected: FutureResult
[08:25:52.144] result() for ClusterFuture ... done
[08:25:52.144] result() for ClusterFuture ...
[08:25:52.144] - result already collected: FutureResult
[08:25:52.144] result() for ClusterFuture ... done
[08:25:52.144] result() for ClusterFuture ...
[08:25:52.144] - result already collected: FutureResult
[08:25:52.144] result() for ClusterFuture ... done
[08:25:52.145]  - Number of value chunks collected: 2
[08:25:52.145] Resolving 2 futures (chunks) ... DONE
[08:25:52.145] Reducing values from 2 chunks ...
[08:25:52.145]  - Number of values collected after concatenation: 3
[08:25:52.145]  - Number of values expected: 3
[08:25:52.145] Reducing values from 2 chunks ... DONE
[08:25:52.145] future_mapply() ... DONE
[08:25:52.145] future_mapply() ...
[08:25:52.149] Number of chunks: 5
[08:25:52.149] getGlobalsAndPackagesXApply() ...
[08:25:52.149]  - future.globals: TRUE
[08:25:52.149] getGlobalsAndPackages() ...
[08:25:52.149] Searching for globals...
[08:25:52.151] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:52.151] Searching for globals ... DONE
[08:25:52.151] Resolving globals: FALSE
[08:25:52.151] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:52.152] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:52.152] - globals: [1] ‘FUN’
[08:25:52.152] 
[08:25:52.152] getGlobalsAndPackages() ... DONE
[08:25:52.152]  - globals found/used: [n=1] ‘FUN’
[08:25:52.152]  - needed namespaces: [n=0] 
[08:25:52.152] Finding globals ... DONE
[08:25:52.152] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:52.152] List of 2
[08:25:52.152]  $ ...future.FUN:function (C, k)  
[08:25:52.152]  $ MoreArgs     : NULL
[08:25:52.152]  - attr(*, "where")=List of 2
[08:25:52.152]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:52.152]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:52.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:52.152]  - attr(*, "resolved")= logi FALSE
[08:25:52.152]  - attr(*, "total_size")= num NA
[08:25:52.155] Packages to be attached in all futures: [n=0] 
[08:25:52.155] getGlobalsAndPackagesXApply() ... DONE
[08:25:52.155] Number of futures (= number of chunks): 5
[08:25:52.155] Launching 5 futures (chunks) ...
[08:25:52.155] Chunk #1 of 5 ...
[08:25:52.156]  - Finding globals in '...' for chunk #1 ...
[08:25:52.156] getGlobalsAndPackages() ...
[08:25:52.156] Searching for globals...
[08:25:52.156] 
[08:25:52.156] Searching for globals ... DONE
[08:25:52.156] - globals: [0] <none>
[08:25:52.156] getGlobalsAndPackages() ... DONE
[08:25:52.156]    + additional globals found: [n=0] 
[08:25:52.156]    + additional namespaces needed: [n=0] 
[08:25:52.157]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:52.157]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:52.157]  - seeds: <none>
[08:25:52.157]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.157] getGlobalsAndPackages() ...
[08:25:52.157] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.157] Resolving globals: FALSE
[08:25:52.157] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:52.158] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:52.158] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.158] 
[08:25:52.158] getGlobalsAndPackages() ... DONE
[08:25:52.158] run() for ‘Future’ ...
[08:25:52.159] - state: ‘created’
[08:25:52.159] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.172] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.172]   - Field: ‘node’
[08:25:52.172]   - Field: ‘label’
[08:25:52.173]   - Field: ‘local’
[08:25:52.173]   - Field: ‘owner’
[08:25:52.173]   - Field: ‘envir’
[08:25:52.173]   - Field: ‘workers’
[08:25:52.173]   - Field: ‘packages’
[08:25:52.173]   - Field: ‘gc’
[08:25:52.173]   - Field: ‘conditions’
[08:25:52.173]   - Field: ‘persistent’
[08:25:52.173]   - Field: ‘expr’
[08:25:52.173]   - Field: ‘uuid’
[08:25:52.173]   - Field: ‘seed’
[08:25:52.174]   - Field: ‘version’
[08:25:52.174]   - Field: ‘result’
[08:25:52.174]   - Field: ‘asynchronous’
[08:25:52.174]   - Field: ‘calls’
[08:25:52.174]   - Field: ‘globals’
[08:25:52.174]   - Field: ‘stdout’
[08:25:52.174]   - Field: ‘earlySignal’
[08:25:52.174]   - Field: ‘lazy’
[08:25:52.174]   - Field: ‘state’
[08:25:52.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.174] - Launch lazy future ...
[08:25:52.175] Packages needed by the future expression (n = 0): <none>
[08:25:52.175] Packages needed by future strategies (n = 0): <none>
[08:25:52.175] {
[08:25:52.175]     {
[08:25:52.175]         {
[08:25:52.175]             ...future.startTime <- base::Sys.time()
[08:25:52.175]             {
[08:25:52.175]                 {
[08:25:52.175]                   {
[08:25:52.175]                     {
[08:25:52.175]                       base::local({
[08:25:52.175]                         has_future <- base::requireNamespace("future", 
[08:25:52.175]                           quietly = TRUE)
[08:25:52.175]                         if (has_future) {
[08:25:52.175]                           ns <- base::getNamespace("future")
[08:25:52.175]                           version <- ns[[".package"]][["version"]]
[08:25:52.175]                           if (is.null(version)) 
[08:25:52.175]                             version <- utils::packageVersion("future")
[08:25:52.175]                         }
[08:25:52.175]                         else {
[08:25:52.175]                           version <- NULL
[08:25:52.175]                         }
[08:25:52.175]                         if (!has_future || version < "1.8.0") {
[08:25:52.175]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.175]                             "", base::R.version$version.string), 
[08:25:52.175]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.175]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.175]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.175]                               "release", "version")], collapse = " "), 
[08:25:52.175]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.175]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.175]                             info)
[08:25:52.175]                           info <- base::paste(info, collapse = "; ")
[08:25:52.175]                           if (!has_future) {
[08:25:52.175]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.175]                               info)
[08:25:52.175]                           }
[08:25:52.175]                           else {
[08:25:52.175]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.175]                               info, version)
[08:25:52.175]                           }
[08:25:52.175]                           base::stop(msg)
[08:25:52.175]                         }
[08:25:52.175]                       })
[08:25:52.175]                     }
[08:25:52.175]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.175]                     base::options(mc.cores = 1L)
[08:25:52.175]                   }
[08:25:52.175]                   ...future.strategy.old <- future::plan("list")
[08:25:52.175]                   options(future.plan = NULL)
[08:25:52.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.175]                 }
[08:25:52.175]                 ...future.workdir <- getwd()
[08:25:52.175]             }
[08:25:52.175]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.175]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.175]         }
[08:25:52.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.175]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:52.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.175]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.175]             base::names(...future.oldOptions))
[08:25:52.175]     }
[08:25:52.175]     if (FALSE) {
[08:25:52.175]     }
[08:25:52.175]     else {
[08:25:52.175]         if (TRUE) {
[08:25:52.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.175]                 open = "w")
[08:25:52.175]         }
[08:25:52.175]         else {
[08:25:52.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.175]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.175]         }
[08:25:52.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.175]             base::sink(type = "output", split = FALSE)
[08:25:52.175]             base::close(...future.stdout)
[08:25:52.175]         }, add = TRUE)
[08:25:52.175]     }
[08:25:52.175]     ...future.frame <- base::sys.nframe()
[08:25:52.175]     ...future.conditions <- base::list()
[08:25:52.175]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.175]     if (FALSE) {
[08:25:52.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.175]     }
[08:25:52.175]     ...future.result <- base::tryCatch({
[08:25:52.175]         base::withCallingHandlers({
[08:25:52.175]             ...future.value <- base::withVisible(base::local({
[08:25:52.175]                 ...future.makeSendCondition <- base::local({
[08:25:52.175]                   sendCondition <- NULL
[08:25:52.175]                   function(frame = 1L) {
[08:25:52.175]                     if (is.function(sendCondition)) 
[08:25:52.175]                       return(sendCondition)
[08:25:52.175]                     ns <- getNamespace("parallel")
[08:25:52.175]                     if (exists("sendData", mode = "function", 
[08:25:52.175]                       envir = ns)) {
[08:25:52.175]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.175]                         envir = ns)
[08:25:52.175]                       envir <- sys.frame(frame)
[08:25:52.175]                       master <- NULL
[08:25:52.175]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.175]                         !identical(envir, emptyenv())) {
[08:25:52.175]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.175]                           inherits = FALSE)) {
[08:25:52.175]                           master <- get("master", mode = "list", 
[08:25:52.175]                             envir = envir, inherits = FALSE)
[08:25:52.175]                           if (inherits(master, c("SOCKnode", 
[08:25:52.175]                             "SOCK0node"))) {
[08:25:52.175]                             sendCondition <<- function(cond) {
[08:25:52.175]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.175]                                 success = TRUE)
[08:25:52.175]                               parallel_sendData(master, data)
[08:25:52.175]                             }
[08:25:52.175]                             return(sendCondition)
[08:25:52.175]                           }
[08:25:52.175]                         }
[08:25:52.175]                         frame <- frame + 1L
[08:25:52.175]                         envir <- sys.frame(frame)
[08:25:52.175]                       }
[08:25:52.175]                     }
[08:25:52.175]                     sendCondition <<- function(cond) NULL
[08:25:52.175]                   }
[08:25:52.175]                 })
[08:25:52.175]                 withCallingHandlers({
[08:25:52.175]                   {
[08:25:52.175]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.175]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.175]                       ...future.globals.maxSize)) {
[08:25:52.175]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.175]                       on.exit(options(oopts), add = TRUE)
[08:25:52.175]                     }
[08:25:52.175]                     {
[08:25:52.175]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.175]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.175]                         USE.NAMES = FALSE)
[08:25:52.175]                       do.call(mapply, args = args)
[08:25:52.175]                     }
[08:25:52.175]                   }
[08:25:52.175]                 }, immediateCondition = function(cond) {
[08:25:52.175]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.175]                   sendCondition(cond)
[08:25:52.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.175]                   {
[08:25:52.175]                     inherits <- base::inherits
[08:25:52.175]                     invokeRestart <- base::invokeRestart
[08:25:52.175]                     is.null <- base::is.null
[08:25:52.175]                     muffled <- FALSE
[08:25:52.175]                     if (inherits(cond, "message")) {
[08:25:52.175]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.175]                       if (muffled) 
[08:25:52.175]                         invokeRestart("muffleMessage")
[08:25:52.175]                     }
[08:25:52.175]                     else if (inherits(cond, "warning")) {
[08:25:52.175]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.175]                       if (muffled) 
[08:25:52.175]                         invokeRestart("muffleWarning")
[08:25:52.175]                     }
[08:25:52.175]                     else if (inherits(cond, "condition")) {
[08:25:52.175]                       if (!is.null(pattern)) {
[08:25:52.175]                         computeRestarts <- base::computeRestarts
[08:25:52.175]                         grepl <- base::grepl
[08:25:52.175]                         restarts <- computeRestarts(cond)
[08:25:52.175]                         for (restart in restarts) {
[08:25:52.175]                           name <- restart$name
[08:25:52.175]                           if (is.null(name)) 
[08:25:52.175]                             next
[08:25:52.175]                           if (!grepl(pattern, name)) 
[08:25:52.175]                             next
[08:25:52.175]                           invokeRestart(restart)
[08:25:52.175]                           muffled <- TRUE
[08:25:52.175]                           break
[08:25:52.175]                         }
[08:25:52.175]                       }
[08:25:52.175]                     }
[08:25:52.175]                     invisible(muffled)
[08:25:52.175]                   }
[08:25:52.175]                   muffleCondition(cond)
[08:25:52.175]                 })
[08:25:52.175]             }))
[08:25:52.175]             future::FutureResult(value = ...future.value$value, 
[08:25:52.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.175]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.175]                     ...future.globalenv.names))
[08:25:52.175]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.175]         }, condition = base::local({
[08:25:52.175]             c <- base::c
[08:25:52.175]             inherits <- base::inherits
[08:25:52.175]             invokeRestart <- base::invokeRestart
[08:25:52.175]             length <- base::length
[08:25:52.175]             list <- base::list
[08:25:52.175]             seq.int <- base::seq.int
[08:25:52.175]             signalCondition <- base::signalCondition
[08:25:52.175]             sys.calls <- base::sys.calls
[08:25:52.175]             `[[` <- base::`[[`
[08:25:52.175]             `+` <- base::`+`
[08:25:52.175]             `<<-` <- base::`<<-`
[08:25:52.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.175]                   3L)]
[08:25:52.175]             }
[08:25:52.175]             function(cond) {
[08:25:52.175]                 is_error <- inherits(cond, "error")
[08:25:52.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.175]                   NULL)
[08:25:52.175]                 if (is_error) {
[08:25:52.175]                   sessionInformation <- function() {
[08:25:52.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.175]                       search = base::search(), system = base::Sys.info())
[08:25:52.175]                   }
[08:25:52.175]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.175]                     cond$call), session = sessionInformation(), 
[08:25:52.175]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.175]                   signalCondition(cond)
[08:25:52.175]                 }
[08:25:52.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.175]                 "immediateCondition"))) {
[08:25:52.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.175]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.175]                   if (TRUE && !signal) {
[08:25:52.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.175]                     {
[08:25:52.175]                       inherits <- base::inherits
[08:25:52.175]                       invokeRestart <- base::invokeRestart
[08:25:52.175]                       is.null <- base::is.null
[08:25:52.175]                       muffled <- FALSE
[08:25:52.175]                       if (inherits(cond, "message")) {
[08:25:52.175]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.175]                         if (muffled) 
[08:25:52.175]                           invokeRestart("muffleMessage")
[08:25:52.175]                       }
[08:25:52.175]                       else if (inherits(cond, "warning")) {
[08:25:52.175]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.175]                         if (muffled) 
[08:25:52.175]                           invokeRestart("muffleWarning")
[08:25:52.175]                       }
[08:25:52.175]                       else if (inherits(cond, "condition")) {
[08:25:52.175]                         if (!is.null(pattern)) {
[08:25:52.175]                           computeRestarts <- base::computeRestarts
[08:25:52.175]                           grepl <- base::grepl
[08:25:52.175]                           restarts <- computeRestarts(cond)
[08:25:52.175]                           for (restart in restarts) {
[08:25:52.175]                             name <- restart$name
[08:25:52.175]                             if (is.null(name)) 
[08:25:52.175]                               next
[08:25:52.175]                             if (!grepl(pattern, name)) 
[08:25:52.175]                               next
[08:25:52.175]                             invokeRestart(restart)
[08:25:52.175]                             muffled <- TRUE
[08:25:52.175]                             break
[08:25:52.175]                           }
[08:25:52.175]                         }
[08:25:52.175]                       }
[08:25:52.175]                       invisible(muffled)
[08:25:52.175]                     }
[08:25:52.175]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.175]                   }
[08:25:52.175]                 }
[08:25:52.175]                 else {
[08:25:52.175]                   if (TRUE) {
[08:25:52.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.175]                     {
[08:25:52.175]                       inherits <- base::inherits
[08:25:52.175]                       invokeRestart <- base::invokeRestart
[08:25:52.175]                       is.null <- base::is.null
[08:25:52.175]                       muffled <- FALSE
[08:25:52.175]                       if (inherits(cond, "message")) {
[08:25:52.175]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.175]                         if (muffled) 
[08:25:52.175]                           invokeRestart("muffleMessage")
[08:25:52.175]                       }
[08:25:52.175]                       else if (inherits(cond, "warning")) {
[08:25:52.175]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.175]                         if (muffled) 
[08:25:52.175]                           invokeRestart("muffleWarning")
[08:25:52.175]                       }
[08:25:52.175]                       else if (inherits(cond, "condition")) {
[08:25:52.175]                         if (!is.null(pattern)) {
[08:25:52.175]                           computeRestarts <- base::computeRestarts
[08:25:52.175]                           grepl <- base::grepl
[08:25:52.175]                           restarts <- computeRestarts(cond)
[08:25:52.175]                           for (restart in restarts) {
[08:25:52.175]                             name <- restart$name
[08:25:52.175]                             if (is.null(name)) 
[08:25:52.175]                               next
[08:25:52.175]                             if (!grepl(pattern, name)) 
[08:25:52.175]                               next
[08:25:52.175]                             invokeRestart(restart)
[08:25:52.175]                             muffled <- TRUE
[08:25:52.175]                             break
[08:25:52.175]                           }
[08:25:52.175]                         }
[08:25:52.175]                       }
[08:25:52.175]                       invisible(muffled)
[08:25:52.175]                     }
[08:25:52.175]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.175]                   }
[08:25:52.175]                 }
[08:25:52.175]             }
[08:25:52.175]         }))
[08:25:52.175]     }, error = function(ex) {
[08:25:52.175]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.175]                 ...future.rng), started = ...future.startTime, 
[08:25:52.175]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.175]             version = "1.8"), class = "FutureResult")
[08:25:52.175]     }, finally = {
[08:25:52.175]         if (!identical(...future.workdir, getwd())) 
[08:25:52.175]             setwd(...future.workdir)
[08:25:52.175]         {
[08:25:52.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.175]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.175]             }
[08:25:52.175]             base::options(...future.oldOptions)
[08:25:52.175]             if (.Platform$OS.type == "windows") {
[08:25:52.175]                 old_names <- names(...future.oldEnvVars)
[08:25:52.175]                 envs <- base::Sys.getenv()
[08:25:52.175]                 names <- names(envs)
[08:25:52.175]                 common <- intersect(names, old_names)
[08:25:52.175]                 added <- setdiff(names, old_names)
[08:25:52.175]                 removed <- setdiff(old_names, names)
[08:25:52.175]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.175]                   envs[common]]
[08:25:52.175]                 NAMES <- toupper(changed)
[08:25:52.175]                 args <- list()
[08:25:52.175]                 for (kk in seq_along(NAMES)) {
[08:25:52.175]                   name <- changed[[kk]]
[08:25:52.175]                   NAME <- NAMES[[kk]]
[08:25:52.175]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.175]                     next
[08:25:52.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.175]                 }
[08:25:52.175]                 NAMES <- toupper(added)
[08:25:52.175]                 for (kk in seq_along(NAMES)) {
[08:25:52.175]                   name <- added[[kk]]
[08:25:52.175]                   NAME <- NAMES[[kk]]
[08:25:52.175]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.175]                     next
[08:25:52.175]                   args[[name]] <- ""
[08:25:52.175]                 }
[08:25:52.175]                 NAMES <- toupper(removed)
[08:25:52.175]                 for (kk in seq_along(NAMES)) {
[08:25:52.175]                   name <- removed[[kk]]
[08:25:52.175]                   NAME <- NAMES[[kk]]
[08:25:52.175]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.175]                     next
[08:25:52.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.175]                 }
[08:25:52.175]                 if (length(args) > 0) 
[08:25:52.175]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.175]             }
[08:25:52.175]             else {
[08:25:52.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.175]             }
[08:25:52.175]             {
[08:25:52.175]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.175]                   0L) {
[08:25:52.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.175]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.175]                   base::options(opts)
[08:25:52.175]                 }
[08:25:52.175]                 {
[08:25:52.175]                   {
[08:25:52.175]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.175]                     NULL
[08:25:52.175]                   }
[08:25:52.175]                   options(future.plan = NULL)
[08:25:52.175]                   if (is.na(NA_character_)) 
[08:25:52.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.175]                     .init = FALSE)
[08:25:52.175]                 }
[08:25:52.175]             }
[08:25:52.175]         }
[08:25:52.175]     })
[08:25:52.175]     if (TRUE) {
[08:25:52.175]         base::sink(type = "output", split = FALSE)
[08:25:52.175]         if (TRUE) {
[08:25:52.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.175]         }
[08:25:52.175]         else {
[08:25:52.175]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.175]         }
[08:25:52.175]         base::close(...future.stdout)
[08:25:52.175]         ...future.stdout <- NULL
[08:25:52.175]     }
[08:25:52.175]     ...future.result$conditions <- ...future.conditions
[08:25:52.175]     ...future.result$finished <- base::Sys.time()
[08:25:52.175]     ...future.result
[08:25:52.175] }
[08:25:52.178] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[08:25:52.178] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[08:25:52.179] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[08:25:52.179] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:52.179] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.179] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ...
[08:25:52.180] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ... DONE
[08:25:52.180] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:52.180] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.180] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:52.181] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.181] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[08:25:52.181] MultisessionFuture started
[08:25:52.181] - Launch lazy future ... done
[08:25:52.181] run() for ‘MultisessionFuture’ ... done
[08:25:52.182] Created future:
[08:25:52.182] MultisessionFuture:
[08:25:52.182] Label: ‘future_mapply-1’
[08:25:52.182] Expression:
[08:25:52.182] {
[08:25:52.182]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.182]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.182]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.182]         on.exit(options(oopts), add = TRUE)
[08:25:52.182]     }
[08:25:52.182]     {
[08:25:52.182]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.182]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.182]         do.call(mapply, args = args)
[08:25:52.182]     }
[08:25:52.182] }
[08:25:52.182] Lazy evaluation: FALSE
[08:25:52.182] Asynchronous evaluation: TRUE
[08:25:52.182] Local evaluation: TRUE
[08:25:52.182] Environment: R_GlobalEnv
[08:25:52.182] Capture standard output: TRUE
[08:25:52.182] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.182] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.182] Packages: <none>
[08:25:52.182] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.182] Resolved: FALSE
[08:25:52.182] Value: <not collected>
[08:25:52.182] Conditions captured: <none>
[08:25:52.182] Early signaling: FALSE
[08:25:52.182] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.182] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.193] Chunk #1 of 5 ... DONE
[08:25:52.193] Chunk #2 of 5 ...
[08:25:52.193]  - Finding globals in '...' for chunk #2 ...
[08:25:52.193] getGlobalsAndPackages() ...
[08:25:52.194] Searching for globals...
[08:25:52.194] 
[08:25:52.194] Searching for globals ... DONE
[08:25:52.194] - globals: [0] <none>
[08:25:52.194] getGlobalsAndPackages() ... DONE
[08:25:52.194]    + additional globals found: [n=0] 
[08:25:52.194]    + additional namespaces needed: [n=0] 
[08:25:52.195]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:52.195]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:52.195]  - seeds: <none>
[08:25:52.195]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.195] getGlobalsAndPackages() ...
[08:25:52.195] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.195] Resolving globals: FALSE
[08:25:52.196] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:52.196] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:52.196] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.196] 
[08:25:52.196] getGlobalsAndPackages() ... DONE
[08:25:52.197] run() for ‘Future’ ...
[08:25:52.197] - state: ‘created’
[08:25:52.197] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.210] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.211]   - Field: ‘node’
[08:25:52.211]   - Field: ‘label’
[08:25:52.211]   - Field: ‘local’
[08:25:52.211]   - Field: ‘owner’
[08:25:52.211]   - Field: ‘envir’
[08:25:52.211]   - Field: ‘workers’
[08:25:52.211]   - Field: ‘packages’
[08:25:52.211]   - Field: ‘gc’
[08:25:52.211]   - Field: ‘conditions’
[08:25:52.211]   - Field: ‘persistent’
[08:25:52.212]   - Field: ‘expr’
[08:25:52.212]   - Field: ‘uuid’
[08:25:52.212]   - Field: ‘seed’
[08:25:52.212]   - Field: ‘version’
[08:25:52.212]   - Field: ‘result’
[08:25:52.212]   - Field: ‘asynchronous’
[08:25:52.212]   - Field: ‘calls’
[08:25:52.212]   - Field: ‘globals’
[08:25:52.212]   - Field: ‘stdout’
[08:25:52.212]   - Field: ‘earlySignal’
[08:25:52.212]   - Field: ‘lazy’
[08:25:52.212]   - Field: ‘state’
[08:25:52.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.213] - Launch lazy future ...
[08:25:52.213] Packages needed by the future expression (n = 0): <none>
[08:25:52.213] Packages needed by future strategies (n = 0): <none>
[08:25:52.213] {
[08:25:52.213]     {
[08:25:52.213]         {
[08:25:52.213]             ...future.startTime <- base::Sys.time()
[08:25:52.213]             {
[08:25:52.213]                 {
[08:25:52.213]                   {
[08:25:52.213]                     {
[08:25:52.213]                       base::local({
[08:25:52.213]                         has_future <- base::requireNamespace("future", 
[08:25:52.213]                           quietly = TRUE)
[08:25:52.213]                         if (has_future) {
[08:25:52.213]                           ns <- base::getNamespace("future")
[08:25:52.213]                           version <- ns[[".package"]][["version"]]
[08:25:52.213]                           if (is.null(version)) 
[08:25:52.213]                             version <- utils::packageVersion("future")
[08:25:52.213]                         }
[08:25:52.213]                         else {
[08:25:52.213]                           version <- NULL
[08:25:52.213]                         }
[08:25:52.213]                         if (!has_future || version < "1.8.0") {
[08:25:52.213]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.213]                             "", base::R.version$version.string), 
[08:25:52.213]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.213]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.213]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.213]                               "release", "version")], collapse = " "), 
[08:25:52.213]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.213]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.213]                             info)
[08:25:52.213]                           info <- base::paste(info, collapse = "; ")
[08:25:52.213]                           if (!has_future) {
[08:25:52.213]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.213]                               info)
[08:25:52.213]                           }
[08:25:52.213]                           else {
[08:25:52.213]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.213]                               info, version)
[08:25:52.213]                           }
[08:25:52.213]                           base::stop(msg)
[08:25:52.213]                         }
[08:25:52.213]                       })
[08:25:52.213]                     }
[08:25:52.213]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.213]                     base::options(mc.cores = 1L)
[08:25:52.213]                   }
[08:25:52.213]                   ...future.strategy.old <- future::plan("list")
[08:25:52.213]                   options(future.plan = NULL)
[08:25:52.213]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.213]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.213]                 }
[08:25:52.213]                 ...future.workdir <- getwd()
[08:25:52.213]             }
[08:25:52.213]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.213]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.213]         }
[08:25:52.213]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.213]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:52.213]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.213]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.213]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.213]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.213]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.213]             base::names(...future.oldOptions))
[08:25:52.213]     }
[08:25:52.213]     if (FALSE) {
[08:25:52.213]     }
[08:25:52.213]     else {
[08:25:52.213]         if (TRUE) {
[08:25:52.213]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.213]                 open = "w")
[08:25:52.213]         }
[08:25:52.213]         else {
[08:25:52.213]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.213]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.213]         }
[08:25:52.213]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.213]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.213]             base::sink(type = "output", split = FALSE)
[08:25:52.213]             base::close(...future.stdout)
[08:25:52.213]         }, add = TRUE)
[08:25:52.213]     }
[08:25:52.213]     ...future.frame <- base::sys.nframe()
[08:25:52.213]     ...future.conditions <- base::list()
[08:25:52.213]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.213]     if (FALSE) {
[08:25:52.213]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.213]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.213]     }
[08:25:52.213]     ...future.result <- base::tryCatch({
[08:25:52.213]         base::withCallingHandlers({
[08:25:52.213]             ...future.value <- base::withVisible(base::local({
[08:25:52.213]                 ...future.makeSendCondition <- base::local({
[08:25:52.213]                   sendCondition <- NULL
[08:25:52.213]                   function(frame = 1L) {
[08:25:52.213]                     if (is.function(sendCondition)) 
[08:25:52.213]                       return(sendCondition)
[08:25:52.213]                     ns <- getNamespace("parallel")
[08:25:52.213]                     if (exists("sendData", mode = "function", 
[08:25:52.213]                       envir = ns)) {
[08:25:52.213]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.213]                         envir = ns)
[08:25:52.213]                       envir <- sys.frame(frame)
[08:25:52.213]                       master <- NULL
[08:25:52.213]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.213]                         !identical(envir, emptyenv())) {
[08:25:52.213]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.213]                           inherits = FALSE)) {
[08:25:52.213]                           master <- get("master", mode = "list", 
[08:25:52.213]                             envir = envir, inherits = FALSE)
[08:25:52.213]                           if (inherits(master, c("SOCKnode", 
[08:25:52.213]                             "SOCK0node"))) {
[08:25:52.213]                             sendCondition <<- function(cond) {
[08:25:52.213]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.213]                                 success = TRUE)
[08:25:52.213]                               parallel_sendData(master, data)
[08:25:52.213]                             }
[08:25:52.213]                             return(sendCondition)
[08:25:52.213]                           }
[08:25:52.213]                         }
[08:25:52.213]                         frame <- frame + 1L
[08:25:52.213]                         envir <- sys.frame(frame)
[08:25:52.213]                       }
[08:25:52.213]                     }
[08:25:52.213]                     sendCondition <<- function(cond) NULL
[08:25:52.213]                   }
[08:25:52.213]                 })
[08:25:52.213]                 withCallingHandlers({
[08:25:52.213]                   {
[08:25:52.213]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.213]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.213]                       ...future.globals.maxSize)) {
[08:25:52.213]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.213]                       on.exit(options(oopts), add = TRUE)
[08:25:52.213]                     }
[08:25:52.213]                     {
[08:25:52.213]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.213]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.213]                         USE.NAMES = FALSE)
[08:25:52.213]                       do.call(mapply, args = args)
[08:25:52.213]                     }
[08:25:52.213]                   }
[08:25:52.213]                 }, immediateCondition = function(cond) {
[08:25:52.213]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.213]                   sendCondition(cond)
[08:25:52.213]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.213]                   {
[08:25:52.213]                     inherits <- base::inherits
[08:25:52.213]                     invokeRestart <- base::invokeRestart
[08:25:52.213]                     is.null <- base::is.null
[08:25:52.213]                     muffled <- FALSE
[08:25:52.213]                     if (inherits(cond, "message")) {
[08:25:52.213]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.213]                       if (muffled) 
[08:25:52.213]                         invokeRestart("muffleMessage")
[08:25:52.213]                     }
[08:25:52.213]                     else if (inherits(cond, "warning")) {
[08:25:52.213]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.213]                       if (muffled) 
[08:25:52.213]                         invokeRestart("muffleWarning")
[08:25:52.213]                     }
[08:25:52.213]                     else if (inherits(cond, "condition")) {
[08:25:52.213]                       if (!is.null(pattern)) {
[08:25:52.213]                         computeRestarts <- base::computeRestarts
[08:25:52.213]                         grepl <- base::grepl
[08:25:52.213]                         restarts <- computeRestarts(cond)
[08:25:52.213]                         for (restart in restarts) {
[08:25:52.213]                           name <- restart$name
[08:25:52.213]                           if (is.null(name)) 
[08:25:52.213]                             next
[08:25:52.213]                           if (!grepl(pattern, name)) 
[08:25:52.213]                             next
[08:25:52.213]                           invokeRestart(restart)
[08:25:52.213]                           muffled <- TRUE
[08:25:52.213]                           break
[08:25:52.213]                         }
[08:25:52.213]                       }
[08:25:52.213]                     }
[08:25:52.213]                     invisible(muffled)
[08:25:52.213]                   }
[08:25:52.213]                   muffleCondition(cond)
[08:25:52.213]                 })
[08:25:52.213]             }))
[08:25:52.213]             future::FutureResult(value = ...future.value$value, 
[08:25:52.213]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.213]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.213]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.213]                     ...future.globalenv.names))
[08:25:52.213]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.213]         }, condition = base::local({
[08:25:52.213]             c <- base::c
[08:25:52.213]             inherits <- base::inherits
[08:25:52.213]             invokeRestart <- base::invokeRestart
[08:25:52.213]             length <- base::length
[08:25:52.213]             list <- base::list
[08:25:52.213]             seq.int <- base::seq.int
[08:25:52.213]             signalCondition <- base::signalCondition
[08:25:52.213]             sys.calls <- base::sys.calls
[08:25:52.213]             `[[` <- base::`[[`
[08:25:52.213]             `+` <- base::`+`
[08:25:52.213]             `<<-` <- base::`<<-`
[08:25:52.213]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.213]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.213]                   3L)]
[08:25:52.213]             }
[08:25:52.213]             function(cond) {
[08:25:52.213]                 is_error <- inherits(cond, "error")
[08:25:52.213]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.213]                   NULL)
[08:25:52.213]                 if (is_error) {
[08:25:52.213]                   sessionInformation <- function() {
[08:25:52.213]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.213]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.213]                       search = base::search(), system = base::Sys.info())
[08:25:52.213]                   }
[08:25:52.213]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.213]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.213]                     cond$call), session = sessionInformation(), 
[08:25:52.213]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.213]                   signalCondition(cond)
[08:25:52.213]                 }
[08:25:52.213]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.213]                 "immediateCondition"))) {
[08:25:52.213]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.213]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.213]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.213]                   if (TRUE && !signal) {
[08:25:52.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.213]                     {
[08:25:52.213]                       inherits <- base::inherits
[08:25:52.213]                       invokeRestart <- base::invokeRestart
[08:25:52.213]                       is.null <- base::is.null
[08:25:52.213]                       muffled <- FALSE
[08:25:52.213]                       if (inherits(cond, "message")) {
[08:25:52.213]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.213]                         if (muffled) 
[08:25:52.213]                           invokeRestart("muffleMessage")
[08:25:52.213]                       }
[08:25:52.213]                       else if (inherits(cond, "warning")) {
[08:25:52.213]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.213]                         if (muffled) 
[08:25:52.213]                           invokeRestart("muffleWarning")
[08:25:52.213]                       }
[08:25:52.213]                       else if (inherits(cond, "condition")) {
[08:25:52.213]                         if (!is.null(pattern)) {
[08:25:52.213]                           computeRestarts <- base::computeRestarts
[08:25:52.213]                           grepl <- base::grepl
[08:25:52.213]                           restarts <- computeRestarts(cond)
[08:25:52.213]                           for (restart in restarts) {
[08:25:52.213]                             name <- restart$name
[08:25:52.213]                             if (is.null(name)) 
[08:25:52.213]                               next
[08:25:52.213]                             if (!grepl(pattern, name)) 
[08:25:52.213]                               next
[08:25:52.213]                             invokeRestart(restart)
[08:25:52.213]                             muffled <- TRUE
[08:25:52.213]                             break
[08:25:52.213]                           }
[08:25:52.213]                         }
[08:25:52.213]                       }
[08:25:52.213]                       invisible(muffled)
[08:25:52.213]                     }
[08:25:52.213]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.213]                   }
[08:25:52.213]                 }
[08:25:52.213]                 else {
[08:25:52.213]                   if (TRUE) {
[08:25:52.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.213]                     {
[08:25:52.213]                       inherits <- base::inherits
[08:25:52.213]                       invokeRestart <- base::invokeRestart
[08:25:52.213]                       is.null <- base::is.null
[08:25:52.213]                       muffled <- FALSE
[08:25:52.213]                       if (inherits(cond, "message")) {
[08:25:52.213]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.213]                         if (muffled) 
[08:25:52.213]                           invokeRestart("muffleMessage")
[08:25:52.213]                       }
[08:25:52.213]                       else if (inherits(cond, "warning")) {
[08:25:52.213]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.213]                         if (muffled) 
[08:25:52.213]                           invokeRestart("muffleWarning")
[08:25:52.213]                       }
[08:25:52.213]                       else if (inherits(cond, "condition")) {
[08:25:52.213]                         if (!is.null(pattern)) {
[08:25:52.213]                           computeRestarts <- base::computeRestarts
[08:25:52.213]                           grepl <- base::grepl
[08:25:52.213]                           restarts <- computeRestarts(cond)
[08:25:52.213]                           for (restart in restarts) {
[08:25:52.213]                             name <- restart$name
[08:25:52.213]                             if (is.null(name)) 
[08:25:52.213]                               next
[08:25:52.213]                             if (!grepl(pattern, name)) 
[08:25:52.213]                               next
[08:25:52.213]                             invokeRestart(restart)
[08:25:52.213]                             muffled <- TRUE
[08:25:52.213]                             break
[08:25:52.213]                           }
[08:25:52.213]                         }
[08:25:52.213]                       }
[08:25:52.213]                       invisible(muffled)
[08:25:52.213]                     }
[08:25:52.213]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.213]                   }
[08:25:52.213]                 }
[08:25:52.213]             }
[08:25:52.213]         }))
[08:25:52.213]     }, error = function(ex) {
[08:25:52.213]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.213]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.213]                 ...future.rng), started = ...future.startTime, 
[08:25:52.213]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.213]             version = "1.8"), class = "FutureResult")
[08:25:52.213]     }, finally = {
[08:25:52.213]         if (!identical(...future.workdir, getwd())) 
[08:25:52.213]             setwd(...future.workdir)
[08:25:52.213]         {
[08:25:52.213]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.213]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.213]             }
[08:25:52.213]             base::options(...future.oldOptions)
[08:25:52.213]             if (.Platform$OS.type == "windows") {
[08:25:52.213]                 old_names <- names(...future.oldEnvVars)
[08:25:52.213]                 envs <- base::Sys.getenv()
[08:25:52.213]                 names <- names(envs)
[08:25:52.213]                 common <- intersect(names, old_names)
[08:25:52.213]                 added <- setdiff(names, old_names)
[08:25:52.213]                 removed <- setdiff(old_names, names)
[08:25:52.213]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.213]                   envs[common]]
[08:25:52.213]                 NAMES <- toupper(changed)
[08:25:52.213]                 args <- list()
[08:25:52.213]                 for (kk in seq_along(NAMES)) {
[08:25:52.213]                   name <- changed[[kk]]
[08:25:52.213]                   NAME <- NAMES[[kk]]
[08:25:52.213]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.213]                     next
[08:25:52.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.213]                 }
[08:25:52.213]                 NAMES <- toupper(added)
[08:25:52.213]                 for (kk in seq_along(NAMES)) {
[08:25:52.213]                   name <- added[[kk]]
[08:25:52.213]                   NAME <- NAMES[[kk]]
[08:25:52.213]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.213]                     next
[08:25:52.213]                   args[[name]] <- ""
[08:25:52.213]                 }
[08:25:52.213]                 NAMES <- toupper(removed)
[08:25:52.213]                 for (kk in seq_along(NAMES)) {
[08:25:52.213]                   name <- removed[[kk]]
[08:25:52.213]                   NAME <- NAMES[[kk]]
[08:25:52.213]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.213]                     next
[08:25:52.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.213]                 }
[08:25:52.213]                 if (length(args) > 0) 
[08:25:52.213]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.213]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.213]             }
[08:25:52.213]             else {
[08:25:52.213]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.213]             }
[08:25:52.213]             {
[08:25:52.213]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.213]                   0L) {
[08:25:52.213]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.213]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.213]                   base::options(opts)
[08:25:52.213]                 }
[08:25:52.213]                 {
[08:25:52.213]                   {
[08:25:52.213]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.213]                     NULL
[08:25:52.213]                   }
[08:25:52.213]                   options(future.plan = NULL)
[08:25:52.213]                   if (is.na(NA_character_)) 
[08:25:52.213]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.213]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.213]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.213]                     .init = FALSE)
[08:25:52.213]                 }
[08:25:52.213]             }
[08:25:52.213]         }
[08:25:52.213]     })
[08:25:52.213]     if (TRUE) {
[08:25:52.213]         base::sink(type = "output", split = FALSE)
[08:25:52.213]         if (TRUE) {
[08:25:52.213]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.213]         }
[08:25:52.213]         else {
[08:25:52.213]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.213]         }
[08:25:52.213]         base::close(...future.stdout)
[08:25:52.213]         ...future.stdout <- NULL
[08:25:52.213]     }
[08:25:52.213]     ...future.result$conditions <- ...future.conditions
[08:25:52.213]     ...future.result$finished <- base::Sys.time()
[08:25:52.213]     ...future.result
[08:25:52.213] }
[08:25:52.216] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[08:25:52.216] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[08:25:52.217] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[08:25:52.217] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:52.217] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.218] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ...
[08:25:52.218] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ... DONE
[08:25:52.218] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:52.218] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.219] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:52.219] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.219] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[08:25:52.219] MultisessionFuture started
[08:25:52.220] - Launch lazy future ... done
[08:25:52.220] run() for ‘MultisessionFuture’ ... done
[08:25:52.220] Created future:
[08:25:52.220] MultisessionFuture:
[08:25:52.220] Label: ‘future_mapply-2’
[08:25:52.220] Expression:
[08:25:52.220] {
[08:25:52.220]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.220]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.220]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.220]         on.exit(options(oopts), add = TRUE)
[08:25:52.220]     }
[08:25:52.220]     {
[08:25:52.220]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.220]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.220]         do.call(mapply, args = args)
[08:25:52.220]     }
[08:25:52.220] }
[08:25:52.220] Lazy evaluation: FALSE
[08:25:52.220] Asynchronous evaluation: TRUE
[08:25:52.220] Local evaluation: TRUE
[08:25:52.220] Environment: R_GlobalEnv
[08:25:52.220] Capture standard output: TRUE
[08:25:52.220] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.220] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.220] Packages: <none>
[08:25:52.220] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.220] Resolved: FALSE
[08:25:52.220] Value: <not collected>
[08:25:52.220] Conditions captured: <none>
[08:25:52.220] Early signaling: FALSE
[08:25:52.220] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.220] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.231] Chunk #2 of 5 ... DONE
[08:25:52.231] Chunk #3 of 5 ...
[08:25:52.232]  - Finding globals in '...' for chunk #3 ...
[08:25:52.232] getGlobalsAndPackages() ...
[08:25:52.232] Searching for globals...
[08:25:52.232] 
[08:25:52.232] Searching for globals ... DONE
[08:25:52.232] - globals: [0] <none>
[08:25:52.232] getGlobalsAndPackages() ... DONE
[08:25:52.232]    + additional globals found: [n=0] 
[08:25:52.233]    + additional namespaces needed: [n=0] 
[08:25:52.233]  - Finding globals in '...' for chunk #3 ... DONE
[08:25:52.233]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:52.233]  - seeds: <none>
[08:25:52.233]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.233] getGlobalsAndPackages() ...
[08:25:52.233] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.233] Resolving globals: FALSE
[08:25:52.234] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:52.234] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:52.234] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.234] 
[08:25:52.234] getGlobalsAndPackages() ... DONE
[08:25:52.235] run() for ‘Future’ ...
[08:25:52.235] - state: ‘created’
[08:25:52.235] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.248] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.249] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.249]   - Field: ‘node’
[08:25:52.249]   - Field: ‘label’
[08:25:52.249]   - Field: ‘local’
[08:25:52.249]   - Field: ‘owner’
[08:25:52.249]   - Field: ‘envir’
[08:25:52.249]   - Field: ‘workers’
[08:25:52.249]   - Field: ‘packages’
[08:25:52.249]   - Field: ‘gc’
[08:25:52.249]   - Field: ‘conditions’
[08:25:52.249]   - Field: ‘persistent’
[08:25:52.250]   - Field: ‘expr’
[08:25:52.250]   - Field: ‘uuid’
[08:25:52.250]   - Field: ‘seed’
[08:25:52.250]   - Field: ‘version’
[08:25:52.250]   - Field: ‘result’
[08:25:52.250]   - Field: ‘asynchronous’
[08:25:52.250]   - Field: ‘calls’
[08:25:52.250]   - Field: ‘globals’
[08:25:52.250]   - Field: ‘stdout’
[08:25:52.250]   - Field: ‘earlySignal’
[08:25:52.250]   - Field: ‘lazy’
[08:25:52.250]   - Field: ‘state’
[08:25:52.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.251] - Launch lazy future ...
[08:25:52.251] Packages needed by the future expression (n = 0): <none>
[08:25:52.251] Packages needed by future strategies (n = 0): <none>
[08:25:52.251] {
[08:25:52.251]     {
[08:25:52.251]         {
[08:25:52.251]             ...future.startTime <- base::Sys.time()
[08:25:52.251]             {
[08:25:52.251]                 {
[08:25:52.251]                   {
[08:25:52.251]                     {
[08:25:52.251]                       base::local({
[08:25:52.251]                         has_future <- base::requireNamespace("future", 
[08:25:52.251]                           quietly = TRUE)
[08:25:52.251]                         if (has_future) {
[08:25:52.251]                           ns <- base::getNamespace("future")
[08:25:52.251]                           version <- ns[[".package"]][["version"]]
[08:25:52.251]                           if (is.null(version)) 
[08:25:52.251]                             version <- utils::packageVersion("future")
[08:25:52.251]                         }
[08:25:52.251]                         else {
[08:25:52.251]                           version <- NULL
[08:25:52.251]                         }
[08:25:52.251]                         if (!has_future || version < "1.8.0") {
[08:25:52.251]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.251]                             "", base::R.version$version.string), 
[08:25:52.251]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.251]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.251]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.251]                               "release", "version")], collapse = " "), 
[08:25:52.251]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.251]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.251]                             info)
[08:25:52.251]                           info <- base::paste(info, collapse = "; ")
[08:25:52.251]                           if (!has_future) {
[08:25:52.251]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.251]                               info)
[08:25:52.251]                           }
[08:25:52.251]                           else {
[08:25:52.251]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.251]                               info, version)
[08:25:52.251]                           }
[08:25:52.251]                           base::stop(msg)
[08:25:52.251]                         }
[08:25:52.251]                       })
[08:25:52.251]                     }
[08:25:52.251]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.251]                     base::options(mc.cores = 1L)
[08:25:52.251]                   }
[08:25:52.251]                   ...future.strategy.old <- future::plan("list")
[08:25:52.251]                   options(future.plan = NULL)
[08:25:52.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.251]                 }
[08:25:52.251]                 ...future.workdir <- getwd()
[08:25:52.251]             }
[08:25:52.251]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.251]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.251]         }
[08:25:52.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.251]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:52.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.251]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.251]             base::names(...future.oldOptions))
[08:25:52.251]     }
[08:25:52.251]     if (FALSE) {
[08:25:52.251]     }
[08:25:52.251]     else {
[08:25:52.251]         if (TRUE) {
[08:25:52.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.251]                 open = "w")
[08:25:52.251]         }
[08:25:52.251]         else {
[08:25:52.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.251]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.251]         }
[08:25:52.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.251]             base::sink(type = "output", split = FALSE)
[08:25:52.251]             base::close(...future.stdout)
[08:25:52.251]         }, add = TRUE)
[08:25:52.251]     }
[08:25:52.251]     ...future.frame <- base::sys.nframe()
[08:25:52.251]     ...future.conditions <- base::list()
[08:25:52.251]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.251]     if (FALSE) {
[08:25:52.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.251]     }
[08:25:52.251]     ...future.result <- base::tryCatch({
[08:25:52.251]         base::withCallingHandlers({
[08:25:52.251]             ...future.value <- base::withVisible(base::local({
[08:25:52.251]                 ...future.makeSendCondition <- base::local({
[08:25:52.251]                   sendCondition <- NULL
[08:25:52.251]                   function(frame = 1L) {
[08:25:52.251]                     if (is.function(sendCondition)) 
[08:25:52.251]                       return(sendCondition)
[08:25:52.251]                     ns <- getNamespace("parallel")
[08:25:52.251]                     if (exists("sendData", mode = "function", 
[08:25:52.251]                       envir = ns)) {
[08:25:52.251]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.251]                         envir = ns)
[08:25:52.251]                       envir <- sys.frame(frame)
[08:25:52.251]                       master <- NULL
[08:25:52.251]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.251]                         !identical(envir, emptyenv())) {
[08:25:52.251]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.251]                           inherits = FALSE)) {
[08:25:52.251]                           master <- get("master", mode = "list", 
[08:25:52.251]                             envir = envir, inherits = FALSE)
[08:25:52.251]                           if (inherits(master, c("SOCKnode", 
[08:25:52.251]                             "SOCK0node"))) {
[08:25:52.251]                             sendCondition <<- function(cond) {
[08:25:52.251]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.251]                                 success = TRUE)
[08:25:52.251]                               parallel_sendData(master, data)
[08:25:52.251]                             }
[08:25:52.251]                             return(sendCondition)
[08:25:52.251]                           }
[08:25:52.251]                         }
[08:25:52.251]                         frame <- frame + 1L
[08:25:52.251]                         envir <- sys.frame(frame)
[08:25:52.251]                       }
[08:25:52.251]                     }
[08:25:52.251]                     sendCondition <<- function(cond) NULL
[08:25:52.251]                   }
[08:25:52.251]                 })
[08:25:52.251]                 withCallingHandlers({
[08:25:52.251]                   {
[08:25:52.251]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.251]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.251]                       ...future.globals.maxSize)) {
[08:25:52.251]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.251]                       on.exit(options(oopts), add = TRUE)
[08:25:52.251]                     }
[08:25:52.251]                     {
[08:25:52.251]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.251]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.251]                         USE.NAMES = FALSE)
[08:25:52.251]                       do.call(mapply, args = args)
[08:25:52.251]                     }
[08:25:52.251]                   }
[08:25:52.251]                 }, immediateCondition = function(cond) {
[08:25:52.251]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.251]                   sendCondition(cond)
[08:25:52.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.251]                   {
[08:25:52.251]                     inherits <- base::inherits
[08:25:52.251]                     invokeRestart <- base::invokeRestart
[08:25:52.251]                     is.null <- base::is.null
[08:25:52.251]                     muffled <- FALSE
[08:25:52.251]                     if (inherits(cond, "message")) {
[08:25:52.251]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.251]                       if (muffled) 
[08:25:52.251]                         invokeRestart("muffleMessage")
[08:25:52.251]                     }
[08:25:52.251]                     else if (inherits(cond, "warning")) {
[08:25:52.251]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.251]                       if (muffled) 
[08:25:52.251]                         invokeRestart("muffleWarning")
[08:25:52.251]                     }
[08:25:52.251]                     else if (inherits(cond, "condition")) {
[08:25:52.251]                       if (!is.null(pattern)) {
[08:25:52.251]                         computeRestarts <- base::computeRestarts
[08:25:52.251]                         grepl <- base::grepl
[08:25:52.251]                         restarts <- computeRestarts(cond)
[08:25:52.251]                         for (restart in restarts) {
[08:25:52.251]                           name <- restart$name
[08:25:52.251]                           if (is.null(name)) 
[08:25:52.251]                             next
[08:25:52.251]                           if (!grepl(pattern, name)) 
[08:25:52.251]                             next
[08:25:52.251]                           invokeRestart(restart)
[08:25:52.251]                           muffled <- TRUE
[08:25:52.251]                           break
[08:25:52.251]                         }
[08:25:52.251]                       }
[08:25:52.251]                     }
[08:25:52.251]                     invisible(muffled)
[08:25:52.251]                   }
[08:25:52.251]                   muffleCondition(cond)
[08:25:52.251]                 })
[08:25:52.251]             }))
[08:25:52.251]             future::FutureResult(value = ...future.value$value, 
[08:25:52.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.251]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.251]                     ...future.globalenv.names))
[08:25:52.251]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.251]         }, condition = base::local({
[08:25:52.251]             c <- base::c
[08:25:52.251]             inherits <- base::inherits
[08:25:52.251]             invokeRestart <- base::invokeRestart
[08:25:52.251]             length <- base::length
[08:25:52.251]             list <- base::list
[08:25:52.251]             seq.int <- base::seq.int
[08:25:52.251]             signalCondition <- base::signalCondition
[08:25:52.251]             sys.calls <- base::sys.calls
[08:25:52.251]             `[[` <- base::`[[`
[08:25:52.251]             `+` <- base::`+`
[08:25:52.251]             `<<-` <- base::`<<-`
[08:25:52.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.251]                   3L)]
[08:25:52.251]             }
[08:25:52.251]             function(cond) {
[08:25:52.251]                 is_error <- inherits(cond, "error")
[08:25:52.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.251]                   NULL)
[08:25:52.251]                 if (is_error) {
[08:25:52.251]                   sessionInformation <- function() {
[08:25:52.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.251]                       search = base::search(), system = base::Sys.info())
[08:25:52.251]                   }
[08:25:52.251]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.251]                     cond$call), session = sessionInformation(), 
[08:25:52.251]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.251]                   signalCondition(cond)
[08:25:52.251]                 }
[08:25:52.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.251]                 "immediateCondition"))) {
[08:25:52.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.251]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.251]                   if (TRUE && !signal) {
[08:25:52.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.251]                     {
[08:25:52.251]                       inherits <- base::inherits
[08:25:52.251]                       invokeRestart <- base::invokeRestart
[08:25:52.251]                       is.null <- base::is.null
[08:25:52.251]                       muffled <- FALSE
[08:25:52.251]                       if (inherits(cond, "message")) {
[08:25:52.251]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.251]                         if (muffled) 
[08:25:52.251]                           invokeRestart("muffleMessage")
[08:25:52.251]                       }
[08:25:52.251]                       else if (inherits(cond, "warning")) {
[08:25:52.251]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.251]                         if (muffled) 
[08:25:52.251]                           invokeRestart("muffleWarning")
[08:25:52.251]                       }
[08:25:52.251]                       else if (inherits(cond, "condition")) {
[08:25:52.251]                         if (!is.null(pattern)) {
[08:25:52.251]                           computeRestarts <- base::computeRestarts
[08:25:52.251]                           grepl <- base::grepl
[08:25:52.251]                           restarts <- computeRestarts(cond)
[08:25:52.251]                           for (restart in restarts) {
[08:25:52.251]                             name <- restart$name
[08:25:52.251]                             if (is.null(name)) 
[08:25:52.251]                               next
[08:25:52.251]                             if (!grepl(pattern, name)) 
[08:25:52.251]                               next
[08:25:52.251]                             invokeRestart(restart)
[08:25:52.251]                             muffled <- TRUE
[08:25:52.251]                             break
[08:25:52.251]                           }
[08:25:52.251]                         }
[08:25:52.251]                       }
[08:25:52.251]                       invisible(muffled)
[08:25:52.251]                     }
[08:25:52.251]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.251]                   }
[08:25:52.251]                 }
[08:25:52.251]                 else {
[08:25:52.251]                   if (TRUE) {
[08:25:52.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.251]                     {
[08:25:52.251]                       inherits <- base::inherits
[08:25:52.251]                       invokeRestart <- base::invokeRestart
[08:25:52.251]                       is.null <- base::is.null
[08:25:52.251]                       muffled <- FALSE
[08:25:52.251]                       if (inherits(cond, "message")) {
[08:25:52.251]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.251]                         if (muffled) 
[08:25:52.251]                           invokeRestart("muffleMessage")
[08:25:52.251]                       }
[08:25:52.251]                       else if (inherits(cond, "warning")) {
[08:25:52.251]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.251]                         if (muffled) 
[08:25:52.251]                           invokeRestart("muffleWarning")
[08:25:52.251]                       }
[08:25:52.251]                       else if (inherits(cond, "condition")) {
[08:25:52.251]                         if (!is.null(pattern)) {
[08:25:52.251]                           computeRestarts <- base::computeRestarts
[08:25:52.251]                           grepl <- base::grepl
[08:25:52.251]                           restarts <- computeRestarts(cond)
[08:25:52.251]                           for (restart in restarts) {
[08:25:52.251]                             name <- restart$name
[08:25:52.251]                             if (is.null(name)) 
[08:25:52.251]                               next
[08:25:52.251]                             if (!grepl(pattern, name)) 
[08:25:52.251]                               next
[08:25:52.251]                             invokeRestart(restart)
[08:25:52.251]                             muffled <- TRUE
[08:25:52.251]                             break
[08:25:52.251]                           }
[08:25:52.251]                         }
[08:25:52.251]                       }
[08:25:52.251]                       invisible(muffled)
[08:25:52.251]                     }
[08:25:52.251]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.251]                   }
[08:25:52.251]                 }
[08:25:52.251]             }
[08:25:52.251]         }))
[08:25:52.251]     }, error = function(ex) {
[08:25:52.251]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.251]                 ...future.rng), started = ...future.startTime, 
[08:25:52.251]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.251]             version = "1.8"), class = "FutureResult")
[08:25:52.251]     }, finally = {
[08:25:52.251]         if (!identical(...future.workdir, getwd())) 
[08:25:52.251]             setwd(...future.workdir)
[08:25:52.251]         {
[08:25:52.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.251]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.251]             }
[08:25:52.251]             base::options(...future.oldOptions)
[08:25:52.251]             if (.Platform$OS.type == "windows") {
[08:25:52.251]                 old_names <- names(...future.oldEnvVars)
[08:25:52.251]                 envs <- base::Sys.getenv()
[08:25:52.251]                 names <- names(envs)
[08:25:52.251]                 common <- intersect(names, old_names)
[08:25:52.251]                 added <- setdiff(names, old_names)
[08:25:52.251]                 removed <- setdiff(old_names, names)
[08:25:52.251]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.251]                   envs[common]]
[08:25:52.251]                 NAMES <- toupper(changed)
[08:25:52.251]                 args <- list()
[08:25:52.251]                 for (kk in seq_along(NAMES)) {
[08:25:52.251]                   name <- changed[[kk]]
[08:25:52.251]                   NAME <- NAMES[[kk]]
[08:25:52.251]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.251]                     next
[08:25:52.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.251]                 }
[08:25:52.251]                 NAMES <- toupper(added)
[08:25:52.251]                 for (kk in seq_along(NAMES)) {
[08:25:52.251]                   name <- added[[kk]]
[08:25:52.251]                   NAME <- NAMES[[kk]]
[08:25:52.251]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.251]                     next
[08:25:52.251]                   args[[name]] <- ""
[08:25:52.251]                 }
[08:25:52.251]                 NAMES <- toupper(removed)
[08:25:52.251]                 for (kk in seq_along(NAMES)) {
[08:25:52.251]                   name <- removed[[kk]]
[08:25:52.251]                   NAME <- NAMES[[kk]]
[08:25:52.251]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.251]                     next
[08:25:52.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.251]                 }
[08:25:52.251]                 if (length(args) > 0) 
[08:25:52.251]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.251]             }
[08:25:52.251]             else {
[08:25:52.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.251]             }
[08:25:52.251]             {
[08:25:52.251]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.251]                   0L) {
[08:25:52.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.251]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.251]                   base::options(opts)
[08:25:52.251]                 }
[08:25:52.251]                 {
[08:25:52.251]                   {
[08:25:52.251]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.251]                     NULL
[08:25:52.251]                   }
[08:25:52.251]                   options(future.plan = NULL)
[08:25:52.251]                   if (is.na(NA_character_)) 
[08:25:52.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.251]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.251]                     .init = FALSE)
[08:25:52.251]                 }
[08:25:52.251]             }
[08:25:52.251]         }
[08:25:52.251]     })
[08:25:52.251]     if (TRUE) {
[08:25:52.251]         base::sink(type = "output", split = FALSE)
[08:25:52.251]         if (TRUE) {
[08:25:52.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.251]         }
[08:25:52.251]         else {
[08:25:52.251]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.251]         }
[08:25:52.251]         base::close(...future.stdout)
[08:25:52.251]         ...future.stdout <- NULL
[08:25:52.251]     }
[08:25:52.251]     ...future.result$conditions <- ...future.conditions
[08:25:52.251]     ...future.result$finished <- base::Sys.time()
[08:25:52.251]     ...future.result
[08:25:52.251] }
[08:25:52.254] Poll #1 (0): usedNodes() = 2, workers = 2
[08:25:52.265] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.265] - Validating connection of MultisessionFuture
[08:25:52.265] - received message: FutureResult
[08:25:52.265] - Received FutureResult
[08:25:52.265] - Erased future from FutureRegistry
[08:25:52.265] result() for ClusterFuture ...
[08:25:52.265] - result already collected: FutureResult
[08:25:52.265] result() for ClusterFuture ... done
[08:25:52.266] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.266] result() for ClusterFuture ...
[08:25:52.266] - result already collected: FutureResult
[08:25:52.266] result() for ClusterFuture ... done
[08:25:52.266] result() for ClusterFuture ...
[08:25:52.266] - result already collected: FutureResult
[08:25:52.266] result() for ClusterFuture ... done
[08:25:52.267] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[08:25:52.267] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[08:25:52.267] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[08:25:52.267] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:52.268] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.268] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ...
[08:25:52.268] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ... DONE
[08:25:52.268] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:52.269] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.269] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:52.269] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.269] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[08:25:52.270] MultisessionFuture started
[08:25:52.270] - Launch lazy future ... done
[08:25:52.270] run() for ‘MultisessionFuture’ ... done
[08:25:52.270] Created future:
[08:25:52.270] MultisessionFuture:
[08:25:52.270] Label: ‘future_mapply-3’
[08:25:52.270] Expression:
[08:25:52.270] {
[08:25:52.270]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.270]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.270]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.270]         on.exit(options(oopts), add = TRUE)
[08:25:52.270]     }
[08:25:52.270]     {
[08:25:52.270]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.270]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.270]         do.call(mapply, args = args)
[08:25:52.270]     }
[08:25:52.270] }
[08:25:52.270] Lazy evaluation: FALSE
[08:25:52.270] Asynchronous evaluation: TRUE
[08:25:52.270] Local evaluation: TRUE
[08:25:52.270] Environment: R_GlobalEnv
[08:25:52.270] Capture standard output: TRUE
[08:25:52.270] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.270] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.270] Packages: <none>
[08:25:52.270] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.270] Resolved: FALSE
[08:25:52.270] Value: <not collected>
[08:25:52.270] Conditions captured: <none>
[08:25:52.270] Early signaling: FALSE
[08:25:52.270] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.270] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.282] Chunk #3 of 5 ... DONE
[08:25:52.282] Chunk #4 of 5 ...
[08:25:52.282]  - Finding globals in '...' for chunk #4 ...
[08:25:52.282] getGlobalsAndPackages() ...
[08:25:52.282] Searching for globals...
[08:25:52.283] 
[08:25:52.283] Searching for globals ... DONE
[08:25:52.283] - globals: [0] <none>
[08:25:52.283] getGlobalsAndPackages() ... DONE
[08:25:52.283]    + additional globals found: [n=0] 
[08:25:52.283]    + additional namespaces needed: [n=0] 
[08:25:52.283]  - Finding globals in '...' for chunk #4 ... DONE
[08:25:52.283]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:52.283]  - seeds: <none>
[08:25:52.283]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.284] getGlobalsAndPackages() ...
[08:25:52.284] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.284] Resolving globals: FALSE
[08:25:52.284] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:52.285] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:52.285] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.285] 
[08:25:52.285] getGlobalsAndPackages() ... DONE
[08:25:52.285] run() for ‘Future’ ...
[08:25:52.285] - state: ‘created’
[08:25:52.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.300]   - Field: ‘node’
[08:25:52.301]   - Field: ‘label’
[08:25:52.301]   - Field: ‘local’
[08:25:52.301]   - Field: ‘owner’
[08:25:52.301]   - Field: ‘envir’
[08:25:52.301]   - Field: ‘workers’
[08:25:52.301]   - Field: ‘packages’
[08:25:52.301]   - Field: ‘gc’
[08:25:52.301]   - Field: ‘conditions’
[08:25:52.301]   - Field: ‘persistent’
[08:25:52.301]   - Field: ‘expr’
[08:25:52.301]   - Field: ‘uuid’
[08:25:52.302]   - Field: ‘seed’
[08:25:52.302]   - Field: ‘version’
[08:25:52.302]   - Field: ‘result’
[08:25:52.302]   - Field: ‘asynchronous’
[08:25:52.302]   - Field: ‘calls’
[08:25:52.302]   - Field: ‘globals’
[08:25:52.302]   - Field: ‘stdout’
[08:25:52.302]   - Field: ‘earlySignal’
[08:25:52.302]   - Field: ‘lazy’
[08:25:52.302]   - Field: ‘state’
[08:25:52.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.303] - Launch lazy future ...
[08:25:52.303] Packages needed by the future expression (n = 0): <none>
[08:25:52.303] Packages needed by future strategies (n = 0): <none>
[08:25:52.303] {
[08:25:52.303]     {
[08:25:52.303]         {
[08:25:52.303]             ...future.startTime <- base::Sys.time()
[08:25:52.303]             {
[08:25:52.303]                 {
[08:25:52.303]                   {
[08:25:52.303]                     {
[08:25:52.303]                       base::local({
[08:25:52.303]                         has_future <- base::requireNamespace("future", 
[08:25:52.303]                           quietly = TRUE)
[08:25:52.303]                         if (has_future) {
[08:25:52.303]                           ns <- base::getNamespace("future")
[08:25:52.303]                           version <- ns[[".package"]][["version"]]
[08:25:52.303]                           if (is.null(version)) 
[08:25:52.303]                             version <- utils::packageVersion("future")
[08:25:52.303]                         }
[08:25:52.303]                         else {
[08:25:52.303]                           version <- NULL
[08:25:52.303]                         }
[08:25:52.303]                         if (!has_future || version < "1.8.0") {
[08:25:52.303]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.303]                             "", base::R.version$version.string), 
[08:25:52.303]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.303]                               "release", "version")], collapse = " "), 
[08:25:52.303]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.303]                             info)
[08:25:52.303]                           info <- base::paste(info, collapse = "; ")
[08:25:52.303]                           if (!has_future) {
[08:25:52.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.303]                               info)
[08:25:52.303]                           }
[08:25:52.303]                           else {
[08:25:52.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.303]                               info, version)
[08:25:52.303]                           }
[08:25:52.303]                           base::stop(msg)
[08:25:52.303]                         }
[08:25:52.303]                       })
[08:25:52.303]                     }
[08:25:52.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.303]                     base::options(mc.cores = 1L)
[08:25:52.303]                   }
[08:25:52.303]                   ...future.strategy.old <- future::plan("list")
[08:25:52.303]                   options(future.plan = NULL)
[08:25:52.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.303]                 }
[08:25:52.303]                 ...future.workdir <- getwd()
[08:25:52.303]             }
[08:25:52.303]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.303]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.303]         }
[08:25:52.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.303]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:52.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.303]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.303]             base::names(...future.oldOptions))
[08:25:52.303]     }
[08:25:52.303]     if (FALSE) {
[08:25:52.303]     }
[08:25:52.303]     else {
[08:25:52.303]         if (TRUE) {
[08:25:52.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.303]                 open = "w")
[08:25:52.303]         }
[08:25:52.303]         else {
[08:25:52.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.303]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.303]         }
[08:25:52.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.303]             base::sink(type = "output", split = FALSE)
[08:25:52.303]             base::close(...future.stdout)
[08:25:52.303]         }, add = TRUE)
[08:25:52.303]     }
[08:25:52.303]     ...future.frame <- base::sys.nframe()
[08:25:52.303]     ...future.conditions <- base::list()
[08:25:52.303]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.303]     if (FALSE) {
[08:25:52.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.303]     }
[08:25:52.303]     ...future.result <- base::tryCatch({
[08:25:52.303]         base::withCallingHandlers({
[08:25:52.303]             ...future.value <- base::withVisible(base::local({
[08:25:52.303]                 ...future.makeSendCondition <- base::local({
[08:25:52.303]                   sendCondition <- NULL
[08:25:52.303]                   function(frame = 1L) {
[08:25:52.303]                     if (is.function(sendCondition)) 
[08:25:52.303]                       return(sendCondition)
[08:25:52.303]                     ns <- getNamespace("parallel")
[08:25:52.303]                     if (exists("sendData", mode = "function", 
[08:25:52.303]                       envir = ns)) {
[08:25:52.303]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.303]                         envir = ns)
[08:25:52.303]                       envir <- sys.frame(frame)
[08:25:52.303]                       master <- NULL
[08:25:52.303]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.303]                         !identical(envir, emptyenv())) {
[08:25:52.303]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.303]                           inherits = FALSE)) {
[08:25:52.303]                           master <- get("master", mode = "list", 
[08:25:52.303]                             envir = envir, inherits = FALSE)
[08:25:52.303]                           if (inherits(master, c("SOCKnode", 
[08:25:52.303]                             "SOCK0node"))) {
[08:25:52.303]                             sendCondition <<- function(cond) {
[08:25:52.303]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.303]                                 success = TRUE)
[08:25:52.303]                               parallel_sendData(master, data)
[08:25:52.303]                             }
[08:25:52.303]                             return(sendCondition)
[08:25:52.303]                           }
[08:25:52.303]                         }
[08:25:52.303]                         frame <- frame + 1L
[08:25:52.303]                         envir <- sys.frame(frame)
[08:25:52.303]                       }
[08:25:52.303]                     }
[08:25:52.303]                     sendCondition <<- function(cond) NULL
[08:25:52.303]                   }
[08:25:52.303]                 })
[08:25:52.303]                 withCallingHandlers({
[08:25:52.303]                   {
[08:25:52.303]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.303]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.303]                       ...future.globals.maxSize)) {
[08:25:52.303]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.303]                       on.exit(options(oopts), add = TRUE)
[08:25:52.303]                     }
[08:25:52.303]                     {
[08:25:52.303]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.303]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.303]                         USE.NAMES = FALSE)
[08:25:52.303]                       do.call(mapply, args = args)
[08:25:52.303]                     }
[08:25:52.303]                   }
[08:25:52.303]                 }, immediateCondition = function(cond) {
[08:25:52.303]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.303]                   sendCondition(cond)
[08:25:52.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.303]                   {
[08:25:52.303]                     inherits <- base::inherits
[08:25:52.303]                     invokeRestart <- base::invokeRestart
[08:25:52.303]                     is.null <- base::is.null
[08:25:52.303]                     muffled <- FALSE
[08:25:52.303]                     if (inherits(cond, "message")) {
[08:25:52.303]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.303]                       if (muffled) 
[08:25:52.303]                         invokeRestart("muffleMessage")
[08:25:52.303]                     }
[08:25:52.303]                     else if (inherits(cond, "warning")) {
[08:25:52.303]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.303]                       if (muffled) 
[08:25:52.303]                         invokeRestart("muffleWarning")
[08:25:52.303]                     }
[08:25:52.303]                     else if (inherits(cond, "condition")) {
[08:25:52.303]                       if (!is.null(pattern)) {
[08:25:52.303]                         computeRestarts <- base::computeRestarts
[08:25:52.303]                         grepl <- base::grepl
[08:25:52.303]                         restarts <- computeRestarts(cond)
[08:25:52.303]                         for (restart in restarts) {
[08:25:52.303]                           name <- restart$name
[08:25:52.303]                           if (is.null(name)) 
[08:25:52.303]                             next
[08:25:52.303]                           if (!grepl(pattern, name)) 
[08:25:52.303]                             next
[08:25:52.303]                           invokeRestart(restart)
[08:25:52.303]                           muffled <- TRUE
[08:25:52.303]                           break
[08:25:52.303]                         }
[08:25:52.303]                       }
[08:25:52.303]                     }
[08:25:52.303]                     invisible(muffled)
[08:25:52.303]                   }
[08:25:52.303]                   muffleCondition(cond)
[08:25:52.303]                 })
[08:25:52.303]             }))
[08:25:52.303]             future::FutureResult(value = ...future.value$value, 
[08:25:52.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.303]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.303]                     ...future.globalenv.names))
[08:25:52.303]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.303]         }, condition = base::local({
[08:25:52.303]             c <- base::c
[08:25:52.303]             inherits <- base::inherits
[08:25:52.303]             invokeRestart <- base::invokeRestart
[08:25:52.303]             length <- base::length
[08:25:52.303]             list <- base::list
[08:25:52.303]             seq.int <- base::seq.int
[08:25:52.303]             signalCondition <- base::signalCondition
[08:25:52.303]             sys.calls <- base::sys.calls
[08:25:52.303]             `[[` <- base::`[[`
[08:25:52.303]             `+` <- base::`+`
[08:25:52.303]             `<<-` <- base::`<<-`
[08:25:52.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.303]                   3L)]
[08:25:52.303]             }
[08:25:52.303]             function(cond) {
[08:25:52.303]                 is_error <- inherits(cond, "error")
[08:25:52.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.303]                   NULL)
[08:25:52.303]                 if (is_error) {
[08:25:52.303]                   sessionInformation <- function() {
[08:25:52.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.303]                       search = base::search(), system = base::Sys.info())
[08:25:52.303]                   }
[08:25:52.303]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.303]                     cond$call), session = sessionInformation(), 
[08:25:52.303]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.303]                   signalCondition(cond)
[08:25:52.303]                 }
[08:25:52.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.303]                 "immediateCondition"))) {
[08:25:52.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.303]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.303]                   if (TRUE && !signal) {
[08:25:52.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.303]                     {
[08:25:52.303]                       inherits <- base::inherits
[08:25:52.303]                       invokeRestart <- base::invokeRestart
[08:25:52.303]                       is.null <- base::is.null
[08:25:52.303]                       muffled <- FALSE
[08:25:52.303]                       if (inherits(cond, "message")) {
[08:25:52.303]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.303]                         if (muffled) 
[08:25:52.303]                           invokeRestart("muffleMessage")
[08:25:52.303]                       }
[08:25:52.303]                       else if (inherits(cond, "warning")) {
[08:25:52.303]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.303]                         if (muffled) 
[08:25:52.303]                           invokeRestart("muffleWarning")
[08:25:52.303]                       }
[08:25:52.303]                       else if (inherits(cond, "condition")) {
[08:25:52.303]                         if (!is.null(pattern)) {
[08:25:52.303]                           computeRestarts <- base::computeRestarts
[08:25:52.303]                           grepl <- base::grepl
[08:25:52.303]                           restarts <- computeRestarts(cond)
[08:25:52.303]                           for (restart in restarts) {
[08:25:52.303]                             name <- restart$name
[08:25:52.303]                             if (is.null(name)) 
[08:25:52.303]                               next
[08:25:52.303]                             if (!grepl(pattern, name)) 
[08:25:52.303]                               next
[08:25:52.303]                             invokeRestart(restart)
[08:25:52.303]                             muffled <- TRUE
[08:25:52.303]                             break
[08:25:52.303]                           }
[08:25:52.303]                         }
[08:25:52.303]                       }
[08:25:52.303]                       invisible(muffled)
[08:25:52.303]                     }
[08:25:52.303]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.303]                   }
[08:25:52.303]                 }
[08:25:52.303]                 else {
[08:25:52.303]                   if (TRUE) {
[08:25:52.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.303]                     {
[08:25:52.303]                       inherits <- base::inherits
[08:25:52.303]                       invokeRestart <- base::invokeRestart
[08:25:52.303]                       is.null <- base::is.null
[08:25:52.303]                       muffled <- FALSE
[08:25:52.303]                       if (inherits(cond, "message")) {
[08:25:52.303]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.303]                         if (muffled) 
[08:25:52.303]                           invokeRestart("muffleMessage")
[08:25:52.303]                       }
[08:25:52.303]                       else if (inherits(cond, "warning")) {
[08:25:52.303]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.303]                         if (muffled) 
[08:25:52.303]                           invokeRestart("muffleWarning")
[08:25:52.303]                       }
[08:25:52.303]                       else if (inherits(cond, "condition")) {
[08:25:52.303]                         if (!is.null(pattern)) {
[08:25:52.303]                           computeRestarts <- base::computeRestarts
[08:25:52.303]                           grepl <- base::grepl
[08:25:52.303]                           restarts <- computeRestarts(cond)
[08:25:52.303]                           for (restart in restarts) {
[08:25:52.303]                             name <- restart$name
[08:25:52.303]                             if (is.null(name)) 
[08:25:52.303]                               next
[08:25:52.303]                             if (!grepl(pattern, name)) 
[08:25:52.303]                               next
[08:25:52.303]                             invokeRestart(restart)
[08:25:52.303]                             muffled <- TRUE
[08:25:52.303]                             break
[08:25:52.303]                           }
[08:25:52.303]                         }
[08:25:52.303]                       }
[08:25:52.303]                       invisible(muffled)
[08:25:52.303]                     }
[08:25:52.303]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.303]                   }
[08:25:52.303]                 }
[08:25:52.303]             }
[08:25:52.303]         }))
[08:25:52.303]     }, error = function(ex) {
[08:25:52.303]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.303]                 ...future.rng), started = ...future.startTime, 
[08:25:52.303]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.303]             version = "1.8"), class = "FutureResult")
[08:25:52.303]     }, finally = {
[08:25:52.303]         if (!identical(...future.workdir, getwd())) 
[08:25:52.303]             setwd(...future.workdir)
[08:25:52.303]         {
[08:25:52.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.303]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.303]             }
[08:25:52.303]             base::options(...future.oldOptions)
[08:25:52.303]             if (.Platform$OS.type == "windows") {
[08:25:52.303]                 old_names <- names(...future.oldEnvVars)
[08:25:52.303]                 envs <- base::Sys.getenv()
[08:25:52.303]                 names <- names(envs)
[08:25:52.303]                 common <- intersect(names, old_names)
[08:25:52.303]                 added <- setdiff(names, old_names)
[08:25:52.303]                 removed <- setdiff(old_names, names)
[08:25:52.303]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.303]                   envs[common]]
[08:25:52.303]                 NAMES <- toupper(changed)
[08:25:52.303]                 args <- list()
[08:25:52.303]                 for (kk in seq_along(NAMES)) {
[08:25:52.303]                   name <- changed[[kk]]
[08:25:52.303]                   NAME <- NAMES[[kk]]
[08:25:52.303]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.303]                     next
[08:25:52.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.303]                 }
[08:25:52.303]                 NAMES <- toupper(added)
[08:25:52.303]                 for (kk in seq_along(NAMES)) {
[08:25:52.303]                   name <- added[[kk]]
[08:25:52.303]                   NAME <- NAMES[[kk]]
[08:25:52.303]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.303]                     next
[08:25:52.303]                   args[[name]] <- ""
[08:25:52.303]                 }
[08:25:52.303]                 NAMES <- toupper(removed)
[08:25:52.303]                 for (kk in seq_along(NAMES)) {
[08:25:52.303]                   name <- removed[[kk]]
[08:25:52.303]                   NAME <- NAMES[[kk]]
[08:25:52.303]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.303]                     next
[08:25:52.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.303]                 }
[08:25:52.303]                 if (length(args) > 0) 
[08:25:52.303]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.303]             }
[08:25:52.303]             else {
[08:25:52.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.303]             }
[08:25:52.303]             {
[08:25:52.303]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.303]                   0L) {
[08:25:52.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.303]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.303]                   base::options(opts)
[08:25:52.303]                 }
[08:25:52.303]                 {
[08:25:52.303]                   {
[08:25:52.303]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.303]                     NULL
[08:25:52.303]                   }
[08:25:52.303]                   options(future.plan = NULL)
[08:25:52.303]                   if (is.na(NA_character_)) 
[08:25:52.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.303]                     .init = FALSE)
[08:25:52.303]                 }
[08:25:52.303]             }
[08:25:52.303]         }
[08:25:52.303]     })
[08:25:52.303]     if (TRUE) {
[08:25:52.303]         base::sink(type = "output", split = FALSE)
[08:25:52.303]         if (TRUE) {
[08:25:52.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.303]         }
[08:25:52.303]         else {
[08:25:52.303]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.303]         }
[08:25:52.303]         base::close(...future.stdout)
[08:25:52.303]         ...future.stdout <- NULL
[08:25:52.303]     }
[08:25:52.303]     ...future.result$conditions <- ...future.conditions
[08:25:52.303]     ...future.result$finished <- base::Sys.time()
[08:25:52.303]     ...future.result
[08:25:52.303] }
[08:25:52.306] Poll #1 (0): usedNodes() = 2, workers = 2
[08:25:52.317] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.317] - Validating connection of MultisessionFuture
[08:25:52.317] - received message: FutureResult
[08:25:52.317] - Received FutureResult
[08:25:52.317] - Erased future from FutureRegistry
[08:25:52.317] result() for ClusterFuture ...
[08:25:52.317] - result already collected: FutureResult
[08:25:52.318] result() for ClusterFuture ... done
[08:25:52.318] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.318] result() for ClusterFuture ...
[08:25:52.318] - result already collected: FutureResult
[08:25:52.318] result() for ClusterFuture ... done
[08:25:52.318] result() for ClusterFuture ...
[08:25:52.318] - result already collected: FutureResult
[08:25:52.318] result() for ClusterFuture ... done
[08:25:52.319] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[08:25:52.319] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[08:25:52.320] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[08:25:52.320] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:52.320] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.320] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ...
[08:25:52.321] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ... DONE
[08:25:52.321] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:52.321] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.321] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:52.322] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.322] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[08:25:52.322] MultisessionFuture started
[08:25:52.323] - Launch lazy future ... done
[08:25:52.323] run() for ‘MultisessionFuture’ ... done
[08:25:52.323] Created future:
[08:25:52.323] MultisessionFuture:
[08:25:52.323] Label: ‘future_mapply-4’
[08:25:52.323] Expression:
[08:25:52.323] {
[08:25:52.323]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.323]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.323]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.323]         on.exit(options(oopts), add = TRUE)
[08:25:52.323]     }
[08:25:52.323]     {
[08:25:52.323]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.323]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.323]         do.call(mapply, args = args)
[08:25:52.323]     }
[08:25:52.323] }
[08:25:52.323] Lazy evaluation: FALSE
[08:25:52.323] Asynchronous evaluation: TRUE
[08:25:52.323] Local evaluation: TRUE
[08:25:52.323] Environment: R_GlobalEnv
[08:25:52.323] Capture standard output: TRUE
[08:25:52.323] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.323] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.323] Packages: <none>
[08:25:52.323] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.323] Resolved: FALSE
[08:25:52.323] Value: <not collected>
[08:25:52.323] Conditions captured: <none>
[08:25:52.323] Early signaling: FALSE
[08:25:52.323] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.323] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.334] Chunk #4 of 5 ... DONE
[08:25:52.335] Chunk #5 of 5 ...
[08:25:52.335]  - Finding globals in '...' for chunk #5 ...
[08:25:52.335] getGlobalsAndPackages() ...
[08:25:52.335] Searching for globals...
[08:25:52.335] 
[08:25:52.335] Searching for globals ... DONE
[08:25:52.336] - globals: [0] <none>
[08:25:52.336] getGlobalsAndPackages() ... DONE
[08:25:52.336]    + additional globals found: [n=0] 
[08:25:52.336]    + additional namespaces needed: [n=0] 
[08:25:52.336]  - Finding globals in '...' for chunk #5 ... DONE
[08:25:52.336]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[08:25:52.336]  - seeds: <none>
[08:25:52.336]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.336] getGlobalsAndPackages() ...
[08:25:52.336] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.336] Resolving globals: FALSE
[08:25:52.337] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:52.337] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:52.338] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.338] 
[08:25:52.338] getGlobalsAndPackages() ... DONE
[08:25:52.338] run() for ‘Future’ ...
[08:25:52.338] - state: ‘created’
[08:25:52.338] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.353] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.354]   - Field: ‘node’
[08:25:52.354]   - Field: ‘label’
[08:25:52.354]   - Field: ‘local’
[08:25:52.354]   - Field: ‘owner’
[08:25:52.354]   - Field: ‘envir’
[08:25:52.354]   - Field: ‘workers’
[08:25:52.354]   - Field: ‘packages’
[08:25:52.354]   - Field: ‘gc’
[08:25:52.355]   - Field: ‘conditions’
[08:25:52.355]   - Field: ‘persistent’
[08:25:52.355]   - Field: ‘expr’
[08:25:52.355]   - Field: ‘uuid’
[08:25:52.355]   - Field: ‘seed’
[08:25:52.355]   - Field: ‘version’
[08:25:52.355]   - Field: ‘result’
[08:25:52.355]   - Field: ‘asynchronous’
[08:25:52.355]   - Field: ‘calls’
[08:25:52.355]   - Field: ‘globals’
[08:25:52.355]   - Field: ‘stdout’
[08:25:52.356]   - Field: ‘earlySignal’
[08:25:52.356]   - Field: ‘lazy’
[08:25:52.358]   - Field: ‘state’
[08:25:52.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.358] - Launch lazy future ...
[08:25:52.359] Packages needed by the future expression (n = 0): <none>
[08:25:52.359] Packages needed by future strategies (n = 0): <none>
[08:25:52.359] {
[08:25:52.359]     {
[08:25:52.359]         {
[08:25:52.359]             ...future.startTime <- base::Sys.time()
[08:25:52.359]             {
[08:25:52.359]                 {
[08:25:52.359]                   {
[08:25:52.359]                     {
[08:25:52.359]                       base::local({
[08:25:52.359]                         has_future <- base::requireNamespace("future", 
[08:25:52.359]                           quietly = TRUE)
[08:25:52.359]                         if (has_future) {
[08:25:52.359]                           ns <- base::getNamespace("future")
[08:25:52.359]                           version <- ns[[".package"]][["version"]]
[08:25:52.359]                           if (is.null(version)) 
[08:25:52.359]                             version <- utils::packageVersion("future")
[08:25:52.359]                         }
[08:25:52.359]                         else {
[08:25:52.359]                           version <- NULL
[08:25:52.359]                         }
[08:25:52.359]                         if (!has_future || version < "1.8.0") {
[08:25:52.359]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.359]                             "", base::R.version$version.string), 
[08:25:52.359]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.359]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.359]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.359]                               "release", "version")], collapse = " "), 
[08:25:52.359]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.359]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.359]                             info)
[08:25:52.359]                           info <- base::paste(info, collapse = "; ")
[08:25:52.359]                           if (!has_future) {
[08:25:52.359]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.359]                               info)
[08:25:52.359]                           }
[08:25:52.359]                           else {
[08:25:52.359]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.359]                               info, version)
[08:25:52.359]                           }
[08:25:52.359]                           base::stop(msg)
[08:25:52.359]                         }
[08:25:52.359]                       })
[08:25:52.359]                     }
[08:25:52.359]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.359]                     base::options(mc.cores = 1L)
[08:25:52.359]                   }
[08:25:52.359]                   ...future.strategy.old <- future::plan("list")
[08:25:52.359]                   options(future.plan = NULL)
[08:25:52.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.359]                 }
[08:25:52.359]                 ...future.workdir <- getwd()
[08:25:52.359]             }
[08:25:52.359]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.359]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.359]         }
[08:25:52.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.359]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[08:25:52.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.359]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.359]             base::names(...future.oldOptions))
[08:25:52.359]     }
[08:25:52.359]     if (FALSE) {
[08:25:52.359]     }
[08:25:52.359]     else {
[08:25:52.359]         if (TRUE) {
[08:25:52.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.359]                 open = "w")
[08:25:52.359]         }
[08:25:52.359]         else {
[08:25:52.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.359]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.359]         }
[08:25:52.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.359]             base::sink(type = "output", split = FALSE)
[08:25:52.359]             base::close(...future.stdout)
[08:25:52.359]         }, add = TRUE)
[08:25:52.359]     }
[08:25:52.359]     ...future.frame <- base::sys.nframe()
[08:25:52.359]     ...future.conditions <- base::list()
[08:25:52.359]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.359]     if (FALSE) {
[08:25:52.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.359]     }
[08:25:52.359]     ...future.result <- base::tryCatch({
[08:25:52.359]         base::withCallingHandlers({
[08:25:52.359]             ...future.value <- base::withVisible(base::local({
[08:25:52.359]                 ...future.makeSendCondition <- base::local({
[08:25:52.359]                   sendCondition <- NULL
[08:25:52.359]                   function(frame = 1L) {
[08:25:52.359]                     if (is.function(sendCondition)) 
[08:25:52.359]                       return(sendCondition)
[08:25:52.359]                     ns <- getNamespace("parallel")
[08:25:52.359]                     if (exists("sendData", mode = "function", 
[08:25:52.359]                       envir = ns)) {
[08:25:52.359]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.359]                         envir = ns)
[08:25:52.359]                       envir <- sys.frame(frame)
[08:25:52.359]                       master <- NULL
[08:25:52.359]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.359]                         !identical(envir, emptyenv())) {
[08:25:52.359]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.359]                           inherits = FALSE)) {
[08:25:52.359]                           master <- get("master", mode = "list", 
[08:25:52.359]                             envir = envir, inherits = FALSE)
[08:25:52.359]                           if (inherits(master, c("SOCKnode", 
[08:25:52.359]                             "SOCK0node"))) {
[08:25:52.359]                             sendCondition <<- function(cond) {
[08:25:52.359]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.359]                                 success = TRUE)
[08:25:52.359]                               parallel_sendData(master, data)
[08:25:52.359]                             }
[08:25:52.359]                             return(sendCondition)
[08:25:52.359]                           }
[08:25:52.359]                         }
[08:25:52.359]                         frame <- frame + 1L
[08:25:52.359]                         envir <- sys.frame(frame)
[08:25:52.359]                       }
[08:25:52.359]                     }
[08:25:52.359]                     sendCondition <<- function(cond) NULL
[08:25:52.359]                   }
[08:25:52.359]                 })
[08:25:52.359]                 withCallingHandlers({
[08:25:52.359]                   {
[08:25:52.359]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.359]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.359]                       ...future.globals.maxSize)) {
[08:25:52.359]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.359]                       on.exit(options(oopts), add = TRUE)
[08:25:52.359]                     }
[08:25:52.359]                     {
[08:25:52.359]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.359]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.359]                         USE.NAMES = FALSE)
[08:25:52.359]                       do.call(mapply, args = args)
[08:25:52.359]                     }
[08:25:52.359]                   }
[08:25:52.359]                 }, immediateCondition = function(cond) {
[08:25:52.359]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.359]                   sendCondition(cond)
[08:25:52.359]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.359]                   {
[08:25:52.359]                     inherits <- base::inherits
[08:25:52.359]                     invokeRestart <- base::invokeRestart
[08:25:52.359]                     is.null <- base::is.null
[08:25:52.359]                     muffled <- FALSE
[08:25:52.359]                     if (inherits(cond, "message")) {
[08:25:52.359]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.359]                       if (muffled) 
[08:25:52.359]                         invokeRestart("muffleMessage")
[08:25:52.359]                     }
[08:25:52.359]                     else if (inherits(cond, "warning")) {
[08:25:52.359]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.359]                       if (muffled) 
[08:25:52.359]                         invokeRestart("muffleWarning")
[08:25:52.359]                     }
[08:25:52.359]                     else if (inherits(cond, "condition")) {
[08:25:52.359]                       if (!is.null(pattern)) {
[08:25:52.359]                         computeRestarts <- base::computeRestarts
[08:25:52.359]                         grepl <- base::grepl
[08:25:52.359]                         restarts <- computeRestarts(cond)
[08:25:52.359]                         for (restart in restarts) {
[08:25:52.359]                           name <- restart$name
[08:25:52.359]                           if (is.null(name)) 
[08:25:52.359]                             next
[08:25:52.359]                           if (!grepl(pattern, name)) 
[08:25:52.359]                             next
[08:25:52.359]                           invokeRestart(restart)
[08:25:52.359]                           muffled <- TRUE
[08:25:52.359]                           break
[08:25:52.359]                         }
[08:25:52.359]                       }
[08:25:52.359]                     }
[08:25:52.359]                     invisible(muffled)
[08:25:52.359]                   }
[08:25:52.359]                   muffleCondition(cond)
[08:25:52.359]                 })
[08:25:52.359]             }))
[08:25:52.359]             future::FutureResult(value = ...future.value$value, 
[08:25:52.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.359]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.359]                     ...future.globalenv.names))
[08:25:52.359]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.359]         }, condition = base::local({
[08:25:52.359]             c <- base::c
[08:25:52.359]             inherits <- base::inherits
[08:25:52.359]             invokeRestart <- base::invokeRestart
[08:25:52.359]             length <- base::length
[08:25:52.359]             list <- base::list
[08:25:52.359]             seq.int <- base::seq.int
[08:25:52.359]             signalCondition <- base::signalCondition
[08:25:52.359]             sys.calls <- base::sys.calls
[08:25:52.359]             `[[` <- base::`[[`
[08:25:52.359]             `+` <- base::`+`
[08:25:52.359]             `<<-` <- base::`<<-`
[08:25:52.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.359]                   3L)]
[08:25:52.359]             }
[08:25:52.359]             function(cond) {
[08:25:52.359]                 is_error <- inherits(cond, "error")
[08:25:52.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.359]                   NULL)
[08:25:52.359]                 if (is_error) {
[08:25:52.359]                   sessionInformation <- function() {
[08:25:52.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.359]                       search = base::search(), system = base::Sys.info())
[08:25:52.359]                   }
[08:25:52.359]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.359]                     cond$call), session = sessionInformation(), 
[08:25:52.359]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.359]                   signalCondition(cond)
[08:25:52.359]                 }
[08:25:52.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.359]                 "immediateCondition"))) {
[08:25:52.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.359]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.359]                   if (TRUE && !signal) {
[08:25:52.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.359]                     {
[08:25:52.359]                       inherits <- base::inherits
[08:25:52.359]                       invokeRestart <- base::invokeRestart
[08:25:52.359]                       is.null <- base::is.null
[08:25:52.359]                       muffled <- FALSE
[08:25:52.359]                       if (inherits(cond, "message")) {
[08:25:52.359]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.359]                         if (muffled) 
[08:25:52.359]                           invokeRestart("muffleMessage")
[08:25:52.359]                       }
[08:25:52.359]                       else if (inherits(cond, "warning")) {
[08:25:52.359]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.359]                         if (muffled) 
[08:25:52.359]                           invokeRestart("muffleWarning")
[08:25:52.359]                       }
[08:25:52.359]                       else if (inherits(cond, "condition")) {
[08:25:52.359]                         if (!is.null(pattern)) {
[08:25:52.359]                           computeRestarts <- base::computeRestarts
[08:25:52.359]                           grepl <- base::grepl
[08:25:52.359]                           restarts <- computeRestarts(cond)
[08:25:52.359]                           for (restart in restarts) {
[08:25:52.359]                             name <- restart$name
[08:25:52.359]                             if (is.null(name)) 
[08:25:52.359]                               next
[08:25:52.359]                             if (!grepl(pattern, name)) 
[08:25:52.359]                               next
[08:25:52.359]                             invokeRestart(restart)
[08:25:52.359]                             muffled <- TRUE
[08:25:52.359]                             break
[08:25:52.359]                           }
[08:25:52.359]                         }
[08:25:52.359]                       }
[08:25:52.359]                       invisible(muffled)
[08:25:52.359]                     }
[08:25:52.359]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.359]                   }
[08:25:52.359]                 }
[08:25:52.359]                 else {
[08:25:52.359]                   if (TRUE) {
[08:25:52.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.359]                     {
[08:25:52.359]                       inherits <- base::inherits
[08:25:52.359]                       invokeRestart <- base::invokeRestart
[08:25:52.359]                       is.null <- base::is.null
[08:25:52.359]                       muffled <- FALSE
[08:25:52.359]                       if (inherits(cond, "message")) {
[08:25:52.359]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.359]                         if (muffled) 
[08:25:52.359]                           invokeRestart("muffleMessage")
[08:25:52.359]                       }
[08:25:52.359]                       else if (inherits(cond, "warning")) {
[08:25:52.359]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.359]                         if (muffled) 
[08:25:52.359]                           invokeRestart("muffleWarning")
[08:25:52.359]                       }
[08:25:52.359]                       else if (inherits(cond, "condition")) {
[08:25:52.359]                         if (!is.null(pattern)) {
[08:25:52.359]                           computeRestarts <- base::computeRestarts
[08:25:52.359]                           grepl <- base::grepl
[08:25:52.359]                           restarts <- computeRestarts(cond)
[08:25:52.359]                           for (restart in restarts) {
[08:25:52.359]                             name <- restart$name
[08:25:52.359]                             if (is.null(name)) 
[08:25:52.359]                               next
[08:25:52.359]                             if (!grepl(pattern, name)) 
[08:25:52.359]                               next
[08:25:52.359]                             invokeRestart(restart)
[08:25:52.359]                             muffled <- TRUE
[08:25:52.359]                             break
[08:25:52.359]                           }
[08:25:52.359]                         }
[08:25:52.359]                       }
[08:25:52.359]                       invisible(muffled)
[08:25:52.359]                     }
[08:25:52.359]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.359]                   }
[08:25:52.359]                 }
[08:25:52.359]             }
[08:25:52.359]         }))
[08:25:52.359]     }, error = function(ex) {
[08:25:52.359]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.359]                 ...future.rng), started = ...future.startTime, 
[08:25:52.359]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.359]             version = "1.8"), class = "FutureResult")
[08:25:52.359]     }, finally = {
[08:25:52.359]         if (!identical(...future.workdir, getwd())) 
[08:25:52.359]             setwd(...future.workdir)
[08:25:52.359]         {
[08:25:52.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.359]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.359]             }
[08:25:52.359]             base::options(...future.oldOptions)
[08:25:52.359]             if (.Platform$OS.type == "windows") {
[08:25:52.359]                 old_names <- names(...future.oldEnvVars)
[08:25:52.359]                 envs <- base::Sys.getenv()
[08:25:52.359]                 names <- names(envs)
[08:25:52.359]                 common <- intersect(names, old_names)
[08:25:52.359]                 added <- setdiff(names, old_names)
[08:25:52.359]                 removed <- setdiff(old_names, names)
[08:25:52.359]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.359]                   envs[common]]
[08:25:52.359]                 NAMES <- toupper(changed)
[08:25:52.359]                 args <- list()
[08:25:52.359]                 for (kk in seq_along(NAMES)) {
[08:25:52.359]                   name <- changed[[kk]]
[08:25:52.359]                   NAME <- NAMES[[kk]]
[08:25:52.359]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.359]                     next
[08:25:52.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.359]                 }
[08:25:52.359]                 NAMES <- toupper(added)
[08:25:52.359]                 for (kk in seq_along(NAMES)) {
[08:25:52.359]                   name <- added[[kk]]
[08:25:52.359]                   NAME <- NAMES[[kk]]
[08:25:52.359]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.359]                     next
[08:25:52.359]                   args[[name]] <- ""
[08:25:52.359]                 }
[08:25:52.359]                 NAMES <- toupper(removed)
[08:25:52.359]                 for (kk in seq_along(NAMES)) {
[08:25:52.359]                   name <- removed[[kk]]
[08:25:52.359]                   NAME <- NAMES[[kk]]
[08:25:52.359]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.359]                     next
[08:25:52.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.359]                 }
[08:25:52.359]                 if (length(args) > 0) 
[08:25:52.359]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.359]             }
[08:25:52.359]             else {
[08:25:52.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.359]             }
[08:25:52.359]             {
[08:25:52.359]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.359]                   0L) {
[08:25:52.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.359]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.359]                   base::options(opts)
[08:25:52.359]                 }
[08:25:52.359]                 {
[08:25:52.359]                   {
[08:25:52.359]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.359]                     NULL
[08:25:52.359]                   }
[08:25:52.359]                   options(future.plan = NULL)
[08:25:52.359]                   if (is.na(NA_character_)) 
[08:25:52.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.359]                     .init = FALSE)
[08:25:52.359]                 }
[08:25:52.359]             }
[08:25:52.359]         }
[08:25:52.359]     })
[08:25:52.359]     if (TRUE) {
[08:25:52.359]         base::sink(type = "output", split = FALSE)
[08:25:52.359]         if (TRUE) {
[08:25:52.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.359]         }
[08:25:52.359]         else {
[08:25:52.359]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.359]         }
[08:25:52.359]         base::close(...future.stdout)
[08:25:52.359]         ...future.stdout <- NULL
[08:25:52.359]     }
[08:25:52.359]     ...future.result$conditions <- ...future.conditions
[08:25:52.359]     ...future.result$finished <- base::Sys.time()
[08:25:52.359]     ...future.result
[08:25:52.359] }
[08:25:52.361] Poll #1 (0): usedNodes() = 2, workers = 2
[08:25:52.372] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.372] - Validating connection of MultisessionFuture
[08:25:52.373] - received message: FutureResult
[08:25:52.373] - Received FutureResult
[08:25:52.373] - Erased future from FutureRegistry
[08:25:52.373] result() for ClusterFuture ...
[08:25:52.373] - result already collected: FutureResult
[08:25:52.373] result() for ClusterFuture ... done
[08:25:52.373] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.373] result() for ClusterFuture ...
[08:25:52.373] - result already collected: FutureResult
[08:25:52.374] result() for ClusterFuture ... done
[08:25:52.374] result() for ClusterFuture ...
[08:25:52.374] - result already collected: FutureResult
[08:25:52.374] result() for ClusterFuture ... done
[08:25:52.375] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[08:25:52.375] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[08:25:52.375] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[08:25:52.375] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:52.376] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.376] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ...
[08:25:52.376] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #1 ... DONE
[08:25:52.376] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:52.376] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.377] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:52.377] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.377] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[08:25:52.377] MultisessionFuture started
[08:25:52.378] - Launch lazy future ... done
[08:25:52.378] run() for ‘MultisessionFuture’ ... done
[08:25:52.378] Created future:
[08:25:52.378] MultisessionFuture:
[08:25:52.378] Label: ‘future_mapply-5’
[08:25:52.378] Expression:
[08:25:52.378] {
[08:25:52.378]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.378]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.378]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.378]         on.exit(options(oopts), add = TRUE)
[08:25:52.378]     }
[08:25:52.378]     {
[08:25:52.378]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.378]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.378]         do.call(mapply, args = args)
[08:25:52.378]     }
[08:25:52.378] }
[08:25:52.378] Lazy evaluation: FALSE
[08:25:52.378] Asynchronous evaluation: TRUE
[08:25:52.378] Local evaluation: TRUE
[08:25:52.378] Environment: R_GlobalEnv
[08:25:52.378] Capture standard output: TRUE
[08:25:52.378] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.378] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.378] Packages: <none>
[08:25:52.378] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.378] Resolved: FALSE
[08:25:52.378] Value: <not collected>
[08:25:52.378] Conditions captured: <none>
[08:25:52.378] Early signaling: FALSE
[08:25:52.378] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.378] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.389] Chunk #5 of 5 ... DONE
[08:25:52.389] Launching 5 futures (chunks) ... DONE
[08:25:52.390] Resolving 5 futures (chunks) ...
[08:25:52.390] resolve() on list ...
[08:25:52.390]  recursive: 0
[08:25:52.390]  length: 5
[08:25:52.390] 
[08:25:52.390] Future #1
[08:25:52.390] result() for ClusterFuture ...
[08:25:52.390] - result already collected: FutureResult
[08:25:52.390] result() for ClusterFuture ... done
[08:25:52.390] result() for ClusterFuture ...
[08:25:52.391] - result already collected: FutureResult
[08:25:52.391] result() for ClusterFuture ... done
[08:25:52.391] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:52.391] - nx: 5
[08:25:52.391] - relay: TRUE
[08:25:52.391] - stdout: TRUE
[08:25:52.391] - signal: TRUE
[08:25:52.391] - resignal: FALSE
[08:25:52.391] - force: TRUE
[08:25:52.391] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[08:25:52.391] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[08:25:52.391]  - until=1
[08:25:52.392]  - relaying element #1
[08:25:52.392] result() for ClusterFuture ...
[08:25:52.392] - result already collected: FutureResult
[08:25:52.392] result() for ClusterFuture ... done
[08:25:52.392] result() for ClusterFuture ...
[08:25:52.392] - result already collected: FutureResult
[08:25:52.392] result() for ClusterFuture ... done
[08:25:52.392] result() for ClusterFuture ...
[08:25:52.392] - result already collected: FutureResult
[08:25:52.392] result() for ClusterFuture ... done
[08:25:52.392] result() for ClusterFuture ...
[08:25:52.392] - result already collected: FutureResult
[08:25:52.393] result() for ClusterFuture ... done
[08:25:52.393] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:52.393] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:52.393] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:52.393]  length: 4 (resolved future 1)
[08:25:52.393] Future #2
[08:25:52.393] result() for ClusterFuture ...
[08:25:52.393] - result already collected: FutureResult
[08:25:52.393] result() for ClusterFuture ... done
[08:25:52.393] result() for ClusterFuture ...
[08:25:52.393] - result already collected: FutureResult
[08:25:52.394] result() for ClusterFuture ... done
[08:25:52.394] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:52.394] - nx: 5
[08:25:52.394] - relay: TRUE
[08:25:52.394] - stdout: TRUE
[08:25:52.394] - signal: TRUE
[08:25:52.394] - resignal: FALSE
[08:25:52.394] - force: TRUE
[08:25:52.394] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:52.394] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[08:25:52.394]  - until=2
[08:25:52.394]  - relaying element #2
[08:25:52.394] result() for ClusterFuture ...
[08:25:52.395] - result already collected: FutureResult
[08:25:52.395] result() for ClusterFuture ... done
[08:25:52.395] result() for ClusterFuture ...
[08:25:52.395] - result already collected: FutureResult
[08:25:52.395] result() for ClusterFuture ... done
[08:25:52.395] result() for ClusterFuture ...
[08:25:52.395] - result already collected: FutureResult
[08:25:52.395] result() for ClusterFuture ... done
[08:25:52.395] result() for ClusterFuture ...
[08:25:52.395] - result already collected: FutureResult
[08:25:52.395] result() for ClusterFuture ... done
[08:25:52.395] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:52.396] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:52.396] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:52.396]  length: 3 (resolved future 2)
[08:25:52.396] Future #3
[08:25:52.396] result() for ClusterFuture ...
[08:25:52.396] - result already collected: FutureResult
[08:25:52.396] result() for ClusterFuture ... done
[08:25:52.396] result() for ClusterFuture ...
[08:25:52.396] - result already collected: FutureResult
[08:25:52.396] result() for ClusterFuture ... done
[08:25:52.396] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:25:52.397] - nx: 5
[08:25:52.397] - relay: TRUE
[08:25:52.397] - stdout: TRUE
[08:25:52.397] - signal: TRUE
[08:25:52.397] - resignal: FALSE
[08:25:52.397] - force: TRUE
[08:25:52.397] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:52.397] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[08:25:52.397]  - until=3
[08:25:52.397]  - relaying element #3
[08:25:52.397] result() for ClusterFuture ...
[08:25:52.397] - result already collected: FutureResult
[08:25:52.397] result() for ClusterFuture ... done
[08:25:52.398] result() for ClusterFuture ...
[08:25:52.398] - result already collected: FutureResult
[08:25:52.398] result() for ClusterFuture ... done
[08:25:52.398] result() for ClusterFuture ...
[08:25:52.398] - result already collected: FutureResult
[08:25:52.398] result() for ClusterFuture ... done
[08:25:52.398] result() for ClusterFuture ...
[08:25:52.398] - result already collected: FutureResult
[08:25:52.398] result() for ClusterFuture ... done
[08:25:52.398] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:52.398] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:52.398] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:25:52.399]  length: 2 (resolved future 3)
[08:25:52.399] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.399] - Validating connection of MultisessionFuture
[08:25:52.399] - received message: FutureResult
[08:25:52.400] - Received FutureResult
[08:25:52.400] - Erased future from FutureRegistry
[08:25:52.400] result() for ClusterFuture ...
[08:25:52.400] - result already collected: FutureResult
[08:25:52.400] result() for ClusterFuture ... done
[08:25:52.400] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.400] Future #4
[08:25:52.400] result() for ClusterFuture ...
[08:25:52.400] - result already collected: FutureResult
[08:25:52.400] result() for ClusterFuture ... done
[08:25:52.400] result() for ClusterFuture ...
[08:25:52.400] - result already collected: FutureResult
[08:25:52.401] result() for ClusterFuture ... done
[08:25:52.401] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:25:52.401] - nx: 5
[08:25:52.401] - relay: TRUE
[08:25:52.401] - stdout: TRUE
[08:25:52.401] - signal: TRUE
[08:25:52.401] - resignal: FALSE
[08:25:52.401] - force: TRUE
[08:25:52.401] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:52.401] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[08:25:52.401]  - until=4
[08:25:52.401]  - relaying element #4
[08:25:52.402] result() for ClusterFuture ...
[08:25:52.402] - result already collected: FutureResult
[08:25:52.402] result() for ClusterFuture ... done
[08:25:52.402] result() for ClusterFuture ...
[08:25:52.402] - result already collected: FutureResult
[08:25:52.402] result() for ClusterFuture ... done
[08:25:52.402] result() for ClusterFuture ...
[08:25:52.402] - result already collected: FutureResult
[08:25:52.402] result() for ClusterFuture ... done
[08:25:52.402] result() for ClusterFuture ...
[08:25:52.402] - result already collected: FutureResult
[08:25:52.402] result() for ClusterFuture ... done
[08:25:52.403] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:52.403] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:52.403] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:25:52.403]  length: 1 (resolved future 4)
[08:25:52.424] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.424] - Validating connection of MultisessionFuture
[08:25:52.424] - received message: FutureResult
[08:25:52.424] - Received FutureResult
[08:25:52.425] - Erased future from FutureRegistry
[08:25:52.425] result() for ClusterFuture ...
[08:25:52.425] - result already collected: FutureResult
[08:25:52.425] result() for ClusterFuture ... done
[08:25:52.425] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.425] Future #5
[08:25:52.425] result() for ClusterFuture ...
[08:25:52.425] - result already collected: FutureResult
[08:25:52.425] result() for ClusterFuture ... done
[08:25:52.425] result() for ClusterFuture ...
[08:25:52.425] - result already collected: FutureResult
[08:25:52.425] result() for ClusterFuture ... done
[08:25:52.426] signalConditionsASAP(MultisessionFuture, pos=5) ...
[08:25:52.426] - nx: 5
[08:25:52.426] - relay: TRUE
[08:25:52.426] - stdout: TRUE
[08:25:52.426] - signal: TRUE
[08:25:52.426] - resignal: FALSE
[08:25:52.426] - force: TRUE
[08:25:52.426] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:52.426] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[08:25:52.426]  - until=5
[08:25:52.426]  - relaying element #5
[08:25:52.426] result() for ClusterFuture ...
[08:25:52.427] - result already collected: FutureResult
[08:25:52.427] result() for ClusterFuture ... done
[08:25:52.427] result() for ClusterFuture ...
[08:25:52.427] - result already collected: FutureResult
[08:25:52.427] result() for ClusterFuture ... done
[08:25:52.427] result() for ClusterFuture ...
[08:25:52.427] - result already collected: FutureResult
[08:25:52.427] result() for ClusterFuture ... done
[08:25:52.427] result() for ClusterFuture ...
[08:25:52.427] - result already collected: FutureResult
[08:25:52.427] result() for ClusterFuture ... done
[08:25:52.427] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:52.428] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:52.428] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[08:25:52.428]  length: 0 (resolved future 5)
[08:25:52.428] Relaying remaining futures
[08:25:52.428] signalConditionsASAP(NULL, pos=0) ...
[08:25:52.428] - nx: 5
[08:25:52.428] - relay: TRUE
[08:25:52.428] - stdout: TRUE
[08:25:52.428] - signal: TRUE
[08:25:52.428] - resignal: FALSE
[08:25:52.428] - force: TRUE
[08:25:52.428] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:52.428] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[08:25:52.429] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:52.429] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[08:25:52.429] signalConditionsASAP(NULL, pos=0) ... done
[08:25:52.429] resolve() on list ... DONE
[08:25:52.429] result() for ClusterFuture ...
[08:25:52.429] - result already collected: FutureResult
[08:25:52.429] result() for ClusterFuture ... done
[08:25:52.429] result() for ClusterFuture ...
[08:25:52.429] - result already collected: FutureResult
[08:25:52.429] result() for ClusterFuture ... done
[08:25:52.429] result() for ClusterFuture ...
[08:25:52.430] - result already collected: FutureResult
[08:25:52.430] result() for ClusterFuture ... done
[08:25:52.430] result() for ClusterFuture ...
[08:25:52.430] - result already collected: FutureResult
[08:25:52.430] result() for ClusterFuture ... done
[08:25:52.430] result() for ClusterFuture ...
[08:25:52.430] - result already collected: FutureResult
[08:25:52.430] result() for ClusterFuture ... done
[08:25:52.430] result() for ClusterFuture ...
[08:25:52.430] - result already collected: FutureResult
[08:25:52.430] result() for ClusterFuture ... done
[08:25:52.430] result() for ClusterFuture ...
[08:25:52.431] - result already collected: FutureResult
[08:25:52.431] result() for ClusterFuture ... done
[08:25:52.431] result() for ClusterFuture ...
[08:25:52.431] - result already collected: FutureResult
[08:25:52.431] result() for ClusterFuture ... done
[08:25:52.431] result() for ClusterFuture ...
[08:25:52.431] - result already collected: FutureResult
[08:25:52.431] result() for ClusterFuture ... done
[08:25:52.431] result() for ClusterFuture ...
[08:25:52.431] - result already collected: FutureResult
[08:25:52.431] result() for ClusterFuture ... done
[08:25:52.431]  - Number of value chunks collected: 5
[08:25:52.432] Resolving 5 futures (chunks) ... DONE
[08:25:52.432] Reducing values from 5 chunks ...
[08:25:52.432]  - Number of values collected after concatenation: 5
[08:25:52.432]  - Number of values expected: 5
[08:25:52.432] Reducing values from 5 chunks ... DONE
[08:25:52.432] future_mapply() ... DONE
[08:25:52.432] future_mapply() ...
[08:25:52.434] Number of chunks: 2
[08:25:52.434] getGlobalsAndPackagesXApply() ...
[08:25:52.434]  - future.globals: TRUE
[08:25:52.434] getGlobalsAndPackages() ...
[08:25:52.434] Searching for globals...
[08:25:52.436] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:52.436] Searching for globals ... DONE
[08:25:52.436] Resolving globals: FALSE
[08:25:52.436] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:52.436] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:52.437] - globals: [1] ‘FUN’
[08:25:52.437] 
[08:25:52.437] getGlobalsAndPackages() ... DONE
[08:25:52.437]  - globals found/used: [n=1] ‘FUN’
[08:25:52.437]  - needed namespaces: [n=0] 
[08:25:52.437] Finding globals ... DONE
[08:25:52.437] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:52.437] List of 2
[08:25:52.437]  $ ...future.FUN:function (C, k)  
[08:25:52.437]  $ MoreArgs     : list()
[08:25:52.437]  - attr(*, "where")=List of 2
[08:25:52.437]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:52.437]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:52.437]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:52.437]  - attr(*, "resolved")= logi FALSE
[08:25:52.437]  - attr(*, "total_size")= num NA
[08:25:52.440] Packages to be attached in all futures: [n=0] 
[08:25:52.440] getGlobalsAndPackagesXApply() ... DONE
[08:25:52.440] Number of futures (= number of chunks): 2
[08:25:52.440] Launching 2 futures (chunks) ...
[08:25:52.440] Chunk #1 of 2 ...
[08:25:52.440]  - Finding globals in '...' for chunk #1 ...
[08:25:52.440] getGlobalsAndPackages() ...
[08:25:52.441] Searching for globals...
[08:25:52.441] 
[08:25:52.441] Searching for globals ... DONE
[08:25:52.441] - globals: [0] <none>
[08:25:52.441] getGlobalsAndPackages() ... DONE
[08:25:52.441]    + additional globals found: [n=0] 
[08:25:52.441]    + additional namespaces needed: [n=0] 
[08:25:52.441]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:52.441]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:52.442]  - seeds: <none>
[08:25:52.442]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.442] getGlobalsAndPackages() ...
[08:25:52.442] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.442] Resolving globals: FALSE
[08:25:52.442] The total size of the 5 globals is 880 bytes (880 bytes)
[08:25:52.443] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:52.443] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.443] 
[08:25:52.443] getGlobalsAndPackages() ... DONE
[08:25:52.443] run() for ‘Future’ ...
[08:25:52.443] - state: ‘created’
[08:25:52.444] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.457] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.457]   - Field: ‘node’
[08:25:52.457]   - Field: ‘label’
[08:25:52.457]   - Field: ‘local’
[08:25:52.458]   - Field: ‘owner’
[08:25:52.458]   - Field: ‘envir’
[08:25:52.458]   - Field: ‘workers’
[08:25:52.458]   - Field: ‘packages’
[08:25:52.458]   - Field: ‘gc’
[08:25:52.458]   - Field: ‘conditions’
[08:25:52.458]   - Field: ‘persistent’
[08:25:52.458]   - Field: ‘expr’
[08:25:52.458]   - Field: ‘uuid’
[08:25:52.458]   - Field: ‘seed’
[08:25:52.458]   - Field: ‘version’
[08:25:52.458]   - Field: ‘result’
[08:25:52.459]   - Field: ‘asynchronous’
[08:25:52.459]   - Field: ‘calls’
[08:25:52.459]   - Field: ‘globals’
[08:25:52.459]   - Field: ‘stdout’
[08:25:52.459]   - Field: ‘earlySignal’
[08:25:52.459]   - Field: ‘lazy’
[08:25:52.459]   - Field: ‘state’
[08:25:52.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.459] - Launch lazy future ...
[08:25:52.460] Packages needed by the future expression (n = 0): <none>
[08:25:52.460] Packages needed by future strategies (n = 0): <none>
[08:25:52.460] {
[08:25:52.460]     {
[08:25:52.460]         {
[08:25:52.460]             ...future.startTime <- base::Sys.time()
[08:25:52.460]             {
[08:25:52.460]                 {
[08:25:52.460]                   {
[08:25:52.460]                     {
[08:25:52.460]                       base::local({
[08:25:52.460]                         has_future <- base::requireNamespace("future", 
[08:25:52.460]                           quietly = TRUE)
[08:25:52.460]                         if (has_future) {
[08:25:52.460]                           ns <- base::getNamespace("future")
[08:25:52.460]                           version <- ns[[".package"]][["version"]]
[08:25:52.460]                           if (is.null(version)) 
[08:25:52.460]                             version <- utils::packageVersion("future")
[08:25:52.460]                         }
[08:25:52.460]                         else {
[08:25:52.460]                           version <- NULL
[08:25:52.460]                         }
[08:25:52.460]                         if (!has_future || version < "1.8.0") {
[08:25:52.460]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.460]                             "", base::R.version$version.string), 
[08:25:52.460]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.460]                               "release", "version")], collapse = " "), 
[08:25:52.460]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.460]                             info)
[08:25:52.460]                           info <- base::paste(info, collapse = "; ")
[08:25:52.460]                           if (!has_future) {
[08:25:52.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.460]                               info)
[08:25:52.460]                           }
[08:25:52.460]                           else {
[08:25:52.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.460]                               info, version)
[08:25:52.460]                           }
[08:25:52.460]                           base::stop(msg)
[08:25:52.460]                         }
[08:25:52.460]                       })
[08:25:52.460]                     }
[08:25:52.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.460]                     base::options(mc.cores = 1L)
[08:25:52.460]                   }
[08:25:52.460]                   ...future.strategy.old <- future::plan("list")
[08:25:52.460]                   options(future.plan = NULL)
[08:25:52.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.460]                 }
[08:25:52.460]                 ...future.workdir <- getwd()
[08:25:52.460]             }
[08:25:52.460]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.460]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.460]         }
[08:25:52.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.460]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:52.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.460]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.460]             base::names(...future.oldOptions))
[08:25:52.460]     }
[08:25:52.460]     if (FALSE) {
[08:25:52.460]     }
[08:25:52.460]     else {
[08:25:52.460]         if (TRUE) {
[08:25:52.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.460]                 open = "w")
[08:25:52.460]         }
[08:25:52.460]         else {
[08:25:52.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.460]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.460]         }
[08:25:52.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.460]             base::sink(type = "output", split = FALSE)
[08:25:52.460]             base::close(...future.stdout)
[08:25:52.460]         }, add = TRUE)
[08:25:52.460]     }
[08:25:52.460]     ...future.frame <- base::sys.nframe()
[08:25:52.460]     ...future.conditions <- base::list()
[08:25:52.460]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.460]     if (FALSE) {
[08:25:52.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.460]     }
[08:25:52.460]     ...future.result <- base::tryCatch({
[08:25:52.460]         base::withCallingHandlers({
[08:25:52.460]             ...future.value <- base::withVisible(base::local({
[08:25:52.460]                 ...future.makeSendCondition <- base::local({
[08:25:52.460]                   sendCondition <- NULL
[08:25:52.460]                   function(frame = 1L) {
[08:25:52.460]                     if (is.function(sendCondition)) 
[08:25:52.460]                       return(sendCondition)
[08:25:52.460]                     ns <- getNamespace("parallel")
[08:25:52.460]                     if (exists("sendData", mode = "function", 
[08:25:52.460]                       envir = ns)) {
[08:25:52.460]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.460]                         envir = ns)
[08:25:52.460]                       envir <- sys.frame(frame)
[08:25:52.460]                       master <- NULL
[08:25:52.460]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.460]                         !identical(envir, emptyenv())) {
[08:25:52.460]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.460]                           inherits = FALSE)) {
[08:25:52.460]                           master <- get("master", mode = "list", 
[08:25:52.460]                             envir = envir, inherits = FALSE)
[08:25:52.460]                           if (inherits(master, c("SOCKnode", 
[08:25:52.460]                             "SOCK0node"))) {
[08:25:52.460]                             sendCondition <<- function(cond) {
[08:25:52.460]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.460]                                 success = TRUE)
[08:25:52.460]                               parallel_sendData(master, data)
[08:25:52.460]                             }
[08:25:52.460]                             return(sendCondition)
[08:25:52.460]                           }
[08:25:52.460]                         }
[08:25:52.460]                         frame <- frame + 1L
[08:25:52.460]                         envir <- sys.frame(frame)
[08:25:52.460]                       }
[08:25:52.460]                     }
[08:25:52.460]                     sendCondition <<- function(cond) NULL
[08:25:52.460]                   }
[08:25:52.460]                 })
[08:25:52.460]                 withCallingHandlers({
[08:25:52.460]                   {
[08:25:52.460]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.460]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.460]                       ...future.globals.maxSize)) {
[08:25:52.460]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.460]                       on.exit(options(oopts), add = TRUE)
[08:25:52.460]                     }
[08:25:52.460]                     {
[08:25:52.460]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.460]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.460]                         USE.NAMES = FALSE)
[08:25:52.460]                       do.call(mapply, args = args)
[08:25:52.460]                     }
[08:25:52.460]                   }
[08:25:52.460]                 }, immediateCondition = function(cond) {
[08:25:52.460]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.460]                   sendCondition(cond)
[08:25:52.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.460]                   {
[08:25:52.460]                     inherits <- base::inherits
[08:25:52.460]                     invokeRestart <- base::invokeRestart
[08:25:52.460]                     is.null <- base::is.null
[08:25:52.460]                     muffled <- FALSE
[08:25:52.460]                     if (inherits(cond, "message")) {
[08:25:52.460]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.460]                       if (muffled) 
[08:25:52.460]                         invokeRestart("muffleMessage")
[08:25:52.460]                     }
[08:25:52.460]                     else if (inherits(cond, "warning")) {
[08:25:52.460]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.460]                       if (muffled) 
[08:25:52.460]                         invokeRestart("muffleWarning")
[08:25:52.460]                     }
[08:25:52.460]                     else if (inherits(cond, "condition")) {
[08:25:52.460]                       if (!is.null(pattern)) {
[08:25:52.460]                         computeRestarts <- base::computeRestarts
[08:25:52.460]                         grepl <- base::grepl
[08:25:52.460]                         restarts <- computeRestarts(cond)
[08:25:52.460]                         for (restart in restarts) {
[08:25:52.460]                           name <- restart$name
[08:25:52.460]                           if (is.null(name)) 
[08:25:52.460]                             next
[08:25:52.460]                           if (!grepl(pattern, name)) 
[08:25:52.460]                             next
[08:25:52.460]                           invokeRestart(restart)
[08:25:52.460]                           muffled <- TRUE
[08:25:52.460]                           break
[08:25:52.460]                         }
[08:25:52.460]                       }
[08:25:52.460]                     }
[08:25:52.460]                     invisible(muffled)
[08:25:52.460]                   }
[08:25:52.460]                   muffleCondition(cond)
[08:25:52.460]                 })
[08:25:52.460]             }))
[08:25:52.460]             future::FutureResult(value = ...future.value$value, 
[08:25:52.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.460]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.460]                     ...future.globalenv.names))
[08:25:52.460]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.460]         }, condition = base::local({
[08:25:52.460]             c <- base::c
[08:25:52.460]             inherits <- base::inherits
[08:25:52.460]             invokeRestart <- base::invokeRestart
[08:25:52.460]             length <- base::length
[08:25:52.460]             list <- base::list
[08:25:52.460]             seq.int <- base::seq.int
[08:25:52.460]             signalCondition <- base::signalCondition
[08:25:52.460]             sys.calls <- base::sys.calls
[08:25:52.460]             `[[` <- base::`[[`
[08:25:52.460]             `+` <- base::`+`
[08:25:52.460]             `<<-` <- base::`<<-`
[08:25:52.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.460]                   3L)]
[08:25:52.460]             }
[08:25:52.460]             function(cond) {
[08:25:52.460]                 is_error <- inherits(cond, "error")
[08:25:52.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.460]                   NULL)
[08:25:52.460]                 if (is_error) {
[08:25:52.460]                   sessionInformation <- function() {
[08:25:52.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.460]                       search = base::search(), system = base::Sys.info())
[08:25:52.460]                   }
[08:25:52.460]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.460]                     cond$call), session = sessionInformation(), 
[08:25:52.460]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.460]                   signalCondition(cond)
[08:25:52.460]                 }
[08:25:52.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.460]                 "immediateCondition"))) {
[08:25:52.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.460]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.460]                   if (TRUE && !signal) {
[08:25:52.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.460]                     {
[08:25:52.460]                       inherits <- base::inherits
[08:25:52.460]                       invokeRestart <- base::invokeRestart
[08:25:52.460]                       is.null <- base::is.null
[08:25:52.460]                       muffled <- FALSE
[08:25:52.460]                       if (inherits(cond, "message")) {
[08:25:52.460]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.460]                         if (muffled) 
[08:25:52.460]                           invokeRestart("muffleMessage")
[08:25:52.460]                       }
[08:25:52.460]                       else if (inherits(cond, "warning")) {
[08:25:52.460]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.460]                         if (muffled) 
[08:25:52.460]                           invokeRestart("muffleWarning")
[08:25:52.460]                       }
[08:25:52.460]                       else if (inherits(cond, "condition")) {
[08:25:52.460]                         if (!is.null(pattern)) {
[08:25:52.460]                           computeRestarts <- base::computeRestarts
[08:25:52.460]                           grepl <- base::grepl
[08:25:52.460]                           restarts <- computeRestarts(cond)
[08:25:52.460]                           for (restart in restarts) {
[08:25:52.460]                             name <- restart$name
[08:25:52.460]                             if (is.null(name)) 
[08:25:52.460]                               next
[08:25:52.460]                             if (!grepl(pattern, name)) 
[08:25:52.460]                               next
[08:25:52.460]                             invokeRestart(restart)
[08:25:52.460]                             muffled <- TRUE
[08:25:52.460]                             break
[08:25:52.460]                           }
[08:25:52.460]                         }
[08:25:52.460]                       }
[08:25:52.460]                       invisible(muffled)
[08:25:52.460]                     }
[08:25:52.460]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.460]                   }
[08:25:52.460]                 }
[08:25:52.460]                 else {
[08:25:52.460]                   if (TRUE) {
[08:25:52.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.460]                     {
[08:25:52.460]                       inherits <- base::inherits
[08:25:52.460]                       invokeRestart <- base::invokeRestart
[08:25:52.460]                       is.null <- base::is.null
[08:25:52.460]                       muffled <- FALSE
[08:25:52.460]                       if (inherits(cond, "message")) {
[08:25:52.460]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.460]                         if (muffled) 
[08:25:52.460]                           invokeRestart("muffleMessage")
[08:25:52.460]                       }
[08:25:52.460]                       else if (inherits(cond, "warning")) {
[08:25:52.460]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.460]                         if (muffled) 
[08:25:52.460]                           invokeRestart("muffleWarning")
[08:25:52.460]                       }
[08:25:52.460]                       else if (inherits(cond, "condition")) {
[08:25:52.460]                         if (!is.null(pattern)) {
[08:25:52.460]                           computeRestarts <- base::computeRestarts
[08:25:52.460]                           grepl <- base::grepl
[08:25:52.460]                           restarts <- computeRestarts(cond)
[08:25:52.460]                           for (restart in restarts) {
[08:25:52.460]                             name <- restart$name
[08:25:52.460]                             if (is.null(name)) 
[08:25:52.460]                               next
[08:25:52.460]                             if (!grepl(pattern, name)) 
[08:25:52.460]                               next
[08:25:52.460]                             invokeRestart(restart)
[08:25:52.460]                             muffled <- TRUE
[08:25:52.460]                             break
[08:25:52.460]                           }
[08:25:52.460]                         }
[08:25:52.460]                       }
[08:25:52.460]                       invisible(muffled)
[08:25:52.460]                     }
[08:25:52.460]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.460]                   }
[08:25:52.460]                 }
[08:25:52.460]             }
[08:25:52.460]         }))
[08:25:52.460]     }, error = function(ex) {
[08:25:52.460]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.460]                 ...future.rng), started = ...future.startTime, 
[08:25:52.460]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.460]             version = "1.8"), class = "FutureResult")
[08:25:52.460]     }, finally = {
[08:25:52.460]         if (!identical(...future.workdir, getwd())) 
[08:25:52.460]             setwd(...future.workdir)
[08:25:52.460]         {
[08:25:52.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.460]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.460]             }
[08:25:52.460]             base::options(...future.oldOptions)
[08:25:52.460]             if (.Platform$OS.type == "windows") {
[08:25:52.460]                 old_names <- names(...future.oldEnvVars)
[08:25:52.460]                 envs <- base::Sys.getenv()
[08:25:52.460]                 names <- names(envs)
[08:25:52.460]                 common <- intersect(names, old_names)
[08:25:52.460]                 added <- setdiff(names, old_names)
[08:25:52.460]                 removed <- setdiff(old_names, names)
[08:25:52.460]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.460]                   envs[common]]
[08:25:52.460]                 NAMES <- toupper(changed)
[08:25:52.460]                 args <- list()
[08:25:52.460]                 for (kk in seq_along(NAMES)) {
[08:25:52.460]                   name <- changed[[kk]]
[08:25:52.460]                   NAME <- NAMES[[kk]]
[08:25:52.460]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.460]                     next
[08:25:52.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.460]                 }
[08:25:52.460]                 NAMES <- toupper(added)
[08:25:52.460]                 for (kk in seq_along(NAMES)) {
[08:25:52.460]                   name <- added[[kk]]
[08:25:52.460]                   NAME <- NAMES[[kk]]
[08:25:52.460]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.460]                     next
[08:25:52.460]                   args[[name]] <- ""
[08:25:52.460]                 }
[08:25:52.460]                 NAMES <- toupper(removed)
[08:25:52.460]                 for (kk in seq_along(NAMES)) {
[08:25:52.460]                   name <- removed[[kk]]
[08:25:52.460]                   NAME <- NAMES[[kk]]
[08:25:52.460]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.460]                     next
[08:25:52.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.460]                 }
[08:25:52.460]                 if (length(args) > 0) 
[08:25:52.460]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.460]             }
[08:25:52.460]             else {
[08:25:52.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.460]             }
[08:25:52.460]             {
[08:25:52.460]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.460]                   0L) {
[08:25:52.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.460]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.460]                   base::options(opts)
[08:25:52.460]                 }
[08:25:52.460]                 {
[08:25:52.460]                   {
[08:25:52.460]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.460]                     NULL
[08:25:52.460]                   }
[08:25:52.460]                   options(future.plan = NULL)
[08:25:52.460]                   if (is.na(NA_character_)) 
[08:25:52.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.460]                     .init = FALSE)
[08:25:52.460]                 }
[08:25:52.460]             }
[08:25:52.460]         }
[08:25:52.460]     })
[08:25:52.460]     if (TRUE) {
[08:25:52.460]         base::sink(type = "output", split = FALSE)
[08:25:52.460]         if (TRUE) {
[08:25:52.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.460]         }
[08:25:52.460]         else {
[08:25:52.460]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.460]         }
[08:25:52.460]         base::close(...future.stdout)
[08:25:52.460]         ...future.stdout <- NULL
[08:25:52.460]     }
[08:25:52.460]     ...future.result$conditions <- ...future.conditions
[08:25:52.460]     ...future.result$finished <- base::Sys.time()
[08:25:52.460]     ...future.result
[08:25:52.460] }
[08:25:52.463] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[08:25:52.463] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[08:25:52.464] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[08:25:52.464] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[08:25:52.464] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[08:25:52.464] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[08:25:52.465] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[08:25:52.465] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:52.465] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.465] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:52.466] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.466] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[08:25:52.466] MultisessionFuture started
[08:25:52.466] - Launch lazy future ... done
[08:25:52.466] run() for ‘MultisessionFuture’ ... done
[08:25:52.467] Created future:
[08:25:52.467] MultisessionFuture:
[08:25:52.467] Label: ‘future_.mapply-1’
[08:25:52.467] Expression:
[08:25:52.467] {
[08:25:52.467]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.467]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.467]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.467]         on.exit(options(oopts), add = TRUE)
[08:25:52.467]     }
[08:25:52.467]     {
[08:25:52.467]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.467]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.467]         do.call(mapply, args = args)
[08:25:52.467]     }
[08:25:52.467] }
[08:25:52.467] Lazy evaluation: FALSE
[08:25:52.467] Asynchronous evaluation: TRUE
[08:25:52.467] Local evaluation: TRUE
[08:25:52.467] Environment: R_GlobalEnv
[08:25:52.467] Capture standard output: TRUE
[08:25:52.467] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.467] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.467] Packages: <none>
[08:25:52.467] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.467] Resolved: FALSE
[08:25:52.467] Value: <not collected>
[08:25:52.467] Conditions captured: <none>
[08:25:52.467] Early signaling: FALSE
[08:25:52.467] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.467] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.478] Chunk #1 of 2 ... DONE
[08:25:52.478] Chunk #2 of 2 ...
[08:25:52.478]  - Finding globals in '...' for chunk #2 ...
[08:25:52.479] getGlobalsAndPackages() ...
[08:25:52.479] Searching for globals...
[08:25:52.479] 
[08:25:52.479] Searching for globals ... DONE
[08:25:52.479] - globals: [0] <none>
[08:25:52.479] getGlobalsAndPackages() ... DONE
[08:25:52.479]    + additional globals found: [n=0] 
[08:25:52.480]    + additional namespaces needed: [n=0] 
[08:25:52.480]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:52.480]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:52.480]  - seeds: <none>
[08:25:52.480]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.480] getGlobalsAndPackages() ...
[08:25:52.480] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.480] Resolving globals: FALSE
[08:25:52.481] The total size of the 5 globals is 909 bytes (909 bytes)
[08:25:52.481] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:52.481] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.481] 
[08:25:52.481] getGlobalsAndPackages() ... DONE
[08:25:52.482] run() for ‘Future’ ...
[08:25:52.482] - state: ‘created’
[08:25:52.482] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.497] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.497] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.497]   - Field: ‘node’
[08:25:52.497]   - Field: ‘label’
[08:25:52.497]   - Field: ‘local’
[08:25:52.497]   - Field: ‘owner’
[08:25:52.497]   - Field: ‘envir’
[08:25:52.498]   - Field: ‘workers’
[08:25:52.498]   - Field: ‘packages’
[08:25:52.498]   - Field: ‘gc’
[08:25:52.498]   - Field: ‘conditions’
[08:25:52.498]   - Field: ‘persistent’
[08:25:52.498]   - Field: ‘expr’
[08:25:52.498]   - Field: ‘uuid’
[08:25:52.498]   - Field: ‘seed’
[08:25:52.498]   - Field: ‘version’
[08:25:52.498]   - Field: ‘result’
[08:25:52.498]   - Field: ‘asynchronous’
[08:25:52.499]   - Field: ‘calls’
[08:25:52.499]   - Field: ‘globals’
[08:25:52.499]   - Field: ‘stdout’
[08:25:52.499]   - Field: ‘earlySignal’
[08:25:52.499]   - Field: ‘lazy’
[08:25:52.499]   - Field: ‘state’
[08:25:52.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.499] - Launch lazy future ...
[08:25:52.499] Packages needed by the future expression (n = 0): <none>
[08:25:52.500] Packages needed by future strategies (n = 0): <none>
[08:25:52.500] {
[08:25:52.500]     {
[08:25:52.500]         {
[08:25:52.500]             ...future.startTime <- base::Sys.time()
[08:25:52.500]             {
[08:25:52.500]                 {
[08:25:52.500]                   {
[08:25:52.500]                     {
[08:25:52.500]                       base::local({
[08:25:52.500]                         has_future <- base::requireNamespace("future", 
[08:25:52.500]                           quietly = TRUE)
[08:25:52.500]                         if (has_future) {
[08:25:52.500]                           ns <- base::getNamespace("future")
[08:25:52.500]                           version <- ns[[".package"]][["version"]]
[08:25:52.500]                           if (is.null(version)) 
[08:25:52.500]                             version <- utils::packageVersion("future")
[08:25:52.500]                         }
[08:25:52.500]                         else {
[08:25:52.500]                           version <- NULL
[08:25:52.500]                         }
[08:25:52.500]                         if (!has_future || version < "1.8.0") {
[08:25:52.500]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.500]                             "", base::R.version$version.string), 
[08:25:52.500]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.500]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.500]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.500]                               "release", "version")], collapse = " "), 
[08:25:52.500]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.500]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.500]                             info)
[08:25:52.500]                           info <- base::paste(info, collapse = "; ")
[08:25:52.500]                           if (!has_future) {
[08:25:52.500]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.500]                               info)
[08:25:52.500]                           }
[08:25:52.500]                           else {
[08:25:52.500]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.500]                               info, version)
[08:25:52.500]                           }
[08:25:52.500]                           base::stop(msg)
[08:25:52.500]                         }
[08:25:52.500]                       })
[08:25:52.500]                     }
[08:25:52.500]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.500]                     base::options(mc.cores = 1L)
[08:25:52.500]                   }
[08:25:52.500]                   ...future.strategy.old <- future::plan("list")
[08:25:52.500]                   options(future.plan = NULL)
[08:25:52.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.500]                 }
[08:25:52.500]                 ...future.workdir <- getwd()
[08:25:52.500]             }
[08:25:52.500]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.500]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.500]         }
[08:25:52.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.500]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:52.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.500]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.500]             base::names(...future.oldOptions))
[08:25:52.500]     }
[08:25:52.500]     if (FALSE) {
[08:25:52.500]     }
[08:25:52.500]     else {
[08:25:52.500]         if (TRUE) {
[08:25:52.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.500]                 open = "w")
[08:25:52.500]         }
[08:25:52.500]         else {
[08:25:52.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.500]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.500]         }
[08:25:52.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.500]             base::sink(type = "output", split = FALSE)
[08:25:52.500]             base::close(...future.stdout)
[08:25:52.500]         }, add = TRUE)
[08:25:52.500]     }
[08:25:52.500]     ...future.frame <- base::sys.nframe()
[08:25:52.500]     ...future.conditions <- base::list()
[08:25:52.500]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.500]     if (FALSE) {
[08:25:52.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.500]     }
[08:25:52.500]     ...future.result <- base::tryCatch({
[08:25:52.500]         base::withCallingHandlers({
[08:25:52.500]             ...future.value <- base::withVisible(base::local({
[08:25:52.500]                 ...future.makeSendCondition <- base::local({
[08:25:52.500]                   sendCondition <- NULL
[08:25:52.500]                   function(frame = 1L) {
[08:25:52.500]                     if (is.function(sendCondition)) 
[08:25:52.500]                       return(sendCondition)
[08:25:52.500]                     ns <- getNamespace("parallel")
[08:25:52.500]                     if (exists("sendData", mode = "function", 
[08:25:52.500]                       envir = ns)) {
[08:25:52.500]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.500]                         envir = ns)
[08:25:52.500]                       envir <- sys.frame(frame)
[08:25:52.500]                       master <- NULL
[08:25:52.500]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.500]                         !identical(envir, emptyenv())) {
[08:25:52.500]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.500]                           inherits = FALSE)) {
[08:25:52.500]                           master <- get("master", mode = "list", 
[08:25:52.500]                             envir = envir, inherits = FALSE)
[08:25:52.500]                           if (inherits(master, c("SOCKnode", 
[08:25:52.500]                             "SOCK0node"))) {
[08:25:52.500]                             sendCondition <<- function(cond) {
[08:25:52.500]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.500]                                 success = TRUE)
[08:25:52.500]                               parallel_sendData(master, data)
[08:25:52.500]                             }
[08:25:52.500]                             return(sendCondition)
[08:25:52.500]                           }
[08:25:52.500]                         }
[08:25:52.500]                         frame <- frame + 1L
[08:25:52.500]                         envir <- sys.frame(frame)
[08:25:52.500]                       }
[08:25:52.500]                     }
[08:25:52.500]                     sendCondition <<- function(cond) NULL
[08:25:52.500]                   }
[08:25:52.500]                 })
[08:25:52.500]                 withCallingHandlers({
[08:25:52.500]                   {
[08:25:52.500]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.500]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.500]                       ...future.globals.maxSize)) {
[08:25:52.500]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.500]                       on.exit(options(oopts), add = TRUE)
[08:25:52.500]                     }
[08:25:52.500]                     {
[08:25:52.500]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.500]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.500]                         USE.NAMES = FALSE)
[08:25:52.500]                       do.call(mapply, args = args)
[08:25:52.500]                     }
[08:25:52.500]                   }
[08:25:52.500]                 }, immediateCondition = function(cond) {
[08:25:52.500]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.500]                   sendCondition(cond)
[08:25:52.500]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.500]                   {
[08:25:52.500]                     inherits <- base::inherits
[08:25:52.500]                     invokeRestart <- base::invokeRestart
[08:25:52.500]                     is.null <- base::is.null
[08:25:52.500]                     muffled <- FALSE
[08:25:52.500]                     if (inherits(cond, "message")) {
[08:25:52.500]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.500]                       if (muffled) 
[08:25:52.500]                         invokeRestart("muffleMessage")
[08:25:52.500]                     }
[08:25:52.500]                     else if (inherits(cond, "warning")) {
[08:25:52.500]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.500]                       if (muffled) 
[08:25:52.500]                         invokeRestart("muffleWarning")
[08:25:52.500]                     }
[08:25:52.500]                     else if (inherits(cond, "condition")) {
[08:25:52.500]                       if (!is.null(pattern)) {
[08:25:52.500]                         computeRestarts <- base::computeRestarts
[08:25:52.500]                         grepl <- base::grepl
[08:25:52.500]                         restarts <- computeRestarts(cond)
[08:25:52.500]                         for (restart in restarts) {
[08:25:52.500]                           name <- restart$name
[08:25:52.500]                           if (is.null(name)) 
[08:25:52.500]                             next
[08:25:52.500]                           if (!grepl(pattern, name)) 
[08:25:52.500]                             next
[08:25:52.500]                           invokeRestart(restart)
[08:25:52.500]                           muffled <- TRUE
[08:25:52.500]                           break
[08:25:52.500]                         }
[08:25:52.500]                       }
[08:25:52.500]                     }
[08:25:52.500]                     invisible(muffled)
[08:25:52.500]                   }
[08:25:52.500]                   muffleCondition(cond)
[08:25:52.500]                 })
[08:25:52.500]             }))
[08:25:52.500]             future::FutureResult(value = ...future.value$value, 
[08:25:52.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.500]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.500]                     ...future.globalenv.names))
[08:25:52.500]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.500]         }, condition = base::local({
[08:25:52.500]             c <- base::c
[08:25:52.500]             inherits <- base::inherits
[08:25:52.500]             invokeRestart <- base::invokeRestart
[08:25:52.500]             length <- base::length
[08:25:52.500]             list <- base::list
[08:25:52.500]             seq.int <- base::seq.int
[08:25:52.500]             signalCondition <- base::signalCondition
[08:25:52.500]             sys.calls <- base::sys.calls
[08:25:52.500]             `[[` <- base::`[[`
[08:25:52.500]             `+` <- base::`+`
[08:25:52.500]             `<<-` <- base::`<<-`
[08:25:52.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.500]                   3L)]
[08:25:52.500]             }
[08:25:52.500]             function(cond) {
[08:25:52.500]                 is_error <- inherits(cond, "error")
[08:25:52.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.500]                   NULL)
[08:25:52.500]                 if (is_error) {
[08:25:52.500]                   sessionInformation <- function() {
[08:25:52.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.500]                       search = base::search(), system = base::Sys.info())
[08:25:52.500]                   }
[08:25:52.500]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.500]                     cond$call), session = sessionInformation(), 
[08:25:52.500]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.500]                   signalCondition(cond)
[08:25:52.500]                 }
[08:25:52.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.500]                 "immediateCondition"))) {
[08:25:52.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.500]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.500]                   if (TRUE && !signal) {
[08:25:52.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.500]                     {
[08:25:52.500]                       inherits <- base::inherits
[08:25:52.500]                       invokeRestart <- base::invokeRestart
[08:25:52.500]                       is.null <- base::is.null
[08:25:52.500]                       muffled <- FALSE
[08:25:52.500]                       if (inherits(cond, "message")) {
[08:25:52.500]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.500]                         if (muffled) 
[08:25:52.500]                           invokeRestart("muffleMessage")
[08:25:52.500]                       }
[08:25:52.500]                       else if (inherits(cond, "warning")) {
[08:25:52.500]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.500]                         if (muffled) 
[08:25:52.500]                           invokeRestart("muffleWarning")
[08:25:52.500]                       }
[08:25:52.500]                       else if (inherits(cond, "condition")) {
[08:25:52.500]                         if (!is.null(pattern)) {
[08:25:52.500]                           computeRestarts <- base::computeRestarts
[08:25:52.500]                           grepl <- base::grepl
[08:25:52.500]                           restarts <- computeRestarts(cond)
[08:25:52.500]                           for (restart in restarts) {
[08:25:52.500]                             name <- restart$name
[08:25:52.500]                             if (is.null(name)) 
[08:25:52.500]                               next
[08:25:52.500]                             if (!grepl(pattern, name)) 
[08:25:52.500]                               next
[08:25:52.500]                             invokeRestart(restart)
[08:25:52.500]                             muffled <- TRUE
[08:25:52.500]                             break
[08:25:52.500]                           }
[08:25:52.500]                         }
[08:25:52.500]                       }
[08:25:52.500]                       invisible(muffled)
[08:25:52.500]                     }
[08:25:52.500]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.500]                   }
[08:25:52.500]                 }
[08:25:52.500]                 else {
[08:25:52.500]                   if (TRUE) {
[08:25:52.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.500]                     {
[08:25:52.500]                       inherits <- base::inherits
[08:25:52.500]                       invokeRestart <- base::invokeRestart
[08:25:52.500]                       is.null <- base::is.null
[08:25:52.500]                       muffled <- FALSE
[08:25:52.500]                       if (inherits(cond, "message")) {
[08:25:52.500]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.500]                         if (muffled) 
[08:25:52.500]                           invokeRestart("muffleMessage")
[08:25:52.500]                       }
[08:25:52.500]                       else if (inherits(cond, "warning")) {
[08:25:52.500]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.500]                         if (muffled) 
[08:25:52.500]                           invokeRestart("muffleWarning")
[08:25:52.500]                       }
[08:25:52.500]                       else if (inherits(cond, "condition")) {
[08:25:52.500]                         if (!is.null(pattern)) {
[08:25:52.500]                           computeRestarts <- base::computeRestarts
[08:25:52.500]                           grepl <- base::grepl
[08:25:52.500]                           restarts <- computeRestarts(cond)
[08:25:52.500]                           for (restart in restarts) {
[08:25:52.500]                             name <- restart$name
[08:25:52.500]                             if (is.null(name)) 
[08:25:52.500]                               next
[08:25:52.500]                             if (!grepl(pattern, name)) 
[08:25:52.500]                               next
[08:25:52.500]                             invokeRestart(restart)
[08:25:52.500]                             muffled <- TRUE
[08:25:52.500]                             break
[08:25:52.500]                           }
[08:25:52.500]                         }
[08:25:52.500]                       }
[08:25:52.500]                       invisible(muffled)
[08:25:52.500]                     }
[08:25:52.500]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.500]                   }
[08:25:52.500]                 }
[08:25:52.500]             }
[08:25:52.500]         }))
[08:25:52.500]     }, error = function(ex) {
[08:25:52.500]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.500]                 ...future.rng), started = ...future.startTime, 
[08:25:52.500]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.500]             version = "1.8"), class = "FutureResult")
[08:25:52.500]     }, finally = {
[08:25:52.500]         if (!identical(...future.workdir, getwd())) 
[08:25:52.500]             setwd(...future.workdir)
[08:25:52.500]         {
[08:25:52.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.500]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.500]             }
[08:25:52.500]             base::options(...future.oldOptions)
[08:25:52.500]             if (.Platform$OS.type == "windows") {
[08:25:52.500]                 old_names <- names(...future.oldEnvVars)
[08:25:52.500]                 envs <- base::Sys.getenv()
[08:25:52.500]                 names <- names(envs)
[08:25:52.500]                 common <- intersect(names, old_names)
[08:25:52.500]                 added <- setdiff(names, old_names)
[08:25:52.500]                 removed <- setdiff(old_names, names)
[08:25:52.500]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.500]                   envs[common]]
[08:25:52.500]                 NAMES <- toupper(changed)
[08:25:52.500]                 args <- list()
[08:25:52.500]                 for (kk in seq_along(NAMES)) {
[08:25:52.500]                   name <- changed[[kk]]
[08:25:52.500]                   NAME <- NAMES[[kk]]
[08:25:52.500]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.500]                     next
[08:25:52.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.500]                 }
[08:25:52.500]                 NAMES <- toupper(added)
[08:25:52.500]                 for (kk in seq_along(NAMES)) {
[08:25:52.500]                   name <- added[[kk]]
[08:25:52.500]                   NAME <- NAMES[[kk]]
[08:25:52.500]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.500]                     next
[08:25:52.500]                   args[[name]] <- ""
[08:25:52.500]                 }
[08:25:52.500]                 NAMES <- toupper(removed)
[08:25:52.500]                 for (kk in seq_along(NAMES)) {
[08:25:52.500]                   name <- removed[[kk]]
[08:25:52.500]                   NAME <- NAMES[[kk]]
[08:25:52.500]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.500]                     next
[08:25:52.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.500]                 }
[08:25:52.500]                 if (length(args) > 0) 
[08:25:52.500]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.500]             }
[08:25:52.500]             else {
[08:25:52.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.500]             }
[08:25:52.500]             {
[08:25:52.500]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.500]                   0L) {
[08:25:52.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.500]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.500]                   base::options(opts)
[08:25:52.500]                 }
[08:25:52.500]                 {
[08:25:52.500]                   {
[08:25:52.500]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.500]                     NULL
[08:25:52.500]                   }
[08:25:52.500]                   options(future.plan = NULL)
[08:25:52.500]                   if (is.na(NA_character_)) 
[08:25:52.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.500]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.500]                     .init = FALSE)
[08:25:52.500]                 }
[08:25:52.500]             }
[08:25:52.500]         }
[08:25:52.500]     })
[08:25:52.500]     if (TRUE) {
[08:25:52.500]         base::sink(type = "output", split = FALSE)
[08:25:52.500]         if (TRUE) {
[08:25:52.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.500]         }
[08:25:52.500]         else {
[08:25:52.500]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.500]         }
[08:25:52.500]         base::close(...future.stdout)
[08:25:52.500]         ...future.stdout <- NULL
[08:25:52.500]     }
[08:25:52.500]     ...future.result$conditions <- ...future.conditions
[08:25:52.500]     ...future.result$finished <- base::Sys.time()
[08:25:52.500]     ...future.result
[08:25:52.500] }
[08:25:52.503] Exporting 5 global objects (1.33 KiB) to cluster node #2 ...
[08:25:52.503] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[08:25:52.504] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[08:25:52.504] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[08:25:52.504] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[08:25:52.504] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[08:25:52.505] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[08:25:52.505] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:52.505] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.505] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:52.506] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.506] Exporting 5 global objects (1.33 KiB) to cluster node #2 ... DONE
[08:25:52.506] MultisessionFuture started
[08:25:52.506] - Launch lazy future ... done
[08:25:52.507] run() for ‘MultisessionFuture’ ... done
[08:25:52.507] Created future:
[08:25:52.507] MultisessionFuture:
[08:25:52.507] Label: ‘future_.mapply-2’
[08:25:52.507] Expression:
[08:25:52.507] {
[08:25:52.507]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.507]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.507]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.507]         on.exit(options(oopts), add = TRUE)
[08:25:52.507]     }
[08:25:52.507]     {
[08:25:52.507]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.507]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.507]         do.call(mapply, args = args)
[08:25:52.507]     }
[08:25:52.507] }
[08:25:52.507] Lazy evaluation: FALSE
[08:25:52.507] Asynchronous evaluation: TRUE
[08:25:52.507] Local evaluation: TRUE
[08:25:52.507] Environment: R_GlobalEnv
[08:25:52.507] Capture standard output: TRUE
[08:25:52.507] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.507] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.507] Packages: <none>
[08:25:52.507] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.507] Resolved: FALSE
[08:25:52.507] Value: <not collected>
[08:25:52.507] Conditions captured: <none>
[08:25:52.507] Early signaling: FALSE
[08:25:52.507] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.507] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.518] Chunk #2 of 2 ... DONE
[08:25:52.518] Launching 2 futures (chunks) ... DONE
[08:25:52.519] Resolving 2 futures (chunks) ...
[08:25:52.519] resolve() on list ...
[08:25:52.519]  recursive: 0
[08:25:52.519]  length: 2
[08:25:52.519] 
[08:25:52.520] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.520] - Validating connection of MultisessionFuture
[08:25:52.520] - received message: FutureResult
[08:25:52.520] - Received FutureResult
[08:25:52.520] - Erased future from FutureRegistry
[08:25:52.520] result() for ClusterFuture ...
[08:25:52.520] - result already collected: FutureResult
[08:25:52.520] result() for ClusterFuture ... done
[08:25:52.521] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.521] Future #1
[08:25:52.521] result() for ClusterFuture ...
[08:25:52.521] - result already collected: FutureResult
[08:25:52.521] result() for ClusterFuture ... done
[08:25:52.521] result() for ClusterFuture ...
[08:25:52.521] - result already collected: FutureResult
[08:25:52.521] result() for ClusterFuture ... done
[08:25:52.521] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:52.521] - nx: 2
[08:25:52.521] - relay: TRUE
[08:25:52.521] - stdout: TRUE
[08:25:52.522] - signal: TRUE
[08:25:52.522] - resignal: FALSE
[08:25:52.522] - force: TRUE
[08:25:52.522] - relayed: [n=2] FALSE, FALSE
[08:25:52.522] - queued futures: [n=2] FALSE, FALSE
[08:25:52.522]  - until=1
[08:25:52.522]  - relaying element #1
[08:25:52.522] result() for ClusterFuture ...
[08:25:52.522] - result already collected: FutureResult
[08:25:52.522] result() for ClusterFuture ... done
[08:25:52.522] result() for ClusterFuture ...
[08:25:52.522] - result already collected: FutureResult
[08:25:52.523] result() for ClusterFuture ... done
[08:25:52.523] result() for ClusterFuture ...
[08:25:52.523] - result already collected: FutureResult
[08:25:52.523] result() for ClusterFuture ... done
[08:25:52.523] result() for ClusterFuture ...
[08:25:52.523] - result already collected: FutureResult
[08:25:52.523] result() for ClusterFuture ... done
[08:25:52.523] - relayed: [n=2] TRUE, FALSE
[08:25:52.523] - queued futures: [n=2] TRUE, FALSE
[08:25:52.523] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:52.523]  length: 1 (resolved future 1)
[08:25:52.548] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.549] - Validating connection of MultisessionFuture
[08:25:52.549] - received message: FutureResult
[08:25:52.549] - Received FutureResult
[08:25:52.549] - Erased future from FutureRegistry
[08:25:52.549] result() for ClusterFuture ...
[08:25:52.549] - result already collected: FutureResult
[08:25:52.549] result() for ClusterFuture ... done
[08:25:52.549] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.549] Future #2
[08:25:52.550] result() for ClusterFuture ...
[08:25:52.550] - result already collected: FutureResult
[08:25:52.550] result() for ClusterFuture ... done
[08:25:52.550] result() for ClusterFuture ...
[08:25:52.550] - result already collected: FutureResult
[08:25:52.550] result() for ClusterFuture ... done
[08:25:52.550] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:52.550] - nx: 2
[08:25:52.550] - relay: TRUE
[08:25:52.550] - stdout: TRUE
[08:25:52.550] - signal: TRUE
[08:25:52.550] - resignal: FALSE
[08:25:52.551] - force: TRUE
[08:25:52.551] - relayed: [n=2] TRUE, FALSE
[08:25:52.551] - queued futures: [n=2] TRUE, FALSE
[08:25:52.551]  - until=2
[08:25:52.551]  - relaying element #2
[08:25:52.551] result() for ClusterFuture ...
[08:25:52.551] - result already collected: FutureResult
[08:25:52.551] result() for ClusterFuture ... done
[08:25:52.551] result() for ClusterFuture ...
[08:25:52.551] - result already collected: FutureResult
[08:25:52.551] result() for ClusterFuture ... done
[08:25:52.551] result() for ClusterFuture ...
[08:25:52.552] - result already collected: FutureResult
[08:25:52.552] result() for ClusterFuture ... done
[08:25:52.552] result() for ClusterFuture ...
[08:25:52.552] - result already collected: FutureResult
[08:25:52.552] result() for ClusterFuture ... done
[08:25:52.552] - relayed: [n=2] TRUE, TRUE
[08:25:52.552] - queued futures: [n=2] TRUE, TRUE
[08:25:52.552] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:52.552]  length: 0 (resolved future 2)
[08:25:52.552] Relaying remaining futures
[08:25:52.552] signalConditionsASAP(NULL, pos=0) ...
[08:25:52.552] - nx: 2
[08:25:52.553] - relay: TRUE
[08:25:52.553] - stdout: TRUE
[08:25:52.553] - signal: TRUE
[08:25:52.553] - resignal: FALSE
[08:25:52.553] - force: TRUE
[08:25:52.553] - relayed: [n=2] TRUE, TRUE
[08:25:52.553] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:52.553] - relayed: [n=2] TRUE, TRUE
[08:25:52.553] - queued futures: [n=2] TRUE, TRUE
[08:25:52.553] signalConditionsASAP(NULL, pos=0) ... done
[08:25:52.553] resolve() on list ... DONE
[08:25:52.553] result() for ClusterFuture ...
[08:25:52.554] - result already collected: FutureResult
[08:25:52.554] result() for ClusterFuture ... done
[08:25:52.554] result() for ClusterFuture ...
[08:25:52.554] - result already collected: FutureResult
[08:25:52.554] result() for ClusterFuture ... done
[08:25:52.554] result() for ClusterFuture ...
[08:25:52.554] - result already collected: FutureResult
[08:25:52.554] result() for ClusterFuture ... done
[08:25:52.554] result() for ClusterFuture ...
[08:25:52.554] - result already collected: FutureResult
[08:25:52.554] result() for ClusterFuture ... done
[08:25:52.554]  - Number of value chunks collected: 2
[08:25:52.555] Resolving 2 futures (chunks) ... DONE
[08:25:52.555] Reducing values from 2 chunks ...
[08:25:52.555]  - Number of values collected after concatenation: 5
[08:25:52.555]  - Number of values expected: 5
[08:25:52.555] Reducing values from 2 chunks ... DONE
[08:25:52.555] future_mapply() ... DONE
[08:25:52.555] future_mapply() ...
[08:25:52.557] Number of chunks: 3
[08:25:52.557] Index remapping (attribute 'ordering'): [n = 5] 5, 3, 4, 2, 1
[08:25:52.557] getGlobalsAndPackagesXApply() ...
[08:25:52.557]  - future.globals: TRUE
[08:25:52.557] getGlobalsAndPackages() ...
[08:25:52.557] Searching for globals...
[08:25:52.559] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:52.559] Searching for globals ... DONE
[08:25:52.559] Resolving globals: FALSE
[08:25:52.559] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:52.560] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:52.560] - globals: [1] ‘FUN’
[08:25:52.560] 
[08:25:52.560] getGlobalsAndPackages() ... DONE
[08:25:52.560]  - globals found/used: [n=1] ‘FUN’
[08:25:52.560]  - needed namespaces: [n=0] 
[08:25:52.560] Finding globals ... DONE
[08:25:52.560] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:52.560] List of 2
[08:25:52.560]  $ ...future.FUN:function (C, k)  
[08:25:52.560]  $ MoreArgs     : NULL
[08:25:52.560]  - attr(*, "where")=List of 2
[08:25:52.560]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:52.560]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:52.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:52.560]  - attr(*, "resolved")= logi FALSE
[08:25:52.560]  - attr(*, "total_size")= num NA
[08:25:52.563] Packages to be attached in all futures: [n=0] 
[08:25:52.563] getGlobalsAndPackagesXApply() ... DONE
[08:25:52.563] Number of futures (= number of chunks): 3
[08:25:52.563] Launching 3 futures (chunks) ...
[08:25:52.563] Chunk #1 of 3 ...
[08:25:52.563]  - Finding globals in '...' for chunk #1 ...
[08:25:52.564] getGlobalsAndPackages() ...
[08:25:52.564] Searching for globals...
[08:25:52.564] 
[08:25:52.564] Searching for globals ... DONE
[08:25:52.564] - globals: [0] <none>
[08:25:52.564] getGlobalsAndPackages() ... DONE
[08:25:52.564]    + additional globals found: [n=0] 
[08:25:52.564]    + additional namespaces needed: [n=0] 
[08:25:52.564]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:52.565]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[08:25:52.565]  - seeds: <none>
[08:25:52.565]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.565] getGlobalsAndPackages() ...
[08:25:52.565] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.565] Resolving globals: FALSE
[08:25:52.565] The total size of the 5 globals is 876 bytes (876 bytes)
[08:25:52.566] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:52.566] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.566] 
[08:25:52.566] getGlobalsAndPackages() ... DONE
[08:25:52.566] run() for ‘Future’ ...
[08:25:52.567] - state: ‘created’
[08:25:52.567] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.580] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.580]   - Field: ‘node’
[08:25:52.580]   - Field: ‘label’
[08:25:52.581]   - Field: ‘local’
[08:25:52.581]   - Field: ‘owner’
[08:25:52.581]   - Field: ‘envir’
[08:25:52.581]   - Field: ‘workers’
[08:25:52.581]   - Field: ‘packages’
[08:25:52.581]   - Field: ‘gc’
[08:25:52.581]   - Field: ‘conditions’
[08:25:52.581]   - Field: ‘persistent’
[08:25:52.581]   - Field: ‘expr’
[08:25:52.581]   - Field: ‘uuid’
[08:25:52.581]   - Field: ‘seed’
[08:25:52.581]   - Field: ‘version’
[08:25:52.582]   - Field: ‘result’
[08:25:52.582]   - Field: ‘asynchronous’
[08:25:52.582]   - Field: ‘calls’
[08:25:52.582]   - Field: ‘globals’
[08:25:52.582]   - Field: ‘stdout’
[08:25:52.582]   - Field: ‘earlySignal’
[08:25:52.582]   - Field: ‘lazy’
[08:25:52.582]   - Field: ‘state’
[08:25:52.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.582] - Launch lazy future ...
[08:25:52.583] Packages needed by the future expression (n = 0): <none>
[08:25:52.583] Packages needed by future strategies (n = 0): <none>
[08:25:52.583] {
[08:25:52.583]     {
[08:25:52.583]         {
[08:25:52.583]             ...future.startTime <- base::Sys.time()
[08:25:52.583]             {
[08:25:52.583]                 {
[08:25:52.583]                   {
[08:25:52.583]                     {
[08:25:52.583]                       base::local({
[08:25:52.583]                         has_future <- base::requireNamespace("future", 
[08:25:52.583]                           quietly = TRUE)
[08:25:52.583]                         if (has_future) {
[08:25:52.583]                           ns <- base::getNamespace("future")
[08:25:52.583]                           version <- ns[[".package"]][["version"]]
[08:25:52.583]                           if (is.null(version)) 
[08:25:52.583]                             version <- utils::packageVersion("future")
[08:25:52.583]                         }
[08:25:52.583]                         else {
[08:25:52.583]                           version <- NULL
[08:25:52.583]                         }
[08:25:52.583]                         if (!has_future || version < "1.8.0") {
[08:25:52.583]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.583]                             "", base::R.version$version.string), 
[08:25:52.583]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.583]                               "release", "version")], collapse = " "), 
[08:25:52.583]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.583]                             info)
[08:25:52.583]                           info <- base::paste(info, collapse = "; ")
[08:25:52.583]                           if (!has_future) {
[08:25:52.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.583]                               info)
[08:25:52.583]                           }
[08:25:52.583]                           else {
[08:25:52.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.583]                               info, version)
[08:25:52.583]                           }
[08:25:52.583]                           base::stop(msg)
[08:25:52.583]                         }
[08:25:52.583]                       })
[08:25:52.583]                     }
[08:25:52.583]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.583]                     base::options(mc.cores = 1L)
[08:25:52.583]                   }
[08:25:52.583]                   ...future.strategy.old <- future::plan("list")
[08:25:52.583]                   options(future.plan = NULL)
[08:25:52.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.583]                 }
[08:25:52.583]                 ...future.workdir <- getwd()
[08:25:52.583]             }
[08:25:52.583]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.583]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.583]         }
[08:25:52.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.583]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[08:25:52.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.583]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.583]             base::names(...future.oldOptions))
[08:25:52.583]     }
[08:25:52.583]     if (FALSE) {
[08:25:52.583]     }
[08:25:52.583]     else {
[08:25:52.583]         if (TRUE) {
[08:25:52.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.583]                 open = "w")
[08:25:52.583]         }
[08:25:52.583]         else {
[08:25:52.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.583]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.583]         }
[08:25:52.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.583]             base::sink(type = "output", split = FALSE)
[08:25:52.583]             base::close(...future.stdout)
[08:25:52.583]         }, add = TRUE)
[08:25:52.583]     }
[08:25:52.583]     ...future.frame <- base::sys.nframe()
[08:25:52.583]     ...future.conditions <- base::list()
[08:25:52.583]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.583]     if (FALSE) {
[08:25:52.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.583]     }
[08:25:52.583]     ...future.result <- base::tryCatch({
[08:25:52.583]         base::withCallingHandlers({
[08:25:52.583]             ...future.value <- base::withVisible(base::local({
[08:25:52.583]                 ...future.makeSendCondition <- base::local({
[08:25:52.583]                   sendCondition <- NULL
[08:25:52.583]                   function(frame = 1L) {
[08:25:52.583]                     if (is.function(sendCondition)) 
[08:25:52.583]                       return(sendCondition)
[08:25:52.583]                     ns <- getNamespace("parallel")
[08:25:52.583]                     if (exists("sendData", mode = "function", 
[08:25:52.583]                       envir = ns)) {
[08:25:52.583]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.583]                         envir = ns)
[08:25:52.583]                       envir <- sys.frame(frame)
[08:25:52.583]                       master <- NULL
[08:25:52.583]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.583]                         !identical(envir, emptyenv())) {
[08:25:52.583]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.583]                           inherits = FALSE)) {
[08:25:52.583]                           master <- get("master", mode = "list", 
[08:25:52.583]                             envir = envir, inherits = FALSE)
[08:25:52.583]                           if (inherits(master, c("SOCKnode", 
[08:25:52.583]                             "SOCK0node"))) {
[08:25:52.583]                             sendCondition <<- function(cond) {
[08:25:52.583]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.583]                                 success = TRUE)
[08:25:52.583]                               parallel_sendData(master, data)
[08:25:52.583]                             }
[08:25:52.583]                             return(sendCondition)
[08:25:52.583]                           }
[08:25:52.583]                         }
[08:25:52.583]                         frame <- frame + 1L
[08:25:52.583]                         envir <- sys.frame(frame)
[08:25:52.583]                       }
[08:25:52.583]                     }
[08:25:52.583]                     sendCondition <<- function(cond) NULL
[08:25:52.583]                   }
[08:25:52.583]                 })
[08:25:52.583]                 withCallingHandlers({
[08:25:52.583]                   {
[08:25:52.583]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.583]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.583]                       ...future.globals.maxSize)) {
[08:25:52.583]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.583]                       on.exit(options(oopts), add = TRUE)
[08:25:52.583]                     }
[08:25:52.583]                     {
[08:25:52.583]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.583]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.583]                         USE.NAMES = FALSE)
[08:25:52.583]                       do.call(mapply, args = args)
[08:25:52.583]                     }
[08:25:52.583]                   }
[08:25:52.583]                 }, immediateCondition = function(cond) {
[08:25:52.583]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.583]                   sendCondition(cond)
[08:25:52.583]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.583]                   {
[08:25:52.583]                     inherits <- base::inherits
[08:25:52.583]                     invokeRestart <- base::invokeRestart
[08:25:52.583]                     is.null <- base::is.null
[08:25:52.583]                     muffled <- FALSE
[08:25:52.583]                     if (inherits(cond, "message")) {
[08:25:52.583]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.583]                       if (muffled) 
[08:25:52.583]                         invokeRestart("muffleMessage")
[08:25:52.583]                     }
[08:25:52.583]                     else if (inherits(cond, "warning")) {
[08:25:52.583]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.583]                       if (muffled) 
[08:25:52.583]                         invokeRestart("muffleWarning")
[08:25:52.583]                     }
[08:25:52.583]                     else if (inherits(cond, "condition")) {
[08:25:52.583]                       if (!is.null(pattern)) {
[08:25:52.583]                         computeRestarts <- base::computeRestarts
[08:25:52.583]                         grepl <- base::grepl
[08:25:52.583]                         restarts <- computeRestarts(cond)
[08:25:52.583]                         for (restart in restarts) {
[08:25:52.583]                           name <- restart$name
[08:25:52.583]                           if (is.null(name)) 
[08:25:52.583]                             next
[08:25:52.583]                           if (!grepl(pattern, name)) 
[08:25:52.583]                             next
[08:25:52.583]                           invokeRestart(restart)
[08:25:52.583]                           muffled <- TRUE
[08:25:52.583]                           break
[08:25:52.583]                         }
[08:25:52.583]                       }
[08:25:52.583]                     }
[08:25:52.583]                     invisible(muffled)
[08:25:52.583]                   }
[08:25:52.583]                   muffleCondition(cond)
[08:25:52.583]                 })
[08:25:52.583]             }))
[08:25:52.583]             future::FutureResult(value = ...future.value$value, 
[08:25:52.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.583]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.583]                     ...future.globalenv.names))
[08:25:52.583]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.583]         }, condition = base::local({
[08:25:52.583]             c <- base::c
[08:25:52.583]             inherits <- base::inherits
[08:25:52.583]             invokeRestart <- base::invokeRestart
[08:25:52.583]             length <- base::length
[08:25:52.583]             list <- base::list
[08:25:52.583]             seq.int <- base::seq.int
[08:25:52.583]             signalCondition <- base::signalCondition
[08:25:52.583]             sys.calls <- base::sys.calls
[08:25:52.583]             `[[` <- base::`[[`
[08:25:52.583]             `+` <- base::`+`
[08:25:52.583]             `<<-` <- base::`<<-`
[08:25:52.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.583]                   3L)]
[08:25:52.583]             }
[08:25:52.583]             function(cond) {
[08:25:52.583]                 is_error <- inherits(cond, "error")
[08:25:52.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.583]                   NULL)
[08:25:52.583]                 if (is_error) {
[08:25:52.583]                   sessionInformation <- function() {
[08:25:52.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.583]                       search = base::search(), system = base::Sys.info())
[08:25:52.583]                   }
[08:25:52.583]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.583]                     cond$call), session = sessionInformation(), 
[08:25:52.583]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.583]                   signalCondition(cond)
[08:25:52.583]                 }
[08:25:52.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.583]                 "immediateCondition"))) {
[08:25:52.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.583]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.583]                   if (TRUE && !signal) {
[08:25:52.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.583]                     {
[08:25:52.583]                       inherits <- base::inherits
[08:25:52.583]                       invokeRestart <- base::invokeRestart
[08:25:52.583]                       is.null <- base::is.null
[08:25:52.583]                       muffled <- FALSE
[08:25:52.583]                       if (inherits(cond, "message")) {
[08:25:52.583]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.583]                         if (muffled) 
[08:25:52.583]                           invokeRestart("muffleMessage")
[08:25:52.583]                       }
[08:25:52.583]                       else if (inherits(cond, "warning")) {
[08:25:52.583]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.583]                         if (muffled) 
[08:25:52.583]                           invokeRestart("muffleWarning")
[08:25:52.583]                       }
[08:25:52.583]                       else if (inherits(cond, "condition")) {
[08:25:52.583]                         if (!is.null(pattern)) {
[08:25:52.583]                           computeRestarts <- base::computeRestarts
[08:25:52.583]                           grepl <- base::grepl
[08:25:52.583]                           restarts <- computeRestarts(cond)
[08:25:52.583]                           for (restart in restarts) {
[08:25:52.583]                             name <- restart$name
[08:25:52.583]                             if (is.null(name)) 
[08:25:52.583]                               next
[08:25:52.583]                             if (!grepl(pattern, name)) 
[08:25:52.583]                               next
[08:25:52.583]                             invokeRestart(restart)
[08:25:52.583]                             muffled <- TRUE
[08:25:52.583]                             break
[08:25:52.583]                           }
[08:25:52.583]                         }
[08:25:52.583]                       }
[08:25:52.583]                       invisible(muffled)
[08:25:52.583]                     }
[08:25:52.583]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.583]                   }
[08:25:52.583]                 }
[08:25:52.583]                 else {
[08:25:52.583]                   if (TRUE) {
[08:25:52.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.583]                     {
[08:25:52.583]                       inherits <- base::inherits
[08:25:52.583]                       invokeRestart <- base::invokeRestart
[08:25:52.583]                       is.null <- base::is.null
[08:25:52.583]                       muffled <- FALSE
[08:25:52.583]                       if (inherits(cond, "message")) {
[08:25:52.583]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.583]                         if (muffled) 
[08:25:52.583]                           invokeRestart("muffleMessage")
[08:25:52.583]                       }
[08:25:52.583]                       else if (inherits(cond, "warning")) {
[08:25:52.583]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.583]                         if (muffled) 
[08:25:52.583]                           invokeRestart("muffleWarning")
[08:25:52.583]                       }
[08:25:52.583]                       else if (inherits(cond, "condition")) {
[08:25:52.583]                         if (!is.null(pattern)) {
[08:25:52.583]                           computeRestarts <- base::computeRestarts
[08:25:52.583]                           grepl <- base::grepl
[08:25:52.583]                           restarts <- computeRestarts(cond)
[08:25:52.583]                           for (restart in restarts) {
[08:25:52.583]                             name <- restart$name
[08:25:52.583]                             if (is.null(name)) 
[08:25:52.583]                               next
[08:25:52.583]                             if (!grepl(pattern, name)) 
[08:25:52.583]                               next
[08:25:52.583]                             invokeRestart(restart)
[08:25:52.583]                             muffled <- TRUE
[08:25:52.583]                             break
[08:25:52.583]                           }
[08:25:52.583]                         }
[08:25:52.583]                       }
[08:25:52.583]                       invisible(muffled)
[08:25:52.583]                     }
[08:25:52.583]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.583]                   }
[08:25:52.583]                 }
[08:25:52.583]             }
[08:25:52.583]         }))
[08:25:52.583]     }, error = function(ex) {
[08:25:52.583]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.583]                 ...future.rng), started = ...future.startTime, 
[08:25:52.583]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.583]             version = "1.8"), class = "FutureResult")
[08:25:52.583]     }, finally = {
[08:25:52.583]         if (!identical(...future.workdir, getwd())) 
[08:25:52.583]             setwd(...future.workdir)
[08:25:52.583]         {
[08:25:52.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.583]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.583]             }
[08:25:52.583]             base::options(...future.oldOptions)
[08:25:52.583]             if (.Platform$OS.type == "windows") {
[08:25:52.583]                 old_names <- names(...future.oldEnvVars)
[08:25:52.583]                 envs <- base::Sys.getenv()
[08:25:52.583]                 names <- names(envs)
[08:25:52.583]                 common <- intersect(names, old_names)
[08:25:52.583]                 added <- setdiff(names, old_names)
[08:25:52.583]                 removed <- setdiff(old_names, names)
[08:25:52.583]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.583]                   envs[common]]
[08:25:52.583]                 NAMES <- toupper(changed)
[08:25:52.583]                 args <- list()
[08:25:52.583]                 for (kk in seq_along(NAMES)) {
[08:25:52.583]                   name <- changed[[kk]]
[08:25:52.583]                   NAME <- NAMES[[kk]]
[08:25:52.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.583]                     next
[08:25:52.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.583]                 }
[08:25:52.583]                 NAMES <- toupper(added)
[08:25:52.583]                 for (kk in seq_along(NAMES)) {
[08:25:52.583]                   name <- added[[kk]]
[08:25:52.583]                   NAME <- NAMES[[kk]]
[08:25:52.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.583]                     next
[08:25:52.583]                   args[[name]] <- ""
[08:25:52.583]                 }
[08:25:52.583]                 NAMES <- toupper(removed)
[08:25:52.583]                 for (kk in seq_along(NAMES)) {
[08:25:52.583]                   name <- removed[[kk]]
[08:25:52.583]                   NAME <- NAMES[[kk]]
[08:25:52.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.583]                     next
[08:25:52.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.583]                 }
[08:25:52.583]                 if (length(args) > 0) 
[08:25:52.583]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.583]             }
[08:25:52.583]             else {
[08:25:52.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.583]             }
[08:25:52.583]             {
[08:25:52.583]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.583]                   0L) {
[08:25:52.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.583]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.583]                   base::options(opts)
[08:25:52.583]                 }
[08:25:52.583]                 {
[08:25:52.583]                   {
[08:25:52.583]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.583]                     NULL
[08:25:52.583]                   }
[08:25:52.583]                   options(future.plan = NULL)
[08:25:52.583]                   if (is.na(NA_character_)) 
[08:25:52.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.583]                     .init = FALSE)
[08:25:52.583]                 }
[08:25:52.583]             }
[08:25:52.583]         }
[08:25:52.583]     })
[08:25:52.583]     if (TRUE) {
[08:25:52.583]         base::sink(type = "output", split = FALSE)
[08:25:52.583]         if (TRUE) {
[08:25:52.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.583]         }
[08:25:52.583]         else {
[08:25:52.583]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.583]         }
[08:25:52.583]         base::close(...future.stdout)
[08:25:52.583]         ...future.stdout <- NULL
[08:25:52.583]     }
[08:25:52.583]     ...future.result$conditions <- ...future.conditions
[08:25:52.583]     ...future.result$finished <- base::Sys.time()
[08:25:52.583]     ...future.result
[08:25:52.583] }
[08:25:52.586] Exporting 5 global objects (1.29 KiB) to cluster node #1 ...
[08:25:52.586] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[08:25:52.587] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[08:25:52.587] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:52.587] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.587] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[08:25:52.588] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[08:25:52.588] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:52.588] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.588] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:52.589] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.589] Exporting 5 global objects (1.29 KiB) to cluster node #1 ... DONE
[08:25:52.589] MultisessionFuture started
[08:25:52.589] - Launch lazy future ... done
[08:25:52.589] run() for ‘MultisessionFuture’ ... done
[08:25:52.590] Created future:
[08:25:52.590] MultisessionFuture:
[08:25:52.590] Label: ‘future_mapply-1’
[08:25:52.590] Expression:
[08:25:52.590] {
[08:25:52.590]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.590]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.590]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.590]         on.exit(options(oopts), add = TRUE)
[08:25:52.590]     }
[08:25:52.590]     {
[08:25:52.590]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.590]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.590]         do.call(mapply, args = args)
[08:25:52.590]     }
[08:25:52.590] }
[08:25:52.590] Lazy evaluation: FALSE
[08:25:52.590] Asynchronous evaluation: TRUE
[08:25:52.590] Local evaluation: TRUE
[08:25:52.590] Environment: R_GlobalEnv
[08:25:52.590] Capture standard output: TRUE
[08:25:52.590] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.590] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.590] Packages: <none>
[08:25:52.590] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.590] Resolved: FALSE
[08:25:52.590] Value: <not collected>
[08:25:52.590] Conditions captured: <none>
[08:25:52.590] Early signaling: FALSE
[08:25:52.590] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.590] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.601] Chunk #1 of 3 ... DONE
[08:25:52.601] Chunk #2 of 3 ...
[08:25:52.601]  - Finding globals in '...' for chunk #2 ...
[08:25:52.601] getGlobalsAndPackages() ...
[08:25:52.601] Searching for globals...
[08:25:52.602] 
[08:25:52.602] Searching for globals ... DONE
[08:25:52.602] - globals: [0] <none>
[08:25:52.602] getGlobalsAndPackages() ... DONE
[08:25:52.602]    + additional globals found: [n=0] 
[08:25:52.602]    + additional namespaces needed: [n=0] 
[08:25:52.602]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:52.602]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[08:25:52.603]  - seeds: <none>
[08:25:52.603]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.603] getGlobalsAndPackages() ...
[08:25:52.603] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.603] Resolving globals: FALSE
[08:25:52.603] The total size of the 5 globals is 847 bytes (847 bytes)
[08:25:52.604] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 847 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (76 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:52.604] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.604] 
[08:25:52.604] getGlobalsAndPackages() ... DONE
[08:25:52.604] run() for ‘Future’ ...
[08:25:52.605] - state: ‘created’
[08:25:52.605] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.618] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.618]   - Field: ‘node’
[08:25:52.618]   - Field: ‘label’
[08:25:52.619]   - Field: ‘local’
[08:25:52.619]   - Field: ‘owner’
[08:25:52.619]   - Field: ‘envir’
[08:25:52.619]   - Field: ‘workers’
[08:25:52.619]   - Field: ‘packages’
[08:25:52.619]   - Field: ‘gc’
[08:25:52.619]   - Field: ‘conditions’
[08:25:52.619]   - Field: ‘persistent’
[08:25:52.619]   - Field: ‘expr’
[08:25:52.619]   - Field: ‘uuid’
[08:25:52.619]   - Field: ‘seed’
[08:25:52.620]   - Field: ‘version’
[08:25:52.620]   - Field: ‘result’
[08:25:52.620]   - Field: ‘asynchronous’
[08:25:52.620]   - Field: ‘calls’
[08:25:52.620]   - Field: ‘globals’
[08:25:52.620]   - Field: ‘stdout’
[08:25:52.620]   - Field: ‘earlySignal’
[08:25:52.620]   - Field: ‘lazy’
[08:25:52.620]   - Field: ‘state’
[08:25:52.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.620] - Launch lazy future ...
[08:25:52.621] Packages needed by the future expression (n = 0): <none>
[08:25:52.621] Packages needed by future strategies (n = 0): <none>
[08:25:52.621] {
[08:25:52.621]     {
[08:25:52.621]         {
[08:25:52.621]             ...future.startTime <- base::Sys.time()
[08:25:52.621]             {
[08:25:52.621]                 {
[08:25:52.621]                   {
[08:25:52.621]                     {
[08:25:52.621]                       base::local({
[08:25:52.621]                         has_future <- base::requireNamespace("future", 
[08:25:52.621]                           quietly = TRUE)
[08:25:52.621]                         if (has_future) {
[08:25:52.621]                           ns <- base::getNamespace("future")
[08:25:52.621]                           version <- ns[[".package"]][["version"]]
[08:25:52.621]                           if (is.null(version)) 
[08:25:52.621]                             version <- utils::packageVersion("future")
[08:25:52.621]                         }
[08:25:52.621]                         else {
[08:25:52.621]                           version <- NULL
[08:25:52.621]                         }
[08:25:52.621]                         if (!has_future || version < "1.8.0") {
[08:25:52.621]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.621]                             "", base::R.version$version.string), 
[08:25:52.621]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.621]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.621]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.621]                               "release", "version")], collapse = " "), 
[08:25:52.621]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.621]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.621]                             info)
[08:25:52.621]                           info <- base::paste(info, collapse = "; ")
[08:25:52.621]                           if (!has_future) {
[08:25:52.621]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.621]                               info)
[08:25:52.621]                           }
[08:25:52.621]                           else {
[08:25:52.621]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.621]                               info, version)
[08:25:52.621]                           }
[08:25:52.621]                           base::stop(msg)
[08:25:52.621]                         }
[08:25:52.621]                       })
[08:25:52.621]                     }
[08:25:52.621]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.621]                     base::options(mc.cores = 1L)
[08:25:52.621]                   }
[08:25:52.621]                   ...future.strategy.old <- future::plan("list")
[08:25:52.621]                   options(future.plan = NULL)
[08:25:52.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.621]                 }
[08:25:52.621]                 ...future.workdir <- getwd()
[08:25:52.621]             }
[08:25:52.621]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.621]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.621]         }
[08:25:52.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.621]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[08:25:52.621]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.621]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.621]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.621]             base::names(...future.oldOptions))
[08:25:52.621]     }
[08:25:52.621]     if (FALSE) {
[08:25:52.621]     }
[08:25:52.621]     else {
[08:25:52.621]         if (TRUE) {
[08:25:52.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.621]                 open = "w")
[08:25:52.621]         }
[08:25:52.621]         else {
[08:25:52.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.621]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.621]         }
[08:25:52.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.621]             base::sink(type = "output", split = FALSE)
[08:25:52.621]             base::close(...future.stdout)
[08:25:52.621]         }, add = TRUE)
[08:25:52.621]     }
[08:25:52.621]     ...future.frame <- base::sys.nframe()
[08:25:52.621]     ...future.conditions <- base::list()
[08:25:52.621]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.621]     if (FALSE) {
[08:25:52.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.621]     }
[08:25:52.621]     ...future.result <- base::tryCatch({
[08:25:52.621]         base::withCallingHandlers({
[08:25:52.621]             ...future.value <- base::withVisible(base::local({
[08:25:52.621]                 ...future.makeSendCondition <- base::local({
[08:25:52.621]                   sendCondition <- NULL
[08:25:52.621]                   function(frame = 1L) {
[08:25:52.621]                     if (is.function(sendCondition)) 
[08:25:52.621]                       return(sendCondition)
[08:25:52.621]                     ns <- getNamespace("parallel")
[08:25:52.621]                     if (exists("sendData", mode = "function", 
[08:25:52.621]                       envir = ns)) {
[08:25:52.621]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.621]                         envir = ns)
[08:25:52.621]                       envir <- sys.frame(frame)
[08:25:52.621]                       master <- NULL
[08:25:52.621]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.621]                         !identical(envir, emptyenv())) {
[08:25:52.621]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.621]                           inherits = FALSE)) {
[08:25:52.621]                           master <- get("master", mode = "list", 
[08:25:52.621]                             envir = envir, inherits = FALSE)
[08:25:52.621]                           if (inherits(master, c("SOCKnode", 
[08:25:52.621]                             "SOCK0node"))) {
[08:25:52.621]                             sendCondition <<- function(cond) {
[08:25:52.621]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.621]                                 success = TRUE)
[08:25:52.621]                               parallel_sendData(master, data)
[08:25:52.621]                             }
[08:25:52.621]                             return(sendCondition)
[08:25:52.621]                           }
[08:25:52.621]                         }
[08:25:52.621]                         frame <- frame + 1L
[08:25:52.621]                         envir <- sys.frame(frame)
[08:25:52.621]                       }
[08:25:52.621]                     }
[08:25:52.621]                     sendCondition <<- function(cond) NULL
[08:25:52.621]                   }
[08:25:52.621]                 })
[08:25:52.621]                 withCallingHandlers({
[08:25:52.621]                   {
[08:25:52.621]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.621]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.621]                       ...future.globals.maxSize)) {
[08:25:52.621]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.621]                       on.exit(options(oopts), add = TRUE)
[08:25:52.621]                     }
[08:25:52.621]                     {
[08:25:52.621]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.621]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.621]                         USE.NAMES = FALSE)
[08:25:52.621]                       do.call(mapply, args = args)
[08:25:52.621]                     }
[08:25:52.621]                   }
[08:25:52.621]                 }, immediateCondition = function(cond) {
[08:25:52.621]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.621]                   sendCondition(cond)
[08:25:52.621]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.621]                   {
[08:25:52.621]                     inherits <- base::inherits
[08:25:52.621]                     invokeRestart <- base::invokeRestart
[08:25:52.621]                     is.null <- base::is.null
[08:25:52.621]                     muffled <- FALSE
[08:25:52.621]                     if (inherits(cond, "message")) {
[08:25:52.621]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.621]                       if (muffled) 
[08:25:52.621]                         invokeRestart("muffleMessage")
[08:25:52.621]                     }
[08:25:52.621]                     else if (inherits(cond, "warning")) {
[08:25:52.621]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.621]                       if (muffled) 
[08:25:52.621]                         invokeRestart("muffleWarning")
[08:25:52.621]                     }
[08:25:52.621]                     else if (inherits(cond, "condition")) {
[08:25:52.621]                       if (!is.null(pattern)) {
[08:25:52.621]                         computeRestarts <- base::computeRestarts
[08:25:52.621]                         grepl <- base::grepl
[08:25:52.621]                         restarts <- computeRestarts(cond)
[08:25:52.621]                         for (restart in restarts) {
[08:25:52.621]                           name <- restart$name
[08:25:52.621]                           if (is.null(name)) 
[08:25:52.621]                             next
[08:25:52.621]                           if (!grepl(pattern, name)) 
[08:25:52.621]                             next
[08:25:52.621]                           invokeRestart(restart)
[08:25:52.621]                           muffled <- TRUE
[08:25:52.621]                           break
[08:25:52.621]                         }
[08:25:52.621]                       }
[08:25:52.621]                     }
[08:25:52.621]                     invisible(muffled)
[08:25:52.621]                   }
[08:25:52.621]                   muffleCondition(cond)
[08:25:52.621]                 })
[08:25:52.621]             }))
[08:25:52.621]             future::FutureResult(value = ...future.value$value, 
[08:25:52.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.621]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.621]                     ...future.globalenv.names))
[08:25:52.621]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.621]         }, condition = base::local({
[08:25:52.621]             c <- base::c
[08:25:52.621]             inherits <- base::inherits
[08:25:52.621]             invokeRestart <- base::invokeRestart
[08:25:52.621]             length <- base::length
[08:25:52.621]             list <- base::list
[08:25:52.621]             seq.int <- base::seq.int
[08:25:52.621]             signalCondition <- base::signalCondition
[08:25:52.621]             sys.calls <- base::sys.calls
[08:25:52.621]             `[[` <- base::`[[`
[08:25:52.621]             `+` <- base::`+`
[08:25:52.621]             `<<-` <- base::`<<-`
[08:25:52.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.621]                   3L)]
[08:25:52.621]             }
[08:25:52.621]             function(cond) {
[08:25:52.621]                 is_error <- inherits(cond, "error")
[08:25:52.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.621]                   NULL)
[08:25:52.621]                 if (is_error) {
[08:25:52.621]                   sessionInformation <- function() {
[08:25:52.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.621]                       search = base::search(), system = base::Sys.info())
[08:25:52.621]                   }
[08:25:52.621]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.621]                     cond$call), session = sessionInformation(), 
[08:25:52.621]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.621]                   signalCondition(cond)
[08:25:52.621]                 }
[08:25:52.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.621]                 "immediateCondition"))) {
[08:25:52.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.621]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.621]                   if (TRUE && !signal) {
[08:25:52.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.621]                     {
[08:25:52.621]                       inherits <- base::inherits
[08:25:52.621]                       invokeRestart <- base::invokeRestart
[08:25:52.621]                       is.null <- base::is.null
[08:25:52.621]                       muffled <- FALSE
[08:25:52.621]                       if (inherits(cond, "message")) {
[08:25:52.621]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.621]                         if (muffled) 
[08:25:52.621]                           invokeRestart("muffleMessage")
[08:25:52.621]                       }
[08:25:52.621]                       else if (inherits(cond, "warning")) {
[08:25:52.621]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.621]                         if (muffled) 
[08:25:52.621]                           invokeRestart("muffleWarning")
[08:25:52.621]                       }
[08:25:52.621]                       else if (inherits(cond, "condition")) {
[08:25:52.621]                         if (!is.null(pattern)) {
[08:25:52.621]                           computeRestarts <- base::computeRestarts
[08:25:52.621]                           grepl <- base::grepl
[08:25:52.621]                           restarts <- computeRestarts(cond)
[08:25:52.621]                           for (restart in restarts) {
[08:25:52.621]                             name <- restart$name
[08:25:52.621]                             if (is.null(name)) 
[08:25:52.621]                               next
[08:25:52.621]                             if (!grepl(pattern, name)) 
[08:25:52.621]                               next
[08:25:52.621]                             invokeRestart(restart)
[08:25:52.621]                             muffled <- TRUE
[08:25:52.621]                             break
[08:25:52.621]                           }
[08:25:52.621]                         }
[08:25:52.621]                       }
[08:25:52.621]                       invisible(muffled)
[08:25:52.621]                     }
[08:25:52.621]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.621]                   }
[08:25:52.621]                 }
[08:25:52.621]                 else {
[08:25:52.621]                   if (TRUE) {
[08:25:52.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.621]                     {
[08:25:52.621]                       inherits <- base::inherits
[08:25:52.621]                       invokeRestart <- base::invokeRestart
[08:25:52.621]                       is.null <- base::is.null
[08:25:52.621]                       muffled <- FALSE
[08:25:52.621]                       if (inherits(cond, "message")) {
[08:25:52.621]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.621]                         if (muffled) 
[08:25:52.621]                           invokeRestart("muffleMessage")
[08:25:52.621]                       }
[08:25:52.621]                       else if (inherits(cond, "warning")) {
[08:25:52.621]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.621]                         if (muffled) 
[08:25:52.621]                           invokeRestart("muffleWarning")
[08:25:52.621]                       }
[08:25:52.621]                       else if (inherits(cond, "condition")) {
[08:25:52.621]                         if (!is.null(pattern)) {
[08:25:52.621]                           computeRestarts <- base::computeRestarts
[08:25:52.621]                           grepl <- base::grepl
[08:25:52.621]                           restarts <- computeRestarts(cond)
[08:25:52.621]                           for (restart in restarts) {
[08:25:52.621]                             name <- restart$name
[08:25:52.621]                             if (is.null(name)) 
[08:25:52.621]                               next
[08:25:52.621]                             if (!grepl(pattern, name)) 
[08:25:52.621]                               next
[08:25:52.621]                             invokeRestart(restart)
[08:25:52.621]                             muffled <- TRUE
[08:25:52.621]                             break
[08:25:52.621]                           }
[08:25:52.621]                         }
[08:25:52.621]                       }
[08:25:52.621]                       invisible(muffled)
[08:25:52.621]                     }
[08:25:52.621]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.621]                   }
[08:25:52.621]                 }
[08:25:52.621]             }
[08:25:52.621]         }))
[08:25:52.621]     }, error = function(ex) {
[08:25:52.621]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.621]                 ...future.rng), started = ...future.startTime, 
[08:25:52.621]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.621]             version = "1.8"), class = "FutureResult")
[08:25:52.621]     }, finally = {
[08:25:52.621]         if (!identical(...future.workdir, getwd())) 
[08:25:52.621]             setwd(...future.workdir)
[08:25:52.621]         {
[08:25:52.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.621]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.621]             }
[08:25:52.621]             base::options(...future.oldOptions)
[08:25:52.621]             if (.Platform$OS.type == "windows") {
[08:25:52.621]                 old_names <- names(...future.oldEnvVars)
[08:25:52.621]                 envs <- base::Sys.getenv()
[08:25:52.621]                 names <- names(envs)
[08:25:52.621]                 common <- intersect(names, old_names)
[08:25:52.621]                 added <- setdiff(names, old_names)
[08:25:52.621]                 removed <- setdiff(old_names, names)
[08:25:52.621]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.621]                   envs[common]]
[08:25:52.621]                 NAMES <- toupper(changed)
[08:25:52.621]                 args <- list()
[08:25:52.621]                 for (kk in seq_along(NAMES)) {
[08:25:52.621]                   name <- changed[[kk]]
[08:25:52.621]                   NAME <- NAMES[[kk]]
[08:25:52.621]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.621]                     next
[08:25:52.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.621]                 }
[08:25:52.621]                 NAMES <- toupper(added)
[08:25:52.621]                 for (kk in seq_along(NAMES)) {
[08:25:52.621]                   name <- added[[kk]]
[08:25:52.621]                   NAME <- NAMES[[kk]]
[08:25:52.621]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.621]                     next
[08:25:52.621]                   args[[name]] <- ""
[08:25:52.621]                 }
[08:25:52.621]                 NAMES <- toupper(removed)
[08:25:52.621]                 for (kk in seq_along(NAMES)) {
[08:25:52.621]                   name <- removed[[kk]]
[08:25:52.621]                   NAME <- NAMES[[kk]]
[08:25:52.621]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.621]                     next
[08:25:52.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.621]                 }
[08:25:52.621]                 if (length(args) > 0) 
[08:25:52.621]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.621]             }
[08:25:52.621]             else {
[08:25:52.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.621]             }
[08:25:52.621]             {
[08:25:52.621]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.621]                   0L) {
[08:25:52.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.621]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.621]                   base::options(opts)
[08:25:52.621]                 }
[08:25:52.621]                 {
[08:25:52.621]                   {
[08:25:52.621]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.621]                     NULL
[08:25:52.621]                   }
[08:25:52.621]                   options(future.plan = NULL)
[08:25:52.621]                   if (is.na(NA_character_)) 
[08:25:52.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.621]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.621]                     .init = FALSE)
[08:25:52.621]                 }
[08:25:52.621]             }
[08:25:52.621]         }
[08:25:52.621]     })
[08:25:52.621]     if (TRUE) {
[08:25:52.621]         base::sink(type = "output", split = FALSE)
[08:25:52.621]         if (TRUE) {
[08:25:52.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.621]         }
[08:25:52.621]         else {
[08:25:52.621]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.621]         }
[08:25:52.621]         base::close(...future.stdout)
[08:25:52.621]         ...future.stdout <- NULL
[08:25:52.621]     }
[08:25:52.621]     ...future.result$conditions <- ...future.conditions
[08:25:52.621]     ...future.result$finished <- base::Sys.time()
[08:25:52.621]     ...future.result
[08:25:52.621] }
[08:25:52.624] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[08:25:52.624] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[08:25:52.625] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[08:25:52.625] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:52.625] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.625] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ...
[08:25:52.626] Exporting ‘...future.elements_ii’ (76 bytes) to cluster node #2 ... DONE
[08:25:52.626] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:52.626] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.626] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:52.627] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.627] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[08:25:52.627] MultisessionFuture started
[08:25:52.627] - Launch lazy future ... done
[08:25:52.628] run() for ‘MultisessionFuture’ ... done
[08:25:52.628] Created future:
[08:25:52.628] MultisessionFuture:
[08:25:52.628] Label: ‘future_mapply-2’
[08:25:52.628] Expression:
[08:25:52.628] {
[08:25:52.628]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.628]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.628]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.628]         on.exit(options(oopts), add = TRUE)
[08:25:52.628]     }
[08:25:52.628]     {
[08:25:52.628]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.628]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.628]         do.call(mapply, args = args)
[08:25:52.628]     }
[08:25:52.628] }
[08:25:52.628] Lazy evaluation: FALSE
[08:25:52.628] Asynchronous evaluation: TRUE
[08:25:52.628] Local evaluation: TRUE
[08:25:52.628] Environment: R_GlobalEnv
[08:25:52.628] Capture standard output: TRUE
[08:25:52.628] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.628] Globals: 5 objects totaling 847 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 76 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.628] Packages: <none>
[08:25:52.628] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.628] Resolved: FALSE
[08:25:52.628] Value: <not collected>
[08:25:52.628] Conditions captured: <none>
[08:25:52.628] Early signaling: FALSE
[08:25:52.628] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.628] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.639] Chunk #2 of 3 ... DONE
[08:25:52.639] Chunk #3 of 3 ...
[08:25:52.639]  - Finding globals in '...' for chunk #3 ...
[08:25:52.640] getGlobalsAndPackages() ...
[08:25:52.640] Searching for globals...
[08:25:52.640] 
[08:25:52.640] Searching for globals ... DONE
[08:25:52.640] - globals: [0] <none>
[08:25:52.640] getGlobalsAndPackages() ... DONE
[08:25:52.640]    + additional globals found: [n=0] 
[08:25:52.640]    + additional namespaces needed: [n=0] 
[08:25:52.641]  - Finding globals in '...' for chunk #3 ... DONE
[08:25:52.641]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[08:25:52.641]  - seeds: <none>
[08:25:52.641]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.641] getGlobalsAndPackages() ...
[08:25:52.641] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.641] Resolving globals: FALSE
[08:25:52.642] The total size of the 5 globals is 876 bytes (876 bytes)
[08:25:52.642] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:52.642] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.642] 
[08:25:52.642] getGlobalsAndPackages() ... DONE
[08:25:52.643] run() for ‘Future’ ...
[08:25:52.643] - state: ‘created’
[08:25:52.643] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.657] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.657]   - Field: ‘node’
[08:25:52.657]   - Field: ‘label’
[08:25:52.657]   - Field: ‘local’
[08:25:52.657]   - Field: ‘owner’
[08:25:52.657]   - Field: ‘envir’
[08:25:52.657]   - Field: ‘workers’
[08:25:52.657]   - Field: ‘packages’
[08:25:52.657]   - Field: ‘gc’
[08:25:52.658]   - Field: ‘conditions’
[08:25:52.658]   - Field: ‘persistent’
[08:25:52.658]   - Field: ‘expr’
[08:25:52.658]   - Field: ‘uuid’
[08:25:52.658]   - Field: ‘seed’
[08:25:52.658]   - Field: ‘version’
[08:25:52.658]   - Field: ‘result’
[08:25:52.658]   - Field: ‘asynchronous’
[08:25:52.658]   - Field: ‘calls’
[08:25:52.658]   - Field: ‘globals’
[08:25:52.658]   - Field: ‘stdout’
[08:25:52.658]   - Field: ‘earlySignal’
[08:25:52.659]   - Field: ‘lazy’
[08:25:52.659]   - Field: ‘state’
[08:25:52.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.659] - Launch lazy future ...
[08:25:52.659] Packages needed by the future expression (n = 0): <none>
[08:25:52.659] Packages needed by future strategies (n = 0): <none>
[08:25:52.660] {
[08:25:52.660]     {
[08:25:52.660]         {
[08:25:52.660]             ...future.startTime <- base::Sys.time()
[08:25:52.660]             {
[08:25:52.660]                 {
[08:25:52.660]                   {
[08:25:52.660]                     {
[08:25:52.660]                       base::local({
[08:25:52.660]                         has_future <- base::requireNamespace("future", 
[08:25:52.660]                           quietly = TRUE)
[08:25:52.660]                         if (has_future) {
[08:25:52.660]                           ns <- base::getNamespace("future")
[08:25:52.660]                           version <- ns[[".package"]][["version"]]
[08:25:52.660]                           if (is.null(version)) 
[08:25:52.660]                             version <- utils::packageVersion("future")
[08:25:52.660]                         }
[08:25:52.660]                         else {
[08:25:52.660]                           version <- NULL
[08:25:52.660]                         }
[08:25:52.660]                         if (!has_future || version < "1.8.0") {
[08:25:52.660]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.660]                             "", base::R.version$version.string), 
[08:25:52.660]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.660]                               "release", "version")], collapse = " "), 
[08:25:52.660]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.660]                             info)
[08:25:52.660]                           info <- base::paste(info, collapse = "; ")
[08:25:52.660]                           if (!has_future) {
[08:25:52.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.660]                               info)
[08:25:52.660]                           }
[08:25:52.660]                           else {
[08:25:52.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.660]                               info, version)
[08:25:52.660]                           }
[08:25:52.660]                           base::stop(msg)
[08:25:52.660]                         }
[08:25:52.660]                       })
[08:25:52.660]                     }
[08:25:52.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.660]                     base::options(mc.cores = 1L)
[08:25:52.660]                   }
[08:25:52.660]                   ...future.strategy.old <- future::plan("list")
[08:25:52.660]                   options(future.plan = NULL)
[08:25:52.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.660]                 }
[08:25:52.660]                 ...future.workdir <- getwd()
[08:25:52.660]             }
[08:25:52.660]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.660]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.660]         }
[08:25:52.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.660]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[08:25:52.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.660]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.660]             base::names(...future.oldOptions))
[08:25:52.660]     }
[08:25:52.660]     if (FALSE) {
[08:25:52.660]     }
[08:25:52.660]     else {
[08:25:52.660]         if (TRUE) {
[08:25:52.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.660]                 open = "w")
[08:25:52.660]         }
[08:25:52.660]         else {
[08:25:52.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.660]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.660]         }
[08:25:52.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.660]             base::sink(type = "output", split = FALSE)
[08:25:52.660]             base::close(...future.stdout)
[08:25:52.660]         }, add = TRUE)
[08:25:52.660]     }
[08:25:52.660]     ...future.frame <- base::sys.nframe()
[08:25:52.660]     ...future.conditions <- base::list()
[08:25:52.660]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.660]     if (FALSE) {
[08:25:52.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.660]     }
[08:25:52.660]     ...future.result <- base::tryCatch({
[08:25:52.660]         base::withCallingHandlers({
[08:25:52.660]             ...future.value <- base::withVisible(base::local({
[08:25:52.660]                 ...future.makeSendCondition <- base::local({
[08:25:52.660]                   sendCondition <- NULL
[08:25:52.660]                   function(frame = 1L) {
[08:25:52.660]                     if (is.function(sendCondition)) 
[08:25:52.660]                       return(sendCondition)
[08:25:52.660]                     ns <- getNamespace("parallel")
[08:25:52.660]                     if (exists("sendData", mode = "function", 
[08:25:52.660]                       envir = ns)) {
[08:25:52.660]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.660]                         envir = ns)
[08:25:52.660]                       envir <- sys.frame(frame)
[08:25:52.660]                       master <- NULL
[08:25:52.660]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.660]                         !identical(envir, emptyenv())) {
[08:25:52.660]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.660]                           inherits = FALSE)) {
[08:25:52.660]                           master <- get("master", mode = "list", 
[08:25:52.660]                             envir = envir, inherits = FALSE)
[08:25:52.660]                           if (inherits(master, c("SOCKnode", 
[08:25:52.660]                             "SOCK0node"))) {
[08:25:52.660]                             sendCondition <<- function(cond) {
[08:25:52.660]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.660]                                 success = TRUE)
[08:25:52.660]                               parallel_sendData(master, data)
[08:25:52.660]                             }
[08:25:52.660]                             return(sendCondition)
[08:25:52.660]                           }
[08:25:52.660]                         }
[08:25:52.660]                         frame <- frame + 1L
[08:25:52.660]                         envir <- sys.frame(frame)
[08:25:52.660]                       }
[08:25:52.660]                     }
[08:25:52.660]                     sendCondition <<- function(cond) NULL
[08:25:52.660]                   }
[08:25:52.660]                 })
[08:25:52.660]                 withCallingHandlers({
[08:25:52.660]                   {
[08:25:52.660]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.660]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.660]                       ...future.globals.maxSize)) {
[08:25:52.660]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.660]                       on.exit(options(oopts), add = TRUE)
[08:25:52.660]                     }
[08:25:52.660]                     {
[08:25:52.660]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.660]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.660]                         USE.NAMES = FALSE)
[08:25:52.660]                       do.call(mapply, args = args)
[08:25:52.660]                     }
[08:25:52.660]                   }
[08:25:52.660]                 }, immediateCondition = function(cond) {
[08:25:52.660]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.660]                   sendCondition(cond)
[08:25:52.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.660]                   {
[08:25:52.660]                     inherits <- base::inherits
[08:25:52.660]                     invokeRestart <- base::invokeRestart
[08:25:52.660]                     is.null <- base::is.null
[08:25:52.660]                     muffled <- FALSE
[08:25:52.660]                     if (inherits(cond, "message")) {
[08:25:52.660]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.660]                       if (muffled) 
[08:25:52.660]                         invokeRestart("muffleMessage")
[08:25:52.660]                     }
[08:25:52.660]                     else if (inherits(cond, "warning")) {
[08:25:52.660]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.660]                       if (muffled) 
[08:25:52.660]                         invokeRestart("muffleWarning")
[08:25:52.660]                     }
[08:25:52.660]                     else if (inherits(cond, "condition")) {
[08:25:52.660]                       if (!is.null(pattern)) {
[08:25:52.660]                         computeRestarts <- base::computeRestarts
[08:25:52.660]                         grepl <- base::grepl
[08:25:52.660]                         restarts <- computeRestarts(cond)
[08:25:52.660]                         for (restart in restarts) {
[08:25:52.660]                           name <- restart$name
[08:25:52.660]                           if (is.null(name)) 
[08:25:52.660]                             next
[08:25:52.660]                           if (!grepl(pattern, name)) 
[08:25:52.660]                             next
[08:25:52.660]                           invokeRestart(restart)
[08:25:52.660]                           muffled <- TRUE
[08:25:52.660]                           break
[08:25:52.660]                         }
[08:25:52.660]                       }
[08:25:52.660]                     }
[08:25:52.660]                     invisible(muffled)
[08:25:52.660]                   }
[08:25:52.660]                   muffleCondition(cond)
[08:25:52.660]                 })
[08:25:52.660]             }))
[08:25:52.660]             future::FutureResult(value = ...future.value$value, 
[08:25:52.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.660]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.660]                     ...future.globalenv.names))
[08:25:52.660]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.660]         }, condition = base::local({
[08:25:52.660]             c <- base::c
[08:25:52.660]             inherits <- base::inherits
[08:25:52.660]             invokeRestart <- base::invokeRestart
[08:25:52.660]             length <- base::length
[08:25:52.660]             list <- base::list
[08:25:52.660]             seq.int <- base::seq.int
[08:25:52.660]             signalCondition <- base::signalCondition
[08:25:52.660]             sys.calls <- base::sys.calls
[08:25:52.660]             `[[` <- base::`[[`
[08:25:52.660]             `+` <- base::`+`
[08:25:52.660]             `<<-` <- base::`<<-`
[08:25:52.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.660]                   3L)]
[08:25:52.660]             }
[08:25:52.660]             function(cond) {
[08:25:52.660]                 is_error <- inherits(cond, "error")
[08:25:52.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.660]                   NULL)
[08:25:52.660]                 if (is_error) {
[08:25:52.660]                   sessionInformation <- function() {
[08:25:52.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.660]                       search = base::search(), system = base::Sys.info())
[08:25:52.660]                   }
[08:25:52.660]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.660]                     cond$call), session = sessionInformation(), 
[08:25:52.660]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.660]                   signalCondition(cond)
[08:25:52.660]                 }
[08:25:52.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.660]                 "immediateCondition"))) {
[08:25:52.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.660]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.660]                   if (TRUE && !signal) {
[08:25:52.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.660]                     {
[08:25:52.660]                       inherits <- base::inherits
[08:25:52.660]                       invokeRestart <- base::invokeRestart
[08:25:52.660]                       is.null <- base::is.null
[08:25:52.660]                       muffled <- FALSE
[08:25:52.660]                       if (inherits(cond, "message")) {
[08:25:52.660]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.660]                         if (muffled) 
[08:25:52.660]                           invokeRestart("muffleMessage")
[08:25:52.660]                       }
[08:25:52.660]                       else if (inherits(cond, "warning")) {
[08:25:52.660]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.660]                         if (muffled) 
[08:25:52.660]                           invokeRestart("muffleWarning")
[08:25:52.660]                       }
[08:25:52.660]                       else if (inherits(cond, "condition")) {
[08:25:52.660]                         if (!is.null(pattern)) {
[08:25:52.660]                           computeRestarts <- base::computeRestarts
[08:25:52.660]                           grepl <- base::grepl
[08:25:52.660]                           restarts <- computeRestarts(cond)
[08:25:52.660]                           for (restart in restarts) {
[08:25:52.660]                             name <- restart$name
[08:25:52.660]                             if (is.null(name)) 
[08:25:52.660]                               next
[08:25:52.660]                             if (!grepl(pattern, name)) 
[08:25:52.660]                               next
[08:25:52.660]                             invokeRestart(restart)
[08:25:52.660]                             muffled <- TRUE
[08:25:52.660]                             break
[08:25:52.660]                           }
[08:25:52.660]                         }
[08:25:52.660]                       }
[08:25:52.660]                       invisible(muffled)
[08:25:52.660]                     }
[08:25:52.660]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.660]                   }
[08:25:52.660]                 }
[08:25:52.660]                 else {
[08:25:52.660]                   if (TRUE) {
[08:25:52.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.660]                     {
[08:25:52.660]                       inherits <- base::inherits
[08:25:52.660]                       invokeRestart <- base::invokeRestart
[08:25:52.660]                       is.null <- base::is.null
[08:25:52.660]                       muffled <- FALSE
[08:25:52.660]                       if (inherits(cond, "message")) {
[08:25:52.660]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.660]                         if (muffled) 
[08:25:52.660]                           invokeRestart("muffleMessage")
[08:25:52.660]                       }
[08:25:52.660]                       else if (inherits(cond, "warning")) {
[08:25:52.660]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.660]                         if (muffled) 
[08:25:52.660]                           invokeRestart("muffleWarning")
[08:25:52.660]                       }
[08:25:52.660]                       else if (inherits(cond, "condition")) {
[08:25:52.660]                         if (!is.null(pattern)) {
[08:25:52.660]                           computeRestarts <- base::computeRestarts
[08:25:52.660]                           grepl <- base::grepl
[08:25:52.660]                           restarts <- computeRestarts(cond)
[08:25:52.660]                           for (restart in restarts) {
[08:25:52.660]                             name <- restart$name
[08:25:52.660]                             if (is.null(name)) 
[08:25:52.660]                               next
[08:25:52.660]                             if (!grepl(pattern, name)) 
[08:25:52.660]                               next
[08:25:52.660]                             invokeRestart(restart)
[08:25:52.660]                             muffled <- TRUE
[08:25:52.660]                             break
[08:25:52.660]                           }
[08:25:52.660]                         }
[08:25:52.660]                       }
[08:25:52.660]                       invisible(muffled)
[08:25:52.660]                     }
[08:25:52.660]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.660]                   }
[08:25:52.660]                 }
[08:25:52.660]             }
[08:25:52.660]         }))
[08:25:52.660]     }, error = function(ex) {
[08:25:52.660]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.660]                 ...future.rng), started = ...future.startTime, 
[08:25:52.660]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.660]             version = "1.8"), class = "FutureResult")
[08:25:52.660]     }, finally = {
[08:25:52.660]         if (!identical(...future.workdir, getwd())) 
[08:25:52.660]             setwd(...future.workdir)
[08:25:52.660]         {
[08:25:52.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.660]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.660]             }
[08:25:52.660]             base::options(...future.oldOptions)
[08:25:52.660]             if (.Platform$OS.type == "windows") {
[08:25:52.660]                 old_names <- names(...future.oldEnvVars)
[08:25:52.660]                 envs <- base::Sys.getenv()
[08:25:52.660]                 names <- names(envs)
[08:25:52.660]                 common <- intersect(names, old_names)
[08:25:52.660]                 added <- setdiff(names, old_names)
[08:25:52.660]                 removed <- setdiff(old_names, names)
[08:25:52.660]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.660]                   envs[common]]
[08:25:52.660]                 NAMES <- toupper(changed)
[08:25:52.660]                 args <- list()
[08:25:52.660]                 for (kk in seq_along(NAMES)) {
[08:25:52.660]                   name <- changed[[kk]]
[08:25:52.660]                   NAME <- NAMES[[kk]]
[08:25:52.660]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.660]                     next
[08:25:52.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.660]                 }
[08:25:52.660]                 NAMES <- toupper(added)
[08:25:52.660]                 for (kk in seq_along(NAMES)) {
[08:25:52.660]                   name <- added[[kk]]
[08:25:52.660]                   NAME <- NAMES[[kk]]
[08:25:52.660]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.660]                     next
[08:25:52.660]                   args[[name]] <- ""
[08:25:52.660]                 }
[08:25:52.660]                 NAMES <- toupper(removed)
[08:25:52.660]                 for (kk in seq_along(NAMES)) {
[08:25:52.660]                   name <- removed[[kk]]
[08:25:52.660]                   NAME <- NAMES[[kk]]
[08:25:52.660]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.660]                     next
[08:25:52.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.660]                 }
[08:25:52.660]                 if (length(args) > 0) 
[08:25:52.660]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.660]             }
[08:25:52.660]             else {
[08:25:52.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.660]             }
[08:25:52.660]             {
[08:25:52.660]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.660]                   0L) {
[08:25:52.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.660]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.660]                   base::options(opts)
[08:25:52.660]                 }
[08:25:52.660]                 {
[08:25:52.660]                   {
[08:25:52.660]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.660]                     NULL
[08:25:52.660]                   }
[08:25:52.660]                   options(future.plan = NULL)
[08:25:52.660]                   if (is.na(NA_character_)) 
[08:25:52.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.660]                     .init = FALSE)
[08:25:52.660]                 }
[08:25:52.660]             }
[08:25:52.660]         }
[08:25:52.660]     })
[08:25:52.660]     if (TRUE) {
[08:25:52.660]         base::sink(type = "output", split = FALSE)
[08:25:52.660]         if (TRUE) {
[08:25:52.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.660]         }
[08:25:52.660]         else {
[08:25:52.660]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.660]         }
[08:25:52.660]         base::close(...future.stdout)
[08:25:52.660]         ...future.stdout <- NULL
[08:25:52.660]     }
[08:25:52.660]     ...future.result$conditions <- ...future.conditions
[08:25:52.660]     ...future.result$finished <- base::Sys.time()
[08:25:52.660]     ...future.result
[08:25:52.660] }
[08:25:52.662] Poll #1 (0): usedNodes() = 2, workers = 2
[08:25:52.673] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.673] - Validating connection of MultisessionFuture
[08:25:52.673] - received message: FutureResult
[08:25:52.673] - Received FutureResult
[08:25:52.673] - Erased future from FutureRegistry
[08:25:52.674] result() for ClusterFuture ...
[08:25:52.674] - result already collected: FutureResult
[08:25:52.674] result() for ClusterFuture ... done
[08:25:52.674] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.674] result() for ClusterFuture ...
[08:25:52.674] - result already collected: FutureResult
[08:25:52.674] result() for ClusterFuture ... done
[08:25:52.674] result() for ClusterFuture ...
[08:25:52.674] - result already collected: FutureResult
[08:25:52.674] result() for ClusterFuture ... done
[08:25:52.675] Exporting 5 global objects (1.29 KiB) to cluster node #1 ...
[08:25:52.675] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[08:25:52.676] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[08:25:52.676] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:52.676] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.676] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[08:25:52.677] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[08:25:52.677] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:52.677] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.677] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:52.678] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.678] Exporting 5 global objects (1.29 KiB) to cluster node #1 ... DONE
[08:25:52.678] MultisessionFuture started
[08:25:52.678] - Launch lazy future ... done
[08:25:52.679] run() for ‘MultisessionFuture’ ... done
[08:25:52.679] Created future:
[08:25:52.679] MultisessionFuture:
[08:25:52.679] Label: ‘future_mapply-3’
[08:25:52.679] Expression:
[08:25:52.679] {
[08:25:52.679]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.679]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.679]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.679]         on.exit(options(oopts), add = TRUE)
[08:25:52.679]     }
[08:25:52.679]     {
[08:25:52.679]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.679]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.679]         do.call(mapply, args = args)
[08:25:52.679]     }
[08:25:52.679] }
[08:25:52.679] Lazy evaluation: FALSE
[08:25:52.679] Asynchronous evaluation: TRUE
[08:25:52.679] Local evaluation: TRUE
[08:25:52.679] Environment: R_GlobalEnv
[08:25:52.679] Capture standard output: TRUE
[08:25:52.679] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.679] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.679] Packages: <none>
[08:25:52.679] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.679] Resolved: FALSE
[08:25:52.679] Value: <not collected>
[08:25:52.679] Conditions captured: <none>
[08:25:52.679] Early signaling: FALSE
[08:25:52.679] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.679] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.690] Chunk #3 of 3 ... DONE
[08:25:52.690] Launching 3 futures (chunks) ... DONE
[08:25:52.690] Resolving 3 futures (chunks) ...
[08:25:52.691] resolve() on list ...
[08:25:52.691]  recursive: 0
[08:25:52.691]  length: 3
[08:25:52.691] 
[08:25:52.691] Future #1
[08:25:52.691] result() for ClusterFuture ...
[08:25:52.691] - result already collected: FutureResult
[08:25:52.691] result() for ClusterFuture ... done
[08:25:52.691] result() for ClusterFuture ...
[08:25:52.691] - result already collected: FutureResult
[08:25:52.691] result() for ClusterFuture ... done
[08:25:52.692] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:52.692] - nx: 3
[08:25:52.692] - relay: TRUE
[08:25:52.692] - stdout: TRUE
[08:25:52.692] - signal: TRUE
[08:25:52.692] - resignal: FALSE
[08:25:52.692] - force: TRUE
[08:25:52.692] - relayed: [n=3] FALSE, FALSE, FALSE
[08:25:52.692] - queued futures: [n=3] FALSE, FALSE, FALSE
[08:25:52.692]  - until=1
[08:25:52.692]  - relaying element #1
[08:25:52.693] result() for ClusterFuture ...
[08:25:52.693] - result already collected: FutureResult
[08:25:52.693] result() for ClusterFuture ... done
[08:25:52.693] result() for ClusterFuture ...
[08:25:52.693] - result already collected: FutureResult
[08:25:52.693] result() for ClusterFuture ... done
[08:25:52.693] result() for ClusterFuture ...
[08:25:52.693] - result already collected: FutureResult
[08:25:52.693] result() for ClusterFuture ... done
[08:25:52.693] result() for ClusterFuture ...
[08:25:52.693] - result already collected: FutureResult
[08:25:52.693] result() for ClusterFuture ... done
[08:25:52.694] - relayed: [n=3] TRUE, FALSE, FALSE
[08:25:52.694] - queued futures: [n=3] TRUE, FALSE, FALSE
[08:25:52.694] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:52.694]  length: 2 (resolved future 1)
[08:25:52.694] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.694] - Validating connection of MultisessionFuture
[08:25:52.695] - received message: FutureResult
[08:25:52.695] - Received FutureResult
[08:25:52.695] - Erased future from FutureRegistry
[08:25:52.695] result() for ClusterFuture ...
[08:25:52.695] - result already collected: FutureResult
[08:25:52.695] result() for ClusterFuture ... done
[08:25:52.695] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.695] Future #2
[08:25:52.695] result() for ClusterFuture ...
[08:25:52.695] - result already collected: FutureResult
[08:25:52.696] result() for ClusterFuture ... done
[08:25:52.696] result() for ClusterFuture ...
[08:25:52.696] - result already collected: FutureResult
[08:25:52.696] result() for ClusterFuture ... done
[08:25:52.696] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:52.696] - nx: 3
[08:25:52.696] - relay: TRUE
[08:25:52.696] - stdout: TRUE
[08:25:52.696] - signal: TRUE
[08:25:52.696] - resignal: FALSE
[08:25:52.696] - force: TRUE
[08:25:52.696] - relayed: [n=3] TRUE, FALSE, FALSE
[08:25:52.697] - queued futures: [n=3] TRUE, FALSE, FALSE
[08:25:52.697]  - until=2
[08:25:52.697]  - relaying element #2
[08:25:52.697] result() for ClusterFuture ...
[08:25:52.697] - result already collected: FutureResult
[08:25:52.697] result() for ClusterFuture ... done
[08:25:52.697] result() for ClusterFuture ...
[08:25:52.697] - result already collected: FutureResult
[08:25:52.697] result() for ClusterFuture ... done
[08:25:52.697] result() for ClusterFuture ...
[08:25:52.697] - result already collected: FutureResult
[08:25:52.698] result() for ClusterFuture ... done
[08:25:52.698] result() for ClusterFuture ...
[08:25:52.698] - result already collected: FutureResult
[08:25:52.698] result() for ClusterFuture ... done
[08:25:52.698] - relayed: [n=3] TRUE, TRUE, FALSE
[08:25:52.698] - queued futures: [n=3] TRUE, TRUE, FALSE
[08:25:52.698] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:52.698]  length: 1 (resolved future 2)
[08:25:52.720] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.720] - Validating connection of MultisessionFuture
[08:25:52.721] - received message: FutureResult
[08:25:52.721] - Received FutureResult
[08:25:52.721] - Erased future from FutureRegistry
[08:25:52.721] result() for ClusterFuture ...
[08:25:52.721] - result already collected: FutureResult
[08:25:52.721] result() for ClusterFuture ... done
[08:25:52.721] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.721] Future #3
[08:25:52.721] result() for ClusterFuture ...
[08:25:52.721] - result already collected: FutureResult
[08:25:52.721] result() for ClusterFuture ... done
[08:25:52.722] result() for ClusterFuture ...
[08:25:52.722] - result already collected: FutureResult
[08:25:52.722] result() for ClusterFuture ... done
[08:25:52.722] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:25:52.722] - nx: 3
[08:25:52.722] - relay: TRUE
[08:25:52.722] - stdout: TRUE
[08:25:52.722] - signal: TRUE
[08:25:52.722] - resignal: FALSE
[08:25:52.722] - force: TRUE
[08:25:52.722] - relayed: [n=3] TRUE, TRUE, FALSE
[08:25:52.722] - queued futures: [n=3] TRUE, TRUE, FALSE
[08:25:52.723]  - until=3
[08:25:52.723]  - relaying element #3
[08:25:52.723] result() for ClusterFuture ...
[08:25:52.723] - result already collected: FutureResult
[08:25:52.723] result() for ClusterFuture ... done
[08:25:52.723] result() for ClusterFuture ...
[08:25:52.723] - result already collected: FutureResult
[08:25:52.723] result() for ClusterFuture ... done
[08:25:52.723] result() for ClusterFuture ...
[08:25:52.723] - result already collected: FutureResult
[08:25:52.723] result() for ClusterFuture ... done
[08:25:52.724] result() for ClusterFuture ...
[08:25:52.724] - result already collected: FutureResult
[08:25:52.724] result() for ClusterFuture ... done
[08:25:52.724] - relayed: [n=3] TRUE, TRUE, TRUE
[08:25:52.724] - queued futures: [n=3] TRUE, TRUE, TRUE
[08:25:52.724] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:25:52.724]  length: 0 (resolved future 3)
[08:25:52.724] Relaying remaining futures
[08:25:52.724] signalConditionsASAP(NULL, pos=0) ...
[08:25:52.724] - nx: 3
[08:25:52.724] - relay: TRUE
[08:25:52.725] - stdout: TRUE
[08:25:52.725] - signal: TRUE
[08:25:52.725] - resignal: FALSE
[08:25:52.725] - force: TRUE
[08:25:52.725] - relayed: [n=3] TRUE, TRUE, TRUE
[08:25:52.725] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[08:25:52.727] - relayed: [n=3] TRUE, TRUE, TRUE
[08:25:52.728] - queued futures: [n=3] TRUE, TRUE, TRUE
[08:25:52.728] signalConditionsASAP(NULL, pos=0) ... done
[08:25:52.728] resolve() on list ... DONE
[08:25:52.728] result() for ClusterFuture ...
[08:25:52.728] - result already collected: FutureResult
[08:25:52.728] result() for ClusterFuture ... done
[08:25:52.728] result() for ClusterFuture ...
[08:25:52.728] - result already collected: FutureResult
[08:25:52.728] result() for ClusterFuture ... done
[08:25:52.728] result() for ClusterFuture ...
[08:25:52.728] - result already collected: FutureResult
[08:25:52.729] result() for ClusterFuture ... done
[08:25:52.729] result() for ClusterFuture ...
[08:25:52.729] - result already collected: FutureResult
[08:25:52.729] result() for ClusterFuture ... done
[08:25:52.729] result() for ClusterFuture ...
[08:25:52.729] - result already collected: FutureResult
[08:25:52.729] result() for ClusterFuture ... done
[08:25:52.729] result() for ClusterFuture ...
[08:25:52.729] - result already collected: FutureResult
[08:25:52.729] result() for ClusterFuture ... done
[08:25:52.729]  - Number of value chunks collected: 3
[08:25:52.729] Resolving 3 futures (chunks) ... DONE
[08:25:52.730] Reducing values from 3 chunks ...
[08:25:52.730]  - Number of values collected after concatenation: 5
[08:25:52.730]  - Number of values expected: 5
[08:25:52.730] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 2, 3, 1
[08:25:52.730] Reducing values from 3 chunks ... DONE
[08:25:52.730] future_mapply() ... DONE
[08:25:52.730] future_mapply() ...
[08:25:52.732] Number of chunks: 2
[08:25:52.732] getGlobalsAndPackagesXApply() ...
[08:25:52.732]  - future.globals: TRUE
[08:25:52.732] getGlobalsAndPackages() ...
[08:25:52.733] Searching for globals...
[08:25:52.734] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:52.734] Searching for globals ... DONE
[08:25:52.734] Resolving globals: FALSE
[08:25:52.734] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:52.735] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:52.735] - globals: [1] ‘FUN’
[08:25:52.735] 
[08:25:52.735] getGlobalsAndPackages() ... DONE
[08:25:52.735]  - globals found/used: [n=1] ‘FUN’
[08:25:52.735]  - needed namespaces: [n=0] 
[08:25:52.735] Finding globals ... DONE
[08:25:52.736] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:52.736] List of 2
[08:25:52.736]  $ ...future.FUN:function (C, k)  
[08:25:52.736]  $ MoreArgs     : list()
[08:25:52.736]  - attr(*, "where")=List of 2
[08:25:52.736]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:52.736]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:52.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:52.736]  - attr(*, "resolved")= logi FALSE
[08:25:52.736]  - attr(*, "total_size")= num NA
[08:25:52.738] Packages to be attached in all futures: [n=0] 
[08:25:52.738] getGlobalsAndPackagesXApply() ... DONE
[08:25:52.738] Number of futures (= number of chunks): 2
[08:25:52.739] Launching 2 futures (chunks) ...
[08:25:52.739] Chunk #1 of 2 ...
[08:25:52.739]  - Finding globals in '...' for chunk #1 ...
[08:25:52.739] getGlobalsAndPackages() ...
[08:25:52.739] Searching for globals...
[08:25:52.739] 
[08:25:52.739] Searching for globals ... DONE
[08:25:52.739] - globals: [0] <none>
[08:25:52.740] getGlobalsAndPackages() ... DONE
[08:25:52.740]    + additional globals found: [n=0] 
[08:25:52.740]    + additional namespaces needed: [n=0] 
[08:25:52.740]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:52.740]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:52.740]  - seeds: <none>
[08:25:52.740]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.740] getGlobalsAndPackages() ...
[08:25:52.740] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.740] Resolving globals: FALSE
[08:25:52.741] The total size of the 5 globals is 880 bytes (880 bytes)
[08:25:52.741] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:52.741] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.741] 
[08:25:52.742] getGlobalsAndPackages() ... DONE
[08:25:52.742] run() for ‘Future’ ...
[08:25:52.742] - state: ‘created’
[08:25:52.742] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.756] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.756] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.756]   - Field: ‘node’
[08:25:52.756]   - Field: ‘label’
[08:25:52.756]   - Field: ‘local’
[08:25:52.756]   - Field: ‘owner’
[08:25:52.757]   - Field: ‘envir’
[08:25:52.757]   - Field: ‘workers’
[08:25:52.757]   - Field: ‘packages’
[08:25:52.757]   - Field: ‘gc’
[08:25:52.757]   - Field: ‘conditions’
[08:25:52.757]   - Field: ‘persistent’
[08:25:52.757]   - Field: ‘expr’
[08:25:52.757]   - Field: ‘uuid’
[08:25:52.757]   - Field: ‘seed’
[08:25:52.757]   - Field: ‘version’
[08:25:52.757]   - Field: ‘result’
[08:25:52.758]   - Field: ‘asynchronous’
[08:25:52.758]   - Field: ‘calls’
[08:25:52.758]   - Field: ‘globals’
[08:25:52.758]   - Field: ‘stdout’
[08:25:52.758]   - Field: ‘earlySignal’
[08:25:52.758]   - Field: ‘lazy’
[08:25:52.758]   - Field: ‘state’
[08:25:52.758] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.758] - Launch lazy future ...
[08:25:52.759] Packages needed by the future expression (n = 0): <none>
[08:25:52.759] Packages needed by future strategies (n = 0): <none>
[08:25:52.759] {
[08:25:52.759]     {
[08:25:52.759]         {
[08:25:52.759]             ...future.startTime <- base::Sys.time()
[08:25:52.759]             {
[08:25:52.759]                 {
[08:25:52.759]                   {
[08:25:52.759]                     {
[08:25:52.759]                       base::local({
[08:25:52.759]                         has_future <- base::requireNamespace("future", 
[08:25:52.759]                           quietly = TRUE)
[08:25:52.759]                         if (has_future) {
[08:25:52.759]                           ns <- base::getNamespace("future")
[08:25:52.759]                           version <- ns[[".package"]][["version"]]
[08:25:52.759]                           if (is.null(version)) 
[08:25:52.759]                             version <- utils::packageVersion("future")
[08:25:52.759]                         }
[08:25:52.759]                         else {
[08:25:52.759]                           version <- NULL
[08:25:52.759]                         }
[08:25:52.759]                         if (!has_future || version < "1.8.0") {
[08:25:52.759]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.759]                             "", base::R.version$version.string), 
[08:25:52.759]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.759]                               "release", "version")], collapse = " "), 
[08:25:52.759]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.759]                             info)
[08:25:52.759]                           info <- base::paste(info, collapse = "; ")
[08:25:52.759]                           if (!has_future) {
[08:25:52.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.759]                               info)
[08:25:52.759]                           }
[08:25:52.759]                           else {
[08:25:52.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.759]                               info, version)
[08:25:52.759]                           }
[08:25:52.759]                           base::stop(msg)
[08:25:52.759]                         }
[08:25:52.759]                       })
[08:25:52.759]                     }
[08:25:52.759]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.759]                     base::options(mc.cores = 1L)
[08:25:52.759]                   }
[08:25:52.759]                   ...future.strategy.old <- future::plan("list")
[08:25:52.759]                   options(future.plan = NULL)
[08:25:52.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.759]                 }
[08:25:52.759]                 ...future.workdir <- getwd()
[08:25:52.759]             }
[08:25:52.759]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.759]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.759]         }
[08:25:52.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.759]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:52.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.759]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.759]             base::names(...future.oldOptions))
[08:25:52.759]     }
[08:25:52.759]     if (FALSE) {
[08:25:52.759]     }
[08:25:52.759]     else {
[08:25:52.759]         if (TRUE) {
[08:25:52.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.759]                 open = "w")
[08:25:52.759]         }
[08:25:52.759]         else {
[08:25:52.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.759]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.759]         }
[08:25:52.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.759]             base::sink(type = "output", split = FALSE)
[08:25:52.759]             base::close(...future.stdout)
[08:25:52.759]         }, add = TRUE)
[08:25:52.759]     }
[08:25:52.759]     ...future.frame <- base::sys.nframe()
[08:25:52.759]     ...future.conditions <- base::list()
[08:25:52.759]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.759]     if (FALSE) {
[08:25:52.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.759]     }
[08:25:52.759]     ...future.result <- base::tryCatch({
[08:25:52.759]         base::withCallingHandlers({
[08:25:52.759]             ...future.value <- base::withVisible(base::local({
[08:25:52.759]                 ...future.makeSendCondition <- base::local({
[08:25:52.759]                   sendCondition <- NULL
[08:25:52.759]                   function(frame = 1L) {
[08:25:52.759]                     if (is.function(sendCondition)) 
[08:25:52.759]                       return(sendCondition)
[08:25:52.759]                     ns <- getNamespace("parallel")
[08:25:52.759]                     if (exists("sendData", mode = "function", 
[08:25:52.759]                       envir = ns)) {
[08:25:52.759]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.759]                         envir = ns)
[08:25:52.759]                       envir <- sys.frame(frame)
[08:25:52.759]                       master <- NULL
[08:25:52.759]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.759]                         !identical(envir, emptyenv())) {
[08:25:52.759]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.759]                           inherits = FALSE)) {
[08:25:52.759]                           master <- get("master", mode = "list", 
[08:25:52.759]                             envir = envir, inherits = FALSE)
[08:25:52.759]                           if (inherits(master, c("SOCKnode", 
[08:25:52.759]                             "SOCK0node"))) {
[08:25:52.759]                             sendCondition <<- function(cond) {
[08:25:52.759]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.759]                                 success = TRUE)
[08:25:52.759]                               parallel_sendData(master, data)
[08:25:52.759]                             }
[08:25:52.759]                             return(sendCondition)
[08:25:52.759]                           }
[08:25:52.759]                         }
[08:25:52.759]                         frame <- frame + 1L
[08:25:52.759]                         envir <- sys.frame(frame)
[08:25:52.759]                       }
[08:25:52.759]                     }
[08:25:52.759]                     sendCondition <<- function(cond) NULL
[08:25:52.759]                   }
[08:25:52.759]                 })
[08:25:52.759]                 withCallingHandlers({
[08:25:52.759]                   {
[08:25:52.759]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.759]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.759]                       ...future.globals.maxSize)) {
[08:25:52.759]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.759]                       on.exit(options(oopts), add = TRUE)
[08:25:52.759]                     }
[08:25:52.759]                     {
[08:25:52.759]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.759]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.759]                         USE.NAMES = FALSE)
[08:25:52.759]                       do.call(mapply, args = args)
[08:25:52.759]                     }
[08:25:52.759]                   }
[08:25:52.759]                 }, immediateCondition = function(cond) {
[08:25:52.759]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.759]                   sendCondition(cond)
[08:25:52.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.759]                   {
[08:25:52.759]                     inherits <- base::inherits
[08:25:52.759]                     invokeRestart <- base::invokeRestart
[08:25:52.759]                     is.null <- base::is.null
[08:25:52.759]                     muffled <- FALSE
[08:25:52.759]                     if (inherits(cond, "message")) {
[08:25:52.759]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.759]                       if (muffled) 
[08:25:52.759]                         invokeRestart("muffleMessage")
[08:25:52.759]                     }
[08:25:52.759]                     else if (inherits(cond, "warning")) {
[08:25:52.759]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.759]                       if (muffled) 
[08:25:52.759]                         invokeRestart("muffleWarning")
[08:25:52.759]                     }
[08:25:52.759]                     else if (inherits(cond, "condition")) {
[08:25:52.759]                       if (!is.null(pattern)) {
[08:25:52.759]                         computeRestarts <- base::computeRestarts
[08:25:52.759]                         grepl <- base::grepl
[08:25:52.759]                         restarts <- computeRestarts(cond)
[08:25:52.759]                         for (restart in restarts) {
[08:25:52.759]                           name <- restart$name
[08:25:52.759]                           if (is.null(name)) 
[08:25:52.759]                             next
[08:25:52.759]                           if (!grepl(pattern, name)) 
[08:25:52.759]                             next
[08:25:52.759]                           invokeRestart(restart)
[08:25:52.759]                           muffled <- TRUE
[08:25:52.759]                           break
[08:25:52.759]                         }
[08:25:52.759]                       }
[08:25:52.759]                     }
[08:25:52.759]                     invisible(muffled)
[08:25:52.759]                   }
[08:25:52.759]                   muffleCondition(cond)
[08:25:52.759]                 })
[08:25:52.759]             }))
[08:25:52.759]             future::FutureResult(value = ...future.value$value, 
[08:25:52.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.759]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.759]                     ...future.globalenv.names))
[08:25:52.759]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.759]         }, condition = base::local({
[08:25:52.759]             c <- base::c
[08:25:52.759]             inherits <- base::inherits
[08:25:52.759]             invokeRestart <- base::invokeRestart
[08:25:52.759]             length <- base::length
[08:25:52.759]             list <- base::list
[08:25:52.759]             seq.int <- base::seq.int
[08:25:52.759]             signalCondition <- base::signalCondition
[08:25:52.759]             sys.calls <- base::sys.calls
[08:25:52.759]             `[[` <- base::`[[`
[08:25:52.759]             `+` <- base::`+`
[08:25:52.759]             `<<-` <- base::`<<-`
[08:25:52.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.759]                   3L)]
[08:25:52.759]             }
[08:25:52.759]             function(cond) {
[08:25:52.759]                 is_error <- inherits(cond, "error")
[08:25:52.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.759]                   NULL)
[08:25:52.759]                 if (is_error) {
[08:25:52.759]                   sessionInformation <- function() {
[08:25:52.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.759]                       search = base::search(), system = base::Sys.info())
[08:25:52.759]                   }
[08:25:52.759]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.759]                     cond$call), session = sessionInformation(), 
[08:25:52.759]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.759]                   signalCondition(cond)
[08:25:52.759]                 }
[08:25:52.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.759]                 "immediateCondition"))) {
[08:25:52.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.759]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.759]                   if (TRUE && !signal) {
[08:25:52.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.759]                     {
[08:25:52.759]                       inherits <- base::inherits
[08:25:52.759]                       invokeRestart <- base::invokeRestart
[08:25:52.759]                       is.null <- base::is.null
[08:25:52.759]                       muffled <- FALSE
[08:25:52.759]                       if (inherits(cond, "message")) {
[08:25:52.759]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.759]                         if (muffled) 
[08:25:52.759]                           invokeRestart("muffleMessage")
[08:25:52.759]                       }
[08:25:52.759]                       else if (inherits(cond, "warning")) {
[08:25:52.759]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.759]                         if (muffled) 
[08:25:52.759]                           invokeRestart("muffleWarning")
[08:25:52.759]                       }
[08:25:52.759]                       else if (inherits(cond, "condition")) {
[08:25:52.759]                         if (!is.null(pattern)) {
[08:25:52.759]                           computeRestarts <- base::computeRestarts
[08:25:52.759]                           grepl <- base::grepl
[08:25:52.759]                           restarts <- computeRestarts(cond)
[08:25:52.759]                           for (restart in restarts) {
[08:25:52.759]                             name <- restart$name
[08:25:52.759]                             if (is.null(name)) 
[08:25:52.759]                               next
[08:25:52.759]                             if (!grepl(pattern, name)) 
[08:25:52.759]                               next
[08:25:52.759]                             invokeRestart(restart)
[08:25:52.759]                             muffled <- TRUE
[08:25:52.759]                             break
[08:25:52.759]                           }
[08:25:52.759]                         }
[08:25:52.759]                       }
[08:25:52.759]                       invisible(muffled)
[08:25:52.759]                     }
[08:25:52.759]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.759]                   }
[08:25:52.759]                 }
[08:25:52.759]                 else {
[08:25:52.759]                   if (TRUE) {
[08:25:52.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.759]                     {
[08:25:52.759]                       inherits <- base::inherits
[08:25:52.759]                       invokeRestart <- base::invokeRestart
[08:25:52.759]                       is.null <- base::is.null
[08:25:52.759]                       muffled <- FALSE
[08:25:52.759]                       if (inherits(cond, "message")) {
[08:25:52.759]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.759]                         if (muffled) 
[08:25:52.759]                           invokeRestart("muffleMessage")
[08:25:52.759]                       }
[08:25:52.759]                       else if (inherits(cond, "warning")) {
[08:25:52.759]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.759]                         if (muffled) 
[08:25:52.759]                           invokeRestart("muffleWarning")
[08:25:52.759]                       }
[08:25:52.759]                       else if (inherits(cond, "condition")) {
[08:25:52.759]                         if (!is.null(pattern)) {
[08:25:52.759]                           computeRestarts <- base::computeRestarts
[08:25:52.759]                           grepl <- base::grepl
[08:25:52.759]                           restarts <- computeRestarts(cond)
[08:25:52.759]                           for (restart in restarts) {
[08:25:52.759]                             name <- restart$name
[08:25:52.759]                             if (is.null(name)) 
[08:25:52.759]                               next
[08:25:52.759]                             if (!grepl(pattern, name)) 
[08:25:52.759]                               next
[08:25:52.759]                             invokeRestart(restart)
[08:25:52.759]                             muffled <- TRUE
[08:25:52.759]                             break
[08:25:52.759]                           }
[08:25:52.759]                         }
[08:25:52.759]                       }
[08:25:52.759]                       invisible(muffled)
[08:25:52.759]                     }
[08:25:52.759]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.759]                   }
[08:25:52.759]                 }
[08:25:52.759]             }
[08:25:52.759]         }))
[08:25:52.759]     }, error = function(ex) {
[08:25:52.759]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.759]                 ...future.rng), started = ...future.startTime, 
[08:25:52.759]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.759]             version = "1.8"), class = "FutureResult")
[08:25:52.759]     }, finally = {
[08:25:52.759]         if (!identical(...future.workdir, getwd())) 
[08:25:52.759]             setwd(...future.workdir)
[08:25:52.759]         {
[08:25:52.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.759]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.759]             }
[08:25:52.759]             base::options(...future.oldOptions)
[08:25:52.759]             if (.Platform$OS.type == "windows") {
[08:25:52.759]                 old_names <- names(...future.oldEnvVars)
[08:25:52.759]                 envs <- base::Sys.getenv()
[08:25:52.759]                 names <- names(envs)
[08:25:52.759]                 common <- intersect(names, old_names)
[08:25:52.759]                 added <- setdiff(names, old_names)
[08:25:52.759]                 removed <- setdiff(old_names, names)
[08:25:52.759]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.759]                   envs[common]]
[08:25:52.759]                 NAMES <- toupper(changed)
[08:25:52.759]                 args <- list()
[08:25:52.759]                 for (kk in seq_along(NAMES)) {
[08:25:52.759]                   name <- changed[[kk]]
[08:25:52.759]                   NAME <- NAMES[[kk]]
[08:25:52.759]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.759]                     next
[08:25:52.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.759]                 }
[08:25:52.759]                 NAMES <- toupper(added)
[08:25:52.759]                 for (kk in seq_along(NAMES)) {
[08:25:52.759]                   name <- added[[kk]]
[08:25:52.759]                   NAME <- NAMES[[kk]]
[08:25:52.759]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.759]                     next
[08:25:52.759]                   args[[name]] <- ""
[08:25:52.759]                 }
[08:25:52.759]                 NAMES <- toupper(removed)
[08:25:52.759]                 for (kk in seq_along(NAMES)) {
[08:25:52.759]                   name <- removed[[kk]]
[08:25:52.759]                   NAME <- NAMES[[kk]]
[08:25:52.759]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.759]                     next
[08:25:52.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.759]                 }
[08:25:52.759]                 if (length(args) > 0) 
[08:25:52.759]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.759]             }
[08:25:52.759]             else {
[08:25:52.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.759]             }
[08:25:52.759]             {
[08:25:52.759]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.759]                   0L) {
[08:25:52.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.759]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.759]                   base::options(opts)
[08:25:52.759]                 }
[08:25:52.759]                 {
[08:25:52.759]                   {
[08:25:52.759]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.759]                     NULL
[08:25:52.759]                   }
[08:25:52.759]                   options(future.plan = NULL)
[08:25:52.759]                   if (is.na(NA_character_)) 
[08:25:52.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.759]                     .init = FALSE)
[08:25:52.759]                 }
[08:25:52.759]             }
[08:25:52.759]         }
[08:25:52.759]     })
[08:25:52.759]     if (TRUE) {
[08:25:52.759]         base::sink(type = "output", split = FALSE)
[08:25:52.759]         if (TRUE) {
[08:25:52.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.759]         }
[08:25:52.759]         else {
[08:25:52.759]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.759]         }
[08:25:52.759]         base::close(...future.stdout)
[08:25:52.759]         ...future.stdout <- NULL
[08:25:52.759]     }
[08:25:52.759]     ...future.result$conditions <- ...future.conditions
[08:25:52.759]     ...future.result$finished <- base::Sys.time()
[08:25:52.759]     ...future.result
[08:25:52.759] }
[08:25:52.762] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[08:25:52.762] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[08:25:52.763] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[08:25:52.763] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[08:25:52.763] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[08:25:52.763] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[08:25:52.764] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[08:25:52.764] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:52.764] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.764] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:52.765] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.765] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[08:25:52.765] MultisessionFuture started
[08:25:52.765] - Launch lazy future ... done
[08:25:52.766] run() for ‘MultisessionFuture’ ... done
[08:25:52.766] Created future:
[08:25:52.766] MultisessionFuture:
[08:25:52.766] Label: ‘future_.mapply-1’
[08:25:52.766] Expression:
[08:25:52.766] {
[08:25:52.766]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.766]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.766]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.766]         on.exit(options(oopts), add = TRUE)
[08:25:52.766]     }
[08:25:52.766]     {
[08:25:52.766]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.766]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.766]         do.call(mapply, args = args)
[08:25:52.766]     }
[08:25:52.766] }
[08:25:52.766] Lazy evaluation: FALSE
[08:25:52.766] Asynchronous evaluation: TRUE
[08:25:52.766] Local evaluation: TRUE
[08:25:52.766] Environment: R_GlobalEnv
[08:25:52.766] Capture standard output: TRUE
[08:25:52.766] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.766] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.766] Packages: <none>
[08:25:52.766] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.766] Resolved: FALSE
[08:25:52.766] Value: <not collected>
[08:25:52.766] Conditions captured: <none>
[08:25:52.766] Early signaling: FALSE
[08:25:52.766] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.766] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.777] Chunk #1 of 2 ... DONE
[08:25:52.777] Chunk #2 of 2 ...
[08:25:52.777]  - Finding globals in '...' for chunk #2 ...
[08:25:52.778] getGlobalsAndPackages() ...
[08:25:52.778] Searching for globals...
[08:25:52.778] 
[08:25:52.778] Searching for globals ... DONE
[08:25:52.778] - globals: [0] <none>
[08:25:52.778] getGlobalsAndPackages() ... DONE
[08:25:52.778]    + additional globals found: [n=0] 
[08:25:52.778]    + additional namespaces needed: [n=0] 
[08:25:52.778]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:52.779]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:52.779]  - seeds: <none>
[08:25:52.779]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.779] getGlobalsAndPackages() ...
[08:25:52.779] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.779] Resolving globals: FALSE
[08:25:52.779] The total size of the 5 globals is 909 bytes (909 bytes)
[08:25:52.780] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:52.780] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.780] 
[08:25:52.780] getGlobalsAndPackages() ... DONE
[08:25:52.781] run() for ‘Future’ ...
[08:25:52.781] - state: ‘created’
[08:25:52.781] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.795] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.796]   - Field: ‘node’
[08:25:52.796]   - Field: ‘label’
[08:25:52.796]   - Field: ‘local’
[08:25:52.796]   - Field: ‘owner’
[08:25:52.796]   - Field: ‘envir’
[08:25:52.796]   - Field: ‘workers’
[08:25:52.796]   - Field: ‘packages’
[08:25:52.796]   - Field: ‘gc’
[08:25:52.796]   - Field: ‘conditions’
[08:25:52.797]   - Field: ‘persistent’
[08:25:52.797]   - Field: ‘expr’
[08:25:52.797]   - Field: ‘uuid’
[08:25:52.797]   - Field: ‘seed’
[08:25:52.797]   - Field: ‘version’
[08:25:52.797]   - Field: ‘result’
[08:25:52.797]   - Field: ‘asynchronous’
[08:25:52.797]   - Field: ‘calls’
[08:25:52.797]   - Field: ‘globals’
[08:25:52.797]   - Field: ‘stdout’
[08:25:52.797]   - Field: ‘earlySignal’
[08:25:52.797]   - Field: ‘lazy’
[08:25:52.798]   - Field: ‘state’
[08:25:52.798] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.798] - Launch lazy future ...
[08:25:52.798] Packages needed by the future expression (n = 0): <none>
[08:25:52.798] Packages needed by future strategies (n = 0): <none>
[08:25:52.799] {
[08:25:52.799]     {
[08:25:52.799]         {
[08:25:52.799]             ...future.startTime <- base::Sys.time()
[08:25:52.799]             {
[08:25:52.799]                 {
[08:25:52.799]                   {
[08:25:52.799]                     {
[08:25:52.799]                       base::local({
[08:25:52.799]                         has_future <- base::requireNamespace("future", 
[08:25:52.799]                           quietly = TRUE)
[08:25:52.799]                         if (has_future) {
[08:25:52.799]                           ns <- base::getNamespace("future")
[08:25:52.799]                           version <- ns[[".package"]][["version"]]
[08:25:52.799]                           if (is.null(version)) 
[08:25:52.799]                             version <- utils::packageVersion("future")
[08:25:52.799]                         }
[08:25:52.799]                         else {
[08:25:52.799]                           version <- NULL
[08:25:52.799]                         }
[08:25:52.799]                         if (!has_future || version < "1.8.0") {
[08:25:52.799]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.799]                             "", base::R.version$version.string), 
[08:25:52.799]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.799]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.799]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.799]                               "release", "version")], collapse = " "), 
[08:25:52.799]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.799]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.799]                             info)
[08:25:52.799]                           info <- base::paste(info, collapse = "; ")
[08:25:52.799]                           if (!has_future) {
[08:25:52.799]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.799]                               info)
[08:25:52.799]                           }
[08:25:52.799]                           else {
[08:25:52.799]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.799]                               info, version)
[08:25:52.799]                           }
[08:25:52.799]                           base::stop(msg)
[08:25:52.799]                         }
[08:25:52.799]                       })
[08:25:52.799]                     }
[08:25:52.799]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.799]                     base::options(mc.cores = 1L)
[08:25:52.799]                   }
[08:25:52.799]                   ...future.strategy.old <- future::plan("list")
[08:25:52.799]                   options(future.plan = NULL)
[08:25:52.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.799]                 }
[08:25:52.799]                 ...future.workdir <- getwd()
[08:25:52.799]             }
[08:25:52.799]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.799]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.799]         }
[08:25:52.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.799]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:52.799]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.799]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.799]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.799]             base::names(...future.oldOptions))
[08:25:52.799]     }
[08:25:52.799]     if (FALSE) {
[08:25:52.799]     }
[08:25:52.799]     else {
[08:25:52.799]         if (TRUE) {
[08:25:52.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.799]                 open = "w")
[08:25:52.799]         }
[08:25:52.799]         else {
[08:25:52.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.799]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.799]         }
[08:25:52.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.799]             base::sink(type = "output", split = FALSE)
[08:25:52.799]             base::close(...future.stdout)
[08:25:52.799]         }, add = TRUE)
[08:25:52.799]     }
[08:25:52.799]     ...future.frame <- base::sys.nframe()
[08:25:52.799]     ...future.conditions <- base::list()
[08:25:52.799]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.799]     if (FALSE) {
[08:25:52.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.799]     }
[08:25:52.799]     ...future.result <- base::tryCatch({
[08:25:52.799]         base::withCallingHandlers({
[08:25:52.799]             ...future.value <- base::withVisible(base::local({
[08:25:52.799]                 ...future.makeSendCondition <- base::local({
[08:25:52.799]                   sendCondition <- NULL
[08:25:52.799]                   function(frame = 1L) {
[08:25:52.799]                     if (is.function(sendCondition)) 
[08:25:52.799]                       return(sendCondition)
[08:25:52.799]                     ns <- getNamespace("parallel")
[08:25:52.799]                     if (exists("sendData", mode = "function", 
[08:25:52.799]                       envir = ns)) {
[08:25:52.799]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.799]                         envir = ns)
[08:25:52.799]                       envir <- sys.frame(frame)
[08:25:52.799]                       master <- NULL
[08:25:52.799]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.799]                         !identical(envir, emptyenv())) {
[08:25:52.799]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.799]                           inherits = FALSE)) {
[08:25:52.799]                           master <- get("master", mode = "list", 
[08:25:52.799]                             envir = envir, inherits = FALSE)
[08:25:52.799]                           if (inherits(master, c("SOCKnode", 
[08:25:52.799]                             "SOCK0node"))) {
[08:25:52.799]                             sendCondition <<- function(cond) {
[08:25:52.799]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.799]                                 success = TRUE)
[08:25:52.799]                               parallel_sendData(master, data)
[08:25:52.799]                             }
[08:25:52.799]                             return(sendCondition)
[08:25:52.799]                           }
[08:25:52.799]                         }
[08:25:52.799]                         frame <- frame + 1L
[08:25:52.799]                         envir <- sys.frame(frame)
[08:25:52.799]                       }
[08:25:52.799]                     }
[08:25:52.799]                     sendCondition <<- function(cond) NULL
[08:25:52.799]                   }
[08:25:52.799]                 })
[08:25:52.799]                 withCallingHandlers({
[08:25:52.799]                   {
[08:25:52.799]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.799]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.799]                       ...future.globals.maxSize)) {
[08:25:52.799]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.799]                       on.exit(options(oopts), add = TRUE)
[08:25:52.799]                     }
[08:25:52.799]                     {
[08:25:52.799]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.799]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.799]                         USE.NAMES = FALSE)
[08:25:52.799]                       do.call(mapply, args = args)
[08:25:52.799]                     }
[08:25:52.799]                   }
[08:25:52.799]                 }, immediateCondition = function(cond) {
[08:25:52.799]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.799]                   sendCondition(cond)
[08:25:52.799]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.799]                   {
[08:25:52.799]                     inherits <- base::inherits
[08:25:52.799]                     invokeRestart <- base::invokeRestart
[08:25:52.799]                     is.null <- base::is.null
[08:25:52.799]                     muffled <- FALSE
[08:25:52.799]                     if (inherits(cond, "message")) {
[08:25:52.799]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.799]                       if (muffled) 
[08:25:52.799]                         invokeRestart("muffleMessage")
[08:25:52.799]                     }
[08:25:52.799]                     else if (inherits(cond, "warning")) {
[08:25:52.799]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.799]                       if (muffled) 
[08:25:52.799]                         invokeRestart("muffleWarning")
[08:25:52.799]                     }
[08:25:52.799]                     else if (inherits(cond, "condition")) {
[08:25:52.799]                       if (!is.null(pattern)) {
[08:25:52.799]                         computeRestarts <- base::computeRestarts
[08:25:52.799]                         grepl <- base::grepl
[08:25:52.799]                         restarts <- computeRestarts(cond)
[08:25:52.799]                         for (restart in restarts) {
[08:25:52.799]                           name <- restart$name
[08:25:52.799]                           if (is.null(name)) 
[08:25:52.799]                             next
[08:25:52.799]                           if (!grepl(pattern, name)) 
[08:25:52.799]                             next
[08:25:52.799]                           invokeRestart(restart)
[08:25:52.799]                           muffled <- TRUE
[08:25:52.799]                           break
[08:25:52.799]                         }
[08:25:52.799]                       }
[08:25:52.799]                     }
[08:25:52.799]                     invisible(muffled)
[08:25:52.799]                   }
[08:25:52.799]                   muffleCondition(cond)
[08:25:52.799]                 })
[08:25:52.799]             }))
[08:25:52.799]             future::FutureResult(value = ...future.value$value, 
[08:25:52.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.799]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.799]                     ...future.globalenv.names))
[08:25:52.799]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.799]         }, condition = base::local({
[08:25:52.799]             c <- base::c
[08:25:52.799]             inherits <- base::inherits
[08:25:52.799]             invokeRestart <- base::invokeRestart
[08:25:52.799]             length <- base::length
[08:25:52.799]             list <- base::list
[08:25:52.799]             seq.int <- base::seq.int
[08:25:52.799]             signalCondition <- base::signalCondition
[08:25:52.799]             sys.calls <- base::sys.calls
[08:25:52.799]             `[[` <- base::`[[`
[08:25:52.799]             `+` <- base::`+`
[08:25:52.799]             `<<-` <- base::`<<-`
[08:25:52.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.799]                   3L)]
[08:25:52.799]             }
[08:25:52.799]             function(cond) {
[08:25:52.799]                 is_error <- inherits(cond, "error")
[08:25:52.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.799]                   NULL)
[08:25:52.799]                 if (is_error) {
[08:25:52.799]                   sessionInformation <- function() {
[08:25:52.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.799]                       search = base::search(), system = base::Sys.info())
[08:25:52.799]                   }
[08:25:52.799]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.799]                     cond$call), session = sessionInformation(), 
[08:25:52.799]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.799]                   signalCondition(cond)
[08:25:52.799]                 }
[08:25:52.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.799]                 "immediateCondition"))) {
[08:25:52.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.799]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.799]                   if (TRUE && !signal) {
[08:25:52.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.799]                     {
[08:25:52.799]                       inherits <- base::inherits
[08:25:52.799]                       invokeRestart <- base::invokeRestart
[08:25:52.799]                       is.null <- base::is.null
[08:25:52.799]                       muffled <- FALSE
[08:25:52.799]                       if (inherits(cond, "message")) {
[08:25:52.799]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.799]                         if (muffled) 
[08:25:52.799]                           invokeRestart("muffleMessage")
[08:25:52.799]                       }
[08:25:52.799]                       else if (inherits(cond, "warning")) {
[08:25:52.799]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.799]                         if (muffled) 
[08:25:52.799]                           invokeRestart("muffleWarning")
[08:25:52.799]                       }
[08:25:52.799]                       else if (inherits(cond, "condition")) {
[08:25:52.799]                         if (!is.null(pattern)) {
[08:25:52.799]                           computeRestarts <- base::computeRestarts
[08:25:52.799]                           grepl <- base::grepl
[08:25:52.799]                           restarts <- computeRestarts(cond)
[08:25:52.799]                           for (restart in restarts) {
[08:25:52.799]                             name <- restart$name
[08:25:52.799]                             if (is.null(name)) 
[08:25:52.799]                               next
[08:25:52.799]                             if (!grepl(pattern, name)) 
[08:25:52.799]                               next
[08:25:52.799]                             invokeRestart(restart)
[08:25:52.799]                             muffled <- TRUE
[08:25:52.799]                             break
[08:25:52.799]                           }
[08:25:52.799]                         }
[08:25:52.799]                       }
[08:25:52.799]                       invisible(muffled)
[08:25:52.799]                     }
[08:25:52.799]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.799]                   }
[08:25:52.799]                 }
[08:25:52.799]                 else {
[08:25:52.799]                   if (TRUE) {
[08:25:52.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.799]                     {
[08:25:52.799]                       inherits <- base::inherits
[08:25:52.799]                       invokeRestart <- base::invokeRestart
[08:25:52.799]                       is.null <- base::is.null
[08:25:52.799]                       muffled <- FALSE
[08:25:52.799]                       if (inherits(cond, "message")) {
[08:25:52.799]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.799]                         if (muffled) 
[08:25:52.799]                           invokeRestart("muffleMessage")
[08:25:52.799]                       }
[08:25:52.799]                       else if (inherits(cond, "warning")) {
[08:25:52.799]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.799]                         if (muffled) 
[08:25:52.799]                           invokeRestart("muffleWarning")
[08:25:52.799]                       }
[08:25:52.799]                       else if (inherits(cond, "condition")) {
[08:25:52.799]                         if (!is.null(pattern)) {
[08:25:52.799]                           computeRestarts <- base::computeRestarts
[08:25:52.799]                           grepl <- base::grepl
[08:25:52.799]                           restarts <- computeRestarts(cond)
[08:25:52.799]                           for (restart in restarts) {
[08:25:52.799]                             name <- restart$name
[08:25:52.799]                             if (is.null(name)) 
[08:25:52.799]                               next
[08:25:52.799]                             if (!grepl(pattern, name)) 
[08:25:52.799]                               next
[08:25:52.799]                             invokeRestart(restart)
[08:25:52.799]                             muffled <- TRUE
[08:25:52.799]                             break
[08:25:52.799]                           }
[08:25:52.799]                         }
[08:25:52.799]                       }
[08:25:52.799]                       invisible(muffled)
[08:25:52.799]                     }
[08:25:52.799]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.799]                   }
[08:25:52.799]                 }
[08:25:52.799]             }
[08:25:52.799]         }))
[08:25:52.799]     }, error = function(ex) {
[08:25:52.799]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.799]                 ...future.rng), started = ...future.startTime, 
[08:25:52.799]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.799]             version = "1.8"), class = "FutureResult")
[08:25:52.799]     }, finally = {
[08:25:52.799]         if (!identical(...future.workdir, getwd())) 
[08:25:52.799]             setwd(...future.workdir)
[08:25:52.799]         {
[08:25:52.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.799]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.799]             }
[08:25:52.799]             base::options(...future.oldOptions)
[08:25:52.799]             if (.Platform$OS.type == "windows") {
[08:25:52.799]                 old_names <- names(...future.oldEnvVars)
[08:25:52.799]                 envs <- base::Sys.getenv()
[08:25:52.799]                 names <- names(envs)
[08:25:52.799]                 common <- intersect(names, old_names)
[08:25:52.799]                 added <- setdiff(names, old_names)
[08:25:52.799]                 removed <- setdiff(old_names, names)
[08:25:52.799]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.799]                   envs[common]]
[08:25:52.799]                 NAMES <- toupper(changed)
[08:25:52.799]                 args <- list()
[08:25:52.799]                 for (kk in seq_along(NAMES)) {
[08:25:52.799]                   name <- changed[[kk]]
[08:25:52.799]                   NAME <- NAMES[[kk]]
[08:25:52.799]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.799]                     next
[08:25:52.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.799]                 }
[08:25:52.799]                 NAMES <- toupper(added)
[08:25:52.799]                 for (kk in seq_along(NAMES)) {
[08:25:52.799]                   name <- added[[kk]]
[08:25:52.799]                   NAME <- NAMES[[kk]]
[08:25:52.799]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.799]                     next
[08:25:52.799]                   args[[name]] <- ""
[08:25:52.799]                 }
[08:25:52.799]                 NAMES <- toupper(removed)
[08:25:52.799]                 for (kk in seq_along(NAMES)) {
[08:25:52.799]                   name <- removed[[kk]]
[08:25:52.799]                   NAME <- NAMES[[kk]]
[08:25:52.799]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.799]                     next
[08:25:52.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.799]                 }
[08:25:52.799]                 if (length(args) > 0) 
[08:25:52.799]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.799]             }
[08:25:52.799]             else {
[08:25:52.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.799]             }
[08:25:52.799]             {
[08:25:52.799]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.799]                   0L) {
[08:25:52.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.799]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.799]                   base::options(opts)
[08:25:52.799]                 }
[08:25:52.799]                 {
[08:25:52.799]                   {
[08:25:52.799]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.799]                     NULL
[08:25:52.799]                   }
[08:25:52.799]                   options(future.plan = NULL)
[08:25:52.799]                   if (is.na(NA_character_)) 
[08:25:52.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.799]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.799]                     .init = FALSE)
[08:25:52.799]                 }
[08:25:52.799]             }
[08:25:52.799]         }
[08:25:52.799]     })
[08:25:52.799]     if (TRUE) {
[08:25:52.799]         base::sink(type = "output", split = FALSE)
[08:25:52.799]         if (TRUE) {
[08:25:52.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.799]         }
[08:25:52.799]         else {
[08:25:52.799]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.799]         }
[08:25:52.799]         base::close(...future.stdout)
[08:25:52.799]         ...future.stdout <- NULL
[08:25:52.799]     }
[08:25:52.799]     ...future.result$conditions <- ...future.conditions
[08:25:52.799]     ...future.result$finished <- base::Sys.time()
[08:25:52.799]     ...future.result
[08:25:52.799] }
[08:25:52.802] Exporting 5 global objects (1.33 KiB) to cluster node #2 ...
[08:25:52.802] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[08:25:52.802] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[08:25:52.802] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[08:25:52.803] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[08:25:52.803] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[08:25:52.803] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[08:25:52.803] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:52.804] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.804] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:52.804] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.804] Exporting 5 global objects (1.33 KiB) to cluster node #2 ... DONE
[08:25:52.805] MultisessionFuture started
[08:25:52.805] - Launch lazy future ... done
[08:25:52.805] run() for ‘MultisessionFuture’ ... done
[08:25:52.805] Created future:
[08:25:52.805] MultisessionFuture:
[08:25:52.805] Label: ‘future_.mapply-2’
[08:25:52.805] Expression:
[08:25:52.805] {
[08:25:52.805]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.805]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.805]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.805]         on.exit(options(oopts), add = TRUE)
[08:25:52.805]     }
[08:25:52.805]     {
[08:25:52.805]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.805]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.805]         do.call(mapply, args = args)
[08:25:52.805]     }
[08:25:52.805] }
[08:25:52.805] Lazy evaluation: FALSE
[08:25:52.805] Asynchronous evaluation: TRUE
[08:25:52.805] Local evaluation: TRUE
[08:25:52.805] Environment: R_GlobalEnv
[08:25:52.805] Capture standard output: TRUE
[08:25:52.805] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.805] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.805] Packages: <none>
[08:25:52.805] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.805] Resolved: FALSE
[08:25:52.805] Value: <not collected>
[08:25:52.805] Conditions captured: <none>
[08:25:52.805] Early signaling: FALSE
[08:25:52.805] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.805] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.817] Chunk #2 of 2 ... DONE
[08:25:52.817] Launching 2 futures (chunks) ... DONE
[08:25:52.817] Resolving 2 futures (chunks) ...
[08:25:52.817] resolve() on list ...
[08:25:52.817]  recursive: 0
[08:25:52.818]  length: 2
[08:25:52.818] 
[08:25:52.818] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.818] - Validating connection of MultisessionFuture
[08:25:52.819] - received message: FutureResult
[08:25:52.819] - Received FutureResult
[08:25:52.819] - Erased future from FutureRegistry
[08:25:52.819] result() for ClusterFuture ...
[08:25:52.819] - result already collected: FutureResult
[08:25:52.819] result() for ClusterFuture ... done
[08:25:52.819] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.819] Future #1
[08:25:52.819] result() for ClusterFuture ...
[08:25:52.819] - result already collected: FutureResult
[08:25:52.819] result() for ClusterFuture ... done
[08:25:52.820] result() for ClusterFuture ...
[08:25:52.820] - result already collected: FutureResult
[08:25:52.820] result() for ClusterFuture ... done
[08:25:52.820] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:52.820] - nx: 2
[08:25:52.820] - relay: TRUE
[08:25:52.820] - stdout: TRUE
[08:25:52.820] - signal: TRUE
[08:25:52.820] - resignal: FALSE
[08:25:52.820] - force: TRUE
[08:25:52.820] - relayed: [n=2] FALSE, FALSE
[08:25:52.820] - queued futures: [n=2] FALSE, FALSE
[08:25:52.821]  - until=1
[08:25:52.821]  - relaying element #1
[08:25:52.821] result() for ClusterFuture ...
[08:25:52.821] - result already collected: FutureResult
[08:25:52.821] result() for ClusterFuture ... done
[08:25:52.821] result() for ClusterFuture ...
[08:25:52.821] - result already collected: FutureResult
[08:25:52.821] result() for ClusterFuture ... done
[08:25:52.821] result() for ClusterFuture ...
[08:25:52.821] - result already collected: FutureResult
[08:25:52.821] result() for ClusterFuture ... done
[08:25:52.821] result() for ClusterFuture ...
[08:25:52.822] - result already collected: FutureResult
[08:25:52.822] result() for ClusterFuture ... done
[08:25:52.822] - relayed: [n=2] TRUE, FALSE
[08:25:52.822] - queued futures: [n=2] TRUE, FALSE
[08:25:52.822] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:52.822]  length: 1 (resolved future 1)
[08:25:52.847] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.847] - Validating connection of MultisessionFuture
[08:25:52.848] - received message: FutureResult
[08:25:52.848] - Received FutureResult
[08:25:52.848] - Erased future from FutureRegistry
[08:25:52.848] result() for ClusterFuture ...
[08:25:52.848] - result already collected: FutureResult
[08:25:52.848] result() for ClusterFuture ... done
[08:25:52.848] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.848] Future #2
[08:25:52.848] result() for ClusterFuture ...
[08:25:52.849] - result already collected: FutureResult
[08:25:52.849] result() for ClusterFuture ... done
[08:25:52.849] result() for ClusterFuture ...
[08:25:52.849] - result already collected: FutureResult
[08:25:52.849] result() for ClusterFuture ... done
[08:25:52.849] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:52.849] - nx: 2
[08:25:52.849] - relay: TRUE
[08:25:52.849] - stdout: TRUE
[08:25:52.849] - signal: TRUE
[08:25:52.849] - resignal: FALSE
[08:25:52.849] - force: TRUE
[08:25:52.850] - relayed: [n=2] TRUE, FALSE
[08:25:52.850] - queued futures: [n=2] TRUE, FALSE
[08:25:52.850]  - until=2
[08:25:52.850]  - relaying element #2
[08:25:52.850] result() for ClusterFuture ...
[08:25:52.850] - result already collected: FutureResult
[08:25:52.850] result() for ClusterFuture ... done
[08:25:52.850] result() for ClusterFuture ...
[08:25:52.850] - result already collected: FutureResult
[08:25:52.850] result() for ClusterFuture ... done
[08:25:52.850] result() for ClusterFuture ...
[08:25:52.850] - result already collected: FutureResult
[08:25:52.851] result() for ClusterFuture ... done
[08:25:52.851] result() for ClusterFuture ...
[08:25:52.851] - result already collected: FutureResult
[08:25:52.851] result() for ClusterFuture ... done
[08:25:52.851] - relayed: [n=2] TRUE, TRUE
[08:25:52.851] - queued futures: [n=2] TRUE, TRUE
[08:25:52.851] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:52.851]  length: 0 (resolved future 2)
[08:25:52.851] Relaying remaining futures
[08:25:52.851] signalConditionsASAP(NULL, pos=0) ...
[08:25:52.851] - nx: 2
[08:25:52.851] - relay: TRUE
[08:25:52.852] - stdout: TRUE
[08:25:52.852] - signal: TRUE
[08:25:52.852] - resignal: FALSE
[08:25:52.852] - force: TRUE
[08:25:52.852] - relayed: [n=2] TRUE, TRUE
[08:25:52.852] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:52.852] - relayed: [n=2] TRUE, TRUE
[08:25:52.852] - queued futures: [n=2] TRUE, TRUE
[08:25:52.852] signalConditionsASAP(NULL, pos=0) ... done
[08:25:52.852] resolve() on list ... DONE
[08:25:52.852] result() for ClusterFuture ...
[08:25:52.852] - result already collected: FutureResult
[08:25:52.853] result() for ClusterFuture ... done
[08:25:52.853] result() for ClusterFuture ...
[08:25:52.853] - result already collected: FutureResult
[08:25:52.853] result() for ClusterFuture ... done
[08:25:52.853] result() for ClusterFuture ...
[08:25:52.853] - result already collected: FutureResult
[08:25:52.853] result() for ClusterFuture ... done
[08:25:52.853] result() for ClusterFuture ...
[08:25:52.853] - result already collected: FutureResult
[08:25:52.853] result() for ClusterFuture ... done
[08:25:52.853]  - Number of value chunks collected: 2
[08:25:52.854] Resolving 2 futures (chunks) ... DONE
[08:25:52.854] Reducing values from 2 chunks ...
[08:25:52.854]  - Number of values collected after concatenation: 5
[08:25:52.854]  - Number of values expected: 5
[08:25:52.854] Reducing values from 2 chunks ... DONE
[08:25:52.854] future_mapply() ... DONE
[08:25:52.854] future_mapply() ...
[08:25:52.856] Number of chunks: 2
[08:25:52.856] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[08:25:52.856] getGlobalsAndPackagesXApply() ...
[08:25:52.856]  - future.globals: TRUE
[08:25:52.856] getGlobalsAndPackages() ...
[08:25:52.857] Searching for globals...
[08:25:52.858] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:52.858] Searching for globals ... DONE
[08:25:52.858] Resolving globals: FALSE
[08:25:52.858] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:52.859] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:52.859] - globals: [1] ‘FUN’
[08:25:52.859] 
[08:25:52.859] getGlobalsAndPackages() ... DONE
[08:25:52.859]  - globals found/used: [n=1] ‘FUN’
[08:25:52.859]  - needed namespaces: [n=0] 
[08:25:52.859] Finding globals ... DONE
[08:25:52.860] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:52.860] List of 2
[08:25:52.860]  $ ...future.FUN:function (C, k)  
[08:25:52.860]  $ MoreArgs     : NULL
[08:25:52.860]  - attr(*, "where")=List of 2
[08:25:52.860]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:52.860]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:52.860]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:52.860]  - attr(*, "resolved")= logi FALSE
[08:25:52.860]  - attr(*, "total_size")= num NA
[08:25:52.862] Packages to be attached in all futures: [n=0] 
[08:25:52.862] getGlobalsAndPackagesXApply() ... DONE
[08:25:52.862] Number of futures (= number of chunks): 2
[08:25:52.862] Launching 2 futures (chunks) ...
[08:25:52.863] Chunk #1 of 2 ...
[08:25:52.863]  - Finding globals in '...' for chunk #1 ...
[08:25:52.863] getGlobalsAndPackages() ...
[08:25:52.863] Searching for globals...
[08:25:52.863] 
[08:25:52.863] Searching for globals ... DONE
[08:25:52.863] - globals: [0] <none>
[08:25:52.863] getGlobalsAndPackages() ... DONE
[08:25:52.863]    + additional globals found: [n=0] 
[08:25:52.864]    + additional namespaces needed: [n=0] 
[08:25:52.864]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:52.864]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:52.864]  - seeds: <none>
[08:25:52.864]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.864] getGlobalsAndPackages() ...
[08:25:52.864] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.864] Resolving globals: FALSE
[08:25:52.865] The total size of the 5 globals is 876 bytes (876 bytes)
[08:25:52.865] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 876 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:52.865] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.865] 
[08:25:52.865] getGlobalsAndPackages() ... DONE
[08:25:52.866] run() for ‘Future’ ...
[08:25:52.866] - state: ‘created’
[08:25:52.866] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.880] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.880] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.880]   - Field: ‘node’
[08:25:52.880]   - Field: ‘label’
[08:25:52.880]   - Field: ‘local’
[08:25:52.880]   - Field: ‘owner’
[08:25:52.881]   - Field: ‘envir’
[08:25:52.881]   - Field: ‘workers’
[08:25:52.881]   - Field: ‘packages’
[08:25:52.881]   - Field: ‘gc’
[08:25:52.881]   - Field: ‘conditions’
[08:25:52.881]   - Field: ‘persistent’
[08:25:52.881]   - Field: ‘expr’
[08:25:52.881]   - Field: ‘uuid’
[08:25:52.881]   - Field: ‘seed’
[08:25:52.881]   - Field: ‘version’
[08:25:52.881]   - Field: ‘result’
[08:25:52.882]   - Field: ‘asynchronous’
[08:25:52.882]   - Field: ‘calls’
[08:25:52.882]   - Field: ‘globals’
[08:25:52.882]   - Field: ‘stdout’
[08:25:52.882]   - Field: ‘earlySignal’
[08:25:52.882]   - Field: ‘lazy’
[08:25:52.882]   - Field: ‘state’
[08:25:52.882] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.882] - Launch lazy future ...
[08:25:52.883] Packages needed by the future expression (n = 0): <none>
[08:25:52.883] Packages needed by future strategies (n = 0): <none>
[08:25:52.883] {
[08:25:52.883]     {
[08:25:52.883]         {
[08:25:52.883]             ...future.startTime <- base::Sys.time()
[08:25:52.883]             {
[08:25:52.883]                 {
[08:25:52.883]                   {
[08:25:52.883]                     {
[08:25:52.883]                       base::local({
[08:25:52.883]                         has_future <- base::requireNamespace("future", 
[08:25:52.883]                           quietly = TRUE)
[08:25:52.883]                         if (has_future) {
[08:25:52.883]                           ns <- base::getNamespace("future")
[08:25:52.883]                           version <- ns[[".package"]][["version"]]
[08:25:52.883]                           if (is.null(version)) 
[08:25:52.883]                             version <- utils::packageVersion("future")
[08:25:52.883]                         }
[08:25:52.883]                         else {
[08:25:52.883]                           version <- NULL
[08:25:52.883]                         }
[08:25:52.883]                         if (!has_future || version < "1.8.0") {
[08:25:52.883]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.883]                             "", base::R.version$version.string), 
[08:25:52.883]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.883]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.883]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.883]                               "release", "version")], collapse = " "), 
[08:25:52.883]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.883]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.883]                             info)
[08:25:52.883]                           info <- base::paste(info, collapse = "; ")
[08:25:52.883]                           if (!has_future) {
[08:25:52.883]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.883]                               info)
[08:25:52.883]                           }
[08:25:52.883]                           else {
[08:25:52.883]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.883]                               info, version)
[08:25:52.883]                           }
[08:25:52.883]                           base::stop(msg)
[08:25:52.883]                         }
[08:25:52.883]                       })
[08:25:52.883]                     }
[08:25:52.883]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.883]                     base::options(mc.cores = 1L)
[08:25:52.883]                   }
[08:25:52.883]                   ...future.strategy.old <- future::plan("list")
[08:25:52.883]                   options(future.plan = NULL)
[08:25:52.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.883]                 }
[08:25:52.883]                 ...future.workdir <- getwd()
[08:25:52.883]             }
[08:25:52.883]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.883]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.883]         }
[08:25:52.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.883]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:52.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.883]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.883]             base::names(...future.oldOptions))
[08:25:52.883]     }
[08:25:52.883]     if (FALSE) {
[08:25:52.883]     }
[08:25:52.883]     else {
[08:25:52.883]         if (TRUE) {
[08:25:52.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.883]                 open = "w")
[08:25:52.883]         }
[08:25:52.883]         else {
[08:25:52.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.883]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.883]         }
[08:25:52.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.883]             base::sink(type = "output", split = FALSE)
[08:25:52.883]             base::close(...future.stdout)
[08:25:52.883]         }, add = TRUE)
[08:25:52.883]     }
[08:25:52.883]     ...future.frame <- base::sys.nframe()
[08:25:52.883]     ...future.conditions <- base::list()
[08:25:52.883]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.883]     if (FALSE) {
[08:25:52.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.883]     }
[08:25:52.883]     ...future.result <- base::tryCatch({
[08:25:52.883]         base::withCallingHandlers({
[08:25:52.883]             ...future.value <- base::withVisible(base::local({
[08:25:52.883]                 ...future.makeSendCondition <- base::local({
[08:25:52.883]                   sendCondition <- NULL
[08:25:52.883]                   function(frame = 1L) {
[08:25:52.883]                     if (is.function(sendCondition)) 
[08:25:52.883]                       return(sendCondition)
[08:25:52.883]                     ns <- getNamespace("parallel")
[08:25:52.883]                     if (exists("sendData", mode = "function", 
[08:25:52.883]                       envir = ns)) {
[08:25:52.883]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.883]                         envir = ns)
[08:25:52.883]                       envir <- sys.frame(frame)
[08:25:52.883]                       master <- NULL
[08:25:52.883]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.883]                         !identical(envir, emptyenv())) {
[08:25:52.883]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.883]                           inherits = FALSE)) {
[08:25:52.883]                           master <- get("master", mode = "list", 
[08:25:52.883]                             envir = envir, inherits = FALSE)
[08:25:52.883]                           if (inherits(master, c("SOCKnode", 
[08:25:52.883]                             "SOCK0node"))) {
[08:25:52.883]                             sendCondition <<- function(cond) {
[08:25:52.883]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.883]                                 success = TRUE)
[08:25:52.883]                               parallel_sendData(master, data)
[08:25:52.883]                             }
[08:25:52.883]                             return(sendCondition)
[08:25:52.883]                           }
[08:25:52.883]                         }
[08:25:52.883]                         frame <- frame + 1L
[08:25:52.883]                         envir <- sys.frame(frame)
[08:25:52.883]                       }
[08:25:52.883]                     }
[08:25:52.883]                     sendCondition <<- function(cond) NULL
[08:25:52.883]                   }
[08:25:52.883]                 })
[08:25:52.883]                 withCallingHandlers({
[08:25:52.883]                   {
[08:25:52.883]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.883]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.883]                       ...future.globals.maxSize)) {
[08:25:52.883]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.883]                       on.exit(options(oopts), add = TRUE)
[08:25:52.883]                     }
[08:25:52.883]                     {
[08:25:52.883]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.883]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.883]                         USE.NAMES = FALSE)
[08:25:52.883]                       do.call(mapply, args = args)
[08:25:52.883]                     }
[08:25:52.883]                   }
[08:25:52.883]                 }, immediateCondition = function(cond) {
[08:25:52.883]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.883]                   sendCondition(cond)
[08:25:52.883]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.883]                   {
[08:25:52.883]                     inherits <- base::inherits
[08:25:52.883]                     invokeRestart <- base::invokeRestart
[08:25:52.883]                     is.null <- base::is.null
[08:25:52.883]                     muffled <- FALSE
[08:25:52.883]                     if (inherits(cond, "message")) {
[08:25:52.883]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.883]                       if (muffled) 
[08:25:52.883]                         invokeRestart("muffleMessage")
[08:25:52.883]                     }
[08:25:52.883]                     else if (inherits(cond, "warning")) {
[08:25:52.883]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.883]                       if (muffled) 
[08:25:52.883]                         invokeRestart("muffleWarning")
[08:25:52.883]                     }
[08:25:52.883]                     else if (inherits(cond, "condition")) {
[08:25:52.883]                       if (!is.null(pattern)) {
[08:25:52.883]                         computeRestarts <- base::computeRestarts
[08:25:52.883]                         grepl <- base::grepl
[08:25:52.883]                         restarts <- computeRestarts(cond)
[08:25:52.883]                         for (restart in restarts) {
[08:25:52.883]                           name <- restart$name
[08:25:52.883]                           if (is.null(name)) 
[08:25:52.883]                             next
[08:25:52.883]                           if (!grepl(pattern, name)) 
[08:25:52.883]                             next
[08:25:52.883]                           invokeRestart(restart)
[08:25:52.883]                           muffled <- TRUE
[08:25:52.883]                           break
[08:25:52.883]                         }
[08:25:52.883]                       }
[08:25:52.883]                     }
[08:25:52.883]                     invisible(muffled)
[08:25:52.883]                   }
[08:25:52.883]                   muffleCondition(cond)
[08:25:52.883]                 })
[08:25:52.883]             }))
[08:25:52.883]             future::FutureResult(value = ...future.value$value, 
[08:25:52.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.883]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.883]                     ...future.globalenv.names))
[08:25:52.883]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.883]         }, condition = base::local({
[08:25:52.883]             c <- base::c
[08:25:52.883]             inherits <- base::inherits
[08:25:52.883]             invokeRestart <- base::invokeRestart
[08:25:52.883]             length <- base::length
[08:25:52.883]             list <- base::list
[08:25:52.883]             seq.int <- base::seq.int
[08:25:52.883]             signalCondition <- base::signalCondition
[08:25:52.883]             sys.calls <- base::sys.calls
[08:25:52.883]             `[[` <- base::`[[`
[08:25:52.883]             `+` <- base::`+`
[08:25:52.883]             `<<-` <- base::`<<-`
[08:25:52.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.883]                   3L)]
[08:25:52.883]             }
[08:25:52.883]             function(cond) {
[08:25:52.883]                 is_error <- inherits(cond, "error")
[08:25:52.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.883]                   NULL)
[08:25:52.883]                 if (is_error) {
[08:25:52.883]                   sessionInformation <- function() {
[08:25:52.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.883]                       search = base::search(), system = base::Sys.info())
[08:25:52.883]                   }
[08:25:52.883]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.883]                     cond$call), session = sessionInformation(), 
[08:25:52.883]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.883]                   signalCondition(cond)
[08:25:52.883]                 }
[08:25:52.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.883]                 "immediateCondition"))) {
[08:25:52.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.883]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.883]                   if (TRUE && !signal) {
[08:25:52.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.883]                     {
[08:25:52.883]                       inherits <- base::inherits
[08:25:52.883]                       invokeRestart <- base::invokeRestart
[08:25:52.883]                       is.null <- base::is.null
[08:25:52.883]                       muffled <- FALSE
[08:25:52.883]                       if (inherits(cond, "message")) {
[08:25:52.883]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.883]                         if (muffled) 
[08:25:52.883]                           invokeRestart("muffleMessage")
[08:25:52.883]                       }
[08:25:52.883]                       else if (inherits(cond, "warning")) {
[08:25:52.883]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.883]                         if (muffled) 
[08:25:52.883]                           invokeRestart("muffleWarning")
[08:25:52.883]                       }
[08:25:52.883]                       else if (inherits(cond, "condition")) {
[08:25:52.883]                         if (!is.null(pattern)) {
[08:25:52.883]                           computeRestarts <- base::computeRestarts
[08:25:52.883]                           grepl <- base::grepl
[08:25:52.883]                           restarts <- computeRestarts(cond)
[08:25:52.883]                           for (restart in restarts) {
[08:25:52.883]                             name <- restart$name
[08:25:52.883]                             if (is.null(name)) 
[08:25:52.883]                               next
[08:25:52.883]                             if (!grepl(pattern, name)) 
[08:25:52.883]                               next
[08:25:52.883]                             invokeRestart(restart)
[08:25:52.883]                             muffled <- TRUE
[08:25:52.883]                             break
[08:25:52.883]                           }
[08:25:52.883]                         }
[08:25:52.883]                       }
[08:25:52.883]                       invisible(muffled)
[08:25:52.883]                     }
[08:25:52.883]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.883]                   }
[08:25:52.883]                 }
[08:25:52.883]                 else {
[08:25:52.883]                   if (TRUE) {
[08:25:52.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.883]                     {
[08:25:52.883]                       inherits <- base::inherits
[08:25:52.883]                       invokeRestart <- base::invokeRestart
[08:25:52.883]                       is.null <- base::is.null
[08:25:52.883]                       muffled <- FALSE
[08:25:52.883]                       if (inherits(cond, "message")) {
[08:25:52.883]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.883]                         if (muffled) 
[08:25:52.883]                           invokeRestart("muffleMessage")
[08:25:52.883]                       }
[08:25:52.883]                       else if (inherits(cond, "warning")) {
[08:25:52.883]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.883]                         if (muffled) 
[08:25:52.883]                           invokeRestart("muffleWarning")
[08:25:52.883]                       }
[08:25:52.883]                       else if (inherits(cond, "condition")) {
[08:25:52.883]                         if (!is.null(pattern)) {
[08:25:52.883]                           computeRestarts <- base::computeRestarts
[08:25:52.883]                           grepl <- base::grepl
[08:25:52.883]                           restarts <- computeRestarts(cond)
[08:25:52.883]                           for (restart in restarts) {
[08:25:52.883]                             name <- restart$name
[08:25:52.883]                             if (is.null(name)) 
[08:25:52.883]                               next
[08:25:52.883]                             if (!grepl(pattern, name)) 
[08:25:52.883]                               next
[08:25:52.883]                             invokeRestart(restart)
[08:25:52.883]                             muffled <- TRUE
[08:25:52.883]                             break
[08:25:52.883]                           }
[08:25:52.883]                         }
[08:25:52.883]                       }
[08:25:52.883]                       invisible(muffled)
[08:25:52.883]                     }
[08:25:52.883]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.883]                   }
[08:25:52.883]                 }
[08:25:52.883]             }
[08:25:52.883]         }))
[08:25:52.883]     }, error = function(ex) {
[08:25:52.883]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.883]                 ...future.rng), started = ...future.startTime, 
[08:25:52.883]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.883]             version = "1.8"), class = "FutureResult")
[08:25:52.883]     }, finally = {
[08:25:52.883]         if (!identical(...future.workdir, getwd())) 
[08:25:52.883]             setwd(...future.workdir)
[08:25:52.883]         {
[08:25:52.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.883]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.883]             }
[08:25:52.883]             base::options(...future.oldOptions)
[08:25:52.883]             if (.Platform$OS.type == "windows") {
[08:25:52.883]                 old_names <- names(...future.oldEnvVars)
[08:25:52.883]                 envs <- base::Sys.getenv()
[08:25:52.883]                 names <- names(envs)
[08:25:52.883]                 common <- intersect(names, old_names)
[08:25:52.883]                 added <- setdiff(names, old_names)
[08:25:52.883]                 removed <- setdiff(old_names, names)
[08:25:52.883]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.883]                   envs[common]]
[08:25:52.883]                 NAMES <- toupper(changed)
[08:25:52.883]                 args <- list()
[08:25:52.883]                 for (kk in seq_along(NAMES)) {
[08:25:52.883]                   name <- changed[[kk]]
[08:25:52.883]                   NAME <- NAMES[[kk]]
[08:25:52.883]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.883]                     next
[08:25:52.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.883]                 }
[08:25:52.883]                 NAMES <- toupper(added)
[08:25:52.883]                 for (kk in seq_along(NAMES)) {
[08:25:52.883]                   name <- added[[kk]]
[08:25:52.883]                   NAME <- NAMES[[kk]]
[08:25:52.883]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.883]                     next
[08:25:52.883]                   args[[name]] <- ""
[08:25:52.883]                 }
[08:25:52.883]                 NAMES <- toupper(removed)
[08:25:52.883]                 for (kk in seq_along(NAMES)) {
[08:25:52.883]                   name <- removed[[kk]]
[08:25:52.883]                   NAME <- NAMES[[kk]]
[08:25:52.883]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.883]                     next
[08:25:52.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.883]                 }
[08:25:52.883]                 if (length(args) > 0) 
[08:25:52.883]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.883]             }
[08:25:52.883]             else {
[08:25:52.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.883]             }
[08:25:52.883]             {
[08:25:52.883]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.883]                   0L) {
[08:25:52.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.883]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.883]                   base::options(opts)
[08:25:52.883]                 }
[08:25:52.883]                 {
[08:25:52.883]                   {
[08:25:52.883]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.883]                     NULL
[08:25:52.883]                   }
[08:25:52.883]                   options(future.plan = NULL)
[08:25:52.883]                   if (is.na(NA_character_)) 
[08:25:52.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.883]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.883]                     .init = FALSE)
[08:25:52.883]                 }
[08:25:52.883]             }
[08:25:52.883]         }
[08:25:52.883]     })
[08:25:52.883]     if (TRUE) {
[08:25:52.883]         base::sink(type = "output", split = FALSE)
[08:25:52.883]         if (TRUE) {
[08:25:52.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.883]         }
[08:25:52.883]         else {
[08:25:52.883]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.883]         }
[08:25:52.883]         base::close(...future.stdout)
[08:25:52.883]         ...future.stdout <- NULL
[08:25:52.883]     }
[08:25:52.883]     ...future.result$conditions <- ...future.conditions
[08:25:52.883]     ...future.result$finished <- base::Sys.time()
[08:25:52.883]     ...future.result
[08:25:52.883] }
[08:25:52.886] Exporting 5 global objects (1.29 KiB) to cluster node #1 ...
[08:25:52.886] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[08:25:52.887] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[08:25:52.887] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:52.887] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.887] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[08:25:52.888] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[08:25:52.888] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:52.888] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.888] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:52.889] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:52.889] Exporting 5 global objects (1.29 KiB) to cluster node #1 ... DONE
[08:25:52.889] MultisessionFuture started
[08:25:52.889] - Launch lazy future ... done
[08:25:52.889] run() for ‘MultisessionFuture’ ... done
[08:25:52.889] Created future:
[08:25:52.890] MultisessionFuture:
[08:25:52.890] Label: ‘future_mapply-1’
[08:25:52.890] Expression:
[08:25:52.890] {
[08:25:52.890]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.890]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.890]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.890]         on.exit(options(oopts), add = TRUE)
[08:25:52.890]     }
[08:25:52.890]     {
[08:25:52.890]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.890]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.890]         do.call(mapply, args = args)
[08:25:52.890]     }
[08:25:52.890] }
[08:25:52.890] Lazy evaluation: FALSE
[08:25:52.890] Asynchronous evaluation: TRUE
[08:25:52.890] Local evaluation: TRUE
[08:25:52.890] Environment: R_GlobalEnv
[08:25:52.890] Capture standard output: TRUE
[08:25:52.890] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.890] Globals: 5 objects totaling 876 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.890] Packages: <none>
[08:25:52.890] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.890] Resolved: FALSE
[08:25:52.890] Value: <not collected>
[08:25:52.890] Conditions captured: <none>
[08:25:52.890] Early signaling: FALSE
[08:25:52.890] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.890] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.909] Chunk #1 of 2 ... DONE
[08:25:52.909] Chunk #2 of 2 ...
[08:25:52.909]  - Finding globals in '...' for chunk #2 ...
[08:25:52.909] getGlobalsAndPackages() ...
[08:25:52.909] Searching for globals...
[08:25:52.910] 
[08:25:52.910] Searching for globals ... DONE
[08:25:52.910] - globals: [0] <none>
[08:25:52.910] getGlobalsAndPackages() ... DONE
[08:25:52.910]    + additional globals found: [n=0] 
[08:25:52.910]    + additional namespaces needed: [n=0] 
[08:25:52.910]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:52.910]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:52.910]  - seeds: <none>
[08:25:52.910]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.910] getGlobalsAndPackages() ...
[08:25:52.911] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.911] Resolving globals: FALSE
[08:25:52.911] The total size of the 5 globals is 905 bytes (905 bytes)
[08:25:52.912] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 905 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:52.912] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.912] 
[08:25:52.912] getGlobalsAndPackages() ... DONE
[08:25:52.912] run() for ‘Future’ ...
[08:25:52.912] - state: ‘created’
[08:25:52.912] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:52.926] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.926] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:52.926]   - Field: ‘node’
[08:25:52.926]   - Field: ‘label’
[08:25:52.927]   - Field: ‘local’
[08:25:52.927]   - Field: ‘owner’
[08:25:52.927]   - Field: ‘envir’
[08:25:52.927]   - Field: ‘workers’
[08:25:52.927]   - Field: ‘packages’
[08:25:52.927]   - Field: ‘gc’
[08:25:52.927]   - Field: ‘conditions’
[08:25:52.927]   - Field: ‘persistent’
[08:25:52.927]   - Field: ‘expr’
[08:25:52.927]   - Field: ‘uuid’
[08:25:52.928]   - Field: ‘seed’
[08:25:52.928]   - Field: ‘version’
[08:25:52.928]   - Field: ‘result’
[08:25:52.928]   - Field: ‘asynchronous’
[08:25:52.928]   - Field: ‘calls’
[08:25:52.928]   - Field: ‘globals’
[08:25:52.928]   - Field: ‘stdout’
[08:25:52.928]   - Field: ‘earlySignal’
[08:25:52.928]   - Field: ‘lazy’
[08:25:52.928]   - Field: ‘state’
[08:25:52.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:52.929] - Launch lazy future ...
[08:25:52.929] Packages needed by the future expression (n = 0): <none>
[08:25:52.929] Packages needed by future strategies (n = 0): <none>
[08:25:52.929] {
[08:25:52.929]     {
[08:25:52.929]         {
[08:25:52.929]             ...future.startTime <- base::Sys.time()
[08:25:52.929]             {
[08:25:52.929]                 {
[08:25:52.929]                   {
[08:25:52.929]                     {
[08:25:52.929]                       base::local({
[08:25:52.929]                         has_future <- base::requireNamespace("future", 
[08:25:52.929]                           quietly = TRUE)
[08:25:52.929]                         if (has_future) {
[08:25:52.929]                           ns <- base::getNamespace("future")
[08:25:52.929]                           version <- ns[[".package"]][["version"]]
[08:25:52.929]                           if (is.null(version)) 
[08:25:52.929]                             version <- utils::packageVersion("future")
[08:25:52.929]                         }
[08:25:52.929]                         else {
[08:25:52.929]                           version <- NULL
[08:25:52.929]                         }
[08:25:52.929]                         if (!has_future || version < "1.8.0") {
[08:25:52.929]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:52.929]                             "", base::R.version$version.string), 
[08:25:52.929]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:52.929]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:52.929]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:52.929]                               "release", "version")], collapse = " "), 
[08:25:52.929]                             hostname = base::Sys.info()[["nodename"]])
[08:25:52.929]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:52.929]                             info)
[08:25:52.929]                           info <- base::paste(info, collapse = "; ")
[08:25:52.929]                           if (!has_future) {
[08:25:52.929]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:52.929]                               info)
[08:25:52.929]                           }
[08:25:52.929]                           else {
[08:25:52.929]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:52.929]                               info, version)
[08:25:52.929]                           }
[08:25:52.929]                           base::stop(msg)
[08:25:52.929]                         }
[08:25:52.929]                       })
[08:25:52.929]                     }
[08:25:52.929]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:52.929]                     base::options(mc.cores = 1L)
[08:25:52.929]                   }
[08:25:52.929]                   ...future.strategy.old <- future::plan("list")
[08:25:52.929]                   options(future.plan = NULL)
[08:25:52.929]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.929]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:52.929]                 }
[08:25:52.929]                 ...future.workdir <- getwd()
[08:25:52.929]             }
[08:25:52.929]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:52.929]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:52.929]         }
[08:25:52.929]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:52.929]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:52.929]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:52.929]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:52.929]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:52.929]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:52.929]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:52.929]             base::names(...future.oldOptions))
[08:25:52.929]     }
[08:25:52.929]     if (FALSE) {
[08:25:52.929]     }
[08:25:52.929]     else {
[08:25:52.929]         if (TRUE) {
[08:25:52.929]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:52.929]                 open = "w")
[08:25:52.929]         }
[08:25:52.929]         else {
[08:25:52.929]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:52.929]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:52.929]         }
[08:25:52.929]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:52.929]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:52.929]             base::sink(type = "output", split = FALSE)
[08:25:52.929]             base::close(...future.stdout)
[08:25:52.929]         }, add = TRUE)
[08:25:52.929]     }
[08:25:52.929]     ...future.frame <- base::sys.nframe()
[08:25:52.929]     ...future.conditions <- base::list()
[08:25:52.929]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:52.929]     if (FALSE) {
[08:25:52.929]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:52.929]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:52.929]     }
[08:25:52.929]     ...future.result <- base::tryCatch({
[08:25:52.929]         base::withCallingHandlers({
[08:25:52.929]             ...future.value <- base::withVisible(base::local({
[08:25:52.929]                 ...future.makeSendCondition <- base::local({
[08:25:52.929]                   sendCondition <- NULL
[08:25:52.929]                   function(frame = 1L) {
[08:25:52.929]                     if (is.function(sendCondition)) 
[08:25:52.929]                       return(sendCondition)
[08:25:52.929]                     ns <- getNamespace("parallel")
[08:25:52.929]                     if (exists("sendData", mode = "function", 
[08:25:52.929]                       envir = ns)) {
[08:25:52.929]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:52.929]                         envir = ns)
[08:25:52.929]                       envir <- sys.frame(frame)
[08:25:52.929]                       master <- NULL
[08:25:52.929]                       while (!identical(envir, .GlobalEnv) && 
[08:25:52.929]                         !identical(envir, emptyenv())) {
[08:25:52.929]                         if (exists("master", mode = "list", envir = envir, 
[08:25:52.929]                           inherits = FALSE)) {
[08:25:52.929]                           master <- get("master", mode = "list", 
[08:25:52.929]                             envir = envir, inherits = FALSE)
[08:25:52.929]                           if (inherits(master, c("SOCKnode", 
[08:25:52.929]                             "SOCK0node"))) {
[08:25:52.929]                             sendCondition <<- function(cond) {
[08:25:52.929]                               data <- list(type = "VALUE", value = cond, 
[08:25:52.929]                                 success = TRUE)
[08:25:52.929]                               parallel_sendData(master, data)
[08:25:52.929]                             }
[08:25:52.929]                             return(sendCondition)
[08:25:52.929]                           }
[08:25:52.929]                         }
[08:25:52.929]                         frame <- frame + 1L
[08:25:52.929]                         envir <- sys.frame(frame)
[08:25:52.929]                       }
[08:25:52.929]                     }
[08:25:52.929]                     sendCondition <<- function(cond) NULL
[08:25:52.929]                   }
[08:25:52.929]                 })
[08:25:52.929]                 withCallingHandlers({
[08:25:52.929]                   {
[08:25:52.929]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.929]                     if (!identical(...future.globals.maxSize.org, 
[08:25:52.929]                       ...future.globals.maxSize)) {
[08:25:52.929]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.929]                       on.exit(options(oopts), add = TRUE)
[08:25:52.929]                     }
[08:25:52.929]                     {
[08:25:52.929]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.929]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:52.929]                         USE.NAMES = FALSE)
[08:25:52.929]                       do.call(mapply, args = args)
[08:25:52.929]                     }
[08:25:52.929]                   }
[08:25:52.929]                 }, immediateCondition = function(cond) {
[08:25:52.929]                   sendCondition <- ...future.makeSendCondition()
[08:25:52.929]                   sendCondition(cond)
[08:25:52.929]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.929]                   {
[08:25:52.929]                     inherits <- base::inherits
[08:25:52.929]                     invokeRestart <- base::invokeRestart
[08:25:52.929]                     is.null <- base::is.null
[08:25:52.929]                     muffled <- FALSE
[08:25:52.929]                     if (inherits(cond, "message")) {
[08:25:52.929]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:52.929]                       if (muffled) 
[08:25:52.929]                         invokeRestart("muffleMessage")
[08:25:52.929]                     }
[08:25:52.929]                     else if (inherits(cond, "warning")) {
[08:25:52.929]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:52.929]                       if (muffled) 
[08:25:52.929]                         invokeRestart("muffleWarning")
[08:25:52.929]                     }
[08:25:52.929]                     else if (inherits(cond, "condition")) {
[08:25:52.929]                       if (!is.null(pattern)) {
[08:25:52.929]                         computeRestarts <- base::computeRestarts
[08:25:52.929]                         grepl <- base::grepl
[08:25:52.929]                         restarts <- computeRestarts(cond)
[08:25:52.929]                         for (restart in restarts) {
[08:25:52.929]                           name <- restart$name
[08:25:52.929]                           if (is.null(name)) 
[08:25:52.929]                             next
[08:25:52.929]                           if (!grepl(pattern, name)) 
[08:25:52.929]                             next
[08:25:52.929]                           invokeRestart(restart)
[08:25:52.929]                           muffled <- TRUE
[08:25:52.929]                           break
[08:25:52.929]                         }
[08:25:52.929]                       }
[08:25:52.929]                     }
[08:25:52.929]                     invisible(muffled)
[08:25:52.929]                   }
[08:25:52.929]                   muffleCondition(cond)
[08:25:52.929]                 })
[08:25:52.929]             }))
[08:25:52.929]             future::FutureResult(value = ...future.value$value, 
[08:25:52.929]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.929]                   ...future.rng), globalenv = if (FALSE) 
[08:25:52.929]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:52.929]                     ...future.globalenv.names))
[08:25:52.929]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:52.929]         }, condition = base::local({
[08:25:52.929]             c <- base::c
[08:25:52.929]             inherits <- base::inherits
[08:25:52.929]             invokeRestart <- base::invokeRestart
[08:25:52.929]             length <- base::length
[08:25:52.929]             list <- base::list
[08:25:52.929]             seq.int <- base::seq.int
[08:25:52.929]             signalCondition <- base::signalCondition
[08:25:52.929]             sys.calls <- base::sys.calls
[08:25:52.929]             `[[` <- base::`[[`
[08:25:52.929]             `+` <- base::`+`
[08:25:52.929]             `<<-` <- base::`<<-`
[08:25:52.929]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:52.929]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:52.929]                   3L)]
[08:25:52.929]             }
[08:25:52.929]             function(cond) {
[08:25:52.929]                 is_error <- inherits(cond, "error")
[08:25:52.929]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:52.929]                   NULL)
[08:25:52.929]                 if (is_error) {
[08:25:52.929]                   sessionInformation <- function() {
[08:25:52.929]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:52.929]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:52.929]                       search = base::search(), system = base::Sys.info())
[08:25:52.929]                   }
[08:25:52.929]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.929]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:52.929]                     cond$call), session = sessionInformation(), 
[08:25:52.929]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:52.929]                   signalCondition(cond)
[08:25:52.929]                 }
[08:25:52.929]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:52.929]                 "immediateCondition"))) {
[08:25:52.929]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:52.929]                   ...future.conditions[[length(...future.conditions) + 
[08:25:52.929]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:52.929]                   if (TRUE && !signal) {
[08:25:52.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.929]                     {
[08:25:52.929]                       inherits <- base::inherits
[08:25:52.929]                       invokeRestart <- base::invokeRestart
[08:25:52.929]                       is.null <- base::is.null
[08:25:52.929]                       muffled <- FALSE
[08:25:52.929]                       if (inherits(cond, "message")) {
[08:25:52.929]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.929]                         if (muffled) 
[08:25:52.929]                           invokeRestart("muffleMessage")
[08:25:52.929]                       }
[08:25:52.929]                       else if (inherits(cond, "warning")) {
[08:25:52.929]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.929]                         if (muffled) 
[08:25:52.929]                           invokeRestart("muffleWarning")
[08:25:52.929]                       }
[08:25:52.929]                       else if (inherits(cond, "condition")) {
[08:25:52.929]                         if (!is.null(pattern)) {
[08:25:52.929]                           computeRestarts <- base::computeRestarts
[08:25:52.929]                           grepl <- base::grepl
[08:25:52.929]                           restarts <- computeRestarts(cond)
[08:25:52.929]                           for (restart in restarts) {
[08:25:52.929]                             name <- restart$name
[08:25:52.929]                             if (is.null(name)) 
[08:25:52.929]                               next
[08:25:52.929]                             if (!grepl(pattern, name)) 
[08:25:52.929]                               next
[08:25:52.929]                             invokeRestart(restart)
[08:25:52.929]                             muffled <- TRUE
[08:25:52.929]                             break
[08:25:52.929]                           }
[08:25:52.929]                         }
[08:25:52.929]                       }
[08:25:52.929]                       invisible(muffled)
[08:25:52.929]                     }
[08:25:52.929]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.929]                   }
[08:25:52.929]                 }
[08:25:52.929]                 else {
[08:25:52.929]                   if (TRUE) {
[08:25:52.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:52.929]                     {
[08:25:52.929]                       inherits <- base::inherits
[08:25:52.929]                       invokeRestart <- base::invokeRestart
[08:25:52.929]                       is.null <- base::is.null
[08:25:52.929]                       muffled <- FALSE
[08:25:52.929]                       if (inherits(cond, "message")) {
[08:25:52.929]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:52.929]                         if (muffled) 
[08:25:52.929]                           invokeRestart("muffleMessage")
[08:25:52.929]                       }
[08:25:52.929]                       else if (inherits(cond, "warning")) {
[08:25:52.929]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:52.929]                         if (muffled) 
[08:25:52.929]                           invokeRestart("muffleWarning")
[08:25:52.929]                       }
[08:25:52.929]                       else if (inherits(cond, "condition")) {
[08:25:52.929]                         if (!is.null(pattern)) {
[08:25:52.929]                           computeRestarts <- base::computeRestarts
[08:25:52.929]                           grepl <- base::grepl
[08:25:52.929]                           restarts <- computeRestarts(cond)
[08:25:52.929]                           for (restart in restarts) {
[08:25:52.929]                             name <- restart$name
[08:25:52.929]                             if (is.null(name)) 
[08:25:52.929]                               next
[08:25:52.929]                             if (!grepl(pattern, name)) 
[08:25:52.929]                               next
[08:25:52.929]                             invokeRestart(restart)
[08:25:52.929]                             muffled <- TRUE
[08:25:52.929]                             break
[08:25:52.929]                           }
[08:25:52.929]                         }
[08:25:52.929]                       }
[08:25:52.929]                       invisible(muffled)
[08:25:52.929]                     }
[08:25:52.929]                     muffleCondition(cond, pattern = "^muffle")
[08:25:52.929]                   }
[08:25:52.929]                 }
[08:25:52.929]             }
[08:25:52.929]         }))
[08:25:52.929]     }, error = function(ex) {
[08:25:52.929]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:52.929]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:52.929]                 ...future.rng), started = ...future.startTime, 
[08:25:52.929]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:52.929]             version = "1.8"), class = "FutureResult")
[08:25:52.929]     }, finally = {
[08:25:52.929]         if (!identical(...future.workdir, getwd())) 
[08:25:52.929]             setwd(...future.workdir)
[08:25:52.929]         {
[08:25:52.929]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:52.929]                 ...future.oldOptions$nwarnings <- NULL
[08:25:52.929]             }
[08:25:52.929]             base::options(...future.oldOptions)
[08:25:52.929]             if (.Platform$OS.type == "windows") {
[08:25:52.929]                 old_names <- names(...future.oldEnvVars)
[08:25:52.929]                 envs <- base::Sys.getenv()
[08:25:52.929]                 names <- names(envs)
[08:25:52.929]                 common <- intersect(names, old_names)
[08:25:52.929]                 added <- setdiff(names, old_names)
[08:25:52.929]                 removed <- setdiff(old_names, names)
[08:25:52.929]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:52.929]                   envs[common]]
[08:25:52.929]                 NAMES <- toupper(changed)
[08:25:52.929]                 args <- list()
[08:25:52.929]                 for (kk in seq_along(NAMES)) {
[08:25:52.929]                   name <- changed[[kk]]
[08:25:52.929]                   NAME <- NAMES[[kk]]
[08:25:52.929]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.929]                     next
[08:25:52.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.929]                 }
[08:25:52.929]                 NAMES <- toupper(added)
[08:25:52.929]                 for (kk in seq_along(NAMES)) {
[08:25:52.929]                   name <- added[[kk]]
[08:25:52.929]                   NAME <- NAMES[[kk]]
[08:25:52.929]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.929]                     next
[08:25:52.929]                   args[[name]] <- ""
[08:25:52.929]                 }
[08:25:52.929]                 NAMES <- toupper(removed)
[08:25:52.929]                 for (kk in seq_along(NAMES)) {
[08:25:52.929]                   name <- removed[[kk]]
[08:25:52.929]                   NAME <- NAMES[[kk]]
[08:25:52.929]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:52.929]                     next
[08:25:52.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:52.929]                 }
[08:25:52.929]                 if (length(args) > 0) 
[08:25:52.929]                   base::do.call(base::Sys.setenv, args = args)
[08:25:52.929]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:52.929]             }
[08:25:52.929]             else {
[08:25:52.929]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:52.929]             }
[08:25:52.929]             {
[08:25:52.929]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:52.929]                   0L) {
[08:25:52.929]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:52.929]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:52.929]                   base::options(opts)
[08:25:52.929]                 }
[08:25:52.929]                 {
[08:25:52.929]                   {
[08:25:52.929]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:52.929]                     NULL
[08:25:52.929]                   }
[08:25:52.929]                   options(future.plan = NULL)
[08:25:52.929]                   if (is.na(NA_character_)) 
[08:25:52.929]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:52.929]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:52.929]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:52.929]                     .init = FALSE)
[08:25:52.929]                 }
[08:25:52.929]             }
[08:25:52.929]         }
[08:25:52.929]     })
[08:25:52.929]     if (TRUE) {
[08:25:52.929]         base::sink(type = "output", split = FALSE)
[08:25:52.929]         if (TRUE) {
[08:25:52.929]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:52.929]         }
[08:25:52.929]         else {
[08:25:52.929]             ...future.result["stdout"] <- base::list(NULL)
[08:25:52.929]         }
[08:25:52.929]         base::close(...future.stdout)
[08:25:52.929]         ...future.stdout <- NULL
[08:25:52.929]     }
[08:25:52.929]     ...future.result$conditions <- ...future.conditions
[08:25:52.929]     ...future.result$finished <- base::Sys.time()
[08:25:52.929]     ...future.result
[08:25:52.929] }
[08:25:52.932] Exporting 5 global objects (1.32 KiB) to cluster node #2 ...
[08:25:52.933] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[08:25:52.933] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[08:25:52.933] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:52.934] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.934] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[08:25:52.934] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[08:25:52.934] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:52.935] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.935] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:52.935] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:52.935] Exporting 5 global objects (1.32 KiB) to cluster node #2 ... DONE
[08:25:52.936] MultisessionFuture started
[08:25:52.936] - Launch lazy future ... done
[08:25:52.936] run() for ‘MultisessionFuture’ ... done
[08:25:52.936] Created future:
[08:25:52.936] MultisessionFuture:
[08:25:52.936] Label: ‘future_mapply-2’
[08:25:52.936] Expression:
[08:25:52.936] {
[08:25:52.936]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:52.936]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:52.936]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:52.936]         on.exit(options(oopts), add = TRUE)
[08:25:52.936]     }
[08:25:52.936]     {
[08:25:52.936]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:52.936]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:52.936]         do.call(mapply, args = args)
[08:25:52.936]     }
[08:25:52.936] }
[08:25:52.936] Lazy evaluation: FALSE
[08:25:52.936] Asynchronous evaluation: TRUE
[08:25:52.936] Local evaluation: TRUE
[08:25:52.936] Environment: R_GlobalEnv
[08:25:52.936] Capture standard output: TRUE
[08:25:52.936] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:52.936] Globals: 5 objects totaling 905 bytes (function ‘...future.FUN’ of 690 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:52.936] Packages: <none>
[08:25:52.936] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:52.936] Resolved: FALSE
[08:25:52.936] Value: <not collected>
[08:25:52.936] Conditions captured: <none>
[08:25:52.936] Early signaling: FALSE
[08:25:52.936] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:52.936] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:52.947] Chunk #2 of 2 ... DONE
[08:25:52.948] Launching 2 futures (chunks) ... DONE
[08:25:52.948] Resolving 2 futures (chunks) ...
[08:25:52.948] resolve() on list ...
[08:25:52.948]  recursive: 0
[08:25:52.948]  length: 2
[08:25:52.948] 
[08:25:52.949] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.949] - Validating connection of MultisessionFuture
[08:25:52.949] - received message: FutureResult
[08:25:52.949] - Received FutureResult
[08:25:52.949] - Erased future from FutureRegistry
[08:25:52.949] result() for ClusterFuture ...
[08:25:52.949] - result already collected: FutureResult
[08:25:52.949] result() for ClusterFuture ... done
[08:25:52.949] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.950] Future #1
[08:25:52.950] result() for ClusterFuture ...
[08:25:52.950] - result already collected: FutureResult
[08:25:52.950] result() for ClusterFuture ... done
[08:25:52.950] result() for ClusterFuture ...
[08:25:52.950] - result already collected: FutureResult
[08:25:52.950] result() for ClusterFuture ... done
[08:25:52.950] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:52.950] - nx: 2
[08:25:52.950] - relay: TRUE
[08:25:52.950] - stdout: TRUE
[08:25:52.950] - signal: TRUE
[08:25:52.951] - resignal: FALSE
[08:25:52.951] - force: TRUE
[08:25:52.951] - relayed: [n=2] FALSE, FALSE
[08:25:52.951] - queued futures: [n=2] FALSE, FALSE
[08:25:52.951]  - until=1
[08:25:52.951]  - relaying element #1
[08:25:52.951] result() for ClusterFuture ...
[08:25:52.951] - result already collected: FutureResult
[08:25:52.951] result() for ClusterFuture ... done
[08:25:52.951] result() for ClusterFuture ...
[08:25:52.951] - result already collected: FutureResult
[08:25:52.951] result() for ClusterFuture ... done
[08:25:52.952] result() for ClusterFuture ...
[08:25:52.952] - result already collected: FutureResult
[08:25:52.952] result() for ClusterFuture ... done
[08:25:52.952] result() for ClusterFuture ...
[08:25:52.952] - result already collected: FutureResult
[08:25:52.952] result() for ClusterFuture ... done
[08:25:52.952] - relayed: [n=2] TRUE, FALSE
[08:25:52.952] - queued futures: [n=2] TRUE, FALSE
[08:25:52.952] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:52.952]  length: 1 (resolved future 1)
[08:25:52.978] receiveMessageFromWorker() for ClusterFuture ...
[08:25:52.978] - Validating connection of MultisessionFuture
[08:25:52.978] - received message: FutureResult
[08:25:52.979] - Received FutureResult
[08:25:52.979] - Erased future from FutureRegistry
[08:25:52.979] result() for ClusterFuture ...
[08:25:52.979] - result already collected: FutureResult
[08:25:52.979] result() for ClusterFuture ... done
[08:25:52.979] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:52.979] Future #2
[08:25:52.979] result() for ClusterFuture ...
[08:25:52.979] - result already collected: FutureResult
[08:25:52.979] result() for ClusterFuture ... done
[08:25:52.979] result() for ClusterFuture ...
[08:25:52.980] - result already collected: FutureResult
[08:25:52.980] result() for ClusterFuture ... done
[08:25:52.980] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:52.980] - nx: 2
[08:25:52.980] - relay: TRUE
[08:25:52.980] - stdout: TRUE
[08:25:52.980] - signal: TRUE
[08:25:52.980] - resignal: FALSE
[08:25:52.980] - force: TRUE
[08:25:52.980] - relayed: [n=2] TRUE, FALSE
[08:25:52.980] - queued futures: [n=2] TRUE, FALSE
[08:25:52.980]  - until=2
[08:25:52.980]  - relaying element #2
[08:25:52.981] result() for ClusterFuture ...
[08:25:52.981] - result already collected: FutureResult
[08:25:52.981] result() for ClusterFuture ... done
[08:25:52.981] result() for ClusterFuture ...
[08:25:52.981] - result already collected: FutureResult
[08:25:52.981] result() for ClusterFuture ... done
[08:25:52.981] result() for ClusterFuture ...
[08:25:52.981] - result already collected: FutureResult
[08:25:52.981] result() for ClusterFuture ... done
[08:25:52.981] result() for ClusterFuture ...
[08:25:52.981] - result already collected: FutureResult
[08:25:52.982] result() for ClusterFuture ... done
[08:25:52.982] - relayed: [n=2] TRUE, TRUE
[08:25:52.982] - queued futures: [n=2] TRUE, TRUE
[08:25:52.982] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:52.982]  length: 0 (resolved future 2)
[08:25:52.982] Relaying remaining futures
[08:25:52.982] signalConditionsASAP(NULL, pos=0) ...
[08:25:52.982] - nx: 2
[08:25:52.982] - relay: TRUE
[08:25:52.982] - stdout: TRUE
[08:25:52.982] - signal: TRUE
[08:25:52.982] - resignal: FALSE
[08:25:52.983] - force: TRUE
[08:25:52.983] - relayed: [n=2] TRUE, TRUE
[08:25:52.983] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:52.983] - relayed: [n=2] TRUE, TRUE
[08:25:52.983] - queued futures: [n=2] TRUE, TRUE
[08:25:52.983] signalConditionsASAP(NULL, pos=0) ... done
[08:25:52.983] resolve() on list ... DONE
[08:25:52.983] result() for ClusterFuture ...
[08:25:52.983] - result already collected: FutureResult
[08:25:52.983] result() for ClusterFuture ... done
[08:25:52.983] result() for ClusterFuture ...
[08:25:52.984] - result already collected: FutureResult
[08:25:52.984] result() for ClusterFuture ... done
[08:25:52.984] result() for ClusterFuture ...
[08:25:52.984] - result already collected: FutureResult
[08:25:52.984] result() for ClusterFuture ... done
[08:25:52.984] result() for ClusterFuture ...
[08:25:52.984] - result already collected: FutureResult
[08:25:52.984] result() for ClusterFuture ... done
[08:25:52.984]  - Number of value chunks collected: 2
[08:25:52.984] Resolving 2 futures (chunks) ... DONE
[08:25:52.984] Reducing values from 2 chunks ...
[08:25:52.984]  - Number of values collected after concatenation: 5
[08:25:52.985]  - Number of values expected: 5
[08:25:52.985] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[08:25:52.985] Reducing values from 2 chunks ... DONE
[08:25:52.985] future_mapply() ... DONE
[08:25:52.985] future_mapply() ...
[08:25:52.987] Number of chunks: 2
[08:25:52.987] getGlobalsAndPackagesXApply() ...
[08:25:52.987]  - future.globals: TRUE
[08:25:52.987] getGlobalsAndPackages() ...
[08:25:52.987] Searching for globals...
[08:25:52.989] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[08:25:52.989] Searching for globals ... DONE
[08:25:52.989] Resolving globals: FALSE
[08:25:52.989] The total size of the 1 globals is 690 bytes (690 bytes)
[08:25:52.989] The total size of the 1 globals exported for future expression (‘FUN()’) is 690 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (690 bytes of class ‘function’)
[08:25:52.990] - globals: [1] ‘FUN’
[08:25:52.990] 
[08:25:52.990] getGlobalsAndPackages() ... DONE
[08:25:52.990]  - globals found/used: [n=1] ‘FUN’
[08:25:52.990]  - needed namespaces: [n=0] 
[08:25:52.990] Finding globals ... DONE
[08:25:52.990] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:52.990] List of 2
[08:25:52.990]  $ ...future.FUN:function (C, k)  
[08:25:52.990]  $ MoreArgs     : list()
[08:25:52.990]  - attr(*, "where")=List of 2
[08:25:52.990]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:52.990]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:52.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:52.990]  - attr(*, "resolved")= logi FALSE
[08:25:52.990]  - attr(*, "total_size")= num NA
[08:25:52.993] Packages to be attached in all futures: [n=0] 
[08:25:52.993] getGlobalsAndPackagesXApply() ... DONE
[08:25:52.993] Number of futures (= number of chunks): 2
[08:25:52.993] Launching 2 futures (chunks) ...
[08:25:52.993] Chunk #1 of 2 ...
[08:25:52.994]  - Finding globals in '...' for chunk #1 ...
[08:25:52.994] getGlobalsAndPackages() ...
[08:25:52.994] Searching for globals...
[08:25:52.994] 
[08:25:52.994] Searching for globals ... DONE
[08:25:52.994] - globals: [0] <none>
[08:25:52.994] getGlobalsAndPackages() ... DONE
[08:25:52.994]    + additional globals found: [n=0] 
[08:25:52.994]    + additional namespaces needed: [n=0] 
[08:25:52.995]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:52.995]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:52.995]  - seeds: <none>
[08:25:52.995]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.995] getGlobalsAndPackages() ...
[08:25:52.995] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.995] Resolving globals: FALSE
[08:25:52.996] The total size of the 5 globals is 880 bytes (880 bytes)
[08:25:52.996] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 880 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (105 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:52.996] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:52.996] 
[08:25:52.996] getGlobalsAndPackages() ... DONE
[08:25:52.997] run() for ‘Future’ ...
[08:25:52.997] - state: ‘created’
[08:25:52.997] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.011] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.011]   - Field: ‘node’
[08:25:53.011]   - Field: ‘label’
[08:25:53.011]   - Field: ‘local’
[08:25:53.011]   - Field: ‘owner’
[08:25:53.012]   - Field: ‘envir’
[08:25:53.012]   - Field: ‘workers’
[08:25:53.012]   - Field: ‘packages’
[08:25:53.012]   - Field: ‘gc’
[08:25:53.012]   - Field: ‘conditions’
[08:25:53.012]   - Field: ‘persistent’
[08:25:53.012]   - Field: ‘expr’
[08:25:53.012]   - Field: ‘uuid’
[08:25:53.012]   - Field: ‘seed’
[08:25:53.012]   - Field: ‘version’
[08:25:53.012]   - Field: ‘result’
[08:25:53.013]   - Field: ‘asynchronous’
[08:25:53.013]   - Field: ‘calls’
[08:25:53.013]   - Field: ‘globals’
[08:25:53.013]   - Field: ‘stdout’
[08:25:53.013]   - Field: ‘earlySignal’
[08:25:53.013]   - Field: ‘lazy’
[08:25:53.013]   - Field: ‘state’
[08:25:53.013] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.013] - Launch lazy future ...
[08:25:53.014] Packages needed by the future expression (n = 0): <none>
[08:25:53.014] Packages needed by future strategies (n = 0): <none>
[08:25:53.014] {
[08:25:53.014]     {
[08:25:53.014]         {
[08:25:53.014]             ...future.startTime <- base::Sys.time()
[08:25:53.014]             {
[08:25:53.014]                 {
[08:25:53.014]                   {
[08:25:53.014]                     {
[08:25:53.014]                       base::local({
[08:25:53.014]                         has_future <- base::requireNamespace("future", 
[08:25:53.014]                           quietly = TRUE)
[08:25:53.014]                         if (has_future) {
[08:25:53.014]                           ns <- base::getNamespace("future")
[08:25:53.014]                           version <- ns[[".package"]][["version"]]
[08:25:53.014]                           if (is.null(version)) 
[08:25:53.014]                             version <- utils::packageVersion("future")
[08:25:53.014]                         }
[08:25:53.014]                         else {
[08:25:53.014]                           version <- NULL
[08:25:53.014]                         }
[08:25:53.014]                         if (!has_future || version < "1.8.0") {
[08:25:53.014]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.014]                             "", base::R.version$version.string), 
[08:25:53.014]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.014]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.014]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.014]                               "release", "version")], collapse = " "), 
[08:25:53.014]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.014]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.014]                             info)
[08:25:53.014]                           info <- base::paste(info, collapse = "; ")
[08:25:53.014]                           if (!has_future) {
[08:25:53.014]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.014]                               info)
[08:25:53.014]                           }
[08:25:53.014]                           else {
[08:25:53.014]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.014]                               info, version)
[08:25:53.014]                           }
[08:25:53.014]                           base::stop(msg)
[08:25:53.014]                         }
[08:25:53.014]                       })
[08:25:53.014]                     }
[08:25:53.014]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.014]                     base::options(mc.cores = 1L)
[08:25:53.014]                   }
[08:25:53.014]                   ...future.strategy.old <- future::plan("list")
[08:25:53.014]                   options(future.plan = NULL)
[08:25:53.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.014]                 }
[08:25:53.014]                 ...future.workdir <- getwd()
[08:25:53.014]             }
[08:25:53.014]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.014]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.014]         }
[08:25:53.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.014]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.014]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.014]             base::names(...future.oldOptions))
[08:25:53.014]     }
[08:25:53.014]     if (FALSE) {
[08:25:53.014]     }
[08:25:53.014]     else {
[08:25:53.014]         if (TRUE) {
[08:25:53.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.014]                 open = "w")
[08:25:53.014]         }
[08:25:53.014]         else {
[08:25:53.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.014]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.014]         }
[08:25:53.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.014]             base::sink(type = "output", split = FALSE)
[08:25:53.014]             base::close(...future.stdout)
[08:25:53.014]         }, add = TRUE)
[08:25:53.014]     }
[08:25:53.014]     ...future.frame <- base::sys.nframe()
[08:25:53.014]     ...future.conditions <- base::list()
[08:25:53.014]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.014]     if (FALSE) {
[08:25:53.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.014]     }
[08:25:53.014]     ...future.result <- base::tryCatch({
[08:25:53.014]         base::withCallingHandlers({
[08:25:53.014]             ...future.value <- base::withVisible(base::local({
[08:25:53.014]                 ...future.makeSendCondition <- base::local({
[08:25:53.014]                   sendCondition <- NULL
[08:25:53.014]                   function(frame = 1L) {
[08:25:53.014]                     if (is.function(sendCondition)) 
[08:25:53.014]                       return(sendCondition)
[08:25:53.014]                     ns <- getNamespace("parallel")
[08:25:53.014]                     if (exists("sendData", mode = "function", 
[08:25:53.014]                       envir = ns)) {
[08:25:53.014]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.014]                         envir = ns)
[08:25:53.014]                       envir <- sys.frame(frame)
[08:25:53.014]                       master <- NULL
[08:25:53.014]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.014]                         !identical(envir, emptyenv())) {
[08:25:53.014]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.014]                           inherits = FALSE)) {
[08:25:53.014]                           master <- get("master", mode = "list", 
[08:25:53.014]                             envir = envir, inherits = FALSE)
[08:25:53.014]                           if (inherits(master, c("SOCKnode", 
[08:25:53.014]                             "SOCK0node"))) {
[08:25:53.014]                             sendCondition <<- function(cond) {
[08:25:53.014]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.014]                                 success = TRUE)
[08:25:53.014]                               parallel_sendData(master, data)
[08:25:53.014]                             }
[08:25:53.014]                             return(sendCondition)
[08:25:53.014]                           }
[08:25:53.014]                         }
[08:25:53.014]                         frame <- frame + 1L
[08:25:53.014]                         envir <- sys.frame(frame)
[08:25:53.014]                       }
[08:25:53.014]                     }
[08:25:53.014]                     sendCondition <<- function(cond) NULL
[08:25:53.014]                   }
[08:25:53.014]                 })
[08:25:53.014]                 withCallingHandlers({
[08:25:53.014]                   {
[08:25:53.014]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.014]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.014]                       ...future.globals.maxSize)) {
[08:25:53.014]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.014]                       on.exit(options(oopts), add = TRUE)
[08:25:53.014]                     }
[08:25:53.014]                     {
[08:25:53.014]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.014]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.014]                         USE.NAMES = FALSE)
[08:25:53.014]                       do.call(mapply, args = args)
[08:25:53.014]                     }
[08:25:53.014]                   }
[08:25:53.014]                 }, immediateCondition = function(cond) {
[08:25:53.014]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.014]                   sendCondition(cond)
[08:25:53.014]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.014]                   {
[08:25:53.014]                     inherits <- base::inherits
[08:25:53.014]                     invokeRestart <- base::invokeRestart
[08:25:53.014]                     is.null <- base::is.null
[08:25:53.014]                     muffled <- FALSE
[08:25:53.014]                     if (inherits(cond, "message")) {
[08:25:53.014]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.014]                       if (muffled) 
[08:25:53.014]                         invokeRestart("muffleMessage")
[08:25:53.014]                     }
[08:25:53.014]                     else if (inherits(cond, "warning")) {
[08:25:53.014]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.014]                       if (muffled) 
[08:25:53.014]                         invokeRestart("muffleWarning")
[08:25:53.014]                     }
[08:25:53.014]                     else if (inherits(cond, "condition")) {
[08:25:53.014]                       if (!is.null(pattern)) {
[08:25:53.014]                         computeRestarts <- base::computeRestarts
[08:25:53.014]                         grepl <- base::grepl
[08:25:53.014]                         restarts <- computeRestarts(cond)
[08:25:53.014]                         for (restart in restarts) {
[08:25:53.014]                           name <- restart$name
[08:25:53.014]                           if (is.null(name)) 
[08:25:53.014]                             next
[08:25:53.014]                           if (!grepl(pattern, name)) 
[08:25:53.014]                             next
[08:25:53.014]                           invokeRestart(restart)
[08:25:53.014]                           muffled <- TRUE
[08:25:53.014]                           break
[08:25:53.014]                         }
[08:25:53.014]                       }
[08:25:53.014]                     }
[08:25:53.014]                     invisible(muffled)
[08:25:53.014]                   }
[08:25:53.014]                   muffleCondition(cond)
[08:25:53.014]                 })
[08:25:53.014]             }))
[08:25:53.014]             future::FutureResult(value = ...future.value$value, 
[08:25:53.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.014]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.014]                     ...future.globalenv.names))
[08:25:53.014]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.014]         }, condition = base::local({
[08:25:53.014]             c <- base::c
[08:25:53.014]             inherits <- base::inherits
[08:25:53.014]             invokeRestart <- base::invokeRestart
[08:25:53.014]             length <- base::length
[08:25:53.014]             list <- base::list
[08:25:53.014]             seq.int <- base::seq.int
[08:25:53.014]             signalCondition <- base::signalCondition
[08:25:53.014]             sys.calls <- base::sys.calls
[08:25:53.014]             `[[` <- base::`[[`
[08:25:53.014]             `+` <- base::`+`
[08:25:53.014]             `<<-` <- base::`<<-`
[08:25:53.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.014]                   3L)]
[08:25:53.014]             }
[08:25:53.014]             function(cond) {
[08:25:53.014]                 is_error <- inherits(cond, "error")
[08:25:53.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.014]                   NULL)
[08:25:53.014]                 if (is_error) {
[08:25:53.014]                   sessionInformation <- function() {
[08:25:53.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.014]                       search = base::search(), system = base::Sys.info())
[08:25:53.014]                   }
[08:25:53.014]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.014]                     cond$call), session = sessionInformation(), 
[08:25:53.014]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.014]                   signalCondition(cond)
[08:25:53.014]                 }
[08:25:53.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.014]                 "immediateCondition"))) {
[08:25:53.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.014]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.014]                   if (TRUE && !signal) {
[08:25:53.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.014]                     {
[08:25:53.014]                       inherits <- base::inherits
[08:25:53.014]                       invokeRestart <- base::invokeRestart
[08:25:53.014]                       is.null <- base::is.null
[08:25:53.014]                       muffled <- FALSE
[08:25:53.014]                       if (inherits(cond, "message")) {
[08:25:53.014]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.014]                         if (muffled) 
[08:25:53.014]                           invokeRestart("muffleMessage")
[08:25:53.014]                       }
[08:25:53.014]                       else if (inherits(cond, "warning")) {
[08:25:53.014]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.014]                         if (muffled) 
[08:25:53.014]                           invokeRestart("muffleWarning")
[08:25:53.014]                       }
[08:25:53.014]                       else if (inherits(cond, "condition")) {
[08:25:53.014]                         if (!is.null(pattern)) {
[08:25:53.014]                           computeRestarts <- base::computeRestarts
[08:25:53.014]                           grepl <- base::grepl
[08:25:53.014]                           restarts <- computeRestarts(cond)
[08:25:53.014]                           for (restart in restarts) {
[08:25:53.014]                             name <- restart$name
[08:25:53.014]                             if (is.null(name)) 
[08:25:53.014]                               next
[08:25:53.014]                             if (!grepl(pattern, name)) 
[08:25:53.014]                               next
[08:25:53.014]                             invokeRestart(restart)
[08:25:53.014]                             muffled <- TRUE
[08:25:53.014]                             break
[08:25:53.014]                           }
[08:25:53.014]                         }
[08:25:53.014]                       }
[08:25:53.014]                       invisible(muffled)
[08:25:53.014]                     }
[08:25:53.014]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.014]                   }
[08:25:53.014]                 }
[08:25:53.014]                 else {
[08:25:53.014]                   if (TRUE) {
[08:25:53.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.014]                     {
[08:25:53.014]                       inherits <- base::inherits
[08:25:53.014]                       invokeRestart <- base::invokeRestart
[08:25:53.014]                       is.null <- base::is.null
[08:25:53.014]                       muffled <- FALSE
[08:25:53.014]                       if (inherits(cond, "message")) {
[08:25:53.014]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.014]                         if (muffled) 
[08:25:53.014]                           invokeRestart("muffleMessage")
[08:25:53.014]                       }
[08:25:53.014]                       else if (inherits(cond, "warning")) {
[08:25:53.014]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.014]                         if (muffled) 
[08:25:53.014]                           invokeRestart("muffleWarning")
[08:25:53.014]                       }
[08:25:53.014]                       else if (inherits(cond, "condition")) {
[08:25:53.014]                         if (!is.null(pattern)) {
[08:25:53.014]                           computeRestarts <- base::computeRestarts
[08:25:53.014]                           grepl <- base::grepl
[08:25:53.014]                           restarts <- computeRestarts(cond)
[08:25:53.014]                           for (restart in restarts) {
[08:25:53.014]                             name <- restart$name
[08:25:53.014]                             if (is.null(name)) 
[08:25:53.014]                               next
[08:25:53.014]                             if (!grepl(pattern, name)) 
[08:25:53.014]                               next
[08:25:53.014]                             invokeRestart(restart)
[08:25:53.014]                             muffled <- TRUE
[08:25:53.014]                             break
[08:25:53.014]                           }
[08:25:53.014]                         }
[08:25:53.014]                       }
[08:25:53.014]                       invisible(muffled)
[08:25:53.014]                     }
[08:25:53.014]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.014]                   }
[08:25:53.014]                 }
[08:25:53.014]             }
[08:25:53.014]         }))
[08:25:53.014]     }, error = function(ex) {
[08:25:53.014]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.014]                 ...future.rng), started = ...future.startTime, 
[08:25:53.014]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.014]             version = "1.8"), class = "FutureResult")
[08:25:53.014]     }, finally = {
[08:25:53.014]         if (!identical(...future.workdir, getwd())) 
[08:25:53.014]             setwd(...future.workdir)
[08:25:53.014]         {
[08:25:53.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.014]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.014]             }
[08:25:53.014]             base::options(...future.oldOptions)
[08:25:53.014]             if (.Platform$OS.type == "windows") {
[08:25:53.014]                 old_names <- names(...future.oldEnvVars)
[08:25:53.014]                 envs <- base::Sys.getenv()
[08:25:53.014]                 names <- names(envs)
[08:25:53.014]                 common <- intersect(names, old_names)
[08:25:53.014]                 added <- setdiff(names, old_names)
[08:25:53.014]                 removed <- setdiff(old_names, names)
[08:25:53.014]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.014]                   envs[common]]
[08:25:53.014]                 NAMES <- toupper(changed)
[08:25:53.014]                 args <- list()
[08:25:53.014]                 for (kk in seq_along(NAMES)) {
[08:25:53.014]                   name <- changed[[kk]]
[08:25:53.014]                   NAME <- NAMES[[kk]]
[08:25:53.014]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.014]                     next
[08:25:53.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.014]                 }
[08:25:53.014]                 NAMES <- toupper(added)
[08:25:53.014]                 for (kk in seq_along(NAMES)) {
[08:25:53.014]                   name <- added[[kk]]
[08:25:53.014]                   NAME <- NAMES[[kk]]
[08:25:53.014]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.014]                     next
[08:25:53.014]                   args[[name]] <- ""
[08:25:53.014]                 }
[08:25:53.014]                 NAMES <- toupper(removed)
[08:25:53.014]                 for (kk in seq_along(NAMES)) {
[08:25:53.014]                   name <- removed[[kk]]
[08:25:53.014]                   NAME <- NAMES[[kk]]
[08:25:53.014]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.014]                     next
[08:25:53.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.014]                 }
[08:25:53.014]                 if (length(args) > 0) 
[08:25:53.014]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.014]             }
[08:25:53.014]             else {
[08:25:53.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.014]             }
[08:25:53.014]             {
[08:25:53.014]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.014]                   0L) {
[08:25:53.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.014]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.014]                   base::options(opts)
[08:25:53.014]                 }
[08:25:53.014]                 {
[08:25:53.014]                   {
[08:25:53.014]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.014]                     NULL
[08:25:53.014]                   }
[08:25:53.014]                   options(future.plan = NULL)
[08:25:53.014]                   if (is.na(NA_character_)) 
[08:25:53.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.014]                     .init = FALSE)
[08:25:53.014]                 }
[08:25:53.014]             }
[08:25:53.014]         }
[08:25:53.014]     })
[08:25:53.014]     if (TRUE) {
[08:25:53.014]         base::sink(type = "output", split = FALSE)
[08:25:53.014]         if (TRUE) {
[08:25:53.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.014]         }
[08:25:53.014]         else {
[08:25:53.014]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.014]         }
[08:25:53.014]         base::close(...future.stdout)
[08:25:53.014]         ...future.stdout <- NULL
[08:25:53.014]     }
[08:25:53.014]     ...future.result$conditions <- ...future.conditions
[08:25:53.014]     ...future.result$finished <- base::Sys.time()
[08:25:53.014]     ...future.result
[08:25:53.014] }
[08:25:53.017] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[08:25:53.017] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ...
[08:25:53.018] Exporting ‘...future.FUN’ (690 bytes) to cluster node #1 ... DONE
[08:25:53.018] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[08:25:53.018] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[08:25:53.018] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ...
[08:25:53.019] Exporting ‘...future.elements_ii’ (105 bytes) to cluster node #1 ... DONE
[08:25:53.019] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:53.019] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.019] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:53.020] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.020] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[08:25:53.020] MultisessionFuture started
[08:25:53.020] - Launch lazy future ... done
[08:25:53.020] run() for ‘MultisessionFuture’ ... done
[08:25:53.021] Created future:
[08:25:53.021] MultisessionFuture:
[08:25:53.021] Label: ‘future_.mapply-1’
[08:25:53.021] Expression:
[08:25:53.021] {
[08:25:53.021]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.021]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.021]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.021]         on.exit(options(oopts), add = TRUE)
[08:25:53.021]     }
[08:25:53.021]     {
[08:25:53.021]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.021]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.021]         do.call(mapply, args = args)
[08:25:53.021]     }
[08:25:53.021] }
[08:25:53.021] Lazy evaluation: FALSE
[08:25:53.021] Asynchronous evaluation: TRUE
[08:25:53.021] Local evaluation: TRUE
[08:25:53.021] Environment: R_GlobalEnv
[08:25:53.021] Capture standard output: TRUE
[08:25:53.021] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.021] Globals: 5 objects totaling 880 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 105 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.021] Packages: <none>
[08:25:53.021] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.021] Resolved: FALSE
[08:25:53.021] Value: <not collected>
[08:25:53.021] Conditions captured: <none>
[08:25:53.021] Early signaling: FALSE
[08:25:53.021] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.021] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.032] Chunk #1 of 2 ... DONE
[08:25:53.032] Chunk #2 of 2 ...
[08:25:53.032]  - Finding globals in '...' for chunk #2 ...
[08:25:53.032] getGlobalsAndPackages() ...
[08:25:53.032] Searching for globals...
[08:25:53.033] 
[08:25:53.033] Searching for globals ... DONE
[08:25:53.033] - globals: [0] <none>
[08:25:53.033] getGlobalsAndPackages() ... DONE
[08:25:53.033]    + additional globals found: [n=0] 
[08:25:53.033]    + additional namespaces needed: [n=0] 
[08:25:53.033]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:53.033]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.034]  - seeds: <none>
[08:25:53.034]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.034] getGlobalsAndPackages() ...
[08:25:53.034] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.034] Resolving globals: FALSE
[08:25:53.034] The total size of the 5 globals is 909 bytes (909 bytes)
[08:25:53.035] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 909 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (690 bytes of class ‘function’), ‘...future.elements_ii’ (134 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:53.035] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.035] 
[08:25:53.035] getGlobalsAndPackages() ... DONE
[08:25:53.035] run() for ‘Future’ ...
[08:25:53.036] - state: ‘created’
[08:25:53.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.049] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.050]   - Field: ‘node’
[08:25:53.050]   - Field: ‘label’
[08:25:53.050]   - Field: ‘local’
[08:25:53.050]   - Field: ‘owner’
[08:25:53.050]   - Field: ‘envir’
[08:25:53.050]   - Field: ‘workers’
[08:25:53.050]   - Field: ‘packages’
[08:25:53.050]   - Field: ‘gc’
[08:25:53.051]   - Field: ‘conditions’
[08:25:53.051]   - Field: ‘persistent’
[08:25:53.051]   - Field: ‘expr’
[08:25:53.051]   - Field: ‘uuid’
[08:25:53.051]   - Field: ‘seed’
[08:25:53.051]   - Field: ‘version’
[08:25:53.051]   - Field: ‘result’
[08:25:53.051]   - Field: ‘asynchronous’
[08:25:53.051]   - Field: ‘calls’
[08:25:53.051]   - Field: ‘globals’
[08:25:53.051]   - Field: ‘stdout’
[08:25:53.051]   - Field: ‘earlySignal’
[08:25:53.052]   - Field: ‘lazy’
[08:25:53.052]   - Field: ‘state’
[08:25:53.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.052] - Launch lazy future ...
[08:25:53.052] Packages needed by the future expression (n = 0): <none>
[08:25:53.052] Packages needed by future strategies (n = 0): <none>
[08:25:53.053] {
[08:25:53.053]     {
[08:25:53.053]         {
[08:25:53.053]             ...future.startTime <- base::Sys.time()
[08:25:53.053]             {
[08:25:53.053]                 {
[08:25:53.053]                   {
[08:25:53.053]                     {
[08:25:53.053]                       base::local({
[08:25:53.053]                         has_future <- base::requireNamespace("future", 
[08:25:53.053]                           quietly = TRUE)
[08:25:53.053]                         if (has_future) {
[08:25:53.053]                           ns <- base::getNamespace("future")
[08:25:53.053]                           version <- ns[[".package"]][["version"]]
[08:25:53.053]                           if (is.null(version)) 
[08:25:53.053]                             version <- utils::packageVersion("future")
[08:25:53.053]                         }
[08:25:53.053]                         else {
[08:25:53.053]                           version <- NULL
[08:25:53.053]                         }
[08:25:53.053]                         if (!has_future || version < "1.8.0") {
[08:25:53.053]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.053]                             "", base::R.version$version.string), 
[08:25:53.053]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.053]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.053]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.053]                               "release", "version")], collapse = " "), 
[08:25:53.053]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.053]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.053]                             info)
[08:25:53.053]                           info <- base::paste(info, collapse = "; ")
[08:25:53.053]                           if (!has_future) {
[08:25:53.053]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.053]                               info)
[08:25:53.053]                           }
[08:25:53.053]                           else {
[08:25:53.053]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.053]                               info, version)
[08:25:53.053]                           }
[08:25:53.053]                           base::stop(msg)
[08:25:53.053]                         }
[08:25:53.053]                       })
[08:25:53.053]                     }
[08:25:53.053]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.053]                     base::options(mc.cores = 1L)
[08:25:53.053]                   }
[08:25:53.053]                   ...future.strategy.old <- future::plan("list")
[08:25:53.053]                   options(future.plan = NULL)
[08:25:53.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.053]                 }
[08:25:53.053]                 ...future.workdir <- getwd()
[08:25:53.053]             }
[08:25:53.053]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.053]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.053]         }
[08:25:53.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.053]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.053]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.053]             base::names(...future.oldOptions))
[08:25:53.053]     }
[08:25:53.053]     if (FALSE) {
[08:25:53.053]     }
[08:25:53.053]     else {
[08:25:53.053]         if (TRUE) {
[08:25:53.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.053]                 open = "w")
[08:25:53.053]         }
[08:25:53.053]         else {
[08:25:53.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.053]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.053]         }
[08:25:53.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.053]             base::sink(type = "output", split = FALSE)
[08:25:53.053]             base::close(...future.stdout)
[08:25:53.053]         }, add = TRUE)
[08:25:53.053]     }
[08:25:53.053]     ...future.frame <- base::sys.nframe()
[08:25:53.053]     ...future.conditions <- base::list()
[08:25:53.053]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.053]     if (FALSE) {
[08:25:53.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.053]     }
[08:25:53.053]     ...future.result <- base::tryCatch({
[08:25:53.053]         base::withCallingHandlers({
[08:25:53.053]             ...future.value <- base::withVisible(base::local({
[08:25:53.053]                 ...future.makeSendCondition <- base::local({
[08:25:53.053]                   sendCondition <- NULL
[08:25:53.053]                   function(frame = 1L) {
[08:25:53.053]                     if (is.function(sendCondition)) 
[08:25:53.053]                       return(sendCondition)
[08:25:53.053]                     ns <- getNamespace("parallel")
[08:25:53.053]                     if (exists("sendData", mode = "function", 
[08:25:53.053]                       envir = ns)) {
[08:25:53.053]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.053]                         envir = ns)
[08:25:53.053]                       envir <- sys.frame(frame)
[08:25:53.053]                       master <- NULL
[08:25:53.053]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.053]                         !identical(envir, emptyenv())) {
[08:25:53.053]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.053]                           inherits = FALSE)) {
[08:25:53.053]                           master <- get("master", mode = "list", 
[08:25:53.053]                             envir = envir, inherits = FALSE)
[08:25:53.053]                           if (inherits(master, c("SOCKnode", 
[08:25:53.053]                             "SOCK0node"))) {
[08:25:53.053]                             sendCondition <<- function(cond) {
[08:25:53.053]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.053]                                 success = TRUE)
[08:25:53.053]                               parallel_sendData(master, data)
[08:25:53.053]                             }
[08:25:53.053]                             return(sendCondition)
[08:25:53.053]                           }
[08:25:53.053]                         }
[08:25:53.053]                         frame <- frame + 1L
[08:25:53.053]                         envir <- sys.frame(frame)
[08:25:53.053]                       }
[08:25:53.053]                     }
[08:25:53.053]                     sendCondition <<- function(cond) NULL
[08:25:53.053]                   }
[08:25:53.053]                 })
[08:25:53.053]                 withCallingHandlers({
[08:25:53.053]                   {
[08:25:53.053]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.053]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.053]                       ...future.globals.maxSize)) {
[08:25:53.053]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.053]                       on.exit(options(oopts), add = TRUE)
[08:25:53.053]                     }
[08:25:53.053]                     {
[08:25:53.053]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.053]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.053]                         USE.NAMES = FALSE)
[08:25:53.053]                       do.call(mapply, args = args)
[08:25:53.053]                     }
[08:25:53.053]                   }
[08:25:53.053]                 }, immediateCondition = function(cond) {
[08:25:53.053]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.053]                   sendCondition(cond)
[08:25:53.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.053]                   {
[08:25:53.053]                     inherits <- base::inherits
[08:25:53.053]                     invokeRestart <- base::invokeRestart
[08:25:53.053]                     is.null <- base::is.null
[08:25:53.053]                     muffled <- FALSE
[08:25:53.053]                     if (inherits(cond, "message")) {
[08:25:53.053]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.053]                       if (muffled) 
[08:25:53.053]                         invokeRestart("muffleMessage")
[08:25:53.053]                     }
[08:25:53.053]                     else if (inherits(cond, "warning")) {
[08:25:53.053]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.053]                       if (muffled) 
[08:25:53.053]                         invokeRestart("muffleWarning")
[08:25:53.053]                     }
[08:25:53.053]                     else if (inherits(cond, "condition")) {
[08:25:53.053]                       if (!is.null(pattern)) {
[08:25:53.053]                         computeRestarts <- base::computeRestarts
[08:25:53.053]                         grepl <- base::grepl
[08:25:53.053]                         restarts <- computeRestarts(cond)
[08:25:53.053]                         for (restart in restarts) {
[08:25:53.053]                           name <- restart$name
[08:25:53.053]                           if (is.null(name)) 
[08:25:53.053]                             next
[08:25:53.053]                           if (!grepl(pattern, name)) 
[08:25:53.053]                             next
[08:25:53.053]                           invokeRestart(restart)
[08:25:53.053]                           muffled <- TRUE
[08:25:53.053]                           break
[08:25:53.053]                         }
[08:25:53.053]                       }
[08:25:53.053]                     }
[08:25:53.053]                     invisible(muffled)
[08:25:53.053]                   }
[08:25:53.053]                   muffleCondition(cond)
[08:25:53.053]                 })
[08:25:53.053]             }))
[08:25:53.053]             future::FutureResult(value = ...future.value$value, 
[08:25:53.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.053]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.053]                     ...future.globalenv.names))
[08:25:53.053]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.053]         }, condition = base::local({
[08:25:53.053]             c <- base::c
[08:25:53.053]             inherits <- base::inherits
[08:25:53.053]             invokeRestart <- base::invokeRestart
[08:25:53.053]             length <- base::length
[08:25:53.053]             list <- base::list
[08:25:53.053]             seq.int <- base::seq.int
[08:25:53.053]             signalCondition <- base::signalCondition
[08:25:53.053]             sys.calls <- base::sys.calls
[08:25:53.053]             `[[` <- base::`[[`
[08:25:53.053]             `+` <- base::`+`
[08:25:53.053]             `<<-` <- base::`<<-`
[08:25:53.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.053]                   3L)]
[08:25:53.053]             }
[08:25:53.053]             function(cond) {
[08:25:53.053]                 is_error <- inherits(cond, "error")
[08:25:53.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.053]                   NULL)
[08:25:53.053]                 if (is_error) {
[08:25:53.053]                   sessionInformation <- function() {
[08:25:53.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.053]                       search = base::search(), system = base::Sys.info())
[08:25:53.053]                   }
[08:25:53.053]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.053]                     cond$call), session = sessionInformation(), 
[08:25:53.053]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.053]                   signalCondition(cond)
[08:25:53.053]                 }
[08:25:53.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.053]                 "immediateCondition"))) {
[08:25:53.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.053]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.053]                   if (TRUE && !signal) {
[08:25:53.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.053]                     {
[08:25:53.053]                       inherits <- base::inherits
[08:25:53.053]                       invokeRestart <- base::invokeRestart
[08:25:53.053]                       is.null <- base::is.null
[08:25:53.053]                       muffled <- FALSE
[08:25:53.053]                       if (inherits(cond, "message")) {
[08:25:53.053]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.053]                         if (muffled) 
[08:25:53.053]                           invokeRestart("muffleMessage")
[08:25:53.053]                       }
[08:25:53.053]                       else if (inherits(cond, "warning")) {
[08:25:53.053]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.053]                         if (muffled) 
[08:25:53.053]                           invokeRestart("muffleWarning")
[08:25:53.053]                       }
[08:25:53.053]                       else if (inherits(cond, "condition")) {
[08:25:53.053]                         if (!is.null(pattern)) {
[08:25:53.053]                           computeRestarts <- base::computeRestarts
[08:25:53.053]                           grepl <- base::grepl
[08:25:53.053]                           restarts <- computeRestarts(cond)
[08:25:53.053]                           for (restart in restarts) {
[08:25:53.053]                             name <- restart$name
[08:25:53.053]                             if (is.null(name)) 
[08:25:53.053]                               next
[08:25:53.053]                             if (!grepl(pattern, name)) 
[08:25:53.053]                               next
[08:25:53.053]                             invokeRestart(restart)
[08:25:53.053]                             muffled <- TRUE
[08:25:53.053]                             break
[08:25:53.053]                           }
[08:25:53.053]                         }
[08:25:53.053]                       }
[08:25:53.053]                       invisible(muffled)
[08:25:53.053]                     }
[08:25:53.053]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.053]                   }
[08:25:53.053]                 }
[08:25:53.053]                 else {
[08:25:53.053]                   if (TRUE) {
[08:25:53.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.053]                     {
[08:25:53.053]                       inherits <- base::inherits
[08:25:53.053]                       invokeRestart <- base::invokeRestart
[08:25:53.053]                       is.null <- base::is.null
[08:25:53.053]                       muffled <- FALSE
[08:25:53.053]                       if (inherits(cond, "message")) {
[08:25:53.053]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.053]                         if (muffled) 
[08:25:53.053]                           invokeRestart("muffleMessage")
[08:25:53.053]                       }
[08:25:53.053]                       else if (inherits(cond, "warning")) {
[08:25:53.053]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.053]                         if (muffled) 
[08:25:53.053]                           invokeRestart("muffleWarning")
[08:25:53.053]                       }
[08:25:53.053]                       else if (inherits(cond, "condition")) {
[08:25:53.053]                         if (!is.null(pattern)) {
[08:25:53.053]                           computeRestarts <- base::computeRestarts
[08:25:53.053]                           grepl <- base::grepl
[08:25:53.053]                           restarts <- computeRestarts(cond)
[08:25:53.053]                           for (restart in restarts) {
[08:25:53.053]                             name <- restart$name
[08:25:53.053]                             if (is.null(name)) 
[08:25:53.053]                               next
[08:25:53.053]                             if (!grepl(pattern, name)) 
[08:25:53.053]                               next
[08:25:53.053]                             invokeRestart(restart)
[08:25:53.053]                             muffled <- TRUE
[08:25:53.053]                             break
[08:25:53.053]                           }
[08:25:53.053]                         }
[08:25:53.053]                       }
[08:25:53.053]                       invisible(muffled)
[08:25:53.053]                     }
[08:25:53.053]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.053]                   }
[08:25:53.053]                 }
[08:25:53.053]             }
[08:25:53.053]         }))
[08:25:53.053]     }, error = function(ex) {
[08:25:53.053]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.053]                 ...future.rng), started = ...future.startTime, 
[08:25:53.053]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.053]             version = "1.8"), class = "FutureResult")
[08:25:53.053]     }, finally = {
[08:25:53.053]         if (!identical(...future.workdir, getwd())) 
[08:25:53.053]             setwd(...future.workdir)
[08:25:53.053]         {
[08:25:53.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.053]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.053]             }
[08:25:53.053]             base::options(...future.oldOptions)
[08:25:53.053]             if (.Platform$OS.type == "windows") {
[08:25:53.053]                 old_names <- names(...future.oldEnvVars)
[08:25:53.053]                 envs <- base::Sys.getenv()
[08:25:53.053]                 names <- names(envs)
[08:25:53.053]                 common <- intersect(names, old_names)
[08:25:53.053]                 added <- setdiff(names, old_names)
[08:25:53.053]                 removed <- setdiff(old_names, names)
[08:25:53.053]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.053]                   envs[common]]
[08:25:53.053]                 NAMES <- toupper(changed)
[08:25:53.053]                 args <- list()
[08:25:53.053]                 for (kk in seq_along(NAMES)) {
[08:25:53.053]                   name <- changed[[kk]]
[08:25:53.053]                   NAME <- NAMES[[kk]]
[08:25:53.053]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.053]                     next
[08:25:53.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.053]                 }
[08:25:53.053]                 NAMES <- toupper(added)
[08:25:53.053]                 for (kk in seq_along(NAMES)) {
[08:25:53.053]                   name <- added[[kk]]
[08:25:53.053]                   NAME <- NAMES[[kk]]
[08:25:53.053]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.053]                     next
[08:25:53.053]                   args[[name]] <- ""
[08:25:53.053]                 }
[08:25:53.053]                 NAMES <- toupper(removed)
[08:25:53.053]                 for (kk in seq_along(NAMES)) {
[08:25:53.053]                   name <- removed[[kk]]
[08:25:53.053]                   NAME <- NAMES[[kk]]
[08:25:53.053]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.053]                     next
[08:25:53.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.053]                 }
[08:25:53.053]                 if (length(args) > 0) 
[08:25:53.053]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.053]             }
[08:25:53.053]             else {
[08:25:53.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.053]             }
[08:25:53.053]             {
[08:25:53.053]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.053]                   0L) {
[08:25:53.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.053]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.053]                   base::options(opts)
[08:25:53.053]                 }
[08:25:53.053]                 {
[08:25:53.053]                   {
[08:25:53.053]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.053]                     NULL
[08:25:53.053]                   }
[08:25:53.053]                   options(future.plan = NULL)
[08:25:53.053]                   if (is.na(NA_character_)) 
[08:25:53.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.053]                     .init = FALSE)
[08:25:53.053]                 }
[08:25:53.053]             }
[08:25:53.053]         }
[08:25:53.053]     })
[08:25:53.053]     if (TRUE) {
[08:25:53.053]         base::sink(type = "output", split = FALSE)
[08:25:53.053]         if (TRUE) {
[08:25:53.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.053]         }
[08:25:53.053]         else {
[08:25:53.053]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.053]         }
[08:25:53.053]         base::close(...future.stdout)
[08:25:53.053]         ...future.stdout <- NULL
[08:25:53.053]     }
[08:25:53.053]     ...future.result$conditions <- ...future.conditions
[08:25:53.053]     ...future.result$finished <- base::Sys.time()
[08:25:53.053]     ...future.result
[08:25:53.053] }
[08:25:53.056] Exporting 5 global objects (1.33 KiB) to cluster node #2 ...
[08:25:53.056] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ...
[08:25:53.056] Exporting ‘...future.FUN’ (690 bytes) to cluster node #2 ... DONE
[08:25:53.056] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ...
[08:25:53.057] Exporting ‘MoreArgs’ (31 bytes) to cluster node #2 ... DONE
[08:25:53.057] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ...
[08:25:53.057] Exporting ‘...future.elements_ii’ (134 bytes) to cluster node #2 ... DONE
[08:25:53.057] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:53.058] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.058] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:53.058] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.058] Exporting 5 global objects (1.33 KiB) to cluster node #2 ... DONE
[08:25:53.059] MultisessionFuture started
[08:25:53.059] - Launch lazy future ... done
[08:25:53.059] run() for ‘MultisessionFuture’ ... done
[08:25:53.059] Created future:
[08:25:53.059] MultisessionFuture:
[08:25:53.059] Label: ‘future_.mapply-2’
[08:25:53.059] Expression:
[08:25:53.059] {
[08:25:53.059]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.059]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.059]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.059]         on.exit(options(oopts), add = TRUE)
[08:25:53.059]     }
[08:25:53.059]     {
[08:25:53.059]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.059]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.059]         do.call(mapply, args = args)
[08:25:53.059]     }
[08:25:53.059] }
[08:25:53.059] Lazy evaluation: FALSE
[08:25:53.059] Asynchronous evaluation: TRUE
[08:25:53.059] Local evaluation: TRUE
[08:25:53.059] Environment: R_GlobalEnv
[08:25:53.059] Capture standard output: TRUE
[08:25:53.059] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.059] Globals: 5 objects totaling 909 bytes (function ‘...future.FUN’ of 690 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 134 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.059] Packages: <none>
[08:25:53.059] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.059] Resolved: FALSE
[08:25:53.059] Value: <not collected>
[08:25:53.059] Conditions captured: <none>
[08:25:53.059] Early signaling: FALSE
[08:25:53.059] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.059] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.071] Chunk #2 of 2 ... DONE
[08:25:53.071] Launching 2 futures (chunks) ... DONE
[08:25:53.071] Resolving 2 futures (chunks) ...
[08:25:53.071] resolve() on list ...
[08:25:53.071]  recursive: 0
[08:25:53.071]  length: 2
[08:25:53.071] 
[08:25:53.072] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.072] - Validating connection of MultisessionFuture
[08:25:53.072] - received message: FutureResult
[08:25:53.072] - Received FutureResult
[08:25:53.072] - Erased future from FutureRegistry
[08:25:53.073] result() for ClusterFuture ...
[08:25:53.073] - result already collected: FutureResult
[08:25:53.073] result() for ClusterFuture ... done
[08:25:53.073] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.073] Future #1
[08:25:53.073] result() for ClusterFuture ...
[08:25:53.073] - result already collected: FutureResult
[08:25:53.073] result() for ClusterFuture ... done
[08:25:53.073] result() for ClusterFuture ...
[08:25:53.073] - result already collected: FutureResult
[08:25:53.073] result() for ClusterFuture ... done
[08:25:53.073] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:53.074] - nx: 2
[08:25:53.074] - relay: TRUE
[08:25:53.074] - stdout: TRUE
[08:25:53.074] - signal: TRUE
[08:25:53.074] - resignal: FALSE
[08:25:53.074] - force: TRUE
[08:25:53.074] - relayed: [n=2] FALSE, FALSE
[08:25:53.074] - queued futures: [n=2] FALSE, FALSE
[08:25:53.074]  - until=1
[08:25:53.074]  - relaying element #1
[08:25:53.074] result() for ClusterFuture ...
[08:25:53.074] - result already collected: FutureResult
[08:25:53.075] result() for ClusterFuture ... done
[08:25:53.075] result() for ClusterFuture ...
[08:25:53.075] - result already collected: FutureResult
[08:25:53.075] result() for ClusterFuture ... done
[08:25:53.075] result() for ClusterFuture ...
[08:25:53.075] - result already collected: FutureResult
[08:25:53.075] result() for ClusterFuture ... done
[08:25:53.075] result() for ClusterFuture ...
[08:25:53.075] - result already collected: FutureResult
[08:25:53.075] result() for ClusterFuture ... done
[08:25:53.075] - relayed: [n=2] TRUE, FALSE
[08:25:53.076] - queued futures: [n=2] TRUE, FALSE
[08:25:53.076] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:53.076]  length: 1 (resolved future 1)
[08:25:53.101] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.101] - Validating connection of MultisessionFuture
[08:25:53.102] - received message: FutureResult
[08:25:53.102] - Received FutureResult
[08:25:53.102] - Erased future from FutureRegistry
[08:25:53.102] result() for ClusterFuture ...
[08:25:53.102] - result already collected: FutureResult
[08:25:53.102] result() for ClusterFuture ... done
[08:25:53.102] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.102] Future #2
[08:25:53.102] result() for ClusterFuture ...
[08:25:53.103] - result already collected: FutureResult
[08:25:53.103] result() for ClusterFuture ... done
[08:25:53.103] result() for ClusterFuture ...
[08:25:53.103] - result already collected: FutureResult
[08:25:53.103] result() for ClusterFuture ... done
[08:25:53.103] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:53.103] - nx: 2
[08:25:53.103] - relay: TRUE
[08:25:53.103] - stdout: TRUE
[08:25:53.103] - signal: TRUE
[08:25:53.103] - resignal: FALSE
[08:25:53.104] - force: TRUE
[08:25:53.104] - relayed: [n=2] TRUE, FALSE
[08:25:53.104] - queued futures: [n=2] TRUE, FALSE
[08:25:53.104]  - until=2
[08:25:53.104]  - relaying element #2
[08:25:53.104] result() for ClusterFuture ...
[08:25:53.104] - result already collected: FutureResult
[08:25:53.104] result() for ClusterFuture ... done
[08:25:53.104] result() for ClusterFuture ...
[08:25:53.104] - result already collected: FutureResult
[08:25:53.104] result() for ClusterFuture ... done
[08:25:53.104] result() for ClusterFuture ...
[08:25:53.105] - result already collected: FutureResult
[08:25:53.105] result() for ClusterFuture ... done
[08:25:53.105] result() for ClusterFuture ...
[08:25:53.105] - result already collected: FutureResult
[08:25:53.105] result() for ClusterFuture ... done
[08:25:53.105] - relayed: [n=2] TRUE, TRUE
[08:25:53.105] - queued futures: [n=2] TRUE, TRUE
[08:25:53.105] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:53.105]  length: 0 (resolved future 2)
[08:25:53.105] Relaying remaining futures
[08:25:53.105] signalConditionsASAP(NULL, pos=0) ...
[08:25:53.106] - nx: 2
[08:25:53.106] - relay: TRUE
[08:25:53.106] - stdout: TRUE
[08:25:53.106] - signal: TRUE
[08:25:53.108] - resignal: FALSE
[08:25:53.108] - force: TRUE
[08:25:53.108] - relayed: [n=2] TRUE, TRUE
[08:25:53.109] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:53.109] - relayed: [n=2] TRUE, TRUE
[08:25:53.109] - queued futures: [n=2] TRUE, TRUE
[08:25:53.109] signalConditionsASAP(NULL, pos=0) ... done
[08:25:53.109] resolve() on list ... DONE
[08:25:53.109] result() for ClusterFuture ...
[08:25:53.109] - result already collected: FutureResult
[08:25:53.109] result() for ClusterFuture ... done
[08:25:53.109] result() for ClusterFuture ...
[08:25:53.109] - result already collected: FutureResult
[08:25:53.109] result() for ClusterFuture ... done
[08:25:53.110] result() for ClusterFuture ...
[08:25:53.110] - result already collected: FutureResult
[08:25:53.110] result() for ClusterFuture ... done
[08:25:53.110] result() for ClusterFuture ...
[08:25:53.110] - result already collected: FutureResult
[08:25:53.110] result() for ClusterFuture ... done
[08:25:53.110]  - Number of value chunks collected: 2
[08:25:53.110] Resolving 2 futures (chunks) ... DONE
[08:25:53.110] Reducing values from 2 chunks ...
[08:25:53.110]  - Number of values collected after concatenation: 5
[08:25:53.110]  - Number of values expected: 5
[08:25:53.111] Reducing values from 2 chunks ... DONE
[08:25:53.111] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[08:25:53.111] future_mapply() ...
[08:25:53.112] Number of chunks: 1
[08:25:53.113] getGlobalsAndPackagesXApply() ...
[08:25:53.113]  - future.globals: TRUE
[08:25:53.113] getGlobalsAndPackages() ...
[08:25:53.113] Searching for globals...
[08:25:53.114] - globals found: [1] ‘FUN’
[08:25:53.114] Searching for globals ... DONE
[08:25:53.114] Resolving globals: FALSE
[08:25:53.114] The total size of the 1 globals is 185 bytes (185 bytes)
[08:25:53.115] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:25:53.115] - globals: [1] ‘FUN’
[08:25:53.115] 
[08:25:53.115] getGlobalsAndPackages() ... DONE
[08:25:53.115]  - globals found/used: [n=1] ‘FUN’
[08:25:53.115]  - needed namespaces: [n=0] 
[08:25:53.115] Finding globals ... DONE
[08:25:53.115] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:53.116] List of 2
[08:25:53.116]  $ ...future.FUN:function (x)  
[08:25:53.116]  $ MoreArgs     : NULL
[08:25:53.116]  - attr(*, "where")=List of 2
[08:25:53.116]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:53.116]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:53.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:53.116]  - attr(*, "resolved")= logi FALSE
[08:25:53.116]  - attr(*, "total_size")= num NA
[08:25:53.118] Packages to be attached in all futures: [n=0] 
[08:25:53.118] getGlobalsAndPackagesXApply() ... DONE
[08:25:53.118] Number of futures (= number of chunks): 1
[08:25:53.118] Launching 1 futures (chunks) ...
[08:25:53.119] Chunk #1 of 1 ...
[08:25:53.119]  - Finding globals in '...' for chunk #1 ...
[08:25:53.119] getGlobalsAndPackages() ...
[08:25:53.119] Searching for globals...
[08:25:53.119] 
[08:25:53.119] Searching for globals ... DONE
[08:25:53.119] - globals: [0] <none>
[08:25:53.119] getGlobalsAndPackages() ... DONE
[08:25:53.119]    + additional globals found: [n=0] 
[08:25:53.120]    + additional namespaces needed: [n=0] 
[08:25:53.120]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:53.120]  - seeds: <none>
[08:25:53.120]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.120] getGlobalsAndPackages() ...
[08:25:53.120] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.120] Resolving globals: FALSE
[08:25:53.120] The total size of the 5 globals is 366 bytes (366 bytes)
[08:25:53.121] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 366 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:53.121] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.121] 
[08:25:53.121] getGlobalsAndPackages() ... DONE
[08:25:53.121] run() for ‘Future’ ...
[08:25:53.122] - state: ‘created’
[08:25:53.122] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.135] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.135] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.135]   - Field: ‘node’
[08:25:53.135]   - Field: ‘label’
[08:25:53.136]   - Field: ‘local’
[08:25:53.136]   - Field: ‘owner’
[08:25:53.136]   - Field: ‘envir’
[08:25:53.136]   - Field: ‘workers’
[08:25:53.136]   - Field: ‘packages’
[08:25:53.136]   - Field: ‘gc’
[08:25:53.136]   - Field: ‘conditions’
[08:25:53.136]   - Field: ‘persistent’
[08:25:53.136]   - Field: ‘expr’
[08:25:53.136]   - Field: ‘uuid’
[08:25:53.136]   - Field: ‘seed’
[08:25:53.137]   - Field: ‘version’
[08:25:53.137]   - Field: ‘result’
[08:25:53.137]   - Field: ‘asynchronous’
[08:25:53.137]   - Field: ‘calls’
[08:25:53.137]   - Field: ‘globals’
[08:25:53.137]   - Field: ‘stdout’
[08:25:53.137]   - Field: ‘earlySignal’
[08:25:53.137]   - Field: ‘lazy’
[08:25:53.137]   - Field: ‘state’
[08:25:53.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.137] - Launch lazy future ...
[08:25:53.138] Packages needed by the future expression (n = 0): <none>
[08:25:53.138] Packages needed by future strategies (n = 0): <none>
[08:25:53.138] {
[08:25:53.138]     {
[08:25:53.138]         {
[08:25:53.138]             ...future.startTime <- base::Sys.time()
[08:25:53.138]             {
[08:25:53.138]                 {
[08:25:53.138]                   {
[08:25:53.138]                     {
[08:25:53.138]                       base::local({
[08:25:53.138]                         has_future <- base::requireNamespace("future", 
[08:25:53.138]                           quietly = TRUE)
[08:25:53.138]                         if (has_future) {
[08:25:53.138]                           ns <- base::getNamespace("future")
[08:25:53.138]                           version <- ns[[".package"]][["version"]]
[08:25:53.138]                           if (is.null(version)) 
[08:25:53.138]                             version <- utils::packageVersion("future")
[08:25:53.138]                         }
[08:25:53.138]                         else {
[08:25:53.138]                           version <- NULL
[08:25:53.138]                         }
[08:25:53.138]                         if (!has_future || version < "1.8.0") {
[08:25:53.138]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.138]                             "", base::R.version$version.string), 
[08:25:53.138]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.138]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.138]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.138]                               "release", "version")], collapse = " "), 
[08:25:53.138]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.138]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.138]                             info)
[08:25:53.138]                           info <- base::paste(info, collapse = "; ")
[08:25:53.138]                           if (!has_future) {
[08:25:53.138]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.138]                               info)
[08:25:53.138]                           }
[08:25:53.138]                           else {
[08:25:53.138]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.138]                               info, version)
[08:25:53.138]                           }
[08:25:53.138]                           base::stop(msg)
[08:25:53.138]                         }
[08:25:53.138]                       })
[08:25:53.138]                     }
[08:25:53.138]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.138]                     base::options(mc.cores = 1L)
[08:25:53.138]                   }
[08:25:53.138]                   ...future.strategy.old <- future::plan("list")
[08:25:53.138]                   options(future.plan = NULL)
[08:25:53.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.138]                 }
[08:25:53.138]                 ...future.workdir <- getwd()
[08:25:53.138]             }
[08:25:53.138]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.138]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.138]         }
[08:25:53.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:53.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.138]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.138]             base::names(...future.oldOptions))
[08:25:53.138]     }
[08:25:53.138]     if (FALSE) {
[08:25:53.138]     }
[08:25:53.138]     else {
[08:25:53.138]         if (TRUE) {
[08:25:53.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.138]                 open = "w")
[08:25:53.138]         }
[08:25:53.138]         else {
[08:25:53.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.138]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.138]         }
[08:25:53.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.138]             base::sink(type = "output", split = FALSE)
[08:25:53.138]             base::close(...future.stdout)
[08:25:53.138]         }, add = TRUE)
[08:25:53.138]     }
[08:25:53.138]     ...future.frame <- base::sys.nframe()
[08:25:53.138]     ...future.conditions <- base::list()
[08:25:53.138]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.138]     if (FALSE) {
[08:25:53.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.138]     }
[08:25:53.138]     ...future.result <- base::tryCatch({
[08:25:53.138]         base::withCallingHandlers({
[08:25:53.138]             ...future.value <- base::withVisible(base::local({
[08:25:53.138]                 ...future.makeSendCondition <- base::local({
[08:25:53.138]                   sendCondition <- NULL
[08:25:53.138]                   function(frame = 1L) {
[08:25:53.138]                     if (is.function(sendCondition)) 
[08:25:53.138]                       return(sendCondition)
[08:25:53.138]                     ns <- getNamespace("parallel")
[08:25:53.138]                     if (exists("sendData", mode = "function", 
[08:25:53.138]                       envir = ns)) {
[08:25:53.138]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.138]                         envir = ns)
[08:25:53.138]                       envir <- sys.frame(frame)
[08:25:53.138]                       master <- NULL
[08:25:53.138]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.138]                         !identical(envir, emptyenv())) {
[08:25:53.138]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.138]                           inherits = FALSE)) {
[08:25:53.138]                           master <- get("master", mode = "list", 
[08:25:53.138]                             envir = envir, inherits = FALSE)
[08:25:53.138]                           if (inherits(master, c("SOCKnode", 
[08:25:53.138]                             "SOCK0node"))) {
[08:25:53.138]                             sendCondition <<- function(cond) {
[08:25:53.138]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.138]                                 success = TRUE)
[08:25:53.138]                               parallel_sendData(master, data)
[08:25:53.138]                             }
[08:25:53.138]                             return(sendCondition)
[08:25:53.138]                           }
[08:25:53.138]                         }
[08:25:53.138]                         frame <- frame + 1L
[08:25:53.138]                         envir <- sys.frame(frame)
[08:25:53.138]                       }
[08:25:53.138]                     }
[08:25:53.138]                     sendCondition <<- function(cond) NULL
[08:25:53.138]                   }
[08:25:53.138]                 })
[08:25:53.138]                 withCallingHandlers({
[08:25:53.138]                   {
[08:25:53.138]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.138]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.138]                       ...future.globals.maxSize)) {
[08:25:53.138]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.138]                       on.exit(options(oopts), add = TRUE)
[08:25:53.138]                     }
[08:25:53.138]                     {
[08:25:53.138]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.138]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.138]                         USE.NAMES = FALSE)
[08:25:53.138]                       do.call(mapply, args = args)
[08:25:53.138]                     }
[08:25:53.138]                   }
[08:25:53.138]                 }, immediateCondition = function(cond) {
[08:25:53.138]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.138]                   sendCondition(cond)
[08:25:53.138]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.138]                   {
[08:25:53.138]                     inherits <- base::inherits
[08:25:53.138]                     invokeRestart <- base::invokeRestart
[08:25:53.138]                     is.null <- base::is.null
[08:25:53.138]                     muffled <- FALSE
[08:25:53.138]                     if (inherits(cond, "message")) {
[08:25:53.138]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.138]                       if (muffled) 
[08:25:53.138]                         invokeRestart("muffleMessage")
[08:25:53.138]                     }
[08:25:53.138]                     else if (inherits(cond, "warning")) {
[08:25:53.138]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.138]                       if (muffled) 
[08:25:53.138]                         invokeRestart("muffleWarning")
[08:25:53.138]                     }
[08:25:53.138]                     else if (inherits(cond, "condition")) {
[08:25:53.138]                       if (!is.null(pattern)) {
[08:25:53.138]                         computeRestarts <- base::computeRestarts
[08:25:53.138]                         grepl <- base::grepl
[08:25:53.138]                         restarts <- computeRestarts(cond)
[08:25:53.138]                         for (restart in restarts) {
[08:25:53.138]                           name <- restart$name
[08:25:53.138]                           if (is.null(name)) 
[08:25:53.138]                             next
[08:25:53.138]                           if (!grepl(pattern, name)) 
[08:25:53.138]                             next
[08:25:53.138]                           invokeRestart(restart)
[08:25:53.138]                           muffled <- TRUE
[08:25:53.138]                           break
[08:25:53.138]                         }
[08:25:53.138]                       }
[08:25:53.138]                     }
[08:25:53.138]                     invisible(muffled)
[08:25:53.138]                   }
[08:25:53.138]                   muffleCondition(cond)
[08:25:53.138]                 })
[08:25:53.138]             }))
[08:25:53.138]             future::FutureResult(value = ...future.value$value, 
[08:25:53.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.138]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.138]                     ...future.globalenv.names))
[08:25:53.138]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.138]         }, condition = base::local({
[08:25:53.138]             c <- base::c
[08:25:53.138]             inherits <- base::inherits
[08:25:53.138]             invokeRestart <- base::invokeRestart
[08:25:53.138]             length <- base::length
[08:25:53.138]             list <- base::list
[08:25:53.138]             seq.int <- base::seq.int
[08:25:53.138]             signalCondition <- base::signalCondition
[08:25:53.138]             sys.calls <- base::sys.calls
[08:25:53.138]             `[[` <- base::`[[`
[08:25:53.138]             `+` <- base::`+`
[08:25:53.138]             `<<-` <- base::`<<-`
[08:25:53.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.138]                   3L)]
[08:25:53.138]             }
[08:25:53.138]             function(cond) {
[08:25:53.138]                 is_error <- inherits(cond, "error")
[08:25:53.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.138]                   NULL)
[08:25:53.138]                 if (is_error) {
[08:25:53.138]                   sessionInformation <- function() {
[08:25:53.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.138]                       search = base::search(), system = base::Sys.info())
[08:25:53.138]                   }
[08:25:53.138]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.138]                     cond$call), session = sessionInformation(), 
[08:25:53.138]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.138]                   signalCondition(cond)
[08:25:53.138]                 }
[08:25:53.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.138]                 "immediateCondition"))) {
[08:25:53.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.138]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.138]                   if (TRUE && !signal) {
[08:25:53.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.138]                     {
[08:25:53.138]                       inherits <- base::inherits
[08:25:53.138]                       invokeRestart <- base::invokeRestart
[08:25:53.138]                       is.null <- base::is.null
[08:25:53.138]                       muffled <- FALSE
[08:25:53.138]                       if (inherits(cond, "message")) {
[08:25:53.138]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.138]                         if (muffled) 
[08:25:53.138]                           invokeRestart("muffleMessage")
[08:25:53.138]                       }
[08:25:53.138]                       else if (inherits(cond, "warning")) {
[08:25:53.138]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.138]                         if (muffled) 
[08:25:53.138]                           invokeRestart("muffleWarning")
[08:25:53.138]                       }
[08:25:53.138]                       else if (inherits(cond, "condition")) {
[08:25:53.138]                         if (!is.null(pattern)) {
[08:25:53.138]                           computeRestarts <- base::computeRestarts
[08:25:53.138]                           grepl <- base::grepl
[08:25:53.138]                           restarts <- computeRestarts(cond)
[08:25:53.138]                           for (restart in restarts) {
[08:25:53.138]                             name <- restart$name
[08:25:53.138]                             if (is.null(name)) 
[08:25:53.138]                               next
[08:25:53.138]                             if (!grepl(pattern, name)) 
[08:25:53.138]                               next
[08:25:53.138]                             invokeRestart(restart)
[08:25:53.138]                             muffled <- TRUE
[08:25:53.138]                             break
[08:25:53.138]                           }
[08:25:53.138]                         }
[08:25:53.138]                       }
[08:25:53.138]                       invisible(muffled)
[08:25:53.138]                     }
[08:25:53.138]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.138]                   }
[08:25:53.138]                 }
[08:25:53.138]                 else {
[08:25:53.138]                   if (TRUE) {
[08:25:53.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.138]                     {
[08:25:53.138]                       inherits <- base::inherits
[08:25:53.138]                       invokeRestart <- base::invokeRestart
[08:25:53.138]                       is.null <- base::is.null
[08:25:53.138]                       muffled <- FALSE
[08:25:53.138]                       if (inherits(cond, "message")) {
[08:25:53.138]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.138]                         if (muffled) 
[08:25:53.138]                           invokeRestart("muffleMessage")
[08:25:53.138]                       }
[08:25:53.138]                       else if (inherits(cond, "warning")) {
[08:25:53.138]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.138]                         if (muffled) 
[08:25:53.138]                           invokeRestart("muffleWarning")
[08:25:53.138]                       }
[08:25:53.138]                       else if (inherits(cond, "condition")) {
[08:25:53.138]                         if (!is.null(pattern)) {
[08:25:53.138]                           computeRestarts <- base::computeRestarts
[08:25:53.138]                           grepl <- base::grepl
[08:25:53.138]                           restarts <- computeRestarts(cond)
[08:25:53.138]                           for (restart in restarts) {
[08:25:53.138]                             name <- restart$name
[08:25:53.138]                             if (is.null(name)) 
[08:25:53.138]                               next
[08:25:53.138]                             if (!grepl(pattern, name)) 
[08:25:53.138]                               next
[08:25:53.138]                             invokeRestart(restart)
[08:25:53.138]                             muffled <- TRUE
[08:25:53.138]                             break
[08:25:53.138]                           }
[08:25:53.138]                         }
[08:25:53.138]                       }
[08:25:53.138]                       invisible(muffled)
[08:25:53.138]                     }
[08:25:53.138]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.138]                   }
[08:25:53.138]                 }
[08:25:53.138]             }
[08:25:53.138]         }))
[08:25:53.138]     }, error = function(ex) {
[08:25:53.138]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.138]                 ...future.rng), started = ...future.startTime, 
[08:25:53.138]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.138]             version = "1.8"), class = "FutureResult")
[08:25:53.138]     }, finally = {
[08:25:53.138]         if (!identical(...future.workdir, getwd())) 
[08:25:53.138]             setwd(...future.workdir)
[08:25:53.138]         {
[08:25:53.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.138]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.138]             }
[08:25:53.138]             base::options(...future.oldOptions)
[08:25:53.138]             if (.Platform$OS.type == "windows") {
[08:25:53.138]                 old_names <- names(...future.oldEnvVars)
[08:25:53.138]                 envs <- base::Sys.getenv()
[08:25:53.138]                 names <- names(envs)
[08:25:53.138]                 common <- intersect(names, old_names)
[08:25:53.138]                 added <- setdiff(names, old_names)
[08:25:53.138]                 removed <- setdiff(old_names, names)
[08:25:53.138]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.138]                   envs[common]]
[08:25:53.138]                 NAMES <- toupper(changed)
[08:25:53.138]                 args <- list()
[08:25:53.138]                 for (kk in seq_along(NAMES)) {
[08:25:53.138]                   name <- changed[[kk]]
[08:25:53.138]                   NAME <- NAMES[[kk]]
[08:25:53.138]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.138]                     next
[08:25:53.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.138]                 }
[08:25:53.138]                 NAMES <- toupper(added)
[08:25:53.138]                 for (kk in seq_along(NAMES)) {
[08:25:53.138]                   name <- added[[kk]]
[08:25:53.138]                   NAME <- NAMES[[kk]]
[08:25:53.138]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.138]                     next
[08:25:53.138]                   args[[name]] <- ""
[08:25:53.138]                 }
[08:25:53.138]                 NAMES <- toupper(removed)
[08:25:53.138]                 for (kk in seq_along(NAMES)) {
[08:25:53.138]                   name <- removed[[kk]]
[08:25:53.138]                   NAME <- NAMES[[kk]]
[08:25:53.138]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.138]                     next
[08:25:53.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.138]                 }
[08:25:53.138]                 if (length(args) > 0) 
[08:25:53.138]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.138]             }
[08:25:53.138]             else {
[08:25:53.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.138]             }
[08:25:53.138]             {
[08:25:53.138]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.138]                   0L) {
[08:25:53.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.138]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.138]                   base::options(opts)
[08:25:53.138]                 }
[08:25:53.138]                 {
[08:25:53.138]                   {
[08:25:53.138]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.138]                     NULL
[08:25:53.138]                   }
[08:25:53.138]                   options(future.plan = NULL)
[08:25:53.138]                   if (is.na(NA_character_)) 
[08:25:53.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.138]                     .init = FALSE)
[08:25:53.138]                 }
[08:25:53.138]             }
[08:25:53.138]         }
[08:25:53.138]     })
[08:25:53.138]     if (TRUE) {
[08:25:53.138]         base::sink(type = "output", split = FALSE)
[08:25:53.138]         if (TRUE) {
[08:25:53.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.138]         }
[08:25:53.138]         else {
[08:25:53.138]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.138]         }
[08:25:53.138]         base::close(...future.stdout)
[08:25:53.138]         ...future.stdout <- NULL
[08:25:53.138]     }
[08:25:53.138]     ...future.result$conditions <- ...future.conditions
[08:25:53.138]     ...future.result$finished <- base::Sys.time()
[08:25:53.138]     ...future.result
[08:25:53.138] }
[08:25:53.141] Exporting 5 global objects (803 bytes) to cluster node #1 ...
[08:25:53.141] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[08:25:53.142] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[08:25:53.142] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:53.142] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.142] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ...
[08:25:53.143] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ... DONE
[08:25:53.143] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:53.143] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.143] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:53.144] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.144] Exporting 5 global objects (803 bytes) to cluster node #1 ... DONE
[08:25:53.144] MultisessionFuture started
[08:25:53.144] - Launch lazy future ... done
[08:25:53.144] run() for ‘MultisessionFuture’ ... done
[08:25:53.144] Created future:
[08:25:53.145] MultisessionFuture:
[08:25:53.145] Label: ‘future_mapply-1’
[08:25:53.145] Expression:
[08:25:53.145] {
[08:25:53.145]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.145]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.145]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.145]         on.exit(options(oopts), add = TRUE)
[08:25:53.145]     }
[08:25:53.145]     {
[08:25:53.145]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.145]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.145]         do.call(mapply, args = args)
[08:25:53.145]     }
[08:25:53.145] }
[08:25:53.145] Lazy evaluation: FALSE
[08:25:53.145] Asynchronous evaluation: TRUE
[08:25:53.145] Local evaluation: TRUE
[08:25:53.145] Environment: R_GlobalEnv
[08:25:53.145] Capture standard output: TRUE
[08:25:53.145] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.145] Globals: 5 objects totaling 366 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.145] Packages: <none>
[08:25:53.145] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.145] Resolved: FALSE
[08:25:53.145] Value: <not collected>
[08:25:53.145] Conditions captured: <none>
[08:25:53.145] Early signaling: FALSE
[08:25:53.145] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.145] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.156] Chunk #1 of 1 ... DONE
[08:25:53.156] Launching 1 futures (chunks) ... DONE
[08:25:53.156] Resolving 1 futures (chunks) ...
[08:25:53.156] resolve() on list ...
[08:25:53.156]  recursive: 0
[08:25:53.156]  length: 1
[08:25:53.157] 
[08:25:53.186] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.186] - Validating connection of MultisessionFuture
[08:25:53.187] - received message: FutureResult
[08:25:53.187] - Received FutureResult
[08:25:53.187] - Erased future from FutureRegistry
[08:25:53.187] result() for ClusterFuture ...
[08:25:53.187] - result already collected: FutureResult
[08:25:53.187] result() for ClusterFuture ... done
[08:25:53.187] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.187] Future #1
[08:25:53.187] result() for ClusterFuture ...
[08:25:53.188] - result already collected: FutureResult
[08:25:53.188] result() for ClusterFuture ... done
[08:25:53.188] result() for ClusterFuture ...
[08:25:53.188] - result already collected: FutureResult
[08:25:53.188] result() for ClusterFuture ... done
[08:25:53.188] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:53.188] - nx: 1
[08:25:53.188] - relay: TRUE
[08:25:53.188] - stdout: TRUE
[08:25:53.188] - signal: TRUE
[08:25:53.188] - resignal: FALSE
[08:25:53.189] - force: TRUE
[08:25:53.189] - relayed: [n=1] FALSE
[08:25:53.189] - queued futures: [n=1] FALSE
[08:25:53.189]  - until=1
[08:25:53.189]  - relaying element #1
[08:25:53.189] result() for ClusterFuture ...
[08:25:53.189] - result already collected: FutureResult
[08:25:53.189] result() for ClusterFuture ... done
[08:25:53.189] result() for ClusterFuture ...
[08:25:53.189] - result already collected: FutureResult
[08:25:53.189] result() for ClusterFuture ... done
[08:25:53.190] result() for ClusterFuture ...
[08:25:53.190] - result already collected: FutureResult
[08:25:53.190] result() for ClusterFuture ... done
[08:25:53.190] result() for ClusterFuture ...
[08:25:53.190] - result already collected: FutureResult
[08:25:53.190] result() for ClusterFuture ... done
[08:25:53.190] - relayed: [n=1] TRUE
[08:25:53.190] - queued futures: [n=1] TRUE
[08:25:53.190] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:53.190]  length: 0 (resolved future 1)
[08:25:53.190] Relaying remaining futures
[08:25:53.190] signalConditionsASAP(NULL, pos=0) ...
[08:25:53.191] - nx: 1
[08:25:53.191] - relay: TRUE
[08:25:53.191] - stdout: TRUE
[08:25:53.191] - signal: TRUE
[08:25:53.191] - resignal: FALSE
[08:25:53.191] - force: TRUE
[08:25:53.191] - relayed: [n=1] TRUE
[08:25:53.191] - queued futures: [n=1] TRUE
 - flush all
[08:25:53.191] - relayed: [n=1] TRUE
[08:25:53.191] - queued futures: [n=1] TRUE
[08:25:53.191] signalConditionsASAP(NULL, pos=0) ... done
[08:25:53.191] resolve() on list ... DONE
[08:25:53.192] result() for ClusterFuture ...
[08:25:53.192] - result already collected: FutureResult
[08:25:53.192] result() for ClusterFuture ... done
[08:25:53.192] result() for ClusterFuture ...
[08:25:53.192] - result already collected: FutureResult
[08:25:53.192] result() for ClusterFuture ... done
[08:25:53.192]  - Number of value chunks collected: 1
[08:25:53.192] Resolving 1 futures (chunks) ... DONE
[08:25:53.192] Reducing values from 1 chunks ...
[08:25:53.192]  - Number of values collected after concatenation: 1
[08:25:53.192]  - Number of values expected: 1
[08:25:53.193] Reducing values from 1 chunks ... DONE
[08:25:53.193] future_mapply() ... DONE
[08:25:53.193] future_mapply() ...
[08:25:53.194] Number of chunks: 1
[08:25:53.194] getGlobalsAndPackagesXApply() ...
[08:25:53.194]  - future.globals: TRUE
[08:25:53.195] getGlobalsAndPackages() ...
[08:25:53.195] Searching for globals...
[08:25:53.196] - globals found: [1] ‘FUN’
[08:25:53.196] Searching for globals ... DONE
[08:25:53.196] Resolving globals: FALSE
[08:25:53.196] The total size of the 1 globals is 185 bytes (185 bytes)
[08:25:53.197] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:25:53.197] - globals: [1] ‘FUN’
[08:25:53.197] 
[08:25:53.197] getGlobalsAndPackages() ... DONE
[08:25:53.197]  - globals found/used: [n=1] ‘FUN’
[08:25:53.197]  - needed namespaces: [n=0] 
[08:25:53.197] Finding globals ... DONE
[08:25:53.197] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:53.197] List of 2
[08:25:53.197]  $ ...future.FUN:function (x)  
[08:25:53.197]  $ MoreArgs     : list()
[08:25:53.197]  - attr(*, "where")=List of 2
[08:25:53.197]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:53.197]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:53.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:53.197]  - attr(*, "resolved")= logi FALSE
[08:25:53.197]  - attr(*, "total_size")= num NA
[08:25:53.200] Packages to be attached in all futures: [n=0] 
[08:25:53.200] getGlobalsAndPackagesXApply() ... DONE
[08:25:53.200] Number of futures (= number of chunks): 1
[08:25:53.200] Launching 1 futures (chunks) ...
[08:25:53.200] Chunk #1 of 1 ...
[08:25:53.201]  - Finding globals in '...' for chunk #1 ...
[08:25:53.201] getGlobalsAndPackages() ...
[08:25:53.201] Searching for globals...
[08:25:53.201] 
[08:25:53.201] Searching for globals ... DONE
[08:25:53.201] - globals: [0] <none>
[08:25:53.201] getGlobalsAndPackages() ... DONE
[08:25:53.201]    + additional globals found: [n=0] 
[08:25:53.201]    + additional namespaces needed: [n=0] 
[08:25:53.202]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:53.202]  - seeds: <none>
[08:25:53.202]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.202] getGlobalsAndPackages() ...
[08:25:53.202] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.202] Resolving globals: FALSE
[08:25:53.202] The total size of the 5 globals is 370 bytes (370 bytes)
[08:25:53.203] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 370 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (100 bytes of class ‘list’) and ‘MoreArgs’ (31 bytes of class ‘list’)
[08:25:53.203] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.203] 
[08:25:53.203] getGlobalsAndPackages() ... DONE
[08:25:53.203] run() for ‘Future’ ...
[08:25:53.204] - state: ‘created’
[08:25:53.204] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.217] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.218]   - Field: ‘node’
[08:25:53.218]   - Field: ‘label’
[08:25:53.218]   - Field: ‘local’
[08:25:53.218]   - Field: ‘owner’
[08:25:53.218]   - Field: ‘envir’
[08:25:53.218]   - Field: ‘workers’
[08:25:53.218]   - Field: ‘packages’
[08:25:53.218]   - Field: ‘gc’
[08:25:53.218]   - Field: ‘conditions’
[08:25:53.218]   - Field: ‘persistent’
[08:25:53.218]   - Field: ‘expr’
[08:25:53.219]   - Field: ‘uuid’
[08:25:53.219]   - Field: ‘seed’
[08:25:53.219]   - Field: ‘version’
[08:25:53.219]   - Field: ‘result’
[08:25:53.219]   - Field: ‘asynchronous’
[08:25:53.219]   - Field: ‘calls’
[08:25:53.219]   - Field: ‘globals’
[08:25:53.219]   - Field: ‘stdout’
[08:25:53.219]   - Field: ‘earlySignal’
[08:25:53.219]   - Field: ‘lazy’
[08:25:53.219]   - Field: ‘state’
[08:25:53.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.220] - Launch lazy future ...
[08:25:53.220] Packages needed by the future expression (n = 0): <none>
[08:25:53.220] Packages needed by future strategies (n = 0): <none>
[08:25:53.220] {
[08:25:53.220]     {
[08:25:53.220]         {
[08:25:53.220]             ...future.startTime <- base::Sys.time()
[08:25:53.220]             {
[08:25:53.220]                 {
[08:25:53.220]                   {
[08:25:53.220]                     {
[08:25:53.220]                       base::local({
[08:25:53.220]                         has_future <- base::requireNamespace("future", 
[08:25:53.220]                           quietly = TRUE)
[08:25:53.220]                         if (has_future) {
[08:25:53.220]                           ns <- base::getNamespace("future")
[08:25:53.220]                           version <- ns[[".package"]][["version"]]
[08:25:53.220]                           if (is.null(version)) 
[08:25:53.220]                             version <- utils::packageVersion("future")
[08:25:53.220]                         }
[08:25:53.220]                         else {
[08:25:53.220]                           version <- NULL
[08:25:53.220]                         }
[08:25:53.220]                         if (!has_future || version < "1.8.0") {
[08:25:53.220]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.220]                             "", base::R.version$version.string), 
[08:25:53.220]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.220]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.220]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.220]                               "release", "version")], collapse = " "), 
[08:25:53.220]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.220]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.220]                             info)
[08:25:53.220]                           info <- base::paste(info, collapse = "; ")
[08:25:53.220]                           if (!has_future) {
[08:25:53.220]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.220]                               info)
[08:25:53.220]                           }
[08:25:53.220]                           else {
[08:25:53.220]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.220]                               info, version)
[08:25:53.220]                           }
[08:25:53.220]                           base::stop(msg)
[08:25:53.220]                         }
[08:25:53.220]                       })
[08:25:53.220]                     }
[08:25:53.220]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.220]                     base::options(mc.cores = 1L)
[08:25:53.220]                   }
[08:25:53.220]                   ...future.strategy.old <- future::plan("list")
[08:25:53.220]                   options(future.plan = NULL)
[08:25:53.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.220]                 }
[08:25:53.220]                 ...future.workdir <- getwd()
[08:25:53.220]             }
[08:25:53.220]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.220]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.220]         }
[08:25:53.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:25:53.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.220]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.220]             base::names(...future.oldOptions))
[08:25:53.220]     }
[08:25:53.220]     if (FALSE) {
[08:25:53.220]     }
[08:25:53.220]     else {
[08:25:53.220]         if (TRUE) {
[08:25:53.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.220]                 open = "w")
[08:25:53.220]         }
[08:25:53.220]         else {
[08:25:53.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.220]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.220]         }
[08:25:53.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.220]             base::sink(type = "output", split = FALSE)
[08:25:53.220]             base::close(...future.stdout)
[08:25:53.220]         }, add = TRUE)
[08:25:53.220]     }
[08:25:53.220]     ...future.frame <- base::sys.nframe()
[08:25:53.220]     ...future.conditions <- base::list()
[08:25:53.220]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.220]     if (FALSE) {
[08:25:53.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.220]     }
[08:25:53.220]     ...future.result <- base::tryCatch({
[08:25:53.220]         base::withCallingHandlers({
[08:25:53.220]             ...future.value <- base::withVisible(base::local({
[08:25:53.220]                 ...future.makeSendCondition <- base::local({
[08:25:53.220]                   sendCondition <- NULL
[08:25:53.220]                   function(frame = 1L) {
[08:25:53.220]                     if (is.function(sendCondition)) 
[08:25:53.220]                       return(sendCondition)
[08:25:53.220]                     ns <- getNamespace("parallel")
[08:25:53.220]                     if (exists("sendData", mode = "function", 
[08:25:53.220]                       envir = ns)) {
[08:25:53.220]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.220]                         envir = ns)
[08:25:53.220]                       envir <- sys.frame(frame)
[08:25:53.220]                       master <- NULL
[08:25:53.220]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.220]                         !identical(envir, emptyenv())) {
[08:25:53.220]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.220]                           inherits = FALSE)) {
[08:25:53.220]                           master <- get("master", mode = "list", 
[08:25:53.220]                             envir = envir, inherits = FALSE)
[08:25:53.220]                           if (inherits(master, c("SOCKnode", 
[08:25:53.220]                             "SOCK0node"))) {
[08:25:53.220]                             sendCondition <<- function(cond) {
[08:25:53.220]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.220]                                 success = TRUE)
[08:25:53.220]                               parallel_sendData(master, data)
[08:25:53.220]                             }
[08:25:53.220]                             return(sendCondition)
[08:25:53.220]                           }
[08:25:53.220]                         }
[08:25:53.220]                         frame <- frame + 1L
[08:25:53.220]                         envir <- sys.frame(frame)
[08:25:53.220]                       }
[08:25:53.220]                     }
[08:25:53.220]                     sendCondition <<- function(cond) NULL
[08:25:53.220]                   }
[08:25:53.220]                 })
[08:25:53.220]                 withCallingHandlers({
[08:25:53.220]                   {
[08:25:53.220]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.220]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.220]                       ...future.globals.maxSize)) {
[08:25:53.220]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.220]                       on.exit(options(oopts), add = TRUE)
[08:25:53.220]                     }
[08:25:53.220]                     {
[08:25:53.220]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.220]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.220]                         USE.NAMES = FALSE)
[08:25:53.220]                       do.call(mapply, args = args)
[08:25:53.220]                     }
[08:25:53.220]                   }
[08:25:53.220]                 }, immediateCondition = function(cond) {
[08:25:53.220]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.220]                   sendCondition(cond)
[08:25:53.220]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.220]                   {
[08:25:53.220]                     inherits <- base::inherits
[08:25:53.220]                     invokeRestart <- base::invokeRestart
[08:25:53.220]                     is.null <- base::is.null
[08:25:53.220]                     muffled <- FALSE
[08:25:53.220]                     if (inherits(cond, "message")) {
[08:25:53.220]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.220]                       if (muffled) 
[08:25:53.220]                         invokeRestart("muffleMessage")
[08:25:53.220]                     }
[08:25:53.220]                     else if (inherits(cond, "warning")) {
[08:25:53.220]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.220]                       if (muffled) 
[08:25:53.220]                         invokeRestart("muffleWarning")
[08:25:53.220]                     }
[08:25:53.220]                     else if (inherits(cond, "condition")) {
[08:25:53.220]                       if (!is.null(pattern)) {
[08:25:53.220]                         computeRestarts <- base::computeRestarts
[08:25:53.220]                         grepl <- base::grepl
[08:25:53.220]                         restarts <- computeRestarts(cond)
[08:25:53.220]                         for (restart in restarts) {
[08:25:53.220]                           name <- restart$name
[08:25:53.220]                           if (is.null(name)) 
[08:25:53.220]                             next
[08:25:53.220]                           if (!grepl(pattern, name)) 
[08:25:53.220]                             next
[08:25:53.220]                           invokeRestart(restart)
[08:25:53.220]                           muffled <- TRUE
[08:25:53.220]                           break
[08:25:53.220]                         }
[08:25:53.220]                       }
[08:25:53.220]                     }
[08:25:53.220]                     invisible(muffled)
[08:25:53.220]                   }
[08:25:53.220]                   muffleCondition(cond)
[08:25:53.220]                 })
[08:25:53.220]             }))
[08:25:53.220]             future::FutureResult(value = ...future.value$value, 
[08:25:53.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.220]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.220]                     ...future.globalenv.names))
[08:25:53.220]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.220]         }, condition = base::local({
[08:25:53.220]             c <- base::c
[08:25:53.220]             inherits <- base::inherits
[08:25:53.220]             invokeRestart <- base::invokeRestart
[08:25:53.220]             length <- base::length
[08:25:53.220]             list <- base::list
[08:25:53.220]             seq.int <- base::seq.int
[08:25:53.220]             signalCondition <- base::signalCondition
[08:25:53.220]             sys.calls <- base::sys.calls
[08:25:53.220]             `[[` <- base::`[[`
[08:25:53.220]             `+` <- base::`+`
[08:25:53.220]             `<<-` <- base::`<<-`
[08:25:53.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.220]                   3L)]
[08:25:53.220]             }
[08:25:53.220]             function(cond) {
[08:25:53.220]                 is_error <- inherits(cond, "error")
[08:25:53.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.220]                   NULL)
[08:25:53.220]                 if (is_error) {
[08:25:53.220]                   sessionInformation <- function() {
[08:25:53.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.220]                       search = base::search(), system = base::Sys.info())
[08:25:53.220]                   }
[08:25:53.220]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.220]                     cond$call), session = sessionInformation(), 
[08:25:53.220]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.220]                   signalCondition(cond)
[08:25:53.220]                 }
[08:25:53.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.220]                 "immediateCondition"))) {
[08:25:53.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.220]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.220]                   if (TRUE && !signal) {
[08:25:53.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.220]                     {
[08:25:53.220]                       inherits <- base::inherits
[08:25:53.220]                       invokeRestart <- base::invokeRestart
[08:25:53.220]                       is.null <- base::is.null
[08:25:53.220]                       muffled <- FALSE
[08:25:53.220]                       if (inherits(cond, "message")) {
[08:25:53.220]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.220]                         if (muffled) 
[08:25:53.220]                           invokeRestart("muffleMessage")
[08:25:53.220]                       }
[08:25:53.220]                       else if (inherits(cond, "warning")) {
[08:25:53.220]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.220]                         if (muffled) 
[08:25:53.220]                           invokeRestart("muffleWarning")
[08:25:53.220]                       }
[08:25:53.220]                       else if (inherits(cond, "condition")) {
[08:25:53.220]                         if (!is.null(pattern)) {
[08:25:53.220]                           computeRestarts <- base::computeRestarts
[08:25:53.220]                           grepl <- base::grepl
[08:25:53.220]                           restarts <- computeRestarts(cond)
[08:25:53.220]                           for (restart in restarts) {
[08:25:53.220]                             name <- restart$name
[08:25:53.220]                             if (is.null(name)) 
[08:25:53.220]                               next
[08:25:53.220]                             if (!grepl(pattern, name)) 
[08:25:53.220]                               next
[08:25:53.220]                             invokeRestart(restart)
[08:25:53.220]                             muffled <- TRUE
[08:25:53.220]                             break
[08:25:53.220]                           }
[08:25:53.220]                         }
[08:25:53.220]                       }
[08:25:53.220]                       invisible(muffled)
[08:25:53.220]                     }
[08:25:53.220]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.220]                   }
[08:25:53.220]                 }
[08:25:53.220]                 else {
[08:25:53.220]                   if (TRUE) {
[08:25:53.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.220]                     {
[08:25:53.220]                       inherits <- base::inherits
[08:25:53.220]                       invokeRestart <- base::invokeRestart
[08:25:53.220]                       is.null <- base::is.null
[08:25:53.220]                       muffled <- FALSE
[08:25:53.220]                       if (inherits(cond, "message")) {
[08:25:53.220]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.220]                         if (muffled) 
[08:25:53.220]                           invokeRestart("muffleMessage")
[08:25:53.220]                       }
[08:25:53.220]                       else if (inherits(cond, "warning")) {
[08:25:53.220]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.220]                         if (muffled) 
[08:25:53.220]                           invokeRestart("muffleWarning")
[08:25:53.220]                       }
[08:25:53.220]                       else if (inherits(cond, "condition")) {
[08:25:53.220]                         if (!is.null(pattern)) {
[08:25:53.220]                           computeRestarts <- base::computeRestarts
[08:25:53.220]                           grepl <- base::grepl
[08:25:53.220]                           restarts <- computeRestarts(cond)
[08:25:53.220]                           for (restart in restarts) {
[08:25:53.220]                             name <- restart$name
[08:25:53.220]                             if (is.null(name)) 
[08:25:53.220]                               next
[08:25:53.220]                             if (!grepl(pattern, name)) 
[08:25:53.220]                               next
[08:25:53.220]                             invokeRestart(restart)
[08:25:53.220]                             muffled <- TRUE
[08:25:53.220]                             break
[08:25:53.220]                           }
[08:25:53.220]                         }
[08:25:53.220]                       }
[08:25:53.220]                       invisible(muffled)
[08:25:53.220]                     }
[08:25:53.220]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.220]                   }
[08:25:53.220]                 }
[08:25:53.220]             }
[08:25:53.220]         }))
[08:25:53.220]     }, error = function(ex) {
[08:25:53.220]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.220]                 ...future.rng), started = ...future.startTime, 
[08:25:53.220]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.220]             version = "1.8"), class = "FutureResult")
[08:25:53.220]     }, finally = {
[08:25:53.220]         if (!identical(...future.workdir, getwd())) 
[08:25:53.220]             setwd(...future.workdir)
[08:25:53.220]         {
[08:25:53.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.220]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.220]             }
[08:25:53.220]             base::options(...future.oldOptions)
[08:25:53.220]             if (.Platform$OS.type == "windows") {
[08:25:53.220]                 old_names <- names(...future.oldEnvVars)
[08:25:53.220]                 envs <- base::Sys.getenv()
[08:25:53.220]                 names <- names(envs)
[08:25:53.220]                 common <- intersect(names, old_names)
[08:25:53.220]                 added <- setdiff(names, old_names)
[08:25:53.220]                 removed <- setdiff(old_names, names)
[08:25:53.220]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.220]                   envs[common]]
[08:25:53.220]                 NAMES <- toupper(changed)
[08:25:53.220]                 args <- list()
[08:25:53.220]                 for (kk in seq_along(NAMES)) {
[08:25:53.220]                   name <- changed[[kk]]
[08:25:53.220]                   NAME <- NAMES[[kk]]
[08:25:53.220]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.220]                     next
[08:25:53.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.220]                 }
[08:25:53.220]                 NAMES <- toupper(added)
[08:25:53.220]                 for (kk in seq_along(NAMES)) {
[08:25:53.220]                   name <- added[[kk]]
[08:25:53.220]                   NAME <- NAMES[[kk]]
[08:25:53.220]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.220]                     next
[08:25:53.220]                   args[[name]] <- ""
[08:25:53.220]                 }
[08:25:53.220]                 NAMES <- toupper(removed)
[08:25:53.220]                 for (kk in seq_along(NAMES)) {
[08:25:53.220]                   name <- removed[[kk]]
[08:25:53.220]                   NAME <- NAMES[[kk]]
[08:25:53.220]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.220]                     next
[08:25:53.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.220]                 }
[08:25:53.220]                 if (length(args) > 0) 
[08:25:53.220]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.220]             }
[08:25:53.220]             else {
[08:25:53.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.220]             }
[08:25:53.220]             {
[08:25:53.220]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.220]                   0L) {
[08:25:53.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.220]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.220]                   base::options(opts)
[08:25:53.220]                 }
[08:25:53.220]                 {
[08:25:53.220]                   {
[08:25:53.220]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.220]                     NULL
[08:25:53.220]                   }
[08:25:53.220]                   options(future.plan = NULL)
[08:25:53.220]                   if (is.na(NA_character_)) 
[08:25:53.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.220]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.220]                     .init = FALSE)
[08:25:53.220]                 }
[08:25:53.220]             }
[08:25:53.220]         }
[08:25:53.220]     })
[08:25:53.220]     if (TRUE) {
[08:25:53.220]         base::sink(type = "output", split = FALSE)
[08:25:53.220]         if (TRUE) {
[08:25:53.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.220]         }
[08:25:53.220]         else {
[08:25:53.220]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.220]         }
[08:25:53.220]         base::close(...future.stdout)
[08:25:53.220]         ...future.stdout <- NULL
[08:25:53.220]     }
[08:25:53.220]     ...future.result$conditions <- ...future.conditions
[08:25:53.220]     ...future.result$finished <- base::Sys.time()
[08:25:53.220]     ...future.result
[08:25:53.220] }
[08:25:53.223] Exporting 5 global objects (807 bytes) to cluster node #1 ...
[08:25:53.224] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[08:25:53.224] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[08:25:53.224] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ...
[08:25:53.224] Exporting ‘MoreArgs’ (31 bytes) to cluster node #1 ... DONE
[08:25:53.225] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ...
[08:25:53.225] Exporting ‘...future.elements_ii’ (100 bytes) to cluster node #1 ... DONE
[08:25:53.225] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:53.225] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.226] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:53.226] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.226] Exporting 5 global objects (807 bytes) to cluster node #1 ... DONE
[08:25:53.227] MultisessionFuture started
[08:25:53.227] - Launch lazy future ... done
[08:25:53.227] run() for ‘MultisessionFuture’ ... done
[08:25:53.227] Created future:
[08:25:53.227] MultisessionFuture:
[08:25:53.227] Label: ‘future_.mapply-1’
[08:25:53.227] Expression:
[08:25:53.227] {
[08:25:53.227]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.227]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.227]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.227]         on.exit(options(oopts), add = TRUE)
[08:25:53.227]     }
[08:25:53.227]     {
[08:25:53.227]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.227]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.227]         do.call(mapply, args = args)
[08:25:53.227]     }
[08:25:53.227] }
[08:25:53.227] Lazy evaluation: FALSE
[08:25:53.227] Asynchronous evaluation: TRUE
[08:25:53.227] Local evaluation: TRUE
[08:25:53.227] Environment: R_GlobalEnv
[08:25:53.227] Capture standard output: TRUE
[08:25:53.227] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.227] Globals: 5 objects totaling 370 bytes (function ‘...future.FUN’ of 185 bytes, list ‘MoreArgs’ of 31 bytes, list ‘...future.elements_ii’ of 100 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.227] Packages: <none>
[08:25:53.227] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.227] Resolved: FALSE
[08:25:53.227] Value: <not collected>
[08:25:53.227] Conditions captured: <none>
[08:25:53.227] Early signaling: FALSE
[08:25:53.227] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.227] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.238] Chunk #1 of 1 ... DONE
[08:25:53.238] Launching 1 futures (chunks) ... DONE
[08:25:53.239] Resolving 1 futures (chunks) ...
[08:25:53.239] resolve() on list ...
[08:25:53.239]  recursive: 0
[08:25:53.239]  length: 1
[08:25:53.239] 
[08:25:53.269] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.269] - Validating connection of MultisessionFuture
[08:25:53.270] - received message: FutureResult
[08:25:53.270] - Received FutureResult
[08:25:53.270] - Erased future from FutureRegistry
[08:25:53.270] result() for ClusterFuture ...
[08:25:53.270] - result already collected: FutureResult
[08:25:53.270] result() for ClusterFuture ... done
[08:25:53.270] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.270] Future #1
[08:25:53.270] result() for ClusterFuture ...
[08:25:53.270] - result already collected: FutureResult
[08:25:53.271] result() for ClusterFuture ... done
[08:25:53.271] result() for ClusterFuture ...
[08:25:53.271] - result already collected: FutureResult
[08:25:53.271] result() for ClusterFuture ... done
[08:25:53.271] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:53.271] - nx: 1
[08:25:53.271] - relay: TRUE
[08:25:53.271] - stdout: TRUE
[08:25:53.271] - signal: TRUE
[08:25:53.271] - resignal: FALSE
[08:25:53.271] - force: TRUE
[08:25:53.271] - relayed: [n=1] FALSE
[08:25:53.272] - queued futures: [n=1] FALSE
[08:25:53.272]  - until=1
[08:25:53.272]  - relaying element #1
[08:25:53.272] result() for ClusterFuture ...
[08:25:53.272] - result already collected: FutureResult
[08:25:53.272] result() for ClusterFuture ... done
[08:25:53.272] result() for ClusterFuture ...
[08:25:53.272] - result already collected: FutureResult
[08:25:53.272] result() for ClusterFuture ... done
[08:25:53.272] result() for ClusterFuture ...
[08:25:53.272] - result already collected: FutureResult
[08:25:53.273] result() for ClusterFuture ... done
[08:25:53.273] result() for ClusterFuture ...
[08:25:53.273] - result already collected: FutureResult
[08:25:53.273] result() for ClusterFuture ... done
[08:25:53.273] - relayed: [n=1] TRUE
[08:25:53.273] - queued futures: [n=1] TRUE
[08:25:53.273] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:53.273]  length: 0 (resolved future 1)
[08:25:53.273] Relaying remaining futures
[08:25:53.273] signalConditionsASAP(NULL, pos=0) ...
[08:25:53.273] - nx: 1
[08:25:53.273] - relay: TRUE
[08:25:53.274] - stdout: TRUE
[08:25:53.274] - signal: TRUE
[08:25:53.274] - resignal: FALSE
[08:25:53.274] - force: TRUE
[08:25:53.274] - relayed: [n=1] TRUE
[08:25:53.274] - queued futures: [n=1] TRUE
 - flush all
[08:25:53.274] - relayed: [n=1] TRUE
[08:25:53.274] - queued futures: [n=1] TRUE
[08:25:53.274] signalConditionsASAP(NULL, pos=0) ... done
[08:25:53.274] resolve() on list ... DONE
[08:25:53.274] result() for ClusterFuture ...
[08:25:53.275] - result already collected: FutureResult
[08:25:53.275] result() for ClusterFuture ... done
[08:25:53.275] result() for ClusterFuture ...
[08:25:53.275] - result already collected: FutureResult
[08:25:53.275] result() for ClusterFuture ... done
[08:25:53.275]  - Number of value chunks collected: 1
[08:25:53.275] Resolving 1 futures (chunks) ... DONE
[08:25:53.275] Reducing values from 1 chunks ...
[08:25:53.275]  - Number of values collected after concatenation: 1
[08:25:53.275]  - Number of values expected: 1
[08:25:53.275] Reducing values from 1 chunks ... DONE
[08:25:53.275] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[08:25:53.276] future_mapply() ...
[08:25:53.278] Number of chunks: 2
[08:25:53.278] getGlobalsAndPackagesXApply() ...
[08:25:53.278]  - future.globals: TRUE
[08:25:53.278] getGlobalsAndPackages() ...
[08:25:53.278] Searching for globals...
[08:25:53.279] - globals found: [1] ‘FUN’
[08:25:53.279] Searching for globals ... DONE
[08:25:53.279] Resolving globals: FALSE
[08:25:53.280] The total size of the 1 globals is 326 bytes (326 bytes)
[08:25:53.280] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[08:25:53.280] - globals: [1] ‘FUN’
[08:25:53.280] 
[08:25:53.280] getGlobalsAndPackages() ... DONE
[08:25:53.280]  - globals found/used: [n=1] ‘FUN’
[08:25:53.280]  - needed namespaces: [n=0] 
[08:25:53.280] Finding globals ... DONE
[08:25:53.281] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:53.281] List of 2
[08:25:53.281]  $ ...future.FUN:function (x, y)  
[08:25:53.281]  $ MoreArgs     :List of 1
[08:25:53.281]   ..$ y: int [1:2] 3 4
[08:25:53.281]  - attr(*, "where")=List of 2
[08:25:53.281]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:53.281]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:53.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:53.281]  - attr(*, "resolved")= logi FALSE
[08:25:53.281]  - attr(*, "total_size")= num NA
[08:25:53.284] Packages to be attached in all futures: [n=0] 
[08:25:53.284] getGlobalsAndPackagesXApply() ... DONE
[08:25:53.284] Number of futures (= number of chunks): 2
[08:25:53.284] Launching 2 futures (chunks) ...
[08:25:53.284] Chunk #1 of 2 ...
[08:25:53.284]  - Finding globals in '...' for chunk #1 ...
[08:25:53.284] getGlobalsAndPackages() ...
[08:25:53.284] Searching for globals...
[08:25:53.285] 
[08:25:53.285] Searching for globals ... DONE
[08:25:53.285] - globals: [0] <none>
[08:25:53.285] getGlobalsAndPackages() ... DONE
[08:25:53.285]    + additional globals found: [n=0] 
[08:25:53.285]    + additional namespaces needed: [n=0] 
[08:25:53.285]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:53.285]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.285]  - seeds: <none>
[08:25:53.285]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.286] getGlobalsAndPackages() ...
[08:25:53.286] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.286] Resolving globals: FALSE
[08:25:53.286] The total size of the 5 globals is 656 bytes (656 bytes)
[08:25:53.287] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:53.287] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.287] 
[08:25:53.287] getGlobalsAndPackages() ... DONE
[08:25:53.287] run() for ‘Future’ ...
[08:25:53.287] - state: ‘created’
[08:25:53.287] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.304] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.304] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.304]   - Field: ‘node’
[08:25:53.304]   - Field: ‘label’
[08:25:53.304]   - Field: ‘local’
[08:25:53.304]   - Field: ‘owner’
[08:25:53.304]   - Field: ‘envir’
[08:25:53.304]   - Field: ‘workers’
[08:25:53.304]   - Field: ‘packages’
[08:25:53.305]   - Field: ‘gc’
[08:25:53.305]   - Field: ‘conditions’
[08:25:53.305]   - Field: ‘persistent’
[08:25:53.305]   - Field: ‘expr’
[08:25:53.305]   - Field: ‘uuid’
[08:25:53.305]   - Field: ‘seed’
[08:25:53.305]   - Field: ‘version’
[08:25:53.305]   - Field: ‘result’
[08:25:53.305]   - Field: ‘asynchronous’
[08:25:53.305]   - Field: ‘calls’
[08:25:53.305]   - Field: ‘globals’
[08:25:53.305]   - Field: ‘stdout’
[08:25:53.306]   - Field: ‘earlySignal’
[08:25:53.306]   - Field: ‘lazy’
[08:25:53.306]   - Field: ‘state’
[08:25:53.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.306] - Launch lazy future ...
[08:25:53.306] Packages needed by the future expression (n = 0): <none>
[08:25:53.306] Packages needed by future strategies (n = 0): <none>
[08:25:53.307] {
[08:25:53.307]     {
[08:25:53.307]         {
[08:25:53.307]             ...future.startTime <- base::Sys.time()
[08:25:53.307]             {
[08:25:53.307]                 {
[08:25:53.307]                   {
[08:25:53.307]                     {
[08:25:53.307]                       base::local({
[08:25:53.307]                         has_future <- base::requireNamespace("future", 
[08:25:53.307]                           quietly = TRUE)
[08:25:53.307]                         if (has_future) {
[08:25:53.307]                           ns <- base::getNamespace("future")
[08:25:53.307]                           version <- ns[[".package"]][["version"]]
[08:25:53.307]                           if (is.null(version)) 
[08:25:53.307]                             version <- utils::packageVersion("future")
[08:25:53.307]                         }
[08:25:53.307]                         else {
[08:25:53.307]                           version <- NULL
[08:25:53.307]                         }
[08:25:53.307]                         if (!has_future || version < "1.8.0") {
[08:25:53.307]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.307]                             "", base::R.version$version.string), 
[08:25:53.307]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.307]                               "release", "version")], collapse = " "), 
[08:25:53.307]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.307]                             info)
[08:25:53.307]                           info <- base::paste(info, collapse = "; ")
[08:25:53.307]                           if (!has_future) {
[08:25:53.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.307]                               info)
[08:25:53.307]                           }
[08:25:53.307]                           else {
[08:25:53.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.307]                               info, version)
[08:25:53.307]                           }
[08:25:53.307]                           base::stop(msg)
[08:25:53.307]                         }
[08:25:53.307]                       })
[08:25:53.307]                     }
[08:25:53.307]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.307]                     base::options(mc.cores = 1L)
[08:25:53.307]                   }
[08:25:53.307]                   ...future.strategy.old <- future::plan("list")
[08:25:53.307]                   options(future.plan = NULL)
[08:25:53.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.307]                 }
[08:25:53.307]                 ...future.workdir <- getwd()
[08:25:53.307]             }
[08:25:53.307]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.307]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.307]         }
[08:25:53.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.307]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.307]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.307]             base::names(...future.oldOptions))
[08:25:53.307]     }
[08:25:53.307]     if (FALSE) {
[08:25:53.307]     }
[08:25:53.307]     else {
[08:25:53.307]         if (TRUE) {
[08:25:53.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.307]                 open = "w")
[08:25:53.307]         }
[08:25:53.307]         else {
[08:25:53.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.307]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.307]         }
[08:25:53.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.307]             base::sink(type = "output", split = FALSE)
[08:25:53.307]             base::close(...future.stdout)
[08:25:53.307]         }, add = TRUE)
[08:25:53.307]     }
[08:25:53.307]     ...future.frame <- base::sys.nframe()
[08:25:53.307]     ...future.conditions <- base::list()
[08:25:53.307]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.307]     if (FALSE) {
[08:25:53.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.307]     }
[08:25:53.307]     ...future.result <- base::tryCatch({
[08:25:53.307]         base::withCallingHandlers({
[08:25:53.307]             ...future.value <- base::withVisible(base::local({
[08:25:53.307]                 ...future.makeSendCondition <- base::local({
[08:25:53.307]                   sendCondition <- NULL
[08:25:53.307]                   function(frame = 1L) {
[08:25:53.307]                     if (is.function(sendCondition)) 
[08:25:53.307]                       return(sendCondition)
[08:25:53.307]                     ns <- getNamespace("parallel")
[08:25:53.307]                     if (exists("sendData", mode = "function", 
[08:25:53.307]                       envir = ns)) {
[08:25:53.307]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.307]                         envir = ns)
[08:25:53.307]                       envir <- sys.frame(frame)
[08:25:53.307]                       master <- NULL
[08:25:53.307]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.307]                         !identical(envir, emptyenv())) {
[08:25:53.307]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.307]                           inherits = FALSE)) {
[08:25:53.307]                           master <- get("master", mode = "list", 
[08:25:53.307]                             envir = envir, inherits = FALSE)
[08:25:53.307]                           if (inherits(master, c("SOCKnode", 
[08:25:53.307]                             "SOCK0node"))) {
[08:25:53.307]                             sendCondition <<- function(cond) {
[08:25:53.307]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.307]                                 success = TRUE)
[08:25:53.307]                               parallel_sendData(master, data)
[08:25:53.307]                             }
[08:25:53.307]                             return(sendCondition)
[08:25:53.307]                           }
[08:25:53.307]                         }
[08:25:53.307]                         frame <- frame + 1L
[08:25:53.307]                         envir <- sys.frame(frame)
[08:25:53.307]                       }
[08:25:53.307]                     }
[08:25:53.307]                     sendCondition <<- function(cond) NULL
[08:25:53.307]                   }
[08:25:53.307]                 })
[08:25:53.307]                 withCallingHandlers({
[08:25:53.307]                   {
[08:25:53.307]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.307]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.307]                       ...future.globals.maxSize)) {
[08:25:53.307]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.307]                       on.exit(options(oopts), add = TRUE)
[08:25:53.307]                     }
[08:25:53.307]                     {
[08:25:53.307]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.307]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.307]                         USE.NAMES = FALSE)
[08:25:53.307]                       do.call(mapply, args = args)
[08:25:53.307]                     }
[08:25:53.307]                   }
[08:25:53.307]                 }, immediateCondition = function(cond) {
[08:25:53.307]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.307]                   sendCondition(cond)
[08:25:53.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.307]                   {
[08:25:53.307]                     inherits <- base::inherits
[08:25:53.307]                     invokeRestart <- base::invokeRestart
[08:25:53.307]                     is.null <- base::is.null
[08:25:53.307]                     muffled <- FALSE
[08:25:53.307]                     if (inherits(cond, "message")) {
[08:25:53.307]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.307]                       if (muffled) 
[08:25:53.307]                         invokeRestart("muffleMessage")
[08:25:53.307]                     }
[08:25:53.307]                     else if (inherits(cond, "warning")) {
[08:25:53.307]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.307]                       if (muffled) 
[08:25:53.307]                         invokeRestart("muffleWarning")
[08:25:53.307]                     }
[08:25:53.307]                     else if (inherits(cond, "condition")) {
[08:25:53.307]                       if (!is.null(pattern)) {
[08:25:53.307]                         computeRestarts <- base::computeRestarts
[08:25:53.307]                         grepl <- base::grepl
[08:25:53.307]                         restarts <- computeRestarts(cond)
[08:25:53.307]                         for (restart in restarts) {
[08:25:53.307]                           name <- restart$name
[08:25:53.307]                           if (is.null(name)) 
[08:25:53.307]                             next
[08:25:53.307]                           if (!grepl(pattern, name)) 
[08:25:53.307]                             next
[08:25:53.307]                           invokeRestart(restart)
[08:25:53.307]                           muffled <- TRUE
[08:25:53.307]                           break
[08:25:53.307]                         }
[08:25:53.307]                       }
[08:25:53.307]                     }
[08:25:53.307]                     invisible(muffled)
[08:25:53.307]                   }
[08:25:53.307]                   muffleCondition(cond)
[08:25:53.307]                 })
[08:25:53.307]             }))
[08:25:53.307]             future::FutureResult(value = ...future.value$value, 
[08:25:53.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.307]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.307]                     ...future.globalenv.names))
[08:25:53.307]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.307]         }, condition = base::local({
[08:25:53.307]             c <- base::c
[08:25:53.307]             inherits <- base::inherits
[08:25:53.307]             invokeRestart <- base::invokeRestart
[08:25:53.307]             length <- base::length
[08:25:53.307]             list <- base::list
[08:25:53.307]             seq.int <- base::seq.int
[08:25:53.307]             signalCondition <- base::signalCondition
[08:25:53.307]             sys.calls <- base::sys.calls
[08:25:53.307]             `[[` <- base::`[[`
[08:25:53.307]             `+` <- base::`+`
[08:25:53.307]             `<<-` <- base::`<<-`
[08:25:53.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.307]                   3L)]
[08:25:53.307]             }
[08:25:53.307]             function(cond) {
[08:25:53.307]                 is_error <- inherits(cond, "error")
[08:25:53.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.307]                   NULL)
[08:25:53.307]                 if (is_error) {
[08:25:53.307]                   sessionInformation <- function() {
[08:25:53.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.307]                       search = base::search(), system = base::Sys.info())
[08:25:53.307]                   }
[08:25:53.307]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.307]                     cond$call), session = sessionInformation(), 
[08:25:53.307]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.307]                   signalCondition(cond)
[08:25:53.307]                 }
[08:25:53.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.307]                 "immediateCondition"))) {
[08:25:53.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.307]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.307]                   if (TRUE && !signal) {
[08:25:53.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.307]                     {
[08:25:53.307]                       inherits <- base::inherits
[08:25:53.307]                       invokeRestart <- base::invokeRestart
[08:25:53.307]                       is.null <- base::is.null
[08:25:53.307]                       muffled <- FALSE
[08:25:53.307]                       if (inherits(cond, "message")) {
[08:25:53.307]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.307]                         if (muffled) 
[08:25:53.307]                           invokeRestart("muffleMessage")
[08:25:53.307]                       }
[08:25:53.307]                       else if (inherits(cond, "warning")) {
[08:25:53.307]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.307]                         if (muffled) 
[08:25:53.307]                           invokeRestart("muffleWarning")
[08:25:53.307]                       }
[08:25:53.307]                       else if (inherits(cond, "condition")) {
[08:25:53.307]                         if (!is.null(pattern)) {
[08:25:53.307]                           computeRestarts <- base::computeRestarts
[08:25:53.307]                           grepl <- base::grepl
[08:25:53.307]                           restarts <- computeRestarts(cond)
[08:25:53.307]                           for (restart in restarts) {
[08:25:53.307]                             name <- restart$name
[08:25:53.307]                             if (is.null(name)) 
[08:25:53.307]                               next
[08:25:53.307]                             if (!grepl(pattern, name)) 
[08:25:53.307]                               next
[08:25:53.307]                             invokeRestart(restart)
[08:25:53.307]                             muffled <- TRUE
[08:25:53.307]                             break
[08:25:53.307]                           }
[08:25:53.307]                         }
[08:25:53.307]                       }
[08:25:53.307]                       invisible(muffled)
[08:25:53.307]                     }
[08:25:53.307]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.307]                   }
[08:25:53.307]                 }
[08:25:53.307]                 else {
[08:25:53.307]                   if (TRUE) {
[08:25:53.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.307]                     {
[08:25:53.307]                       inherits <- base::inherits
[08:25:53.307]                       invokeRestart <- base::invokeRestart
[08:25:53.307]                       is.null <- base::is.null
[08:25:53.307]                       muffled <- FALSE
[08:25:53.307]                       if (inherits(cond, "message")) {
[08:25:53.307]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.307]                         if (muffled) 
[08:25:53.307]                           invokeRestart("muffleMessage")
[08:25:53.307]                       }
[08:25:53.307]                       else if (inherits(cond, "warning")) {
[08:25:53.307]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.307]                         if (muffled) 
[08:25:53.307]                           invokeRestart("muffleWarning")
[08:25:53.307]                       }
[08:25:53.307]                       else if (inherits(cond, "condition")) {
[08:25:53.307]                         if (!is.null(pattern)) {
[08:25:53.307]                           computeRestarts <- base::computeRestarts
[08:25:53.307]                           grepl <- base::grepl
[08:25:53.307]                           restarts <- computeRestarts(cond)
[08:25:53.307]                           for (restart in restarts) {
[08:25:53.307]                             name <- restart$name
[08:25:53.307]                             if (is.null(name)) 
[08:25:53.307]                               next
[08:25:53.307]                             if (!grepl(pattern, name)) 
[08:25:53.307]                               next
[08:25:53.307]                             invokeRestart(restart)
[08:25:53.307]                             muffled <- TRUE
[08:25:53.307]                             break
[08:25:53.307]                           }
[08:25:53.307]                         }
[08:25:53.307]                       }
[08:25:53.307]                       invisible(muffled)
[08:25:53.307]                     }
[08:25:53.307]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.307]                   }
[08:25:53.307]                 }
[08:25:53.307]             }
[08:25:53.307]         }))
[08:25:53.307]     }, error = function(ex) {
[08:25:53.307]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.307]                 ...future.rng), started = ...future.startTime, 
[08:25:53.307]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.307]             version = "1.8"), class = "FutureResult")
[08:25:53.307]     }, finally = {
[08:25:53.307]         if (!identical(...future.workdir, getwd())) 
[08:25:53.307]             setwd(...future.workdir)
[08:25:53.307]         {
[08:25:53.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.307]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.307]             }
[08:25:53.307]             base::options(...future.oldOptions)
[08:25:53.307]             if (.Platform$OS.type == "windows") {
[08:25:53.307]                 old_names <- names(...future.oldEnvVars)
[08:25:53.307]                 envs <- base::Sys.getenv()
[08:25:53.307]                 names <- names(envs)
[08:25:53.307]                 common <- intersect(names, old_names)
[08:25:53.307]                 added <- setdiff(names, old_names)
[08:25:53.307]                 removed <- setdiff(old_names, names)
[08:25:53.307]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.307]                   envs[common]]
[08:25:53.307]                 NAMES <- toupper(changed)
[08:25:53.307]                 args <- list()
[08:25:53.307]                 for (kk in seq_along(NAMES)) {
[08:25:53.307]                   name <- changed[[kk]]
[08:25:53.307]                   NAME <- NAMES[[kk]]
[08:25:53.307]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.307]                     next
[08:25:53.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.307]                 }
[08:25:53.307]                 NAMES <- toupper(added)
[08:25:53.307]                 for (kk in seq_along(NAMES)) {
[08:25:53.307]                   name <- added[[kk]]
[08:25:53.307]                   NAME <- NAMES[[kk]]
[08:25:53.307]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.307]                     next
[08:25:53.307]                   args[[name]] <- ""
[08:25:53.307]                 }
[08:25:53.307]                 NAMES <- toupper(removed)
[08:25:53.307]                 for (kk in seq_along(NAMES)) {
[08:25:53.307]                   name <- removed[[kk]]
[08:25:53.307]                   NAME <- NAMES[[kk]]
[08:25:53.307]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.307]                     next
[08:25:53.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.307]                 }
[08:25:53.307]                 if (length(args) > 0) 
[08:25:53.307]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.307]             }
[08:25:53.307]             else {
[08:25:53.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.307]             }
[08:25:53.307]             {
[08:25:53.307]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.307]                   0L) {
[08:25:53.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.307]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.307]                   base::options(opts)
[08:25:53.307]                 }
[08:25:53.307]                 {
[08:25:53.307]                   {
[08:25:53.307]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.307]                     NULL
[08:25:53.307]                   }
[08:25:53.307]                   options(future.plan = NULL)
[08:25:53.307]                   if (is.na(NA_character_)) 
[08:25:53.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.307]                     .init = FALSE)
[08:25:53.307]                 }
[08:25:53.307]             }
[08:25:53.307]         }
[08:25:53.307]     })
[08:25:53.307]     if (TRUE) {
[08:25:53.307]         base::sink(type = "output", split = FALSE)
[08:25:53.307]         if (TRUE) {
[08:25:53.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.307]         }
[08:25:53.307]         else {
[08:25:53.307]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.307]         }
[08:25:53.307]         base::close(...future.stdout)
[08:25:53.307]         ...future.stdout <- NULL
[08:25:53.307]     }
[08:25:53.307]     ...future.result$conditions <- ...future.conditions
[08:25:53.307]     ...future.result$finished <- base::Sys.time()
[08:25:53.307]     ...future.result
[08:25:53.307] }
[08:25:53.310] Exporting 5 global objects (1.05 KiB) to cluster node #1 ...
[08:25:53.310] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ...
[08:25:53.310] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ... DONE
[08:25:53.310] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ...
[08:25:53.311] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ... DONE
[08:25:53.311] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ...
[08:25:53.311] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ... DONE
[08:25:53.311] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:53.312] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.312] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:53.312] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.312] Exporting 5 global objects (1.05 KiB) to cluster node #1 ... DONE
[08:25:53.313] MultisessionFuture started
[08:25:53.313] - Launch lazy future ... done
[08:25:53.313] run() for ‘MultisessionFuture’ ... done
[08:25:53.313] Created future:
[08:25:53.313] MultisessionFuture:
[08:25:53.313] Label: ‘future_mapply-1’
[08:25:53.313] Expression:
[08:25:53.313] {
[08:25:53.313]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.313]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.313]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.313]         on.exit(options(oopts), add = TRUE)
[08:25:53.313]     }
[08:25:53.313]     {
[08:25:53.313]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.313]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.313]         do.call(mapply, args = args)
[08:25:53.313]     }
[08:25:53.313] }
[08:25:53.313] Lazy evaluation: FALSE
[08:25:53.313] Asynchronous evaluation: TRUE
[08:25:53.313] Local evaluation: TRUE
[08:25:53.313] Environment: R_GlobalEnv
[08:25:53.313] Capture standard output: TRUE
[08:25:53.313] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.313] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.313] Packages: <none>
[08:25:53.313] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.313] Resolved: FALSE
[08:25:53.313] Value: <not collected>
[08:25:53.313] Conditions captured: <none>
[08:25:53.313] Early signaling: FALSE
[08:25:53.313] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.313] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.325] Chunk #1 of 2 ... DONE
[08:25:53.325] Chunk #2 of 2 ...
[08:25:53.325]  - Finding globals in '...' for chunk #2 ...
[08:25:53.325] getGlobalsAndPackages() ...
[08:25:53.325] Searching for globals...
[08:25:53.326] 
[08:25:53.326] Searching for globals ... DONE
[08:25:53.326] - globals: [0] <none>
[08:25:53.326] getGlobalsAndPackages() ... DONE
[08:25:53.326]    + additional globals found: [n=0] 
[08:25:53.326]    + additional namespaces needed: [n=0] 
[08:25:53.326]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:53.326]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.326]  - seeds: <none>
[08:25:53.326]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.327] getGlobalsAndPackages() ...
[08:25:53.327] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.327] Resolving globals: FALSE
[08:25:53.327] The total size of the 5 globals is 656 bytes (656 bytes)
[08:25:53.328] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:53.328] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.328] 
[08:25:53.328] getGlobalsAndPackages() ... DONE
[08:25:53.328] run() for ‘Future’ ...
[08:25:53.328] - state: ‘created’
[08:25:53.328] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.343] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.343] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.343]   - Field: ‘node’
[08:25:53.343]   - Field: ‘label’
[08:25:53.343]   - Field: ‘local’
[08:25:53.344]   - Field: ‘owner’
[08:25:53.344]   - Field: ‘envir’
[08:25:53.344]   - Field: ‘workers’
[08:25:53.344]   - Field: ‘packages’
[08:25:53.344]   - Field: ‘gc’
[08:25:53.344]   - Field: ‘conditions’
[08:25:53.344]   - Field: ‘persistent’
[08:25:53.344]   - Field: ‘expr’
[08:25:53.344]   - Field: ‘uuid’
[08:25:53.344]   - Field: ‘seed’
[08:25:53.344]   - Field: ‘version’
[08:25:53.344]   - Field: ‘result’
[08:25:53.345]   - Field: ‘asynchronous’
[08:25:53.345]   - Field: ‘calls’
[08:25:53.345]   - Field: ‘globals’
[08:25:53.345]   - Field: ‘stdout’
[08:25:53.345]   - Field: ‘earlySignal’
[08:25:53.345]   - Field: ‘lazy’
[08:25:53.345]   - Field: ‘state’
[08:25:53.345] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.345] - Launch lazy future ...
[08:25:53.346] Packages needed by the future expression (n = 0): <none>
[08:25:53.346] Packages needed by future strategies (n = 0): <none>
[08:25:53.346] {
[08:25:53.346]     {
[08:25:53.346]         {
[08:25:53.346]             ...future.startTime <- base::Sys.time()
[08:25:53.346]             {
[08:25:53.346]                 {
[08:25:53.346]                   {
[08:25:53.346]                     {
[08:25:53.346]                       base::local({
[08:25:53.346]                         has_future <- base::requireNamespace("future", 
[08:25:53.346]                           quietly = TRUE)
[08:25:53.346]                         if (has_future) {
[08:25:53.346]                           ns <- base::getNamespace("future")
[08:25:53.346]                           version <- ns[[".package"]][["version"]]
[08:25:53.346]                           if (is.null(version)) 
[08:25:53.346]                             version <- utils::packageVersion("future")
[08:25:53.346]                         }
[08:25:53.346]                         else {
[08:25:53.346]                           version <- NULL
[08:25:53.346]                         }
[08:25:53.346]                         if (!has_future || version < "1.8.0") {
[08:25:53.346]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.346]                             "", base::R.version$version.string), 
[08:25:53.346]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.346]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.346]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.346]                               "release", "version")], collapse = " "), 
[08:25:53.346]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.346]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.346]                             info)
[08:25:53.346]                           info <- base::paste(info, collapse = "; ")
[08:25:53.346]                           if (!has_future) {
[08:25:53.346]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.346]                               info)
[08:25:53.346]                           }
[08:25:53.346]                           else {
[08:25:53.346]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.346]                               info, version)
[08:25:53.346]                           }
[08:25:53.346]                           base::stop(msg)
[08:25:53.346]                         }
[08:25:53.346]                       })
[08:25:53.346]                     }
[08:25:53.346]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.346]                     base::options(mc.cores = 1L)
[08:25:53.346]                   }
[08:25:53.346]                   ...future.strategy.old <- future::plan("list")
[08:25:53.346]                   options(future.plan = NULL)
[08:25:53.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.346]                 }
[08:25:53.346]                 ...future.workdir <- getwd()
[08:25:53.346]             }
[08:25:53.346]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.346]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.346]         }
[08:25:53.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.346]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.346]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.346]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.346]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.346]             base::names(...future.oldOptions))
[08:25:53.346]     }
[08:25:53.346]     if (FALSE) {
[08:25:53.346]     }
[08:25:53.346]     else {
[08:25:53.346]         if (TRUE) {
[08:25:53.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.346]                 open = "w")
[08:25:53.346]         }
[08:25:53.346]         else {
[08:25:53.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.346]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.346]         }
[08:25:53.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.346]             base::sink(type = "output", split = FALSE)
[08:25:53.346]             base::close(...future.stdout)
[08:25:53.346]         }, add = TRUE)
[08:25:53.346]     }
[08:25:53.346]     ...future.frame <- base::sys.nframe()
[08:25:53.346]     ...future.conditions <- base::list()
[08:25:53.346]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.346]     if (FALSE) {
[08:25:53.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.346]     }
[08:25:53.346]     ...future.result <- base::tryCatch({
[08:25:53.346]         base::withCallingHandlers({
[08:25:53.346]             ...future.value <- base::withVisible(base::local({
[08:25:53.346]                 ...future.makeSendCondition <- base::local({
[08:25:53.346]                   sendCondition <- NULL
[08:25:53.346]                   function(frame = 1L) {
[08:25:53.346]                     if (is.function(sendCondition)) 
[08:25:53.346]                       return(sendCondition)
[08:25:53.346]                     ns <- getNamespace("parallel")
[08:25:53.346]                     if (exists("sendData", mode = "function", 
[08:25:53.346]                       envir = ns)) {
[08:25:53.346]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.346]                         envir = ns)
[08:25:53.346]                       envir <- sys.frame(frame)
[08:25:53.346]                       master <- NULL
[08:25:53.346]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.346]                         !identical(envir, emptyenv())) {
[08:25:53.346]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.346]                           inherits = FALSE)) {
[08:25:53.346]                           master <- get("master", mode = "list", 
[08:25:53.346]                             envir = envir, inherits = FALSE)
[08:25:53.346]                           if (inherits(master, c("SOCKnode", 
[08:25:53.346]                             "SOCK0node"))) {
[08:25:53.346]                             sendCondition <<- function(cond) {
[08:25:53.346]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.346]                                 success = TRUE)
[08:25:53.346]                               parallel_sendData(master, data)
[08:25:53.346]                             }
[08:25:53.346]                             return(sendCondition)
[08:25:53.346]                           }
[08:25:53.346]                         }
[08:25:53.346]                         frame <- frame + 1L
[08:25:53.346]                         envir <- sys.frame(frame)
[08:25:53.346]                       }
[08:25:53.346]                     }
[08:25:53.346]                     sendCondition <<- function(cond) NULL
[08:25:53.346]                   }
[08:25:53.346]                 })
[08:25:53.346]                 withCallingHandlers({
[08:25:53.346]                   {
[08:25:53.346]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.346]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.346]                       ...future.globals.maxSize)) {
[08:25:53.346]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.346]                       on.exit(options(oopts), add = TRUE)
[08:25:53.346]                     }
[08:25:53.346]                     {
[08:25:53.346]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.346]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.346]                         USE.NAMES = FALSE)
[08:25:53.346]                       do.call(mapply, args = args)
[08:25:53.346]                     }
[08:25:53.346]                   }
[08:25:53.346]                 }, immediateCondition = function(cond) {
[08:25:53.346]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.346]                   sendCondition(cond)
[08:25:53.346]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.346]                   {
[08:25:53.346]                     inherits <- base::inherits
[08:25:53.346]                     invokeRestart <- base::invokeRestart
[08:25:53.346]                     is.null <- base::is.null
[08:25:53.346]                     muffled <- FALSE
[08:25:53.346]                     if (inherits(cond, "message")) {
[08:25:53.346]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.346]                       if (muffled) 
[08:25:53.346]                         invokeRestart("muffleMessage")
[08:25:53.346]                     }
[08:25:53.346]                     else if (inherits(cond, "warning")) {
[08:25:53.346]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.346]                       if (muffled) 
[08:25:53.346]                         invokeRestart("muffleWarning")
[08:25:53.346]                     }
[08:25:53.346]                     else if (inherits(cond, "condition")) {
[08:25:53.346]                       if (!is.null(pattern)) {
[08:25:53.346]                         computeRestarts <- base::computeRestarts
[08:25:53.346]                         grepl <- base::grepl
[08:25:53.346]                         restarts <- computeRestarts(cond)
[08:25:53.346]                         for (restart in restarts) {
[08:25:53.346]                           name <- restart$name
[08:25:53.346]                           if (is.null(name)) 
[08:25:53.346]                             next
[08:25:53.346]                           if (!grepl(pattern, name)) 
[08:25:53.346]                             next
[08:25:53.346]                           invokeRestart(restart)
[08:25:53.346]                           muffled <- TRUE
[08:25:53.346]                           break
[08:25:53.346]                         }
[08:25:53.346]                       }
[08:25:53.346]                     }
[08:25:53.346]                     invisible(muffled)
[08:25:53.346]                   }
[08:25:53.346]                   muffleCondition(cond)
[08:25:53.346]                 })
[08:25:53.346]             }))
[08:25:53.346]             future::FutureResult(value = ...future.value$value, 
[08:25:53.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.346]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.346]                     ...future.globalenv.names))
[08:25:53.346]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.346]         }, condition = base::local({
[08:25:53.346]             c <- base::c
[08:25:53.346]             inherits <- base::inherits
[08:25:53.346]             invokeRestart <- base::invokeRestart
[08:25:53.346]             length <- base::length
[08:25:53.346]             list <- base::list
[08:25:53.346]             seq.int <- base::seq.int
[08:25:53.346]             signalCondition <- base::signalCondition
[08:25:53.346]             sys.calls <- base::sys.calls
[08:25:53.346]             `[[` <- base::`[[`
[08:25:53.346]             `+` <- base::`+`
[08:25:53.346]             `<<-` <- base::`<<-`
[08:25:53.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.346]                   3L)]
[08:25:53.346]             }
[08:25:53.346]             function(cond) {
[08:25:53.346]                 is_error <- inherits(cond, "error")
[08:25:53.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.346]                   NULL)
[08:25:53.346]                 if (is_error) {
[08:25:53.346]                   sessionInformation <- function() {
[08:25:53.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.346]                       search = base::search(), system = base::Sys.info())
[08:25:53.346]                   }
[08:25:53.346]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.346]                     cond$call), session = sessionInformation(), 
[08:25:53.346]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.346]                   signalCondition(cond)
[08:25:53.346]                 }
[08:25:53.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.346]                 "immediateCondition"))) {
[08:25:53.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.346]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.346]                   if (TRUE && !signal) {
[08:25:53.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.346]                     {
[08:25:53.346]                       inherits <- base::inherits
[08:25:53.346]                       invokeRestart <- base::invokeRestart
[08:25:53.346]                       is.null <- base::is.null
[08:25:53.346]                       muffled <- FALSE
[08:25:53.346]                       if (inherits(cond, "message")) {
[08:25:53.346]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.346]                         if (muffled) 
[08:25:53.346]                           invokeRestart("muffleMessage")
[08:25:53.346]                       }
[08:25:53.346]                       else if (inherits(cond, "warning")) {
[08:25:53.346]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.346]                         if (muffled) 
[08:25:53.346]                           invokeRestart("muffleWarning")
[08:25:53.346]                       }
[08:25:53.346]                       else if (inherits(cond, "condition")) {
[08:25:53.346]                         if (!is.null(pattern)) {
[08:25:53.346]                           computeRestarts <- base::computeRestarts
[08:25:53.346]                           grepl <- base::grepl
[08:25:53.346]                           restarts <- computeRestarts(cond)
[08:25:53.346]                           for (restart in restarts) {
[08:25:53.346]                             name <- restart$name
[08:25:53.346]                             if (is.null(name)) 
[08:25:53.346]                               next
[08:25:53.346]                             if (!grepl(pattern, name)) 
[08:25:53.346]                               next
[08:25:53.346]                             invokeRestart(restart)
[08:25:53.346]                             muffled <- TRUE
[08:25:53.346]                             break
[08:25:53.346]                           }
[08:25:53.346]                         }
[08:25:53.346]                       }
[08:25:53.346]                       invisible(muffled)
[08:25:53.346]                     }
[08:25:53.346]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.346]                   }
[08:25:53.346]                 }
[08:25:53.346]                 else {
[08:25:53.346]                   if (TRUE) {
[08:25:53.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.346]                     {
[08:25:53.346]                       inherits <- base::inherits
[08:25:53.346]                       invokeRestart <- base::invokeRestart
[08:25:53.346]                       is.null <- base::is.null
[08:25:53.346]                       muffled <- FALSE
[08:25:53.346]                       if (inherits(cond, "message")) {
[08:25:53.346]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.346]                         if (muffled) 
[08:25:53.346]                           invokeRestart("muffleMessage")
[08:25:53.346]                       }
[08:25:53.346]                       else if (inherits(cond, "warning")) {
[08:25:53.346]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.346]                         if (muffled) 
[08:25:53.346]                           invokeRestart("muffleWarning")
[08:25:53.346]                       }
[08:25:53.346]                       else if (inherits(cond, "condition")) {
[08:25:53.346]                         if (!is.null(pattern)) {
[08:25:53.346]                           computeRestarts <- base::computeRestarts
[08:25:53.346]                           grepl <- base::grepl
[08:25:53.346]                           restarts <- computeRestarts(cond)
[08:25:53.346]                           for (restart in restarts) {
[08:25:53.346]                             name <- restart$name
[08:25:53.346]                             if (is.null(name)) 
[08:25:53.346]                               next
[08:25:53.346]                             if (!grepl(pattern, name)) 
[08:25:53.346]                               next
[08:25:53.346]                             invokeRestart(restart)
[08:25:53.346]                             muffled <- TRUE
[08:25:53.346]                             break
[08:25:53.346]                           }
[08:25:53.346]                         }
[08:25:53.346]                       }
[08:25:53.346]                       invisible(muffled)
[08:25:53.346]                     }
[08:25:53.346]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.346]                   }
[08:25:53.346]                 }
[08:25:53.346]             }
[08:25:53.346]         }))
[08:25:53.346]     }, error = function(ex) {
[08:25:53.346]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.346]                 ...future.rng), started = ...future.startTime, 
[08:25:53.346]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.346]             version = "1.8"), class = "FutureResult")
[08:25:53.346]     }, finally = {
[08:25:53.346]         if (!identical(...future.workdir, getwd())) 
[08:25:53.346]             setwd(...future.workdir)
[08:25:53.346]         {
[08:25:53.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.346]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.346]             }
[08:25:53.346]             base::options(...future.oldOptions)
[08:25:53.346]             if (.Platform$OS.type == "windows") {
[08:25:53.346]                 old_names <- names(...future.oldEnvVars)
[08:25:53.346]                 envs <- base::Sys.getenv()
[08:25:53.346]                 names <- names(envs)
[08:25:53.346]                 common <- intersect(names, old_names)
[08:25:53.346]                 added <- setdiff(names, old_names)
[08:25:53.346]                 removed <- setdiff(old_names, names)
[08:25:53.346]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.346]                   envs[common]]
[08:25:53.346]                 NAMES <- toupper(changed)
[08:25:53.346]                 args <- list()
[08:25:53.346]                 for (kk in seq_along(NAMES)) {
[08:25:53.346]                   name <- changed[[kk]]
[08:25:53.346]                   NAME <- NAMES[[kk]]
[08:25:53.346]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.346]                     next
[08:25:53.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.346]                 }
[08:25:53.346]                 NAMES <- toupper(added)
[08:25:53.346]                 for (kk in seq_along(NAMES)) {
[08:25:53.346]                   name <- added[[kk]]
[08:25:53.346]                   NAME <- NAMES[[kk]]
[08:25:53.346]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.346]                     next
[08:25:53.346]                   args[[name]] <- ""
[08:25:53.346]                 }
[08:25:53.346]                 NAMES <- toupper(removed)
[08:25:53.346]                 for (kk in seq_along(NAMES)) {
[08:25:53.346]                   name <- removed[[kk]]
[08:25:53.346]                   NAME <- NAMES[[kk]]
[08:25:53.346]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.346]                     next
[08:25:53.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.346]                 }
[08:25:53.346]                 if (length(args) > 0) 
[08:25:53.346]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.346]             }
[08:25:53.346]             else {
[08:25:53.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.346]             }
[08:25:53.346]             {
[08:25:53.346]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.346]                   0L) {
[08:25:53.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.346]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.346]                   base::options(opts)
[08:25:53.346]                 }
[08:25:53.346]                 {
[08:25:53.346]                   {
[08:25:53.346]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.346]                     NULL
[08:25:53.346]                   }
[08:25:53.346]                   options(future.plan = NULL)
[08:25:53.346]                   if (is.na(NA_character_)) 
[08:25:53.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.346]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.346]                     .init = FALSE)
[08:25:53.346]                 }
[08:25:53.346]             }
[08:25:53.346]         }
[08:25:53.346]     })
[08:25:53.346]     if (TRUE) {
[08:25:53.346]         base::sink(type = "output", split = FALSE)
[08:25:53.346]         if (TRUE) {
[08:25:53.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.346]         }
[08:25:53.346]         else {
[08:25:53.346]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.346]         }
[08:25:53.346]         base::close(...future.stdout)
[08:25:53.346]         ...future.stdout <- NULL
[08:25:53.346]     }
[08:25:53.346]     ...future.result$conditions <- ...future.conditions
[08:25:53.346]     ...future.result$finished <- base::Sys.time()
[08:25:53.346]     ...future.result
[08:25:53.346] }
[08:25:53.349] Exporting 5 global objects (1.05 KiB) to cluster node #2 ...
[08:25:53.349] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ...
[08:25:53.350] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ... DONE
[08:25:53.350] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ...
[08:25:53.350] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ... DONE
[08:25:53.350] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ...
[08:25:53.351] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ... DONE
[08:25:53.351] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:53.351] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.351] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:53.352] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.352] Exporting 5 global objects (1.05 KiB) to cluster node #2 ... DONE
[08:25:53.352] MultisessionFuture started
[08:25:53.352] - Launch lazy future ... done
[08:25:53.352] run() for ‘MultisessionFuture’ ... done
[08:25:53.353] Created future:
[08:25:53.353] MultisessionFuture:
[08:25:53.353] Label: ‘future_mapply-2’
[08:25:53.353] Expression:
[08:25:53.353] {
[08:25:53.353]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.353]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.353]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.353]         on.exit(options(oopts), add = TRUE)
[08:25:53.353]     }
[08:25:53.353]     {
[08:25:53.353]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.353]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.353]         do.call(mapply, args = args)
[08:25:53.353]     }
[08:25:53.353] }
[08:25:53.353] Lazy evaluation: FALSE
[08:25:53.353] Asynchronous evaluation: TRUE
[08:25:53.353] Local evaluation: TRUE
[08:25:53.353] Environment: R_GlobalEnv
[08:25:53.353] Capture standard output: TRUE
[08:25:53.353] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.353] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.353] Packages: <none>
[08:25:53.353] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.353] Resolved: FALSE
[08:25:53.353] Value: <not collected>
[08:25:53.353] Conditions captured: <none>
[08:25:53.353] Early signaling: FALSE
[08:25:53.353] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.353] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.364] Chunk #2 of 2 ... DONE
[08:25:53.364] Launching 2 futures (chunks) ... DONE
[08:25:53.364] Resolving 2 futures (chunks) ...
[08:25:53.365] resolve() on list ...
[08:25:53.365]  recursive: 0
[08:25:53.365]  length: 2
[08:25:53.365] 
[08:25:53.365] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.365] - Validating connection of MultisessionFuture
[08:25:53.366] - received message: FutureResult
[08:25:53.366] - Received FutureResult
[08:25:53.366] - Erased future from FutureRegistry
[08:25:53.366] result() for ClusterFuture ...
[08:25:53.366] - result already collected: FutureResult
[08:25:53.366] result() for ClusterFuture ... done
[08:25:53.366] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.366] Future #1
[08:25:53.366] result() for ClusterFuture ...
[08:25:53.366] - result already collected: FutureResult
[08:25:53.367] result() for ClusterFuture ... done
[08:25:53.367] result() for ClusterFuture ...
[08:25:53.367] - result already collected: FutureResult
[08:25:53.367] result() for ClusterFuture ... done
[08:25:53.367] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:53.367] - nx: 2
[08:25:53.367] - relay: TRUE
[08:25:53.367] - stdout: TRUE
[08:25:53.367] - signal: TRUE
[08:25:53.367] - resignal: FALSE
[08:25:53.367] - force: TRUE
[08:25:53.367] - relayed: [n=2] FALSE, FALSE
[08:25:53.368] - queued futures: [n=2] FALSE, FALSE
[08:25:53.368]  - until=1
[08:25:53.368]  - relaying element #1
[08:25:53.368] result() for ClusterFuture ...
[08:25:53.368] - result already collected: FutureResult
[08:25:53.368] result() for ClusterFuture ... done
[08:25:53.368] result() for ClusterFuture ...
[08:25:53.368] - result already collected: FutureResult
[08:25:53.368] result() for ClusterFuture ... done
[08:25:53.368] result() for ClusterFuture ...
[08:25:53.368] - result already collected: FutureResult
[08:25:53.369] result() for ClusterFuture ... done
[08:25:53.369] result() for ClusterFuture ...
[08:25:53.369] - result already collected: FutureResult
[08:25:53.369] result() for ClusterFuture ... done
[08:25:53.369] - relayed: [n=2] TRUE, FALSE
[08:25:53.369] - queued futures: [n=2] TRUE, FALSE
[08:25:53.369] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:53.369]  length: 1 (resolved future 1)
[08:25:53.394] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.394] - Validating connection of MultisessionFuture
[08:25:53.395] - received message: FutureResult
[08:25:53.395] - Received FutureResult
[08:25:53.395] - Erased future from FutureRegistry
[08:25:53.395] result() for ClusterFuture ...
[08:25:53.395] - result already collected: FutureResult
[08:25:53.395] result() for ClusterFuture ... done
[08:25:53.395] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.395] Future #2
[08:25:53.395] result() for ClusterFuture ...
[08:25:53.396] - result already collected: FutureResult
[08:25:53.396] result() for ClusterFuture ... done
[08:25:53.396] result() for ClusterFuture ...
[08:25:53.396] - result already collected: FutureResult
[08:25:53.396] result() for ClusterFuture ... done
[08:25:53.396] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:53.396] - nx: 2
[08:25:53.396] - relay: TRUE
[08:25:53.396] - stdout: TRUE
[08:25:53.396] - signal: TRUE
[08:25:53.396] - resignal: FALSE
[08:25:53.396] - force: TRUE
[08:25:53.397] - relayed: [n=2] TRUE, FALSE
[08:25:53.397] - queued futures: [n=2] TRUE, FALSE
[08:25:53.397]  - until=2
[08:25:53.397]  - relaying element #2
[08:25:53.397] result() for ClusterFuture ...
[08:25:53.397] - result already collected: FutureResult
[08:25:53.397] result() for ClusterFuture ... done
[08:25:53.397] result() for ClusterFuture ...
[08:25:53.397] - result already collected: FutureResult
[08:25:53.397] result() for ClusterFuture ... done
[08:25:53.397] result() for ClusterFuture ...
[08:25:53.398] - result already collected: FutureResult
[08:25:53.398] result() for ClusterFuture ... done
[08:25:53.398] result() for ClusterFuture ...
[08:25:53.398] - result already collected: FutureResult
[08:25:53.398] result() for ClusterFuture ... done
[08:25:53.398] - relayed: [n=2] TRUE, TRUE
[08:25:53.398] - queued futures: [n=2] TRUE, TRUE
[08:25:53.398] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:53.398]  length: 0 (resolved future 2)
[08:25:53.398] Relaying remaining futures
[08:25:53.398] signalConditionsASAP(NULL, pos=0) ...
[08:25:53.398] - nx: 2
[08:25:53.399] - relay: TRUE
[08:25:53.399] - stdout: TRUE
[08:25:53.399] - signal: TRUE
[08:25:53.399] - resignal: FALSE
[08:25:53.399] - force: TRUE
[08:25:53.399] - relayed: [n=2] TRUE, TRUE
[08:25:53.399] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:53.399] - relayed: [n=2] TRUE, TRUE
[08:25:53.399] - queued futures: [n=2] TRUE, TRUE
[08:25:53.399] signalConditionsASAP(NULL, pos=0) ... done
[08:25:53.399] resolve() on list ... DONE
[08:25:53.399] result() for ClusterFuture ...
[08:25:53.400] - result already collected: FutureResult
[08:25:53.400] result() for ClusterFuture ... done
[08:25:53.400] result() for ClusterFuture ...
[08:25:53.400] - result already collected: FutureResult
[08:25:53.400] result() for ClusterFuture ... done
[08:25:53.400] result() for ClusterFuture ...
[08:25:53.400] - result already collected: FutureResult
[08:25:53.400] result() for ClusterFuture ... done
[08:25:53.400] result() for ClusterFuture ...
[08:25:53.400] - result already collected: FutureResult
[08:25:53.400] result() for ClusterFuture ... done
[08:25:53.401]  - Number of value chunks collected: 2
[08:25:53.401] Resolving 2 futures (chunks) ... DONE
[08:25:53.401] Reducing values from 2 chunks ...
[08:25:53.401]  - Number of values collected after concatenation: 2
[08:25:53.401]  - Number of values expected: 2
[08:25:53.401] Reducing values from 2 chunks ... DONE
[08:25:53.401] future_mapply() ... DONE
[08:25:53.401] future_mapply() ...
[08:25:53.401] Generating random seeds ...
[08:25:53.401] Generating random seed streams for 2 elements ...
[08:25:53.402] Generating random seed streams for 2 elements ... DONE
[08:25:53.402] Generating random seeds ... DONE
[08:25:53.402] Will set RNG state on exit: 10407, -67364518, -348196630, 577742858, -2017247128, -1297429740, -270178576
[08:25:53.403] Number of chunks: 2
[08:25:53.404] getGlobalsAndPackagesXApply() ...
[08:25:53.404]  - future.globals: TRUE
[08:25:53.404] getGlobalsAndPackages() ...
[08:25:53.404] Searching for globals...
[08:25:53.405] - globals found: [1] ‘FUN’
[08:25:53.405] Searching for globals ... DONE
[08:25:53.405] Resolving globals: FALSE
[08:25:53.405] The total size of the 1 globals is 326 bytes (326 bytes)
[08:25:53.406] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[08:25:53.406] - globals: [1] ‘FUN’
[08:25:53.406] 
[08:25:53.406] getGlobalsAndPackages() ... DONE
[08:25:53.406]  - globals found/used: [n=1] ‘FUN’
[08:25:53.406]  - needed namespaces: [n=0] 
[08:25:53.406] Finding globals ... DONE
[08:25:53.407] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:53.407] List of 2
[08:25:53.407]  $ ...future.FUN:function (x, y)  
[08:25:53.407]  $ MoreArgs     :List of 1
[08:25:53.407]   ..$ y: int [1:2] 3 4
[08:25:53.407]  - attr(*, "where")=List of 2
[08:25:53.407]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:53.407]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:53.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:53.407]  - attr(*, "resolved")= logi FALSE
[08:25:53.407]  - attr(*, "total_size")= num NA
[08:25:53.410] Packages to be attached in all futures: [n=0] 
[08:25:53.410] getGlobalsAndPackagesXApply() ... DONE
[08:25:53.410] Number of futures (= number of chunks): 2
[08:25:53.410] Launching 2 futures (chunks) ...
[08:25:53.410] Chunk #1 of 2 ...
[08:25:53.410]  - Finding globals in '...' for chunk #1 ...
[08:25:53.410] getGlobalsAndPackages() ...
[08:25:53.410] Searching for globals...
[08:25:53.411] 
[08:25:53.411] Searching for globals ... DONE
[08:25:53.411] - globals: [0] <none>
[08:25:53.411] getGlobalsAndPackages() ... DONE
[08:25:53.411]    + additional globals found: [n=0] 
[08:25:53.411]    + additional namespaces needed: [n=0] 
[08:25:53.411]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:53.411]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.411]  - seeds: [1] <seeds>
[08:25:53.412]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.412] getGlobalsAndPackages() ...
[08:25:53.412] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.412] Resolving globals: FALSE
[08:25:53.412] The total size of the 5 globals is 696 bytes (696 bytes)
[08:25:53.413] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:53.413] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.413] 
[08:25:53.413] getGlobalsAndPackages() ... DONE
[08:25:53.413] run() for ‘Future’ ...
[08:25:53.413] - state: ‘created’
[08:25:53.414] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.428] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.428]   - Field: ‘node’
[08:25:53.429]   - Field: ‘label’
[08:25:53.429]   - Field: ‘local’
[08:25:53.429]   - Field: ‘owner’
[08:25:53.429]   - Field: ‘envir’
[08:25:53.429]   - Field: ‘workers’
[08:25:53.429]   - Field: ‘packages’
[08:25:53.429]   - Field: ‘gc’
[08:25:53.429]   - Field: ‘conditions’
[08:25:53.429]   - Field: ‘persistent’
[08:25:53.429]   - Field: ‘expr’
[08:25:53.429]   - Field: ‘uuid’
[08:25:53.430]   - Field: ‘seed’
[08:25:53.430]   - Field: ‘version’
[08:25:53.430]   - Field: ‘result’
[08:25:53.430]   - Field: ‘asynchronous’
[08:25:53.430]   - Field: ‘calls’
[08:25:53.430]   - Field: ‘globals’
[08:25:53.430]   - Field: ‘stdout’
[08:25:53.430]   - Field: ‘earlySignal’
[08:25:53.430]   - Field: ‘lazy’
[08:25:53.430]   - Field: ‘state’
[08:25:53.430] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.430] - Launch lazy future ...
[08:25:53.431] Packages needed by the future expression (n = 0): <none>
[08:25:53.431] Packages needed by future strategies (n = 0): <none>
[08:25:53.431] {
[08:25:53.431]     {
[08:25:53.431]         {
[08:25:53.431]             ...future.startTime <- base::Sys.time()
[08:25:53.431]             {
[08:25:53.431]                 {
[08:25:53.431]                   {
[08:25:53.431]                     {
[08:25:53.431]                       base::local({
[08:25:53.431]                         has_future <- base::requireNamespace("future", 
[08:25:53.431]                           quietly = TRUE)
[08:25:53.431]                         if (has_future) {
[08:25:53.431]                           ns <- base::getNamespace("future")
[08:25:53.431]                           version <- ns[[".package"]][["version"]]
[08:25:53.431]                           if (is.null(version)) 
[08:25:53.431]                             version <- utils::packageVersion("future")
[08:25:53.431]                         }
[08:25:53.431]                         else {
[08:25:53.431]                           version <- NULL
[08:25:53.431]                         }
[08:25:53.431]                         if (!has_future || version < "1.8.0") {
[08:25:53.431]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.431]                             "", base::R.version$version.string), 
[08:25:53.431]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.431]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.431]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.431]                               "release", "version")], collapse = " "), 
[08:25:53.431]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.431]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.431]                             info)
[08:25:53.431]                           info <- base::paste(info, collapse = "; ")
[08:25:53.431]                           if (!has_future) {
[08:25:53.431]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.431]                               info)
[08:25:53.431]                           }
[08:25:53.431]                           else {
[08:25:53.431]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.431]                               info, version)
[08:25:53.431]                           }
[08:25:53.431]                           base::stop(msg)
[08:25:53.431]                         }
[08:25:53.431]                       })
[08:25:53.431]                     }
[08:25:53.431]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.431]                     base::options(mc.cores = 1L)
[08:25:53.431]                   }
[08:25:53.431]                   ...future.strategy.old <- future::plan("list")
[08:25:53.431]                   options(future.plan = NULL)
[08:25:53.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.431]                 }
[08:25:53.431]                 ...future.workdir <- getwd()
[08:25:53.431]             }
[08:25:53.431]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.431]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.431]         }
[08:25:53.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.431]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.431]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.431]             base::names(...future.oldOptions))
[08:25:53.431]     }
[08:25:53.431]     if (FALSE) {
[08:25:53.431]     }
[08:25:53.431]     else {
[08:25:53.431]         if (TRUE) {
[08:25:53.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.431]                 open = "w")
[08:25:53.431]         }
[08:25:53.431]         else {
[08:25:53.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.431]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.431]         }
[08:25:53.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.431]             base::sink(type = "output", split = FALSE)
[08:25:53.431]             base::close(...future.stdout)
[08:25:53.431]         }, add = TRUE)
[08:25:53.431]     }
[08:25:53.431]     ...future.frame <- base::sys.nframe()
[08:25:53.431]     ...future.conditions <- base::list()
[08:25:53.431]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.431]     if (FALSE) {
[08:25:53.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.431]     }
[08:25:53.431]     ...future.result <- base::tryCatch({
[08:25:53.431]         base::withCallingHandlers({
[08:25:53.431]             ...future.value <- base::withVisible(base::local({
[08:25:53.431]                 ...future.makeSendCondition <- base::local({
[08:25:53.431]                   sendCondition <- NULL
[08:25:53.431]                   function(frame = 1L) {
[08:25:53.431]                     if (is.function(sendCondition)) 
[08:25:53.431]                       return(sendCondition)
[08:25:53.431]                     ns <- getNamespace("parallel")
[08:25:53.431]                     if (exists("sendData", mode = "function", 
[08:25:53.431]                       envir = ns)) {
[08:25:53.431]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.431]                         envir = ns)
[08:25:53.431]                       envir <- sys.frame(frame)
[08:25:53.431]                       master <- NULL
[08:25:53.431]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.431]                         !identical(envir, emptyenv())) {
[08:25:53.431]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.431]                           inherits = FALSE)) {
[08:25:53.431]                           master <- get("master", mode = "list", 
[08:25:53.431]                             envir = envir, inherits = FALSE)
[08:25:53.431]                           if (inherits(master, c("SOCKnode", 
[08:25:53.431]                             "SOCK0node"))) {
[08:25:53.431]                             sendCondition <<- function(cond) {
[08:25:53.431]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.431]                                 success = TRUE)
[08:25:53.431]                               parallel_sendData(master, data)
[08:25:53.431]                             }
[08:25:53.431]                             return(sendCondition)
[08:25:53.431]                           }
[08:25:53.431]                         }
[08:25:53.431]                         frame <- frame + 1L
[08:25:53.431]                         envir <- sys.frame(frame)
[08:25:53.431]                       }
[08:25:53.431]                     }
[08:25:53.431]                     sendCondition <<- function(cond) NULL
[08:25:53.431]                   }
[08:25:53.431]                 })
[08:25:53.431]                 withCallingHandlers({
[08:25:53.431]                   {
[08:25:53.431]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.431]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.431]                       ...future.globals.maxSize)) {
[08:25:53.431]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.431]                       on.exit(options(oopts), add = TRUE)
[08:25:53.431]                     }
[08:25:53.431]                     {
[08:25:53.431]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:53.431]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:53.431]                           envir = globalenv(), inherits = FALSE)
[08:25:53.431]                         ...future.FUN(...)
[08:25:53.431]                       }
[08:25:53.431]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:53.431]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:53.431]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.431]                         USE.NAMES = FALSE)
[08:25:53.431]                       do.call(mapply, args = args)
[08:25:53.431]                     }
[08:25:53.431]                   }
[08:25:53.431]                 }, immediateCondition = function(cond) {
[08:25:53.431]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.431]                   sendCondition(cond)
[08:25:53.431]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.431]                   {
[08:25:53.431]                     inherits <- base::inherits
[08:25:53.431]                     invokeRestart <- base::invokeRestart
[08:25:53.431]                     is.null <- base::is.null
[08:25:53.431]                     muffled <- FALSE
[08:25:53.431]                     if (inherits(cond, "message")) {
[08:25:53.431]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.431]                       if (muffled) 
[08:25:53.431]                         invokeRestart("muffleMessage")
[08:25:53.431]                     }
[08:25:53.431]                     else if (inherits(cond, "warning")) {
[08:25:53.431]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.431]                       if (muffled) 
[08:25:53.431]                         invokeRestart("muffleWarning")
[08:25:53.431]                     }
[08:25:53.431]                     else if (inherits(cond, "condition")) {
[08:25:53.431]                       if (!is.null(pattern)) {
[08:25:53.431]                         computeRestarts <- base::computeRestarts
[08:25:53.431]                         grepl <- base::grepl
[08:25:53.431]                         restarts <- computeRestarts(cond)
[08:25:53.431]                         for (restart in restarts) {
[08:25:53.431]                           name <- restart$name
[08:25:53.431]                           if (is.null(name)) 
[08:25:53.431]                             next
[08:25:53.431]                           if (!grepl(pattern, name)) 
[08:25:53.431]                             next
[08:25:53.431]                           invokeRestart(restart)
[08:25:53.431]                           muffled <- TRUE
[08:25:53.431]                           break
[08:25:53.431]                         }
[08:25:53.431]                       }
[08:25:53.431]                     }
[08:25:53.431]                     invisible(muffled)
[08:25:53.431]                   }
[08:25:53.431]                   muffleCondition(cond)
[08:25:53.431]                 })
[08:25:53.431]             }))
[08:25:53.431]             future::FutureResult(value = ...future.value$value, 
[08:25:53.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.431]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.431]                     ...future.globalenv.names))
[08:25:53.431]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.431]         }, condition = base::local({
[08:25:53.431]             c <- base::c
[08:25:53.431]             inherits <- base::inherits
[08:25:53.431]             invokeRestart <- base::invokeRestart
[08:25:53.431]             length <- base::length
[08:25:53.431]             list <- base::list
[08:25:53.431]             seq.int <- base::seq.int
[08:25:53.431]             signalCondition <- base::signalCondition
[08:25:53.431]             sys.calls <- base::sys.calls
[08:25:53.431]             `[[` <- base::`[[`
[08:25:53.431]             `+` <- base::`+`
[08:25:53.431]             `<<-` <- base::`<<-`
[08:25:53.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.431]                   3L)]
[08:25:53.431]             }
[08:25:53.431]             function(cond) {
[08:25:53.431]                 is_error <- inherits(cond, "error")
[08:25:53.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.431]                   NULL)
[08:25:53.431]                 if (is_error) {
[08:25:53.431]                   sessionInformation <- function() {
[08:25:53.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.431]                       search = base::search(), system = base::Sys.info())
[08:25:53.431]                   }
[08:25:53.431]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.431]                     cond$call), session = sessionInformation(), 
[08:25:53.431]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.431]                   signalCondition(cond)
[08:25:53.431]                 }
[08:25:53.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.431]                 "immediateCondition"))) {
[08:25:53.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.431]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.431]                   if (TRUE && !signal) {
[08:25:53.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.431]                     {
[08:25:53.431]                       inherits <- base::inherits
[08:25:53.431]                       invokeRestart <- base::invokeRestart
[08:25:53.431]                       is.null <- base::is.null
[08:25:53.431]                       muffled <- FALSE
[08:25:53.431]                       if (inherits(cond, "message")) {
[08:25:53.431]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.431]                         if (muffled) 
[08:25:53.431]                           invokeRestart("muffleMessage")
[08:25:53.431]                       }
[08:25:53.431]                       else if (inherits(cond, "warning")) {
[08:25:53.431]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.431]                         if (muffled) 
[08:25:53.431]                           invokeRestart("muffleWarning")
[08:25:53.431]                       }
[08:25:53.431]                       else if (inherits(cond, "condition")) {
[08:25:53.431]                         if (!is.null(pattern)) {
[08:25:53.431]                           computeRestarts <- base::computeRestarts
[08:25:53.431]                           grepl <- base::grepl
[08:25:53.431]                           restarts <- computeRestarts(cond)
[08:25:53.431]                           for (restart in restarts) {
[08:25:53.431]                             name <- restart$name
[08:25:53.431]                             if (is.null(name)) 
[08:25:53.431]                               next
[08:25:53.431]                             if (!grepl(pattern, name)) 
[08:25:53.431]                               next
[08:25:53.431]                             invokeRestart(restart)
[08:25:53.431]                             muffled <- TRUE
[08:25:53.431]                             break
[08:25:53.431]                           }
[08:25:53.431]                         }
[08:25:53.431]                       }
[08:25:53.431]                       invisible(muffled)
[08:25:53.431]                     }
[08:25:53.431]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.431]                   }
[08:25:53.431]                 }
[08:25:53.431]                 else {
[08:25:53.431]                   if (TRUE) {
[08:25:53.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.431]                     {
[08:25:53.431]                       inherits <- base::inherits
[08:25:53.431]                       invokeRestart <- base::invokeRestart
[08:25:53.431]                       is.null <- base::is.null
[08:25:53.431]                       muffled <- FALSE
[08:25:53.431]                       if (inherits(cond, "message")) {
[08:25:53.431]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.431]                         if (muffled) 
[08:25:53.431]                           invokeRestart("muffleMessage")
[08:25:53.431]                       }
[08:25:53.431]                       else if (inherits(cond, "warning")) {
[08:25:53.431]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.431]                         if (muffled) 
[08:25:53.431]                           invokeRestart("muffleWarning")
[08:25:53.431]                       }
[08:25:53.431]                       else if (inherits(cond, "condition")) {
[08:25:53.431]                         if (!is.null(pattern)) {
[08:25:53.431]                           computeRestarts <- base::computeRestarts
[08:25:53.431]                           grepl <- base::grepl
[08:25:53.431]                           restarts <- computeRestarts(cond)
[08:25:53.431]                           for (restart in restarts) {
[08:25:53.431]                             name <- restart$name
[08:25:53.431]                             if (is.null(name)) 
[08:25:53.431]                               next
[08:25:53.431]                             if (!grepl(pattern, name)) 
[08:25:53.431]                               next
[08:25:53.431]                             invokeRestart(restart)
[08:25:53.431]                             muffled <- TRUE
[08:25:53.431]                             break
[08:25:53.431]                           }
[08:25:53.431]                         }
[08:25:53.431]                       }
[08:25:53.431]                       invisible(muffled)
[08:25:53.431]                     }
[08:25:53.431]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.431]                   }
[08:25:53.431]                 }
[08:25:53.431]             }
[08:25:53.431]         }))
[08:25:53.431]     }, error = function(ex) {
[08:25:53.431]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.431]                 ...future.rng), started = ...future.startTime, 
[08:25:53.431]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.431]             version = "1.8"), class = "FutureResult")
[08:25:53.431]     }, finally = {
[08:25:53.431]         if (!identical(...future.workdir, getwd())) 
[08:25:53.431]             setwd(...future.workdir)
[08:25:53.431]         {
[08:25:53.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.431]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.431]             }
[08:25:53.431]             base::options(...future.oldOptions)
[08:25:53.431]             if (.Platform$OS.type == "windows") {
[08:25:53.431]                 old_names <- names(...future.oldEnvVars)
[08:25:53.431]                 envs <- base::Sys.getenv()
[08:25:53.431]                 names <- names(envs)
[08:25:53.431]                 common <- intersect(names, old_names)
[08:25:53.431]                 added <- setdiff(names, old_names)
[08:25:53.431]                 removed <- setdiff(old_names, names)
[08:25:53.431]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.431]                   envs[common]]
[08:25:53.431]                 NAMES <- toupper(changed)
[08:25:53.431]                 args <- list()
[08:25:53.431]                 for (kk in seq_along(NAMES)) {
[08:25:53.431]                   name <- changed[[kk]]
[08:25:53.431]                   NAME <- NAMES[[kk]]
[08:25:53.431]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.431]                     next
[08:25:53.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.431]                 }
[08:25:53.431]                 NAMES <- toupper(added)
[08:25:53.431]                 for (kk in seq_along(NAMES)) {
[08:25:53.431]                   name <- added[[kk]]
[08:25:53.431]                   NAME <- NAMES[[kk]]
[08:25:53.431]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.431]                     next
[08:25:53.431]                   args[[name]] <- ""
[08:25:53.431]                 }
[08:25:53.431]                 NAMES <- toupper(removed)
[08:25:53.431]                 for (kk in seq_along(NAMES)) {
[08:25:53.431]                   name <- removed[[kk]]
[08:25:53.431]                   NAME <- NAMES[[kk]]
[08:25:53.431]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.431]                     next
[08:25:53.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.431]                 }
[08:25:53.431]                 if (length(args) > 0) 
[08:25:53.431]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.431]             }
[08:25:53.431]             else {
[08:25:53.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.431]             }
[08:25:53.431]             {
[08:25:53.431]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.431]                   0L) {
[08:25:53.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.431]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.431]                   base::options(opts)
[08:25:53.431]                 }
[08:25:53.431]                 {
[08:25:53.431]                   {
[08:25:53.431]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.431]                     NULL
[08:25:53.431]                   }
[08:25:53.431]                   options(future.plan = NULL)
[08:25:53.431]                   if (is.na(NA_character_)) 
[08:25:53.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.431]                     .init = FALSE)
[08:25:53.431]                 }
[08:25:53.431]             }
[08:25:53.431]         }
[08:25:53.431]     })
[08:25:53.431]     if (TRUE) {
[08:25:53.431]         base::sink(type = "output", split = FALSE)
[08:25:53.431]         if (TRUE) {
[08:25:53.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.431]         }
[08:25:53.431]         else {
[08:25:53.431]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.431]         }
[08:25:53.431]         base::close(...future.stdout)
[08:25:53.431]         ...future.stdout <- NULL
[08:25:53.431]     }
[08:25:53.431]     ...future.result$conditions <- ...future.conditions
[08:25:53.431]     ...future.result$finished <- base::Sys.time()
[08:25:53.431]     ...future.result
[08:25:53.431] }
[08:25:53.434] Exporting 5 global objects (1.09 KiB) to cluster node #1 ...
[08:25:53.435] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ...
[08:25:53.435] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ... DONE
[08:25:53.435] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ...
[08:25:53.436] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ... DONE
[08:25:53.436] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ...
[08:25:53.436] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ... DONE
[08:25:53.436] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ...
[08:25:53.437] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ... DONE
[08:25:53.437] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:53.437] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.437] Exporting 5 global objects (1.09 KiB) to cluster node #1 ... DONE
[08:25:53.438] MultisessionFuture started
[08:25:53.438] - Launch lazy future ... done
[08:25:53.438] run() for ‘MultisessionFuture’ ... done
[08:25:53.438] Created future:
[08:25:53.438] MultisessionFuture:
[08:25:53.438] Label: ‘future_mapply-1’
[08:25:53.438] Expression:
[08:25:53.438] {
[08:25:53.438]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.438]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.438]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.438]         on.exit(options(oopts), add = TRUE)
[08:25:53.438]     }
[08:25:53.438]     {
[08:25:53.438]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:53.438]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:53.438]                 inherits = FALSE)
[08:25:53.438]             ...future.FUN(...)
[08:25:53.438]         }
[08:25:53.438]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:53.438]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:53.438]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.438]         do.call(mapply, args = args)
[08:25:53.438]     }
[08:25:53.438] }
[08:25:53.438] Lazy evaluation: FALSE
[08:25:53.438] Asynchronous evaluation: TRUE
[08:25:53.438] Local evaluation: TRUE
[08:25:53.438] Environment: R_GlobalEnv
[08:25:53.438] Capture standard output: TRUE
[08:25:53.438] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.438] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.438] Packages: <none>
[08:25:53.438] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:53.438] Resolved: FALSE
[08:25:53.438] Value: <not collected>
[08:25:53.438] Conditions captured: <none>
[08:25:53.438] Early signaling: FALSE
[08:25:53.438] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.438] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.449] Chunk #1 of 2 ... DONE
[08:25:53.450] Chunk #2 of 2 ...
[08:25:53.450]  - Finding globals in '...' for chunk #2 ...
[08:25:53.450] getGlobalsAndPackages() ...
[08:25:53.450] Searching for globals...
[08:25:53.450] 
[08:25:53.450] Searching for globals ... DONE
[08:25:53.451] - globals: [0] <none>
[08:25:53.451] getGlobalsAndPackages() ... DONE
[08:25:53.451]    + additional globals found: [n=0] 
[08:25:53.451]    + additional namespaces needed: [n=0] 
[08:25:53.451]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:53.451]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.451]  - seeds: [1] <seeds>
[08:25:53.451]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.451] getGlobalsAndPackages() ...
[08:25:53.451] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.451] Resolving globals: FALSE
[08:25:53.452] The total size of the 5 globals is 696 bytes (696 bytes)
[08:25:53.452] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 696 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:53.453] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.453] 
[08:25:53.453] getGlobalsAndPackages() ... DONE
[08:25:53.453] run() for ‘Future’ ...
[08:25:53.453] - state: ‘created’
[08:25:53.453] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.467] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.467]   - Field: ‘node’
[08:25:53.467]   - Field: ‘label’
[08:25:53.468]   - Field: ‘local’
[08:25:53.468]   - Field: ‘owner’
[08:25:53.468]   - Field: ‘envir’
[08:25:53.468]   - Field: ‘workers’
[08:25:53.468]   - Field: ‘packages’
[08:25:53.468]   - Field: ‘gc’
[08:25:53.468]   - Field: ‘conditions’
[08:25:53.468]   - Field: ‘persistent’
[08:25:53.468]   - Field: ‘expr’
[08:25:53.468]   - Field: ‘uuid’
[08:25:53.468]   - Field: ‘seed’
[08:25:53.469]   - Field: ‘version’
[08:25:53.469]   - Field: ‘result’
[08:25:53.469]   - Field: ‘asynchronous’
[08:25:53.469]   - Field: ‘calls’
[08:25:53.469]   - Field: ‘globals’
[08:25:53.469]   - Field: ‘stdout’
[08:25:53.469]   - Field: ‘earlySignal’
[08:25:53.469]   - Field: ‘lazy’
[08:25:53.469]   - Field: ‘state’
[08:25:53.469] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.469] - Launch lazy future ...
[08:25:53.470] Packages needed by the future expression (n = 0): <none>
[08:25:53.470] Packages needed by future strategies (n = 0): <none>
[08:25:53.470] {
[08:25:53.470]     {
[08:25:53.470]         {
[08:25:53.470]             ...future.startTime <- base::Sys.time()
[08:25:53.470]             {
[08:25:53.470]                 {
[08:25:53.470]                   {
[08:25:53.470]                     {
[08:25:53.470]                       base::local({
[08:25:53.470]                         has_future <- base::requireNamespace("future", 
[08:25:53.470]                           quietly = TRUE)
[08:25:53.470]                         if (has_future) {
[08:25:53.470]                           ns <- base::getNamespace("future")
[08:25:53.470]                           version <- ns[[".package"]][["version"]]
[08:25:53.470]                           if (is.null(version)) 
[08:25:53.470]                             version <- utils::packageVersion("future")
[08:25:53.470]                         }
[08:25:53.470]                         else {
[08:25:53.470]                           version <- NULL
[08:25:53.470]                         }
[08:25:53.470]                         if (!has_future || version < "1.8.0") {
[08:25:53.470]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.470]                             "", base::R.version$version.string), 
[08:25:53.470]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.470]                               "release", "version")], collapse = " "), 
[08:25:53.470]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.470]                             info)
[08:25:53.470]                           info <- base::paste(info, collapse = "; ")
[08:25:53.470]                           if (!has_future) {
[08:25:53.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.470]                               info)
[08:25:53.470]                           }
[08:25:53.470]                           else {
[08:25:53.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.470]                               info, version)
[08:25:53.470]                           }
[08:25:53.470]                           base::stop(msg)
[08:25:53.470]                         }
[08:25:53.470]                       })
[08:25:53.470]                     }
[08:25:53.470]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.470]                     base::options(mc.cores = 1L)
[08:25:53.470]                   }
[08:25:53.470]                   ...future.strategy.old <- future::plan("list")
[08:25:53.470]                   options(future.plan = NULL)
[08:25:53.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.470]                 }
[08:25:53.470]                 ...future.workdir <- getwd()
[08:25:53.470]             }
[08:25:53.470]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.470]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.470]         }
[08:25:53.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.470]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.470]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.470]             base::names(...future.oldOptions))
[08:25:53.470]     }
[08:25:53.470]     if (FALSE) {
[08:25:53.470]     }
[08:25:53.470]     else {
[08:25:53.470]         if (TRUE) {
[08:25:53.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.470]                 open = "w")
[08:25:53.470]         }
[08:25:53.470]         else {
[08:25:53.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.470]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.470]         }
[08:25:53.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.470]             base::sink(type = "output", split = FALSE)
[08:25:53.470]             base::close(...future.stdout)
[08:25:53.470]         }, add = TRUE)
[08:25:53.470]     }
[08:25:53.470]     ...future.frame <- base::sys.nframe()
[08:25:53.470]     ...future.conditions <- base::list()
[08:25:53.470]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.470]     if (FALSE) {
[08:25:53.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.470]     }
[08:25:53.470]     ...future.result <- base::tryCatch({
[08:25:53.470]         base::withCallingHandlers({
[08:25:53.470]             ...future.value <- base::withVisible(base::local({
[08:25:53.470]                 ...future.makeSendCondition <- base::local({
[08:25:53.470]                   sendCondition <- NULL
[08:25:53.470]                   function(frame = 1L) {
[08:25:53.470]                     if (is.function(sendCondition)) 
[08:25:53.470]                       return(sendCondition)
[08:25:53.470]                     ns <- getNamespace("parallel")
[08:25:53.470]                     if (exists("sendData", mode = "function", 
[08:25:53.470]                       envir = ns)) {
[08:25:53.470]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.470]                         envir = ns)
[08:25:53.470]                       envir <- sys.frame(frame)
[08:25:53.470]                       master <- NULL
[08:25:53.470]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.470]                         !identical(envir, emptyenv())) {
[08:25:53.470]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.470]                           inherits = FALSE)) {
[08:25:53.470]                           master <- get("master", mode = "list", 
[08:25:53.470]                             envir = envir, inherits = FALSE)
[08:25:53.470]                           if (inherits(master, c("SOCKnode", 
[08:25:53.470]                             "SOCK0node"))) {
[08:25:53.470]                             sendCondition <<- function(cond) {
[08:25:53.470]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.470]                                 success = TRUE)
[08:25:53.470]                               parallel_sendData(master, data)
[08:25:53.470]                             }
[08:25:53.470]                             return(sendCondition)
[08:25:53.470]                           }
[08:25:53.470]                         }
[08:25:53.470]                         frame <- frame + 1L
[08:25:53.470]                         envir <- sys.frame(frame)
[08:25:53.470]                       }
[08:25:53.470]                     }
[08:25:53.470]                     sendCondition <<- function(cond) NULL
[08:25:53.470]                   }
[08:25:53.470]                 })
[08:25:53.470]                 withCallingHandlers({
[08:25:53.470]                   {
[08:25:53.470]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.470]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.470]                       ...future.globals.maxSize)) {
[08:25:53.470]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.470]                       on.exit(options(oopts), add = TRUE)
[08:25:53.470]                     }
[08:25:53.470]                     {
[08:25:53.470]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:53.470]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:53.470]                           envir = globalenv(), inherits = FALSE)
[08:25:53.470]                         ...future.FUN(...)
[08:25:53.470]                       }
[08:25:53.470]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:53.470]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:53.470]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.470]                         USE.NAMES = FALSE)
[08:25:53.470]                       do.call(mapply, args = args)
[08:25:53.470]                     }
[08:25:53.470]                   }
[08:25:53.470]                 }, immediateCondition = function(cond) {
[08:25:53.470]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.470]                   sendCondition(cond)
[08:25:53.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.470]                   {
[08:25:53.470]                     inherits <- base::inherits
[08:25:53.470]                     invokeRestart <- base::invokeRestart
[08:25:53.470]                     is.null <- base::is.null
[08:25:53.470]                     muffled <- FALSE
[08:25:53.470]                     if (inherits(cond, "message")) {
[08:25:53.470]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.470]                       if (muffled) 
[08:25:53.470]                         invokeRestart("muffleMessage")
[08:25:53.470]                     }
[08:25:53.470]                     else if (inherits(cond, "warning")) {
[08:25:53.470]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.470]                       if (muffled) 
[08:25:53.470]                         invokeRestart("muffleWarning")
[08:25:53.470]                     }
[08:25:53.470]                     else if (inherits(cond, "condition")) {
[08:25:53.470]                       if (!is.null(pattern)) {
[08:25:53.470]                         computeRestarts <- base::computeRestarts
[08:25:53.470]                         grepl <- base::grepl
[08:25:53.470]                         restarts <- computeRestarts(cond)
[08:25:53.470]                         for (restart in restarts) {
[08:25:53.470]                           name <- restart$name
[08:25:53.470]                           if (is.null(name)) 
[08:25:53.470]                             next
[08:25:53.470]                           if (!grepl(pattern, name)) 
[08:25:53.470]                             next
[08:25:53.470]                           invokeRestart(restart)
[08:25:53.470]                           muffled <- TRUE
[08:25:53.470]                           break
[08:25:53.470]                         }
[08:25:53.470]                       }
[08:25:53.470]                     }
[08:25:53.470]                     invisible(muffled)
[08:25:53.470]                   }
[08:25:53.470]                   muffleCondition(cond)
[08:25:53.470]                 })
[08:25:53.470]             }))
[08:25:53.470]             future::FutureResult(value = ...future.value$value, 
[08:25:53.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.470]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.470]                     ...future.globalenv.names))
[08:25:53.470]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.470]         }, condition = base::local({
[08:25:53.470]             c <- base::c
[08:25:53.470]             inherits <- base::inherits
[08:25:53.470]             invokeRestart <- base::invokeRestart
[08:25:53.470]             length <- base::length
[08:25:53.470]             list <- base::list
[08:25:53.470]             seq.int <- base::seq.int
[08:25:53.470]             signalCondition <- base::signalCondition
[08:25:53.470]             sys.calls <- base::sys.calls
[08:25:53.470]             `[[` <- base::`[[`
[08:25:53.470]             `+` <- base::`+`
[08:25:53.470]             `<<-` <- base::`<<-`
[08:25:53.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.470]                   3L)]
[08:25:53.470]             }
[08:25:53.470]             function(cond) {
[08:25:53.470]                 is_error <- inherits(cond, "error")
[08:25:53.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.470]                   NULL)
[08:25:53.470]                 if (is_error) {
[08:25:53.470]                   sessionInformation <- function() {
[08:25:53.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.470]                       search = base::search(), system = base::Sys.info())
[08:25:53.470]                   }
[08:25:53.470]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.470]                     cond$call), session = sessionInformation(), 
[08:25:53.470]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.470]                   signalCondition(cond)
[08:25:53.470]                 }
[08:25:53.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.470]                 "immediateCondition"))) {
[08:25:53.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.470]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.470]                   if (TRUE && !signal) {
[08:25:53.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.470]                     {
[08:25:53.470]                       inherits <- base::inherits
[08:25:53.470]                       invokeRestart <- base::invokeRestart
[08:25:53.470]                       is.null <- base::is.null
[08:25:53.470]                       muffled <- FALSE
[08:25:53.470]                       if (inherits(cond, "message")) {
[08:25:53.470]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.470]                         if (muffled) 
[08:25:53.470]                           invokeRestart("muffleMessage")
[08:25:53.470]                       }
[08:25:53.470]                       else if (inherits(cond, "warning")) {
[08:25:53.470]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.470]                         if (muffled) 
[08:25:53.470]                           invokeRestart("muffleWarning")
[08:25:53.470]                       }
[08:25:53.470]                       else if (inherits(cond, "condition")) {
[08:25:53.470]                         if (!is.null(pattern)) {
[08:25:53.470]                           computeRestarts <- base::computeRestarts
[08:25:53.470]                           grepl <- base::grepl
[08:25:53.470]                           restarts <- computeRestarts(cond)
[08:25:53.470]                           for (restart in restarts) {
[08:25:53.470]                             name <- restart$name
[08:25:53.470]                             if (is.null(name)) 
[08:25:53.470]                               next
[08:25:53.470]                             if (!grepl(pattern, name)) 
[08:25:53.470]                               next
[08:25:53.470]                             invokeRestart(restart)
[08:25:53.470]                             muffled <- TRUE
[08:25:53.470]                             break
[08:25:53.470]                           }
[08:25:53.470]                         }
[08:25:53.470]                       }
[08:25:53.470]                       invisible(muffled)
[08:25:53.470]                     }
[08:25:53.470]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.470]                   }
[08:25:53.470]                 }
[08:25:53.470]                 else {
[08:25:53.470]                   if (TRUE) {
[08:25:53.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.470]                     {
[08:25:53.470]                       inherits <- base::inherits
[08:25:53.470]                       invokeRestart <- base::invokeRestart
[08:25:53.470]                       is.null <- base::is.null
[08:25:53.470]                       muffled <- FALSE
[08:25:53.470]                       if (inherits(cond, "message")) {
[08:25:53.470]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.470]                         if (muffled) 
[08:25:53.470]                           invokeRestart("muffleMessage")
[08:25:53.470]                       }
[08:25:53.470]                       else if (inherits(cond, "warning")) {
[08:25:53.470]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.470]                         if (muffled) 
[08:25:53.470]                           invokeRestart("muffleWarning")
[08:25:53.470]                       }
[08:25:53.470]                       else if (inherits(cond, "condition")) {
[08:25:53.470]                         if (!is.null(pattern)) {
[08:25:53.470]                           computeRestarts <- base::computeRestarts
[08:25:53.470]                           grepl <- base::grepl
[08:25:53.470]                           restarts <- computeRestarts(cond)
[08:25:53.470]                           for (restart in restarts) {
[08:25:53.470]                             name <- restart$name
[08:25:53.470]                             if (is.null(name)) 
[08:25:53.470]                               next
[08:25:53.470]                             if (!grepl(pattern, name)) 
[08:25:53.470]                               next
[08:25:53.470]                             invokeRestart(restart)
[08:25:53.470]                             muffled <- TRUE
[08:25:53.470]                             break
[08:25:53.470]                           }
[08:25:53.470]                         }
[08:25:53.470]                       }
[08:25:53.470]                       invisible(muffled)
[08:25:53.470]                     }
[08:25:53.470]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.470]                   }
[08:25:53.470]                 }
[08:25:53.470]             }
[08:25:53.470]         }))
[08:25:53.470]     }, error = function(ex) {
[08:25:53.470]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.470]                 ...future.rng), started = ...future.startTime, 
[08:25:53.470]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.470]             version = "1.8"), class = "FutureResult")
[08:25:53.470]     }, finally = {
[08:25:53.470]         if (!identical(...future.workdir, getwd())) 
[08:25:53.470]             setwd(...future.workdir)
[08:25:53.470]         {
[08:25:53.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.470]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.470]             }
[08:25:53.470]             base::options(...future.oldOptions)
[08:25:53.470]             if (.Platform$OS.type == "windows") {
[08:25:53.470]                 old_names <- names(...future.oldEnvVars)
[08:25:53.470]                 envs <- base::Sys.getenv()
[08:25:53.470]                 names <- names(envs)
[08:25:53.470]                 common <- intersect(names, old_names)
[08:25:53.470]                 added <- setdiff(names, old_names)
[08:25:53.470]                 removed <- setdiff(old_names, names)
[08:25:53.470]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.470]                   envs[common]]
[08:25:53.470]                 NAMES <- toupper(changed)
[08:25:53.470]                 args <- list()
[08:25:53.470]                 for (kk in seq_along(NAMES)) {
[08:25:53.470]                   name <- changed[[kk]]
[08:25:53.470]                   NAME <- NAMES[[kk]]
[08:25:53.470]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.470]                     next
[08:25:53.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.470]                 }
[08:25:53.470]                 NAMES <- toupper(added)
[08:25:53.470]                 for (kk in seq_along(NAMES)) {
[08:25:53.470]                   name <- added[[kk]]
[08:25:53.470]                   NAME <- NAMES[[kk]]
[08:25:53.470]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.470]                     next
[08:25:53.470]                   args[[name]] <- ""
[08:25:53.470]                 }
[08:25:53.470]                 NAMES <- toupper(removed)
[08:25:53.470]                 for (kk in seq_along(NAMES)) {
[08:25:53.470]                   name <- removed[[kk]]
[08:25:53.470]                   NAME <- NAMES[[kk]]
[08:25:53.470]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.470]                     next
[08:25:53.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.470]                 }
[08:25:53.470]                 if (length(args) > 0) 
[08:25:53.470]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.470]             }
[08:25:53.470]             else {
[08:25:53.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.470]             }
[08:25:53.470]             {
[08:25:53.470]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.470]                   0L) {
[08:25:53.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.470]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.470]                   base::options(opts)
[08:25:53.470]                 }
[08:25:53.470]                 {
[08:25:53.470]                   {
[08:25:53.470]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.470]                     NULL
[08:25:53.470]                   }
[08:25:53.470]                   options(future.plan = NULL)
[08:25:53.470]                   if (is.na(NA_character_)) 
[08:25:53.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.470]                     .init = FALSE)
[08:25:53.470]                 }
[08:25:53.470]             }
[08:25:53.470]         }
[08:25:53.470]     })
[08:25:53.470]     if (TRUE) {
[08:25:53.470]         base::sink(type = "output", split = FALSE)
[08:25:53.470]         if (TRUE) {
[08:25:53.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.470]         }
[08:25:53.470]         else {
[08:25:53.470]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.470]         }
[08:25:53.470]         base::close(...future.stdout)
[08:25:53.470]         ...future.stdout <- NULL
[08:25:53.470]     }
[08:25:53.470]     ...future.result$conditions <- ...future.conditions
[08:25:53.470]     ...future.result$finished <- base::Sys.time()
[08:25:53.470]     ...future.result
[08:25:53.470] }
[08:25:53.473] Exporting 5 global objects (1.09 KiB) to cluster node #2 ...
[08:25:53.473] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ...
[08:25:53.474] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ... DONE
[08:25:53.474] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ...
[08:25:53.474] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ... DONE
[08:25:53.474] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ...
[08:25:53.475] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ... DONE
[08:25:53.475] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ...
[08:25:53.475] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ... DONE
[08:25:53.475] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:53.476] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.476] Exporting 5 global objects (1.09 KiB) to cluster node #2 ... DONE
[08:25:53.476] MultisessionFuture started
[08:25:53.476] - Launch lazy future ... done
[08:25:53.477] run() for ‘MultisessionFuture’ ... done
[08:25:53.477] Created future:
[08:25:53.477] MultisessionFuture:
[08:25:53.477] Label: ‘future_mapply-2’
[08:25:53.477] Expression:
[08:25:53.477] {
[08:25:53.477]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.477]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.477]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.477]         on.exit(options(oopts), add = TRUE)
[08:25:53.477]     }
[08:25:53.477]     {
[08:25:53.477]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:53.477]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:53.477]                 inherits = FALSE)
[08:25:53.477]             ...future.FUN(...)
[08:25:53.477]         }
[08:25:53.477]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:53.477]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:53.477]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.477]         do.call(mapply, args = args)
[08:25:53.477]     }
[08:25:53.477] }
[08:25:53.477] Lazy evaluation: FALSE
[08:25:53.477] Asynchronous evaluation: TRUE
[08:25:53.477] Local evaluation: TRUE
[08:25:53.477] Environment: R_GlobalEnv
[08:25:53.477] Capture standard output: TRUE
[08:25:53.477] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.477] Globals: 5 objects totaling 696 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, list ‘...future.seeds_ii’ of 67 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.477] Packages: <none>
[08:25:53.477] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:53.477] Resolved: FALSE
[08:25:53.477] Value: <not collected>
[08:25:53.477] Conditions captured: <none>
[08:25:53.477] Early signaling: FALSE
[08:25:53.477] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.477] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.488] Chunk #2 of 2 ... DONE
[08:25:53.488] Launching 2 futures (chunks) ... DONE
[08:25:53.489] Resolving 2 futures (chunks) ...
[08:25:53.489] resolve() on list ...
[08:25:53.489]  recursive: 0
[08:25:53.489]  length: 2
[08:25:53.489] 
[08:25:53.489] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.490] - Validating connection of MultisessionFuture
[08:25:53.490] - received message: FutureResult
[08:25:53.490] - Received FutureResult
[08:25:53.492] - Erased future from FutureRegistry
[08:25:53.493] result() for ClusterFuture ...
[08:25:53.493] - result already collected: FutureResult
[08:25:53.493] result() for ClusterFuture ... done
[08:25:53.493] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.493] Future #1
[08:25:53.493] result() for ClusterFuture ...
[08:25:53.493] - result already collected: FutureResult
[08:25:53.493] result() for ClusterFuture ... done
[08:25:53.493] result() for ClusterFuture ...
[08:25:53.493] - result already collected: FutureResult
[08:25:53.494] result() for ClusterFuture ... done
[08:25:53.494] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:53.494] - nx: 2
[08:25:53.494] - relay: TRUE
[08:25:53.494] - stdout: TRUE
[08:25:53.494] - signal: TRUE
[08:25:53.494] - resignal: FALSE
[08:25:53.494] - force: TRUE
[08:25:53.494] - relayed: [n=2] FALSE, FALSE
[08:25:53.494] - queued futures: [n=2] FALSE, FALSE
[08:25:53.494]  - until=1
[08:25:53.494]  - relaying element #1
[08:25:53.495] result() for ClusterFuture ...
[08:25:53.495] - result already collected: FutureResult
[08:25:53.495] result() for ClusterFuture ... done
[08:25:53.495] result() for ClusterFuture ...
[08:25:53.495] - result already collected: FutureResult
[08:25:53.495] result() for ClusterFuture ... done
[08:25:53.495] result() for ClusterFuture ...
[08:25:53.495] - result already collected: FutureResult
[08:25:53.495] result() for ClusterFuture ... done
[08:25:53.495] result() for ClusterFuture ...
[08:25:53.495] - result already collected: FutureResult
[08:25:53.496] result() for ClusterFuture ... done
[08:25:53.496] - relayed: [n=2] TRUE, FALSE
[08:25:53.496] - queued futures: [n=2] TRUE, FALSE
[08:25:53.496] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:53.496]  length: 1 (resolved future 1)
[08:25:53.518] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.519] - Validating connection of MultisessionFuture
[08:25:53.519] - received message: FutureResult
[08:25:53.519] - Received FutureResult
[08:25:53.519] - Erased future from FutureRegistry
[08:25:53.519] result() for ClusterFuture ...
[08:25:53.519] - result already collected: FutureResult
[08:25:53.519] result() for ClusterFuture ... done
[08:25:53.519] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.520] Future #2
[08:25:53.520] result() for ClusterFuture ...
[08:25:53.520] - result already collected: FutureResult
[08:25:53.520] result() for ClusterFuture ... done
[08:25:53.520] result() for ClusterFuture ...
[08:25:53.520] - result already collected: FutureResult
[08:25:53.520] result() for ClusterFuture ... done
[08:25:53.520] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:53.520] - nx: 2
[08:25:53.520] - relay: TRUE
[08:25:53.520] - stdout: TRUE
[08:25:53.521] - signal: TRUE
[08:25:53.521] - resignal: FALSE
[08:25:53.521] - force: TRUE
[08:25:53.521] - relayed: [n=2] TRUE, FALSE
[08:25:53.521] - queued futures: [n=2] TRUE, FALSE
[08:25:53.521]  - until=2
[08:25:53.521]  - relaying element #2
[08:25:53.521] result() for ClusterFuture ...
[08:25:53.521] - result already collected: FutureResult
[08:25:53.521] result() for ClusterFuture ... done
[08:25:53.521] result() for ClusterFuture ...
[08:25:53.521] - result already collected: FutureResult
[08:25:53.522] result() for ClusterFuture ... done
[08:25:53.522] result() for ClusterFuture ...
[08:25:53.522] - result already collected: FutureResult
[08:25:53.522] result() for ClusterFuture ... done
[08:25:53.522] result() for ClusterFuture ...
[08:25:53.522] - result already collected: FutureResult
[08:25:53.522] result() for ClusterFuture ... done
[08:25:53.522] - relayed: [n=2] TRUE, TRUE
[08:25:53.522] - queued futures: [n=2] TRUE, TRUE
[08:25:53.522] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:53.522]  length: 0 (resolved future 2)
[08:25:53.523] Relaying remaining futures
[08:25:53.523] signalConditionsASAP(NULL, pos=0) ...
[08:25:53.523] - nx: 2
[08:25:53.523] - relay: TRUE
[08:25:53.523] - stdout: TRUE
[08:25:53.523] - signal: TRUE
[08:25:53.523] - resignal: FALSE
[08:25:53.523] - force: TRUE
[08:25:53.523] - relayed: [n=2] TRUE, TRUE
[08:25:53.523] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:53.523] - relayed: [n=2] TRUE, TRUE
[08:25:53.523] - queued futures: [n=2] TRUE, TRUE
[08:25:53.524] signalConditionsASAP(NULL, pos=0) ... done
[08:25:53.524] resolve() on list ... DONE
[08:25:53.524] result() for ClusterFuture ...
[08:25:53.524] - result already collected: FutureResult
[08:25:53.524] result() for ClusterFuture ... done
[08:25:53.524] result() for ClusterFuture ...
[08:25:53.524] - result already collected: FutureResult
[08:25:53.524] result() for ClusterFuture ... done
[08:25:53.524] result() for ClusterFuture ...
[08:25:53.524] - result already collected: FutureResult
[08:25:53.524] result() for ClusterFuture ... done
[08:25:53.524] result() for ClusterFuture ...
[08:25:53.525] - result already collected: FutureResult
[08:25:53.525] result() for ClusterFuture ... done
[08:25:53.525]  - Number of value chunks collected: 2
[08:25:53.525] Resolving 2 futures (chunks) ... DONE
[08:25:53.525] Reducing values from 2 chunks ...
[08:25:53.525]  - Number of values collected after concatenation: 2
[08:25:53.525]  - Number of values expected: 2
[08:25:53.525] Reducing values from 2 chunks ... DONE
[08:25:53.525] future_mapply() ... DONE
[08:25:53.525] future_mapply() ...
[08:25:53.527] Number of chunks: 2
[08:25:53.527] getGlobalsAndPackagesXApply() ...
[08:25:53.527]  - future.globals: TRUE
[08:25:53.528] getGlobalsAndPackages() ...
[08:25:53.528] Searching for globals...
[08:25:53.529] - globals found: [1] ‘FUN’
[08:25:53.529] Searching for globals ... DONE
[08:25:53.529] Resolving globals: FALSE
[08:25:53.529] The total size of the 1 globals is 326 bytes (326 bytes)
[08:25:53.529] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 326 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (326 bytes of class ‘function’)
[08:25:53.530] - globals: [1] ‘FUN’
[08:25:53.530] 
[08:25:53.530] getGlobalsAndPackages() ... DONE
[08:25:53.530]  - globals found/used: [n=1] ‘FUN’
[08:25:53.530]  - needed namespaces: [n=0] 
[08:25:53.530] Finding globals ... DONE
[08:25:53.530] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:53.530] List of 2
[08:25:53.530]  $ ...future.FUN:function (x, y)  
[08:25:53.530]  $ MoreArgs     :List of 1
[08:25:53.530]   ..$ y: int [1:2] 3 4
[08:25:53.530]  - attr(*, "where")=List of 2
[08:25:53.530]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:53.530]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:53.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:53.530]  - attr(*, "resolved")= logi FALSE
[08:25:53.530]  - attr(*, "total_size")= num NA
[08:25:53.533] Packages to be attached in all futures: [n=0] 
[08:25:53.533] getGlobalsAndPackagesXApply() ... DONE
[08:25:53.533] Number of futures (= number of chunks): 2
[08:25:53.534] Launching 2 futures (chunks) ...
[08:25:53.534] Chunk #1 of 2 ...
[08:25:53.534]  - Finding globals in '...' for chunk #1 ...
[08:25:53.534] getGlobalsAndPackages() ...
[08:25:53.534] Searching for globals...
[08:25:53.534] 
[08:25:53.534] Searching for globals ... DONE
[08:25:53.534] - globals: [0] <none>
[08:25:53.535] getGlobalsAndPackages() ... DONE
[08:25:53.535]    + additional globals found: [n=0] 
[08:25:53.535]    + additional namespaces needed: [n=0] 
[08:25:53.535]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:53.535]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.535]  - seeds: <none>
[08:25:53.535]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.535] getGlobalsAndPackages() ...
[08:25:53.535] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.535] Resolving globals: FALSE
[08:25:53.536] The total size of the 5 globals is 656 bytes (656 bytes)
[08:25:53.536] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:53.536] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.536] 
[08:25:53.537] getGlobalsAndPackages() ... DONE
[08:25:53.537] run() for ‘Future’ ...
[08:25:53.537] - state: ‘created’
[08:25:53.537] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.553] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.553]   - Field: ‘node’
[08:25:53.553]   - Field: ‘label’
[08:25:53.554]   - Field: ‘local’
[08:25:53.554]   - Field: ‘owner’
[08:25:53.554]   - Field: ‘envir’
[08:25:53.554]   - Field: ‘workers’
[08:25:53.554]   - Field: ‘packages’
[08:25:53.554]   - Field: ‘gc’
[08:25:53.554]   - Field: ‘conditions’
[08:25:53.554]   - Field: ‘persistent’
[08:25:53.554]   - Field: ‘expr’
[08:25:53.554]   - Field: ‘uuid’
[08:25:53.554]   - Field: ‘seed’
[08:25:53.555]   - Field: ‘version’
[08:25:53.555]   - Field: ‘result’
[08:25:53.555]   - Field: ‘asynchronous’
[08:25:53.555]   - Field: ‘calls’
[08:25:53.555]   - Field: ‘globals’
[08:25:53.555]   - Field: ‘stdout’
[08:25:53.555]   - Field: ‘earlySignal’
[08:25:53.555]   - Field: ‘lazy’
[08:25:53.555]   - Field: ‘state’
[08:25:53.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.555] - Launch lazy future ...
[08:25:53.556] Packages needed by the future expression (n = 0): <none>
[08:25:53.556] Packages needed by future strategies (n = 0): <none>
[08:25:53.556] {
[08:25:53.556]     {
[08:25:53.556]         {
[08:25:53.556]             ...future.startTime <- base::Sys.time()
[08:25:53.556]             {
[08:25:53.556]                 {
[08:25:53.556]                   {
[08:25:53.556]                     {
[08:25:53.556]                       base::local({
[08:25:53.556]                         has_future <- base::requireNamespace("future", 
[08:25:53.556]                           quietly = TRUE)
[08:25:53.556]                         if (has_future) {
[08:25:53.556]                           ns <- base::getNamespace("future")
[08:25:53.556]                           version <- ns[[".package"]][["version"]]
[08:25:53.556]                           if (is.null(version)) 
[08:25:53.556]                             version <- utils::packageVersion("future")
[08:25:53.556]                         }
[08:25:53.556]                         else {
[08:25:53.556]                           version <- NULL
[08:25:53.556]                         }
[08:25:53.556]                         if (!has_future || version < "1.8.0") {
[08:25:53.556]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.556]                             "", base::R.version$version.string), 
[08:25:53.556]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.556]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.556]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.556]                               "release", "version")], collapse = " "), 
[08:25:53.556]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.556]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.556]                             info)
[08:25:53.556]                           info <- base::paste(info, collapse = "; ")
[08:25:53.556]                           if (!has_future) {
[08:25:53.556]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.556]                               info)
[08:25:53.556]                           }
[08:25:53.556]                           else {
[08:25:53.556]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.556]                               info, version)
[08:25:53.556]                           }
[08:25:53.556]                           base::stop(msg)
[08:25:53.556]                         }
[08:25:53.556]                       })
[08:25:53.556]                     }
[08:25:53.556]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.556]                     base::options(mc.cores = 1L)
[08:25:53.556]                   }
[08:25:53.556]                   ...future.strategy.old <- future::plan("list")
[08:25:53.556]                   options(future.plan = NULL)
[08:25:53.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.556]                 }
[08:25:53.556]                 ...future.workdir <- getwd()
[08:25:53.556]             }
[08:25:53.556]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.556]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.556]         }
[08:25:53.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.556]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.556]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.556]             base::names(...future.oldOptions))
[08:25:53.556]     }
[08:25:53.556]     if (FALSE) {
[08:25:53.556]     }
[08:25:53.556]     else {
[08:25:53.556]         if (TRUE) {
[08:25:53.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.556]                 open = "w")
[08:25:53.556]         }
[08:25:53.556]         else {
[08:25:53.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.556]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.556]         }
[08:25:53.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.556]             base::sink(type = "output", split = FALSE)
[08:25:53.556]             base::close(...future.stdout)
[08:25:53.556]         }, add = TRUE)
[08:25:53.556]     }
[08:25:53.556]     ...future.frame <- base::sys.nframe()
[08:25:53.556]     ...future.conditions <- base::list()
[08:25:53.556]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.556]     if (FALSE) {
[08:25:53.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.556]     }
[08:25:53.556]     ...future.result <- base::tryCatch({
[08:25:53.556]         base::withCallingHandlers({
[08:25:53.556]             ...future.value <- base::withVisible(base::local({
[08:25:53.556]                 ...future.makeSendCondition <- base::local({
[08:25:53.556]                   sendCondition <- NULL
[08:25:53.556]                   function(frame = 1L) {
[08:25:53.556]                     if (is.function(sendCondition)) 
[08:25:53.556]                       return(sendCondition)
[08:25:53.556]                     ns <- getNamespace("parallel")
[08:25:53.556]                     if (exists("sendData", mode = "function", 
[08:25:53.556]                       envir = ns)) {
[08:25:53.556]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.556]                         envir = ns)
[08:25:53.556]                       envir <- sys.frame(frame)
[08:25:53.556]                       master <- NULL
[08:25:53.556]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.556]                         !identical(envir, emptyenv())) {
[08:25:53.556]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.556]                           inherits = FALSE)) {
[08:25:53.556]                           master <- get("master", mode = "list", 
[08:25:53.556]                             envir = envir, inherits = FALSE)
[08:25:53.556]                           if (inherits(master, c("SOCKnode", 
[08:25:53.556]                             "SOCK0node"))) {
[08:25:53.556]                             sendCondition <<- function(cond) {
[08:25:53.556]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.556]                                 success = TRUE)
[08:25:53.556]                               parallel_sendData(master, data)
[08:25:53.556]                             }
[08:25:53.556]                             return(sendCondition)
[08:25:53.556]                           }
[08:25:53.556]                         }
[08:25:53.556]                         frame <- frame + 1L
[08:25:53.556]                         envir <- sys.frame(frame)
[08:25:53.556]                       }
[08:25:53.556]                     }
[08:25:53.556]                     sendCondition <<- function(cond) NULL
[08:25:53.556]                   }
[08:25:53.556]                 })
[08:25:53.556]                 withCallingHandlers({
[08:25:53.556]                   {
[08:25:53.556]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.556]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.556]                       ...future.globals.maxSize)) {
[08:25:53.556]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.556]                       on.exit(options(oopts), add = TRUE)
[08:25:53.556]                     }
[08:25:53.556]                     {
[08:25:53.556]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.556]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.556]                         USE.NAMES = FALSE)
[08:25:53.556]                       do.call(mapply, args = args)
[08:25:53.556]                     }
[08:25:53.556]                   }
[08:25:53.556]                 }, immediateCondition = function(cond) {
[08:25:53.556]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.556]                   sendCondition(cond)
[08:25:53.556]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.556]                   {
[08:25:53.556]                     inherits <- base::inherits
[08:25:53.556]                     invokeRestart <- base::invokeRestart
[08:25:53.556]                     is.null <- base::is.null
[08:25:53.556]                     muffled <- FALSE
[08:25:53.556]                     if (inherits(cond, "message")) {
[08:25:53.556]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.556]                       if (muffled) 
[08:25:53.556]                         invokeRestart("muffleMessage")
[08:25:53.556]                     }
[08:25:53.556]                     else if (inherits(cond, "warning")) {
[08:25:53.556]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.556]                       if (muffled) 
[08:25:53.556]                         invokeRestart("muffleWarning")
[08:25:53.556]                     }
[08:25:53.556]                     else if (inherits(cond, "condition")) {
[08:25:53.556]                       if (!is.null(pattern)) {
[08:25:53.556]                         computeRestarts <- base::computeRestarts
[08:25:53.556]                         grepl <- base::grepl
[08:25:53.556]                         restarts <- computeRestarts(cond)
[08:25:53.556]                         for (restart in restarts) {
[08:25:53.556]                           name <- restart$name
[08:25:53.556]                           if (is.null(name)) 
[08:25:53.556]                             next
[08:25:53.556]                           if (!grepl(pattern, name)) 
[08:25:53.556]                             next
[08:25:53.556]                           invokeRestart(restart)
[08:25:53.556]                           muffled <- TRUE
[08:25:53.556]                           break
[08:25:53.556]                         }
[08:25:53.556]                       }
[08:25:53.556]                     }
[08:25:53.556]                     invisible(muffled)
[08:25:53.556]                   }
[08:25:53.556]                   muffleCondition(cond)
[08:25:53.556]                 })
[08:25:53.556]             }))
[08:25:53.556]             future::FutureResult(value = ...future.value$value, 
[08:25:53.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.556]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.556]                     ...future.globalenv.names))
[08:25:53.556]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.556]         }, condition = base::local({
[08:25:53.556]             c <- base::c
[08:25:53.556]             inherits <- base::inherits
[08:25:53.556]             invokeRestart <- base::invokeRestart
[08:25:53.556]             length <- base::length
[08:25:53.556]             list <- base::list
[08:25:53.556]             seq.int <- base::seq.int
[08:25:53.556]             signalCondition <- base::signalCondition
[08:25:53.556]             sys.calls <- base::sys.calls
[08:25:53.556]             `[[` <- base::`[[`
[08:25:53.556]             `+` <- base::`+`
[08:25:53.556]             `<<-` <- base::`<<-`
[08:25:53.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.556]                   3L)]
[08:25:53.556]             }
[08:25:53.556]             function(cond) {
[08:25:53.556]                 is_error <- inherits(cond, "error")
[08:25:53.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.556]                   NULL)
[08:25:53.556]                 if (is_error) {
[08:25:53.556]                   sessionInformation <- function() {
[08:25:53.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.556]                       search = base::search(), system = base::Sys.info())
[08:25:53.556]                   }
[08:25:53.556]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.556]                     cond$call), session = sessionInformation(), 
[08:25:53.556]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.556]                   signalCondition(cond)
[08:25:53.556]                 }
[08:25:53.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.556]                 "immediateCondition"))) {
[08:25:53.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.556]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.556]                   if (TRUE && !signal) {
[08:25:53.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.556]                     {
[08:25:53.556]                       inherits <- base::inherits
[08:25:53.556]                       invokeRestart <- base::invokeRestart
[08:25:53.556]                       is.null <- base::is.null
[08:25:53.556]                       muffled <- FALSE
[08:25:53.556]                       if (inherits(cond, "message")) {
[08:25:53.556]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.556]                         if (muffled) 
[08:25:53.556]                           invokeRestart("muffleMessage")
[08:25:53.556]                       }
[08:25:53.556]                       else if (inherits(cond, "warning")) {
[08:25:53.556]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.556]                         if (muffled) 
[08:25:53.556]                           invokeRestart("muffleWarning")
[08:25:53.556]                       }
[08:25:53.556]                       else if (inherits(cond, "condition")) {
[08:25:53.556]                         if (!is.null(pattern)) {
[08:25:53.556]                           computeRestarts <- base::computeRestarts
[08:25:53.556]                           grepl <- base::grepl
[08:25:53.556]                           restarts <- computeRestarts(cond)
[08:25:53.556]                           for (restart in restarts) {
[08:25:53.556]                             name <- restart$name
[08:25:53.556]                             if (is.null(name)) 
[08:25:53.556]                               next
[08:25:53.556]                             if (!grepl(pattern, name)) 
[08:25:53.556]                               next
[08:25:53.556]                             invokeRestart(restart)
[08:25:53.556]                             muffled <- TRUE
[08:25:53.556]                             break
[08:25:53.556]                           }
[08:25:53.556]                         }
[08:25:53.556]                       }
[08:25:53.556]                       invisible(muffled)
[08:25:53.556]                     }
[08:25:53.556]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.556]                   }
[08:25:53.556]                 }
[08:25:53.556]                 else {
[08:25:53.556]                   if (TRUE) {
[08:25:53.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.556]                     {
[08:25:53.556]                       inherits <- base::inherits
[08:25:53.556]                       invokeRestart <- base::invokeRestart
[08:25:53.556]                       is.null <- base::is.null
[08:25:53.556]                       muffled <- FALSE
[08:25:53.556]                       if (inherits(cond, "message")) {
[08:25:53.556]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.556]                         if (muffled) 
[08:25:53.556]                           invokeRestart("muffleMessage")
[08:25:53.556]                       }
[08:25:53.556]                       else if (inherits(cond, "warning")) {
[08:25:53.556]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.556]                         if (muffled) 
[08:25:53.556]                           invokeRestart("muffleWarning")
[08:25:53.556]                       }
[08:25:53.556]                       else if (inherits(cond, "condition")) {
[08:25:53.556]                         if (!is.null(pattern)) {
[08:25:53.556]                           computeRestarts <- base::computeRestarts
[08:25:53.556]                           grepl <- base::grepl
[08:25:53.556]                           restarts <- computeRestarts(cond)
[08:25:53.556]                           for (restart in restarts) {
[08:25:53.556]                             name <- restart$name
[08:25:53.556]                             if (is.null(name)) 
[08:25:53.556]                               next
[08:25:53.556]                             if (!grepl(pattern, name)) 
[08:25:53.556]                               next
[08:25:53.556]                             invokeRestart(restart)
[08:25:53.556]                             muffled <- TRUE
[08:25:53.556]                             break
[08:25:53.556]                           }
[08:25:53.556]                         }
[08:25:53.556]                       }
[08:25:53.556]                       invisible(muffled)
[08:25:53.556]                     }
[08:25:53.556]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.556]                   }
[08:25:53.556]                 }
[08:25:53.556]             }
[08:25:53.556]         }))
[08:25:53.556]     }, error = function(ex) {
[08:25:53.556]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.556]                 ...future.rng), started = ...future.startTime, 
[08:25:53.556]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.556]             version = "1.8"), class = "FutureResult")
[08:25:53.556]     }, finally = {
[08:25:53.556]         if (!identical(...future.workdir, getwd())) 
[08:25:53.556]             setwd(...future.workdir)
[08:25:53.556]         {
[08:25:53.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.556]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.556]             }
[08:25:53.556]             base::options(...future.oldOptions)
[08:25:53.556]             if (.Platform$OS.type == "windows") {
[08:25:53.556]                 old_names <- names(...future.oldEnvVars)
[08:25:53.556]                 envs <- base::Sys.getenv()
[08:25:53.556]                 names <- names(envs)
[08:25:53.556]                 common <- intersect(names, old_names)
[08:25:53.556]                 added <- setdiff(names, old_names)
[08:25:53.556]                 removed <- setdiff(old_names, names)
[08:25:53.556]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.556]                   envs[common]]
[08:25:53.556]                 NAMES <- toupper(changed)
[08:25:53.556]                 args <- list()
[08:25:53.556]                 for (kk in seq_along(NAMES)) {
[08:25:53.556]                   name <- changed[[kk]]
[08:25:53.556]                   NAME <- NAMES[[kk]]
[08:25:53.556]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.556]                     next
[08:25:53.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.556]                 }
[08:25:53.556]                 NAMES <- toupper(added)
[08:25:53.556]                 for (kk in seq_along(NAMES)) {
[08:25:53.556]                   name <- added[[kk]]
[08:25:53.556]                   NAME <- NAMES[[kk]]
[08:25:53.556]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.556]                     next
[08:25:53.556]                   args[[name]] <- ""
[08:25:53.556]                 }
[08:25:53.556]                 NAMES <- toupper(removed)
[08:25:53.556]                 for (kk in seq_along(NAMES)) {
[08:25:53.556]                   name <- removed[[kk]]
[08:25:53.556]                   NAME <- NAMES[[kk]]
[08:25:53.556]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.556]                     next
[08:25:53.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.556]                 }
[08:25:53.556]                 if (length(args) > 0) 
[08:25:53.556]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.556]             }
[08:25:53.556]             else {
[08:25:53.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.556]             }
[08:25:53.556]             {
[08:25:53.556]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.556]                   0L) {
[08:25:53.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.556]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.556]                   base::options(opts)
[08:25:53.556]                 }
[08:25:53.556]                 {
[08:25:53.556]                   {
[08:25:53.556]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.556]                     NULL
[08:25:53.556]                   }
[08:25:53.556]                   options(future.plan = NULL)
[08:25:53.556]                   if (is.na(NA_character_)) 
[08:25:53.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.556]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.556]                     .init = FALSE)
[08:25:53.556]                 }
[08:25:53.556]             }
[08:25:53.556]         }
[08:25:53.556]     })
[08:25:53.556]     if (TRUE) {
[08:25:53.556]         base::sink(type = "output", split = FALSE)
[08:25:53.556]         if (TRUE) {
[08:25:53.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.556]         }
[08:25:53.556]         else {
[08:25:53.556]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.556]         }
[08:25:53.556]         base::close(...future.stdout)
[08:25:53.556]         ...future.stdout <- NULL
[08:25:53.556]     }
[08:25:53.556]     ...future.result$conditions <- ...future.conditions
[08:25:53.556]     ...future.result$finished <- base::Sys.time()
[08:25:53.556]     ...future.result
[08:25:53.556] }
[08:25:53.559] Exporting 5 global objects (1.05 KiB) to cluster node #1 ...
[08:25:53.560] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ...
[08:25:53.560] Exporting ‘...future.FUN’ (326 bytes) to cluster node #1 ... DONE
[08:25:53.560] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ...
[08:25:53.561] Exporting ‘MoreArgs’ (183 bytes) to cluster node #1 ... DONE
[08:25:53.561] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ...
[08:25:53.561] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #1 ... DONE
[08:25:53.561] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:53.561] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.562] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:53.562] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.562] Exporting 5 global objects (1.05 KiB) to cluster node #1 ... DONE
[08:25:53.562] MultisessionFuture started
[08:25:53.563] - Launch lazy future ... done
[08:25:53.563] run() for ‘MultisessionFuture’ ... done
[08:25:53.563] Created future:
[08:25:53.563] MultisessionFuture:
[08:25:53.563] Label: ‘future_.mapply-1’
[08:25:53.563] Expression:
[08:25:53.563] {
[08:25:53.563]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.563]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.563]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.563]         on.exit(options(oopts), add = TRUE)
[08:25:53.563]     }
[08:25:53.563]     {
[08:25:53.563]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.563]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.563]         do.call(mapply, args = args)
[08:25:53.563]     }
[08:25:53.563] }
[08:25:53.563] Lazy evaluation: FALSE
[08:25:53.563] Asynchronous evaluation: TRUE
[08:25:53.563] Local evaluation: TRUE
[08:25:53.563] Environment: R_GlobalEnv
[08:25:53.563] Capture standard output: TRUE
[08:25:53.563] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.563] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.563] Packages: <none>
[08:25:53.563] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.563] Resolved: FALSE
[08:25:53.563] Value: <not collected>
[08:25:53.563] Conditions captured: <none>
[08:25:53.563] Early signaling: FALSE
[08:25:53.563] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.563] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.574] Chunk #1 of 2 ... DONE
[08:25:53.574] Chunk #2 of 2 ...
[08:25:53.575]  - Finding globals in '...' for chunk #2 ...
[08:25:53.575] getGlobalsAndPackages() ...
[08:25:53.575] Searching for globals...
[08:25:53.575] 
[08:25:53.575] Searching for globals ... DONE
[08:25:53.575] - globals: [0] <none>
[08:25:53.575] getGlobalsAndPackages() ... DONE
[08:25:53.575]    + additional globals found: [n=0] 
[08:25:53.576]    + additional namespaces needed: [n=0] 
[08:25:53.576]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:53.576]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.576]  - seeds: <none>
[08:25:53.576]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.576] getGlobalsAndPackages() ...
[08:25:53.576] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.576] Resolving globals: FALSE
[08:25:53.577] The total size of the 5 globals is 656 bytes (656 bytes)
[08:25:53.577] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 656 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (326 bytes of class ‘function’), ‘MoreArgs’ (183 bytes of class ‘list’) and ‘...future.elements_ii’ (93 bytes of class ‘list’)
[08:25:53.577] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.577] 
[08:25:53.577] getGlobalsAndPackages() ... DONE
[08:25:53.578] run() for ‘Future’ ...
[08:25:53.578] - state: ‘created’
[08:25:53.578] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.593] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.593]   - Field: ‘node’
[08:25:53.593]   - Field: ‘label’
[08:25:53.593]   - Field: ‘local’
[08:25:53.593]   - Field: ‘owner’
[08:25:53.593]   - Field: ‘envir’
[08:25:53.593]   - Field: ‘workers’
[08:25:53.594]   - Field: ‘packages’
[08:25:53.594]   - Field: ‘gc’
[08:25:53.594]   - Field: ‘conditions’
[08:25:53.594]   - Field: ‘persistent’
[08:25:53.594]   - Field: ‘expr’
[08:25:53.594]   - Field: ‘uuid’
[08:25:53.594]   - Field: ‘seed’
[08:25:53.594]   - Field: ‘version’
[08:25:53.594]   - Field: ‘result’
[08:25:53.594]   - Field: ‘asynchronous’
[08:25:53.594]   - Field: ‘calls’
[08:25:53.595]   - Field: ‘globals’
[08:25:53.595]   - Field: ‘stdout’
[08:25:53.595]   - Field: ‘earlySignal’
[08:25:53.595]   - Field: ‘lazy’
[08:25:53.595]   - Field: ‘state’
[08:25:53.595] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.595] - Launch lazy future ...
[08:25:53.595] Packages needed by the future expression (n = 0): <none>
[08:25:53.595] Packages needed by future strategies (n = 0): <none>
[08:25:53.596] {
[08:25:53.596]     {
[08:25:53.596]         {
[08:25:53.596]             ...future.startTime <- base::Sys.time()
[08:25:53.596]             {
[08:25:53.596]                 {
[08:25:53.596]                   {
[08:25:53.596]                     {
[08:25:53.596]                       base::local({
[08:25:53.596]                         has_future <- base::requireNamespace("future", 
[08:25:53.596]                           quietly = TRUE)
[08:25:53.596]                         if (has_future) {
[08:25:53.596]                           ns <- base::getNamespace("future")
[08:25:53.596]                           version <- ns[[".package"]][["version"]]
[08:25:53.596]                           if (is.null(version)) 
[08:25:53.596]                             version <- utils::packageVersion("future")
[08:25:53.596]                         }
[08:25:53.596]                         else {
[08:25:53.596]                           version <- NULL
[08:25:53.596]                         }
[08:25:53.596]                         if (!has_future || version < "1.8.0") {
[08:25:53.596]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.596]                             "", base::R.version$version.string), 
[08:25:53.596]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.596]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.596]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.596]                               "release", "version")], collapse = " "), 
[08:25:53.596]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.596]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.596]                             info)
[08:25:53.596]                           info <- base::paste(info, collapse = "; ")
[08:25:53.596]                           if (!has_future) {
[08:25:53.596]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.596]                               info)
[08:25:53.596]                           }
[08:25:53.596]                           else {
[08:25:53.596]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.596]                               info, version)
[08:25:53.596]                           }
[08:25:53.596]                           base::stop(msg)
[08:25:53.596]                         }
[08:25:53.596]                       })
[08:25:53.596]                     }
[08:25:53.596]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.596]                     base::options(mc.cores = 1L)
[08:25:53.596]                   }
[08:25:53.596]                   ...future.strategy.old <- future::plan("list")
[08:25:53.596]                   options(future.plan = NULL)
[08:25:53.596]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.596]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.596]                 }
[08:25:53.596]                 ...future.workdir <- getwd()
[08:25:53.596]             }
[08:25:53.596]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.596]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.596]         }
[08:25:53.596]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.596]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.596]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.596]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.596]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.596]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.596]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.596]             base::names(...future.oldOptions))
[08:25:53.596]     }
[08:25:53.596]     if (FALSE) {
[08:25:53.596]     }
[08:25:53.596]     else {
[08:25:53.596]         if (TRUE) {
[08:25:53.596]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.596]                 open = "w")
[08:25:53.596]         }
[08:25:53.596]         else {
[08:25:53.596]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.596]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.596]         }
[08:25:53.596]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.596]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.596]             base::sink(type = "output", split = FALSE)
[08:25:53.596]             base::close(...future.stdout)
[08:25:53.596]         }, add = TRUE)
[08:25:53.596]     }
[08:25:53.596]     ...future.frame <- base::sys.nframe()
[08:25:53.596]     ...future.conditions <- base::list()
[08:25:53.596]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.596]     if (FALSE) {
[08:25:53.596]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.596]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.596]     }
[08:25:53.596]     ...future.result <- base::tryCatch({
[08:25:53.596]         base::withCallingHandlers({
[08:25:53.596]             ...future.value <- base::withVisible(base::local({
[08:25:53.596]                 ...future.makeSendCondition <- base::local({
[08:25:53.596]                   sendCondition <- NULL
[08:25:53.596]                   function(frame = 1L) {
[08:25:53.596]                     if (is.function(sendCondition)) 
[08:25:53.596]                       return(sendCondition)
[08:25:53.596]                     ns <- getNamespace("parallel")
[08:25:53.596]                     if (exists("sendData", mode = "function", 
[08:25:53.596]                       envir = ns)) {
[08:25:53.596]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.596]                         envir = ns)
[08:25:53.596]                       envir <- sys.frame(frame)
[08:25:53.596]                       master <- NULL
[08:25:53.596]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.596]                         !identical(envir, emptyenv())) {
[08:25:53.596]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.596]                           inherits = FALSE)) {
[08:25:53.596]                           master <- get("master", mode = "list", 
[08:25:53.596]                             envir = envir, inherits = FALSE)
[08:25:53.596]                           if (inherits(master, c("SOCKnode", 
[08:25:53.596]                             "SOCK0node"))) {
[08:25:53.596]                             sendCondition <<- function(cond) {
[08:25:53.596]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.596]                                 success = TRUE)
[08:25:53.596]                               parallel_sendData(master, data)
[08:25:53.596]                             }
[08:25:53.596]                             return(sendCondition)
[08:25:53.596]                           }
[08:25:53.596]                         }
[08:25:53.596]                         frame <- frame + 1L
[08:25:53.596]                         envir <- sys.frame(frame)
[08:25:53.596]                       }
[08:25:53.596]                     }
[08:25:53.596]                     sendCondition <<- function(cond) NULL
[08:25:53.596]                   }
[08:25:53.596]                 })
[08:25:53.596]                 withCallingHandlers({
[08:25:53.596]                   {
[08:25:53.596]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.596]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.596]                       ...future.globals.maxSize)) {
[08:25:53.596]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.596]                       on.exit(options(oopts), add = TRUE)
[08:25:53.596]                     }
[08:25:53.596]                     {
[08:25:53.596]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.596]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.596]                         USE.NAMES = FALSE)
[08:25:53.596]                       do.call(mapply, args = args)
[08:25:53.596]                     }
[08:25:53.596]                   }
[08:25:53.596]                 }, immediateCondition = function(cond) {
[08:25:53.596]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.596]                   sendCondition(cond)
[08:25:53.596]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.596]                   {
[08:25:53.596]                     inherits <- base::inherits
[08:25:53.596]                     invokeRestart <- base::invokeRestart
[08:25:53.596]                     is.null <- base::is.null
[08:25:53.596]                     muffled <- FALSE
[08:25:53.596]                     if (inherits(cond, "message")) {
[08:25:53.596]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.596]                       if (muffled) 
[08:25:53.596]                         invokeRestart("muffleMessage")
[08:25:53.596]                     }
[08:25:53.596]                     else if (inherits(cond, "warning")) {
[08:25:53.596]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.596]                       if (muffled) 
[08:25:53.596]                         invokeRestart("muffleWarning")
[08:25:53.596]                     }
[08:25:53.596]                     else if (inherits(cond, "condition")) {
[08:25:53.596]                       if (!is.null(pattern)) {
[08:25:53.596]                         computeRestarts <- base::computeRestarts
[08:25:53.596]                         grepl <- base::grepl
[08:25:53.596]                         restarts <- computeRestarts(cond)
[08:25:53.596]                         for (restart in restarts) {
[08:25:53.596]                           name <- restart$name
[08:25:53.596]                           if (is.null(name)) 
[08:25:53.596]                             next
[08:25:53.596]                           if (!grepl(pattern, name)) 
[08:25:53.596]                             next
[08:25:53.596]                           invokeRestart(restart)
[08:25:53.596]                           muffled <- TRUE
[08:25:53.596]                           break
[08:25:53.596]                         }
[08:25:53.596]                       }
[08:25:53.596]                     }
[08:25:53.596]                     invisible(muffled)
[08:25:53.596]                   }
[08:25:53.596]                   muffleCondition(cond)
[08:25:53.596]                 })
[08:25:53.596]             }))
[08:25:53.596]             future::FutureResult(value = ...future.value$value, 
[08:25:53.596]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.596]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.596]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.596]                     ...future.globalenv.names))
[08:25:53.596]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.596]         }, condition = base::local({
[08:25:53.596]             c <- base::c
[08:25:53.596]             inherits <- base::inherits
[08:25:53.596]             invokeRestart <- base::invokeRestart
[08:25:53.596]             length <- base::length
[08:25:53.596]             list <- base::list
[08:25:53.596]             seq.int <- base::seq.int
[08:25:53.596]             signalCondition <- base::signalCondition
[08:25:53.596]             sys.calls <- base::sys.calls
[08:25:53.596]             `[[` <- base::`[[`
[08:25:53.596]             `+` <- base::`+`
[08:25:53.596]             `<<-` <- base::`<<-`
[08:25:53.596]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.596]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.596]                   3L)]
[08:25:53.596]             }
[08:25:53.596]             function(cond) {
[08:25:53.596]                 is_error <- inherits(cond, "error")
[08:25:53.596]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.596]                   NULL)
[08:25:53.596]                 if (is_error) {
[08:25:53.596]                   sessionInformation <- function() {
[08:25:53.596]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.596]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.596]                       search = base::search(), system = base::Sys.info())
[08:25:53.596]                   }
[08:25:53.596]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.596]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.596]                     cond$call), session = sessionInformation(), 
[08:25:53.596]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.596]                   signalCondition(cond)
[08:25:53.596]                 }
[08:25:53.596]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.596]                 "immediateCondition"))) {
[08:25:53.596]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.596]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.596]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.596]                   if (TRUE && !signal) {
[08:25:53.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.596]                     {
[08:25:53.596]                       inherits <- base::inherits
[08:25:53.596]                       invokeRestart <- base::invokeRestart
[08:25:53.596]                       is.null <- base::is.null
[08:25:53.596]                       muffled <- FALSE
[08:25:53.596]                       if (inherits(cond, "message")) {
[08:25:53.596]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.596]                         if (muffled) 
[08:25:53.596]                           invokeRestart("muffleMessage")
[08:25:53.596]                       }
[08:25:53.596]                       else if (inherits(cond, "warning")) {
[08:25:53.596]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.596]                         if (muffled) 
[08:25:53.596]                           invokeRestart("muffleWarning")
[08:25:53.596]                       }
[08:25:53.596]                       else if (inherits(cond, "condition")) {
[08:25:53.596]                         if (!is.null(pattern)) {
[08:25:53.596]                           computeRestarts <- base::computeRestarts
[08:25:53.596]                           grepl <- base::grepl
[08:25:53.596]                           restarts <- computeRestarts(cond)
[08:25:53.596]                           for (restart in restarts) {
[08:25:53.596]                             name <- restart$name
[08:25:53.596]                             if (is.null(name)) 
[08:25:53.596]                               next
[08:25:53.596]                             if (!grepl(pattern, name)) 
[08:25:53.596]                               next
[08:25:53.596]                             invokeRestart(restart)
[08:25:53.596]                             muffled <- TRUE
[08:25:53.596]                             break
[08:25:53.596]                           }
[08:25:53.596]                         }
[08:25:53.596]                       }
[08:25:53.596]                       invisible(muffled)
[08:25:53.596]                     }
[08:25:53.596]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.596]                   }
[08:25:53.596]                 }
[08:25:53.596]                 else {
[08:25:53.596]                   if (TRUE) {
[08:25:53.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.596]                     {
[08:25:53.596]                       inherits <- base::inherits
[08:25:53.596]                       invokeRestart <- base::invokeRestart
[08:25:53.596]                       is.null <- base::is.null
[08:25:53.596]                       muffled <- FALSE
[08:25:53.596]                       if (inherits(cond, "message")) {
[08:25:53.596]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.596]                         if (muffled) 
[08:25:53.596]                           invokeRestart("muffleMessage")
[08:25:53.596]                       }
[08:25:53.596]                       else if (inherits(cond, "warning")) {
[08:25:53.596]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.596]                         if (muffled) 
[08:25:53.596]                           invokeRestart("muffleWarning")
[08:25:53.596]                       }
[08:25:53.596]                       else if (inherits(cond, "condition")) {
[08:25:53.596]                         if (!is.null(pattern)) {
[08:25:53.596]                           computeRestarts <- base::computeRestarts
[08:25:53.596]                           grepl <- base::grepl
[08:25:53.596]                           restarts <- computeRestarts(cond)
[08:25:53.596]                           for (restart in restarts) {
[08:25:53.596]                             name <- restart$name
[08:25:53.596]                             if (is.null(name)) 
[08:25:53.596]                               next
[08:25:53.596]                             if (!grepl(pattern, name)) 
[08:25:53.596]                               next
[08:25:53.596]                             invokeRestart(restart)
[08:25:53.596]                             muffled <- TRUE
[08:25:53.596]                             break
[08:25:53.596]                           }
[08:25:53.596]                         }
[08:25:53.596]                       }
[08:25:53.596]                       invisible(muffled)
[08:25:53.596]                     }
[08:25:53.596]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.596]                   }
[08:25:53.596]                 }
[08:25:53.596]             }
[08:25:53.596]         }))
[08:25:53.596]     }, error = function(ex) {
[08:25:53.596]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.596]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.596]                 ...future.rng), started = ...future.startTime, 
[08:25:53.596]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.596]             version = "1.8"), class = "FutureResult")
[08:25:53.596]     }, finally = {
[08:25:53.596]         if (!identical(...future.workdir, getwd())) 
[08:25:53.596]             setwd(...future.workdir)
[08:25:53.596]         {
[08:25:53.596]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.596]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.596]             }
[08:25:53.596]             base::options(...future.oldOptions)
[08:25:53.596]             if (.Platform$OS.type == "windows") {
[08:25:53.596]                 old_names <- names(...future.oldEnvVars)
[08:25:53.596]                 envs <- base::Sys.getenv()
[08:25:53.596]                 names <- names(envs)
[08:25:53.596]                 common <- intersect(names, old_names)
[08:25:53.596]                 added <- setdiff(names, old_names)
[08:25:53.596]                 removed <- setdiff(old_names, names)
[08:25:53.596]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.596]                   envs[common]]
[08:25:53.596]                 NAMES <- toupper(changed)
[08:25:53.596]                 args <- list()
[08:25:53.596]                 for (kk in seq_along(NAMES)) {
[08:25:53.596]                   name <- changed[[kk]]
[08:25:53.596]                   NAME <- NAMES[[kk]]
[08:25:53.596]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.596]                     next
[08:25:53.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.596]                 }
[08:25:53.596]                 NAMES <- toupper(added)
[08:25:53.596]                 for (kk in seq_along(NAMES)) {
[08:25:53.596]                   name <- added[[kk]]
[08:25:53.596]                   NAME <- NAMES[[kk]]
[08:25:53.596]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.596]                     next
[08:25:53.596]                   args[[name]] <- ""
[08:25:53.596]                 }
[08:25:53.596]                 NAMES <- toupper(removed)
[08:25:53.596]                 for (kk in seq_along(NAMES)) {
[08:25:53.596]                   name <- removed[[kk]]
[08:25:53.596]                   NAME <- NAMES[[kk]]
[08:25:53.596]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.596]                     next
[08:25:53.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.596]                 }
[08:25:53.596]                 if (length(args) > 0) 
[08:25:53.596]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.596]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.596]             }
[08:25:53.596]             else {
[08:25:53.596]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.596]             }
[08:25:53.596]             {
[08:25:53.596]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.596]                   0L) {
[08:25:53.596]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.596]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.596]                   base::options(opts)
[08:25:53.596]                 }
[08:25:53.596]                 {
[08:25:53.596]                   {
[08:25:53.596]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.596]                     NULL
[08:25:53.596]                   }
[08:25:53.596]                   options(future.plan = NULL)
[08:25:53.596]                   if (is.na(NA_character_)) 
[08:25:53.596]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.596]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.596]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.596]                     .init = FALSE)
[08:25:53.596]                 }
[08:25:53.596]             }
[08:25:53.596]         }
[08:25:53.596]     })
[08:25:53.596]     if (TRUE) {
[08:25:53.596]         base::sink(type = "output", split = FALSE)
[08:25:53.596]         if (TRUE) {
[08:25:53.596]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.596]         }
[08:25:53.596]         else {
[08:25:53.596]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.596]         }
[08:25:53.596]         base::close(...future.stdout)
[08:25:53.596]         ...future.stdout <- NULL
[08:25:53.596]     }
[08:25:53.596]     ...future.result$conditions <- ...future.conditions
[08:25:53.596]     ...future.result$finished <- base::Sys.time()
[08:25:53.596]     ...future.result
[08:25:53.596] }
[08:25:53.599] Exporting 5 global objects (1.05 KiB) to cluster node #2 ...
[08:25:53.599] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ...
[08:25:53.600] Exporting ‘...future.FUN’ (326 bytes) to cluster node #2 ... DONE
[08:25:53.600] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ...
[08:25:53.600] Exporting ‘MoreArgs’ (183 bytes) to cluster node #2 ... DONE
[08:25:53.600] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ...
[08:25:53.600] Exporting ‘...future.elements_ii’ (93 bytes) to cluster node #2 ... DONE
[08:25:53.601] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:53.601] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.601] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:53.601] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.601] Exporting 5 global objects (1.05 KiB) to cluster node #2 ... DONE
[08:25:53.602] MultisessionFuture started
[08:25:53.602] - Launch lazy future ... done
[08:25:53.602] run() for ‘MultisessionFuture’ ... done
[08:25:53.602] Created future:
[08:25:53.602] MultisessionFuture:
[08:25:53.602] Label: ‘future_.mapply-2’
[08:25:53.602] Expression:
[08:25:53.602] {
[08:25:53.602]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.602]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.602]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.602]         on.exit(options(oopts), add = TRUE)
[08:25:53.602]     }
[08:25:53.602]     {
[08:25:53.602]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.602]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.602]         do.call(mapply, args = args)
[08:25:53.602]     }
[08:25:53.602] }
[08:25:53.602] Lazy evaluation: FALSE
[08:25:53.602] Asynchronous evaluation: TRUE
[08:25:53.602] Local evaluation: TRUE
[08:25:53.602] Environment: R_GlobalEnv
[08:25:53.602] Capture standard output: TRUE
[08:25:53.602] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.602] Globals: 5 objects totaling 656 bytes (function ‘...future.FUN’ of 326 bytes, list ‘MoreArgs’ of 183 bytes, list ‘...future.elements_ii’ of 93 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.602] Packages: <none>
[08:25:53.602] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.602] Resolved: FALSE
[08:25:53.602] Value: <not collected>
[08:25:53.602] Conditions captured: <none>
[08:25:53.602] Early signaling: FALSE
[08:25:53.602] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.602] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.614] Chunk #2 of 2 ... DONE
[08:25:53.614] Launching 2 futures (chunks) ... DONE
[08:25:53.614] Resolving 2 futures (chunks) ...
[08:25:53.614] resolve() on list ...
[08:25:53.614]  recursive: 0
[08:25:53.614]  length: 2
[08:25:53.614] 
[08:25:53.615] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.615] - Validating connection of MultisessionFuture
[08:25:53.615] - received message: FutureResult
[08:25:53.615] - Received FutureResult
[08:25:53.615] - Erased future from FutureRegistry
[08:25:53.615] result() for ClusterFuture ...
[08:25:53.616] - result already collected: FutureResult
[08:25:53.616] result() for ClusterFuture ... done
[08:25:53.616] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.616] Future #1
[08:25:53.616] result() for ClusterFuture ...
[08:25:53.616] - result already collected: FutureResult
[08:25:53.616] result() for ClusterFuture ... done
[08:25:53.616] result() for ClusterFuture ...
[08:25:53.616] - result already collected: FutureResult
[08:25:53.616] result() for ClusterFuture ... done
[08:25:53.616] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:53.617] - nx: 2
[08:25:53.617] - relay: TRUE
[08:25:53.617] - stdout: TRUE
[08:25:53.617] - signal: TRUE
[08:25:53.617] - resignal: FALSE
[08:25:53.617] - force: TRUE
[08:25:53.617] - relayed: [n=2] FALSE, FALSE
[08:25:53.617] - queued futures: [n=2] FALSE, FALSE
[08:25:53.617]  - until=1
[08:25:53.617]  - relaying element #1
[08:25:53.617] result() for ClusterFuture ...
[08:25:53.617] - result already collected: FutureResult
[08:25:53.618] result() for ClusterFuture ... done
[08:25:53.618] result() for ClusterFuture ...
[08:25:53.618] - result already collected: FutureResult
[08:25:53.618] result() for ClusterFuture ... done
[08:25:53.618] result() for ClusterFuture ...
[08:25:53.618] - result already collected: FutureResult
[08:25:53.618] result() for ClusterFuture ... done
[08:25:53.618] result() for ClusterFuture ...
[08:25:53.618] - result already collected: FutureResult
[08:25:53.618] result() for ClusterFuture ... done
[08:25:53.618] - relayed: [n=2] TRUE, FALSE
[08:25:53.618] - queued futures: [n=2] TRUE, FALSE
[08:25:53.619] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:53.619]  length: 1 (resolved future 1)
[08:25:53.644] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.644] - Validating connection of MultisessionFuture
[08:25:53.645] - received message: FutureResult
[08:25:53.645] - Received FutureResult
[08:25:53.645] - Erased future from FutureRegistry
[08:25:53.645] result() for ClusterFuture ...
[08:25:53.645] - result already collected: FutureResult
[08:25:53.645] result() for ClusterFuture ... done
[08:25:53.645] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.645] Future #2
[08:25:53.645] result() for ClusterFuture ...
[08:25:53.645] - result already collected: FutureResult
[08:25:53.645] result() for ClusterFuture ... done
[08:25:53.646] result() for ClusterFuture ...
[08:25:53.646] - result already collected: FutureResult
[08:25:53.646] result() for ClusterFuture ... done
[08:25:53.646] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:53.646] - nx: 2
[08:25:53.646] - relay: TRUE
[08:25:53.646] - stdout: TRUE
[08:25:53.646] - signal: TRUE
[08:25:53.646] - resignal: FALSE
[08:25:53.646] - force: TRUE
[08:25:53.646] - relayed: [n=2] TRUE, FALSE
[08:25:53.646] - queued futures: [n=2] TRUE, FALSE
[08:25:53.647]  - until=2
[08:25:53.647]  - relaying element #2
[08:25:53.647] result() for ClusterFuture ...
[08:25:53.647] - result already collected: FutureResult
[08:25:53.647] result() for ClusterFuture ... done
[08:25:53.647] result() for ClusterFuture ...
[08:25:53.647] - result already collected: FutureResult
[08:25:53.647] result() for ClusterFuture ... done
[08:25:53.647] result() for ClusterFuture ...
[08:25:53.647] - result already collected: FutureResult
[08:25:53.647] result() for ClusterFuture ... done
[08:25:53.648] result() for ClusterFuture ...
[08:25:53.648] - result already collected: FutureResult
[08:25:53.648] result() for ClusterFuture ... done
[08:25:53.648] - relayed: [n=2] TRUE, TRUE
[08:25:53.648] - queued futures: [n=2] TRUE, TRUE
[08:25:53.648] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:53.648]  length: 0 (resolved future 2)
[08:25:53.648] Relaying remaining futures
[08:25:53.648] signalConditionsASAP(NULL, pos=0) ...
[08:25:53.648] - nx: 2
[08:25:53.648] - relay: TRUE
[08:25:53.648] - stdout: TRUE
[08:25:53.649] - signal: TRUE
[08:25:53.649] - resignal: FALSE
[08:25:53.649] - force: TRUE
[08:25:53.649] - relayed: [n=2] TRUE, TRUE
[08:25:53.649] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:53.649] - relayed: [n=2] TRUE, TRUE
[08:25:53.649] - queued futures: [n=2] TRUE, TRUE
[08:25:53.649] signalConditionsASAP(NULL, pos=0) ... done
[08:25:53.649] resolve() on list ... DONE
[08:25:53.649] result() for ClusterFuture ...
[08:25:53.649] - result already collected: FutureResult
[08:25:53.650] result() for ClusterFuture ... done
[08:25:53.650] result() for ClusterFuture ...
[08:25:53.650] - result already collected: FutureResult
[08:25:53.650] result() for ClusterFuture ... done
[08:25:53.650] result() for ClusterFuture ...
[08:25:53.650] - result already collected: FutureResult
[08:25:53.650] result() for ClusterFuture ... done
[08:25:53.650] result() for ClusterFuture ...
[08:25:53.650] - result already collected: FutureResult
[08:25:53.650] result() for ClusterFuture ... done
[08:25:53.650]  - Number of value chunks collected: 2
[08:25:53.651] Resolving 2 futures (chunks) ... DONE
[08:25:53.651] Reducing values from 2 chunks ...
[08:25:53.651]  - Number of values collected after concatenation: 2
[08:25:53.651]  - Number of values expected: 2
[08:25:53.651] Reducing values from 2 chunks ... DONE
[08:25:53.651] future_mapply() ... DONE
- Recycle arguments to same length ...
[08:25:53.651] future_mapply() ...
[08:25:53.653] Number of chunks: 2
[08:25:53.653] getGlobalsAndPackagesXApply() ...
[08:25:53.653]  - future.globals: TRUE
[08:25:53.653] getGlobalsAndPackages() ...
[08:25:53.653] Searching for globals...
[08:25:53.654] - globals found: [1] ‘FUN’
[08:25:53.654] Searching for globals ... DONE
[08:25:53.654] Resolving globals: FALSE
[08:25:53.654] The total size of the 1 globals is 34 bytes (34 bytes)
[08:25:53.655] The total size of the 1 globals exported for future expression (‘FUN()’) is 34 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (34 bytes of class ‘function’)
[08:25:53.655] - globals: [1] ‘FUN’
[08:25:53.655] 
[08:25:53.655] getGlobalsAndPackages() ... DONE
[08:25:53.655]  - globals found/used: [n=1] ‘FUN’
[08:25:53.655]  - needed namespaces: [n=0] 
[08:25:53.655] Finding globals ... DONE
[08:25:53.656] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:53.656] List of 2
[08:25:53.656]  $ ...future.FUN:function (x, ...)  
[08:25:53.656]  $ MoreArgs     : NULL
[08:25:53.656]  - attr(*, "where")=List of 2
[08:25:53.656]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:53.656]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:53.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:53.656]  - attr(*, "resolved")= logi FALSE
[08:25:53.656]  - attr(*, "total_size")= num NA
[08:25:53.658] Packages to be attached in all futures: [n=0] 
[08:25:53.658] getGlobalsAndPackagesXApply() ... DONE
[08:25:53.658] Number of futures (= number of chunks): 2
[08:25:53.658] Launching 2 futures (chunks) ...
[08:25:53.659] Chunk #1 of 2 ...
[08:25:53.659]  - Finding globals in '...' for chunk #1 ...
[08:25:53.659] getGlobalsAndPackages() ...
[08:25:53.659] Searching for globals...
[08:25:53.659] 
[08:25:53.659] Searching for globals ... DONE
[08:25:53.659] - globals: [0] <none>
[08:25:53.659] getGlobalsAndPackages() ... DONE
[08:25:53.660]    + additional globals found: [n=0] 
[08:25:53.660]    + additional namespaces needed: [n=0] 
[08:25:53.660]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:53.660]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.660]  - seeds: <none>
[08:25:53.660]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.660] getGlobalsAndPackages() ...
[08:25:53.660] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.660] Resolving globals: FALSE
[08:25:53.661] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:53.661] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:53.661] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.661] 
[08:25:53.661] getGlobalsAndPackages() ... DONE
[08:25:53.662] run() for ‘Future’ ...
[08:25:53.662] - state: ‘created’
[08:25:53.662] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.678] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.679]   - Field: ‘node’
[08:25:53.679]   - Field: ‘label’
[08:25:53.679]   - Field: ‘local’
[08:25:53.679]   - Field: ‘owner’
[08:25:53.679]   - Field: ‘envir’
[08:25:53.679]   - Field: ‘workers’
[08:25:53.679]   - Field: ‘packages’
[08:25:53.679]   - Field: ‘gc’
[08:25:53.679]   - Field: ‘conditions’
[08:25:53.679]   - Field: ‘persistent’
[08:25:53.680]   - Field: ‘expr’
[08:25:53.680]   - Field: ‘uuid’
[08:25:53.680]   - Field: ‘seed’
[08:25:53.680]   - Field: ‘version’
[08:25:53.680]   - Field: ‘result’
[08:25:53.680]   - Field: ‘asynchronous’
[08:25:53.680]   - Field: ‘calls’
[08:25:53.680]   - Field: ‘globals’
[08:25:53.680]   - Field: ‘stdout’
[08:25:53.680]   - Field: ‘earlySignal’
[08:25:53.680]   - Field: ‘lazy’
[08:25:53.680]   - Field: ‘state’
[08:25:53.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.681] - Launch lazy future ...
[08:25:53.681] Packages needed by the future expression (n = 0): <none>
[08:25:53.681] Packages needed by future strategies (n = 0): <none>
[08:25:53.682] {
[08:25:53.682]     {
[08:25:53.682]         {
[08:25:53.682]             ...future.startTime <- base::Sys.time()
[08:25:53.682]             {
[08:25:53.682]                 {
[08:25:53.682]                   {
[08:25:53.682]                     {
[08:25:53.682]                       base::local({
[08:25:53.682]                         has_future <- base::requireNamespace("future", 
[08:25:53.682]                           quietly = TRUE)
[08:25:53.682]                         if (has_future) {
[08:25:53.682]                           ns <- base::getNamespace("future")
[08:25:53.682]                           version <- ns[[".package"]][["version"]]
[08:25:53.682]                           if (is.null(version)) 
[08:25:53.682]                             version <- utils::packageVersion("future")
[08:25:53.682]                         }
[08:25:53.682]                         else {
[08:25:53.682]                           version <- NULL
[08:25:53.682]                         }
[08:25:53.682]                         if (!has_future || version < "1.8.0") {
[08:25:53.682]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.682]                             "", base::R.version$version.string), 
[08:25:53.682]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.682]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.682]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.682]                               "release", "version")], collapse = " "), 
[08:25:53.682]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.682]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.682]                             info)
[08:25:53.682]                           info <- base::paste(info, collapse = "; ")
[08:25:53.682]                           if (!has_future) {
[08:25:53.682]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.682]                               info)
[08:25:53.682]                           }
[08:25:53.682]                           else {
[08:25:53.682]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.682]                               info, version)
[08:25:53.682]                           }
[08:25:53.682]                           base::stop(msg)
[08:25:53.682]                         }
[08:25:53.682]                       })
[08:25:53.682]                     }
[08:25:53.682]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.682]                     base::options(mc.cores = 1L)
[08:25:53.682]                   }
[08:25:53.682]                   ...future.strategy.old <- future::plan("list")
[08:25:53.682]                   options(future.plan = NULL)
[08:25:53.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.682]                 }
[08:25:53.682]                 ...future.workdir <- getwd()
[08:25:53.682]             }
[08:25:53.682]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.682]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.682]         }
[08:25:53.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.682]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.682]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.682]             base::names(...future.oldOptions))
[08:25:53.682]     }
[08:25:53.682]     if (FALSE) {
[08:25:53.682]     }
[08:25:53.682]     else {
[08:25:53.682]         if (TRUE) {
[08:25:53.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.682]                 open = "w")
[08:25:53.682]         }
[08:25:53.682]         else {
[08:25:53.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.682]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.682]         }
[08:25:53.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.682]             base::sink(type = "output", split = FALSE)
[08:25:53.682]             base::close(...future.stdout)
[08:25:53.682]         }, add = TRUE)
[08:25:53.682]     }
[08:25:53.682]     ...future.frame <- base::sys.nframe()
[08:25:53.682]     ...future.conditions <- base::list()
[08:25:53.682]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.682]     if (FALSE) {
[08:25:53.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.682]     }
[08:25:53.682]     ...future.result <- base::tryCatch({
[08:25:53.682]         base::withCallingHandlers({
[08:25:53.682]             ...future.value <- base::withVisible(base::local({
[08:25:53.682]                 ...future.makeSendCondition <- base::local({
[08:25:53.682]                   sendCondition <- NULL
[08:25:53.682]                   function(frame = 1L) {
[08:25:53.682]                     if (is.function(sendCondition)) 
[08:25:53.682]                       return(sendCondition)
[08:25:53.682]                     ns <- getNamespace("parallel")
[08:25:53.682]                     if (exists("sendData", mode = "function", 
[08:25:53.682]                       envir = ns)) {
[08:25:53.682]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.682]                         envir = ns)
[08:25:53.682]                       envir <- sys.frame(frame)
[08:25:53.682]                       master <- NULL
[08:25:53.682]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.682]                         !identical(envir, emptyenv())) {
[08:25:53.682]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.682]                           inherits = FALSE)) {
[08:25:53.682]                           master <- get("master", mode = "list", 
[08:25:53.682]                             envir = envir, inherits = FALSE)
[08:25:53.682]                           if (inherits(master, c("SOCKnode", 
[08:25:53.682]                             "SOCK0node"))) {
[08:25:53.682]                             sendCondition <<- function(cond) {
[08:25:53.682]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.682]                                 success = TRUE)
[08:25:53.682]                               parallel_sendData(master, data)
[08:25:53.682]                             }
[08:25:53.682]                             return(sendCondition)
[08:25:53.682]                           }
[08:25:53.682]                         }
[08:25:53.682]                         frame <- frame + 1L
[08:25:53.682]                         envir <- sys.frame(frame)
[08:25:53.682]                       }
[08:25:53.682]                     }
[08:25:53.682]                     sendCondition <<- function(cond) NULL
[08:25:53.682]                   }
[08:25:53.682]                 })
[08:25:53.682]                 withCallingHandlers({
[08:25:53.682]                   {
[08:25:53.682]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.682]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.682]                       ...future.globals.maxSize)) {
[08:25:53.682]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.682]                       on.exit(options(oopts), add = TRUE)
[08:25:53.682]                     }
[08:25:53.682]                     {
[08:25:53.682]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.682]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.682]                         USE.NAMES = FALSE)
[08:25:53.682]                       do.call(mapply, args = args)
[08:25:53.682]                     }
[08:25:53.682]                   }
[08:25:53.682]                 }, immediateCondition = function(cond) {
[08:25:53.682]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.682]                   sendCondition(cond)
[08:25:53.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.682]                   {
[08:25:53.682]                     inherits <- base::inherits
[08:25:53.682]                     invokeRestart <- base::invokeRestart
[08:25:53.682]                     is.null <- base::is.null
[08:25:53.682]                     muffled <- FALSE
[08:25:53.682]                     if (inherits(cond, "message")) {
[08:25:53.682]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.682]                       if (muffled) 
[08:25:53.682]                         invokeRestart("muffleMessage")
[08:25:53.682]                     }
[08:25:53.682]                     else if (inherits(cond, "warning")) {
[08:25:53.682]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.682]                       if (muffled) 
[08:25:53.682]                         invokeRestart("muffleWarning")
[08:25:53.682]                     }
[08:25:53.682]                     else if (inherits(cond, "condition")) {
[08:25:53.682]                       if (!is.null(pattern)) {
[08:25:53.682]                         computeRestarts <- base::computeRestarts
[08:25:53.682]                         grepl <- base::grepl
[08:25:53.682]                         restarts <- computeRestarts(cond)
[08:25:53.682]                         for (restart in restarts) {
[08:25:53.682]                           name <- restart$name
[08:25:53.682]                           if (is.null(name)) 
[08:25:53.682]                             next
[08:25:53.682]                           if (!grepl(pattern, name)) 
[08:25:53.682]                             next
[08:25:53.682]                           invokeRestart(restart)
[08:25:53.682]                           muffled <- TRUE
[08:25:53.682]                           break
[08:25:53.682]                         }
[08:25:53.682]                       }
[08:25:53.682]                     }
[08:25:53.682]                     invisible(muffled)
[08:25:53.682]                   }
[08:25:53.682]                   muffleCondition(cond)
[08:25:53.682]                 })
[08:25:53.682]             }))
[08:25:53.682]             future::FutureResult(value = ...future.value$value, 
[08:25:53.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.682]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.682]                     ...future.globalenv.names))
[08:25:53.682]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.682]         }, condition = base::local({
[08:25:53.682]             c <- base::c
[08:25:53.682]             inherits <- base::inherits
[08:25:53.682]             invokeRestart <- base::invokeRestart
[08:25:53.682]             length <- base::length
[08:25:53.682]             list <- base::list
[08:25:53.682]             seq.int <- base::seq.int
[08:25:53.682]             signalCondition <- base::signalCondition
[08:25:53.682]             sys.calls <- base::sys.calls
[08:25:53.682]             `[[` <- base::`[[`
[08:25:53.682]             `+` <- base::`+`
[08:25:53.682]             `<<-` <- base::`<<-`
[08:25:53.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.682]                   3L)]
[08:25:53.682]             }
[08:25:53.682]             function(cond) {
[08:25:53.682]                 is_error <- inherits(cond, "error")
[08:25:53.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.682]                   NULL)
[08:25:53.682]                 if (is_error) {
[08:25:53.682]                   sessionInformation <- function() {
[08:25:53.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.682]                       search = base::search(), system = base::Sys.info())
[08:25:53.682]                   }
[08:25:53.682]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.682]                     cond$call), session = sessionInformation(), 
[08:25:53.682]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.682]                   signalCondition(cond)
[08:25:53.682]                 }
[08:25:53.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.682]                 "immediateCondition"))) {
[08:25:53.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.682]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.682]                   if (TRUE && !signal) {
[08:25:53.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.682]                     {
[08:25:53.682]                       inherits <- base::inherits
[08:25:53.682]                       invokeRestart <- base::invokeRestart
[08:25:53.682]                       is.null <- base::is.null
[08:25:53.682]                       muffled <- FALSE
[08:25:53.682]                       if (inherits(cond, "message")) {
[08:25:53.682]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.682]                         if (muffled) 
[08:25:53.682]                           invokeRestart("muffleMessage")
[08:25:53.682]                       }
[08:25:53.682]                       else if (inherits(cond, "warning")) {
[08:25:53.682]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.682]                         if (muffled) 
[08:25:53.682]                           invokeRestart("muffleWarning")
[08:25:53.682]                       }
[08:25:53.682]                       else if (inherits(cond, "condition")) {
[08:25:53.682]                         if (!is.null(pattern)) {
[08:25:53.682]                           computeRestarts <- base::computeRestarts
[08:25:53.682]                           grepl <- base::grepl
[08:25:53.682]                           restarts <- computeRestarts(cond)
[08:25:53.682]                           for (restart in restarts) {
[08:25:53.682]                             name <- restart$name
[08:25:53.682]                             if (is.null(name)) 
[08:25:53.682]                               next
[08:25:53.682]                             if (!grepl(pattern, name)) 
[08:25:53.682]                               next
[08:25:53.682]                             invokeRestart(restart)
[08:25:53.682]                             muffled <- TRUE
[08:25:53.682]                             break
[08:25:53.682]                           }
[08:25:53.682]                         }
[08:25:53.682]                       }
[08:25:53.682]                       invisible(muffled)
[08:25:53.682]                     }
[08:25:53.682]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.682]                   }
[08:25:53.682]                 }
[08:25:53.682]                 else {
[08:25:53.682]                   if (TRUE) {
[08:25:53.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.682]                     {
[08:25:53.682]                       inherits <- base::inherits
[08:25:53.682]                       invokeRestart <- base::invokeRestart
[08:25:53.682]                       is.null <- base::is.null
[08:25:53.682]                       muffled <- FALSE
[08:25:53.682]                       if (inherits(cond, "message")) {
[08:25:53.682]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.682]                         if (muffled) 
[08:25:53.682]                           invokeRestart("muffleMessage")
[08:25:53.682]                       }
[08:25:53.682]                       else if (inherits(cond, "warning")) {
[08:25:53.682]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.682]                         if (muffled) 
[08:25:53.682]                           invokeRestart("muffleWarning")
[08:25:53.682]                       }
[08:25:53.682]                       else if (inherits(cond, "condition")) {
[08:25:53.682]                         if (!is.null(pattern)) {
[08:25:53.682]                           computeRestarts <- base::computeRestarts
[08:25:53.682]                           grepl <- base::grepl
[08:25:53.682]                           restarts <- computeRestarts(cond)
[08:25:53.682]                           for (restart in restarts) {
[08:25:53.682]                             name <- restart$name
[08:25:53.682]                             if (is.null(name)) 
[08:25:53.682]                               next
[08:25:53.682]                             if (!grepl(pattern, name)) 
[08:25:53.682]                               next
[08:25:53.682]                             invokeRestart(restart)
[08:25:53.682]                             muffled <- TRUE
[08:25:53.682]                             break
[08:25:53.682]                           }
[08:25:53.682]                         }
[08:25:53.682]                       }
[08:25:53.682]                       invisible(muffled)
[08:25:53.682]                     }
[08:25:53.682]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.682]                   }
[08:25:53.682]                 }
[08:25:53.682]             }
[08:25:53.682]         }))
[08:25:53.682]     }, error = function(ex) {
[08:25:53.682]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.682]                 ...future.rng), started = ...future.startTime, 
[08:25:53.682]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.682]             version = "1.8"), class = "FutureResult")
[08:25:53.682]     }, finally = {
[08:25:53.682]         if (!identical(...future.workdir, getwd())) 
[08:25:53.682]             setwd(...future.workdir)
[08:25:53.682]         {
[08:25:53.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.682]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.682]             }
[08:25:53.682]             base::options(...future.oldOptions)
[08:25:53.682]             if (.Platform$OS.type == "windows") {
[08:25:53.682]                 old_names <- names(...future.oldEnvVars)
[08:25:53.682]                 envs <- base::Sys.getenv()
[08:25:53.682]                 names <- names(envs)
[08:25:53.682]                 common <- intersect(names, old_names)
[08:25:53.682]                 added <- setdiff(names, old_names)
[08:25:53.682]                 removed <- setdiff(old_names, names)
[08:25:53.682]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.682]                   envs[common]]
[08:25:53.682]                 NAMES <- toupper(changed)
[08:25:53.682]                 args <- list()
[08:25:53.682]                 for (kk in seq_along(NAMES)) {
[08:25:53.682]                   name <- changed[[kk]]
[08:25:53.682]                   NAME <- NAMES[[kk]]
[08:25:53.682]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.682]                     next
[08:25:53.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.682]                 }
[08:25:53.682]                 NAMES <- toupper(added)
[08:25:53.682]                 for (kk in seq_along(NAMES)) {
[08:25:53.682]                   name <- added[[kk]]
[08:25:53.682]                   NAME <- NAMES[[kk]]
[08:25:53.682]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.682]                     next
[08:25:53.682]                   args[[name]] <- ""
[08:25:53.682]                 }
[08:25:53.682]                 NAMES <- toupper(removed)
[08:25:53.682]                 for (kk in seq_along(NAMES)) {
[08:25:53.682]                   name <- removed[[kk]]
[08:25:53.682]                   NAME <- NAMES[[kk]]
[08:25:53.682]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.682]                     next
[08:25:53.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.682]                 }
[08:25:53.682]                 if (length(args) > 0) 
[08:25:53.682]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.682]             }
[08:25:53.682]             else {
[08:25:53.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.682]             }
[08:25:53.682]             {
[08:25:53.682]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.682]                   0L) {
[08:25:53.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.682]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.682]                   base::options(opts)
[08:25:53.682]                 }
[08:25:53.682]                 {
[08:25:53.682]                   {
[08:25:53.682]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.682]                     NULL
[08:25:53.682]                   }
[08:25:53.682]                   options(future.plan = NULL)
[08:25:53.682]                   if (is.na(NA_character_)) 
[08:25:53.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.682]                     .init = FALSE)
[08:25:53.682]                 }
[08:25:53.682]             }
[08:25:53.682]         }
[08:25:53.682]     })
[08:25:53.682]     if (TRUE) {
[08:25:53.682]         base::sink(type = "output", split = FALSE)
[08:25:53.682]         if (TRUE) {
[08:25:53.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.682]         }
[08:25:53.682]         else {
[08:25:53.682]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.682]         }
[08:25:53.682]         base::close(...future.stdout)
[08:25:53.682]         ...future.stdout <- NULL
[08:25:53.682]     }
[08:25:53.682]     ...future.result$conditions <- ...future.conditions
[08:25:53.682]     ...future.result$finished <- base::Sys.time()
[08:25:53.682]     ...future.result
[08:25:53.682] }
[08:25:53.685] Exporting 5 global objects (673 bytes) to cluster node #1 ...
[08:25:53.685] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ...
[08:25:53.685] Exporting ‘...future.FUN’ (34 bytes) to cluster node #1 ... DONE
[08:25:53.685] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:53.686] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.686] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ...
[08:25:53.686] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #1 ... DONE
[08:25:53.686] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:53.687] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.687] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:53.687] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.687] Exporting 5 global objects (673 bytes) to cluster node #1 ... DONE
[08:25:53.688] MultisessionFuture started
[08:25:53.688] - Launch lazy future ... done
[08:25:53.688] run() for ‘MultisessionFuture’ ... done
[08:25:53.688] Created future:
[08:25:53.688] MultisessionFuture:
[08:25:53.688] Label: ‘future_mapply-1’
[08:25:53.688] Expression:
[08:25:53.688] {
[08:25:53.688]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.688]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.688]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.688]         on.exit(options(oopts), add = TRUE)
[08:25:53.688]     }
[08:25:53.688]     {
[08:25:53.688]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.688]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.688]         do.call(mapply, args = args)
[08:25:53.688]     }
[08:25:53.688] }
[08:25:53.688] Lazy evaluation: FALSE
[08:25:53.688] Asynchronous evaluation: TRUE
[08:25:53.688] Local evaluation: TRUE
[08:25:53.688] Environment: R_GlobalEnv
[08:25:53.688] Capture standard output: TRUE
[08:25:53.688] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.688] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.688] Packages: <none>
[08:25:53.688] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.688] Resolved: FALSE
[08:25:53.688] Value: <not collected>
[08:25:53.688] Conditions captured: <none>
[08:25:53.688] Early signaling: FALSE
[08:25:53.688] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.688] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.699] Chunk #1 of 2 ... DONE
[08:25:53.700] Chunk #2 of 2 ...
[08:25:53.700]  - Finding globals in '...' for chunk #2 ...
[08:25:53.700] getGlobalsAndPackages() ...
[08:25:53.700] Searching for globals...
[08:25:53.700] 
[08:25:53.700] Searching for globals ... DONE
[08:25:53.701] - globals: [0] <none>
[08:25:53.701] getGlobalsAndPackages() ... DONE
[08:25:53.701]    + additional globals found: [n=0] 
[08:25:53.701]    + additional namespaces needed: [n=0] 
[08:25:53.701]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:53.701]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.701]  - seeds: <none>
[08:25:53.701]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.701] getGlobalsAndPackages() ...
[08:25:53.701] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.702] Resolving globals: FALSE
[08:25:53.702] The total size of the 5 globals is 210 bytes (210 bytes)
[08:25:53.702] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 210 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (95 bytes of class ‘list’), ‘...future.FUN’ (34 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:53.703] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.703] 
[08:25:53.703] getGlobalsAndPackages() ... DONE
[08:25:53.703] run() for ‘Future’ ...
[08:25:53.703] - state: ‘created’
[08:25:53.703] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.717] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.718]   - Field: ‘node’
[08:25:53.718]   - Field: ‘label’
[08:25:53.718]   - Field: ‘local’
[08:25:53.718]   - Field: ‘owner’
[08:25:53.718]   - Field: ‘envir’
[08:25:53.718]   - Field: ‘workers’
[08:25:53.718]   - Field: ‘packages’
[08:25:53.718]   - Field: ‘gc’
[08:25:53.718]   - Field: ‘conditions’
[08:25:53.718]   - Field: ‘persistent’
[08:25:53.718]   - Field: ‘expr’
[08:25:53.719]   - Field: ‘uuid’
[08:25:53.719]   - Field: ‘seed’
[08:25:53.719]   - Field: ‘version’
[08:25:53.719]   - Field: ‘result’
[08:25:53.719]   - Field: ‘asynchronous’
[08:25:53.719]   - Field: ‘calls’
[08:25:53.719]   - Field: ‘globals’
[08:25:53.719]   - Field: ‘stdout’
[08:25:53.719]   - Field: ‘earlySignal’
[08:25:53.719]   - Field: ‘lazy’
[08:25:53.719]   - Field: ‘state’
[08:25:53.719] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.720] - Launch lazy future ...
[08:25:53.720] Packages needed by the future expression (n = 0): <none>
[08:25:53.720] Packages needed by future strategies (n = 0): <none>
[08:25:53.720] {
[08:25:53.720]     {
[08:25:53.720]         {
[08:25:53.720]             ...future.startTime <- base::Sys.time()
[08:25:53.720]             {
[08:25:53.720]                 {
[08:25:53.720]                   {
[08:25:53.720]                     {
[08:25:53.720]                       base::local({
[08:25:53.720]                         has_future <- base::requireNamespace("future", 
[08:25:53.720]                           quietly = TRUE)
[08:25:53.720]                         if (has_future) {
[08:25:53.720]                           ns <- base::getNamespace("future")
[08:25:53.720]                           version <- ns[[".package"]][["version"]]
[08:25:53.720]                           if (is.null(version)) 
[08:25:53.720]                             version <- utils::packageVersion("future")
[08:25:53.720]                         }
[08:25:53.720]                         else {
[08:25:53.720]                           version <- NULL
[08:25:53.720]                         }
[08:25:53.720]                         if (!has_future || version < "1.8.0") {
[08:25:53.720]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.720]                             "", base::R.version$version.string), 
[08:25:53.720]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:53.720]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:53.720]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.720]                               "release", "version")], collapse = " "), 
[08:25:53.720]                             hostname = base::Sys.info()[["nodename"]])
[08:25:53.720]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.720]                             info)
[08:25:53.720]                           info <- base::paste(info, collapse = "; ")
[08:25:53.720]                           if (!has_future) {
[08:25:53.720]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.720]                               info)
[08:25:53.720]                           }
[08:25:53.720]                           else {
[08:25:53.720]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.720]                               info, version)
[08:25:53.720]                           }
[08:25:53.720]                           base::stop(msg)
[08:25:53.720]                         }
[08:25:53.720]                       })
[08:25:53.720]                     }
[08:25:53.720]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.720]                     base::options(mc.cores = 1L)
[08:25:53.720]                   }
[08:25:53.720]                   ...future.strategy.old <- future::plan("list")
[08:25:53.720]                   options(future.plan = NULL)
[08:25:53.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.720]                 }
[08:25:53.720]                 ...future.workdir <- getwd()
[08:25:53.720]             }
[08:25:53.720]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.720]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.720]         }
[08:25:53.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.720]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.720]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.720]             base::names(...future.oldOptions))
[08:25:53.720]     }
[08:25:53.720]     if (FALSE) {
[08:25:53.720]     }
[08:25:53.720]     else {
[08:25:53.720]         if (TRUE) {
[08:25:53.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.720]                 open = "w")
[08:25:53.720]         }
[08:25:53.720]         else {
[08:25:53.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.720]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.720]         }
[08:25:53.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.720]             base::sink(type = "output", split = FALSE)
[08:25:53.720]             base::close(...future.stdout)
[08:25:53.720]         }, add = TRUE)
[08:25:53.720]     }
[08:25:53.720]     ...future.frame <- base::sys.nframe()
[08:25:53.720]     ...future.conditions <- base::list()
[08:25:53.720]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.720]     if (FALSE) {
[08:25:53.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.720]     }
[08:25:53.720]     ...future.result <- base::tryCatch({
[08:25:53.720]         base::withCallingHandlers({
[08:25:53.720]             ...future.value <- base::withVisible(base::local({
[08:25:53.720]                 ...future.makeSendCondition <- base::local({
[08:25:53.720]                   sendCondition <- NULL
[08:25:53.720]                   function(frame = 1L) {
[08:25:53.720]                     if (is.function(sendCondition)) 
[08:25:53.720]                       return(sendCondition)
[08:25:53.720]                     ns <- getNamespace("parallel")
[08:25:53.720]                     if (exists("sendData", mode = "function", 
[08:25:53.720]                       envir = ns)) {
[08:25:53.720]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.720]                         envir = ns)
[08:25:53.720]                       envir <- sys.frame(frame)
[08:25:53.720]                       master <- NULL
[08:25:53.720]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.720]                         !identical(envir, emptyenv())) {
[08:25:53.720]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.720]                           inherits = FALSE)) {
[08:25:53.720]                           master <- get("master", mode = "list", 
[08:25:53.720]                             envir = envir, inherits = FALSE)
[08:25:53.720]                           if (inherits(master, c("SOCKnode", 
[08:25:53.720]                             "SOCK0node"))) {
[08:25:53.720]                             sendCondition <<- function(cond) {
[08:25:53.720]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.720]                                 success = TRUE)
[08:25:53.720]                               parallel_sendData(master, data)
[08:25:53.720]                             }
[08:25:53.720]                             return(sendCondition)
[08:25:53.720]                           }
[08:25:53.720]                         }
[08:25:53.720]                         frame <- frame + 1L
[08:25:53.720]                         envir <- sys.frame(frame)
[08:25:53.720]                       }
[08:25:53.720]                     }
[08:25:53.720]                     sendCondition <<- function(cond) NULL
[08:25:53.720]                   }
[08:25:53.720]                 })
[08:25:53.720]                 withCallingHandlers({
[08:25:53.720]                   {
[08:25:53.720]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.720]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.720]                       ...future.globals.maxSize)) {
[08:25:53.720]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.720]                       on.exit(options(oopts), add = TRUE)
[08:25:53.720]                     }
[08:25:53.720]                     {
[08:25:53.720]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.720]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.720]                         USE.NAMES = FALSE)
[08:25:53.720]                       do.call(mapply, args = args)
[08:25:53.720]                     }
[08:25:53.720]                   }
[08:25:53.720]                 }, immediateCondition = function(cond) {
[08:25:53.720]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.720]                   sendCondition(cond)
[08:25:53.720]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.720]                   {
[08:25:53.720]                     inherits <- base::inherits
[08:25:53.720]                     invokeRestart <- base::invokeRestart
[08:25:53.720]                     is.null <- base::is.null
[08:25:53.720]                     muffled <- FALSE
[08:25:53.720]                     if (inherits(cond, "message")) {
[08:25:53.720]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.720]                       if (muffled) 
[08:25:53.720]                         invokeRestart("muffleMessage")
[08:25:53.720]                     }
[08:25:53.720]                     else if (inherits(cond, "warning")) {
[08:25:53.720]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.720]                       if (muffled) 
[08:25:53.720]                         invokeRestart("muffleWarning")
[08:25:53.720]                     }
[08:25:53.720]                     else if (inherits(cond, "condition")) {
[08:25:53.720]                       if (!is.null(pattern)) {
[08:25:53.720]                         computeRestarts <- base::computeRestarts
[08:25:53.720]                         grepl <- base::grepl
[08:25:53.720]                         restarts <- computeRestarts(cond)
[08:25:53.720]                         for (restart in restarts) {
[08:25:53.720]                           name <- restart$name
[08:25:53.720]                           if (is.null(name)) 
[08:25:53.720]                             next
[08:25:53.720]                           if (!grepl(pattern, name)) 
[08:25:53.720]                             next
[08:25:53.720]                           invokeRestart(restart)
[08:25:53.720]                           muffled <- TRUE
[08:25:53.720]                           break
[08:25:53.720]                         }
[08:25:53.720]                       }
[08:25:53.720]                     }
[08:25:53.720]                     invisible(muffled)
[08:25:53.720]                   }
[08:25:53.720]                   muffleCondition(cond)
[08:25:53.720]                 })
[08:25:53.720]             }))
[08:25:53.720]             future::FutureResult(value = ...future.value$value, 
[08:25:53.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.720]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.720]                     ...future.globalenv.names))
[08:25:53.720]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.720]         }, condition = base::local({
[08:25:53.720]             c <- base::c
[08:25:53.720]             inherits <- base::inherits
[08:25:53.720]             invokeRestart <- base::invokeRestart
[08:25:53.720]             length <- base::length
[08:25:53.720]             list <- base::list
[08:25:53.720]             seq.int <- base::seq.int
[08:25:53.720]             signalCondition <- base::signalCondition
[08:25:53.720]             sys.calls <- base::sys.calls
[08:25:53.720]             `[[` <- base::`[[`
[08:25:53.720]             `+` <- base::`+`
[08:25:53.720]             `<<-` <- base::`<<-`
[08:25:53.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.720]                   3L)]
[08:25:53.720]             }
[08:25:53.720]             function(cond) {
[08:25:53.720]                 is_error <- inherits(cond, "error")
[08:25:53.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.720]                   NULL)
[08:25:53.720]                 if (is_error) {
[08:25:53.720]                   sessionInformation <- function() {
[08:25:53.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.720]                       search = base::search(), system = base::Sys.info())
[08:25:53.720]                   }
[08:25:53.720]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.720]                     cond$call), session = sessionInformation(), 
[08:25:53.720]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.720]                   signalCondition(cond)
[08:25:53.720]                 }
[08:25:53.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.720]                 "immediateCondition"))) {
[08:25:53.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.720]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.720]                   if (TRUE && !signal) {
[08:25:53.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.720]                     {
[08:25:53.720]                       inherits <- base::inherits
[08:25:53.720]                       invokeRestart <- base::invokeRestart
[08:25:53.720]                       is.null <- base::is.null
[08:25:53.720]                       muffled <- FALSE
[08:25:53.720]                       if (inherits(cond, "message")) {
[08:25:53.720]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.720]                         if (muffled) 
[08:25:53.720]                           invokeRestart("muffleMessage")
[08:25:53.720]                       }
[08:25:53.720]                       else if (inherits(cond, "warning")) {
[08:25:53.720]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.720]                         if (muffled) 
[08:25:53.720]                           invokeRestart("muffleWarning")
[08:25:53.720]                       }
[08:25:53.720]                       else if (inherits(cond, "condition")) {
[08:25:53.720]                         if (!is.null(pattern)) {
[08:25:53.720]                           computeRestarts <- base::computeRestarts
[08:25:53.720]                           grepl <- base::grepl
[08:25:53.720]                           restarts <- computeRestarts(cond)
[08:25:53.720]                           for (restart in restarts) {
[08:25:53.720]                             name <- restart$name
[08:25:53.720]                             if (is.null(name)) 
[08:25:53.720]                               next
[08:25:53.720]                             if (!grepl(pattern, name)) 
[08:25:53.720]                               next
[08:25:53.720]                             invokeRestart(restart)
[08:25:53.720]                             muffled <- TRUE
[08:25:53.720]                             break
[08:25:53.720]                           }
[08:25:53.720]                         }
[08:25:53.720]                       }
[08:25:53.720]                       invisible(muffled)
[08:25:53.720]                     }
[08:25:53.720]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.720]                   }
[08:25:53.720]                 }
[08:25:53.720]                 else {
[08:25:53.720]                   if (TRUE) {
[08:25:53.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.720]                     {
[08:25:53.720]                       inherits <- base::inherits
[08:25:53.720]                       invokeRestart <- base::invokeRestart
[08:25:53.720]                       is.null <- base::is.null
[08:25:53.720]                       muffled <- FALSE
[08:25:53.720]                       if (inherits(cond, "message")) {
[08:25:53.720]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.720]                         if (muffled) 
[08:25:53.720]                           invokeRestart("muffleMessage")
[08:25:53.720]                       }
[08:25:53.720]                       else if (inherits(cond, "warning")) {
[08:25:53.720]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.720]                         if (muffled) 
[08:25:53.720]                           invokeRestart("muffleWarning")
[08:25:53.720]                       }
[08:25:53.720]                       else if (inherits(cond, "condition")) {
[08:25:53.720]                         if (!is.null(pattern)) {
[08:25:53.720]                           computeRestarts <- base::computeRestarts
[08:25:53.720]                           grepl <- base::grepl
[08:25:53.720]                           restarts <- computeRestarts(cond)
[08:25:53.720]                           for (restart in restarts) {
[08:25:53.720]                             name <- restart$name
[08:25:53.720]                             if (is.null(name)) 
[08:25:53.720]                               next
[08:25:53.720]                             if (!grepl(pattern, name)) 
[08:25:53.720]                               next
[08:25:53.720]                             invokeRestart(restart)
[08:25:53.720]                             muffled <- TRUE
[08:25:53.720]                             break
[08:25:53.720]                           }
[08:25:53.720]                         }
[08:25:53.720]                       }
[08:25:53.720]                       invisible(muffled)
[08:25:53.720]                     }
[08:25:53.720]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.720]                   }
[08:25:53.720]                 }
[08:25:53.720]             }
[08:25:53.720]         }))
[08:25:53.720]     }, error = function(ex) {
[08:25:53.720]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.720]                 ...future.rng), started = ...future.startTime, 
[08:25:53.720]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.720]             version = "1.8"), class = "FutureResult")
[08:25:53.720]     }, finally = {
[08:25:53.720]         if (!identical(...future.workdir, getwd())) 
[08:25:53.720]             setwd(...future.workdir)
[08:25:53.720]         {
[08:25:53.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.720]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.720]             }
[08:25:53.720]             base::options(...future.oldOptions)
[08:25:53.720]             if (.Platform$OS.type == "windows") {
[08:25:53.720]                 old_names <- names(...future.oldEnvVars)
[08:25:53.720]                 envs <- base::Sys.getenv()
[08:25:53.720]                 names <- names(envs)
[08:25:53.720]                 common <- intersect(names, old_names)
[08:25:53.720]                 added <- setdiff(names, old_names)
[08:25:53.720]                 removed <- setdiff(old_names, names)
[08:25:53.720]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.720]                   envs[common]]
[08:25:53.720]                 NAMES <- toupper(changed)
[08:25:53.720]                 args <- list()
[08:25:53.720]                 for (kk in seq_along(NAMES)) {
[08:25:53.720]                   name <- changed[[kk]]
[08:25:53.720]                   NAME <- NAMES[[kk]]
[08:25:53.720]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.720]                     next
[08:25:53.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.720]                 }
[08:25:53.720]                 NAMES <- toupper(added)
[08:25:53.720]                 for (kk in seq_along(NAMES)) {
[08:25:53.720]                   name <- added[[kk]]
[08:25:53.720]                   NAME <- NAMES[[kk]]
[08:25:53.720]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.720]                     next
[08:25:53.720]                   args[[name]] <- ""
[08:25:53.720]                 }
[08:25:53.720]                 NAMES <- toupper(removed)
[08:25:53.720]                 for (kk in seq_along(NAMES)) {
[08:25:53.720]                   name <- removed[[kk]]
[08:25:53.720]                   NAME <- NAMES[[kk]]
[08:25:53.720]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.720]                     next
[08:25:53.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.720]                 }
[08:25:53.720]                 if (length(args) > 0) 
[08:25:53.720]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.720]             }
[08:25:53.720]             else {
[08:25:53.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.720]             }
[08:25:53.720]             {
[08:25:53.720]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.720]                   0L) {
[08:25:53.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.720]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.720]                   base::options(opts)
[08:25:53.720]                 }
[08:25:53.720]                 {
[08:25:53.720]                   {
[08:25:53.720]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.720]                     NULL
[08:25:53.720]                   }
[08:25:53.720]                   options(future.plan = NULL)
[08:25:53.720]                   if (is.na(NA_character_)) 
[08:25:53.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.720]                     .init = FALSE)
[08:25:53.720]                 }
[08:25:53.720]             }
[08:25:53.720]         }
[08:25:53.720]     })
[08:25:53.720]     if (TRUE) {
[08:25:53.720]         base::sink(type = "output", split = FALSE)
[08:25:53.720]         if (TRUE) {
[08:25:53.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.720]         }
[08:25:53.720]         else {
[08:25:53.720]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.720]         }
[08:25:53.720]         base::close(...future.stdout)
[08:25:53.720]         ...future.stdout <- NULL
[08:25:53.720]     }
[08:25:53.720]     ...future.result$conditions <- ...future.conditions
[08:25:53.720]     ...future.result$finished <- base::Sys.time()
[08:25:53.720]     ...future.result
[08:25:53.720] }
[08:25:53.723] Exporting 5 global objects (673 bytes) to cluster node #2 ...
[08:25:53.724] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ...
[08:25:53.724] Exporting ‘...future.FUN’ (34 bytes) to cluster node #2 ... DONE
[08:25:53.724] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:53.724] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.725] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ...
[08:25:53.725] Exporting ‘...future.elements_ii’ (95 bytes) to cluster node #2 ... DONE
[08:25:53.725] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:53.725] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.726] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:53.726] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.726] Exporting 5 global objects (673 bytes) to cluster node #2 ... DONE
[08:25:53.726] MultisessionFuture started
[08:25:53.727] - Launch lazy future ... done
[08:25:53.727] run() for ‘MultisessionFuture’ ... done
[08:25:53.727] Created future:
[08:25:53.727] MultisessionFuture:
[08:25:53.727] Label: ‘future_mapply-2’
[08:25:53.727] Expression:
[08:25:53.727] {
[08:25:53.727]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.727]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.727]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.727]         on.exit(options(oopts), add = TRUE)
[08:25:53.727]     }
[08:25:53.727]     {
[08:25:53.727]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.727]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.727]         do.call(mapply, args = args)
[08:25:53.727]     }
[08:25:53.727] }
[08:25:53.727] Lazy evaluation: FALSE
[08:25:53.727] Asynchronous evaluation: TRUE
[08:25:53.727] Local evaluation: TRUE
[08:25:53.727] Environment: R_GlobalEnv
[08:25:53.727] Capture standard output: TRUE
[08:25:53.727] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.727] Globals: 5 objects totaling 210 bytes (function ‘...future.FUN’ of 34 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.727] Packages: <none>
[08:25:53.727] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.727] Resolved: FALSE
[08:25:53.727] Value: <not collected>
[08:25:53.727] Conditions captured: <none>
[08:25:53.727] Early signaling: FALSE
[08:25:53.727] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.727] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.738] Chunk #2 of 2 ... DONE
[08:25:53.738] Launching 2 futures (chunks) ... DONE
[08:25:53.739] Resolving 2 futures (chunks) ...
[08:25:53.739] resolve() on list ...
[08:25:53.739]  recursive: 0
[08:25:53.739]  length: 2
[08:25:53.739] 
[08:25:53.739] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.739] - Validating connection of MultisessionFuture
[08:25:53.740] - received message: FutureResult
[08:25:53.740] - Received FutureResult
[08:25:53.740] - Erased future from FutureRegistry
[08:25:53.740] result() for ClusterFuture ...
[08:25:53.740] - result already collected: FutureResult
[08:25:53.740] result() for ClusterFuture ... done
[08:25:53.740] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.740] Future #1
[08:25:53.740] result() for ClusterFuture ...
[08:25:53.740] - result already collected: FutureResult
[08:25:53.741] result() for ClusterFuture ... done
[08:25:53.741] result() for ClusterFuture ...
[08:25:53.741] - result already collected: FutureResult
[08:25:53.741] result() for ClusterFuture ... done
[08:25:53.741] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:53.741] - nx: 2
[08:25:53.741] - relay: TRUE
[08:25:53.741] - stdout: TRUE
[08:25:53.741] - signal: TRUE
[08:25:53.741] - resignal: FALSE
[08:25:53.741] - force: TRUE
[08:25:53.741] - relayed: [n=2] FALSE, FALSE
[08:25:53.742] - queued futures: [n=2] FALSE, FALSE
[08:25:53.742]  - until=1
[08:25:53.742]  - relaying element #1
[08:25:53.742] result() for ClusterFuture ...
[08:25:53.742] - result already collected: FutureResult
[08:25:53.742] result() for ClusterFuture ... done
[08:25:53.742] result() for ClusterFuture ...
[08:25:53.742] - result already collected: FutureResult
[08:25:53.742] result() for ClusterFuture ... done
[08:25:53.742] result() for ClusterFuture ...
[08:25:53.742] - result already collected: FutureResult
[08:25:53.743] result() for ClusterFuture ... done
[08:25:53.743] result() for ClusterFuture ...
[08:25:53.743] - result already collected: FutureResult
[08:25:53.743] result() for ClusterFuture ... done
[08:25:53.743] - relayed: [n=2] TRUE, FALSE
[08:25:53.743] - queued futures: [n=2] TRUE, FALSE
[08:25:53.743] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:53.743]  length: 1 (resolved future 1)
[08:25:53.769] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.769] - Validating connection of MultisessionFuture
[08:25:53.770] - received message: FutureResult
[08:25:53.770] - Received FutureResult
[08:25:53.770] - Erased future from FutureRegistry
[08:25:53.770] result() for ClusterFuture ...
[08:25:53.770] - result already collected: FutureResult
[08:25:53.770] result() for ClusterFuture ... done
[08:25:53.770] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.770] Future #2
[08:25:53.770] result() for ClusterFuture ...
[08:25:53.770] - result already collected: FutureResult
[08:25:53.770] result() for ClusterFuture ... done
[08:25:53.771] result() for ClusterFuture ...
[08:25:53.771] - result already collected: FutureResult
[08:25:53.771] result() for ClusterFuture ... done
[08:25:53.771] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:53.771] - nx: 2
[08:25:53.771] - relay: TRUE
[08:25:53.771] - stdout: TRUE
[08:25:53.771] - signal: TRUE
[08:25:53.771] - resignal: FALSE
[08:25:53.771] - force: TRUE
[08:25:53.771] - relayed: [n=2] TRUE, FALSE
[08:25:53.771] - queued futures: [n=2] TRUE, FALSE
[08:25:53.772]  - until=2
[08:25:53.772]  - relaying element #2
[08:25:53.772] result() for ClusterFuture ...
[08:25:53.772] - result already collected: FutureResult
[08:25:53.772] result() for ClusterFuture ... done
[08:25:53.772] result() for ClusterFuture ...
[08:25:53.772] - result already collected: FutureResult
[08:25:53.772] result() for ClusterFuture ... done
[08:25:53.772] result() for ClusterFuture ...
[08:25:53.772] - result already collected: FutureResult
[08:25:53.772] result() for ClusterFuture ... done
[08:25:53.773] result() for ClusterFuture ...
[08:25:53.773] - result already collected: FutureResult
[08:25:53.773] result() for ClusterFuture ... done
[08:25:53.773] - relayed: [n=2] TRUE, TRUE
[08:25:53.773] - queued futures: [n=2] TRUE, TRUE
[08:25:53.773] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:53.773]  length: 0 (resolved future 2)
[08:25:53.773] Relaying remaining futures
[08:25:53.773] signalConditionsASAP(NULL, pos=0) ...
[08:25:53.773] - nx: 2
[08:25:53.773] - relay: TRUE
[08:25:53.773] - stdout: TRUE
[08:25:53.774] - signal: TRUE
[08:25:53.774] - resignal: FALSE
[08:25:53.774] - force: TRUE
[08:25:53.774] - relayed: [n=2] TRUE, TRUE
[08:25:53.774] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:53.774] - relayed: [n=2] TRUE, TRUE
[08:25:53.774] - queued futures: [n=2] TRUE, TRUE
[08:25:53.774] signalConditionsASAP(NULL, pos=0) ... done
[08:25:53.774] resolve() on list ... DONE
[08:25:53.774] result() for ClusterFuture ...
[08:25:53.774] - result already collected: FutureResult
[08:25:53.775] result() for ClusterFuture ... done
[08:25:53.775] result() for ClusterFuture ...
[08:25:53.775] - result already collected: FutureResult
[08:25:53.775] result() for ClusterFuture ... done
[08:25:53.775] result() for ClusterFuture ...
[08:25:53.775] - result already collected: FutureResult
[08:25:53.775] result() for ClusterFuture ... done
[08:25:53.775] result() for ClusterFuture ...
[08:25:53.775] - result already collected: FutureResult
[08:25:53.775] result() for ClusterFuture ... done
[08:25:53.775]  - Number of value chunks collected: 2
[08:25:53.776] Resolving 2 futures (chunks) ... DONE
[08:25:53.776] Reducing values from 2 chunks ...
[08:25:53.776]  - Number of values collected after concatenation: 4
[08:25:53.776]  - Number of values expected: 4
[08:25:53.776] Reducing values from 2 chunks ... DONE
[08:25:53.776] future_mapply() ... DONE
- Parallel RNG ...
[08:25:53.776] future_mapply() ...
[08:25:53.776] Generating random seeds ...
[08:25:53.776] Generating random seed streams for 4 elements ...
[08:25:53.777] Generating random seed streams for 4 elements ... DONE
[08:25:53.777] Generating random seeds ... DONE
[08:25:53.777] Will set RNG state on exit: 10407, 577742858, 2102271210, -1358985278, -270178576, -264560903, 889705382
[08:25:53.778] Number of chunks: 2
[08:25:53.779] getGlobalsAndPackagesXApply() ...
[08:25:53.779]  - future.globals: TRUE
[08:25:53.779] getGlobalsAndPackages() ...
[08:25:53.779] Searching for globals...
[08:25:53.780] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[08:25:53.780] Searching for globals ... DONE
[08:25:53.780] Resolving globals: FALSE
[08:25:53.781] The total size of the 1 globals is 501 bytes (501 bytes)
[08:25:53.781] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 501 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (501 bytes of class ‘function’)
[08:25:53.781] - globals: [1] ‘FUN’
[08:25:53.781] - packages: [1] ‘stats’
[08:25:53.781] getGlobalsAndPackages() ... DONE
[08:25:53.782]  - globals found/used: [n=1] ‘FUN’
[08:25:53.782]  - needed namespaces: [n=1] ‘stats’
[08:25:53.782] Finding globals ... DONE
[08:25:53.782] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:53.782] List of 2
[08:25:53.782]  $ ...future.FUN:function (n, min = 0, max = 1)  
[08:25:53.782]  $ MoreArgs     :List of 1
[08:25:53.782]   ..$ min: num 1
[08:25:53.782]  - attr(*, "where")=List of 2
[08:25:53.782]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:53.782]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:53.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:53.782]  - attr(*, "resolved")= logi FALSE
[08:25:53.782]  - attr(*, "total_size")= num NA
[08:25:53.785] Packages to be attached in all futures: [n=1] ‘stats’
[08:25:53.785] getGlobalsAndPackagesXApply() ... DONE
[08:25:53.785] Number of futures (= number of chunks): 2
[08:25:53.785] Launching 2 futures (chunks) ...
[08:25:53.785] Chunk #1 of 2 ...
[08:25:53.786]  - Finding globals in '...' for chunk #1 ...
[08:25:53.786] getGlobalsAndPackages() ...
[08:25:53.786] Searching for globals...
[08:25:53.786] 
[08:25:53.786] Searching for globals ... DONE
[08:25:53.786] - globals: [0] <none>
[08:25:53.786] getGlobalsAndPackages() ... DONE
[08:25:53.786]    + additional globals found: [n=0] 
[08:25:53.786]    + additional namespaces needed: [n=0] 
[08:25:53.787]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:53.787]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.787]  - seeds: [2] <seeds>
[08:25:53.787]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.787] getGlobalsAndPackages() ...
[08:25:53.787] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.787] Resolving globals: FALSE
[08:25:53.788] The total size of the 5 globals is 870 bytes (870 bytes)
[08:25:53.788] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[08:25:53.788] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.788] - packages: [1] ‘stats’
[08:25:53.788] getGlobalsAndPackages() ... DONE
[08:25:53.789] run() for ‘Future’ ...
[08:25:53.789] - state: ‘created’
[08:25:53.789] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.803] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.803]   - Field: ‘node’
[08:25:53.803]   - Field: ‘label’
[08:25:53.803]   - Field: ‘local’
[08:25:53.803]   - Field: ‘owner’
[08:25:53.803]   - Field: ‘envir’
[08:25:53.803]   - Field: ‘workers’
[08:25:53.804]   - Field: ‘packages’
[08:25:53.804]   - Field: ‘gc’
[08:25:53.804]   - Field: ‘conditions’
[08:25:53.804]   - Field: ‘persistent’
[08:25:53.804]   - Field: ‘expr’
[08:25:53.804]   - Field: ‘uuid’
[08:25:53.804]   - Field: ‘seed’
[08:25:53.804]   - Field: ‘version’
[08:25:53.804]   - Field: ‘result’
[08:25:53.804]   - Field: ‘asynchronous’
[08:25:53.804]   - Field: ‘calls’
[08:25:53.804]   - Field: ‘globals’
[08:25:53.805]   - Field: ‘stdout’
[08:25:53.805]   - Field: ‘earlySignal’
[08:25:53.805]   - Field: ‘lazy’
[08:25:53.805]   - Field: ‘state’
[08:25:53.805] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.805] - Launch lazy future ...
[08:25:53.805] Packages needed by the future expression (n = 1): ‘stats’
[08:25:53.805] Packages needed by future strategies (n = 0): <none>
[08:25:53.806] {
[08:25:53.806]     {
[08:25:53.806]         {
[08:25:53.806]             ...future.startTime <- base::Sys.time()
[08:25:53.806]             {
[08:25:53.806]                 {
[08:25:53.806]                   {
[08:25:53.806]                     {
[08:25:53.806]                       {
[08:25:53.806]                         base::local({
[08:25:53.806]                           has_future <- base::requireNamespace("future", 
[08:25:53.806]                             quietly = TRUE)
[08:25:53.806]                           if (has_future) {
[08:25:53.806]                             ns <- base::getNamespace("future")
[08:25:53.806]                             version <- ns[[".package"]][["version"]]
[08:25:53.806]                             if (is.null(version)) 
[08:25:53.806]                               version <- utils::packageVersion("future")
[08:25:53.806]                           }
[08:25:53.806]                           else {
[08:25:53.806]                             version <- NULL
[08:25:53.806]                           }
[08:25:53.806]                           if (!has_future || version < "1.8.0") {
[08:25:53.806]                             info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.806]                               "", base::R.version$version.string), 
[08:25:53.806]                               platform = base::sprintf("%s (%s-bit)", 
[08:25:53.806]                                 base::R.version$platform, 8 * 
[08:25:53.806]                                   base::.Machine$sizeof.pointer), 
[08:25:53.806]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.806]                                 "release", "version")], collapse = " "), 
[08:25:53.806]                               hostname = base::Sys.info()[["nodename"]])
[08:25:53.806]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.806]                               info)
[08:25:53.806]                             info <- base::paste(info, collapse = "; ")
[08:25:53.806]                             if (!has_future) {
[08:25:53.806]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.806]                                 info)
[08:25:53.806]                             }
[08:25:53.806]                             else {
[08:25:53.806]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.806]                                 info, version)
[08:25:53.806]                             }
[08:25:53.806]                             base::stop(msg)
[08:25:53.806]                           }
[08:25:53.806]                         })
[08:25:53.806]                       }
[08:25:53.806]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.806]                       base::options(mc.cores = 1L)
[08:25:53.806]                     }
[08:25:53.806]                     base::local({
[08:25:53.806]                       for (pkg in "stats") {
[08:25:53.806]                         base::loadNamespace(pkg)
[08:25:53.806]                         base::library(pkg, character.only = TRUE)
[08:25:53.806]                       }
[08:25:53.806]                     })
[08:25:53.806]                   }
[08:25:53.806]                   ...future.strategy.old <- future::plan("list")
[08:25:53.806]                   options(future.plan = NULL)
[08:25:53.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.806]                 }
[08:25:53.806]                 ...future.workdir <- getwd()
[08:25:53.806]             }
[08:25:53.806]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.806]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.806]         }
[08:25:53.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.806]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.806]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.806]             base::names(...future.oldOptions))
[08:25:53.806]     }
[08:25:53.806]     if (FALSE) {
[08:25:53.806]     }
[08:25:53.806]     else {
[08:25:53.806]         if (TRUE) {
[08:25:53.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.806]                 open = "w")
[08:25:53.806]         }
[08:25:53.806]         else {
[08:25:53.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.806]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.806]         }
[08:25:53.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.806]             base::sink(type = "output", split = FALSE)
[08:25:53.806]             base::close(...future.stdout)
[08:25:53.806]         }, add = TRUE)
[08:25:53.806]     }
[08:25:53.806]     ...future.frame <- base::sys.nframe()
[08:25:53.806]     ...future.conditions <- base::list()
[08:25:53.806]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.806]     if (FALSE) {
[08:25:53.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.806]     }
[08:25:53.806]     ...future.result <- base::tryCatch({
[08:25:53.806]         base::withCallingHandlers({
[08:25:53.806]             ...future.value <- base::withVisible(base::local({
[08:25:53.806]                 ...future.makeSendCondition <- base::local({
[08:25:53.806]                   sendCondition <- NULL
[08:25:53.806]                   function(frame = 1L) {
[08:25:53.806]                     if (is.function(sendCondition)) 
[08:25:53.806]                       return(sendCondition)
[08:25:53.806]                     ns <- getNamespace("parallel")
[08:25:53.806]                     if (exists("sendData", mode = "function", 
[08:25:53.806]                       envir = ns)) {
[08:25:53.806]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.806]                         envir = ns)
[08:25:53.806]                       envir <- sys.frame(frame)
[08:25:53.806]                       master <- NULL
[08:25:53.806]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.806]                         !identical(envir, emptyenv())) {
[08:25:53.806]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.806]                           inherits = FALSE)) {
[08:25:53.806]                           master <- get("master", mode = "list", 
[08:25:53.806]                             envir = envir, inherits = FALSE)
[08:25:53.806]                           if (inherits(master, c("SOCKnode", 
[08:25:53.806]                             "SOCK0node"))) {
[08:25:53.806]                             sendCondition <<- function(cond) {
[08:25:53.806]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.806]                                 success = TRUE)
[08:25:53.806]                               parallel_sendData(master, data)
[08:25:53.806]                             }
[08:25:53.806]                             return(sendCondition)
[08:25:53.806]                           }
[08:25:53.806]                         }
[08:25:53.806]                         frame <- frame + 1L
[08:25:53.806]                         envir <- sys.frame(frame)
[08:25:53.806]                       }
[08:25:53.806]                     }
[08:25:53.806]                     sendCondition <<- function(cond) NULL
[08:25:53.806]                   }
[08:25:53.806]                 })
[08:25:53.806]                 withCallingHandlers({
[08:25:53.806]                   {
[08:25:53.806]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.806]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.806]                       ...future.globals.maxSize)) {
[08:25:53.806]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.806]                       on.exit(options(oopts), add = TRUE)
[08:25:53.806]                     }
[08:25:53.806]                     {
[08:25:53.806]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:53.806]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:53.806]                           envir = globalenv(), inherits = FALSE)
[08:25:53.806]                         ...future.FUN(...)
[08:25:53.806]                       }
[08:25:53.806]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:53.806]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:53.806]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.806]                         USE.NAMES = FALSE)
[08:25:53.806]                       do.call(mapply, args = args)
[08:25:53.806]                     }
[08:25:53.806]                   }
[08:25:53.806]                 }, immediateCondition = function(cond) {
[08:25:53.806]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.806]                   sendCondition(cond)
[08:25:53.806]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.806]                   {
[08:25:53.806]                     inherits <- base::inherits
[08:25:53.806]                     invokeRestart <- base::invokeRestart
[08:25:53.806]                     is.null <- base::is.null
[08:25:53.806]                     muffled <- FALSE
[08:25:53.806]                     if (inherits(cond, "message")) {
[08:25:53.806]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.806]                       if (muffled) 
[08:25:53.806]                         invokeRestart("muffleMessage")
[08:25:53.806]                     }
[08:25:53.806]                     else if (inherits(cond, "warning")) {
[08:25:53.806]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.806]                       if (muffled) 
[08:25:53.806]                         invokeRestart("muffleWarning")
[08:25:53.806]                     }
[08:25:53.806]                     else if (inherits(cond, "condition")) {
[08:25:53.806]                       if (!is.null(pattern)) {
[08:25:53.806]                         computeRestarts <- base::computeRestarts
[08:25:53.806]                         grepl <- base::grepl
[08:25:53.806]                         restarts <- computeRestarts(cond)
[08:25:53.806]                         for (restart in restarts) {
[08:25:53.806]                           name <- restart$name
[08:25:53.806]                           if (is.null(name)) 
[08:25:53.806]                             next
[08:25:53.806]                           if (!grepl(pattern, name)) 
[08:25:53.806]                             next
[08:25:53.806]                           invokeRestart(restart)
[08:25:53.806]                           muffled <- TRUE
[08:25:53.806]                           break
[08:25:53.806]                         }
[08:25:53.806]                       }
[08:25:53.806]                     }
[08:25:53.806]                     invisible(muffled)
[08:25:53.806]                   }
[08:25:53.806]                   muffleCondition(cond)
[08:25:53.806]                 })
[08:25:53.806]             }))
[08:25:53.806]             future::FutureResult(value = ...future.value$value, 
[08:25:53.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.806]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.806]                     ...future.globalenv.names))
[08:25:53.806]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.806]         }, condition = base::local({
[08:25:53.806]             c <- base::c
[08:25:53.806]             inherits <- base::inherits
[08:25:53.806]             invokeRestart <- base::invokeRestart
[08:25:53.806]             length <- base::length
[08:25:53.806]             list <- base::list
[08:25:53.806]             seq.int <- base::seq.int
[08:25:53.806]             signalCondition <- base::signalCondition
[08:25:53.806]             sys.calls <- base::sys.calls
[08:25:53.806]             `[[` <- base::`[[`
[08:25:53.806]             `+` <- base::`+`
[08:25:53.806]             `<<-` <- base::`<<-`
[08:25:53.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.806]                   3L)]
[08:25:53.806]             }
[08:25:53.806]             function(cond) {
[08:25:53.806]                 is_error <- inherits(cond, "error")
[08:25:53.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.806]                   NULL)
[08:25:53.806]                 if (is_error) {
[08:25:53.806]                   sessionInformation <- function() {
[08:25:53.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.806]                       search = base::search(), system = base::Sys.info())
[08:25:53.806]                   }
[08:25:53.806]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.806]                     cond$call), session = sessionInformation(), 
[08:25:53.806]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.806]                   signalCondition(cond)
[08:25:53.806]                 }
[08:25:53.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.806]                 "immediateCondition"))) {
[08:25:53.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.806]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.806]                   if (TRUE && !signal) {
[08:25:53.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.806]                     {
[08:25:53.806]                       inherits <- base::inherits
[08:25:53.806]                       invokeRestart <- base::invokeRestart
[08:25:53.806]                       is.null <- base::is.null
[08:25:53.806]                       muffled <- FALSE
[08:25:53.806]                       if (inherits(cond, "message")) {
[08:25:53.806]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.806]                         if (muffled) 
[08:25:53.806]                           invokeRestart("muffleMessage")
[08:25:53.806]                       }
[08:25:53.806]                       else if (inherits(cond, "warning")) {
[08:25:53.806]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.806]                         if (muffled) 
[08:25:53.806]                           invokeRestart("muffleWarning")
[08:25:53.806]                       }
[08:25:53.806]                       else if (inherits(cond, "condition")) {
[08:25:53.806]                         if (!is.null(pattern)) {
[08:25:53.806]                           computeRestarts <- base::computeRestarts
[08:25:53.806]                           grepl <- base::grepl
[08:25:53.806]                           restarts <- computeRestarts(cond)
[08:25:53.806]                           for (restart in restarts) {
[08:25:53.806]                             name <- restart$name
[08:25:53.806]                             if (is.null(name)) 
[08:25:53.806]                               next
[08:25:53.806]                             if (!grepl(pattern, name)) 
[08:25:53.806]                               next
[08:25:53.806]                             invokeRestart(restart)
[08:25:53.806]                             muffled <- TRUE
[08:25:53.806]                             break
[08:25:53.806]                           }
[08:25:53.806]                         }
[08:25:53.806]                       }
[08:25:53.806]                       invisible(muffled)
[08:25:53.806]                     }
[08:25:53.806]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.806]                   }
[08:25:53.806]                 }
[08:25:53.806]                 else {
[08:25:53.806]                   if (TRUE) {
[08:25:53.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.806]                     {
[08:25:53.806]                       inherits <- base::inherits
[08:25:53.806]                       invokeRestart <- base::invokeRestart
[08:25:53.806]                       is.null <- base::is.null
[08:25:53.806]                       muffled <- FALSE
[08:25:53.806]                       if (inherits(cond, "message")) {
[08:25:53.806]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.806]                         if (muffled) 
[08:25:53.806]                           invokeRestart("muffleMessage")
[08:25:53.806]                       }
[08:25:53.806]                       else if (inherits(cond, "warning")) {
[08:25:53.806]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.806]                         if (muffled) 
[08:25:53.806]                           invokeRestart("muffleWarning")
[08:25:53.806]                       }
[08:25:53.806]                       else if (inherits(cond, "condition")) {
[08:25:53.806]                         if (!is.null(pattern)) {
[08:25:53.806]                           computeRestarts <- base::computeRestarts
[08:25:53.806]                           grepl <- base::grepl
[08:25:53.806]                           restarts <- computeRestarts(cond)
[08:25:53.806]                           for (restart in restarts) {
[08:25:53.806]                             name <- restart$name
[08:25:53.806]                             if (is.null(name)) 
[08:25:53.806]                               next
[08:25:53.806]                             if (!grepl(pattern, name)) 
[08:25:53.806]                               next
[08:25:53.806]                             invokeRestart(restart)
[08:25:53.806]                             muffled <- TRUE
[08:25:53.806]                             break
[08:25:53.806]                           }
[08:25:53.806]                         }
[08:25:53.806]                       }
[08:25:53.806]                       invisible(muffled)
[08:25:53.806]                     }
[08:25:53.806]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.806]                   }
[08:25:53.806]                 }
[08:25:53.806]             }
[08:25:53.806]         }))
[08:25:53.806]     }, error = function(ex) {
[08:25:53.806]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.806]                 ...future.rng), started = ...future.startTime, 
[08:25:53.806]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.806]             version = "1.8"), class = "FutureResult")
[08:25:53.806]     }, finally = {
[08:25:53.806]         if (!identical(...future.workdir, getwd())) 
[08:25:53.806]             setwd(...future.workdir)
[08:25:53.806]         {
[08:25:53.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.806]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.806]             }
[08:25:53.806]             base::options(...future.oldOptions)
[08:25:53.806]             if (.Platform$OS.type == "windows") {
[08:25:53.806]                 old_names <- names(...future.oldEnvVars)
[08:25:53.806]                 envs <- base::Sys.getenv()
[08:25:53.806]                 names <- names(envs)
[08:25:53.806]                 common <- intersect(names, old_names)
[08:25:53.806]                 added <- setdiff(names, old_names)
[08:25:53.806]                 removed <- setdiff(old_names, names)
[08:25:53.806]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.806]                   envs[common]]
[08:25:53.806]                 NAMES <- toupper(changed)
[08:25:53.806]                 args <- list()
[08:25:53.806]                 for (kk in seq_along(NAMES)) {
[08:25:53.806]                   name <- changed[[kk]]
[08:25:53.806]                   NAME <- NAMES[[kk]]
[08:25:53.806]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.806]                     next
[08:25:53.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.806]                 }
[08:25:53.806]                 NAMES <- toupper(added)
[08:25:53.806]                 for (kk in seq_along(NAMES)) {
[08:25:53.806]                   name <- added[[kk]]
[08:25:53.806]                   NAME <- NAMES[[kk]]
[08:25:53.806]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.806]                     next
[08:25:53.806]                   args[[name]] <- ""
[08:25:53.806]                 }
[08:25:53.806]                 NAMES <- toupper(removed)
[08:25:53.806]                 for (kk in seq_along(NAMES)) {
[08:25:53.806]                   name <- removed[[kk]]
[08:25:53.806]                   NAME <- NAMES[[kk]]
[08:25:53.806]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.806]                     next
[08:25:53.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.806]                 }
[08:25:53.806]                 if (length(args) > 0) 
[08:25:53.806]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.806]             }
[08:25:53.806]             else {
[08:25:53.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.806]             }
[08:25:53.806]             {
[08:25:53.806]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.806]                   0L) {
[08:25:53.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.806]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.806]                   base::options(opts)
[08:25:53.806]                 }
[08:25:53.806]                 {
[08:25:53.806]                   {
[08:25:53.806]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.806]                     NULL
[08:25:53.806]                   }
[08:25:53.806]                   options(future.plan = NULL)
[08:25:53.806]                   if (is.na(NA_character_)) 
[08:25:53.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.806]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.806]                     .init = FALSE)
[08:25:53.806]                 }
[08:25:53.806]             }
[08:25:53.806]         }
[08:25:53.806]     })
[08:25:53.806]     if (TRUE) {
[08:25:53.806]         base::sink(type = "output", split = FALSE)
[08:25:53.806]         if (TRUE) {
[08:25:53.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.806]         }
[08:25:53.806]         else {
[08:25:53.806]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.806]         }
[08:25:53.806]         base::close(...future.stdout)
[08:25:53.806]         ...future.stdout <- NULL
[08:25:53.806]     }
[08:25:53.806]     ...future.result$conditions <- ...future.conditions
[08:25:53.806]     ...future.result$finished <- base::Sys.time()
[08:25:53.806]     ...future.result
[08:25:53.806] }
[08:25:53.809] Exporting 5 global objects (1.26 KiB) to cluster node #1 ...
[08:25:53.809] Exporting ‘...future.FUN’ (501 bytes) to cluster node #1 ...
[08:25:53.810] Exporting ‘...future.FUN’ (501 bytes) to cluster node #1 ... DONE
[08:25:53.810] Exporting ‘MoreArgs’ (91 bytes) to cluster node #1 ...
[08:25:53.810] Exporting ‘MoreArgs’ (91 bytes) to cluster node #1 ... DONE
[08:25:53.810] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #1 ...
[08:25:53.811] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #1 ... DONE
[08:25:53.811] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #1 ...
[08:25:53.811] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #1 ... DONE
[08:25:53.811] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:53.812] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.812] Exporting 5 global objects (1.26 KiB) to cluster node #1 ... DONE
[08:25:53.812] MultisessionFuture started
[08:25:53.812] - Launch lazy future ... done
[08:25:53.812] run() for ‘MultisessionFuture’ ... done
[08:25:53.812] Created future:
[08:25:53.813] MultisessionFuture:
[08:25:53.813] Label: ‘future_mapply-1’
[08:25:53.813] Expression:
[08:25:53.813] {
[08:25:53.813]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.813]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.813]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.813]         on.exit(options(oopts), add = TRUE)
[08:25:53.813]     }
[08:25:53.813]     {
[08:25:53.813]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:53.813]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:53.813]                 inherits = FALSE)
[08:25:53.813]             ...future.FUN(...)
[08:25:53.813]         }
[08:25:53.813]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:53.813]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:53.813]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.813]         do.call(mapply, args = args)
[08:25:53.813]     }
[08:25:53.813] }
[08:25:53.813] Lazy evaluation: FALSE
[08:25:53.813] Asynchronous evaluation: TRUE
[08:25:53.813] Local evaluation: TRUE
[08:25:53.813] Environment: R_GlobalEnv
[08:25:53.813] Capture standard output: TRUE
[08:25:53.813] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.813] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.813] Packages: 1 packages (‘stats’)
[08:25:53.813] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:53.813] Resolved: FALSE
[08:25:53.813] Value: <not collected>
[08:25:53.813] Conditions captured: <none>
[08:25:53.813] Early signaling: FALSE
[08:25:53.813] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.813] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.824] Chunk #1 of 2 ... DONE
[08:25:53.824] Chunk #2 of 2 ...
[08:25:53.824]  - Finding globals in '...' for chunk #2 ...
[08:25:53.825] getGlobalsAndPackages() ...
[08:25:53.825] Searching for globals...
[08:25:53.825] 
[08:25:53.825] Searching for globals ... DONE
[08:25:53.825] - globals: [0] <none>
[08:25:53.825] getGlobalsAndPackages() ... DONE
[08:25:53.825]    + additional globals found: [n=0] 
[08:25:53.825]    + additional namespaces needed: [n=0] 
[08:25:53.826]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:53.826]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.826]  - seeds: [2] <seeds>
[08:25:53.826]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.826] getGlobalsAndPackages() ...
[08:25:53.826] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.826] Resolving globals: FALSE
[08:25:53.827] The total size of the 5 globals is 870 bytes (870 bytes)
[08:25:53.827] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 870 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (501 bytes of class ‘function’), ‘...future.elements_ii’ (148 bytes of class ‘list’) and ‘...future.seeds_ii’ (103 bytes of class ‘list’)
[08:25:53.827] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.827] - packages: [1] ‘stats’
[08:25:53.827] getGlobalsAndPackages() ... DONE
[08:25:53.828] run() for ‘Future’ ...
[08:25:53.828] - state: ‘created’
[08:25:53.828] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.842] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.842]   - Field: ‘node’
[08:25:53.842]   - Field: ‘label’
[08:25:53.842]   - Field: ‘local’
[08:25:53.842]   - Field: ‘owner’
[08:25:53.842]   - Field: ‘envir’
[08:25:53.842]   - Field: ‘workers’
[08:25:53.843]   - Field: ‘packages’
[08:25:53.843]   - Field: ‘gc’
[08:25:53.843]   - Field: ‘conditions’
[08:25:53.843]   - Field: ‘persistent’
[08:25:53.843]   - Field: ‘expr’
[08:25:53.843]   - Field: ‘uuid’
[08:25:53.843]   - Field: ‘seed’
[08:25:53.843]   - Field: ‘version’
[08:25:53.843]   - Field: ‘result’
[08:25:53.843]   - Field: ‘asynchronous’
[08:25:53.843]   - Field: ‘calls’
[08:25:53.843]   - Field: ‘globals’
[08:25:53.844]   - Field: ‘stdout’
[08:25:53.844]   - Field: ‘earlySignal’
[08:25:53.844]   - Field: ‘lazy’
[08:25:53.844]   - Field: ‘state’
[08:25:53.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.844] - Launch lazy future ...
[08:25:53.844] Packages needed by the future expression (n = 1): ‘stats’
[08:25:53.844] Packages needed by future strategies (n = 0): <none>
[08:25:53.845] {
[08:25:53.845]     {
[08:25:53.845]         {
[08:25:53.845]             ...future.startTime <- base::Sys.time()
[08:25:53.845]             {
[08:25:53.845]                 {
[08:25:53.845]                   {
[08:25:53.845]                     {
[08:25:53.845]                       {
[08:25:53.845]                         base::local({
[08:25:53.845]                           has_future <- base::requireNamespace("future", 
[08:25:53.845]                             quietly = TRUE)
[08:25:53.845]                           if (has_future) {
[08:25:53.845]                             ns <- base::getNamespace("future")
[08:25:53.845]                             version <- ns[[".package"]][["version"]]
[08:25:53.845]                             if (is.null(version)) 
[08:25:53.845]                               version <- utils::packageVersion("future")
[08:25:53.845]                           }
[08:25:53.845]                           else {
[08:25:53.845]                             version <- NULL
[08:25:53.845]                           }
[08:25:53.845]                           if (!has_future || version < "1.8.0") {
[08:25:53.845]                             info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.845]                               "", base::R.version$version.string), 
[08:25:53.845]                               platform = base::sprintf("%s (%s-bit)", 
[08:25:53.845]                                 base::R.version$platform, 8 * 
[08:25:53.845]                                   base::.Machine$sizeof.pointer), 
[08:25:53.845]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.845]                                 "release", "version")], collapse = " "), 
[08:25:53.845]                               hostname = base::Sys.info()[["nodename"]])
[08:25:53.845]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.845]                               info)
[08:25:53.845]                             info <- base::paste(info, collapse = "; ")
[08:25:53.845]                             if (!has_future) {
[08:25:53.845]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.845]                                 info)
[08:25:53.845]                             }
[08:25:53.845]                             else {
[08:25:53.845]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.845]                                 info, version)
[08:25:53.845]                             }
[08:25:53.845]                             base::stop(msg)
[08:25:53.845]                           }
[08:25:53.845]                         })
[08:25:53.845]                       }
[08:25:53.845]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.845]                       base::options(mc.cores = 1L)
[08:25:53.845]                     }
[08:25:53.845]                     base::local({
[08:25:53.845]                       for (pkg in "stats") {
[08:25:53.845]                         base::loadNamespace(pkg)
[08:25:53.845]                         base::library(pkg, character.only = TRUE)
[08:25:53.845]                       }
[08:25:53.845]                     })
[08:25:53.845]                   }
[08:25:53.845]                   ...future.strategy.old <- future::plan("list")
[08:25:53.845]                   options(future.plan = NULL)
[08:25:53.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.845]                 }
[08:25:53.845]                 ...future.workdir <- getwd()
[08:25:53.845]             }
[08:25:53.845]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.845]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.845]         }
[08:25:53.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.845]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.845]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.845]             base::names(...future.oldOptions))
[08:25:53.845]     }
[08:25:53.845]     if (FALSE) {
[08:25:53.845]     }
[08:25:53.845]     else {
[08:25:53.845]         if (TRUE) {
[08:25:53.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.845]                 open = "w")
[08:25:53.845]         }
[08:25:53.845]         else {
[08:25:53.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.845]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.845]         }
[08:25:53.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.845]             base::sink(type = "output", split = FALSE)
[08:25:53.845]             base::close(...future.stdout)
[08:25:53.845]         }, add = TRUE)
[08:25:53.845]     }
[08:25:53.845]     ...future.frame <- base::sys.nframe()
[08:25:53.845]     ...future.conditions <- base::list()
[08:25:53.845]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.845]     if (FALSE) {
[08:25:53.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.845]     }
[08:25:53.845]     ...future.result <- base::tryCatch({
[08:25:53.845]         base::withCallingHandlers({
[08:25:53.845]             ...future.value <- base::withVisible(base::local({
[08:25:53.845]                 ...future.makeSendCondition <- base::local({
[08:25:53.845]                   sendCondition <- NULL
[08:25:53.845]                   function(frame = 1L) {
[08:25:53.845]                     if (is.function(sendCondition)) 
[08:25:53.845]                       return(sendCondition)
[08:25:53.845]                     ns <- getNamespace("parallel")
[08:25:53.845]                     if (exists("sendData", mode = "function", 
[08:25:53.845]                       envir = ns)) {
[08:25:53.845]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.845]                         envir = ns)
[08:25:53.845]                       envir <- sys.frame(frame)
[08:25:53.845]                       master <- NULL
[08:25:53.845]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.845]                         !identical(envir, emptyenv())) {
[08:25:53.845]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.845]                           inherits = FALSE)) {
[08:25:53.845]                           master <- get("master", mode = "list", 
[08:25:53.845]                             envir = envir, inherits = FALSE)
[08:25:53.845]                           if (inherits(master, c("SOCKnode", 
[08:25:53.845]                             "SOCK0node"))) {
[08:25:53.845]                             sendCondition <<- function(cond) {
[08:25:53.845]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.845]                                 success = TRUE)
[08:25:53.845]                               parallel_sendData(master, data)
[08:25:53.845]                             }
[08:25:53.845]                             return(sendCondition)
[08:25:53.845]                           }
[08:25:53.845]                         }
[08:25:53.845]                         frame <- frame + 1L
[08:25:53.845]                         envir <- sys.frame(frame)
[08:25:53.845]                       }
[08:25:53.845]                     }
[08:25:53.845]                     sendCondition <<- function(cond) NULL
[08:25:53.845]                   }
[08:25:53.845]                 })
[08:25:53.845]                 withCallingHandlers({
[08:25:53.845]                   {
[08:25:53.845]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.845]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.845]                       ...future.globals.maxSize)) {
[08:25:53.845]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.845]                       on.exit(options(oopts), add = TRUE)
[08:25:53.845]                     }
[08:25:53.845]                     {
[08:25:53.845]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:53.845]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[08:25:53.845]                           envir = globalenv(), inherits = FALSE)
[08:25:53.845]                         ...future.FUN(...)
[08:25:53.845]                       }
[08:25:53.845]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:53.845]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:53.845]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.845]                         USE.NAMES = FALSE)
[08:25:53.845]                       do.call(mapply, args = args)
[08:25:53.845]                     }
[08:25:53.845]                   }
[08:25:53.845]                 }, immediateCondition = function(cond) {
[08:25:53.845]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.845]                   sendCondition(cond)
[08:25:53.845]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.845]                   {
[08:25:53.845]                     inherits <- base::inherits
[08:25:53.845]                     invokeRestart <- base::invokeRestart
[08:25:53.845]                     is.null <- base::is.null
[08:25:53.845]                     muffled <- FALSE
[08:25:53.845]                     if (inherits(cond, "message")) {
[08:25:53.845]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.845]                       if (muffled) 
[08:25:53.845]                         invokeRestart("muffleMessage")
[08:25:53.845]                     }
[08:25:53.845]                     else if (inherits(cond, "warning")) {
[08:25:53.845]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.845]                       if (muffled) 
[08:25:53.845]                         invokeRestart("muffleWarning")
[08:25:53.845]                     }
[08:25:53.845]                     else if (inherits(cond, "condition")) {
[08:25:53.845]                       if (!is.null(pattern)) {
[08:25:53.845]                         computeRestarts <- base::computeRestarts
[08:25:53.845]                         grepl <- base::grepl
[08:25:53.845]                         restarts <- computeRestarts(cond)
[08:25:53.845]                         for (restart in restarts) {
[08:25:53.845]                           name <- restart$name
[08:25:53.845]                           if (is.null(name)) 
[08:25:53.845]                             next
[08:25:53.845]                           if (!grepl(pattern, name)) 
[08:25:53.845]                             next
[08:25:53.845]                           invokeRestart(restart)
[08:25:53.845]                           muffled <- TRUE
[08:25:53.845]                           break
[08:25:53.845]                         }
[08:25:53.845]                       }
[08:25:53.845]                     }
[08:25:53.845]                     invisible(muffled)
[08:25:53.845]                   }
[08:25:53.845]                   muffleCondition(cond)
[08:25:53.845]                 })
[08:25:53.845]             }))
[08:25:53.845]             future::FutureResult(value = ...future.value$value, 
[08:25:53.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.845]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.845]                     ...future.globalenv.names))
[08:25:53.845]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.845]         }, condition = base::local({
[08:25:53.845]             c <- base::c
[08:25:53.845]             inherits <- base::inherits
[08:25:53.845]             invokeRestart <- base::invokeRestart
[08:25:53.845]             length <- base::length
[08:25:53.845]             list <- base::list
[08:25:53.845]             seq.int <- base::seq.int
[08:25:53.845]             signalCondition <- base::signalCondition
[08:25:53.845]             sys.calls <- base::sys.calls
[08:25:53.845]             `[[` <- base::`[[`
[08:25:53.845]             `+` <- base::`+`
[08:25:53.845]             `<<-` <- base::`<<-`
[08:25:53.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.845]                   3L)]
[08:25:53.845]             }
[08:25:53.845]             function(cond) {
[08:25:53.845]                 is_error <- inherits(cond, "error")
[08:25:53.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.845]                   NULL)
[08:25:53.845]                 if (is_error) {
[08:25:53.845]                   sessionInformation <- function() {
[08:25:53.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.845]                       search = base::search(), system = base::Sys.info())
[08:25:53.845]                   }
[08:25:53.845]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.845]                     cond$call), session = sessionInformation(), 
[08:25:53.845]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.845]                   signalCondition(cond)
[08:25:53.845]                 }
[08:25:53.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.845]                 "immediateCondition"))) {
[08:25:53.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.845]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.845]                   if (TRUE && !signal) {
[08:25:53.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.845]                     {
[08:25:53.845]                       inherits <- base::inherits
[08:25:53.845]                       invokeRestart <- base::invokeRestart
[08:25:53.845]                       is.null <- base::is.null
[08:25:53.845]                       muffled <- FALSE
[08:25:53.845]                       if (inherits(cond, "message")) {
[08:25:53.845]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.845]                         if (muffled) 
[08:25:53.845]                           invokeRestart("muffleMessage")
[08:25:53.845]                       }
[08:25:53.845]                       else if (inherits(cond, "warning")) {
[08:25:53.845]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.845]                         if (muffled) 
[08:25:53.845]                           invokeRestart("muffleWarning")
[08:25:53.845]                       }
[08:25:53.845]                       else if (inherits(cond, "condition")) {
[08:25:53.845]                         if (!is.null(pattern)) {
[08:25:53.845]                           computeRestarts <- base::computeRestarts
[08:25:53.845]                           grepl <- base::grepl
[08:25:53.845]                           restarts <- computeRestarts(cond)
[08:25:53.845]                           for (restart in restarts) {
[08:25:53.845]                             name <- restart$name
[08:25:53.845]                             if (is.null(name)) 
[08:25:53.845]                               next
[08:25:53.845]                             if (!grepl(pattern, name)) 
[08:25:53.845]                               next
[08:25:53.845]                             invokeRestart(restart)
[08:25:53.845]                             muffled <- TRUE
[08:25:53.845]                             break
[08:25:53.845]                           }
[08:25:53.845]                         }
[08:25:53.845]                       }
[08:25:53.845]                       invisible(muffled)
[08:25:53.845]                     }
[08:25:53.845]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.845]                   }
[08:25:53.845]                 }
[08:25:53.845]                 else {
[08:25:53.845]                   if (TRUE) {
[08:25:53.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.845]                     {
[08:25:53.845]                       inherits <- base::inherits
[08:25:53.845]                       invokeRestart <- base::invokeRestart
[08:25:53.845]                       is.null <- base::is.null
[08:25:53.845]                       muffled <- FALSE
[08:25:53.845]                       if (inherits(cond, "message")) {
[08:25:53.845]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.845]                         if (muffled) 
[08:25:53.845]                           invokeRestart("muffleMessage")
[08:25:53.845]                       }
[08:25:53.845]                       else if (inherits(cond, "warning")) {
[08:25:53.845]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.845]                         if (muffled) 
[08:25:53.845]                           invokeRestart("muffleWarning")
[08:25:53.845]                       }
[08:25:53.845]                       else if (inherits(cond, "condition")) {
[08:25:53.845]                         if (!is.null(pattern)) {
[08:25:53.845]                           computeRestarts <- base::computeRestarts
[08:25:53.845]                           grepl <- base::grepl
[08:25:53.845]                           restarts <- computeRestarts(cond)
[08:25:53.845]                           for (restart in restarts) {
[08:25:53.845]                             name <- restart$name
[08:25:53.845]                             if (is.null(name)) 
[08:25:53.845]                               next
[08:25:53.845]                             if (!grepl(pattern, name)) 
[08:25:53.845]                               next
[08:25:53.845]                             invokeRestart(restart)
[08:25:53.845]                             muffled <- TRUE
[08:25:53.845]                             break
[08:25:53.845]                           }
[08:25:53.845]                         }
[08:25:53.845]                       }
[08:25:53.845]                       invisible(muffled)
[08:25:53.845]                     }
[08:25:53.845]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.845]                   }
[08:25:53.845]                 }
[08:25:53.845]             }
[08:25:53.845]         }))
[08:25:53.845]     }, error = function(ex) {
[08:25:53.845]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.845]                 ...future.rng), started = ...future.startTime, 
[08:25:53.845]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.845]             version = "1.8"), class = "FutureResult")
[08:25:53.845]     }, finally = {
[08:25:53.845]         if (!identical(...future.workdir, getwd())) 
[08:25:53.845]             setwd(...future.workdir)
[08:25:53.845]         {
[08:25:53.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.845]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.845]             }
[08:25:53.845]             base::options(...future.oldOptions)
[08:25:53.845]             if (.Platform$OS.type == "windows") {
[08:25:53.845]                 old_names <- names(...future.oldEnvVars)
[08:25:53.845]                 envs <- base::Sys.getenv()
[08:25:53.845]                 names <- names(envs)
[08:25:53.845]                 common <- intersect(names, old_names)
[08:25:53.845]                 added <- setdiff(names, old_names)
[08:25:53.845]                 removed <- setdiff(old_names, names)
[08:25:53.845]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.845]                   envs[common]]
[08:25:53.845]                 NAMES <- toupper(changed)
[08:25:53.845]                 args <- list()
[08:25:53.845]                 for (kk in seq_along(NAMES)) {
[08:25:53.845]                   name <- changed[[kk]]
[08:25:53.845]                   NAME <- NAMES[[kk]]
[08:25:53.845]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.845]                     next
[08:25:53.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.845]                 }
[08:25:53.845]                 NAMES <- toupper(added)
[08:25:53.845]                 for (kk in seq_along(NAMES)) {
[08:25:53.845]                   name <- added[[kk]]
[08:25:53.845]                   NAME <- NAMES[[kk]]
[08:25:53.845]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.845]                     next
[08:25:53.845]                   args[[name]] <- ""
[08:25:53.845]                 }
[08:25:53.845]                 NAMES <- toupper(removed)
[08:25:53.845]                 for (kk in seq_along(NAMES)) {
[08:25:53.845]                   name <- removed[[kk]]
[08:25:53.845]                   NAME <- NAMES[[kk]]
[08:25:53.845]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.845]                     next
[08:25:53.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.845]                 }
[08:25:53.845]                 if (length(args) > 0) 
[08:25:53.845]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.845]             }
[08:25:53.845]             else {
[08:25:53.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.845]             }
[08:25:53.845]             {
[08:25:53.845]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.845]                   0L) {
[08:25:53.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.845]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.845]                   base::options(opts)
[08:25:53.845]                 }
[08:25:53.845]                 {
[08:25:53.845]                   {
[08:25:53.845]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.845]                     NULL
[08:25:53.845]                   }
[08:25:53.845]                   options(future.plan = NULL)
[08:25:53.845]                   if (is.na(NA_character_)) 
[08:25:53.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.845]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.845]                     .init = FALSE)
[08:25:53.845]                 }
[08:25:53.845]             }
[08:25:53.845]         }
[08:25:53.845]     })
[08:25:53.845]     if (TRUE) {
[08:25:53.845]         base::sink(type = "output", split = FALSE)
[08:25:53.845]         if (TRUE) {
[08:25:53.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.845]         }
[08:25:53.845]         else {
[08:25:53.845]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.845]         }
[08:25:53.845]         base::close(...future.stdout)
[08:25:53.845]         ...future.stdout <- NULL
[08:25:53.845]     }
[08:25:53.845]     ...future.result$conditions <- ...future.conditions
[08:25:53.845]     ...future.result$finished <- base::Sys.time()
[08:25:53.845]     ...future.result
[08:25:53.845] }
[08:25:53.848] Exporting 5 global objects (1.26 KiB) to cluster node #2 ...
[08:25:53.848] Exporting ‘...future.FUN’ (501 bytes) to cluster node #2 ...
[08:25:53.849] Exporting ‘...future.FUN’ (501 bytes) to cluster node #2 ... DONE
[08:25:53.849] Exporting ‘MoreArgs’ (91 bytes) to cluster node #2 ...
[08:25:53.849] Exporting ‘MoreArgs’ (91 bytes) to cluster node #2 ... DONE
[08:25:53.849] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #2 ...
[08:25:53.850] Exporting ‘...future.elements_ii’ (148 bytes) to cluster node #2 ... DONE
[08:25:53.850] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #2 ...
[08:25:53.850] Exporting ‘...future.seeds_ii’ (103 bytes) to cluster node #2 ... DONE
[08:25:53.850] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:53.851] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.851] Exporting 5 global objects (1.26 KiB) to cluster node #2 ... DONE
[08:25:53.851] MultisessionFuture started
[08:25:53.851] - Launch lazy future ... done
[08:25:53.851] run() for ‘MultisessionFuture’ ... done
[08:25:53.852] Created future:
[08:25:53.852] MultisessionFuture:
[08:25:53.852] Label: ‘future_mapply-2’
[08:25:53.852] Expression:
[08:25:53.852] {
[08:25:53.852]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.852]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.852]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.852]         on.exit(options(oopts), add = TRUE)
[08:25:53.852]     }
[08:25:53.852]     {
[08:25:53.852]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[08:25:53.852]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[08:25:53.852]                 inherits = FALSE)
[08:25:53.852]             ...future.FUN(...)
[08:25:53.852]         }
[08:25:53.852]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[08:25:53.852]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[08:25:53.852]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.852]         do.call(mapply, args = args)
[08:25:53.852]     }
[08:25:53.852] }
[08:25:53.852] Lazy evaluation: FALSE
[08:25:53.852] Asynchronous evaluation: TRUE
[08:25:53.852] Local evaluation: TRUE
[08:25:53.852] Environment: R_GlobalEnv
[08:25:53.852] Capture standard output: TRUE
[08:25:53.852] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.852] Globals: 5 objects totaling 870 bytes (function ‘...future.FUN’ of 501 bytes, list ‘MoreArgs’ of 91 bytes, list ‘...future.elements_ii’ of 148 bytes, list ‘...future.seeds_ii’ of 103 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.852] Packages: 1 packages (‘stats’)
[08:25:53.852] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:25:53.852] Resolved: FALSE
[08:25:53.852] Value: <not collected>
[08:25:53.852] Conditions captured: <none>
[08:25:53.852] Early signaling: FALSE
[08:25:53.852] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.852] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.863] Chunk #2 of 2 ... DONE
[08:25:53.866] Launching 2 futures (chunks) ... DONE
[08:25:53.866] Resolving 2 futures (chunks) ...
[08:25:53.866] resolve() on list ...
[08:25:53.866]  recursive: 0
[08:25:53.866]  length: 2
[08:25:53.867] 
[08:25:53.867] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.867] - Validating connection of MultisessionFuture
[08:25:53.867] - received message: FutureResult
[08:25:53.868] - Received FutureResult
[08:25:53.868] - Erased future from FutureRegistry
[08:25:53.868] result() for ClusterFuture ...
[08:25:53.868] - result already collected: FutureResult
[08:25:53.868] result() for ClusterFuture ... done
[08:25:53.868] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.868] Future #1
[08:25:53.868] result() for ClusterFuture ...
[08:25:53.868] - result already collected: FutureResult
[08:25:53.868] result() for ClusterFuture ... done
[08:25:53.868] result() for ClusterFuture ...
[08:25:53.868] - result already collected: FutureResult
[08:25:53.869] result() for ClusterFuture ... done
[08:25:53.869] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:53.869] - nx: 2
[08:25:53.869] - relay: TRUE
[08:25:53.869] - stdout: TRUE
[08:25:53.869] - signal: TRUE
[08:25:53.869] - resignal: FALSE
[08:25:53.869] - force: TRUE
[08:25:53.869] - relayed: [n=2] FALSE, FALSE
[08:25:53.869] - queued futures: [n=2] FALSE, FALSE
[08:25:53.869]  - until=1
[08:25:53.869]  - relaying element #1
[08:25:53.870] result() for ClusterFuture ...
[08:25:53.870] - result already collected: FutureResult
[08:25:53.870] result() for ClusterFuture ... done
[08:25:53.870] result() for ClusterFuture ...
[08:25:53.870] - result already collected: FutureResult
[08:25:53.870] result() for ClusterFuture ... done
[08:25:53.870] result() for ClusterFuture ...
[08:25:53.870] - result already collected: FutureResult
[08:25:53.870] result() for ClusterFuture ... done
[08:25:53.870] result() for ClusterFuture ...
[08:25:53.870] - result already collected: FutureResult
[08:25:53.870] result() for ClusterFuture ... done
[08:25:53.871] - relayed: [n=2] TRUE, FALSE
[08:25:53.871] - queued futures: [n=2] TRUE, FALSE
[08:25:53.871] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:53.871]  length: 1 (resolved future 1)
[08:25:53.893] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.894] - Validating connection of MultisessionFuture
[08:25:53.894] - received message: FutureResult
[08:25:53.894] - Received FutureResult
[08:25:53.894] - Erased future from FutureRegistry
[08:25:53.894] result() for ClusterFuture ...
[08:25:53.894] - result already collected: FutureResult
[08:25:53.894] result() for ClusterFuture ... done
[08:25:53.894] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.894] Future #2
[08:25:53.895] result() for ClusterFuture ...
[08:25:53.895] - result already collected: FutureResult
[08:25:53.895] result() for ClusterFuture ... done
[08:25:53.895] result() for ClusterFuture ...
[08:25:53.895] - result already collected: FutureResult
[08:25:53.895] result() for ClusterFuture ... done
[08:25:53.895] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:53.895] - nx: 2
[08:25:53.895] - relay: TRUE
[08:25:53.895] - stdout: TRUE
[08:25:53.895] - signal: TRUE
[08:25:53.895] - resignal: FALSE
[08:25:53.896] - force: TRUE
[08:25:53.896] - relayed: [n=2] TRUE, FALSE
[08:25:53.896] - queued futures: [n=2] TRUE, FALSE
[08:25:53.896]  - until=2
[08:25:53.896]  - relaying element #2
[08:25:53.896] result() for ClusterFuture ...
[08:25:53.896] - result already collected: FutureResult
[08:25:53.896] result() for ClusterFuture ... done
[08:25:53.896] result() for ClusterFuture ...
[08:25:53.896] - result already collected: FutureResult
[08:25:53.896] result() for ClusterFuture ... done
[08:25:53.897] result() for ClusterFuture ...
[08:25:53.897] - result already collected: FutureResult
[08:25:53.897] result() for ClusterFuture ... done
[08:25:53.897] result() for ClusterFuture ...
[08:25:53.897] - result already collected: FutureResult
[08:25:53.897] result() for ClusterFuture ... done
[08:25:53.897] - relayed: [n=2] TRUE, TRUE
[08:25:53.897] - queued futures: [n=2] TRUE, TRUE
[08:25:53.897] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:53.897]  length: 0 (resolved future 2)
[08:25:53.897] Relaying remaining futures
[08:25:53.897] signalConditionsASAP(NULL, pos=0) ...
[08:25:53.898] - nx: 2
[08:25:53.898] - relay: TRUE
[08:25:53.898] - stdout: TRUE
[08:25:53.898] - signal: TRUE
[08:25:53.898] - resignal: FALSE
[08:25:53.898] - force: TRUE
[08:25:53.898] - relayed: [n=2] TRUE, TRUE
[08:25:53.898] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:53.898] - relayed: [n=2] TRUE, TRUE
[08:25:53.898] - queued futures: [n=2] TRUE, TRUE
[08:25:53.898] signalConditionsASAP(NULL, pos=0) ... done
[08:25:53.898] resolve() on list ... DONE
[08:25:53.899] result() for ClusterFuture ...
[08:25:53.899] - result already collected: FutureResult
[08:25:53.899] result() for ClusterFuture ... done
[08:25:53.899] result() for ClusterFuture ...
[08:25:53.899] - result already collected: FutureResult
[08:25:53.899] result() for ClusterFuture ... done
[08:25:53.899] result() for ClusterFuture ...
[08:25:53.899] - result already collected: FutureResult
[08:25:53.899] result() for ClusterFuture ... done
[08:25:53.899] result() for ClusterFuture ...
[08:25:53.899] - result already collected: FutureResult
[08:25:53.899] result() for ClusterFuture ... done
[08:25:53.900]  - Number of value chunks collected: 2
[08:25:53.900] Resolving 2 futures (chunks) ... DONE
[08:25:53.900] Reducing values from 2 chunks ...
[08:25:53.900]  - Number of values collected after concatenation: 4
[08:25:53.900]  - Number of values expected: 4
[08:25:53.900] Reducing values from 2 chunks ... DONE
[08:25:53.900] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[08:25:53.901] future_mapply() ...
[08:25:53.902] Number of chunks: 2
[08:25:53.903] getGlobalsAndPackagesXApply() ...
[08:25:53.903]  - future.globals: TRUE
[08:25:53.903] getGlobalsAndPackages() ...
[08:25:53.903] Searching for globals...
[08:25:53.904] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:25:53.904] Searching for globals ... DONE
[08:25:53.904] Resolving globals: FALSE
[08:25:53.904] The total size of the 1 globals is 337 bytes (337 bytes)
[08:25:53.905] The total size of the 1 globals exported for future expression (‘FUN()’) is 337 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (337 bytes of class ‘function’)
[08:25:53.905] - globals: [1] ‘FUN’
[08:25:53.905] - packages: [1] ‘stats’
[08:25:53.905] getGlobalsAndPackages() ... DONE
[08:25:53.905]  - globals found/used: [n=1] ‘FUN’
[08:25:53.905]  - needed namespaces: [n=1] ‘stats’
[08:25:53.905] Finding globals ... DONE
[08:25:53.906] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:53.906] List of 2
[08:25:53.906]  $ ...future.FUN:function (x, w, ...)  
[08:25:53.906]  $ MoreArgs     : NULL
[08:25:53.906]  - attr(*, "where")=List of 2
[08:25:53.906]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:53.906]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:53.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:53.906]  - attr(*, "resolved")= logi FALSE
[08:25:53.906]  - attr(*, "total_size")= num NA
[08:25:53.908] Packages to be attached in all futures: [n=1] ‘stats’
[08:25:53.908] getGlobalsAndPackagesXApply() ... DONE
[08:25:53.909] Number of futures (= number of chunks): 2
[08:25:53.909] Launching 2 futures (chunks) ...
[08:25:53.909] Chunk #1 of 2 ...
[08:25:53.909]  - Finding globals in '...' for chunk #1 ...
[08:25:53.909] getGlobalsAndPackages() ...
[08:25:53.909] Searching for globals...
[08:25:53.909] 
[08:25:53.909] Searching for globals ... DONE
[08:25:53.910] - globals: [0] <none>
[08:25:53.910] getGlobalsAndPackages() ... DONE
[08:25:53.910]    + additional globals found: [n=0] 
[08:25:53.910]    + additional namespaces needed: [n=0] 
[08:25:53.910]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:53.910]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.910]  - seeds: <none>
[08:25:53.910]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.910] getGlobalsAndPackages() ...
[08:25:53.910] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.910] Resolving globals: FALSE
[08:25:53.911] The total size of the 5 globals is 817 bytes (817 bytes)
[08:25:53.911] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 817 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (399 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:53.911] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.912] - packages: [1] ‘stats’
[08:25:53.912] getGlobalsAndPackages() ... DONE
[08:25:53.912] run() for ‘Future’ ...
[08:25:53.912] - state: ‘created’
[08:25:53.912] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.927] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.927] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.927]   - Field: ‘node’
[08:25:53.928]   - Field: ‘label’
[08:25:53.928]   - Field: ‘local’
[08:25:53.928]   - Field: ‘owner’
[08:25:53.928]   - Field: ‘envir’
[08:25:53.928]   - Field: ‘workers’
[08:25:53.928]   - Field: ‘packages’
[08:25:53.928]   - Field: ‘gc’
[08:25:53.928]   - Field: ‘conditions’
[08:25:53.928]   - Field: ‘persistent’
[08:25:53.928]   - Field: ‘expr’
[08:25:53.928]   - Field: ‘uuid’
[08:25:53.929]   - Field: ‘seed’
[08:25:53.929]   - Field: ‘version’
[08:25:53.929]   - Field: ‘result’
[08:25:53.929]   - Field: ‘asynchronous’
[08:25:53.929]   - Field: ‘calls’
[08:25:53.929]   - Field: ‘globals’
[08:25:53.929]   - Field: ‘stdout’
[08:25:53.929]   - Field: ‘earlySignal’
[08:25:53.929]   - Field: ‘lazy’
[08:25:53.929]   - Field: ‘state’
[08:25:53.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.930] - Launch lazy future ...
[08:25:53.930] Packages needed by the future expression (n = 1): ‘stats’
[08:25:53.930] Packages needed by future strategies (n = 0): <none>
[08:25:53.930] {
[08:25:53.930]     {
[08:25:53.930]         {
[08:25:53.930]             ...future.startTime <- base::Sys.time()
[08:25:53.930]             {
[08:25:53.930]                 {
[08:25:53.930]                   {
[08:25:53.930]                     {
[08:25:53.930]                       {
[08:25:53.930]                         base::local({
[08:25:53.930]                           has_future <- base::requireNamespace("future", 
[08:25:53.930]                             quietly = TRUE)
[08:25:53.930]                           if (has_future) {
[08:25:53.930]                             ns <- base::getNamespace("future")
[08:25:53.930]                             version <- ns[[".package"]][["version"]]
[08:25:53.930]                             if (is.null(version)) 
[08:25:53.930]                               version <- utils::packageVersion("future")
[08:25:53.930]                           }
[08:25:53.930]                           else {
[08:25:53.930]                             version <- NULL
[08:25:53.930]                           }
[08:25:53.930]                           if (!has_future || version < "1.8.0") {
[08:25:53.930]                             info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.930]                               "", base::R.version$version.string), 
[08:25:53.930]                               platform = base::sprintf("%s (%s-bit)", 
[08:25:53.930]                                 base::R.version$platform, 8 * 
[08:25:53.930]                                   base::.Machine$sizeof.pointer), 
[08:25:53.930]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.930]                                 "release", "version")], collapse = " "), 
[08:25:53.930]                               hostname = base::Sys.info()[["nodename"]])
[08:25:53.930]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.930]                               info)
[08:25:53.930]                             info <- base::paste(info, collapse = "; ")
[08:25:53.930]                             if (!has_future) {
[08:25:53.930]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.930]                                 info)
[08:25:53.930]                             }
[08:25:53.930]                             else {
[08:25:53.930]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.930]                                 info, version)
[08:25:53.930]                             }
[08:25:53.930]                             base::stop(msg)
[08:25:53.930]                           }
[08:25:53.930]                         })
[08:25:53.930]                       }
[08:25:53.930]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.930]                       base::options(mc.cores = 1L)
[08:25:53.930]                     }
[08:25:53.930]                     base::local({
[08:25:53.930]                       for (pkg in "stats") {
[08:25:53.930]                         base::loadNamespace(pkg)
[08:25:53.930]                         base::library(pkg, character.only = TRUE)
[08:25:53.930]                       }
[08:25:53.930]                     })
[08:25:53.930]                   }
[08:25:53.930]                   ...future.strategy.old <- future::plan("list")
[08:25:53.930]                   options(future.plan = NULL)
[08:25:53.930]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.930]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.930]                 }
[08:25:53.930]                 ...future.workdir <- getwd()
[08:25:53.930]             }
[08:25:53.930]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.930]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.930]         }
[08:25:53.930]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.930]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.930]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.930]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.930]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.930]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.930]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.930]             base::names(...future.oldOptions))
[08:25:53.930]     }
[08:25:53.930]     if (FALSE) {
[08:25:53.930]     }
[08:25:53.930]     else {
[08:25:53.930]         if (TRUE) {
[08:25:53.930]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.930]                 open = "w")
[08:25:53.930]         }
[08:25:53.930]         else {
[08:25:53.930]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.930]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.930]         }
[08:25:53.930]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.930]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.930]             base::sink(type = "output", split = FALSE)
[08:25:53.930]             base::close(...future.stdout)
[08:25:53.930]         }, add = TRUE)
[08:25:53.930]     }
[08:25:53.930]     ...future.frame <- base::sys.nframe()
[08:25:53.930]     ...future.conditions <- base::list()
[08:25:53.930]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.930]     if (FALSE) {
[08:25:53.930]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.930]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.930]     }
[08:25:53.930]     ...future.result <- base::tryCatch({
[08:25:53.930]         base::withCallingHandlers({
[08:25:53.930]             ...future.value <- base::withVisible(base::local({
[08:25:53.930]                 ...future.makeSendCondition <- base::local({
[08:25:53.930]                   sendCondition <- NULL
[08:25:53.930]                   function(frame = 1L) {
[08:25:53.930]                     if (is.function(sendCondition)) 
[08:25:53.930]                       return(sendCondition)
[08:25:53.930]                     ns <- getNamespace("parallel")
[08:25:53.930]                     if (exists("sendData", mode = "function", 
[08:25:53.930]                       envir = ns)) {
[08:25:53.930]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.930]                         envir = ns)
[08:25:53.930]                       envir <- sys.frame(frame)
[08:25:53.930]                       master <- NULL
[08:25:53.930]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.930]                         !identical(envir, emptyenv())) {
[08:25:53.930]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.930]                           inherits = FALSE)) {
[08:25:53.930]                           master <- get("master", mode = "list", 
[08:25:53.930]                             envir = envir, inherits = FALSE)
[08:25:53.930]                           if (inherits(master, c("SOCKnode", 
[08:25:53.930]                             "SOCK0node"))) {
[08:25:53.930]                             sendCondition <<- function(cond) {
[08:25:53.930]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.930]                                 success = TRUE)
[08:25:53.930]                               parallel_sendData(master, data)
[08:25:53.930]                             }
[08:25:53.930]                             return(sendCondition)
[08:25:53.930]                           }
[08:25:53.930]                         }
[08:25:53.930]                         frame <- frame + 1L
[08:25:53.930]                         envir <- sys.frame(frame)
[08:25:53.930]                       }
[08:25:53.930]                     }
[08:25:53.930]                     sendCondition <<- function(cond) NULL
[08:25:53.930]                   }
[08:25:53.930]                 })
[08:25:53.930]                 withCallingHandlers({
[08:25:53.930]                   {
[08:25:53.930]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.930]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.930]                       ...future.globals.maxSize)) {
[08:25:53.930]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.930]                       on.exit(options(oopts), add = TRUE)
[08:25:53.930]                     }
[08:25:53.930]                     {
[08:25:53.930]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.930]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.930]                         USE.NAMES = FALSE)
[08:25:53.930]                       do.call(mapply, args = args)
[08:25:53.930]                     }
[08:25:53.930]                   }
[08:25:53.930]                 }, immediateCondition = function(cond) {
[08:25:53.930]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.930]                   sendCondition(cond)
[08:25:53.930]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.930]                   {
[08:25:53.930]                     inherits <- base::inherits
[08:25:53.930]                     invokeRestart <- base::invokeRestart
[08:25:53.930]                     is.null <- base::is.null
[08:25:53.930]                     muffled <- FALSE
[08:25:53.930]                     if (inherits(cond, "message")) {
[08:25:53.930]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.930]                       if (muffled) 
[08:25:53.930]                         invokeRestart("muffleMessage")
[08:25:53.930]                     }
[08:25:53.930]                     else if (inherits(cond, "warning")) {
[08:25:53.930]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.930]                       if (muffled) 
[08:25:53.930]                         invokeRestart("muffleWarning")
[08:25:53.930]                     }
[08:25:53.930]                     else if (inherits(cond, "condition")) {
[08:25:53.930]                       if (!is.null(pattern)) {
[08:25:53.930]                         computeRestarts <- base::computeRestarts
[08:25:53.930]                         grepl <- base::grepl
[08:25:53.930]                         restarts <- computeRestarts(cond)
[08:25:53.930]                         for (restart in restarts) {
[08:25:53.930]                           name <- restart$name
[08:25:53.930]                           if (is.null(name)) 
[08:25:53.930]                             next
[08:25:53.930]                           if (!grepl(pattern, name)) 
[08:25:53.930]                             next
[08:25:53.930]                           invokeRestart(restart)
[08:25:53.930]                           muffled <- TRUE
[08:25:53.930]                           break
[08:25:53.930]                         }
[08:25:53.930]                       }
[08:25:53.930]                     }
[08:25:53.930]                     invisible(muffled)
[08:25:53.930]                   }
[08:25:53.930]                   muffleCondition(cond)
[08:25:53.930]                 })
[08:25:53.930]             }))
[08:25:53.930]             future::FutureResult(value = ...future.value$value, 
[08:25:53.930]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.930]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.930]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.930]                     ...future.globalenv.names))
[08:25:53.930]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.930]         }, condition = base::local({
[08:25:53.930]             c <- base::c
[08:25:53.930]             inherits <- base::inherits
[08:25:53.930]             invokeRestart <- base::invokeRestart
[08:25:53.930]             length <- base::length
[08:25:53.930]             list <- base::list
[08:25:53.930]             seq.int <- base::seq.int
[08:25:53.930]             signalCondition <- base::signalCondition
[08:25:53.930]             sys.calls <- base::sys.calls
[08:25:53.930]             `[[` <- base::`[[`
[08:25:53.930]             `+` <- base::`+`
[08:25:53.930]             `<<-` <- base::`<<-`
[08:25:53.930]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.930]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.930]                   3L)]
[08:25:53.930]             }
[08:25:53.930]             function(cond) {
[08:25:53.930]                 is_error <- inherits(cond, "error")
[08:25:53.930]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.930]                   NULL)
[08:25:53.930]                 if (is_error) {
[08:25:53.930]                   sessionInformation <- function() {
[08:25:53.930]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.930]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.930]                       search = base::search(), system = base::Sys.info())
[08:25:53.930]                   }
[08:25:53.930]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.930]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.930]                     cond$call), session = sessionInformation(), 
[08:25:53.930]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.930]                   signalCondition(cond)
[08:25:53.930]                 }
[08:25:53.930]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.930]                 "immediateCondition"))) {
[08:25:53.930]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.930]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.930]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.930]                   if (TRUE && !signal) {
[08:25:53.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.930]                     {
[08:25:53.930]                       inherits <- base::inherits
[08:25:53.930]                       invokeRestart <- base::invokeRestart
[08:25:53.930]                       is.null <- base::is.null
[08:25:53.930]                       muffled <- FALSE
[08:25:53.930]                       if (inherits(cond, "message")) {
[08:25:53.930]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.930]                         if (muffled) 
[08:25:53.930]                           invokeRestart("muffleMessage")
[08:25:53.930]                       }
[08:25:53.930]                       else if (inherits(cond, "warning")) {
[08:25:53.930]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.930]                         if (muffled) 
[08:25:53.930]                           invokeRestart("muffleWarning")
[08:25:53.930]                       }
[08:25:53.930]                       else if (inherits(cond, "condition")) {
[08:25:53.930]                         if (!is.null(pattern)) {
[08:25:53.930]                           computeRestarts <- base::computeRestarts
[08:25:53.930]                           grepl <- base::grepl
[08:25:53.930]                           restarts <- computeRestarts(cond)
[08:25:53.930]                           for (restart in restarts) {
[08:25:53.930]                             name <- restart$name
[08:25:53.930]                             if (is.null(name)) 
[08:25:53.930]                               next
[08:25:53.930]                             if (!grepl(pattern, name)) 
[08:25:53.930]                               next
[08:25:53.930]                             invokeRestart(restart)
[08:25:53.930]                             muffled <- TRUE
[08:25:53.930]                             break
[08:25:53.930]                           }
[08:25:53.930]                         }
[08:25:53.930]                       }
[08:25:53.930]                       invisible(muffled)
[08:25:53.930]                     }
[08:25:53.930]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.930]                   }
[08:25:53.930]                 }
[08:25:53.930]                 else {
[08:25:53.930]                   if (TRUE) {
[08:25:53.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.930]                     {
[08:25:53.930]                       inherits <- base::inherits
[08:25:53.930]                       invokeRestart <- base::invokeRestart
[08:25:53.930]                       is.null <- base::is.null
[08:25:53.930]                       muffled <- FALSE
[08:25:53.930]                       if (inherits(cond, "message")) {
[08:25:53.930]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.930]                         if (muffled) 
[08:25:53.930]                           invokeRestart("muffleMessage")
[08:25:53.930]                       }
[08:25:53.930]                       else if (inherits(cond, "warning")) {
[08:25:53.930]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.930]                         if (muffled) 
[08:25:53.930]                           invokeRestart("muffleWarning")
[08:25:53.930]                       }
[08:25:53.930]                       else if (inherits(cond, "condition")) {
[08:25:53.930]                         if (!is.null(pattern)) {
[08:25:53.930]                           computeRestarts <- base::computeRestarts
[08:25:53.930]                           grepl <- base::grepl
[08:25:53.930]                           restarts <- computeRestarts(cond)
[08:25:53.930]                           for (restart in restarts) {
[08:25:53.930]                             name <- restart$name
[08:25:53.930]                             if (is.null(name)) 
[08:25:53.930]                               next
[08:25:53.930]                             if (!grepl(pattern, name)) 
[08:25:53.930]                               next
[08:25:53.930]                             invokeRestart(restart)
[08:25:53.930]                             muffled <- TRUE
[08:25:53.930]                             break
[08:25:53.930]                           }
[08:25:53.930]                         }
[08:25:53.930]                       }
[08:25:53.930]                       invisible(muffled)
[08:25:53.930]                     }
[08:25:53.930]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.930]                   }
[08:25:53.930]                 }
[08:25:53.930]             }
[08:25:53.930]         }))
[08:25:53.930]     }, error = function(ex) {
[08:25:53.930]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.930]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.930]                 ...future.rng), started = ...future.startTime, 
[08:25:53.930]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.930]             version = "1.8"), class = "FutureResult")
[08:25:53.930]     }, finally = {
[08:25:53.930]         if (!identical(...future.workdir, getwd())) 
[08:25:53.930]             setwd(...future.workdir)
[08:25:53.930]         {
[08:25:53.930]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.930]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.930]             }
[08:25:53.930]             base::options(...future.oldOptions)
[08:25:53.930]             if (.Platform$OS.type == "windows") {
[08:25:53.930]                 old_names <- names(...future.oldEnvVars)
[08:25:53.930]                 envs <- base::Sys.getenv()
[08:25:53.930]                 names <- names(envs)
[08:25:53.930]                 common <- intersect(names, old_names)
[08:25:53.930]                 added <- setdiff(names, old_names)
[08:25:53.930]                 removed <- setdiff(old_names, names)
[08:25:53.930]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.930]                   envs[common]]
[08:25:53.930]                 NAMES <- toupper(changed)
[08:25:53.930]                 args <- list()
[08:25:53.930]                 for (kk in seq_along(NAMES)) {
[08:25:53.930]                   name <- changed[[kk]]
[08:25:53.930]                   NAME <- NAMES[[kk]]
[08:25:53.930]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.930]                     next
[08:25:53.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.930]                 }
[08:25:53.930]                 NAMES <- toupper(added)
[08:25:53.930]                 for (kk in seq_along(NAMES)) {
[08:25:53.930]                   name <- added[[kk]]
[08:25:53.930]                   NAME <- NAMES[[kk]]
[08:25:53.930]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.930]                     next
[08:25:53.930]                   args[[name]] <- ""
[08:25:53.930]                 }
[08:25:53.930]                 NAMES <- toupper(removed)
[08:25:53.930]                 for (kk in seq_along(NAMES)) {
[08:25:53.930]                   name <- removed[[kk]]
[08:25:53.930]                   NAME <- NAMES[[kk]]
[08:25:53.930]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.930]                     next
[08:25:53.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.930]                 }
[08:25:53.930]                 if (length(args) > 0) 
[08:25:53.930]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.930]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.930]             }
[08:25:53.930]             else {
[08:25:53.930]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.930]             }
[08:25:53.930]             {
[08:25:53.930]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.930]                   0L) {
[08:25:53.930]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.930]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.930]                   base::options(opts)
[08:25:53.930]                 }
[08:25:53.930]                 {
[08:25:53.930]                   {
[08:25:53.930]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.930]                     NULL
[08:25:53.930]                   }
[08:25:53.930]                   options(future.plan = NULL)
[08:25:53.930]                   if (is.na(NA_character_)) 
[08:25:53.930]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.930]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.930]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.930]                     .init = FALSE)
[08:25:53.930]                 }
[08:25:53.930]             }
[08:25:53.930]         }
[08:25:53.930]     })
[08:25:53.930]     if (TRUE) {
[08:25:53.930]         base::sink(type = "output", split = FALSE)
[08:25:53.930]         if (TRUE) {
[08:25:53.930]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.930]         }
[08:25:53.930]         else {
[08:25:53.930]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.930]         }
[08:25:53.930]         base::close(...future.stdout)
[08:25:53.930]         ...future.stdout <- NULL
[08:25:53.930]     }
[08:25:53.930]     ...future.result$conditions <- ...future.conditions
[08:25:53.930]     ...future.result$finished <- base::Sys.time()
[08:25:53.930]     ...future.result
[08:25:53.930] }
[08:25:53.933] Exporting 5 global objects (1.24 KiB) to cluster node #1 ...
[08:25:53.934] Exporting ‘...future.FUN’ (337 bytes) to cluster node #1 ...
[08:25:53.934] Exporting ‘...future.FUN’ (337 bytes) to cluster node #1 ... DONE
[08:25:53.934] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:53.934] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.935] Exporting ‘...future.elements_ii’ (399 bytes) to cluster node #1 ...
[08:25:53.935] Exporting ‘...future.elements_ii’ (399 bytes) to cluster node #1 ... DONE
[08:25:53.935] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:53.935] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.936] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:53.936] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:53.936] Exporting 5 global objects (1.24 KiB) to cluster node #1 ... DONE
[08:25:53.937] MultisessionFuture started
[08:25:53.937] - Launch lazy future ... done
[08:25:53.937] run() for ‘MultisessionFuture’ ... done
[08:25:53.937] Created future:
[08:25:53.937] MultisessionFuture:
[08:25:53.937] Label: ‘future_Map-1’
[08:25:53.937] Expression:
[08:25:53.937] {
[08:25:53.937]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.937]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.937]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.937]         on.exit(options(oopts), add = TRUE)
[08:25:53.937]     }
[08:25:53.937]     {
[08:25:53.937]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.937]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.937]         do.call(mapply, args = args)
[08:25:53.937]     }
[08:25:53.937] }
[08:25:53.937] Lazy evaluation: FALSE
[08:25:53.937] Asynchronous evaluation: TRUE
[08:25:53.937] Local evaluation: TRUE
[08:25:53.937] Environment: R_GlobalEnv
[08:25:53.937] Capture standard output: TRUE
[08:25:53.937] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.937] Globals: 5 objects totaling 817 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 399 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.937] Packages: 1 packages (‘stats’)
[08:25:53.937] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.937] Resolved: FALSE
[08:25:53.937] Value: <not collected>
[08:25:53.937] Conditions captured: <none>
[08:25:53.937] Early signaling: FALSE
[08:25:53.937] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.937] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.948] Chunk #1 of 2 ... DONE
[08:25:53.948] Chunk #2 of 2 ...
[08:25:53.949]  - Finding globals in '...' for chunk #2 ...
[08:25:53.949] getGlobalsAndPackages() ...
[08:25:53.949] Searching for globals...
[08:25:53.949] 
[08:25:53.949] Searching for globals ... DONE
[08:25:53.949] - globals: [0] <none>
[08:25:53.949] getGlobalsAndPackages() ... DONE
[08:25:53.950]    + additional globals found: [n=0] 
[08:25:53.950]    + additional namespaces needed: [n=0] 
[08:25:53.950]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:53.950]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:53.950]  - seeds: <none>
[08:25:53.950]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.950] getGlobalsAndPackages() ...
[08:25:53.950] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.950] Resolving globals: FALSE
[08:25:53.951] The total size of the 5 globals is 993 bytes (993 bytes)
[08:25:53.951] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 993 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (575 bytes of class ‘list’), ‘...future.FUN’ (337 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:53.951] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:53.951] - packages: [1] ‘stats’
[08:25:53.952] getGlobalsAndPackages() ... DONE
[08:25:53.952] run() for ‘Future’ ...
[08:25:53.952] - state: ‘created’
[08:25:53.952] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:53.966] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:53.967]   - Field: ‘node’
[08:25:53.967]   - Field: ‘label’
[08:25:53.967]   - Field: ‘local’
[08:25:53.967]   - Field: ‘owner’
[08:25:53.967]   - Field: ‘envir’
[08:25:53.967]   - Field: ‘workers’
[08:25:53.967]   - Field: ‘packages’
[08:25:53.967]   - Field: ‘gc’
[08:25:53.967]   - Field: ‘conditions’
[08:25:53.967]   - Field: ‘persistent’
[08:25:53.967]   - Field: ‘expr’
[08:25:53.968]   - Field: ‘uuid’
[08:25:53.968]   - Field: ‘seed’
[08:25:53.968]   - Field: ‘version’
[08:25:53.968]   - Field: ‘result’
[08:25:53.968]   - Field: ‘asynchronous’
[08:25:53.968]   - Field: ‘calls’
[08:25:53.968]   - Field: ‘globals’
[08:25:53.968]   - Field: ‘stdout’
[08:25:53.968]   - Field: ‘earlySignal’
[08:25:53.968]   - Field: ‘lazy’
[08:25:53.968]   - Field: ‘state’
[08:25:53.969] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:53.969] - Launch lazy future ...
[08:25:53.969] Packages needed by the future expression (n = 1): ‘stats’
[08:25:53.969] Packages needed by future strategies (n = 0): <none>
[08:25:53.970] {
[08:25:53.970]     {
[08:25:53.970]         {
[08:25:53.970]             ...future.startTime <- base::Sys.time()
[08:25:53.970]             {
[08:25:53.970]                 {
[08:25:53.970]                   {
[08:25:53.970]                     {
[08:25:53.970]                       {
[08:25:53.970]                         base::local({
[08:25:53.970]                           has_future <- base::requireNamespace("future", 
[08:25:53.970]                             quietly = TRUE)
[08:25:53.970]                           if (has_future) {
[08:25:53.970]                             ns <- base::getNamespace("future")
[08:25:53.970]                             version <- ns[[".package"]][["version"]]
[08:25:53.970]                             if (is.null(version)) 
[08:25:53.970]                               version <- utils::packageVersion("future")
[08:25:53.970]                           }
[08:25:53.970]                           else {
[08:25:53.970]                             version <- NULL
[08:25:53.970]                           }
[08:25:53.970]                           if (!has_future || version < "1.8.0") {
[08:25:53.970]                             info <- base::c(r_version = base::gsub("R version ", 
[08:25:53.970]                               "", base::R.version$version.string), 
[08:25:53.970]                               platform = base::sprintf("%s (%s-bit)", 
[08:25:53.970]                                 base::R.version$platform, 8 * 
[08:25:53.970]                                   base::.Machine$sizeof.pointer), 
[08:25:53.970]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:53.970]                                 "release", "version")], collapse = " "), 
[08:25:53.970]                               hostname = base::Sys.info()[["nodename"]])
[08:25:53.970]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:25:53.970]                               info)
[08:25:53.970]                             info <- base::paste(info, collapse = "; ")
[08:25:53.970]                             if (!has_future) {
[08:25:53.970]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:53.970]                                 info)
[08:25:53.970]                             }
[08:25:53.970]                             else {
[08:25:53.970]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:53.970]                                 info, version)
[08:25:53.970]                             }
[08:25:53.970]                             base::stop(msg)
[08:25:53.970]                           }
[08:25:53.970]                         })
[08:25:53.970]                       }
[08:25:53.970]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:53.970]                       base::options(mc.cores = 1L)
[08:25:53.970]                     }
[08:25:53.970]                     base::local({
[08:25:53.970]                       for (pkg in "stats") {
[08:25:53.970]                         base::loadNamespace(pkg)
[08:25:53.970]                         base::library(pkg, character.only = TRUE)
[08:25:53.970]                       }
[08:25:53.970]                     })
[08:25:53.970]                   }
[08:25:53.970]                   ...future.strategy.old <- future::plan("list")
[08:25:53.970]                   options(future.plan = NULL)
[08:25:53.970]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.970]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:53.970]                 }
[08:25:53.970]                 ...future.workdir <- getwd()
[08:25:53.970]             }
[08:25:53.970]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:53.970]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:53.970]         }
[08:25:53.970]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:53.970]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:53.970]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:53.970]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:53.970]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:53.970]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:53.970]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:53.970]             base::names(...future.oldOptions))
[08:25:53.970]     }
[08:25:53.970]     if (FALSE) {
[08:25:53.970]     }
[08:25:53.970]     else {
[08:25:53.970]         if (TRUE) {
[08:25:53.970]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:53.970]                 open = "w")
[08:25:53.970]         }
[08:25:53.970]         else {
[08:25:53.970]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:53.970]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:53.970]         }
[08:25:53.970]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:53.970]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:53.970]             base::sink(type = "output", split = FALSE)
[08:25:53.970]             base::close(...future.stdout)
[08:25:53.970]         }, add = TRUE)
[08:25:53.970]     }
[08:25:53.970]     ...future.frame <- base::sys.nframe()
[08:25:53.970]     ...future.conditions <- base::list()
[08:25:53.970]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:53.970]     if (FALSE) {
[08:25:53.970]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:53.970]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:53.970]     }
[08:25:53.970]     ...future.result <- base::tryCatch({
[08:25:53.970]         base::withCallingHandlers({
[08:25:53.970]             ...future.value <- base::withVisible(base::local({
[08:25:53.970]                 ...future.makeSendCondition <- base::local({
[08:25:53.970]                   sendCondition <- NULL
[08:25:53.970]                   function(frame = 1L) {
[08:25:53.970]                     if (is.function(sendCondition)) 
[08:25:53.970]                       return(sendCondition)
[08:25:53.970]                     ns <- getNamespace("parallel")
[08:25:53.970]                     if (exists("sendData", mode = "function", 
[08:25:53.970]                       envir = ns)) {
[08:25:53.970]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:53.970]                         envir = ns)
[08:25:53.970]                       envir <- sys.frame(frame)
[08:25:53.970]                       master <- NULL
[08:25:53.970]                       while (!identical(envir, .GlobalEnv) && 
[08:25:53.970]                         !identical(envir, emptyenv())) {
[08:25:53.970]                         if (exists("master", mode = "list", envir = envir, 
[08:25:53.970]                           inherits = FALSE)) {
[08:25:53.970]                           master <- get("master", mode = "list", 
[08:25:53.970]                             envir = envir, inherits = FALSE)
[08:25:53.970]                           if (inherits(master, c("SOCKnode", 
[08:25:53.970]                             "SOCK0node"))) {
[08:25:53.970]                             sendCondition <<- function(cond) {
[08:25:53.970]                               data <- list(type = "VALUE", value = cond, 
[08:25:53.970]                                 success = TRUE)
[08:25:53.970]                               parallel_sendData(master, data)
[08:25:53.970]                             }
[08:25:53.970]                             return(sendCondition)
[08:25:53.970]                           }
[08:25:53.970]                         }
[08:25:53.970]                         frame <- frame + 1L
[08:25:53.970]                         envir <- sys.frame(frame)
[08:25:53.970]                       }
[08:25:53.970]                     }
[08:25:53.970]                     sendCondition <<- function(cond) NULL
[08:25:53.970]                   }
[08:25:53.970]                 })
[08:25:53.970]                 withCallingHandlers({
[08:25:53.970]                   {
[08:25:53.970]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.970]                     if (!identical(...future.globals.maxSize.org, 
[08:25:53.970]                       ...future.globals.maxSize)) {
[08:25:53.970]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.970]                       on.exit(options(oopts), add = TRUE)
[08:25:53.970]                     }
[08:25:53.970]                     {
[08:25:53.970]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.970]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:53.970]                         USE.NAMES = FALSE)
[08:25:53.970]                       do.call(mapply, args = args)
[08:25:53.970]                     }
[08:25:53.970]                   }
[08:25:53.970]                 }, immediateCondition = function(cond) {
[08:25:53.970]                   sendCondition <- ...future.makeSendCondition()
[08:25:53.970]                   sendCondition(cond)
[08:25:53.970]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.970]                   {
[08:25:53.970]                     inherits <- base::inherits
[08:25:53.970]                     invokeRestart <- base::invokeRestart
[08:25:53.970]                     is.null <- base::is.null
[08:25:53.970]                     muffled <- FALSE
[08:25:53.970]                     if (inherits(cond, "message")) {
[08:25:53.970]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:53.970]                       if (muffled) 
[08:25:53.970]                         invokeRestart("muffleMessage")
[08:25:53.970]                     }
[08:25:53.970]                     else if (inherits(cond, "warning")) {
[08:25:53.970]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:53.970]                       if (muffled) 
[08:25:53.970]                         invokeRestart("muffleWarning")
[08:25:53.970]                     }
[08:25:53.970]                     else if (inherits(cond, "condition")) {
[08:25:53.970]                       if (!is.null(pattern)) {
[08:25:53.970]                         computeRestarts <- base::computeRestarts
[08:25:53.970]                         grepl <- base::grepl
[08:25:53.970]                         restarts <- computeRestarts(cond)
[08:25:53.970]                         for (restart in restarts) {
[08:25:53.970]                           name <- restart$name
[08:25:53.970]                           if (is.null(name)) 
[08:25:53.970]                             next
[08:25:53.970]                           if (!grepl(pattern, name)) 
[08:25:53.970]                             next
[08:25:53.970]                           invokeRestart(restart)
[08:25:53.970]                           muffled <- TRUE
[08:25:53.970]                           break
[08:25:53.970]                         }
[08:25:53.970]                       }
[08:25:53.970]                     }
[08:25:53.970]                     invisible(muffled)
[08:25:53.970]                   }
[08:25:53.970]                   muffleCondition(cond)
[08:25:53.970]                 })
[08:25:53.970]             }))
[08:25:53.970]             future::FutureResult(value = ...future.value$value, 
[08:25:53.970]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.970]                   ...future.rng), globalenv = if (FALSE) 
[08:25:53.970]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:53.970]                     ...future.globalenv.names))
[08:25:53.970]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:53.970]         }, condition = base::local({
[08:25:53.970]             c <- base::c
[08:25:53.970]             inherits <- base::inherits
[08:25:53.970]             invokeRestart <- base::invokeRestart
[08:25:53.970]             length <- base::length
[08:25:53.970]             list <- base::list
[08:25:53.970]             seq.int <- base::seq.int
[08:25:53.970]             signalCondition <- base::signalCondition
[08:25:53.970]             sys.calls <- base::sys.calls
[08:25:53.970]             `[[` <- base::`[[`
[08:25:53.970]             `+` <- base::`+`
[08:25:53.970]             `<<-` <- base::`<<-`
[08:25:53.970]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:53.970]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:53.970]                   3L)]
[08:25:53.970]             }
[08:25:53.970]             function(cond) {
[08:25:53.970]                 is_error <- inherits(cond, "error")
[08:25:53.970]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:53.970]                   NULL)
[08:25:53.970]                 if (is_error) {
[08:25:53.970]                   sessionInformation <- function() {
[08:25:53.970]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:53.970]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:53.970]                       search = base::search(), system = base::Sys.info())
[08:25:53.970]                   }
[08:25:53.970]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.970]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:53.970]                     cond$call), session = sessionInformation(), 
[08:25:53.970]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:53.970]                   signalCondition(cond)
[08:25:53.970]                 }
[08:25:53.970]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:53.970]                 "immediateCondition"))) {
[08:25:53.970]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:53.970]                   ...future.conditions[[length(...future.conditions) + 
[08:25:53.970]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:53.970]                   if (TRUE && !signal) {
[08:25:53.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.970]                     {
[08:25:53.970]                       inherits <- base::inherits
[08:25:53.970]                       invokeRestart <- base::invokeRestart
[08:25:53.970]                       is.null <- base::is.null
[08:25:53.970]                       muffled <- FALSE
[08:25:53.970]                       if (inherits(cond, "message")) {
[08:25:53.970]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.970]                         if (muffled) 
[08:25:53.970]                           invokeRestart("muffleMessage")
[08:25:53.970]                       }
[08:25:53.970]                       else if (inherits(cond, "warning")) {
[08:25:53.970]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.970]                         if (muffled) 
[08:25:53.970]                           invokeRestart("muffleWarning")
[08:25:53.970]                       }
[08:25:53.970]                       else if (inherits(cond, "condition")) {
[08:25:53.970]                         if (!is.null(pattern)) {
[08:25:53.970]                           computeRestarts <- base::computeRestarts
[08:25:53.970]                           grepl <- base::grepl
[08:25:53.970]                           restarts <- computeRestarts(cond)
[08:25:53.970]                           for (restart in restarts) {
[08:25:53.970]                             name <- restart$name
[08:25:53.970]                             if (is.null(name)) 
[08:25:53.970]                               next
[08:25:53.970]                             if (!grepl(pattern, name)) 
[08:25:53.970]                               next
[08:25:53.970]                             invokeRestart(restart)
[08:25:53.970]                             muffled <- TRUE
[08:25:53.970]                             break
[08:25:53.970]                           }
[08:25:53.970]                         }
[08:25:53.970]                       }
[08:25:53.970]                       invisible(muffled)
[08:25:53.970]                     }
[08:25:53.970]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.970]                   }
[08:25:53.970]                 }
[08:25:53.970]                 else {
[08:25:53.970]                   if (TRUE) {
[08:25:53.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:53.970]                     {
[08:25:53.970]                       inherits <- base::inherits
[08:25:53.970]                       invokeRestart <- base::invokeRestart
[08:25:53.970]                       is.null <- base::is.null
[08:25:53.970]                       muffled <- FALSE
[08:25:53.970]                       if (inherits(cond, "message")) {
[08:25:53.970]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:53.970]                         if (muffled) 
[08:25:53.970]                           invokeRestart("muffleMessage")
[08:25:53.970]                       }
[08:25:53.970]                       else if (inherits(cond, "warning")) {
[08:25:53.970]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:53.970]                         if (muffled) 
[08:25:53.970]                           invokeRestart("muffleWarning")
[08:25:53.970]                       }
[08:25:53.970]                       else if (inherits(cond, "condition")) {
[08:25:53.970]                         if (!is.null(pattern)) {
[08:25:53.970]                           computeRestarts <- base::computeRestarts
[08:25:53.970]                           grepl <- base::grepl
[08:25:53.970]                           restarts <- computeRestarts(cond)
[08:25:53.970]                           for (restart in restarts) {
[08:25:53.970]                             name <- restart$name
[08:25:53.970]                             if (is.null(name)) 
[08:25:53.970]                               next
[08:25:53.970]                             if (!grepl(pattern, name)) 
[08:25:53.970]                               next
[08:25:53.970]                             invokeRestart(restart)
[08:25:53.970]                             muffled <- TRUE
[08:25:53.970]                             break
[08:25:53.970]                           }
[08:25:53.970]                         }
[08:25:53.970]                       }
[08:25:53.970]                       invisible(muffled)
[08:25:53.970]                     }
[08:25:53.970]                     muffleCondition(cond, pattern = "^muffle")
[08:25:53.970]                   }
[08:25:53.970]                 }
[08:25:53.970]             }
[08:25:53.970]         }))
[08:25:53.970]     }, error = function(ex) {
[08:25:53.970]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:53.970]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:53.970]                 ...future.rng), started = ...future.startTime, 
[08:25:53.970]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:53.970]             version = "1.8"), class = "FutureResult")
[08:25:53.970]     }, finally = {
[08:25:53.970]         if (!identical(...future.workdir, getwd())) 
[08:25:53.970]             setwd(...future.workdir)
[08:25:53.970]         {
[08:25:53.970]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:53.970]                 ...future.oldOptions$nwarnings <- NULL
[08:25:53.970]             }
[08:25:53.970]             base::options(...future.oldOptions)
[08:25:53.970]             if (.Platform$OS.type == "windows") {
[08:25:53.970]                 old_names <- names(...future.oldEnvVars)
[08:25:53.970]                 envs <- base::Sys.getenv()
[08:25:53.970]                 names <- names(envs)
[08:25:53.970]                 common <- intersect(names, old_names)
[08:25:53.970]                 added <- setdiff(names, old_names)
[08:25:53.970]                 removed <- setdiff(old_names, names)
[08:25:53.970]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:53.970]                   envs[common]]
[08:25:53.970]                 NAMES <- toupper(changed)
[08:25:53.970]                 args <- list()
[08:25:53.970]                 for (kk in seq_along(NAMES)) {
[08:25:53.970]                   name <- changed[[kk]]
[08:25:53.970]                   NAME <- NAMES[[kk]]
[08:25:53.970]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.970]                     next
[08:25:53.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.970]                 }
[08:25:53.970]                 NAMES <- toupper(added)
[08:25:53.970]                 for (kk in seq_along(NAMES)) {
[08:25:53.970]                   name <- added[[kk]]
[08:25:53.970]                   NAME <- NAMES[[kk]]
[08:25:53.970]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.970]                     next
[08:25:53.970]                   args[[name]] <- ""
[08:25:53.970]                 }
[08:25:53.970]                 NAMES <- toupper(removed)
[08:25:53.970]                 for (kk in seq_along(NAMES)) {
[08:25:53.970]                   name <- removed[[kk]]
[08:25:53.970]                   NAME <- NAMES[[kk]]
[08:25:53.970]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:53.970]                     next
[08:25:53.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:53.970]                 }
[08:25:53.970]                 if (length(args) > 0) 
[08:25:53.970]                   base::do.call(base::Sys.setenv, args = args)
[08:25:53.970]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:53.970]             }
[08:25:53.970]             else {
[08:25:53.970]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:53.970]             }
[08:25:53.970]             {
[08:25:53.970]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:53.970]                   0L) {
[08:25:53.970]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:53.970]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:53.970]                   base::options(opts)
[08:25:53.970]                 }
[08:25:53.970]                 {
[08:25:53.970]                   {
[08:25:53.970]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:53.970]                     NULL
[08:25:53.970]                   }
[08:25:53.970]                   options(future.plan = NULL)
[08:25:53.970]                   if (is.na(NA_character_)) 
[08:25:53.970]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:53.970]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:53.970]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:53.970]                     .init = FALSE)
[08:25:53.970]                 }
[08:25:53.970]             }
[08:25:53.970]         }
[08:25:53.970]     })
[08:25:53.970]     if (TRUE) {
[08:25:53.970]         base::sink(type = "output", split = FALSE)
[08:25:53.970]         if (TRUE) {
[08:25:53.970]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:53.970]         }
[08:25:53.970]         else {
[08:25:53.970]             ...future.result["stdout"] <- base::list(NULL)
[08:25:53.970]         }
[08:25:53.970]         base::close(...future.stdout)
[08:25:53.970]         ...future.stdout <- NULL
[08:25:53.970]     }
[08:25:53.970]     ...future.result$conditions <- ...future.conditions
[08:25:53.970]     ...future.result$finished <- base::Sys.time()
[08:25:53.970]     ...future.result
[08:25:53.970] }
[08:25:53.973] Exporting 5 global objects (1.41 KiB) to cluster node #2 ...
[08:25:53.973] Exporting ‘...future.FUN’ (337 bytes) to cluster node #2 ...
[08:25:53.973] Exporting ‘...future.FUN’ (337 bytes) to cluster node #2 ... DONE
[08:25:53.973] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:53.974] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.974] Exporting ‘...future.elements_ii’ (575 bytes) to cluster node #2 ...
[08:25:53.974] Exporting ‘...future.elements_ii’ (575 bytes) to cluster node #2 ... DONE
[08:25:53.974] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:53.975] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.975] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:53.975] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:53.975] Exporting 5 global objects (1.41 KiB) to cluster node #2 ... DONE
[08:25:53.976] MultisessionFuture started
[08:25:53.976] - Launch lazy future ... done
[08:25:53.976] run() for ‘MultisessionFuture’ ... done
[08:25:53.976] Created future:
[08:25:53.976] MultisessionFuture:
[08:25:53.976] Label: ‘future_Map-2’
[08:25:53.976] Expression:
[08:25:53.976] {
[08:25:53.976]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:53.976]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:53.976]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:53.976]         on.exit(options(oopts), add = TRUE)
[08:25:53.976]     }
[08:25:53.976]     {
[08:25:53.976]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:53.976]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:53.976]         do.call(mapply, args = args)
[08:25:53.976]     }
[08:25:53.976] }
[08:25:53.976] Lazy evaluation: FALSE
[08:25:53.976] Asynchronous evaluation: TRUE
[08:25:53.976] Local evaluation: TRUE
[08:25:53.976] Environment: R_GlobalEnv
[08:25:53.976] Capture standard output: TRUE
[08:25:53.976] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:53.976] Globals: 5 objects totaling 993 bytes (function ‘...future.FUN’ of 337 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 575 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:53.976] Packages: 1 packages (‘stats’)
[08:25:53.976] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:53.976] Resolved: FALSE
[08:25:53.976] Value: <not collected>
[08:25:53.976] Conditions captured: <none>
[08:25:53.976] Early signaling: FALSE
[08:25:53.976] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:53.976] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:53.988] Chunk #2 of 2 ... DONE
[08:25:53.988] Launching 2 futures (chunks) ... DONE
[08:25:53.988] Resolving 2 futures (chunks) ...
[08:25:53.988] resolve() on list ...
[08:25:53.988]  recursive: 0
[08:25:53.988]  length: 2
[08:25:53.988] 
[08:25:53.989] receiveMessageFromWorker() for ClusterFuture ...
[08:25:53.989] - Validating connection of MultisessionFuture
[08:25:53.989] - received message: FutureResult
[08:25:53.989] - Received FutureResult
[08:25:53.989] - Erased future from FutureRegistry
[08:25:53.990] result() for ClusterFuture ...
[08:25:53.990] - result already collected: FutureResult
[08:25:53.990] result() for ClusterFuture ... done
[08:25:53.990] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:53.990] Future #1
[08:25:53.990] result() for ClusterFuture ...
[08:25:53.990] - result already collected: FutureResult
[08:25:53.990] result() for ClusterFuture ... done
[08:25:53.990] result() for ClusterFuture ...
[08:25:53.990] - result already collected: FutureResult
[08:25:53.990] result() for ClusterFuture ... done
[08:25:53.990] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:53.991] - nx: 2
[08:25:53.991] - relay: TRUE
[08:25:53.991] - stdout: TRUE
[08:25:53.991] - signal: TRUE
[08:25:53.991] - resignal: FALSE
[08:25:53.991] - force: TRUE
[08:25:53.991] - relayed: [n=2] FALSE, FALSE
[08:25:53.991] - queued futures: [n=2] FALSE, FALSE
[08:25:53.991]  - until=1
[08:25:53.991]  - relaying element #1
[08:25:53.991] result() for ClusterFuture ...
[08:25:53.991] - result already collected: FutureResult
[08:25:53.992] result() for ClusterFuture ... done
[08:25:53.992] result() for ClusterFuture ...
[08:25:53.992] - result already collected: FutureResult
[08:25:53.992] result() for ClusterFuture ... done
[08:25:53.992] result() for ClusterFuture ...
[08:25:53.992] - result already collected: FutureResult
[08:25:53.992] result() for ClusterFuture ... done
[08:25:53.992] result() for ClusterFuture ...
[08:25:53.992] - result already collected: FutureResult
[08:25:53.992] result() for ClusterFuture ... done
[08:25:53.992] - relayed: [n=2] TRUE, FALSE
[08:25:53.993] - queued futures: [n=2] TRUE, FALSE
[08:25:53.993] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:53.993]  length: 1 (resolved future 1)
[08:25:54.018] receiveMessageFromWorker() for ClusterFuture ...
[08:25:54.019] - Validating connection of MultisessionFuture
[08:25:54.019] - received message: FutureResult
[08:25:54.019] - Received FutureResult
[08:25:54.019] - Erased future from FutureRegistry
[08:25:54.019] result() for ClusterFuture ...
[08:25:54.019] - result already collected: FutureResult
[08:25:54.020] result() for ClusterFuture ... done
[08:25:54.020] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:54.020] Future #2
[08:25:54.020] result() for ClusterFuture ...
[08:25:54.020] - result already collected: FutureResult
[08:25:54.020] result() for ClusterFuture ... done
[08:25:54.020] result() for ClusterFuture ...
[08:25:54.020] - result already collected: FutureResult
[08:25:54.020] result() for ClusterFuture ... done
[08:25:54.020] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:54.021] - nx: 2
[08:25:54.021] - relay: TRUE
[08:25:54.021] - stdout: TRUE
[08:25:54.021] - signal: TRUE
[08:25:54.021] - resignal: FALSE
[08:25:54.021] - force: TRUE
[08:25:54.021] - relayed: [n=2] TRUE, FALSE
[08:25:54.021] - queued futures: [n=2] TRUE, FALSE
[08:25:54.021]  - until=2
[08:25:54.021]  - relaying element #2
[08:25:54.021] result() for ClusterFuture ...
[08:25:54.021] - result already collected: FutureResult
[08:25:54.022] result() for ClusterFuture ... done
[08:25:54.022] result() for ClusterFuture ...
[08:25:54.022] - result already collected: FutureResult
[08:25:54.022] result() for ClusterFuture ... done
[08:25:54.022] result() for ClusterFuture ...
[08:25:54.022] - result already collected: FutureResult
[08:25:54.022] result() for ClusterFuture ... done
[08:25:54.022] result() for ClusterFuture ...
[08:25:54.022] - result already collected: FutureResult
[08:25:54.022] result() for ClusterFuture ... done
[08:25:54.022] - relayed: [n=2] TRUE, TRUE
[08:25:54.022] - queued futures: [n=2] TRUE, TRUE
[08:25:54.023] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:54.023]  length: 0 (resolved future 2)
[08:25:54.023] Relaying remaining futures
[08:25:54.023] signalConditionsASAP(NULL, pos=0) ...
[08:25:54.023] - nx: 2
[08:25:54.023] - relay: TRUE
[08:25:54.023] - stdout: TRUE
[08:25:54.023] - signal: TRUE
[08:25:54.023] - resignal: FALSE
[08:25:54.023] - force: TRUE
[08:25:54.023] - relayed: [n=2] TRUE, TRUE
[08:25:54.023] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:54.024] - relayed: [n=2] TRUE, TRUE
[08:25:54.024] - queued futures: [n=2] TRUE, TRUE
[08:25:54.024] signalConditionsASAP(NULL, pos=0) ... done
[08:25:54.024] resolve() on list ... DONE
[08:25:54.024] result() for ClusterFuture ...
[08:25:54.024] - result already collected: FutureResult
[08:25:54.024] result() for ClusterFuture ... done
[08:25:54.024] result() for ClusterFuture ...
[08:25:54.024] - result already collected: FutureResult
[08:25:54.024] result() for ClusterFuture ... done
[08:25:54.025] result() for ClusterFuture ...
[08:25:54.025] - result already collected: FutureResult
[08:25:54.025] result() for ClusterFuture ... done
[08:25:54.025] result() for ClusterFuture ...
[08:25:54.025] - result already collected: FutureResult
[08:25:54.025] result() for ClusterFuture ... done
[08:25:54.025]  - Number of value chunks collected: 2
[08:25:54.025] Resolving 2 futures (chunks) ... DONE
[08:25:54.025] Reducing values from 2 chunks ...
[08:25:54.025]  - Number of values collected after concatenation: 5
[08:25:54.025]  - Number of values expected: 5
[08:25:54.025] Reducing values from 2 chunks ... DONE
[08:25:54.026] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[08:25:54.027] future_mapply() ...
[08:25:54.029] Number of chunks: 2
[08:25:54.029] getGlobalsAndPackagesXApply() ...
[08:25:54.029]  - future.globals: TRUE
[08:25:54.029] getGlobalsAndPackages() ...
[08:25:54.030] Searching for globals...
[08:25:54.030] - globals found: [1] ‘FUN’
[08:25:54.030] Searching for globals ... DONE
[08:25:54.030] Resolving globals: FALSE
[08:25:54.031] The total size of the 1 globals is 32 bytes (32 bytes)
[08:25:54.031] The total size of the 1 globals exported for future expression (‘FUN()’) is 32 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (32 bytes of class ‘function’)
[08:25:54.031] - globals: [1] ‘FUN’
[08:25:54.031] 
[08:25:54.031] getGlobalsAndPackages() ... DONE
[08:25:54.031]  - globals found/used: [n=1] ‘FUN’
[08:25:54.031]  - needed namespaces: [n=0] 
[08:25:54.032] Finding globals ... DONE
[08:25:54.032] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:54.032] List of 2
[08:25:54.032]  $ ...future.FUN:function (e1, e2)  
[08:25:54.032]  $ MoreArgs     : NULL
[08:25:54.032]  - attr(*, "where")=List of 2
[08:25:54.032]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:54.032]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:54.032]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:54.032]  - attr(*, "resolved")= logi FALSE
[08:25:54.032]  - attr(*, "total_size")= num NA
[08:25:54.034] Packages to be attached in all futures: [n=0] 
[08:25:54.034] getGlobalsAndPackagesXApply() ... DONE
[08:25:54.035] Number of futures (= number of chunks): 2
[08:25:54.035] Launching 2 futures (chunks) ...
[08:25:54.035] Chunk #1 of 2 ...
[08:25:54.035]  - Finding globals in '...' for chunk #1 ...
[08:25:54.035] getGlobalsAndPackages() ...
[08:25:54.035] Searching for globals...
[08:25:54.038] 
[08:25:54.038] Searching for globals ... DONE
[08:25:54.038] - globals: [0] <none>
[08:25:54.039] getGlobalsAndPackages() ... DONE
[08:25:54.039]    + additional globals found: [n=0] 
[08:25:54.039]    + additional namespaces needed: [n=0] 
[08:25:54.039]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:54.039]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:54.039]  - seeds: <none>
[08:25:54.039]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.039] getGlobalsAndPackages() ...
[08:25:54.039] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.039] Resolving globals: FALSE
[08:25:54.040] The total size of the 5 globals is 188 bytes (188 bytes)
[08:25:54.040] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 188 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (75 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:54.040] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.041] 
[08:25:54.041] getGlobalsAndPackages() ... DONE
[08:25:54.041] run() for ‘Future’ ...
[08:25:54.041] - state: ‘created’
[08:25:54.041] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:54.055] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:54.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:54.056]   - Field: ‘node’
[08:25:54.056]   - Field: ‘label’
[08:25:54.056]   - Field: ‘local’
[08:25:54.056]   - Field: ‘owner’
[08:25:54.056]   - Field: ‘envir’
[08:25:54.056]   - Field: ‘workers’
[08:25:54.056]   - Field: ‘packages’
[08:25:54.056]   - Field: ‘gc’
[08:25:54.056]   - Field: ‘conditions’
[08:25:54.057]   - Field: ‘persistent’
[08:25:54.057]   - Field: ‘expr’
[08:25:54.057]   - Field: ‘uuid’
[08:25:54.057]   - Field: ‘seed’
[08:25:54.057]   - Field: ‘version’
[08:25:54.057]   - Field: ‘result’
[08:25:54.057]   - Field: ‘asynchronous’
[08:25:54.057]   - Field: ‘calls’
[08:25:54.057]   - Field: ‘globals’
[08:25:54.057]   - Field: ‘stdout’
[08:25:54.057]   - Field: ‘earlySignal’
[08:25:54.058]   - Field: ‘lazy’
[08:25:54.058]   - Field: ‘state’
[08:25:54.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:54.058] - Launch lazy future ...
[08:25:54.058] Packages needed by the future expression (n = 0): <none>
[08:25:54.058] Packages needed by future strategies (n = 0): <none>
[08:25:54.059] {
[08:25:54.059]     {
[08:25:54.059]         {
[08:25:54.059]             ...future.startTime <- base::Sys.time()
[08:25:54.059]             {
[08:25:54.059]                 {
[08:25:54.059]                   {
[08:25:54.059]                     {
[08:25:54.059]                       base::local({
[08:25:54.059]                         has_future <- base::requireNamespace("future", 
[08:25:54.059]                           quietly = TRUE)
[08:25:54.059]                         if (has_future) {
[08:25:54.059]                           ns <- base::getNamespace("future")
[08:25:54.059]                           version <- ns[[".package"]][["version"]]
[08:25:54.059]                           if (is.null(version)) 
[08:25:54.059]                             version <- utils::packageVersion("future")
[08:25:54.059]                         }
[08:25:54.059]                         else {
[08:25:54.059]                           version <- NULL
[08:25:54.059]                         }
[08:25:54.059]                         if (!has_future || version < "1.8.0") {
[08:25:54.059]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:54.059]                             "", base::R.version$version.string), 
[08:25:54.059]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:54.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:54.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:54.059]                               "release", "version")], collapse = " "), 
[08:25:54.059]                             hostname = base::Sys.info()[["nodename"]])
[08:25:54.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:54.059]                             info)
[08:25:54.059]                           info <- base::paste(info, collapse = "; ")
[08:25:54.059]                           if (!has_future) {
[08:25:54.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:54.059]                               info)
[08:25:54.059]                           }
[08:25:54.059]                           else {
[08:25:54.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:54.059]                               info, version)
[08:25:54.059]                           }
[08:25:54.059]                           base::stop(msg)
[08:25:54.059]                         }
[08:25:54.059]                       })
[08:25:54.059]                     }
[08:25:54.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:54.059]                     base::options(mc.cores = 1L)
[08:25:54.059]                   }
[08:25:54.059]                   ...future.strategy.old <- future::plan("list")
[08:25:54.059]                   options(future.plan = NULL)
[08:25:54.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:54.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:54.059]                 }
[08:25:54.059]                 ...future.workdir <- getwd()
[08:25:54.059]             }
[08:25:54.059]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:54.059]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:54.059]         }
[08:25:54.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:54.059]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:54.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:54.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:54.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:54.059]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:54.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:54.059]             base::names(...future.oldOptions))
[08:25:54.059]     }
[08:25:54.059]     if (FALSE) {
[08:25:54.059]     }
[08:25:54.059]     else {
[08:25:54.059]         if (TRUE) {
[08:25:54.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:54.059]                 open = "w")
[08:25:54.059]         }
[08:25:54.059]         else {
[08:25:54.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:54.059]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:54.059]         }
[08:25:54.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:54.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:54.059]             base::sink(type = "output", split = FALSE)
[08:25:54.059]             base::close(...future.stdout)
[08:25:54.059]         }, add = TRUE)
[08:25:54.059]     }
[08:25:54.059]     ...future.frame <- base::sys.nframe()
[08:25:54.059]     ...future.conditions <- base::list()
[08:25:54.059]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:54.059]     if (FALSE) {
[08:25:54.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:54.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:54.059]     }
[08:25:54.059]     ...future.result <- base::tryCatch({
[08:25:54.059]         base::withCallingHandlers({
[08:25:54.059]             ...future.value <- base::withVisible(base::local({
[08:25:54.059]                 ...future.makeSendCondition <- base::local({
[08:25:54.059]                   sendCondition <- NULL
[08:25:54.059]                   function(frame = 1L) {
[08:25:54.059]                     if (is.function(sendCondition)) 
[08:25:54.059]                       return(sendCondition)
[08:25:54.059]                     ns <- getNamespace("parallel")
[08:25:54.059]                     if (exists("sendData", mode = "function", 
[08:25:54.059]                       envir = ns)) {
[08:25:54.059]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:54.059]                         envir = ns)
[08:25:54.059]                       envir <- sys.frame(frame)
[08:25:54.059]                       master <- NULL
[08:25:54.059]                       while (!identical(envir, .GlobalEnv) && 
[08:25:54.059]                         !identical(envir, emptyenv())) {
[08:25:54.059]                         if (exists("master", mode = "list", envir = envir, 
[08:25:54.059]                           inherits = FALSE)) {
[08:25:54.059]                           master <- get("master", mode = "list", 
[08:25:54.059]                             envir = envir, inherits = FALSE)
[08:25:54.059]                           if (inherits(master, c("SOCKnode", 
[08:25:54.059]                             "SOCK0node"))) {
[08:25:54.059]                             sendCondition <<- function(cond) {
[08:25:54.059]                               data <- list(type = "VALUE", value = cond, 
[08:25:54.059]                                 success = TRUE)
[08:25:54.059]                               parallel_sendData(master, data)
[08:25:54.059]                             }
[08:25:54.059]                             return(sendCondition)
[08:25:54.059]                           }
[08:25:54.059]                         }
[08:25:54.059]                         frame <- frame + 1L
[08:25:54.059]                         envir <- sys.frame(frame)
[08:25:54.059]                       }
[08:25:54.059]                     }
[08:25:54.059]                     sendCondition <<- function(cond) NULL
[08:25:54.059]                   }
[08:25:54.059]                 })
[08:25:54.059]                 withCallingHandlers({
[08:25:54.059]                   {
[08:25:54.059]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:54.059]                     if (!identical(...future.globals.maxSize.org, 
[08:25:54.059]                       ...future.globals.maxSize)) {
[08:25:54.059]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:54.059]                       on.exit(options(oopts), add = TRUE)
[08:25:54.059]                     }
[08:25:54.059]                     {
[08:25:54.059]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:54.059]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:54.059]                         USE.NAMES = FALSE)
[08:25:54.059]                       do.call(mapply, args = args)
[08:25:54.059]                     }
[08:25:54.059]                   }
[08:25:54.059]                 }, immediateCondition = function(cond) {
[08:25:54.059]                   sendCondition <- ...future.makeSendCondition()
[08:25:54.059]                   sendCondition(cond)
[08:25:54.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.059]                   {
[08:25:54.059]                     inherits <- base::inherits
[08:25:54.059]                     invokeRestart <- base::invokeRestart
[08:25:54.059]                     is.null <- base::is.null
[08:25:54.059]                     muffled <- FALSE
[08:25:54.059]                     if (inherits(cond, "message")) {
[08:25:54.059]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:54.059]                       if (muffled) 
[08:25:54.059]                         invokeRestart("muffleMessage")
[08:25:54.059]                     }
[08:25:54.059]                     else if (inherits(cond, "warning")) {
[08:25:54.059]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:54.059]                       if (muffled) 
[08:25:54.059]                         invokeRestart("muffleWarning")
[08:25:54.059]                     }
[08:25:54.059]                     else if (inherits(cond, "condition")) {
[08:25:54.059]                       if (!is.null(pattern)) {
[08:25:54.059]                         computeRestarts <- base::computeRestarts
[08:25:54.059]                         grepl <- base::grepl
[08:25:54.059]                         restarts <- computeRestarts(cond)
[08:25:54.059]                         for (restart in restarts) {
[08:25:54.059]                           name <- restart$name
[08:25:54.059]                           if (is.null(name)) 
[08:25:54.059]                             next
[08:25:54.059]                           if (!grepl(pattern, name)) 
[08:25:54.059]                             next
[08:25:54.059]                           invokeRestart(restart)
[08:25:54.059]                           muffled <- TRUE
[08:25:54.059]                           break
[08:25:54.059]                         }
[08:25:54.059]                       }
[08:25:54.059]                     }
[08:25:54.059]                     invisible(muffled)
[08:25:54.059]                   }
[08:25:54.059]                   muffleCondition(cond)
[08:25:54.059]                 })
[08:25:54.059]             }))
[08:25:54.059]             future::FutureResult(value = ...future.value$value, 
[08:25:54.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:54.059]                   ...future.rng), globalenv = if (FALSE) 
[08:25:54.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:54.059]                     ...future.globalenv.names))
[08:25:54.059]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:54.059]         }, condition = base::local({
[08:25:54.059]             c <- base::c
[08:25:54.059]             inherits <- base::inherits
[08:25:54.059]             invokeRestart <- base::invokeRestart
[08:25:54.059]             length <- base::length
[08:25:54.059]             list <- base::list
[08:25:54.059]             seq.int <- base::seq.int
[08:25:54.059]             signalCondition <- base::signalCondition
[08:25:54.059]             sys.calls <- base::sys.calls
[08:25:54.059]             `[[` <- base::`[[`
[08:25:54.059]             `+` <- base::`+`
[08:25:54.059]             `<<-` <- base::`<<-`
[08:25:54.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:54.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:54.059]                   3L)]
[08:25:54.059]             }
[08:25:54.059]             function(cond) {
[08:25:54.059]                 is_error <- inherits(cond, "error")
[08:25:54.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:54.059]                   NULL)
[08:25:54.059]                 if (is_error) {
[08:25:54.059]                   sessionInformation <- function() {
[08:25:54.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:54.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:54.059]                       search = base::search(), system = base::Sys.info())
[08:25:54.059]                   }
[08:25:54.059]                   ...future.conditions[[length(...future.conditions) + 
[08:25:54.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:54.059]                     cond$call), session = sessionInformation(), 
[08:25:54.059]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:54.059]                   signalCondition(cond)
[08:25:54.059]                 }
[08:25:54.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:54.059]                 "immediateCondition"))) {
[08:25:54.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:54.059]                   ...future.conditions[[length(...future.conditions) + 
[08:25:54.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:54.059]                   if (TRUE && !signal) {
[08:25:54.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.059]                     {
[08:25:54.059]                       inherits <- base::inherits
[08:25:54.059]                       invokeRestart <- base::invokeRestart
[08:25:54.059]                       is.null <- base::is.null
[08:25:54.059]                       muffled <- FALSE
[08:25:54.059]                       if (inherits(cond, "message")) {
[08:25:54.059]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:54.059]                         if (muffled) 
[08:25:54.059]                           invokeRestart("muffleMessage")
[08:25:54.059]                       }
[08:25:54.059]                       else if (inherits(cond, "warning")) {
[08:25:54.059]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:54.059]                         if (muffled) 
[08:25:54.059]                           invokeRestart("muffleWarning")
[08:25:54.059]                       }
[08:25:54.059]                       else if (inherits(cond, "condition")) {
[08:25:54.059]                         if (!is.null(pattern)) {
[08:25:54.059]                           computeRestarts <- base::computeRestarts
[08:25:54.059]                           grepl <- base::grepl
[08:25:54.059]                           restarts <- computeRestarts(cond)
[08:25:54.059]                           for (restart in restarts) {
[08:25:54.059]                             name <- restart$name
[08:25:54.059]                             if (is.null(name)) 
[08:25:54.059]                               next
[08:25:54.059]                             if (!grepl(pattern, name)) 
[08:25:54.059]                               next
[08:25:54.059]                             invokeRestart(restart)
[08:25:54.059]                             muffled <- TRUE
[08:25:54.059]                             break
[08:25:54.059]                           }
[08:25:54.059]                         }
[08:25:54.059]                       }
[08:25:54.059]                       invisible(muffled)
[08:25:54.059]                     }
[08:25:54.059]                     muffleCondition(cond, pattern = "^muffle")
[08:25:54.059]                   }
[08:25:54.059]                 }
[08:25:54.059]                 else {
[08:25:54.059]                   if (TRUE) {
[08:25:54.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.059]                     {
[08:25:54.059]                       inherits <- base::inherits
[08:25:54.059]                       invokeRestart <- base::invokeRestart
[08:25:54.059]                       is.null <- base::is.null
[08:25:54.059]                       muffled <- FALSE
[08:25:54.059]                       if (inherits(cond, "message")) {
[08:25:54.059]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:54.059]                         if (muffled) 
[08:25:54.059]                           invokeRestart("muffleMessage")
[08:25:54.059]                       }
[08:25:54.059]                       else if (inherits(cond, "warning")) {
[08:25:54.059]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:54.059]                         if (muffled) 
[08:25:54.059]                           invokeRestart("muffleWarning")
[08:25:54.059]                       }
[08:25:54.059]                       else if (inherits(cond, "condition")) {
[08:25:54.059]                         if (!is.null(pattern)) {
[08:25:54.059]                           computeRestarts <- base::computeRestarts
[08:25:54.059]                           grepl <- base::grepl
[08:25:54.059]                           restarts <- computeRestarts(cond)
[08:25:54.059]                           for (restart in restarts) {
[08:25:54.059]                             name <- restart$name
[08:25:54.059]                             if (is.null(name)) 
[08:25:54.059]                               next
[08:25:54.059]                             if (!grepl(pattern, name)) 
[08:25:54.059]                               next
[08:25:54.059]                             invokeRestart(restart)
[08:25:54.059]                             muffled <- TRUE
[08:25:54.059]                             break
[08:25:54.059]                           }
[08:25:54.059]                         }
[08:25:54.059]                       }
[08:25:54.059]                       invisible(muffled)
[08:25:54.059]                     }
[08:25:54.059]                     muffleCondition(cond, pattern = "^muffle")
[08:25:54.059]                   }
[08:25:54.059]                 }
[08:25:54.059]             }
[08:25:54.059]         }))
[08:25:54.059]     }, error = function(ex) {
[08:25:54.059]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:54.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:54.059]                 ...future.rng), started = ...future.startTime, 
[08:25:54.059]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:54.059]             version = "1.8"), class = "FutureResult")
[08:25:54.059]     }, finally = {
[08:25:54.059]         if (!identical(...future.workdir, getwd())) 
[08:25:54.059]             setwd(...future.workdir)
[08:25:54.059]         {
[08:25:54.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:54.059]                 ...future.oldOptions$nwarnings <- NULL
[08:25:54.059]             }
[08:25:54.059]             base::options(...future.oldOptions)
[08:25:54.059]             if (.Platform$OS.type == "windows") {
[08:25:54.059]                 old_names <- names(...future.oldEnvVars)
[08:25:54.059]                 envs <- base::Sys.getenv()
[08:25:54.059]                 names <- names(envs)
[08:25:54.059]                 common <- intersect(names, old_names)
[08:25:54.059]                 added <- setdiff(names, old_names)
[08:25:54.059]                 removed <- setdiff(old_names, names)
[08:25:54.059]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:54.059]                   envs[common]]
[08:25:54.059]                 NAMES <- toupper(changed)
[08:25:54.059]                 args <- list()
[08:25:54.059]                 for (kk in seq_along(NAMES)) {
[08:25:54.059]                   name <- changed[[kk]]
[08:25:54.059]                   NAME <- NAMES[[kk]]
[08:25:54.059]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.059]                     next
[08:25:54.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:54.059]                 }
[08:25:54.059]                 NAMES <- toupper(added)
[08:25:54.059]                 for (kk in seq_along(NAMES)) {
[08:25:54.059]                   name <- added[[kk]]
[08:25:54.059]                   NAME <- NAMES[[kk]]
[08:25:54.059]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.059]                     next
[08:25:54.059]                   args[[name]] <- ""
[08:25:54.059]                 }
[08:25:54.059]                 NAMES <- toupper(removed)
[08:25:54.059]                 for (kk in seq_along(NAMES)) {
[08:25:54.059]                   name <- removed[[kk]]
[08:25:54.059]                   NAME <- NAMES[[kk]]
[08:25:54.059]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.059]                     next
[08:25:54.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:54.059]                 }
[08:25:54.059]                 if (length(args) > 0) 
[08:25:54.059]                   base::do.call(base::Sys.setenv, args = args)
[08:25:54.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:54.059]             }
[08:25:54.059]             else {
[08:25:54.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:54.059]             }
[08:25:54.059]             {
[08:25:54.059]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:54.059]                   0L) {
[08:25:54.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:54.059]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:54.059]                   base::options(opts)
[08:25:54.059]                 }
[08:25:54.059]                 {
[08:25:54.059]                   {
[08:25:54.059]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:54.059]                     NULL
[08:25:54.059]                   }
[08:25:54.059]                   options(future.plan = NULL)
[08:25:54.059]                   if (is.na(NA_character_)) 
[08:25:54.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:54.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:54.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:54.059]                     .init = FALSE)
[08:25:54.059]                 }
[08:25:54.059]             }
[08:25:54.059]         }
[08:25:54.059]     })
[08:25:54.059]     if (TRUE) {
[08:25:54.059]         base::sink(type = "output", split = FALSE)
[08:25:54.059]         if (TRUE) {
[08:25:54.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:54.059]         }
[08:25:54.059]         else {
[08:25:54.059]             ...future.result["stdout"] <- base::list(NULL)
[08:25:54.059]         }
[08:25:54.059]         base::close(...future.stdout)
[08:25:54.059]         ...future.stdout <- NULL
[08:25:54.059]     }
[08:25:54.059]     ...future.result$conditions <- ...future.conditions
[08:25:54.059]     ...future.result$finished <- base::Sys.time()
[08:25:54.059]     ...future.result
[08:25:54.059] }
[08:25:54.062] Exporting 5 global objects (651 bytes) to cluster node #1 ...
[08:25:54.062] Exporting ‘...future.FUN’ (32 bytes) to cluster node #1 ...
[08:25:54.062] Exporting ‘...future.FUN’ (32 bytes) to cluster node #1 ... DONE
[08:25:54.062] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:54.063] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:54.063] Exporting ‘...future.elements_ii’ (75 bytes) to cluster node #1 ...
[08:25:54.063] Exporting ‘...future.elements_ii’ (75 bytes) to cluster node #1 ... DONE
[08:25:54.063] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:54.064] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:54.064] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:54.064] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:54.064] Exporting 5 global objects (651 bytes) to cluster node #1 ... DONE
[08:25:54.065] MultisessionFuture started
[08:25:54.065] - Launch lazy future ... done
[08:25:54.065] run() for ‘MultisessionFuture’ ... done
[08:25:54.065] Created future:
[08:25:54.065] MultisessionFuture:
[08:25:54.065] Label: ‘future_Map-1’
[08:25:54.065] Expression:
[08:25:54.065] {
[08:25:54.065]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:54.065]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:54.065]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:54.065]         on.exit(options(oopts), add = TRUE)
[08:25:54.065]     }
[08:25:54.065]     {
[08:25:54.065]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:54.065]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:54.065]         do.call(mapply, args = args)
[08:25:54.065]     }
[08:25:54.065] }
[08:25:54.065] Lazy evaluation: FALSE
[08:25:54.065] Asynchronous evaluation: TRUE
[08:25:54.065] Local evaluation: TRUE
[08:25:54.065] Environment: R_GlobalEnv
[08:25:54.065] Capture standard output: TRUE
[08:25:54.065] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:54.065] Globals: 5 objects totaling 188 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 75 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:54.065] Packages: <none>
[08:25:54.065] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:54.065] Resolved: FALSE
[08:25:54.065] Value: <not collected>
[08:25:54.065] Conditions captured: <none>
[08:25:54.065] Early signaling: FALSE
[08:25:54.065] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:54.065] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:54.077] Chunk #1 of 2 ... DONE
[08:25:54.077] Chunk #2 of 2 ...
[08:25:54.077]  - Finding globals in '...' for chunk #2 ...
[08:25:54.077] getGlobalsAndPackages() ...
[08:25:54.077] Searching for globals...
[08:25:54.078] 
[08:25:54.078] Searching for globals ... DONE
[08:25:54.078] - globals: [0] <none>
[08:25:54.078] getGlobalsAndPackages() ... DONE
[08:25:54.078]    + additional globals found: [n=0] 
[08:25:54.078]    + additional namespaces needed: [n=0] 
[08:25:54.078]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:54.078]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:54.078]  - seeds: <none>
[08:25:54.078]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.079] getGlobalsAndPackages() ...
[08:25:54.079] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.079] Resolving globals: FALSE
[08:25:54.079] The total size of the 5 globals is 216 bytes (216 bytes)
[08:25:54.080] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 216 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (103 bytes of class ‘list’), ‘...future.FUN’ (32 bytes of class ‘function’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:54.080] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.080] 
[08:25:54.080] getGlobalsAndPackages() ... DONE
[08:25:54.080] run() for ‘Future’ ...
[08:25:54.080] - state: ‘created’
[08:25:54.081] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:54.095] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:54.095] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:54.095]   - Field: ‘node’
[08:25:54.095]   - Field: ‘label’
[08:25:54.095]   - Field: ‘local’
[08:25:54.095]   - Field: ‘owner’
[08:25:54.095]   - Field: ‘envir’
[08:25:54.096]   - Field: ‘workers’
[08:25:54.096]   - Field: ‘packages’
[08:25:54.096]   - Field: ‘gc’
[08:25:54.096]   - Field: ‘conditions’
[08:25:54.096]   - Field: ‘persistent’
[08:25:54.096]   - Field: ‘expr’
[08:25:54.096]   - Field: ‘uuid’
[08:25:54.096]   - Field: ‘seed’
[08:25:54.096]   - Field: ‘version’
[08:25:54.096]   - Field: ‘result’
[08:25:54.096]   - Field: ‘asynchronous’
[08:25:54.097]   - Field: ‘calls’
[08:25:54.097]   - Field: ‘globals’
[08:25:54.097]   - Field: ‘stdout’
[08:25:54.097]   - Field: ‘earlySignal’
[08:25:54.097]   - Field: ‘lazy’
[08:25:54.097]   - Field: ‘state’
[08:25:54.097] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:54.097] - Launch lazy future ...
[08:25:54.097] Packages needed by the future expression (n = 0): <none>
[08:25:54.098] Packages needed by future strategies (n = 0): <none>
[08:25:54.098] {
[08:25:54.098]     {
[08:25:54.098]         {
[08:25:54.098]             ...future.startTime <- base::Sys.time()
[08:25:54.098]             {
[08:25:54.098]                 {
[08:25:54.098]                   {
[08:25:54.098]                     {
[08:25:54.098]                       base::local({
[08:25:54.098]                         has_future <- base::requireNamespace("future", 
[08:25:54.098]                           quietly = TRUE)
[08:25:54.098]                         if (has_future) {
[08:25:54.098]                           ns <- base::getNamespace("future")
[08:25:54.098]                           version <- ns[[".package"]][["version"]]
[08:25:54.098]                           if (is.null(version)) 
[08:25:54.098]                             version <- utils::packageVersion("future")
[08:25:54.098]                         }
[08:25:54.098]                         else {
[08:25:54.098]                           version <- NULL
[08:25:54.098]                         }
[08:25:54.098]                         if (!has_future || version < "1.8.0") {
[08:25:54.098]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:54.098]                             "", base::R.version$version.string), 
[08:25:54.098]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:54.098]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:54.098]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:54.098]                               "release", "version")], collapse = " "), 
[08:25:54.098]                             hostname = base::Sys.info()[["nodename"]])
[08:25:54.098]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:54.098]                             info)
[08:25:54.098]                           info <- base::paste(info, collapse = "; ")
[08:25:54.098]                           if (!has_future) {
[08:25:54.098]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:54.098]                               info)
[08:25:54.098]                           }
[08:25:54.098]                           else {
[08:25:54.098]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:54.098]                               info, version)
[08:25:54.098]                           }
[08:25:54.098]                           base::stop(msg)
[08:25:54.098]                         }
[08:25:54.098]                       })
[08:25:54.098]                     }
[08:25:54.098]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:54.098]                     base::options(mc.cores = 1L)
[08:25:54.098]                   }
[08:25:54.098]                   ...future.strategy.old <- future::plan("list")
[08:25:54.098]                   options(future.plan = NULL)
[08:25:54.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:54.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:54.098]                 }
[08:25:54.098]                 ...future.workdir <- getwd()
[08:25:54.098]             }
[08:25:54.098]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:54.098]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:54.098]         }
[08:25:54.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:54.098]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:54.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:54.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:54.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:54.098]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:54.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:54.098]             base::names(...future.oldOptions))
[08:25:54.098]     }
[08:25:54.098]     if (FALSE) {
[08:25:54.098]     }
[08:25:54.098]     else {
[08:25:54.098]         if (TRUE) {
[08:25:54.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:54.098]                 open = "w")
[08:25:54.098]         }
[08:25:54.098]         else {
[08:25:54.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:54.098]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:54.098]         }
[08:25:54.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:54.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:54.098]             base::sink(type = "output", split = FALSE)
[08:25:54.098]             base::close(...future.stdout)
[08:25:54.098]         }, add = TRUE)
[08:25:54.098]     }
[08:25:54.098]     ...future.frame <- base::sys.nframe()
[08:25:54.098]     ...future.conditions <- base::list()
[08:25:54.098]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:54.098]     if (FALSE) {
[08:25:54.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:54.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:54.098]     }
[08:25:54.098]     ...future.result <- base::tryCatch({
[08:25:54.098]         base::withCallingHandlers({
[08:25:54.098]             ...future.value <- base::withVisible(base::local({
[08:25:54.098]                 ...future.makeSendCondition <- base::local({
[08:25:54.098]                   sendCondition <- NULL
[08:25:54.098]                   function(frame = 1L) {
[08:25:54.098]                     if (is.function(sendCondition)) 
[08:25:54.098]                       return(sendCondition)
[08:25:54.098]                     ns <- getNamespace("parallel")
[08:25:54.098]                     if (exists("sendData", mode = "function", 
[08:25:54.098]                       envir = ns)) {
[08:25:54.098]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:54.098]                         envir = ns)
[08:25:54.098]                       envir <- sys.frame(frame)
[08:25:54.098]                       master <- NULL
[08:25:54.098]                       while (!identical(envir, .GlobalEnv) && 
[08:25:54.098]                         !identical(envir, emptyenv())) {
[08:25:54.098]                         if (exists("master", mode = "list", envir = envir, 
[08:25:54.098]                           inherits = FALSE)) {
[08:25:54.098]                           master <- get("master", mode = "list", 
[08:25:54.098]                             envir = envir, inherits = FALSE)
[08:25:54.098]                           if (inherits(master, c("SOCKnode", 
[08:25:54.098]                             "SOCK0node"))) {
[08:25:54.098]                             sendCondition <<- function(cond) {
[08:25:54.098]                               data <- list(type = "VALUE", value = cond, 
[08:25:54.098]                                 success = TRUE)
[08:25:54.098]                               parallel_sendData(master, data)
[08:25:54.098]                             }
[08:25:54.098]                             return(sendCondition)
[08:25:54.098]                           }
[08:25:54.098]                         }
[08:25:54.098]                         frame <- frame + 1L
[08:25:54.098]                         envir <- sys.frame(frame)
[08:25:54.098]                       }
[08:25:54.098]                     }
[08:25:54.098]                     sendCondition <<- function(cond) NULL
[08:25:54.098]                   }
[08:25:54.098]                 })
[08:25:54.098]                 withCallingHandlers({
[08:25:54.098]                   {
[08:25:54.098]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:54.098]                     if (!identical(...future.globals.maxSize.org, 
[08:25:54.098]                       ...future.globals.maxSize)) {
[08:25:54.098]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:54.098]                       on.exit(options(oopts), add = TRUE)
[08:25:54.098]                     }
[08:25:54.098]                     {
[08:25:54.098]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:54.098]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:54.098]                         USE.NAMES = FALSE)
[08:25:54.098]                       do.call(mapply, args = args)
[08:25:54.098]                     }
[08:25:54.098]                   }
[08:25:54.098]                 }, immediateCondition = function(cond) {
[08:25:54.098]                   sendCondition <- ...future.makeSendCondition()
[08:25:54.098]                   sendCondition(cond)
[08:25:54.098]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.098]                   {
[08:25:54.098]                     inherits <- base::inherits
[08:25:54.098]                     invokeRestart <- base::invokeRestart
[08:25:54.098]                     is.null <- base::is.null
[08:25:54.098]                     muffled <- FALSE
[08:25:54.098]                     if (inherits(cond, "message")) {
[08:25:54.098]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:54.098]                       if (muffled) 
[08:25:54.098]                         invokeRestart("muffleMessage")
[08:25:54.098]                     }
[08:25:54.098]                     else if (inherits(cond, "warning")) {
[08:25:54.098]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:54.098]                       if (muffled) 
[08:25:54.098]                         invokeRestart("muffleWarning")
[08:25:54.098]                     }
[08:25:54.098]                     else if (inherits(cond, "condition")) {
[08:25:54.098]                       if (!is.null(pattern)) {
[08:25:54.098]                         computeRestarts <- base::computeRestarts
[08:25:54.098]                         grepl <- base::grepl
[08:25:54.098]                         restarts <- computeRestarts(cond)
[08:25:54.098]                         for (restart in restarts) {
[08:25:54.098]                           name <- restart$name
[08:25:54.098]                           if (is.null(name)) 
[08:25:54.098]                             next
[08:25:54.098]                           if (!grepl(pattern, name)) 
[08:25:54.098]                             next
[08:25:54.098]                           invokeRestart(restart)
[08:25:54.098]                           muffled <- TRUE
[08:25:54.098]                           break
[08:25:54.098]                         }
[08:25:54.098]                       }
[08:25:54.098]                     }
[08:25:54.098]                     invisible(muffled)
[08:25:54.098]                   }
[08:25:54.098]                   muffleCondition(cond)
[08:25:54.098]                 })
[08:25:54.098]             }))
[08:25:54.098]             future::FutureResult(value = ...future.value$value, 
[08:25:54.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:54.098]                   ...future.rng), globalenv = if (FALSE) 
[08:25:54.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:54.098]                     ...future.globalenv.names))
[08:25:54.098]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:54.098]         }, condition = base::local({
[08:25:54.098]             c <- base::c
[08:25:54.098]             inherits <- base::inherits
[08:25:54.098]             invokeRestart <- base::invokeRestart
[08:25:54.098]             length <- base::length
[08:25:54.098]             list <- base::list
[08:25:54.098]             seq.int <- base::seq.int
[08:25:54.098]             signalCondition <- base::signalCondition
[08:25:54.098]             sys.calls <- base::sys.calls
[08:25:54.098]             `[[` <- base::`[[`
[08:25:54.098]             `+` <- base::`+`
[08:25:54.098]             `<<-` <- base::`<<-`
[08:25:54.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:54.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:54.098]                   3L)]
[08:25:54.098]             }
[08:25:54.098]             function(cond) {
[08:25:54.098]                 is_error <- inherits(cond, "error")
[08:25:54.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:54.098]                   NULL)
[08:25:54.098]                 if (is_error) {
[08:25:54.098]                   sessionInformation <- function() {
[08:25:54.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:54.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:54.098]                       search = base::search(), system = base::Sys.info())
[08:25:54.098]                   }
[08:25:54.098]                   ...future.conditions[[length(...future.conditions) + 
[08:25:54.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:54.098]                     cond$call), session = sessionInformation(), 
[08:25:54.098]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:54.098]                   signalCondition(cond)
[08:25:54.098]                 }
[08:25:54.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:54.098]                 "immediateCondition"))) {
[08:25:54.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:54.098]                   ...future.conditions[[length(...future.conditions) + 
[08:25:54.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:54.098]                   if (TRUE && !signal) {
[08:25:54.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.098]                     {
[08:25:54.098]                       inherits <- base::inherits
[08:25:54.098]                       invokeRestart <- base::invokeRestart
[08:25:54.098]                       is.null <- base::is.null
[08:25:54.098]                       muffled <- FALSE
[08:25:54.098]                       if (inherits(cond, "message")) {
[08:25:54.098]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:54.098]                         if (muffled) 
[08:25:54.098]                           invokeRestart("muffleMessage")
[08:25:54.098]                       }
[08:25:54.098]                       else if (inherits(cond, "warning")) {
[08:25:54.098]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:54.098]                         if (muffled) 
[08:25:54.098]                           invokeRestart("muffleWarning")
[08:25:54.098]                       }
[08:25:54.098]                       else if (inherits(cond, "condition")) {
[08:25:54.098]                         if (!is.null(pattern)) {
[08:25:54.098]                           computeRestarts <- base::computeRestarts
[08:25:54.098]                           grepl <- base::grepl
[08:25:54.098]                           restarts <- computeRestarts(cond)
[08:25:54.098]                           for (restart in restarts) {
[08:25:54.098]                             name <- restart$name
[08:25:54.098]                             if (is.null(name)) 
[08:25:54.098]                               next
[08:25:54.098]                             if (!grepl(pattern, name)) 
[08:25:54.098]                               next
[08:25:54.098]                             invokeRestart(restart)
[08:25:54.098]                             muffled <- TRUE
[08:25:54.098]                             break
[08:25:54.098]                           }
[08:25:54.098]                         }
[08:25:54.098]                       }
[08:25:54.098]                       invisible(muffled)
[08:25:54.098]                     }
[08:25:54.098]                     muffleCondition(cond, pattern = "^muffle")
[08:25:54.098]                   }
[08:25:54.098]                 }
[08:25:54.098]                 else {
[08:25:54.098]                   if (TRUE) {
[08:25:54.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.098]                     {
[08:25:54.098]                       inherits <- base::inherits
[08:25:54.098]                       invokeRestart <- base::invokeRestart
[08:25:54.098]                       is.null <- base::is.null
[08:25:54.098]                       muffled <- FALSE
[08:25:54.098]                       if (inherits(cond, "message")) {
[08:25:54.098]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:54.098]                         if (muffled) 
[08:25:54.098]                           invokeRestart("muffleMessage")
[08:25:54.098]                       }
[08:25:54.098]                       else if (inherits(cond, "warning")) {
[08:25:54.098]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:54.098]                         if (muffled) 
[08:25:54.098]                           invokeRestart("muffleWarning")
[08:25:54.098]                       }
[08:25:54.098]                       else if (inherits(cond, "condition")) {
[08:25:54.098]                         if (!is.null(pattern)) {
[08:25:54.098]                           computeRestarts <- base::computeRestarts
[08:25:54.098]                           grepl <- base::grepl
[08:25:54.098]                           restarts <- computeRestarts(cond)
[08:25:54.098]                           for (restart in restarts) {
[08:25:54.098]                             name <- restart$name
[08:25:54.098]                             if (is.null(name)) 
[08:25:54.098]                               next
[08:25:54.098]                             if (!grepl(pattern, name)) 
[08:25:54.098]                               next
[08:25:54.098]                             invokeRestart(restart)
[08:25:54.098]                             muffled <- TRUE
[08:25:54.098]                             break
[08:25:54.098]                           }
[08:25:54.098]                         }
[08:25:54.098]                       }
[08:25:54.098]                       invisible(muffled)
[08:25:54.098]                     }
[08:25:54.098]                     muffleCondition(cond, pattern = "^muffle")
[08:25:54.098]                   }
[08:25:54.098]                 }
[08:25:54.098]             }
[08:25:54.098]         }))
[08:25:54.098]     }, error = function(ex) {
[08:25:54.098]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:54.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:54.098]                 ...future.rng), started = ...future.startTime, 
[08:25:54.098]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:54.098]             version = "1.8"), class = "FutureResult")
[08:25:54.098]     }, finally = {
[08:25:54.098]         if (!identical(...future.workdir, getwd())) 
[08:25:54.098]             setwd(...future.workdir)
[08:25:54.098]         {
[08:25:54.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:54.098]                 ...future.oldOptions$nwarnings <- NULL
[08:25:54.098]             }
[08:25:54.098]             base::options(...future.oldOptions)
[08:25:54.098]             if (.Platform$OS.type == "windows") {
[08:25:54.098]                 old_names <- names(...future.oldEnvVars)
[08:25:54.098]                 envs <- base::Sys.getenv()
[08:25:54.098]                 names <- names(envs)
[08:25:54.098]                 common <- intersect(names, old_names)
[08:25:54.098]                 added <- setdiff(names, old_names)
[08:25:54.098]                 removed <- setdiff(old_names, names)
[08:25:54.098]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:54.098]                   envs[common]]
[08:25:54.098]                 NAMES <- toupper(changed)
[08:25:54.098]                 args <- list()
[08:25:54.098]                 for (kk in seq_along(NAMES)) {
[08:25:54.098]                   name <- changed[[kk]]
[08:25:54.098]                   NAME <- NAMES[[kk]]
[08:25:54.098]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.098]                     next
[08:25:54.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:54.098]                 }
[08:25:54.098]                 NAMES <- toupper(added)
[08:25:54.098]                 for (kk in seq_along(NAMES)) {
[08:25:54.098]                   name <- added[[kk]]
[08:25:54.098]                   NAME <- NAMES[[kk]]
[08:25:54.098]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.098]                     next
[08:25:54.098]                   args[[name]] <- ""
[08:25:54.098]                 }
[08:25:54.098]                 NAMES <- toupper(removed)
[08:25:54.098]                 for (kk in seq_along(NAMES)) {
[08:25:54.098]                   name <- removed[[kk]]
[08:25:54.098]                   NAME <- NAMES[[kk]]
[08:25:54.098]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.098]                     next
[08:25:54.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:54.098]                 }
[08:25:54.098]                 if (length(args) > 0) 
[08:25:54.098]                   base::do.call(base::Sys.setenv, args = args)
[08:25:54.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:54.098]             }
[08:25:54.098]             else {
[08:25:54.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:54.098]             }
[08:25:54.098]             {
[08:25:54.098]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:54.098]                   0L) {
[08:25:54.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:54.098]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:54.098]                   base::options(opts)
[08:25:54.098]                 }
[08:25:54.098]                 {
[08:25:54.098]                   {
[08:25:54.098]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:54.098]                     NULL
[08:25:54.098]                   }
[08:25:54.098]                   options(future.plan = NULL)
[08:25:54.098]                   if (is.na(NA_character_)) 
[08:25:54.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:54.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:54.098]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:54.098]                     .init = FALSE)
[08:25:54.098]                 }
[08:25:54.098]             }
[08:25:54.098]         }
[08:25:54.098]     })
[08:25:54.098]     if (TRUE) {
[08:25:54.098]         base::sink(type = "output", split = FALSE)
[08:25:54.098]         if (TRUE) {
[08:25:54.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:54.098]         }
[08:25:54.098]         else {
[08:25:54.098]             ...future.result["stdout"] <- base::list(NULL)
[08:25:54.098]         }
[08:25:54.098]         base::close(...future.stdout)
[08:25:54.098]         ...future.stdout <- NULL
[08:25:54.098]     }
[08:25:54.098]     ...future.result$conditions <- ...future.conditions
[08:25:54.098]     ...future.result$finished <- base::Sys.time()
[08:25:54.098]     ...future.result
[08:25:54.098] }
[08:25:54.101] Exporting 5 global objects (679 bytes) to cluster node #2 ...
[08:25:54.101] Exporting ‘...future.FUN’ (32 bytes) to cluster node #2 ...
[08:25:54.102] Exporting ‘...future.FUN’ (32 bytes) to cluster node #2 ... DONE
[08:25:54.102] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:54.102] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:54.102] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ...
[08:25:54.103] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ... DONE
[08:25:54.103] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:54.103] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:54.103] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:54.104] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:54.104] Exporting 5 global objects (679 bytes) to cluster node #2 ... DONE
[08:25:54.104] MultisessionFuture started
[08:25:54.104] - Launch lazy future ... done
[08:25:54.104] run() for ‘MultisessionFuture’ ... done
[08:25:54.105] Created future:
[08:25:54.105] MultisessionFuture:
[08:25:54.105] Label: ‘future_Map-2’
[08:25:54.105] Expression:
[08:25:54.105] {
[08:25:54.105]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:54.105]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:54.105]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:54.105]         on.exit(options(oopts), add = TRUE)
[08:25:54.105]     }
[08:25:54.105]     {
[08:25:54.105]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:54.105]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:54.105]         do.call(mapply, args = args)
[08:25:54.105]     }
[08:25:54.105] }
[08:25:54.105] Lazy evaluation: FALSE
[08:25:54.105] Asynchronous evaluation: TRUE
[08:25:54.105] Local evaluation: TRUE
[08:25:54.105] Environment: R_GlobalEnv
[08:25:54.105] Capture standard output: TRUE
[08:25:54.105] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:54.105] Globals: 5 objects totaling 216 bytes (function ‘...future.FUN’ of 32 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:54.105] Packages: <none>
[08:25:54.105] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:54.105] Resolved: FALSE
[08:25:54.105] Value: <not collected>
[08:25:54.105] Conditions captured: <none>
[08:25:54.105] Early signaling: FALSE
[08:25:54.105] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:54.105] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:54.116] Chunk #2 of 2 ... DONE
[08:25:54.116] Launching 2 futures (chunks) ... DONE
[08:25:54.116] Resolving 2 futures (chunks) ...
[08:25:54.117] resolve() on list ...
[08:25:54.117]  recursive: 0
[08:25:54.117]  length: 2
[08:25:54.117] 
[08:25:54.117] receiveMessageFromWorker() for ClusterFuture ...
[08:25:54.118] - Validating connection of MultisessionFuture
[08:25:54.118] - received message: FutureResult
[08:25:54.118] - Received FutureResult
[08:25:54.118] - Erased future from FutureRegistry
[08:25:54.118] result() for ClusterFuture ...
[08:25:54.118] - result already collected: FutureResult
[08:25:54.118] result() for ClusterFuture ... done
[08:25:54.118] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:54.118] Future #1
[08:25:54.119] result() for ClusterFuture ...
[08:25:54.119] - result already collected: FutureResult
[08:25:54.119] result() for ClusterFuture ... done
[08:25:54.119] result() for ClusterFuture ...
[08:25:54.119] - result already collected: FutureResult
[08:25:54.119] result() for ClusterFuture ... done
[08:25:54.119] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:54.119] - nx: 2
[08:25:54.119] - relay: TRUE
[08:25:54.119] - stdout: TRUE
[08:25:54.119] - signal: TRUE
[08:25:54.120] - resignal: FALSE
[08:25:54.120] - force: TRUE
[08:25:54.120] - relayed: [n=2] FALSE, FALSE
[08:25:54.120] - queued futures: [n=2] FALSE, FALSE
[08:25:54.120]  - until=1
[08:25:54.120]  - relaying element #1
[08:25:54.120] result() for ClusterFuture ...
[08:25:54.120] - result already collected: FutureResult
[08:25:54.120] result() for ClusterFuture ... done
[08:25:54.120] result() for ClusterFuture ...
[08:25:54.120] - result already collected: FutureResult
[08:25:54.120] result() for ClusterFuture ... done
[08:25:54.121] result() for ClusterFuture ...
[08:25:54.121] - result already collected: FutureResult
[08:25:54.121] result() for ClusterFuture ... done
[08:25:54.121] result() for ClusterFuture ...
[08:25:54.121] - result already collected: FutureResult
[08:25:54.121] result() for ClusterFuture ... done
[08:25:54.121] - relayed: [n=2] TRUE, FALSE
[08:25:54.121] - queued futures: [n=2] TRUE, FALSE
[08:25:54.121] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:54.121]  length: 1 (resolved future 1)
[08:25:54.146] receiveMessageFromWorker() for ClusterFuture ...
[08:25:54.146] - Validating connection of MultisessionFuture
[08:25:54.147] - received message: FutureResult
[08:25:54.147] - Received FutureResult
[08:25:54.147] - Erased future from FutureRegistry
[08:25:54.147] result() for ClusterFuture ...
[08:25:54.147] - result already collected: FutureResult
[08:25:54.147] result() for ClusterFuture ... done
[08:25:54.147] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:54.147] Future #2
[08:25:54.147] result() for ClusterFuture ...
[08:25:54.148] - result already collected: FutureResult
[08:25:54.148] result() for ClusterFuture ... done
[08:25:54.148] result() for ClusterFuture ...
[08:25:54.148] - result already collected: FutureResult
[08:25:54.148] result() for ClusterFuture ... done
[08:25:54.148] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:54.148] - nx: 2
[08:25:54.148] - relay: TRUE
[08:25:54.148] - stdout: TRUE
[08:25:54.148] - signal: TRUE
[08:25:54.148] - resignal: FALSE
[08:25:54.148] - force: TRUE
[08:25:54.149] - relayed: [n=2] TRUE, FALSE
[08:25:54.149] - queued futures: [n=2] TRUE, FALSE
[08:25:54.149]  - until=2
[08:25:54.149]  - relaying element #2
[08:25:54.149] result() for ClusterFuture ...
[08:25:54.149] - result already collected: FutureResult
[08:25:54.149] result() for ClusterFuture ... done
[08:25:54.149] result() for ClusterFuture ...
[08:25:54.149] - result already collected: FutureResult
[08:25:54.149] result() for ClusterFuture ... done
[08:25:54.149] result() for ClusterFuture ...
[08:25:54.150] - result already collected: FutureResult
[08:25:54.150] result() for ClusterFuture ... done
[08:25:54.150] result() for ClusterFuture ...
[08:25:54.150] - result already collected: FutureResult
[08:25:54.150] result() for ClusterFuture ... done
[08:25:54.150] - relayed: [n=2] TRUE, TRUE
[08:25:54.150] - queued futures: [n=2] TRUE, TRUE
[08:25:54.150] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:54.150]  length: 0 (resolved future 2)
[08:25:54.150] Relaying remaining futures
[08:25:54.150] signalConditionsASAP(NULL, pos=0) ...
[08:25:54.151] - nx: 2
[08:25:54.151] - relay: TRUE
[08:25:54.151] - stdout: TRUE
[08:25:54.151] - signal: TRUE
[08:25:54.151] - resignal: FALSE
[08:25:54.151] - force: TRUE
[08:25:54.151] - relayed: [n=2] TRUE, TRUE
[08:25:54.151] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:54.151] - relayed: [n=2] TRUE, TRUE
[08:25:54.151] - queued futures: [n=2] TRUE, TRUE
[08:25:54.151] signalConditionsASAP(NULL, pos=0) ... done
[08:25:54.151] resolve() on list ... DONE
[08:25:54.152] result() for ClusterFuture ...
[08:25:54.152] - result already collected: FutureResult
[08:25:54.152] result() for ClusterFuture ... done
[08:25:54.152] result() for ClusterFuture ...
[08:25:54.152] - result already collected: FutureResult
[08:25:54.152] result() for ClusterFuture ... done
[08:25:54.152] result() for ClusterFuture ...
[08:25:54.152] - result already collected: FutureResult
[08:25:54.152] result() for ClusterFuture ... done
[08:25:54.152] result() for ClusterFuture ...
[08:25:54.152] - result already collected: FutureResult
[08:25:54.152] result() for ClusterFuture ... done
[08:25:54.153]  - Number of value chunks collected: 2
[08:25:54.153] Resolving 2 futures (chunks) ... DONE
[08:25:54.153] Reducing values from 2 chunks ...
[08:25:54.153]  - Number of values collected after concatenation: 3
[08:25:54.153]  - Number of values expected: 3
[08:25:54.153] Reducing values from 2 chunks ... DONE
[08:25:54.153] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[08:25:54.154] future_mapply() ...
[08:25:54.155] Number of chunks: 2
[08:25:54.155] getGlobalsAndPackagesXApply() ...
[08:25:54.156]  - future.globals: TRUE
[08:25:54.156] getGlobalsAndPackages() ...
[08:25:54.156] Searching for globals...
[08:25:54.157] - globals found: [1] ‘FUN’
[08:25:54.157] Searching for globals ... DONE
[08:25:54.157] Resolving globals: FALSE
[08:25:54.157] The total size of the 1 globals is 185 bytes (185 bytes)
[08:25:54.158] The total size of the 1 globals exported for future expression (‘FUN()’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:25:54.158] - globals: [1] ‘FUN’
[08:25:54.158] 
[08:25:54.158] getGlobalsAndPackages() ... DONE
[08:25:54.158]  - globals found/used: [n=1] ‘FUN’
[08:25:54.158]  - needed namespaces: [n=0] 
[08:25:54.158] Finding globals ... DONE
[08:25:54.158] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:25:54.159] List of 2
[08:25:54.159]  $ ...future.FUN:function (x)  
[08:25:54.159]  $ MoreArgs     : NULL
[08:25:54.159]  - attr(*, "where")=List of 2
[08:25:54.159]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:25:54.159]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:25:54.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:25:54.159]  - attr(*, "resolved")= logi FALSE
[08:25:54.159]  - attr(*, "total_size")= num NA
[08:25:54.161] Packages to be attached in all futures: [n=0] 
[08:25:54.161] getGlobalsAndPackagesXApply() ... DONE
[08:25:54.161] Number of futures (= number of chunks): 2
[08:25:54.162] Launching 2 futures (chunks) ...
[08:25:54.162] Chunk #1 of 2 ...
[08:25:54.162]  - Finding globals in '...' for chunk #1 ...
[08:25:54.162] getGlobalsAndPackages() ...
[08:25:54.162] Searching for globals...
[08:25:54.162] 
[08:25:54.162] Searching for globals ... DONE
[08:25:54.162] - globals: [0] <none>
[08:25:54.163] getGlobalsAndPackages() ... DONE
[08:25:54.163]    + additional globals found: [n=0] 
[08:25:54.163]    + additional namespaces needed: [n=0] 
[08:25:54.163]  - Finding globals in '...' for chunk #1 ... DONE
[08:25:54.163]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:54.163]  - seeds: <none>
[08:25:54.163]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.163] getGlobalsAndPackages() ...
[08:25:54.163] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.163] Resolving globals: FALSE
[08:25:54.164] The total size of the 5 globals is 363 bytes (363 bytes)
[08:25:54.164] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:54.164] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.164] 
[08:25:54.165] getGlobalsAndPackages() ... DONE
[08:25:54.165] run() for ‘Future’ ...
[08:25:54.165] - state: ‘created’
[08:25:54.165] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:54.179] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:54.179] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:54.179]   - Field: ‘node’
[08:25:54.180]   - Field: ‘label’
[08:25:54.180]   - Field: ‘local’
[08:25:54.180]   - Field: ‘owner’
[08:25:54.180]   - Field: ‘envir’
[08:25:54.180]   - Field: ‘workers’
[08:25:54.180]   - Field: ‘packages’
[08:25:54.180]   - Field: ‘gc’
[08:25:54.180]   - Field: ‘conditions’
[08:25:54.180]   - Field: ‘persistent’
[08:25:54.180]   - Field: ‘expr’
[08:25:54.180]   - Field: ‘uuid’
[08:25:54.181]   - Field: ‘seed’
[08:25:54.181]   - Field: ‘version’
[08:25:54.181]   - Field: ‘result’
[08:25:54.181]   - Field: ‘asynchronous’
[08:25:54.181]   - Field: ‘calls’
[08:25:54.181]   - Field: ‘globals’
[08:25:54.181]   - Field: ‘stdout’
[08:25:54.181]   - Field: ‘earlySignal’
[08:25:54.181]   - Field: ‘lazy’
[08:25:54.181]   - Field: ‘state’
[08:25:54.181] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:54.182] - Launch lazy future ...
[08:25:54.182] Packages needed by the future expression (n = 0): <none>
[08:25:54.182] Packages needed by future strategies (n = 0): <none>
[08:25:54.182] {
[08:25:54.182]     {
[08:25:54.182]         {
[08:25:54.182]             ...future.startTime <- base::Sys.time()
[08:25:54.182]             {
[08:25:54.182]                 {
[08:25:54.182]                   {
[08:25:54.182]                     {
[08:25:54.182]                       base::local({
[08:25:54.182]                         has_future <- base::requireNamespace("future", 
[08:25:54.182]                           quietly = TRUE)
[08:25:54.182]                         if (has_future) {
[08:25:54.182]                           ns <- base::getNamespace("future")
[08:25:54.182]                           version <- ns[[".package"]][["version"]]
[08:25:54.182]                           if (is.null(version)) 
[08:25:54.182]                             version <- utils::packageVersion("future")
[08:25:54.182]                         }
[08:25:54.182]                         else {
[08:25:54.182]                           version <- NULL
[08:25:54.182]                         }
[08:25:54.182]                         if (!has_future || version < "1.8.0") {
[08:25:54.182]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:54.182]                             "", base::R.version$version.string), 
[08:25:54.182]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:54.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:54.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:54.182]                               "release", "version")], collapse = " "), 
[08:25:54.182]                             hostname = base::Sys.info()[["nodename"]])
[08:25:54.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:54.182]                             info)
[08:25:54.182]                           info <- base::paste(info, collapse = "; ")
[08:25:54.182]                           if (!has_future) {
[08:25:54.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:54.182]                               info)
[08:25:54.182]                           }
[08:25:54.182]                           else {
[08:25:54.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:54.182]                               info, version)
[08:25:54.182]                           }
[08:25:54.182]                           base::stop(msg)
[08:25:54.182]                         }
[08:25:54.182]                       })
[08:25:54.182]                     }
[08:25:54.182]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:54.182]                     base::options(mc.cores = 1L)
[08:25:54.182]                   }
[08:25:54.182]                   ...future.strategy.old <- future::plan("list")
[08:25:54.182]                   options(future.plan = NULL)
[08:25:54.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:54.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:54.182]                 }
[08:25:54.182]                 ...future.workdir <- getwd()
[08:25:54.182]             }
[08:25:54.182]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:54.182]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:54.182]         }
[08:25:54.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:54.182]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:54.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:54.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:54.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:54.182]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:54.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:54.182]             base::names(...future.oldOptions))
[08:25:54.182]     }
[08:25:54.182]     if (FALSE) {
[08:25:54.182]     }
[08:25:54.182]     else {
[08:25:54.182]         if (TRUE) {
[08:25:54.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:54.182]                 open = "w")
[08:25:54.182]         }
[08:25:54.182]         else {
[08:25:54.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:54.182]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:54.182]         }
[08:25:54.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:54.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:54.182]             base::sink(type = "output", split = FALSE)
[08:25:54.182]             base::close(...future.stdout)
[08:25:54.182]         }, add = TRUE)
[08:25:54.182]     }
[08:25:54.182]     ...future.frame <- base::sys.nframe()
[08:25:54.182]     ...future.conditions <- base::list()
[08:25:54.182]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:54.182]     if (FALSE) {
[08:25:54.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:54.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:54.182]     }
[08:25:54.182]     ...future.result <- base::tryCatch({
[08:25:54.182]         base::withCallingHandlers({
[08:25:54.182]             ...future.value <- base::withVisible(base::local({
[08:25:54.182]                 ...future.makeSendCondition <- base::local({
[08:25:54.182]                   sendCondition <- NULL
[08:25:54.182]                   function(frame = 1L) {
[08:25:54.182]                     if (is.function(sendCondition)) 
[08:25:54.182]                       return(sendCondition)
[08:25:54.182]                     ns <- getNamespace("parallel")
[08:25:54.182]                     if (exists("sendData", mode = "function", 
[08:25:54.182]                       envir = ns)) {
[08:25:54.182]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:54.182]                         envir = ns)
[08:25:54.182]                       envir <- sys.frame(frame)
[08:25:54.182]                       master <- NULL
[08:25:54.182]                       while (!identical(envir, .GlobalEnv) && 
[08:25:54.182]                         !identical(envir, emptyenv())) {
[08:25:54.182]                         if (exists("master", mode = "list", envir = envir, 
[08:25:54.182]                           inherits = FALSE)) {
[08:25:54.182]                           master <- get("master", mode = "list", 
[08:25:54.182]                             envir = envir, inherits = FALSE)
[08:25:54.182]                           if (inherits(master, c("SOCKnode", 
[08:25:54.182]                             "SOCK0node"))) {
[08:25:54.182]                             sendCondition <<- function(cond) {
[08:25:54.182]                               data <- list(type = "VALUE", value = cond, 
[08:25:54.182]                                 success = TRUE)
[08:25:54.182]                               parallel_sendData(master, data)
[08:25:54.182]                             }
[08:25:54.182]                             return(sendCondition)
[08:25:54.182]                           }
[08:25:54.182]                         }
[08:25:54.182]                         frame <- frame + 1L
[08:25:54.182]                         envir <- sys.frame(frame)
[08:25:54.182]                       }
[08:25:54.182]                     }
[08:25:54.182]                     sendCondition <<- function(cond) NULL
[08:25:54.182]                   }
[08:25:54.182]                 })
[08:25:54.182]                 withCallingHandlers({
[08:25:54.182]                   {
[08:25:54.182]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:54.182]                     if (!identical(...future.globals.maxSize.org, 
[08:25:54.182]                       ...future.globals.maxSize)) {
[08:25:54.182]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:54.182]                       on.exit(options(oopts), add = TRUE)
[08:25:54.182]                     }
[08:25:54.182]                     {
[08:25:54.182]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:54.182]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:54.182]                         USE.NAMES = FALSE)
[08:25:54.182]                       do.call(mapply, args = args)
[08:25:54.182]                     }
[08:25:54.182]                   }
[08:25:54.182]                 }, immediateCondition = function(cond) {
[08:25:54.182]                   sendCondition <- ...future.makeSendCondition()
[08:25:54.182]                   sendCondition(cond)
[08:25:54.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.182]                   {
[08:25:54.182]                     inherits <- base::inherits
[08:25:54.182]                     invokeRestart <- base::invokeRestart
[08:25:54.182]                     is.null <- base::is.null
[08:25:54.182]                     muffled <- FALSE
[08:25:54.182]                     if (inherits(cond, "message")) {
[08:25:54.182]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:54.182]                       if (muffled) 
[08:25:54.182]                         invokeRestart("muffleMessage")
[08:25:54.182]                     }
[08:25:54.182]                     else if (inherits(cond, "warning")) {
[08:25:54.182]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:54.182]                       if (muffled) 
[08:25:54.182]                         invokeRestart("muffleWarning")
[08:25:54.182]                     }
[08:25:54.182]                     else if (inherits(cond, "condition")) {
[08:25:54.182]                       if (!is.null(pattern)) {
[08:25:54.182]                         computeRestarts <- base::computeRestarts
[08:25:54.182]                         grepl <- base::grepl
[08:25:54.182]                         restarts <- computeRestarts(cond)
[08:25:54.182]                         for (restart in restarts) {
[08:25:54.182]                           name <- restart$name
[08:25:54.182]                           if (is.null(name)) 
[08:25:54.182]                             next
[08:25:54.182]                           if (!grepl(pattern, name)) 
[08:25:54.182]                             next
[08:25:54.182]                           invokeRestart(restart)
[08:25:54.182]                           muffled <- TRUE
[08:25:54.182]                           break
[08:25:54.182]                         }
[08:25:54.182]                       }
[08:25:54.182]                     }
[08:25:54.182]                     invisible(muffled)
[08:25:54.182]                   }
[08:25:54.182]                   muffleCondition(cond)
[08:25:54.182]                 })
[08:25:54.182]             }))
[08:25:54.182]             future::FutureResult(value = ...future.value$value, 
[08:25:54.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:54.182]                   ...future.rng), globalenv = if (FALSE) 
[08:25:54.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:54.182]                     ...future.globalenv.names))
[08:25:54.182]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:54.182]         }, condition = base::local({
[08:25:54.182]             c <- base::c
[08:25:54.182]             inherits <- base::inherits
[08:25:54.182]             invokeRestart <- base::invokeRestart
[08:25:54.182]             length <- base::length
[08:25:54.182]             list <- base::list
[08:25:54.182]             seq.int <- base::seq.int
[08:25:54.182]             signalCondition <- base::signalCondition
[08:25:54.182]             sys.calls <- base::sys.calls
[08:25:54.182]             `[[` <- base::`[[`
[08:25:54.182]             `+` <- base::`+`
[08:25:54.182]             `<<-` <- base::`<<-`
[08:25:54.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:54.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:54.182]                   3L)]
[08:25:54.182]             }
[08:25:54.182]             function(cond) {
[08:25:54.182]                 is_error <- inherits(cond, "error")
[08:25:54.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:54.182]                   NULL)
[08:25:54.182]                 if (is_error) {
[08:25:54.182]                   sessionInformation <- function() {
[08:25:54.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:54.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:54.182]                       search = base::search(), system = base::Sys.info())
[08:25:54.182]                   }
[08:25:54.182]                   ...future.conditions[[length(...future.conditions) + 
[08:25:54.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:54.182]                     cond$call), session = sessionInformation(), 
[08:25:54.182]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:54.182]                   signalCondition(cond)
[08:25:54.182]                 }
[08:25:54.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:54.182]                 "immediateCondition"))) {
[08:25:54.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:54.182]                   ...future.conditions[[length(...future.conditions) + 
[08:25:54.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:54.182]                   if (TRUE && !signal) {
[08:25:54.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.182]                     {
[08:25:54.182]                       inherits <- base::inherits
[08:25:54.182]                       invokeRestart <- base::invokeRestart
[08:25:54.182]                       is.null <- base::is.null
[08:25:54.182]                       muffled <- FALSE
[08:25:54.182]                       if (inherits(cond, "message")) {
[08:25:54.182]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:54.182]                         if (muffled) 
[08:25:54.182]                           invokeRestart("muffleMessage")
[08:25:54.182]                       }
[08:25:54.182]                       else if (inherits(cond, "warning")) {
[08:25:54.182]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:54.182]                         if (muffled) 
[08:25:54.182]                           invokeRestart("muffleWarning")
[08:25:54.182]                       }
[08:25:54.182]                       else if (inherits(cond, "condition")) {
[08:25:54.182]                         if (!is.null(pattern)) {
[08:25:54.182]                           computeRestarts <- base::computeRestarts
[08:25:54.182]                           grepl <- base::grepl
[08:25:54.182]                           restarts <- computeRestarts(cond)
[08:25:54.182]                           for (restart in restarts) {
[08:25:54.182]                             name <- restart$name
[08:25:54.182]                             if (is.null(name)) 
[08:25:54.182]                               next
[08:25:54.182]                             if (!grepl(pattern, name)) 
[08:25:54.182]                               next
[08:25:54.182]                             invokeRestart(restart)
[08:25:54.182]                             muffled <- TRUE
[08:25:54.182]                             break
[08:25:54.182]                           }
[08:25:54.182]                         }
[08:25:54.182]                       }
[08:25:54.182]                       invisible(muffled)
[08:25:54.182]                     }
[08:25:54.182]                     muffleCondition(cond, pattern = "^muffle")
[08:25:54.182]                   }
[08:25:54.182]                 }
[08:25:54.182]                 else {
[08:25:54.182]                   if (TRUE) {
[08:25:54.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.182]                     {
[08:25:54.182]                       inherits <- base::inherits
[08:25:54.182]                       invokeRestart <- base::invokeRestart
[08:25:54.182]                       is.null <- base::is.null
[08:25:54.182]                       muffled <- FALSE
[08:25:54.182]                       if (inherits(cond, "message")) {
[08:25:54.182]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:54.182]                         if (muffled) 
[08:25:54.182]                           invokeRestart("muffleMessage")
[08:25:54.182]                       }
[08:25:54.182]                       else if (inherits(cond, "warning")) {
[08:25:54.182]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:54.182]                         if (muffled) 
[08:25:54.182]                           invokeRestart("muffleWarning")
[08:25:54.182]                       }
[08:25:54.182]                       else if (inherits(cond, "condition")) {
[08:25:54.182]                         if (!is.null(pattern)) {
[08:25:54.182]                           computeRestarts <- base::computeRestarts
[08:25:54.182]                           grepl <- base::grepl
[08:25:54.182]                           restarts <- computeRestarts(cond)
[08:25:54.182]                           for (restart in restarts) {
[08:25:54.182]                             name <- restart$name
[08:25:54.182]                             if (is.null(name)) 
[08:25:54.182]                               next
[08:25:54.182]                             if (!grepl(pattern, name)) 
[08:25:54.182]                               next
[08:25:54.182]                             invokeRestart(restart)
[08:25:54.182]                             muffled <- TRUE
[08:25:54.182]                             break
[08:25:54.182]                           }
[08:25:54.182]                         }
[08:25:54.182]                       }
[08:25:54.182]                       invisible(muffled)
[08:25:54.182]                     }
[08:25:54.182]                     muffleCondition(cond, pattern = "^muffle")
[08:25:54.182]                   }
[08:25:54.182]                 }
[08:25:54.182]             }
[08:25:54.182]         }))
[08:25:54.182]     }, error = function(ex) {
[08:25:54.182]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:54.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:54.182]                 ...future.rng), started = ...future.startTime, 
[08:25:54.182]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:54.182]             version = "1.8"), class = "FutureResult")
[08:25:54.182]     }, finally = {
[08:25:54.182]         if (!identical(...future.workdir, getwd())) 
[08:25:54.182]             setwd(...future.workdir)
[08:25:54.182]         {
[08:25:54.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:54.182]                 ...future.oldOptions$nwarnings <- NULL
[08:25:54.182]             }
[08:25:54.182]             base::options(...future.oldOptions)
[08:25:54.182]             if (.Platform$OS.type == "windows") {
[08:25:54.182]                 old_names <- names(...future.oldEnvVars)
[08:25:54.182]                 envs <- base::Sys.getenv()
[08:25:54.182]                 names <- names(envs)
[08:25:54.182]                 common <- intersect(names, old_names)
[08:25:54.182]                 added <- setdiff(names, old_names)
[08:25:54.182]                 removed <- setdiff(old_names, names)
[08:25:54.182]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:54.182]                   envs[common]]
[08:25:54.182]                 NAMES <- toupper(changed)
[08:25:54.182]                 args <- list()
[08:25:54.182]                 for (kk in seq_along(NAMES)) {
[08:25:54.182]                   name <- changed[[kk]]
[08:25:54.182]                   NAME <- NAMES[[kk]]
[08:25:54.182]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.182]                     next
[08:25:54.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:54.182]                 }
[08:25:54.182]                 NAMES <- toupper(added)
[08:25:54.182]                 for (kk in seq_along(NAMES)) {
[08:25:54.182]                   name <- added[[kk]]
[08:25:54.182]                   NAME <- NAMES[[kk]]
[08:25:54.182]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.182]                     next
[08:25:54.182]                   args[[name]] <- ""
[08:25:54.182]                 }
[08:25:54.182]                 NAMES <- toupper(removed)
[08:25:54.182]                 for (kk in seq_along(NAMES)) {
[08:25:54.182]                   name <- removed[[kk]]
[08:25:54.182]                   NAME <- NAMES[[kk]]
[08:25:54.182]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.182]                     next
[08:25:54.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:54.182]                 }
[08:25:54.182]                 if (length(args) > 0) 
[08:25:54.182]                   base::do.call(base::Sys.setenv, args = args)
[08:25:54.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:54.182]             }
[08:25:54.182]             else {
[08:25:54.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:54.182]             }
[08:25:54.182]             {
[08:25:54.182]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:54.182]                   0L) {
[08:25:54.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:54.182]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:54.182]                   base::options(opts)
[08:25:54.182]                 }
[08:25:54.182]                 {
[08:25:54.182]                   {
[08:25:54.182]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:54.182]                     NULL
[08:25:54.182]                   }
[08:25:54.182]                   options(future.plan = NULL)
[08:25:54.182]                   if (is.na(NA_character_)) 
[08:25:54.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:54.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:54.182]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:54.182]                     .init = FALSE)
[08:25:54.182]                 }
[08:25:54.182]             }
[08:25:54.182]         }
[08:25:54.182]     })
[08:25:54.182]     if (TRUE) {
[08:25:54.182]         base::sink(type = "output", split = FALSE)
[08:25:54.182]         if (TRUE) {
[08:25:54.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:54.182]         }
[08:25:54.182]         else {
[08:25:54.182]             ...future.result["stdout"] <- base::list(NULL)
[08:25:54.182]         }
[08:25:54.182]         base::close(...future.stdout)
[08:25:54.182]         ...future.stdout <- NULL
[08:25:54.182]     }
[08:25:54.182]     ...future.result$conditions <- ...future.conditions
[08:25:54.182]     ...future.result$finished <- base::Sys.time()
[08:25:54.182]     ...future.result
[08:25:54.182] }
[08:25:54.185] Exporting 5 global objects (800 bytes) to cluster node #1 ...
[08:25:54.186] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[08:25:54.186] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[08:25:54.186] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:25:54.187] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:25:54.187] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #1 ...
[08:25:54.187] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #1 ... DONE
[08:25:54.187] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:25:54.188] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:25:54.188] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:25:54.188] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:25:54.188] Exporting 5 global objects (800 bytes) to cluster node #1 ... DONE
[08:25:54.189] MultisessionFuture started
[08:25:54.189] - Launch lazy future ... done
[08:25:54.189] run() for ‘MultisessionFuture’ ... done
[08:25:54.189] Created future:
[08:25:54.189] MultisessionFuture:
[08:25:54.189] Label: ‘future_mapply-1’
[08:25:54.189] Expression:
[08:25:54.189] {
[08:25:54.189]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:54.189]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:54.189]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:54.189]         on.exit(options(oopts), add = TRUE)
[08:25:54.189]     }
[08:25:54.189]     {
[08:25:54.189]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:54.189]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:54.189]         do.call(mapply, args = args)
[08:25:54.189]     }
[08:25:54.189] }
[08:25:54.189] Lazy evaluation: FALSE
[08:25:54.189] Asynchronous evaluation: TRUE
[08:25:54.189] Local evaluation: TRUE
[08:25:54.189] Environment: R_GlobalEnv
[08:25:54.189] Capture standard output: TRUE
[08:25:54.189] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:54.189] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:54.189] Packages: <none>
[08:25:54.189] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:54.189] Resolved: FALSE
[08:25:54.189] Value: <not collected>
[08:25:54.189] Conditions captured: <none>
[08:25:54.189] Early signaling: FALSE
[08:25:54.189] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:54.189] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:54.201] Chunk #1 of 2 ... DONE
[08:25:54.201] Chunk #2 of 2 ...
[08:25:54.201]  - Finding globals in '...' for chunk #2 ...
[08:25:54.201] getGlobalsAndPackages() ...
[08:25:54.201] Searching for globals...
[08:25:54.201] 
[08:25:54.202] Searching for globals ... DONE
[08:25:54.202] - globals: [0] <none>
[08:25:54.202] getGlobalsAndPackages() ... DONE
[08:25:54.202]    + additional globals found: [n=0] 
[08:25:54.202]    + additional namespaces needed: [n=0] 
[08:25:54.202]  - Finding globals in '...' for chunk #2 ... DONE
[08:25:54.202]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:25:54.202]  - seeds: <none>
[08:25:54.202]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.202] getGlobalsAndPackages() ...
[08:25:54.203] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.203] Resolving globals: FALSE
[08:25:54.203] The total size of the 5 globals is 363 bytes (363 bytes)
[08:25:54.204] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 363 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (185 bytes of class ‘function’), ‘...future.elements_ii’ (97 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:25:54.204] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:25:54.204] 
[08:25:54.204] getGlobalsAndPackages() ... DONE
[08:25:54.204] run() for ‘Future’ ...
[08:25:54.204] - state: ‘created’
[08:25:54.204] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:25:54.219] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:54.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:25:54.219]   - Field: ‘node’
[08:25:54.219]   - Field: ‘label’
[08:25:54.219]   - Field: ‘local’
[08:25:54.219]   - Field: ‘owner’
[08:25:54.219]   - Field: ‘envir’
[08:25:54.219]   - Field: ‘workers’
[08:25:54.219]   - Field: ‘packages’
[08:25:54.220]   - Field: ‘gc’
[08:25:54.220]   - Field: ‘conditions’
[08:25:54.220]   - Field: ‘persistent’
[08:25:54.220]   - Field: ‘expr’
[08:25:54.220]   - Field: ‘uuid’
[08:25:54.220]   - Field: ‘seed’
[08:25:54.220]   - Field: ‘version’
[08:25:54.220]   - Field: ‘result’
[08:25:54.220]   - Field: ‘asynchronous’
[08:25:54.220]   - Field: ‘calls’
[08:25:54.220]   - Field: ‘globals’
[08:25:54.221]   - Field: ‘stdout’
[08:25:54.221]   - Field: ‘earlySignal’
[08:25:54.221]   - Field: ‘lazy’
[08:25:54.221]   - Field: ‘state’
[08:25:54.221] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:25:54.221] - Launch lazy future ...
[08:25:54.221] Packages needed by the future expression (n = 0): <none>
[08:25:54.221] Packages needed by future strategies (n = 0): <none>
[08:25:54.222] {
[08:25:54.222]     {
[08:25:54.222]         {
[08:25:54.222]             ...future.startTime <- base::Sys.time()
[08:25:54.222]             {
[08:25:54.222]                 {
[08:25:54.222]                   {
[08:25:54.222]                     {
[08:25:54.222]                       base::local({
[08:25:54.222]                         has_future <- base::requireNamespace("future", 
[08:25:54.222]                           quietly = TRUE)
[08:25:54.222]                         if (has_future) {
[08:25:54.222]                           ns <- base::getNamespace("future")
[08:25:54.222]                           version <- ns[[".package"]][["version"]]
[08:25:54.222]                           if (is.null(version)) 
[08:25:54.222]                             version <- utils::packageVersion("future")
[08:25:54.222]                         }
[08:25:54.222]                         else {
[08:25:54.222]                           version <- NULL
[08:25:54.222]                         }
[08:25:54.222]                         if (!has_future || version < "1.8.0") {
[08:25:54.222]                           info <- base::c(r_version = base::gsub("R version ", 
[08:25:54.222]                             "", base::R.version$version.string), 
[08:25:54.222]                             platform = base::sprintf("%s (%s-bit)", 
[08:25:54.222]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:25:54.222]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:25:54.222]                               "release", "version")], collapse = " "), 
[08:25:54.222]                             hostname = base::Sys.info()[["nodename"]])
[08:25:54.222]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:25:54.222]                             info)
[08:25:54.222]                           info <- base::paste(info, collapse = "; ")
[08:25:54.222]                           if (!has_future) {
[08:25:54.222]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:25:54.222]                               info)
[08:25:54.222]                           }
[08:25:54.222]                           else {
[08:25:54.222]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:25:54.222]                               info, version)
[08:25:54.222]                           }
[08:25:54.222]                           base::stop(msg)
[08:25:54.222]                         }
[08:25:54.222]                       })
[08:25:54.222]                     }
[08:25:54.222]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:25:54.222]                     base::options(mc.cores = 1L)
[08:25:54.222]                   }
[08:25:54.222]                   ...future.strategy.old <- future::plan("list")
[08:25:54.222]                   options(future.plan = NULL)
[08:25:54.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:25:54.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:25:54.222]                 }
[08:25:54.222]                 ...future.workdir <- getwd()
[08:25:54.222]             }
[08:25:54.222]             ...future.oldOptions <- base::as.list(base::.Options)
[08:25:54.222]             ...future.oldEnvVars <- base::Sys.getenv()
[08:25:54.222]         }
[08:25:54.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:25:54.222]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:25:54.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:25:54.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:25:54.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:25:54.222]             future.stdout.windows.reencode = NULL, width = 80L)
[08:25:54.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:25:54.222]             base::names(...future.oldOptions))
[08:25:54.222]     }
[08:25:54.222]     if (FALSE) {
[08:25:54.222]     }
[08:25:54.222]     else {
[08:25:54.222]         if (TRUE) {
[08:25:54.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:25:54.222]                 open = "w")
[08:25:54.222]         }
[08:25:54.222]         else {
[08:25:54.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:25:54.222]                 windows = "NUL", "/dev/null"), open = "w")
[08:25:54.222]         }
[08:25:54.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:25:54.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:25:54.222]             base::sink(type = "output", split = FALSE)
[08:25:54.222]             base::close(...future.stdout)
[08:25:54.222]         }, add = TRUE)
[08:25:54.222]     }
[08:25:54.222]     ...future.frame <- base::sys.nframe()
[08:25:54.222]     ...future.conditions <- base::list()
[08:25:54.222]     ...future.rng <- base::globalenv()$.Random.seed
[08:25:54.222]     if (FALSE) {
[08:25:54.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:25:54.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:25:54.222]     }
[08:25:54.222]     ...future.result <- base::tryCatch({
[08:25:54.222]         base::withCallingHandlers({
[08:25:54.222]             ...future.value <- base::withVisible(base::local({
[08:25:54.222]                 ...future.makeSendCondition <- base::local({
[08:25:54.222]                   sendCondition <- NULL
[08:25:54.222]                   function(frame = 1L) {
[08:25:54.222]                     if (is.function(sendCondition)) 
[08:25:54.222]                       return(sendCondition)
[08:25:54.222]                     ns <- getNamespace("parallel")
[08:25:54.222]                     if (exists("sendData", mode = "function", 
[08:25:54.222]                       envir = ns)) {
[08:25:54.222]                       parallel_sendData <- get("sendData", mode = "function", 
[08:25:54.222]                         envir = ns)
[08:25:54.222]                       envir <- sys.frame(frame)
[08:25:54.222]                       master <- NULL
[08:25:54.222]                       while (!identical(envir, .GlobalEnv) && 
[08:25:54.222]                         !identical(envir, emptyenv())) {
[08:25:54.222]                         if (exists("master", mode = "list", envir = envir, 
[08:25:54.222]                           inherits = FALSE)) {
[08:25:54.222]                           master <- get("master", mode = "list", 
[08:25:54.222]                             envir = envir, inherits = FALSE)
[08:25:54.222]                           if (inherits(master, c("SOCKnode", 
[08:25:54.222]                             "SOCK0node"))) {
[08:25:54.222]                             sendCondition <<- function(cond) {
[08:25:54.222]                               data <- list(type = "VALUE", value = cond, 
[08:25:54.222]                                 success = TRUE)
[08:25:54.222]                               parallel_sendData(master, data)
[08:25:54.222]                             }
[08:25:54.222]                             return(sendCondition)
[08:25:54.222]                           }
[08:25:54.222]                         }
[08:25:54.222]                         frame <- frame + 1L
[08:25:54.222]                         envir <- sys.frame(frame)
[08:25:54.222]                       }
[08:25:54.222]                     }
[08:25:54.222]                     sendCondition <<- function(cond) NULL
[08:25:54.222]                   }
[08:25:54.222]                 })
[08:25:54.222]                 withCallingHandlers({
[08:25:54.222]                   {
[08:25:54.222]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:54.222]                     if (!identical(...future.globals.maxSize.org, 
[08:25:54.222]                       ...future.globals.maxSize)) {
[08:25:54.222]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:54.222]                       on.exit(options(oopts), add = TRUE)
[08:25:54.222]                     }
[08:25:54.222]                     {
[08:25:54.222]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:54.222]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:25:54.222]                         USE.NAMES = FALSE)
[08:25:54.222]                       do.call(mapply, args = args)
[08:25:54.222]                     }
[08:25:54.222]                   }
[08:25:54.222]                 }, immediateCondition = function(cond) {
[08:25:54.222]                   sendCondition <- ...future.makeSendCondition()
[08:25:54.222]                   sendCondition(cond)
[08:25:54.222]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.222]                   {
[08:25:54.222]                     inherits <- base::inherits
[08:25:54.222]                     invokeRestart <- base::invokeRestart
[08:25:54.222]                     is.null <- base::is.null
[08:25:54.222]                     muffled <- FALSE
[08:25:54.222]                     if (inherits(cond, "message")) {
[08:25:54.222]                       muffled <- grepl(pattern, "muffleMessage")
[08:25:54.222]                       if (muffled) 
[08:25:54.222]                         invokeRestart("muffleMessage")
[08:25:54.222]                     }
[08:25:54.222]                     else if (inherits(cond, "warning")) {
[08:25:54.222]                       muffled <- grepl(pattern, "muffleWarning")
[08:25:54.222]                       if (muffled) 
[08:25:54.222]                         invokeRestart("muffleWarning")
[08:25:54.222]                     }
[08:25:54.222]                     else if (inherits(cond, "condition")) {
[08:25:54.222]                       if (!is.null(pattern)) {
[08:25:54.222]                         computeRestarts <- base::computeRestarts
[08:25:54.222]                         grepl <- base::grepl
[08:25:54.222]                         restarts <- computeRestarts(cond)
[08:25:54.222]                         for (restart in restarts) {
[08:25:54.222]                           name <- restart$name
[08:25:54.222]                           if (is.null(name)) 
[08:25:54.222]                             next
[08:25:54.222]                           if (!grepl(pattern, name)) 
[08:25:54.222]                             next
[08:25:54.222]                           invokeRestart(restart)
[08:25:54.222]                           muffled <- TRUE
[08:25:54.222]                           break
[08:25:54.222]                         }
[08:25:54.222]                       }
[08:25:54.222]                     }
[08:25:54.222]                     invisible(muffled)
[08:25:54.222]                   }
[08:25:54.222]                   muffleCondition(cond)
[08:25:54.222]                 })
[08:25:54.222]             }))
[08:25:54.222]             future::FutureResult(value = ...future.value$value, 
[08:25:54.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:54.222]                   ...future.rng), globalenv = if (FALSE) 
[08:25:54.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:25:54.222]                     ...future.globalenv.names))
[08:25:54.222]                 else NULL, started = ...future.startTime, version = "1.8")
[08:25:54.222]         }, condition = base::local({
[08:25:54.222]             c <- base::c
[08:25:54.222]             inherits <- base::inherits
[08:25:54.222]             invokeRestart <- base::invokeRestart
[08:25:54.222]             length <- base::length
[08:25:54.222]             list <- base::list
[08:25:54.222]             seq.int <- base::seq.int
[08:25:54.222]             signalCondition <- base::signalCondition
[08:25:54.222]             sys.calls <- base::sys.calls
[08:25:54.222]             `[[` <- base::`[[`
[08:25:54.222]             `+` <- base::`+`
[08:25:54.222]             `<<-` <- base::`<<-`
[08:25:54.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:25:54.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:25:54.222]                   3L)]
[08:25:54.222]             }
[08:25:54.222]             function(cond) {
[08:25:54.222]                 is_error <- inherits(cond, "error")
[08:25:54.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:25:54.222]                   NULL)
[08:25:54.222]                 if (is_error) {
[08:25:54.222]                   sessionInformation <- function() {
[08:25:54.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:25:54.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:25:54.222]                       search = base::search(), system = base::Sys.info())
[08:25:54.222]                   }
[08:25:54.222]                   ...future.conditions[[length(...future.conditions) + 
[08:25:54.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:25:54.222]                     cond$call), session = sessionInformation(), 
[08:25:54.222]                     timestamp = base::Sys.time(), signaled = 0L)
[08:25:54.222]                   signalCondition(cond)
[08:25:54.222]                 }
[08:25:54.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:25:54.222]                 "immediateCondition"))) {
[08:25:54.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:25:54.222]                   ...future.conditions[[length(...future.conditions) + 
[08:25:54.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:25:54.222]                   if (TRUE && !signal) {
[08:25:54.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.222]                     {
[08:25:54.222]                       inherits <- base::inherits
[08:25:54.222]                       invokeRestart <- base::invokeRestart
[08:25:54.222]                       is.null <- base::is.null
[08:25:54.222]                       muffled <- FALSE
[08:25:54.222]                       if (inherits(cond, "message")) {
[08:25:54.222]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:54.222]                         if (muffled) 
[08:25:54.222]                           invokeRestart("muffleMessage")
[08:25:54.222]                       }
[08:25:54.222]                       else if (inherits(cond, "warning")) {
[08:25:54.222]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:54.222]                         if (muffled) 
[08:25:54.222]                           invokeRestart("muffleWarning")
[08:25:54.222]                       }
[08:25:54.222]                       else if (inherits(cond, "condition")) {
[08:25:54.222]                         if (!is.null(pattern)) {
[08:25:54.222]                           computeRestarts <- base::computeRestarts
[08:25:54.222]                           grepl <- base::grepl
[08:25:54.222]                           restarts <- computeRestarts(cond)
[08:25:54.222]                           for (restart in restarts) {
[08:25:54.222]                             name <- restart$name
[08:25:54.222]                             if (is.null(name)) 
[08:25:54.222]                               next
[08:25:54.222]                             if (!grepl(pattern, name)) 
[08:25:54.222]                               next
[08:25:54.222]                             invokeRestart(restart)
[08:25:54.222]                             muffled <- TRUE
[08:25:54.222]                             break
[08:25:54.222]                           }
[08:25:54.222]                         }
[08:25:54.222]                       }
[08:25:54.222]                       invisible(muffled)
[08:25:54.222]                     }
[08:25:54.222]                     muffleCondition(cond, pattern = "^muffle")
[08:25:54.222]                   }
[08:25:54.222]                 }
[08:25:54.222]                 else {
[08:25:54.222]                   if (TRUE) {
[08:25:54.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:25:54.222]                     {
[08:25:54.222]                       inherits <- base::inherits
[08:25:54.222]                       invokeRestart <- base::invokeRestart
[08:25:54.222]                       is.null <- base::is.null
[08:25:54.222]                       muffled <- FALSE
[08:25:54.222]                       if (inherits(cond, "message")) {
[08:25:54.222]                         muffled <- grepl(pattern, "muffleMessage")
[08:25:54.222]                         if (muffled) 
[08:25:54.222]                           invokeRestart("muffleMessage")
[08:25:54.222]                       }
[08:25:54.222]                       else if (inherits(cond, "warning")) {
[08:25:54.222]                         muffled <- grepl(pattern, "muffleWarning")
[08:25:54.222]                         if (muffled) 
[08:25:54.222]                           invokeRestart("muffleWarning")
[08:25:54.222]                       }
[08:25:54.222]                       else if (inherits(cond, "condition")) {
[08:25:54.222]                         if (!is.null(pattern)) {
[08:25:54.222]                           computeRestarts <- base::computeRestarts
[08:25:54.222]                           grepl <- base::grepl
[08:25:54.222]                           restarts <- computeRestarts(cond)
[08:25:54.222]                           for (restart in restarts) {
[08:25:54.222]                             name <- restart$name
[08:25:54.222]                             if (is.null(name)) 
[08:25:54.222]                               next
[08:25:54.222]                             if (!grepl(pattern, name)) 
[08:25:54.222]                               next
[08:25:54.222]                             invokeRestart(restart)
[08:25:54.222]                             muffled <- TRUE
[08:25:54.222]                             break
[08:25:54.222]                           }
[08:25:54.222]                         }
[08:25:54.222]                       }
[08:25:54.222]                       invisible(muffled)
[08:25:54.222]                     }
[08:25:54.222]                     muffleCondition(cond, pattern = "^muffle")
[08:25:54.222]                   }
[08:25:54.222]                 }
[08:25:54.222]             }
[08:25:54.222]         }))
[08:25:54.222]     }, error = function(ex) {
[08:25:54.222]         base::structure(base::list(value = NULL, visible = NULL, 
[08:25:54.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:25:54.222]                 ...future.rng), started = ...future.startTime, 
[08:25:54.222]             finished = Sys.time(), session_uuid = NA_character_, 
[08:25:54.222]             version = "1.8"), class = "FutureResult")
[08:25:54.222]     }, finally = {
[08:25:54.222]         if (!identical(...future.workdir, getwd())) 
[08:25:54.222]             setwd(...future.workdir)
[08:25:54.222]         {
[08:25:54.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:25:54.222]                 ...future.oldOptions$nwarnings <- NULL
[08:25:54.222]             }
[08:25:54.222]             base::options(...future.oldOptions)
[08:25:54.222]             if (.Platform$OS.type == "windows") {
[08:25:54.222]                 old_names <- names(...future.oldEnvVars)
[08:25:54.222]                 envs <- base::Sys.getenv()
[08:25:54.222]                 names <- names(envs)
[08:25:54.222]                 common <- intersect(names, old_names)
[08:25:54.222]                 added <- setdiff(names, old_names)
[08:25:54.222]                 removed <- setdiff(old_names, names)
[08:25:54.222]                 changed <- common[...future.oldEnvVars[common] != 
[08:25:54.222]                   envs[common]]
[08:25:54.222]                 NAMES <- toupper(changed)
[08:25:54.222]                 args <- list()
[08:25:54.222]                 for (kk in seq_along(NAMES)) {
[08:25:54.222]                   name <- changed[[kk]]
[08:25:54.222]                   NAME <- NAMES[[kk]]
[08:25:54.222]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.222]                     next
[08:25:54.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:54.222]                 }
[08:25:54.222]                 NAMES <- toupper(added)
[08:25:54.222]                 for (kk in seq_along(NAMES)) {
[08:25:54.222]                   name <- added[[kk]]
[08:25:54.222]                   NAME <- NAMES[[kk]]
[08:25:54.222]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.222]                     next
[08:25:54.222]                   args[[name]] <- ""
[08:25:54.222]                 }
[08:25:54.222]                 NAMES <- toupper(removed)
[08:25:54.222]                 for (kk in seq_along(NAMES)) {
[08:25:54.222]                   name <- removed[[kk]]
[08:25:54.222]                   NAME <- NAMES[[kk]]
[08:25:54.222]                   if (name != NAME && is.element(NAME, old_names)) 
[08:25:54.222]                     next
[08:25:54.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:25:54.222]                 }
[08:25:54.222]                 if (length(args) > 0) 
[08:25:54.222]                   base::do.call(base::Sys.setenv, args = args)
[08:25:54.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:25:54.222]             }
[08:25:54.222]             else {
[08:25:54.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:25:54.222]             }
[08:25:54.222]             {
[08:25:54.222]                 if (base::length(...future.futureOptionsAdded) > 
[08:25:54.222]                   0L) {
[08:25:54.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:25:54.222]                   base::names(opts) <- ...future.futureOptionsAdded
[08:25:54.222]                   base::options(opts)
[08:25:54.222]                 }
[08:25:54.222]                 {
[08:25:54.222]                   {
[08:25:54.222]                     base::options(mc.cores = ...future.mc.cores.old)
[08:25:54.222]                     NULL
[08:25:54.222]                   }
[08:25:54.222]                   options(future.plan = NULL)
[08:25:54.222]                   if (is.na(NA_character_)) 
[08:25:54.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:25:54.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:25:54.222]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:25:54.222]                     .init = FALSE)
[08:25:54.222]                 }
[08:25:54.222]             }
[08:25:54.222]         }
[08:25:54.222]     })
[08:25:54.222]     if (TRUE) {
[08:25:54.222]         base::sink(type = "output", split = FALSE)
[08:25:54.222]         if (TRUE) {
[08:25:54.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:25:54.222]         }
[08:25:54.222]         else {
[08:25:54.222]             ...future.result["stdout"] <- base::list(NULL)
[08:25:54.222]         }
[08:25:54.222]         base::close(...future.stdout)
[08:25:54.222]         ...future.stdout <- NULL
[08:25:54.222]     }
[08:25:54.222]     ...future.result$conditions <- ...future.conditions
[08:25:54.222]     ...future.result$finished <- base::Sys.time()
[08:25:54.222]     ...future.result
[08:25:54.222] }
[08:25:54.225] Exporting 5 global objects (800 bytes) to cluster node #2 ...
[08:25:54.225] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[08:25:54.228] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[08:25:54.229] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:25:54.229] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:25:54.229] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #2 ...
[08:25:54.230] Exporting ‘...future.elements_ii’ (97 bytes) to cluster node #2 ... DONE
[08:25:54.230] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:25:54.230] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:25:54.230] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:25:54.231] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:25:54.231] Exporting 5 global objects (800 bytes) to cluster node #2 ... DONE
[08:25:54.231] MultisessionFuture started
[08:25:54.231] - Launch lazy future ... done
[08:25:54.232] run() for ‘MultisessionFuture’ ... done
[08:25:54.232] Created future:
[08:25:54.232] MultisessionFuture:
[08:25:54.232] Label: ‘future_mapply-2’
[08:25:54.232] Expression:
[08:25:54.232] {
[08:25:54.232]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:25:54.232]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:25:54.232]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:25:54.232]         on.exit(options(oopts), add = TRUE)
[08:25:54.232]     }
[08:25:54.232]     {
[08:25:54.232]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:25:54.232]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:25:54.232]         do.call(mapply, args = args)
[08:25:54.232]     }
[08:25:54.232] }
[08:25:54.232] Lazy evaluation: FALSE
[08:25:54.232] Asynchronous evaluation: TRUE
[08:25:54.232] Local evaluation: TRUE
[08:25:54.232] Environment: R_GlobalEnv
[08:25:54.232] Capture standard output: TRUE
[08:25:54.232] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:25:54.232] Globals: 5 objects totaling 363 bytes (function ‘...future.FUN’ of 185 bytes, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 97 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:25:54.232] Packages: <none>
[08:25:54.232] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:25:54.232] Resolved: FALSE
[08:25:54.232] Value: <not collected>
[08:25:54.232] Conditions captured: <none>
[08:25:54.232] Early signaling: FALSE
[08:25:54.232] Owner process: 0d93d33d-aa41-2a86-b6c8-ed9693316c08
[08:25:54.232] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:25:54.243] Chunk #2 of 2 ... DONE
[08:25:54.244] Launching 2 futures (chunks) ... DONE
[08:25:54.244] Resolving 2 futures (chunks) ...
[08:25:54.244] resolve() on list ...
[08:25:54.244]  recursive: 0
[08:25:54.244]  length: 2
[08:25:54.244] 
[08:25:54.244] receiveMessageFromWorker() for ClusterFuture ...
[08:25:54.245] - Validating connection of MultisessionFuture
[08:25:54.245] - received message: FutureResult
[08:25:54.245] - Received FutureResult
[08:25:54.245] - Erased future from FutureRegistry
[08:25:54.245] result() for ClusterFuture ...
[08:25:54.245] - result already collected: FutureResult
[08:25:54.245] result() for ClusterFuture ... done
[08:25:54.245] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:54.245] Future #1
[08:25:54.246] result() for ClusterFuture ...
[08:25:54.246] - result already collected: FutureResult
[08:25:54.246] result() for ClusterFuture ... done
[08:25:54.246] result() for ClusterFuture ...
[08:25:54.246] - result already collected: FutureResult
[08:25:54.246] result() for ClusterFuture ... done
[08:25:54.246] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:25:54.246] - nx: 2
[08:25:54.246] - relay: TRUE
[08:25:54.246] - stdout: TRUE
[08:25:54.246] - signal: TRUE
[08:25:54.246] - resignal: FALSE
[08:25:54.247] - force: TRUE
[08:25:54.247] - relayed: [n=2] FALSE, FALSE
[08:25:54.247] - queued futures: [n=2] FALSE, FALSE
[08:25:54.247]  - until=1
[08:25:54.247]  - relaying element #1
[08:25:54.247] result() for ClusterFuture ...
[08:25:54.247] - result already collected: FutureResult
[08:25:54.247] result() for ClusterFuture ... done
[08:25:54.247] result() for ClusterFuture ...
[08:25:54.247] - result already collected: FutureResult
[08:25:54.247] result() for ClusterFuture ... done
[08:25:54.248] result() for ClusterFuture ...
[08:25:54.248] - result already collected: FutureResult
[08:25:54.248] result() for ClusterFuture ... done
[08:25:54.248] result() for ClusterFuture ...
[08:25:54.248] - result already collected: FutureResult
[08:25:54.248] result() for ClusterFuture ... done
[08:25:54.248] - relayed: [n=2] TRUE, FALSE
[08:25:54.248] - queued futures: [n=2] TRUE, FALSE
[08:25:54.248] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:25:54.248]  length: 1 (resolved future 1)
[08:25:54.273] receiveMessageFromWorker() for ClusterFuture ...
[08:25:54.273] - Validating connection of MultisessionFuture
[08:25:54.274] - received message: FutureResult
[08:25:54.274] - Received FutureResult
[08:25:54.274] - Erased future from FutureRegistry
[08:25:54.274] result() for ClusterFuture ...
[08:25:54.274] - result already collected: FutureResult
[08:25:54.274] result() for ClusterFuture ... done
[08:25:54.274] receiveMessageFromWorker() for ClusterFuture ... done
[08:25:54.274] Future #2
[08:25:54.274] result() for ClusterFuture ...
[08:25:54.274] - result already collected: FutureResult
[08:25:54.274] result() for ClusterFuture ... done
[08:25:54.275] result() for ClusterFuture ...
[08:25:54.275] - result already collected: FutureResult
[08:25:54.275] result() for ClusterFuture ... done
[08:25:54.275] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:25:54.275] - nx: 2
[08:25:54.275] - relay: TRUE
[08:25:54.275] - stdout: TRUE
[08:25:54.275] - signal: TRUE
[08:25:54.275] - resignal: FALSE
[08:25:54.275] - force: TRUE
[08:25:54.275] - relayed: [n=2] TRUE, FALSE
[08:25:54.276] - queued futures: [n=2] TRUE, FALSE
[08:25:54.276]  - until=2
[08:25:54.276]  - relaying element #2
[08:25:54.276] result() for ClusterFuture ...
[08:25:54.276] - result already collected: FutureResult
[08:25:54.276] result() for ClusterFuture ... done
[08:25:54.276] result() for ClusterFuture ...
[08:25:54.276] - result already collected: FutureResult
[08:25:54.276] result() for ClusterFuture ... done
[08:25:54.276] result() for ClusterFuture ...
[08:25:54.276] - result already collected: FutureResult
[08:25:54.277] result() for ClusterFuture ... done
[08:25:54.277] result() for ClusterFuture ...
[08:25:54.277] - result already collected: FutureResult
[08:25:54.277] result() for ClusterFuture ... done
[08:25:54.277] - relayed: [n=2] TRUE, TRUE
[08:25:54.277] - queued futures: [n=2] TRUE, TRUE
[08:25:54.277] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:25:54.277]  length: 0 (resolved future 2)
[08:25:54.277] Relaying remaining futures
[08:25:54.277] signalConditionsASAP(NULL, pos=0) ...
[08:25:54.277] - nx: 2
[08:25:54.277] - relay: TRUE
[08:25:54.278] - stdout: TRUE
[08:25:54.278] - signal: TRUE
[08:25:54.278] - resignal: FALSE
[08:25:54.278] - force: TRUE
[08:25:54.278] - relayed: [n=2] TRUE, TRUE
[08:25:54.278] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:25:54.278] - relayed: [n=2] TRUE, TRUE
[08:25:54.278] - queued futures: [n=2] TRUE, TRUE
[08:25:54.278] signalConditionsASAP(NULL, pos=0) ... done
[08:25:54.278] resolve() on list ... DONE
[08:25:54.278] result() for ClusterFuture ...
[08:25:54.278] - result already collected: FutureResult
[08:25:54.279] result() for ClusterFuture ... done
[08:25:54.279] result() for ClusterFuture ...
[08:25:54.279] - result already collected: FutureResult
[08:25:54.279] result() for ClusterFuture ... done
[08:25:54.279] result() for ClusterFuture ...
[08:25:54.279] - result already collected: FutureResult
[08:25:54.279] result() for ClusterFuture ... done
[08:25:54.279] result() for ClusterFuture ...
[08:25:54.279] - result already collected: FutureResult
[08:25:54.279] result() for ClusterFuture ... done
[08:25:54.279]  - Number of value chunks collected: 2
[08:25:54.280] Resolving 2 futures (chunks) ... DONE
[08:25:54.280] Reducing values from 2 chunks ...
[08:25:54.280]  - Number of values collected after concatenation: 2
[08:25:54.280]  - Number of values expected: 2
[08:25:54.280] Reducing values from 2 chunks ... DONE
[08:25:54.280] future_mapply() ... DONE
[08:25:54.280] plan(): Setting new future strategy stack:
[08:25:54.280] List of future strategies:
[08:25:54.280] 1. sequential:
[08:25:54.280]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:54.280]    - tweaked: FALSE
[08:25:54.280]    - call: plan(sequential)
[08:25:54.281] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[08:25:54.283] plan(): Setting new future strategy stack:
[08:25:54.283] List of future strategies:
[08:25:54.283] 1. FutureStrategy:
[08:25:54.283]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:25:54.283]    - tweaked: FALSE
[08:25:54.283]    - call: future::plan(oplan)
[08:25:54.284] plan(): nbrOfWorkers() = 1
> 
